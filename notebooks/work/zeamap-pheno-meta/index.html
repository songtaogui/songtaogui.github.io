<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9e8fea99faf1b669e0d9e04dac6564c095b9197c198b192c0cf445df7ddb3f4e37ec033ea5cf6fcebfcf9f9d82c3b4eaf7df6611d6329b7036c15652a1f2ca43f28ce088f639bbcd494601d24d9b8de78f41cbcc7e74f213239fd2400feecff842ab94925cd4967634a35b24908bf236cfb5c95f00c5c404446280e4db59867c257cac65478e1576b75591f283bb9ef952f86c5f30923fbd702b101d65e01193c88d85de8f278094aa1ec2df2a1a2903b28239e06f7caa7b5676f7f0f12366015cc2a98ba464d56d76d2e44b12a82fa54320835e257adf13e84a078581c8ceee0eff8765c223ce94cb5252d63672ce72b9021f48fe709c80e7935a3e762ae6d2aba01ef8ba256a827034c88c45aa6d7d9183bfe34c45bc07a46846d5b17b499abaa62a6f3727b4a62bea83fb5cac70b1b72818f5cab62365a864c7cc30c1d34d344de80df88e07bb1ecec71d4d039078fadbb8089bf01485fda25b1f9242108e423676f8f73ae5e98a3a5d727f34ea63ad9ba5cdc8e9ecb6b2fd0e330817524d22e0cc07ed7d5c8ae348b7c9c9c9a898c2c2499f46920a765ecf983d69f384d9fae49b6aece539a17448be258785af5b678d7b2c18e7f7ff2c3a78e0440bacb9d5cd05fab518235841c4c04226a095df77457b7dc2dad83b5fe88af4d96ffee3785486d0c2998fdf386209386713e352adb4c91555c2da2ef00b8b3f02d7ef3f7786d775a9d5070bd7d5c4bc1eb9dbeee489dfea4f7b62bb31e85f5b0b38c531811799a812a3f576de5dde996bd72c5a4202aa3fbc3837aa6d79f5fb6c8a0bcadf5a97bb9fb0f270471f45d2e57c39bb64c6591338765da6acf957fa25ab77e8740caac18bb6d22a9f276c1e0d7b71aceee32e3cba074228410a11b26f78027bb3cc77795c5a3b22b04a43714f963b8afe3cff1b9582bc5e6d286c9f804e58914f0b66b989e791a760a5da73f623dcbd0db03014263313756934f5045e8a03d5fbee27f180e4abe2484cdf048eb224da5206f06666d9f78b4082774ee387a273280f815e1b8fb14fde5653f7ae1a4996adf4ded2b5a771ad24698477832bd036ad956912b9db19f63dc56cc18329c61f1f1ca50a6645c0acaf04290e2712f1c7a7ca55a41889cf61594ecf93f8600fb732096b3f65101ab2d0189728acb16c1d2af1e97961cdd6a3da0c4579d983f47ef40f6da826a8c7217ddea0752478aaf028a1dd4cc15a15a98f0d4a5469a8ffb424e4ce3d61c1c6261d58357b0fdcd716c56e142708675a8566e7c21dd83fd48e0baebc58a3bbdfe1dc66e81101e2df28d1eee8b3e106cef33e48c744dc3ad708dd86972d98243cd5bb2d4f77a775da041ab2b41de2e988dc1c0aa10339f761eda648da4c6401e2d41903532524e120f6c761866e4029b958a29b62dc89b3e33df4e90f4e8d2b31f631d9d9e5b6310980b097866aa43af24e433a000a6780457c9be4a1a46356e4034ada0d6c6399192932eef5d2a6e6579fd1c30342808377dcd1a2ba73105278afc08ff657f38dd99aa6503e92b827c5d00965ae6004399e72b16a3592f5b2c2acf6847a0e0d84d969c80b683a03ec2eff1e4a67b42fc6d5fb4d46e89cf1ebc55ab75c99d48fdddde8a1c771ffdba16f5f48dc941606b3154692968ba5f77c43c9e0fa16433a50e9c1e68b4b6a2669ad99ce2ea15d1f8d0f65a8cd53213706bc842ea5be92ab3e3b84006ec3c3021d5adc70f6ae1d902e21731bf950b7223a634191c1f9d17089904b719be4e7021b9f8f4b2675023628d6cc5a096611b215810f3b634dcff16924af8fdc391b6ec6d0eb15e5bbc60bcab65ca833388705f6d84b238f3b392cd6373f3c7475f87bf63427132b46f7b84b627b2ff8bae3d9294170049a68fffe1c98e3c1adb7798c09478ca7ef72e57a339735b553d2c093a7f56ec98829ffe84f56244bb45ba187abf06a26295a798b2b4d7161bc28f0af16298d4eb2cf202b1bce49540316e1c8c1d94ecf32330dea85bda7018da4cafd808e995d2a3580bbb2fc6c6414d10394780f576ddd80790e0695ebd5d234ed3d1bca6850a3c5d411358a1702256a914cc717fb2c6a3b74fd5aa92f8085fb558481b767d903491fd32be9fbc838bdcb1acb5df7631a03ca3837de8c41d266608687d41872b5a35692bab911daf00297cc836c07e015869bb157179c6aa89c5f997181813f7d20812a70c7fcdc0ff52310d04e7aee91aec7eda093bcc1ddaa0802959c797e26a0de6b8099f2c2852396cece7a34c7b90cc27ce2ba072ef873d860d796602ac9c59ae4084eeac5983d813b35cf7162bcb3d97f1709acf3eb9cda79ea29ef6b2db5affa58b52936fa8c4f1233ff5cff29826904898c36c704a64e549ff8cdce7a45379d3063e44ae2f11a08bc73c73cdefe89af09a46fa3488f22ad54e7a5c5a5e8f95260770effc3862a6170e954f2ac2ff219418759cebf843c20ef87baabec6694ed85794544aa5c2cc686719f835beac10ba67489eb0c3db8debaeb522536cc976f2833f68a09f5638f84ddb36fcd167c91938be2c8024db8f6d2a99c60d8754d982204c82ba1426e80e8f68665b172b990f0207194dbce67fa01e7b5a3dc0818cf72d6964864264643f400be05d0cec77e1339f066e24232965fddfb3966e22c99f53705cd7b8acddfa4704514c76e0abaebbc4943559bcc076b61204f1382dd0c004723bebe640e9f21fbc894b539d0507839cb12053227dc2cfd1a48db6655d4312ea1f8064aa890c244ee80bb1ea2737fd435f7e7ed0032f448de8c28aed1a8c5c1d8314fb15008148f6ea77256c72793b7172af111f29865cb2e9746b782ed6fa7c921b6ece2d8a35798990a07d748607f363a0a3c994703aff4aa592d0c145e0fe09a32bc838a2e649d9d8199fe8faf0d4662497bd4a0a89e0220d92c5aea9d46f42086ee8515be5c88baa79dcdcfe98efdb0f437710572e0a9ca8abea352e455c8adc1699ad93d29a48a1c2763e61b98d73140751cf472dd78ec1f02a10ba9e015b95b501a0de6db3548584e25e8e8a7650a47fe8c88dee2ce1eb6c72a4f05a1aedbbd8518f6cd1d47157d87fd072d7513768636107575a2cebb562131ffddb1d16dc9e7fdf055baf7e85b1f5e79ccd0738966e3b12a0f5e1ce68e8d8f95ae0183d186b32ef96f4573c46dadae89534dd2ae9bff193e2ecf70dd41c4a0957747a8307587e729ae861c3fce64bafde6a1ae41744ce676c65601b8c4e838bec6bcafb1c1804f3bacad1d5cdee175c381697251c53c0ec77ca619eddbf9e95b75894c5fae5c1e8dcb45d49892ba97a1f838c464ab2fc686228101dfb83b25da477310d146eb325d3294715fb0d8c81fa66860bb7f65ef1fe4dfcf5209985749544364092c4c90a34ca83d3170e8a72525907df09334bd8af9fff1b4e222a2d047a9825f0c68358c3178b7fa678c8a3634cc3fa352604528a6ef0b0709833ad9ce0ec920952edb329728ffdc9b8b8c5b2b4aa9c6b68c4c6f7777eefd48e032f7d935207719a4ab38e5da3e288a3364d6ad0fd4dac817149c12ba85259fb349c414c896d26c1ed5a3975a582c71a6e3d47b4928069941920efc5f1c9fac4ce229db75a59f659fff65535d4629625b5330e2a52c5a3bd2c3d6e3ac02ae688584e3ef56b026a52609f8932c5e59d7ddb4e2d08d9f550c66afad2dfda8131e02b38488d9ef30c0e71e072b7337b57bb9ab9b188b921b3451ccf1c0b87c0db267e69754196181cc1aeb4fb59a5132a2e473636225ce924e5038c2749cb761b282b89b7ac1d1e18f926574f8e3fd55cea94bc70b8981b12d68e185885a1f5d8b7d6370736ec9cc3698769b793f8ebecce7c42db4f96e48b9e62cf6426819194d9cb15a0e2adf0e0af27788a53980d4e3e7d8f337843311ee4ae83b2431404688c944776c435a357c1b6099bb7da3fa94851ae65f23521bf530628a138f5ce5727c508eea4572c2fd0d25d1bd5e77019e05d55c23161ed5a7eccba09ff9bb866f4b04be6b303fbc4a27d671974a861635c861be8769a45be3fadc0d03ff1ae648b1adc072b53152821cc33b58f345c67b4fb752d6275aa2cd7a8008bdf9651d059248dde9864f4093f7680818f2c32841494a9e0c523743dc2b613c561ab4b48952e580023822d613d70de819b012b7eab3c664572bf3ca44b722bda71d6a10f11333abea7ee09786bdf7b83d41eb3f8d268de3bf0c613dd730210f79ae60fb05353abe94be3ea03b748c189b0e926eccabdbcc5343b7abfc78b022e2cfbe2c6f85bb4d1dfdb4ed1c4d5bd96d473de2e159444831581ae9b1742acf3c5bc126db8b3d143f1f3f6cd099b91ad9c0322576affdb5af4c19dc243b85382698701363bb65bb787f0ae3dcfc2a992d8afdc5ee2e849008363e569f41d3626580789f4fcc64d35ec6f7682ac5f8e05228be7824718543f4c5cdd7b0f36487419cbc132cbe13fdc7d275c57f65bf912315cd2b1869f132d66b1a4494e118a600c367d6d62b414e5ae9a4eabb70da82a300e0af79251dc371129603891f694f7847185c734fadb973d7d5e0160c7926148ce8aff43cf1f506925431c3c0798b1fbf45fca653c57f43c2f6350618913e520e03e7db447b45529862b0068bc71e883284d95ace42dc939da48774c63af2977f1f804e1a98038a74a5375dbe0dbe2c60ec94a68233e6828d186895d4e90af54d5e5162a417da3b5fe9df6211a13ffeaca74e92d191c420ccbc3c36ff0e3315bb8b025aa75fa5880f123d72cfc495ba718f64c5155728f03be87dcdf83812eb311e89fc8bf39df3aebf7cf9ac3f1876914c5ce977ba286bcf1958a7ce80593e8f55f05f169f3aa059b3a6d7b9358863700fa163d23f698a77241529fed46217f78f0b27472b3a704ab9dba682d18075938247b404dbe86c86d109c22e6458480caf333297850c41e7222044105a997ff3dc2a88af7c5959ab1eee1ba107d4405181bf6a2b2983fd5122f1cbe6f73349b7e718497d95766d66c7a699a5d61c6dce54c52ba97000833819e6650b2874c7a8e2b505e57c0e5aa71e7133a8d96ff57ee95e533363e07ce4d4a7d02efc0a33d16059ae10634d45089a14c60aa9cdfc2dd5e89f85a6c41297ca19c2604febf6c84e35a1f3685e5f623029a958bb0796860fa98e7c6340638740ae63bb631aedf3ccb8f14f41357b5b44c139e607f2236f631fcbd77130cff077f620087e490b71175e034468c311fe0e15d3f5aa527bdf948c457515410f27efde70bb12e986e25378fc7467b5b1068e48d22f2675c93c9eae186cea1facf5e079568b1eba4d40029c2111ac53508fe3d8434bd736d111d14ce2e54a0828707ecdab37fde6a30fdd9a3fb36da97e366bb84790e9b601b484c73c3d78007c0d697798b972d348dcf07e2db9ac6571c30dedd8e9534cf02065fc43b03774f30c944f613966fb18bd8306e337a80aa0c153c351161ec674704755d649c66fb840277d35d2f1f0c81119a2c2581705f83461dc4d0d5aa55eb44ff7df852644280279ce78133deedb1ab32b237799b411baaf7ce12be0845d287ce4861fb63aa5b83cdb462d76591699b08cfb3bce3be8f7165bcadaccc6fa0cf5ad3140d88545f6471a1cb07aeb4893fa6940fb65b14777ce76b9cfadd86c0d907cbbace83604d0fa8d482687c2021432be6a7180a81406fe722f01ae315ccc47fa3c205e23bb6beea1f9b9c34b20eb984b2f8985a79bec5b2dd047b02692d3666ecd65206eec357b59a1ab809090723f5c4cbefa9d7d592b0bed9d2e40f5a99860617ddb7a2a15b8ec9690feb43226c98fe124cee3a177757145356aea6f1b5423f54db59a989af90570f093c22f41b61cc35817aa8606aad431c787fb9d8bd8ef3bf2a7ec4d1b7b2b1bffe38edefa20917de44bb2fb83ee9982704d9894ebded91e4d54e95cdc248208b194248952185a3a819539b3b90fe2314bd94b3d4d6f4a92f4f7026e7ac82e54c0ca9801903b425cc66dcf999729a9b25415507fc9d0dbecc7af08302557183fc1dab7a3d6ca9caa1b3c91eea21f3dc02a44da9cc91e15aefab96e0d9e154bdf0fa13cb1ae776a5007355000b58f7bb82f32d9db5f5b9e5d9bf95a2c988755097283e8acb454705e1b2c617d5e2f724c427e3d3794988c60713ffb62a9433cc0a985571356768741996ec0b34c59bcecdaba184c10c2417b3b2fb257bf527cebc0a1bccb3071cdcc02f5373eda67508f630d869f399d80b33dd267bfeb8165b2e0e70bbbcdb55d1acb256f0ffb334ad08f737a322d2bc538e97728a594d6b9ac7e92cac369f059fdadb128062ad0d2ea15675891eb96e817c84a989081e0946217289abacd56d83544f669bb3de3daab261edb58a24dc2912c58e48e88373778f6c43b398f840bcadad3c61a82b584ea933b1ac8135b2d4c5a84c2b5fea660fce99cfcb84693f5442e08d2c82d9c0b3510bf95da6beaedef78a3de008306a13ff0f1d12d9f0c122f1e218ea585c269ca18a0e266ce36269fec1a95f7cae209736c44d1cbfd7803280fcc09bc25ba11b62dd1f5df326364de8b378a6e5a34368d6108682287b1fcc6abd2848389e9e6f8b2d02725a4c883d44ee84edeb0baf3f5c50b886586e59b1c18bc40693760a6127360488590c1e15d59195e4dfd47bbe1fb7bd116f6f8661b0b7045772c1f929723699a232e6265b61651bc732f50fa975262c56ae2ce3a759b2fe825dbcb001db6eb047b28c0b154973f5331f3154eb3a0e6d2f6d87dbe7b82acc0b0675b32ed69112e854d231ed8d3949572fc0749d4aad9977e40894e2457ee1fec6f265ad44b5734a492add08f1df6fd3783d2bb8b3af11ae20d5b680b0223e26197c6a6d4c4f6ee103435202ab04e8916011b30d2b61aedf75063be96a309c313180423839edf1844e4974e6d76788f5c9d582667f388676d2c59de1f97370d079f51377f3a2f9431b739e9742e2fbce95b6e6bbd2b20a041f34db13024cbb3da4391d63513a7fc3bca3acc254d9da56590a534073b59408c568f002346ac045cb0aabcdd3891eb9bf54f4e8933fde3f5c3ab4a2def12573b9d97f832eb106873289086b2a90854ad3d74d58e30dbe93dcb735d8bf51f73038c5f80c47354b8020dbc0d0d71e0e49e846af4e8c5c7bfa9cc1f0c590a02c17e014649dea0fb5e34cc224e4c642b12df0b10ac9597aaf6e28f9ac143a7019f3d76449f29da27de204ec3e0beeecdda4144bcc7ceced6e9eb0e7cd62ca17ed0cf5d68fc2e1852b949309df01fefc3915215b1753d27b907ed398aa6720b654109186a70d009f7d9d281be73f0d0491ced636cdff2fbc8eabe6871b731e4687aa7e1a1299b2e8a51b1571a71ec6bc0aaa7323cc0543c4a6ad12aa6a5a880d1e444765c707ccc69c297088ce062b06e11fb76e7bb13b15fd5cc67121626b04d3152f870afe3a092def8e631701a554afb5ed2385922cf4362072d0a101a3832a936c917ee3cabf9009b4419eafc6769fedb88a9f8738e867902a98e85d0fa4d904a5ac38e29d643c7f4c663a2c34ca69fea9f5de5189d2b42158b7a92da20f8cce35c4a20956f02dd1106809d1f6bc313b01116afbb479a86e517ee4b1ad477bd0a91cebe710ebe0323858be2f87ae54b7bf39f96c173a80854dde10955a710d8c2fa3967a07c80afc6444f2c1bcb8581b04510fa9ba22042c351385071cad9834270bfb09ebf82ddeebf655fbe1ed9edb05ca4e7144ff8063f6ab54d7236ede61e4b23f7b0f917c331ea10bbb317737eae8ee56ad140e66f20cf6491fc1ed8405f9aa26b5ac36fc78f7c2887d095117caccee6ee133434412a864f94f636fc48203fb896432b50f9cd63873ab14e85648f44c3bf5bdc07d6fe32040d9cbd43e6e5d3efa2251e21671f9c62836003ca2296fc1eaf997f0e64518906c968f3d5ddcb2e5a7ce9e55a5144affc86c9c04cb46dcbd37f1433c5afd53647de0ec8df2ee53a46fbf2c61737a1c9c7cc91d0e3ed35da2b59e927aa709420fc466a6f8c997aa9a3a1f7fe604cb108fd34d9d1da00d970c2c6add72918c08fdc4b99bf8780150a2fbf31c479e2b19f7a47ba7e11076965e1c2c0cee6f5da014d23f2a91f2862ac6e7f2fa9a94b588388224b69de70c9bbfa0bddf31a7e72879f9bf0429f5d381cbc5799c5c2cade7cd166757b66cab7da33f3755e226eb8b8e69f8868c628e6a3ade32f9069d0deb7bf7c425a00602f18e65bcfc1b047bb2f31b7f2ee010080a80169514dfabe5ec3a78b3acae941fc6173cc86d115a54f30015352872febb0db4bfd0deabd6851cf412b7b2cc714d47d8a8cd121fd8656d032b82fbeaa08219209fc25334a40faba1480a18d8b905ddecb4df844e320554fe1e3edc1ad3d43071e07b419a1a8a8b534e90b01c7636bbb50dc831ffd56a5184bb029cd1230c0c058291a9bbb9827d0598ab9ddb3989f3e353211365d8c93aec0acf6f83dfaf326bc389b7625fb66bf8ad44f35e9ad1d4b54cf7538466c2eefe4fb6df88ed47c248c4d82436d40270c63860b4949fff50c9ce7d18ff05e69a48fd290cd25d73e27bacf6209a75e3d261159447b8c4f63f3df6db1c3dc9425758f64002cd16d0200745d0454c6f35840d596e5558b72410db6b5efeae872fd26ed0a58fc3b21d3f18d411636ddce238690a0073cb996bf2b221e38e0be600b486ece21d16268d5904b90466b58a6afdd3fb9c8fa90987acd06ddbfebe206595bd0c5bf140ae8ac31365293ef017dba78a10c4d2458819d784420532335b927725b27d05c71bb00a922251ecef58c9453258a28a27913bb10566f8726edd3377997ad0ad97a4cd2a7694efd02abde64771ce9d01e0ff67bd10852b4c41f075fdfd3157ead5c614f9c4114ce45e3b2022a6c977050b37225d923f41e5a7a9aabcf7bfe7c8788a80cf0960d4c4ad2f5d9a44c939482d5a55eabb5cf3bd970f04d83ce3d9860a95c8835ae9a090a998289b20790f468ef6c97cfc06b1260a0693fbeacaa32cb608ffbcd54d581ab4edbaa281a8168087636adea35545bc8e5612f317c291a93e8058a61e74ffde40b7f315b4baffcfd2c9138a358795ae26bd9db01273e021bb18c90a42487c9b3087c3f5a4cb16148dca4c675f27325f2614396eba4a6ed9b6dfebd5f1be9403a3ef2786a64e235062aa1713fd48811b4477af088af47f13d749882133c9335309543f130bea74b1778ca98b0643348e1a327d00f65c2efbc0549fbb74c8f6f230edebbacd422cf12bdf86c332d283f43cb2d726f4f6130c5fb60dbc950fd0bb8fb1eed2f3c9255379e7bbbd675094438ed41920e8094a88229520b750a323858a2aeed2d2a3656120059875800a6774de5a8fb1502c61476640c9dd771da15277c06e4421a2b01c9e6e4a354fc704eb23206561be53b7c7691c9173639860b6cea6df8516fe9a23414fae137fb6ce86bf337de8ed21e61d1ba7954a1e232cb8a42e3c82281c1731df3315662388382a6e2c79c74a64b9798f0cee9716e7e99d7427588976cbad517dd98bd798ad0d0bf5a9ed0c7a163df19c37cfdc02cad6d56e2971dfea52986c4a1916369f5572116a54a6b4f16019200fe1bfb93d302c7bcc7a2e3054cc0f6585552fde049edebeb01c38c73fb24dbf9fddbcd25eb1e3d8a40d22f4ca7fb8f89aec13e5ad28023638c246ae79b56bf0c791c394d63a4f02c655caf50655b9d23b177def00d095af13eb6f4a84963eaa4048751b191c5d0117497638a30ae4d00f9fc253e9206acddecfabcc676b5bdb1c9e4e7ea811c6b81f1ac57a72986b7269e2266b2b6cf5e0a20e22641899773d29004a5294969f1fcb802367722bc0dae12a563dafabe30fff0edc1696992707951d8e8e2580ececab5168e0beb7bdbbcc8a9dd7c5dcfbfb4ccf22257c9f29803bc83ab00fca8f1ee26e21122109a1464364e08f6a572458ebce57fe6226368841cbbb52923aa52de3c49462d1de2e96ce2cf0cc4651d7e8f8a30bfad6f040644f747707f419700f0c02fb4f10582e83c9d9e6021cf9d02a46af73207e9861ace80bd181351a6269054046863b824d21e88c3f26a4c42690f8bf1f729b76b136c6de310ecb59a5e35e0e16cf01290b2d4f7fa308f40c89aee3f80fb7648e5d429f2e2c9dc63cda0180877797fd283262d1f152a2fcb0979f03ab4c17573661a79e64ba7ada78027a599af2dee87c9c8e3dcf6e06464aa919a2e044f0d08d2d7c8dabf45360a0161398c53ae49be6a7bafb85a67e59108e727f189c062ba5308376ef37b20daa52ca16434dd72cd28af53d6a131dc1554c282dd49a15fbe669a219b3880ad1134fc7ee0120070358670d9f674e365159251e7445b2608a73c4acba7f6bac8fc9470d6d538c152ed0a9b68a7cb8f7f21f8be9fd27abceea8429ff29c3b9cbb27dc5952d36b8a8970211f4ca6bb8596a9235c24bf94a19a5b0f4798657b7e954f790681525cba017e3040f4876296aa8a380cac329232efa414e8b6e9c7b5db0dce9e35a114b5e2c21a88539bc21a6573c6459e055a119c29ee5ae99ba2ba7d95fd88d6758c6763612a69596269c8ab0d0c1e5b1c04a754ef69b05ded70af7c5d0f3adb98d1d5dad4516c544dd78edf8e2df6f599304f9691fc45cf27e2d68196493d5ca21be352cbf9bfa31e6769d39e2a232bdacda7ea8086b99b69e624ad25bd9a38c12eca93b8dcff73e1716a5afc0722f35f42a884e432865bd4ce510a15845c1c70b1c80b0761ca664444008fe5bf67e1f0987235030b4a8b7257c1d3c781a442f8debdddfe5fd23d635f3a119bd9328d4662bb90a16c94f021d9dd4620ff75564a20a154b4fe52f23f3f2d6288132ee2df1d667ede792b8f7d552a849bbc2fea17a7231b94bd054af298f76d2e9263b74346f18c8c0295e5a9180cb897741272ae4231892e813ad0244b9019c3fafe8fda742319f709a125d728053215238cf567df884842341954a6c1c72d485c991e19e89429ce17a84f3f7fead5080fe7ef56c7b35ef289aef5b85a50cd953059487c0052a7e52118e9025a5864ae6385af37554f9043fd9ee26f4906aeb39635d0c98e7ec4de072de6d4433bbf51397a65cf2b0b0743ce340bcc0de6755af47bb02edb0c3671b005f92859cd4372f32229887c7e4cbf599ea96b83f97ba2e15f4a0dfa4051bdc5dfaff2fdc09d69be28516d9b608ba0045757df9a306cf613b144f21c58538c9076877237f006f10714c0313cc2035bba5dba61f99ba017870c4cbba05603a1de99a8afdf5ceb539e2665736c416278bcd10491141af1304d09afb7f014aea11b496a309ded67f17079c76e9b083df7ea586c4c6ab4565b5b8a3b02361b185b830c21d65313c730a4af3dc43ffb55a7888b389652f9fd1fa849cb32072b94dc46728304d81c95c1ef6e5cd02c7ed8a9e668e954aa01c0103c2b5fd0c87f139d92ee3608d892b9c850ea5966a87e2ab0ef7734c8b8b64674f1f911b4ee347d22de15a709696ced18dd0dbcca7786b4ef8e3b095c7af4619799a680adea9bd0047062f35a3887a5ff034a3bb6f854a55efdfd7002b448a93f9b41971290685f109f311fe21958c2e1ceafb7dd52d44fefecccdc7007bf3b51b7434c3e2d1c4c2c8d091d43bf7c4ff89f14d3ab74469897aac7e0052fdd0a93aec9835a3d0157cf73dc2f1ac7075cba71c9a2a5f4864fe44a9ccbaf3a52ce30a3f3fe5fc53d1507db9a74c11e01a40159498912de5507feb3dd4fa0cb1258982d513b73dab61b4592b1e7d4d5a7564b9af60eab63179f570cb53b3c02392f430ea7824608ea4b38f4ca21503d70a24fec0fb0ea965cdfc8d01a28554bb1e4cd10a37731b3adc361d7eac96e5ae4c2c7063128a98226f0b6aa3a0253eefa57177744b902e3a018c5de872797381950ac26ec5375ac7b6472f97120c2e859a13a763b0dd10a89f91c9d011051107ae40ef0ef2f395e43b5ce8baa86e4ff1d9dcb384c82d2b2ee41f80eb12b1e091288b8228021f84123942f0e69af19d66687748a34319b73ca2ce83b928f33e18b9cf51e88805351942687532fb5d0a4a95e00b2f26c4104355708b335f8ea8fe8b2cd504c179dfbd650b522c0033834dbbc5c599e871eb717c3a6c60bb249a4fc9202ec5bd76cfa9d0d1c093ceeb37d07a53d57efcb197bb8653435be5e4f657fd77a0216bd61b9f1f3ac0ed4c41c03e2b7b5e272092f2ba1d97c04a4ab7ba565f15d75d5447f4008d636da8b6058e16d0be67f61d5b5ad167db96f5a28b30f817027f32373384a0cc9de0a6fdf5e9fee87862a97ac49eeee729892456f73d85524bce1c42f0fff888d15f9933da24ec0a745cdf84bde5d7d237b54da35998b0cb228b7d99f9cc63847d353caaf7d78b0b034d87e0897327a3cacd4aa50d9e9a01958343ec09ffa17f2d8d2e309c311ca151b8c63cdfdcd01c0487b7ee5989aed08056f667f99a5980599a5aeeafe91d25664decc4c61f0a90d04ae1566fd8241e9ba3a83fad290a2a444804c2b175fa5e3e093cc4eb38f25bd121c70d106b706f41087f62fa6fa73be2d306a5f363158b19ce172430951ee3e18b59d927725b61f7ef1ca59eb50db3b2bf5c2cbf2eab54173938aa80783aef764d1506eac2425cf4e42bf23d10e1ad18520428061954d0d1cd6e0dc1d7973138f279a664403f7b3f6e79a95fd1d319d4502f7913a6c1ad75afe3a076300b6c78668ca3e74fa5d47fd1fb7eb0ddd9d5c64db5159a9d0285112d7af06554f05bc52f5cf01e8d10f1183f1f3fb081a2706e57f0b8ad32b0671b314f10988f3c4790f4160c90d01134f9b7b083662b0c7de1e0f48ae0a7e3681caf1909cf9b568b947a28132b5fd7c40b92f1d413c423571a2b6fa4e7144052b09eabd336fd1f1151065f594ca1548492201856524c024207ce6d8c6959c01245ebaa152519da6f888c2b43b8d74302e3e59e5a35b901da2adedeff35a636eebe3fa0f5252c42bd929d8abfe94d5c98630648a5afbfd7412787fdc35395edaa29f56524bffdb245737f56975d49a3d00744ce9c0494bce1f9a9c1b0041ebbe4c30eecfd917c1be0a2d8f301062fb68ad530fedd13f799bea8a100dbc9733cbc16d3a92ec3f75aa808c04ed2f40660e911d4b74a55ab4c5b98dd0f8c3d0bbbbbd329f363dabac13756df45c8ae22b9d2890f3943173a0d04d3bf0e6d1ccfe2219054d9a45a19416a00bf02590e81ee4f12949e124f1aed7436f0beba1819b6019c416ecc0181d3b7f52989f4e9484824f1a87ded592620d97d6f08f208d650225c1ffb35a7ee2dc4df8dac56ba8c1b5da986e589c3acf3ba3827f8ca4323fb1abb957928300590aeda42a00bb299b06ed60a50a61bcf207e1552b8f217e30edfab49b20bc5a947b8cca6903ebc413d193dd9cf7a43e6023aab34345ca443b47549e9e9a2869d6472c1d9f821b8ad995210fd533263efa19681395aa0401bd41bad75abccb78d8b85d235f3fd596ea2e7bf235d97920936b982ef2a09b1d8bb20f0e93b44a32fa3f6bdbffbbb3d924d4b5079467dab99f5702035631032f3d42cd43d81e7c5a226143aa8b52f9d8de5caf3bdac2c5653c13133989625e567572b335731cfc9ac5e20367dce54fdc110279cfc9c57347ee068f15c9574abf22d2ab3c1317d003e5373d16a03ce03e071aa9225987440a0e49346ce3d6cf4471f4c2bccd9ec57e6460d96fd89b7fc5aa423d2abe983b8625b502dc6954711ea9a0c4b64bcf061e176160a5373cf7d83c0a8fd75cd05c58a2f8476fd4f29f663a973c268db9e0a09099141feb820958b128742311021775891295bb4099cbaaaf17095e5d02759bab0068caefbd8046ff9b6992dff1f92abf850ad3bb01a26c91710f12ac80dc089eba81675f5c0ed3ff3770c54a78bc61784a6359d2a6332cf6d2e95c4ed601a602ea460a29ca66e6d2bd0d28e134e00836d7aa53b312198d1998819d526e3deae6b4994fcafe884a7b0a1df7d29cb30555160406416a146a5ba1030bb9b6ef92bf7213a4887ebf4636229d06c847f7e8d929649afc87e3a77764c8eab313e1c0660b7340f42d1600315bcae81afaf9ff63d051a6c9dea9804b8d7fa8328cd7da8a4aefb989360a3e3dba75c94afa8e9bd18bda9993851306b90fcc86a44daf24e323f48301b6681928c23da1c30b7112b480865be291f7bcb0a08adecf6bd7f4f2432d8cfc36c050dd872a7cdb0db3986b5c937c9473262ee56b2408e5b2f7a44add1fd5dd5e0953c294083d2a0be9faecfc264cfd0aedd296876bb67b7cc84f5dbf13c2cb2722c4a039a5f18f3cf4c35960243d66f3ec777aaed408a84ee02866bff028f6575b1b1d3a53dede18c4cbb98132b9b5f6b4c9c8bf59b475442f0d418c0a6373601d29090763e36a769326f13bd05bffbcae283c9b53bbc559c9782caa44c1a48adebe3cde883bbfd253599d4aadcfb4f80e875bdcc6a02aa739dcfc2bda9a9b94983e3b9c3867f25e2b0d59b564229293047c1e597d36664a9c7670a4a136a2b6b9132131a7011a6895213e9e27fac910546059ce2a4baabd28ec9c451cca4542cd67984c95c82ac690cd9587d153d6a48c53c83c4e97a327b6145889a466886beeba8081f9ea1a38d6cc277a5334efeb360154a98770188334d93ef1fd679cc8c834cb61926992c7592271e89ba1e9ef2ed860373f493a7519ccced339f28d9ec3f78f9ca2549cf4ab2af942061a81ba72911653688e557ae52822381c5f2235a0dc5afb25dcc59cbb3d3d77e4129de02451a5fe8175f338e6b51fe5235101e1698595ec8f9c54876ae01eb0cd920aa1f6e42d67ce143954a378118b0be914042e71c4f686e5596d1ec6c5ac6dbe2b4cbe1c23c5eb1f0594bcd988619d85bd764bea1c289726edf77721fd57b85a3a565148c0b6b68b31f0a006aa595f58c94f21b5994a6a70c4c7eb29ce6a51a890857289cd2438707c76dbe88a156288c3e6db0b34db61489d328b7f511a81847a3c4506309aed1b0aa2a59bddcebad01981a33f6ac76aeac32ccff0117668475c6a9db8ef865f795d5200b6d06e23a9b899960536b8cf06a4e22cdedbb277e06fac7830b92cff023051c5b865957861771dc82cdd134f352388d3dabe5d4e6fcb8763e14ed582a4c4333af3ad9ae266a63780eb956174e60ad6813a30881747ede6944aaf128fd02b4adac4ce0b75a138e38b0d9ea93989e6f282e2be1670a96de8a2fd7f1d51e3745d75b3bfb4dc6b2da0eaf4ecb0b3b96233dab72d528ea433f6da9658d899aa998385b3e7d474cfb59a36357b6b87b4eb00639a3579301625ff10d0584a1dbe2953ab3b42b914549db58d153767a2c6001c4f716fcb354bf86d7d13b9a33857bd5871fc2b62c67cbc877268eed7f694713664d4de122bb9b89526cdf25da903375bc98db7afae20e685172ffae2d1b78a1cafa732045f6ba54c8615aee5348afca59e5d22f372216b0ee029a5618c85566392932582bad565f9700eb5705de495b30b1dda3fe56d54a41ebaac8d68cb3e737dc1415eb39c5c1c8a85fbb72321fbc53fee9cf27fdcfd72c59cce45ee2ff8c290869c0356c6b6664d11b9621ed31f225d60966e238d8af1116556a88a5cf5396f1411354970136cf95f03443fd398eebe000dae8e853141381037860341cfaee66bdcf43dab7986971d38f0ba25ac512c24275d4665232b0e13faad47166fca6ebd599b8cdcea3fd9db825d5d125d907db3f493951694e88b81c02a50fa3435622c9aaed832a1adc80459236ebde2097a7520e06658aedfa159525e242b63e7592bf274ab919c84e326984745f0e3a0d64e628e6053b4854ce2287fad183d1a302a6d5b82bae36fa9d8d635741ef88bcd528c9db15e259c195640ba9c06f67860b40b5a6c0266fba3da26ff4f5af8b3e187cb39f8d05f7e09c171a5592ec8da9a66127d820071d85454ba874a589c3a2c496a486d4feb33e9baa59a9c7b8dcd63203580cc15b296493ef93b5de1632ec1e955c28b8fb24d8e7efa84d9da56f40db291523a0c4256dd74aacbc42c74551c5385e53681d61ea70d2245b3406b37bd29077c80119f4d424e4db8fe0187abf6c4e115762b0f2d3468765cdc0042f2685d658cd399dbf05ed473ef249d281f79d5e69922fe59a4c7c409ea0a1114533689205fa82a0621327899074e0a3f6b7fc4eff90c1a385cd26290686b25d55b990eea068b6bab0fb2cb00eb0df734f7fbceabe21657a462089a9829b6388838593fc61fb83ce3b93cedf8992994ebd257c06c0cfdaf4ef53aae3250dafeb19aa7f392d6f31f9f63d7665fd7814f0a090945fa8e557f537ed74e44a39d1fea77ee0141fcbda8207d91bf09ea7b661608f7fa926599acb456e7b845422bb5eba07e9151b7ce4f221567e1d257633e66d56ee1ca9cf48757ec72709a9d70ddb9620b3e91d96f66dfb246dcea77b0793957d3e9b6271a64ff0b0cd3cdebbadeeb5c10fc6e0dccefb36a0f06cadb97fe42205e3b46c0f889c8f491cba78551d9b0954bb74ea59bdbc831df7b04fd2b0c9319a38d3fd6ce609a4028f5b22ace317faecddbc57db0d93ec7d574a0c18997a1895ce8eb99dac9012fd329ea3653960181ae8d573ae9ef42aac2fa80a1d7a3df2ac5de39a6ee3b9e06c9d7fa2289bb7e009f9ee161dfbca98941f06cedcd2586fcc6e04a4b09f27f61ef5ebf933708b4eb77bc6425c96d969235136acb4caeaf2fc86c3bbbcc85e16f108a7f9320881f74b705f98ceadaf9a93736c1c650bf478ab16d61f84c1c0dc0f66c354888c87a06d06560e317ccd214a38ee7b6601aa0f4830727719c63abb8fe60bded7056cadaa7f24be3e7d63efaf2f665b514ddce5d59a663b81e9902ced98d2eaeb1ed885f9b30a1aba59fdd880bd81cf71ea6633d8e7c882702987cb60349733ca7946daf8cc5ad92ff3dcf5ebf2664880141ec91b8644ee860f6d35f3391abb724f3ef13c75eed5ce6c67e94856c59b2c3ea2efcdbb308eb1262bea34b595ccd408ece450b4622d827546f86acf9f41bb971e5226a9ce70c489a99540eefcc07ff1916b559613fad782d8ce148c30cef457acfe7591832201816aaeae33e0a6a30f692e7e9815425d3cb88729fd602f2937ae0a209fd1122caa7167f408e87aaffe12589c5078c77f6e09243d523f1de6ecdc1494fe00eb8f5d08cf9be5e6946c06093515a15e62d187e3526535407d1f8fd122a2b6506773f2d08747f7aec0c9f580326b91326bb715aafa2bb624ff72764ce93cb4f3a8bff003643dd1830519a563ca7b83bd3368c655ad2c450c7ad15052b52904812dffb2980d406588e7e38c2eab2cbbf2328a53b88184a4ec204934f4aa079c9c0932ba1a2a352954772ddd748c65c1b289838314955b68417c4281a59d383bef54771f1324eb8757038a4f9721f65191c7fbfc286bf18f6177cba5b8dd866e0da590fa1ed8965ba3d06081cce61e37e5cbb67d80bdb838098ebd3380ce1c771274e12cde392720d1a86ab287c638db3023f0ada339bcb3648bd94d9a5ea759698ea81d4375ad1fa0f87d5a34a01a18491e35f9422739b33ce73aee0286e9659199fe9cde2ccc44d822cb1ae8ec1390460fffae876160748f9c1500404b680288731a2457169c16ac765c6c0d9a0dac5f3e191353431e9bf3a09b627ae4611772f15bda621365fe00d4422b6f20cdb8056fc02c3f83b2ee2dc5c10aab193dc14209c33842ec22597bff3c3d9e2fc63e60a76dbcd0a482b90f33c8fb4dcc75ceb8391fc2889949b6992b5db9f7da8b39dc35d77d32dc92119e8c7d9c64875c02472ad7f355ba031ea04ddb2f96fff5c44dff4f15094aaef6937548a9680c3f4fe51e024dbc18424819225f6ef0f0f57039bf844db194cc9c6f703381195f59cf67fec7134eef3822a3653df99864c6aa5d5eb2020c165271a2fb757d32037f400d53a7006d1e6ed24344eefbcdf537d0b7f26bb74e84b4bf03aeaf315291a91d85aa065432a7847c890e47aa29270fac5f269758c933df5a49fc48420f8b98f6a55d0cc8ff97cddcdf049fac69932c18396ce3b48157013b678f6b042846089aea44fb20b8620d1c6a9bb0c3a0adc5d6b244a35795de36aeadb07e05c9fbc6fa40f8219fa30c424cab42701576fb2b3bfd27e40c2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
