<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"387c5be50bb041034ef9c1495ea0bd615d9571b4d22372c2dc52d7e07c1af128bf739710a490b190887ea35e94f2c90b37769c7ec57f9fed346a1321981443329d5d9001bf59348f930e67543c6855a7184c6f4094bcfeeaf683f5a532e207f0c6aba21f84539be149935b9cb0126ad31e544926c086b3c16577167928868b44fa625455d7f7aa745cbc49cda7bf03a50415e6a1d5232c158c1458e5151be64abb2ffbafb284894dcb5dee3df8d87c780c959869acf698e574f33415a8bd9c7941929f97a79b5629113a94ef823abbea2b9a7892974ad8035500441fc647d0ba740f6890b15258f4bc6942a324413a5f033aa2b0722b03cf1c4443df9ca69d577daba8bf5163725336409c5cd666fa06ad7ab8c8ccb52df27d112c6e25106b87d4912f7280b3ef749a987c354d6dd74932ec3f129977ce30e98a386362dcc9fe3d10eb9e6cc1a30962ef1ae1705fef96b89887ba6ab1f34831396f8cbeb946479b5d483dc1c501701b0a94a150d2ffe1639d910d9114a167b6953c9e549f0b20507daa280f38115937c2442a33782d9e2557268097e8c92c190414542cc3721adda83aad294c8ea3711ab708313fddaec2037324fa54a391f0db6ed8d10c117dce7cb58b8dc8af9616b56329c9742d4f25d71969e6835eb706a38fc185b66cd811ac5581872ce88a465e2fd476e6399a1f790657a970d8f7036f0547073c8f508e1d22e647035ec1d5f8194b05b366348c347c5dd850441c68bc9143263f8ff31b02dfe026c80327971b809e8df9f8f6b84a69857f74e6cb2506c208d959f406600dafe5f1a593eb7fbf0086e566b39192e88eb3058547023b841b0447f183f92ba9e5aa25d4729e9180abaed56eed709076aa634e8bb36b20f5881a929691d535ecd33d44d8b53d4894459c673cb9b1995c1dfc59b6a5946367f512a31260d35bf96224e31fceaf9ae92b315e93f923a61ce2c9546f5e994ca7fc4fae9b8389bbaaee80211bed869d0b1a51f0d6382809294636cdbeddf83973cfec46a2a2639556f9f2c51a52c6b6958094c2859a5641bd841d0f47cf1ffa8e8233fcd8a3bae0a9b746a03de450a3dd76aa44784748f6b0ddfe4132e166517ec8f39a6f5dd6da9da09a5bdcc2957b1d5c0174a0b24d473d5598ad51659b90cd847b529d5af1d72de49a48fa6f7f2c62cbcef102ee7744e712bc3c8a0f007160bbbac54e5dfb260fd15c1f6508082637325d795d33ba41f02c32eb8be0592bd4f0b68ecc76adb8e7c1a7ba0f4ec1d807a64c2cd13a734cf9cc9ca655a2f57ba7be234ef087a091b6c4b14dc03bc1b40f70c34b57e60a7e469b0ad80ac031cc52ae0788d82e1f0c908b8ed7b55f4e853cc9f9d1cfbef4da9834d6e75c45e987a282b00384de39bca2e898b883b7da0483a24f8114db5bb4a55d8bdb3ccdc099682d4418c5849d033d919c5bf9ba35639917465bce42c7f461c477b39d68599944699ece6702c8c3ac57b084d702684e5fc104effabd06823143c80b9e8dd35037a2af79c0ad3447725cd55523d1dabd4ea8e261f882d06e655fd4acf93c0969b7cd1fb70da3f21b819ff310027f5ae25f075f5e342e8d05f9c81df92b85a5f30311dbdb6de91997918132452c7c2b4135fb973a817772f9a8aebc051457397c065c34d7423c2e70f17c1e6ab81e0b308629643cc27384945dd1e188527b221eb6b2a3ce3ffccdd8dd232e7f696445eaf2797d42d782b708b27585c06b2ce916d04787f6f442daf9fdbec0241965e7e5be13ffe7bbc68af5d22e18da536579de99a0ab450219143c963db4e59f7ae027ce2a233aec470609011e94fb563b8f134395e5ccb8bb960b31d0ded3a987f695b17123377cb9a3f6817b0e6a4fe8aef99c395824e5e525b7e6bb04f5684407553d1524be66e54c069fef08f0b94d732f65ac8c21660db49fedbd24dec522c131cf7c70743479b055c7a3b78e232c87c24d4115c7ae39bf9485e7149191cb97682bca29fed69adb9f038b6bbeff71779db90be6e91de194f10116c636b6922f4076000dc6018cef35c48f197dfe2e518d6b7546289cdb80f1a075a43e725ef2e2fbc59e237222b24dcb5da3ff77e56b6de065bd4ea2bad3ef19da9c0d4771b29d4384cf28c148b2ad1742b1483760ebdfea8e0b7f2a72dd646a0361bce051cd845c3893cf7c7594fb37640af7fc42adb67fc4375a3dacd1fd244b0b450c17fae6c140982a76ab164cdfb396e8dce60c4645b2f2151f7ea9ec465efdc86617b0856f1bf96c16aaec03e3a3614ce6f79e18899824e7f8c3994dd973f95a91e32b425aaf132c3c9c89c90ff1f0cfb95211293e96ad4b81b76d0c53b0cd043b83eb89baf4c167f8e5c4f1bcde371473739ffbd0a9c255ab690b68fa1d6a67716bcaeb37a775474c8d5014e420fc7bd34c62cd6337187035eabce1a599d7ae4dc96e452f3b10e6464d61704e74813ac784bd62ff4f77e1f4235001800f27238c8a26037faa5c455c556c86595334e62e6bdb3b34cb261a66fe5a200518dc18f606e3ea3b3ed01e27b22b1ac7fade9b8ea05991aeafd0821ccab3767bb50c11b13ec17ca429a3d9bd08d6a0d7089dd2741a1f565da3380f798c4997e5769475a51365483c72da8ddc9de4826030c05e88aeb29dd138ca9d7e030c9255266ab2f9e21f37f4fe8f1ecc08451104182704635b231e64e82d6d16a00f9166ac65f50b1188e688beb2343656db6f44437d9443cfd3287538ad6286a83b57c6ca79a580131623ac5f425e80baca6ad013de3892da5221a191df4dd7e6643ee009af2cd9be2da67d90dd3cd69ad851afc67cd53e30dbc737ff1fa7265408b1720d1c1cfe7047d4361221b30631714266284672ae678543e904f558f3575c4d1485580fbe5a4353c0660aaa7ba7c96d4dcaba9f9c0f144bbbbbd9c2c78a059efb4464d9676bc220759b181e24f3356c9db82cd9f1ce7dd1b443a3291c0fb08b2094f8a924e248b5134beaf4e38f08e3f1a2e1da8f23c6b18d0ac696dc50b5dc6d432fb7d84fad03b9aac292ccd7e7eb21cc390876be3943415ccef16712701b14c2795eb02854fac373235beaba973d0103258d636e070fdc25147d1f381426d8edd930a17fde7970649f4282579ef22333f3bc53bbef2adabb5142d16ca58419192bb5b3f47b57ea447b1f481ed721364e8c3c26f08eb707a94754815803f632efc53e9f4222979ffcd8f5c5c3aa47a86416d5c9242a79b990378a9792ace586caf179a4d7621f453564c09575e324e0d0ea15f937e01e659fd504efd918967c5f8b38786de97518fbde03d4ac856a79498a7ddf32baf0802fb62ed2531c9f6e977cffd61b0e4525642d696ca58308dde3a37033703dbf94d72e3f5b44365163db51d8657a772b7adc03902f16d5c95485e5e1ed7359dccda85d6aef43b34b8dd0320419a9f6b041429cb1592e59f88fcbefd45cf59dcb3d1434cc8ec162159f9bae2ad00cc8f11fccaa8b7469ab07d98f3990abc17c58f398150d0527b3749fc0781a9c170a2a12fb8a831022f338fafc7bfbc2d756cb6e2b83a2250fd85872dfbc67c1cae489ed5ce615b335f974e20f742210757673533f78900326dfd4caac0435d6512dbb3c686523626438b9fdc3553f76810455637cb205072b77c1cc03344f1d949bd56b83b7c7c31fb7a9f77682981b756af751405c4576a14f484fe91aaa072eb46f2036dccad6489b6ada9f995691a8c6746d755dcd525325e8e3eea711301b0863a626c2310bf1d26cdc923bffb4d5f15bf41db909ea67a2128280b1e33f71aaebb4f1876cf73d42295c5ec0c535aadb49f05b971a073bace86698146025e7593f73f4f736b96cccde44fd156f031b572fac0cd5f55732204c679f97f81dfd84eb691d922c20700e32ca4f19585c376118dafd9bdcc1135f93b99277172d6577166c9cc0b4595153fa9d1e8fa5670a12b63da012c93638beef24b9ae9ee91105ce39fb3a2374e99d29dc54ff5e5d8d2cae90cbefeeb358da61aae5d281174d8886523b65780c868f61b4eda4b28fc28b46a0f9703d21f30bb4f5335375c1216b6c9f6c26e9d727d09ce1415bd6aff40dcb9e7f888d8c1d6a55dda2931381c073023867a9b34362c84d44d05083906b62a4e4c81b2d403819747c14286968ec0f935655363270d20ceb31d7d583d983992ad9b8d3b0f35a8566398ed61fbee1badfb4cf024318d2687acad697638f77380d8b669b1ec8e838fdb35579b4f212c21c7c9068e802a7332ad2e400b8214e670711047c3d2635a9609b13da6a7c0c11369e21848a4a328880d4611155370ae0f1ab62d9690e6cfde2478ca47c0ad997b3fbd29316141bdf1bfe77f15438130057fa9b858664827665e3437abf13e74e3272af9cbd2933038f8def4a2d8b033031bd4373249e861eddc694173bf68adfb3cb1b11db09254c42525a52c02da3cd3fadee7f6f6bb1d096a00fc2ebee0ee18255da98ab337382a804c99c32bf6653b7e62c69646fbcd67a8e2f5f525d277ce02c41046d003e9743b426ca6204ad3cd50b3a269e6a4ceeaa7ffd6743a22cf6d561dce7c38d5c75953b8aef7d0379efa6e8835307c71e6229fe4cb6b36e6d7ad80cff603e10a9f6cda0c4bc18106a0a92b33ab63f26cf71d3e1a23e3fa416242b2cb5957ab4392bddcddaefe364facafc6102305a2fada2d8c4a8950372c14222449fae5208ee70dc80ba4e5dc89cb971ec8da4b87609a0a258c3720edd3ccbfd5d3c61b308eed2c18cc7944977a7cc2c9a3427689842ce596d6d0d6235e4c5dd3cf53aab07ebe060d411cd129b49881994be65a1512da072b752defc18cceb984a4e609f8d042f3576384fef8157b35279d6aa337a966590f825a9d82fcbe7d231429d691c7b48614ff895b490153283072760457cc9414a6614402dde7bae6e5c3917324c9a7ccac6d47bab1b7ffe5db3f918dca8b5dc3f91c9c55e102fd77473d8e8b7130a5fb093344283b3967038e7687f428b992c2759d2f89b485f695482d2b7d096d3cbfa537e208dfce41053cc89ad4707985b0269b1d3812b5ad9c3d8fb4538c4b31aef0f927af84d81dd50b0bdf208608cefff70ab72c202b04c624c33e1679eb078129317eb08aa22170c1c8620a6b340ed9ee9f7b4642bee2f5c6e87d21714426e30093ec8c51d44bb9a1572a1a73a38bf33051e9310bb73fffc36157cd7af81457802d6a8048a2c49b07fe610cabf056e70df5108cec5e0f9cd6840cad812189108e15badec289d79fa1a63eba82bd14362f06a23990fb23a342238bb29e6dd5fa36bf53b30eae588e92da38e39e0830951d5640fa67119098f912984266da50bfb9423b58d9b4f52793bfa1c9361663093a31bae0809e29485cc1ae72fa1ddab97d18b387aa298825b10735f5d621d34de87a79dcfb2e26bd4312fb875c0736dee5b5b3d3068158e30f1d486b1fd49b4f55fa1d603e6cad471662dc375508265f7ec33522a996deb5c3bd199996064a2b89da0d5f02e1e7ee6c91ed15db2c09e5d1bae0352f5cffc93888c9d6980c67c3a3ac2a16fdb230f9037d630d7f8bf567dc97ee18ee15889ef5150f1a26f2dec00343f0d5d472031ea1cc81e60142e8ea7875bc7dc338a578aded0c50962631b75799afa5f692040382f2433558e5a13ff4a3496a02c3d3c58c27dad7e01c0faca3a99571eb65d9fbdcdbbaaaf5d72958ebbd726106fca063417c8b5816b5f43d59fc2a74e4759d548a223833e298db6518558f8382fa03553ae78de2e7a1c22bc8e5a611c28319fd7b7eeaaea315fc277b237d85105b67158c15b33b536ddc483141eb73eb8347c35bfd0c951086f4fc981105a8f4d5d9a61a95d6f5bd3219322af05418b4ab56a3889cdab6065da8561da14da5a307fdad20e133906e3b2c879414b9288c572d8dc84b5604b36dc3b6248c4e8d9a7da16c2463504c12aad69fa87a287bae3ac95e7584cef565ec12de6d9ca07be5009265deccc666c135760d35e0ddd0f0ccf53d9863586ff5a6d22ab5ca7bf4457417bedf33fe931dcceb15cb5ef4c3d6ad77b36be3189af8e8541a063a0af67fdf3b34d2cd419020a5e4d3689e1ef9e79166ebfb480398d5d1033d03e053cb0e80bd968fdb49466593d96793819892d9ec9f09a5b0e1a86bb807b4081209915c13d21e81bdf71784ae24aea50fd2b5a7af7bc07e2df0d454955aa5f999310382f5661db8ec7130b2362de6c83eba4a83a8379fb5cb861fbfe37163220b73d6cabbd72cf58f2c07ebdb693dee20d835c40aa90ca275e7d0b7a4c746588931e0ec55421e714e7eb4afe441fc52a9062f910871b310d40cf9f6abd1a9d95140578f13cdcb34a20365b5a3b0521024fdf1bf8435e55593ad01cdf43e8290c709443eb321516048acc10a3e5e362602ce90a1dc5585fa5b85a1c88891d726fab6590810e36f9c5227ded8d6e0dc90b1a1f785e94a049ec3c28dd566e99546996331c62e2658e81d11bba4727dfc52c16fc6d98b7cbfff4d9e0f565c5bee90b545b2d0bd71b6a1b5799f21795d977fa97aadd974be4d6ddd7432321b1d5cb50d5f68c07a45caba71c0100431cb6172dda02d2d14ced217a36cc5a105453d5abfe8429bd7904832cc02687f5176d4e2eae29d8913c531af90056985d87eca94f91ce5a457a54fd440158d2b9f453969ee1e0fbafd78beab7ec67f5e5a56bdbbf7626b6daa3eb8f84b2a30e0eaaf25b44f1a6154f7aad3ec72443ba4301a4ad296cc73bbb4a9e1afdbaea7192678d76428d1f8e7cc4d41ec84beb7eacef0f643cbb5272c92c51d11835201dcf1148272ce0d591497668b94753e7009d3e9e2c83d6c5219122a33f64d9e1c3613d67d22d401fb20f4842435d9ca764412cb68f7597599298ca18f4571d77bdffb48b10a75a57a71027c52c1b8b2af003ee7b52a695849178b88fca7171f08a0149877461828798aa85f51fce0f56d6dfedb685cea108f1a49814ebd483956fbd7831ce19b727d111a63568538abe392d26a8a4fc1a9404464d29bebcbc5a51b13417adfa57a804dbfcb07111f74d0b783d181e48063eb27ba193fc1b2a7e09f57875b7f399745feff0ea54747af2f66804a24bf5f2a05d31244c1efb536148a9cdd1751c108a883b7fb78be26ba5e9f110841a92aa5be1eab4cd48dfb74017e3cc7245ef2078e44d543e4fd622a8748072767c08d46f8b5d4f2ab2c0cb10f4d874d8c7ef858aa25d09f8e77f15966d3fc11e8d808c33ba3d3f9ba40458e78e54c2d4a73116c989365b3b6e07b73222eace87f5155a684f53f62a921635c9ffe3a25686007e5a42b263be60a056450528e7991c3461311686947bf8b38628232224d76b9c9a6ab392280040539d45486ea17fec5a4026a4cbd6e949a15f5aaf0786067398379442e26411d6478c7e0ce2fb997e345d6c6b3a2fd86790edbadabbbbf742d7ced668508e9e5515e8fc7d11a26bf7a3cb23ddc27d5fbe52fac52dce2d7a1db4a6604a6397285bcc1ef3ca3e1a3ee29a22c4c4aba20811a4d6825326b20e1d9dc8e8eb607fc493e0161bd591825cb4ec9d6a484868b4b812518c4a6f7bd597ea8efff97e10c71984cb6e6889559ef2f78e20864f2af5d82eaab7b6f8f2d052f16ccc9d31b4b96420263c5ce910f9661ad27a98738918f6db9d8dbe2aa93f516ce70d6afd44080b36b015e59ea8b37c23f7460bb10c0613136a750e6ebc8cf85a12fe55334c6e66a1b7f0c2ce0a5ba25acd6782d3288a6a99e5107a04bcddefd856d82a96183cbeba26cc94c34ac79edc39f059a883596692dca82d7939556a726f50ec83d5c347fc17083fc7c7867ba9900d0af6f3aab48b3d481de7fcf8afe7a185b0cedc69b58b1305323e87036d8beaa70a9f3247483c270f0d516f0180c55a291c0f00d233403abb2cde22f934658f422967e079b8b5eb1c2c8f77ea0ba04087d7cb5f81e99b5e395a139425679fdab8e4ffa50ff562f7a3373d0c1000803ccbd54903e99d21e71bcbdfaaf0059eb3d63c4da38f1423bdd1d2128c473918f18816a73ffbfd23ec9b7ee82c663a099e36ff44532f4a58aeabe7854dce727a94b81c4a4110c45adcc3ab7f66996653ae9086ce8c7022b11e72d5d0384b4616ac3f6ccfc18045eb6bb8db8f5a44ae3ceca9b4ead7362f07b7d40e998829a78b0b9385939b1456046bac1556b3af4ab4204a0a36c3cf37206d4348db1b5a7e746c71d6208541aa2cd8397168207ef6581b714a0b4a91d15a6955ed7853d2b6fbe618d793736f341184953d3810d14732f405a07bf6d549e85928f2d9141fd66d3ace0f7e769fcecb2a813cb28cbd35a5b0a44b63762fe477dcb1350a698076d255cde6205d2f3a82504ad947fa8e3f95c86cfe048364776348bf4cc8c85fc8c1fc33957cdd8c81883158b16557399255fadbf7db4e7b14ff3510d40d34c2f43de130365cb13a87c9cec6f5daf39154554f74a52964f8c18c87ca3c5d70540e7dde85d6567ff55bf2f59051f1f2eaa52013aedc62267432cc2a4700c92979849ba57e76ff76f0e97d420f5b6aecd5297ba567fd2ff98d0d4522a243c63ce6a1d66ef199e4371559432125127f66a36fec9dccfc70934623df5cd3f356bb579dbc24abf76fea0ca63f14da3da04ceb0a61f9c312054eb691a47725f00afae34ab50dd9bcf1ff5b61f559c6aeb91af70aa1403be4dcf36d87e2fda315dc3485fed40a34385fd8ecb21e9bb390a8f0c401c413c3672d104c5efc42bb7c3e6aa80d855537e44e0691ac468e76156de928b0d2bdf2e8fa8928302dcade2d5d5765b95bcb5b2a1abbfd52908f0307fe400689d2479e8e01c194f3eb874f9f90198b1519b498d8e823f9344557efc859ef226400ee8f65064b9fe025540f95b59567cb66baca6a4a7432c45abfa9c0ae7335f0fada9c591426eb7655622b9b8eec258177dd496193d8a171561ab552a894ecd2775d1947fc3c5fd06faa3165a8cf980fb3815913eb82ecb85fc8ec9e69587af41d19138407309a77c72de01e2123a46326b26bf9fdfbda890d2988a4f77111b4ee110441d6004c58a81c96e593eb79d5f1dda1bf54181ccb7bc7e70cf2b06de6afd2f2d6c72b56ef6437118663f7128c8ed449ea3e1879ca0bb8b05c81f4539c3c6eb8e8b30adeadb3d11ab8c3735173d1b8c5e8cec6e7f3cef2a62d83bde9cd67b5267e9354f5eb1ae2064880b825a2b72f1d8bdd9cc237c0506de37a2536edf9e6049bbbed9a9860ff23663f593afdab340b3673c0d0d646eb704a81f18cfd57717cd2fc14aa7f038c140dd40aa067104e22c50ac397febd76fb8daad7542fe9884f79892ce243770f0560cb96fe0ad5c28f63a0461cb059cd7262095b276975fa230c1cbffee41a6e2e903133db9538e490d4f31dd0176edccb62b0db19c1548a6fa2862515b471a76ec4d81b007ff7d5c88415bca9ac8b47d7a98cf79a417b1e8f2458c7ab2f32abe987b66b83aaa6f6f108965a0ab80a15ef61c7d887399276baf76abf38b857d4bb49b0d8c4ecb323cecdc74e14d7ce06985cb4990ae7c59abd0b23e7ea49f135b5f18ab100e4859e40a89670cc16020373c047e62ae18f1868177efbca5e8bab4ed69510874af607f13573c01626d71ba7c43ee96322ca902d54787cea491b3e6a6e903c97b4f4542e49b3f62aae011b89570bda89f0523a9daaa2664f846132abdee3c715311e7193d380504a1a81d23857add231cbd29e7b7a67e737388ea8e5bcc76b2b08cc58d0cd2d95f08284b0975dd2e50eb96dc9a37268cc5ff72638aafd37c18a6c11af84313927ad9285a9aea926a552c8c60ea97e63e320677fd1b7ed69b12536af185bdb198b1b9ec47fefcf16a7a5269ef44d6907bc1352d85b28588b573e08f0c2f76d7cc97345ef2a733854d509ab580f4ac5ced34ba3a99a832c9bf30f6006a4bfd678826f31e9bc25ed1adf4dd7d4cb95da978b7cec79a12b8d5532c963713c468346a49b2fb97f79efeda2ff15d5f0134e948022b7f785b7570210b326c0322dfc5f38ff2066f1981e0373a3a23ac9fac1cf7504bf3fdaa8bfd8907b837b91cc2ee6fa3afc83d00ff5b61734c7a88ba611123df9d3eff3d5668b3177cd12617a60fef88490463328dda310df97c2dc31ca40488f284156160f6288cb6c33c2e1d6242a53fb7a10f795f8ddd4978a138011fb36f2ab4d2bd3f457c2e54b8f79c587beb850763590bce8300083bb3d8471f49f463838b9b5bde0ad94e547256e69006ed4af7ab5e9b667b1ae1891f3e5e4e795f9f8c3aa5a575f39c2822e4aa77df0dab265846f8a57a48ad1c5f61f6f520d17581c2a81708d678c80474b87a6704a962688a7c3b4a669d0e640faaea2b0934440a7233c6abda2f992937e67561e171c1bf0797f454bbdbf2e25376dd5f2fc328d4d7c6fd8ca4a6436d9bf6c3081a4cd93af8b6261992a1fbe170ba719e76a44f58e1616170f6b58d4c33814139ea901648929800552d0f93fbbdddcca18120bfe6c37a7bed0fd3bbcc5ac52e4644a599f9694a77168e5a6260e9f40b301f7c2a389af7dbfa054061475f6d26d88eeaba3a1f4e742d021a6d20db839e901bc57f8d8f246d47fc09a4a2186464c5e10b170963f6e9f484e7c48d1f341e0edf476c66a9439efd7fc4e65720c6d5bf0a58060199609f94f452623b3900f51ce5ac16f71af47d5f33995faa94ef42c5c2b5027720bf930d10090436ebf9256b895137061eaaf7e4c851e19291fd15d5db0d8cb1cc7e85a30c3d9e23a7fd9520e7490a8f709a18b918085c35f22c48fc4dc7e86893dcc7aa190ce9b5d08742aa798436f98fa6b8e58c69ab747b8cb635dba46256186428b1fe16cd3fa2bce9329b6b7c6cddf39ba9f339d1f8c59b03b576348d926a0cb7cccec89a3a5320ab2ddaf364185d9c7d7d8bfc5a4d8469b1d74f7d3e93530523e140838145440be0b3466d143ef9a9a67f01c7a2e4c499aa1065061709953dcf038d81248dd4d456c416a9edf8c8e30eb81dace7f0452f3de8c09a736d64694277652442901d5a35115474bbf08956194518ceca01437c358eb5b946d1ea05a7dcf8ba63f3d6f5696ef03af70cbe81c47ea1c0a071d6de9cdb69bee0e4bc133286a227c79a0e8594ccdfc2a398895944e6a43c7f4cd1c03343f38c62967f3b0361631f0385dd0ae55a2f8721aeef1898b6dd1f0287324664f7222440a30a1da39e114b9296d73cb3f3e3ab752652df10f305e23843ddf95197392101940e5eaf12590a32cdb0e98458be4df2a75463084c25aee29750cb9e36e9af9e2a73595a802c1ba769be17faea4ec85433d187c07ff01c71f4fdd7aa676af78a0ed401410bf8a2dc6eb6fba5b1699277675abf162c21f4bfe39a87a46ebb8e955901984e3d159dd619b81467bc160d6e114fe14b4ab9405cebdf3395d6e9ad2b745c65d2ed9afd6c3582ad6cf0f38348ce64ac39ade14c4502f682b60b177f4deefb35f9f97db66addf1150d8777109eb03879abfa8dc9c391b3aa75fa1d5cdbd3b2060952f066f4fa51215904e79d4ae7da84d30d58176d4fdbae19a095b96286ed6efb70c3c4b78adf8dfb5cb663dcde25576f6eb53595ec1e99f9d0374757ff19c5c8a71d70572e23295b9373b84912a51d8928008d9793504752b3af99a7b8ad20c5da853f0f1c6fbbce655c670631add90986b6eca20fd26ba5ba84253e07eddbfa0e58af15df47e1fa011ebac3fb0a8636c27510e1ee0dea5576101fc7731b8e6605c2b1314db592f165678c376f7c3b93f09749df70ce1346257474c05b4ae8cdde4075df937bb481c779e51f2327bb6cb77ef998f003e266a72d6af4e63c6271a0491892d2fe8bd45319ae05b9ba189174db925cd08073d59946528623488af94b40534730dfecf9ef96069f727f26d8931a982ab56ba85f1db1ba282d5eabe7c16894c40a82f3ea09cb04fcff0cb653d6731496d865e129f91e9c0d2c9daa9e872d5f1aecf0ec5c84ff6c619d8e1c6f829559479f13b7aafb5d94a306b85656918a1ad6469b91aaa98267529f50f8d24905b64cef5a5e942748e5123d7c867fceb5559b61cbdf7c7d7a4c5595efd0fdfab23d0050599407017a366947adb61f20c2597d24b0aa2f1a4288ed5b9f5ecec943ac07610731404baa445ad547be4991aece74954c8807d47ad33af8fa099f671f941c47d1fee0047e2a474367c6f32bcabcb6c8b177ea275aa8ca733fbb8a395a580174a051321e69b26524f0a022c7945da1f27d5ecd2bc944acce4c4f0d9a03e1668bc2cdb26842007f7b00c68cdfae8036ce855e49faff91a0211f709e1e398a95b15c063dc3e57f346724ba29ca691655004cdcc97f371d7f950b2ded1185d51347295b97f550679fef2c2b00bd8470736bc23fcd4178c222f1357b74a8573efd00b19eb6516b8e0e6765004a1ca672a6889f78f37f52b0773d8aa389c67f706890dcd71176517f525f4204c16f8bdc04a040205c00e3c87f49c0dc592fb725f7e54d5c4bf48a748396fd9b02f5182a3fd7d46a9ccd65b9e1bce7bea44f525a1dfd2b1bc07418a4f33f2d318db08c8c510f644fae86ddc07288056cff427ca9514dcffd8eb60fd2a5be59e6de59335c3934a92fde9c73e2aceaedc102ecbb5fdf7306f674d64ffc269543c4b6948a49ca67c401ee0f0e19d44c0ff50602df8f7d9d2a28a3ec7c324e958837c037d9c4ea57c4e93fb9b3a70412de6025ef2d1758e8565b5b552e4da6ab8781918a9e50797a235df41e562b223194eae822ccc19f616af24861d69780b2affecc0abd8af7fbdb2fe0b5d927b3450c943dee51ce7900633e4e79ed58bf9d116ea206c38482a82822c3ef481c6658cec412255f3aa10ae5c9d25c6df0527e84b552ff69a3322d19baa6bdda8060f6a233e5125226849048dab00ddfbaee71cfed06d1408c00568a22cb3565671e588140d2b3d479e3c5470bc19a25382e377d488acc8e05f4a26e423255d3c7fb6bb9131d5dd07c565c3771008f26dc608495d0d7de279564fb2553ba9fe0564969c227492349cea3c675e239130d1d9451b98b0c8799f7892f90683abe0cc30da1e9cafa23e4f7ae60c11c7ffbc84c121ac2949f58ae4eccadfca65bcc0dd39f9132008527067efbfd478a44b374a858a48ae82ad8f599fb4ba781f7d53e8220ca327957202215b2b3bce9fa77c1205bfc8885ec38b56ce2d7f6c004becae2cf935e55dda328e6e47885e7627e423186f19061da7c013b16ae60f28ed083430e985eb36a3a3a3a622f43fbf459ede1d4dd0c6a74fec5d3e40119a6cac2bd22266f9cb3626a9737bf54ac2783a4bdd4db29b48a38734b91d567aead49e7ca214a6d48decf66e5174c1213dbee100b64cb1d2b1a4263995619193200a35fbb60b9f333129ed83a740bfade135d300dc001386999e3603d57947e86fefa637f99c85d979326b80d196e078bb942256691babec9f8871e59884747ae196be4a1bb2bc3d84b30d7dab760818a2deacefc3481b8f179355aff38cab408f6cc76122e8a449d11ed7b78a1fab5d34b93b36b0a22bffd42f6e5a3ef8a8a5f154180af09a388b6871e0f1593a3c3a28e5f684960c6bd586f3a78d99713324a27a4757a1d2e1ac9e7daa4dece877d346d5d83076b85212fa9f6cc3dd75e2556a61b34ca08d36eb99a6d57515424c1d81e88ddbd060cf6ad1df04fea7c01e781764ca3e7f60fda33161195e50dbcaee669daa518e366fb4395297e2829298f7c8eca79c3e905dad357b99a898c9485303c632e1b24e05053d8355a51314251f5d8f006b309771c1d1a703c718928410b6b741b79e3669312f30da5acb3bf2ca43cdf5d4220d10a426c31830d99583eb9412964152e431a487bb411035423f3f0ad1bc5fb8e50308638247b36377150afe43181d821d94f34d2d24b7e2af2654b45899ba2f94f50dd153f1ad2129eef452544bb4804b8ccd15a589315d7f33442b1a8c8093d422189760c39e029142557f152083de7dc1dd80783b4287829095a1772d1d56563bb5a9fe12d25c5e2e31bea9f4a80ca06fd84f5ae312499b95a218a665e1de5c0de568f53d70f9d55667225c9986519a2a3d27c9bd762c48aaa7137aaa08cf407b28603cfb7fbd703db9caeb68798f201a53f4b21d51a6dee0b550a181238aeb2e98b029ae0a1efa20a73fa0bced44c97a989b0435ff4c8fd56f9069f8035646dda4d9f0c7afdf7e08107061687f09d4960835b12ae6849be2e857a2b6e5dfe77788b40dc26aaae51e9a41667a262c33cf491aa96ee725b29b686ea0980d16f43b334b8b1cdc10d6d1b2088e56b7824171ea38bb71dcf1b360293cfc98ba120f4caf003e76ff790dcc1741add337b4b278bb8a2555320cb50c40e372f7f7abf1955c40d611e327a66484c660fb1271471965e38afee63e026c073f0192604518226938f278a39a438ac69c9290c11941511bbf955d5df6fcd7bad7055af47d5bb8d456ca65326258bfae102867aa06bbe6e2cbe60d4fefffab8762c142f7de659d599a644fd585a9dc21d60ff8c5e7ca8c7b61aa98fb88988c70749aad8127c4f66f356f4e750f6c052d591c868c45efc0e81ff45d4a083aa7edd76b026caacb79b3cbcf89a4b3e83858a1f652d92f8ff13608c01b316f0cd6810636c1b4048300cb49b04fe35e7fa6235028e1f6d3ea0d9737d645ac4973707e206cde7ed6c8dda26a656dceb80acbc619cf3c2faf3cd8ee46f14717c544007c89053bd26638b28bc2bc5de55e5264dfd99aa26e7d16302358421ab626f1349b3f9fb9b24dd37dd83383a2e2a000c3967d1368a5672dac4a2fc9dab5b30cb9be37dd698e745bf74c04f4760a20d0e3d73a578bd7e54cdd258b1caf37fca00ebee0fd39c918a1074e10a00d024bee91f3135007b0765517da8647cfe763de5a33dfda958957cbd89aa266cf2a53aa1805c8d0ff5d33c2ff4f5264ab6a4bb8af17bb1bb0084108f82f4c94bebb5f60d22ae346a8e99737240b67d0847cbc07ae05c4909cabb4f41a47803d7877f51e96329d950eba2e5ffe2e0d7a6399b6c64eecde77400aa3d2b77a307e7b52bb7fb08894acc82e68155d88034d4b82c94f8f1b9d495055da2abe0de8dd673ac8a7babec1f8fd18a694bf03b7aa640520e61d584f8682c38f81cdc54f8593ba5d7d15a036766edef1b40618a2d09b4b0227051f2c09dac28993dfc54696e962cf925081b59eb02f5ae78c5b18ba2b47eac1cd0a27c051b81b4f11de964a1a4b195f614ef79773303bc4de7dd038cfee0ac992a00a0ee7073da099506bb37f0a31e8b7bd8f9242b500f3a769f9f2e58da3c996a872c029b7348181fec21bf07627d335c083384eb749be58d4df8ef985c9450a378dad2d835157b8543fba0141fbb165fd39bd26535aecda5889bfd8668b6c8e03ea1b2a40e7fb47ac64eb336513ab5c8714a6a12b0a7f0efff65670efbb14a7f1cc677e432aa7402b2402c8c05be20760f8b915211d1b681590e5308cbddd9628be2574ed5e4afac57bfd5e47cc6285bd5435db5f35ac3355118dacfaf713aa8a24a6369abb6aae26356b311c4103c0ba0143729a71053648439ca94e51b1fb6bbe3c9044192cc3bc54ba460d3d1415f25092b1496c19aae3d8f8f08cda973176ecedd72a0c3b23c4032dcabbe0bce17f5c5ee29a69b3256b82e1c82f37ae3240d79da2cdb273e2dbd83d114d30a2285907ed74d220a6e4c3e9c82084556668141d8952a250f16f86886953c94c17610fcc235284e7a2e6939b548271ad6c2e0d148abdaa8adfea6f01e7c90f3fb42363c7a122b71f22214bcbc11d738ecc84a30cbfd5ccc84c64e43b6d6a3b0e6965e3372acc1d03da5489b7f06c6252c716d046f4157ebd67d098cacd2f1da14d40c7bb806af29e3ef1ffd8d14f53ae5cf1c7817b78f6bf262def8c7ea7df7c6de2a72f4c8eb06fe24a5cf0574d4d81e53a2d41f98944b932e2d04d1edab8132b84644cd8b4b1657b3636c2d9581efd01cad28e6e4b8263948b5ee3dd55a92f34dc567a85e7093e81c904c3422cf147b1a78115ac485190db408bf59a4bf91547cb3f7c0b0b10bcb1e22a77b67fff6e8cd566791022ea600607bdc4349dc851617d23a41709c166c387d833ab63805838963a19afeb495c63e368d711284e3dac2ef4c9349db47f7fcf6bbc45cf44ac54526d4abec1bc2adff3eb36404327bb2ecc89c0f1dc5d7870b5b552444bfde7c17b9eef71f4b86485acdf477e991e326c4001fc6fe9e3791f20ba6536ec673fec2bfcf89c239c75112db2438c2be025ad584d66e3ed97bb26a31b429bfda73cf883d9758d11d8bc4f3994a8f46fe3e77c60628b19caf69a1a2077dd703e2f5bfc00e1ce78453950570596ef87e4948cdbc396288b1187223f10b411384897cf587bb3c397fd1101ef087f867f3ee8a602c39be7e332181f6ae30d18228c3e4ec91b3b46350e04c00d10b2ce16cfc9c2558024ee4687200d2735f4cd6869e4f944d64a903fde87a1456072ea700a5bef31e8eec50c7ef10cb5cfee006881f54685c19dbfd0697311251d3282914825abacdb6de8d4f596f4e12634da68594b6645d3c2027475f032a9179ed026f3a65cb61f28a0a644eb595a4e74556d354ccca630fbf9588aba5d017974de8a12043280c46d4948b72d3184f6e1a8f5e17070c3a6366522f63c9736109cca718bfd50167113560b2c7cebb6b6e2da8886376297441931a1df033fbafafd7cbc613d4f1791ddaa886f148f96ef9478cffe9954f348f8fc6b826dcea7f051af061e9763b1bb1119ce0152dbe4c2a35b28e81f4f22d9e8e37ec7f50c978839842a7dd6251e5ba84363ef243d5697c34c7c06e3bbbe49491ad4d1c87615d928ef3e71bd9d6663cffea48b366bea3a23397654622f1995de7e335ddda9a0c54cc98dec6444846f7099c0e1b887bda5f0b92aa12a195b2550191901b9ef6604d58cc35bec46396d14a38855461d4bcb1f5d8976a761b8e8caa98ab920a09b03aa4bf5e232ea5b032a0886f3d4b32e8e34c83e47a329ecb90f66ed844873fc582835f017b8907e2348523fdf17660b3a7a0098ec6dd77fc60ddd26ab6b19642b9e464010bd0af865b17b77512cba59911339a02f5398ca4c745bc509c274dd30e9b30d48c27b80e64afa15beb4a24889b716b2435b387045f12875c2307ffeee25aca9264aaf1649c54dc0a4579f926fb0e53efc9aa0d87c7906bf217b5c2645039077940e730cce408e981be242edceefec3211e418f48d6a2215fedd5b9f966f028ecf057b3e2d29c9f05acd2c4cf3d335dbd3440c304c22d59060fdd31741bdbc86f0d157d55e158d66b1402361837a5cb1a237abae905c8aa5b1fce5f1a5b812dc8249286c608b5bdfab40505d9e20b08ceba685e15d45e804befbd8d5b4b36ccbf5ca785b76bda2a25dbfa4e1d11d281cb622280f956d9f2e36ea46f10aeb8c3cd3af39de836a56f9e4217d6d1d5fa2fae135d989c290fd3814b84718c8048644afa6e57ca5ff0c708e9731ec28ec41f421d57d754d301382dc66854c0706ee85dd9c3907c411594ec2a3eb1e12dfe9dd8d434d6c1bbd0cc4fa9355e68b0d1d8559d3c345df6a4082b8a221d581562343afb5448730e8800b2fb4bea0521893ec15978a151757976afe2c672e7edfd278fb725905639112f21c5e53aac5c3091b8f080ef4610a3fb83449e57c4464b6f781bfa944c9c2bdf9a5ab672e8efcb660b44020811eaef8e51c8a23763a0b53a1dbde9fd5a620ee8f5aebbfd95e7ef27c46bcb8089622fbe110861a65dc0a3833650af1f4cb908e838b371ad077419f369c02c1f56669b657ce168019093136ca296043d477f47625e42525bdd768ec329d3c57a5c4b1e70a28e24fa91767eb93e5306a0f667586931440b2672fe895ecbc32928d6b6a506e94461c5a03171be0fbc97c2a24c4fb92e7d4f4e1a6d0a87cdbd30629d9b4bda971004d05fb47e27b7e163bd083abe85fb321bf755577b390811d09324aa34f5ee5ea6b3bddcffa20f4cf7dc44b258614caaf431b718440ac7c6eaa1a0f77b77cc6536c1cca0e7dda7858105be422b26d5b49ea69b8f3118bf6b1e1a15a94b802515e3c3c959f7af665fc4415932f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
