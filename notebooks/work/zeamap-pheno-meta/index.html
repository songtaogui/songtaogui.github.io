<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c075bea8a475a4891f7f8e5a63139fcc980a55898dcccbd9a5a34a75bf84d9b4923b285b5e73c9a02abf6b1e49e7a00dc156373026e2ee6d4a4f9ab80ad86586eecd4a7a9d3966e579e90ea5bef38c66ae1e1b785db0fa5854587b280757d9c679dbe80b80618688aa8f609435719758cdaebe0fe5fe18e4f41425040a4bb6477ffd579cac282db0ad91b67f89cfd441e4e66c3d76081ddd4226706cb09082070cbca35bdfcd17bae62f62777072249c3f0119f060fe41ed84694b0f6d55ef70f26e32922814c8acd8892f6ce2f5b442378ffe91dd2b47b55d290bf6152210268e98b5d9f2ff5787363fc9dd9ea0209ba0909553bbd6154cdff96be358a68239bf72a812d2ad08c6e6985270ef0d0bbe79ff611de90ceea420b0a440772705d82ae5619b718d1f76b433fc7853aa83c819da463a72ced9d4c8d1a4f661049a15bd80d7bcf937299ab0200901867f98311bb1eecf06136b4b7edc228e6ad406b204b273fe33eb634b2994af547013f943e093e491f97ba0ef7968100fd7eab5505aaa129f760094fa52021c22f8cc3421eef04f617d3ec5858abaf6ab285bae81c8166972df0f7d09ac5ed8b7d2645becdc02e43f932e33b908baa216d66e5103eb312927449644f7217ffd0178af413d4537d1e23b82af4c62ab5d2e44986134677fbccebce035b890080d171ba150c1ae1f4352986eeeee47762af1110f96b3bf8311a41f44d740f814d979af47b88d77f0a02ba825fa3cbd03ab347a633f9d1ccf9e3776122364952ae75b4ca04077d04b760211cfc9d0237590aac49a3108fa87c228c02064f5a5f89b7ed689c19facb1a9f1b397a29f9ce39e82593faef99c0ff8d75257ed7b6affbf6a0c38bf9011685d4b8cd787439082e362d8eb35a74f614285e9d524d9c3b4eb9e2f7e4d8be5ba6330cafa96c36619eedb2f974e10e26f5e9dc5cf2bdd02953d4fa981f56d6a74f34e4be112a2cc3573d1d4f87677662a516a58a4f769a57f2f095c91ce8a5b974ca52acf6632b002e4f4dc16305a5226ef7c22874370794e0c966a731af887996cd16731976572dcc69a683d4bb6a7e9caf981d8e6d6a90c621586b8b4cd53df1293545d0370e1e775eb320b6fe2b36e5615439ce8462d06f199211a9bee221a201a6c0d0764a0225384e8b3710b938bffe00ea5fd18d13fc7c7e9397b7b1dc3b03af88e6b4d538f6cdd421c225f874ee76f02b18178e96e59833508ee0bc924c51d91aff3e796a0897e17bf98f14139aa18b7f376e8463d7b7c0c2e6df99bc2a9cdd489f41b1b07abaa7465b604218d91e7d68ebd735a1e3b64b941438b2951b126a6274d7c7643b48524abad67ac16a089144fa65052053bee12a16768e9a395fd047d0a1752c4a38c8f46c1beef95f047ecafb0269bd47f97c8f025873bd41e6be3e91af9807a3b9b36bfd3ce67f1bd899e014a33cc4f2bb4175220c2830801152bb36ed342c8262b481b3314331ad5bd1019861bfdc69ac77456cd7954c63147dbc86816b9b5171cbdad066410ab35383a40019172fda51b1d61cc2dc29fe66350b5d409ae60876385c0eccc73aa8522f0b83a98ff552f8c9ce324c1aecfe926e9b1bcc8413edc3b4b9939792427acbe27c2ac259c4eb313a1978c63ef3a61d048c51463f0204076f684ef05e8bed0ddda46622fdc3b8d0f6b3fe12d058b0a4137b8cb7dd721b635fd8085f4961d5c9cf6ecfbf3bbbc2a35493191a2b20bd2692fb3ef27922a88e9b0ab8181d6b6ebbf62bc1f916404c5ecc354aa2c7d3c6862ae3f6830d0429532465f5f14705f9eacc68d9801c3b4da1433c4f21862365c5d5b23b91fa0190802b9b5e0fd4701539f5f3d40618e3c3535de479f28b76088922c3d16c5f069854c659bf6659892e7ae4e698cfb0431e1bb0b90f3f49a3be16f591ab2d1f057dabe6404c0b89217542e9618a488bf51f799b97f88128f69656b9dc4e33eb7d5822497f0ab295a99f0666d99a5456e481d26836ad9bccfa08d919574cd8a450ee980fe65482f4e1960b4219b8e77b9d6341655ae98b21072fb91a867ce7384f96ea9dc4066e45b649c01a1f81c8889835a23aa64e12bc3ff77b428194f4630e35ae1b7fc4089cfdeced3d9fcda5118246b7490e6b2c3d4a3ed8df88693aa451c448125f4e1f5ce2275abd19ca2a20b7e86db71d6aaaae4b8e96b62b338aba74d78726ebc88e35deacaed11cd68eb32c590442797cc0a1ba93a7c3a917e9e0e23538d90bde4611aea591f3a83b4684e2d02e32278e5ff4fb666baf7bf5a83cf72321caa9dc712e14ab32598a1ccd5cfe4939b0fbdc3f050dba3d5c5ef5c7a18f28666deb6eb38134aeed0432278e78c0130b997c7a87e449f5e8ff2c13312a62dfb940972571bbfeb30804241aa68462cd5ed292a989ed31fd678112d9135e3622638b006cf4e61ab4a85506ef13dba6716a581dd87b03fbf0501cdf1d5d4f1d1cacc878e411c94da651ac553b72098279a0320bface1b325b38ac1e5f1833ba9aacaa46b5c6d765ad45dc441b284c8413fca0dbc9d1df2396bc0635e3d6c745cc7e92f94ad7b6b65001c08d055e064ccc80d60f58a0fa911a62eb9a3f1f0962f40623a713de91771e8acccbcd68f89cc055e65db24235a647217a3c5e76848409b5f2f7e0545fb98fa1f845d666325785f7cdc5a03b550a6014ccd47a6b8803df4e76c89193b1310fcce2c65c836897e1913e6267e76eddf51dfc399e61d74a2b1ce1ca5f70ce971a57df8f5325493604f46d36efe14b0dc3d38a4a3d36dc25fe65043884ed05e479f92c2cdc2ee4a94a7b111dc245d2994bc0e740a5beab61ff1ecaac0108a620140a9ac6f0b322c7d67dd5b31ef90b664aad90005e4efbb5a3de7d379e2336845090ff6744ec27f49e40d48517645bd8b3bfa5f9cb82f34928dea7e5d3489dd5403005426cec43d395d6a0ec49756732b68fc3fdf6a460d4bccc5b421858fd44c907f33791950cd002791a8ed89537d44f8232fb9b99d3ca5f222bae2bb9291533efe7557ba6f42a7453266d232dde760dc381f985ef26d31c9cdb3e6096b781a3d7e5af55d8e1f8123769fff3aa40d1b53b6b394d60dc64100938595575840a844240f5cdf2cfea7313a3d92bcd7d204d36eaba497a7f7597881a40bff2bf3ffb32af5f3cce1d183b3ce51e7c7132e432d5f270fc180da5cbd580a327936af3552824703c7f0355528817cc91d0e6f08046473ef6932e829e34de1b19051cce807bc9b7aeacfb17c89d3adb22e46fc02717926754bf412dffeab7a4c0cff9373a2f95414e81a2ceb5739a81c15aba1305beda7d18de9399ab9816ca86b614bac1f93bf41641aa682b4b3a8051436e806025c058499ddc6b9bfabae781005fa8a3026908bd945d5a5413c4e43730d73acfc64b0cc017a4c51ef8ca6f0589dcad9024c2abc3f613612500c61384f70d7163459e7f751cea86ba451a4eee20b360595d7cc01bb53647e59189d59a705f3ed7d6e705e875de8fa297700ea90740f108804be6b07e63ea5cb18c0d3d61a6dcac3125948fcdbb1c8607a8016a71b99424183080325df210949edd8e17a5f0b7bafcb3f57952b56aead97b67f89e9cc63f70f83b6f226fc4d45a38e4978f2a2655dfbee9ecea57200a55e03163ef49dfd222807bbe5fb196b684fff9f614ecfd59f7919c47a4c536321544723cdb346d85897e661c522a65ec89aee50def8c6396c477aef5c5b60f0c1f43162a519e25062008734686169055671e9315ad1189262191a2233d46c5a36e6112a28806e70ee5eb9e69602fe31c4e57ce476ab76de01dbf8884fd375e4e90a29667c9ba25c7245a9ce4c6c7aad55b01e435c76e2e384944d7aecb95dd282814c6ea48a12eede4e1cbb181751464a93ce69939f6ffbc2d695de5f721de6f3ac7dd9df6a66ffff38765e6080047ffd1f406a1fc152b3e775b2d34e26038856711d446b014590cfec832424fe64d593b05d0608f69a42965c1de011bc99d547e7ae48ad99cce31b8b710d8e719ce7debe9069170853251d94622eb1b986452d151762449a678354043c336b123a7ca13533ac8afca7c8153902efbf0f900c2e057875ca2793ffb24288582a2f112824491597d200a46b43111fc29a20b5a52e3e4fb2101efa0848d9b598a71c72d0a25e23c99cc745707b1e7ba0dd2a45e5d187238051a7bfe2e116d073f878bf68ed9cce72a17a43806f6d681e05c4be78a9721afc55e5ab2b4561afbd25746b2a1f349653bae6e8df175caec27334c929abf1432468e8f018ecb67f774c6495cb94408add5626556fbafb0dc8e031974d6fb904b6b495848f54d5fae4e2a03d74cd6868d3d8acb2329ac923b15d75f2683857b967a949d81e862d0ba94cb54bba413c7d69470b4e9ab05ea6a4e3f15cece73dba41cbe4dcacb0e8f6fe715bb456d9397b2f0ee4e8b49afa889ce6cc19994c9a2be80a377e34903c7e6b3cfc634f779dd36006c129db9e1ec2b624e0a2100bec371bf0b4408980ac162beaeabf300130b72e6a74502b283ce6151f4e305e766bf5e105a000649f3bb30f3b42775188cd6efb844a4ba967b5e4547227273e9ecdb4d95227ce5bef9c3eb82732cd88a7a544a7ce1213b9fc2b7863beefdfa1bee149ddaefb955a26a4ae0494571475f0e6388ce01299e06fd2178066d12275847e0c5257acf53d36896c419d3db4355dce41a216958c1eb741ed985b2f5e963dc4d0d6696463af3fe04a8bbd37daa64f6fbc21ab80e20e88fb80a5a323df5805e6dc37290ac25d50da94ad6cb6486dc0fa0e47edc7e1922840f1cf080cc1726b80de65c33f0779340c875187fdb18575a837c28aefcb1ff06409f97f80b3ff69a2048e92d0d9d8b75b163c3e0848569ece5e5208d110dd655cea40b55ff3a8eaf92f6f80fd50f2580ba59b3d2ce42520a3a7750718876de2f2c38af197baed7c79972c79a391a4e8709086e27b736ceef302503bfbb67f8d89365ae12f6d4f94663712f844f0d7315f819be0a961eb3efbb847ca500b6f1bfd5b97bb7d77b096690892f502910635283752f64065e17b079e0aa68fe0b9b1d44b5c738edfc56f419bb46c3407ba697100a3bc46d2247cc2094068b8663ffecab5ad0bc8ead381cbd396c0e0aff3f84cd8ecdc7fdb95250fa2c53c82487afd80032703c327f40b7d95c2d6c39e0d22c99c5eebbfb0cb136abd5e2524432ec8ee84e24065cc86df808d8e9fdf7eb6faf754a926935e9ca2375fec980d9a258b21e4328840c3bdf929ace034375d0105283d6c1bcb3d4a86d5665cc6b998a3b939986fe81b0df103c7f3942a4abfebdda973de3119a63b8b5196bca8e6456613f7a5f1b1f5452d3f31b9b4ab69ee5f890252ec3f884c16c16d831f0a1eaaeec1dc2ac06ee8d306dbb128f20fd8db564e2e1e7321ca16ff10a09ee1ae614bba01eb439aa1dabb8b4dc16a2ba25fed115e3685040ae13656fdaa71af280eae4205cf6a6737580d10dff7e9a398616e671dc6f3a52ee3e226a8c4de2519639dac1f0ecb200463591651ac84089e33507e8a133b3250655b70122536bf4f8a87bd34c818845d2a987dfade41e44e8175e85bbff59ce4280faf6537443651e23a74a37d0211fd903ca7bdf67fc1b864b78c1be38a6ce48af84bfd2a44cc245f8b0ed6d0ea4b428ffaf39e676cce98d6eac99f6700afce3e00b3ef5d3e02f6f73354f023586bec75352bff441bd8b39ee2972d34495f1ebc8273981b05f29d5b1cd7cf21bc270838e414c93fa44e7fba3bad5d59d8a0f203223871c194265b76c6bc7fc6b27a65755b4f64d1daa3922877134503cb089e04f49d92f34609ee4deee2178bd3475fc9569ec857fd64dab5dbbbbcd5aaa51de7315de00bc760aad5ac5c6c10e96aa22654b02c297f017fa06c66ff13e79886d62635510591afddf7cb5bef9bf08b50200f4289eac4fb36cb8d4a392e2dcb003cacaf8e1af267859746050ff1045b37772085071358e7e83172bd8d37acdb1e4653c9ab32de32a09d4f128725a6e5da03825c71fed258f1170a2f6d3b451d52ac80e660be529bb5f7a34dcbd4bb1880624cfeffa45025615d337672e7ca0562461952547e437f909b6771cc8afc388f6a1f066baf818de8accd418b46ca87998e3c3681dfd3402a9939e425ce874dc90a65a962c2eae690a3593abff1e840960d62b917bcb36681abf450be0abe8bada544a5bea01d6df374bb871ccd84576585fccb45f13134bd72ea48ebad650f2c8b1ea0deb47654edc687a88ab2911aba7df7a780302ffb00bfdd27e4b77d2f39ec017fa3edce747ebeabf742ae1452d1bed3dc3a3ef9c97bc658ec5d9213a6647ac71831be5c970cd751afc2dd4bcb77c12dffb20bf082d78ac795a618a8c344abd1673f1dd9ca1fadcdb804bc7349779b471f8bebb01e6285a1ef9bda4f89f03c29e1ca31d816ef210197d2253e69bc29630cd43d7ac5b8687b9bffc9ca21cf16e8adc375095bfa84bde78ce9f9f289e925b0da69405b63b4f89cfeaf3b987c902cf3b45fc1d92dd7a2b8f2580e0cd67773a6389bccc2e783e0b336f8a947af776fb36976dec902c62f223989bff81296629412836cc1dabfeefaf9de53c8f0f63978ca51244af39be5f131f85745607968434d8d432eeff340870f9ad4ebda9d2c5219016c48a061214b65475659ee5f2682982759eea48b075b863f651e2a62cc3bb64004d6cc11c18d0c825ecbae9126536fcd07b51ba108b5758ee0091d63fcbd9d2a491c2309ea8e6a446964d0dc6a2e86ea3322d980041160170612b32b6ae64e89ac2f6fae60ce3c1cd129184b906191864d612e98d174e00a390c3722381fb3b0a3a32e7fb54d4fde54bc590cd6d378baccfcaea9ebd45c30e42ca90332195d82908db818c30004211b55b7d652a944c06e225e909aea0366906ef4dfd6b0d2885d40250953d92d4960a3ac635a85f943b8d6d91d65d4151152b9f1e068217469c2984b64abd6fbc88bc73c4e2ae27a5f3de843e0945b9f432e9b184213b1694189b2111efe0bef92d155ce6ad682fd0186325e0ec876db389fd6de2a4f13c85d7d38c81b050a6957c7352b0ee050a575f9adb05aee812628496922344cf194f94d9d8840f8eb8139e5c8171eac9195e1c251aee15e973c12cc6312b97fd5aa5d104c9dbe2d6029af42dfd0062224a5a55ec3dfa83b876c9496c4c5f04d473772d700707da058716233d56afff8228e58e54309215aa914baf8485b8970cea41ebaae5b6e8f48007df2457e1846c578a332e4d0f69efdb796277a2d4a27213b9ac59ac9bbbc1a7dfd64731a85ddae0a770963a9cb1b549043bf8ebe5d7e4f56e15cdf97a6b7fd60bab1493c7fbd1fd9c756519acd21c4b9c917443447636e9203e7629723b12cb95cf50475027e21cc654fec80d441ea1d5329eb09ed7b0a6ef479d3e2753e8315a643f32932404c61cf683ca7f521e87e012b1a4da051fe39520c636f6431a4628cce97d72ea7aee00f7e2f5f0e31853b61160c79f7a5faa90c9ff00e975b238adb5bccc54a5448c6881af4bb557988fbc1f88d0ac7043821ccf973f66cdd193057c1a909a0733ddd566b81098f28c144bf8b59bafdc07c77bbee0f269e97bca1fec2eb2e6e1d44110cc973c12deb294b47c20f48ca30470ed3077c7f5482455b7904dc9d30e979361268645114d1ea34937cfe079168d747f0b6889b91c55d48fccec6aff4ebb54c125199744ca17b743c1b4671fe2314403038bdf3a93ec1b74864b1193911bf3ba37a96aa20deb27b5c96905ea179d5f1f7818f2bd1863c5d315689ad041e494961e38169a391ad6d6d8424fe6df86840f5feae2af819ecb4f990218f4cf95890999b1cb27af71293e0562251b873917aa7675b9ed56e4b205f5da9beec65c25f97ce9dd7bb4ec381383a301172981316288dd751b3cd49caa219e7695a0345d4c1e21e0a08d092b07b7ae97730fc82de2a9456d0a4b61f5d064b82a9ae418b0ce30ec770f9b47c457f1bb569f5bae1649347bb65086d23916d52e8b4a588a269fb1bfedebf5ccb696912602982894af05959d4d355d5df9a4a42d6c665ccd3c146487ddce36641998612dffde12606ef0304f156c1b3e51898adbb1670fa4554a68debdaa670355d2b4d44ecb18b33c49f606f5fa52bb87832b1bfd5613ca347ab0cd0ce505787a42ca5579b81ac0284bb26342632ac6dbfdb21f6f39388f945861ea463481b525290add5df058de4897b3e3d49a795e3d2c900bdbd06aecdffd20aefb94b442bf9e49c72443dbebc78c619b0a7116df603d72aa6c78a803c2ee71cfe8d1c87711ab406df158df1710a8e231aad1230907785e53acaa6061b84d22c0fc7129a21e9d44c260a8e3b99eb30b2ac50a551f2ff84818c6d58e284aec47489df7da7de112fea0c64401f198c44fe1cd50083c2d776c6b450af9fde57fc9a55aaa530e14e136872da36178d6fe5577c5bafb33f564d6471c1aa3366031b2ff36db096de62f1594fe6eb139ddc168283b975bd0807cb6c05de151ee57d87463edf682414023000dfb6bf81e84b1b8a66b4ebbadfef9824522291ee0b104f420168507b8bbae38fc0cb4e47bddadfaba35c155116a49ff4e8546315960b2730d80fba2a525f1affc47b9410950ec49240d50b7660dc3ffb15b3112f58f4e2dab7997f8ee54d549095881bb1045fa83c6b4f04c90837def4dfb068f3be9ae668bb2dd1c7a57bb9bb608d834c9d3f3944aa6c282b88c3acdbb4e220d1d7ef82622e703e14510b31a8adbec95797c4fe9f20ed5b15474414a01c3a0196bdd92f4e7dd1d3253ba10e99490cc84a1e70531476aea263165a512e48488c098855c1e51df2a267398fb124f71be7bc993f65ef761dc6db16fe047bf383f958c666af44ac5d98db7a34ecc7bad51bd9aa4703766b9c3d6dbba3a4dee4d50bdff6691c7d6cf0e47f14ad7a7fe089cab9ef888ff0f4dffe317b9a1d2e61442d85abf6389d5d3f7388a51506bf64b85249105ff7ffffed3b41734cbf79d317fb2e66d0a5b5b0e85190576219f747b43c4350c0c5d217e447468e2aae67b222b103b2208f5edff377bf25ae4c383c5569df81565e4ab90d582e355a7733d5e1a1a0c48f9dc0f5bc44d5706924415b6df592645f7a7b8229fd907ac1bccc671a9a78a373c416c7c99487b88fb59dc61bdfa28ec19a637ddaf677335156b7977f9c925d23437431ce8d3838a1a31e1f100d8b45d4600c7b3bbf544ef665e5e46b61c597043f671fd2168e348028c65d468cfe3b9fd22022d63bb0ab41bc8920a828982210acbd7e51ca41c5f1f87b57ca32d76b9e3299715ecf0548f1eb745da6290bae651edf9ef823bbd10d656c48a8b10c291f0eb2a82a817860b487d5b96c380641cc17c6dfba83c14262133217b73b7a4196b24e50a22e440d3d27d5af21c74ff98d797e4a4b453a4aa4904182a0aa5ac6639641476380c23571a636796ccde6272fafcf74e8ac6e3405131fdcf64458638cfdd98af30c06ded87324158341947f8eb1233669110ee31e5b783ed066e050d6357a4d41b90b646c600d2de613cb512a761dd65d07f73ab0bb1bee859bbe745404efd718d6f7537a6e8a11584e746506acd53517f3740b7834076282e42dc5783b753b4398ffdab132a4c4e4389bfc86eb0bffae3e11a4e438598fe43ccf02e33e9cb8772930d97f98fee7c1bb8e7d3c434ce7ea21f8e9dd7c6f2a10157d9e869eb7fa80b9af1b33ee77144394abe32862fb6e1f6a5b4097e601dc3f540c834055fac18ddd59a401986c0a12738e532c5c951b4827631e56db59af5ece45553107ce5d8ae04212cb16dc791070189f5dd90463bdddb77b78e6f17b2fa1e2c2575ee3bcd830c0d7f8f526112b84c37a49c4b5f1bb704a17058e7daf36fb16c765ab4a1f6e8e1169576eaf0b3085b4cc911973c0ca349fe5a9aa9c84378097cf070a81ad3f2e3204c9994f7db7e547e6845a62ed9fc7d23a8a09c9820817d6f8ede45ea106714c6ff0f612c76ab9f58d546bce9f13b27ce7ce1fb38ae5ca56db68bc04306637bbcf9f468a7b55d3b69775bf7d953d5dd430d5dc9e1421eb65afea861bec09efdd35c25598352438216dd506540a72654fd81116c142dbd95bd11c9f4d6c0a89186e0193149aa8f8fdae4621088165310413de591fb5a74a226d416a60099431628e41abc5654422d8c8d9b7df5510a3fb3e3f0c5fed0619a2bc3ea7af0be8501f6a7fed4dbaa9a798b7c6e70cf214a1e6971be1d98b478bec035fdd2d2a86faa9f3ab23911cb1d59999d326cd61dd12da19d2a3ca285636f8ada03cebdea9c2d60ba23e7a39bb7ce12a542046005b0946f3e19a8a9e38d3aff9b7245d0a658d3be9a2018016e655586686c857af61056ad16c04d3642bcd78f4980462837f54c61b1c7619d964706a18a606cba1c159b3b4f9b97ad2ff9cfb447c3335680dced522560c09c5698847568e5ae70e69e334e4b8f0d7d053f2aed29a4625ccc5c069fbf95a9a82e5808e06f6d13ebd8b2e7e29a620acba2d2ce4149d7fda22be99741ed1805f0d3cd7278c844de33d27a22ae0094109720828b205240415258de8b28237b8fa61f62b2e97d6d6267e0dddda98fd806ece11c4adae8ef7c7177d8a9385c8c5f33733a7416a4b130eb058629f2e71caf6961d7a493f7af5e90ae715ddf39cfab99a2c9373a98a01567f0496ef88117fed968d34780a889efe5b676d88c26ba0534cc2b2e6bb1e4d26eda8db9752f4d19bc4b6a798c647b4f6d8055e37d804fa668abc8dee7b281fdff958d029139cf578e70cdebc87f0f8e5cc17719738b93fe41b1577cceb63726c6f1d170e9ec7baf005b6162929facd5d6f4e1a4c085ee32e65abafc25d95fabd2c27ff391411779091a9f57e3257b5bd238806475310dd69f94fc272f5f2aa233af58f6142b7b35f15e66f9f4cee984da2c063be7b27808c484ec1e1fa372aac7578160914e5926bc041c27b83af546ca79355a68200b0da1bae6ca0f9b1fc35b39ee715ce533768d6f77c85e59dac4e0d76a1f7fdf257e4f9f45949737350cc27eadbe48c6bea672adfebc0206efa78ad4d86cc8c1ddb942db96b77a242b24edab03961864c45a59f4ca3682ab08f4a8ace6ab6f743d08e5b921b2945a7b2ebaf6a8f17a59536789132afb586c7d11a123ed91c777808dfe747ff977a628eba24216d32fd4a88fac431384d41db435897015422477981de553134700a7d7d7873d2aef5088532dac131faa6f7f4e7e8df29472e286727eed1dfe4bfef27a363bf8f8259d17b129607161002ec4f523037caafc5a602e033fc29a66061850617c3330a98026e2000babaafcb690b382feb99737c435188902072926e740a7e45c02fe69795a5e8a38122a4700fefe203271fb291584693cd53118115acd9cbd108d9a9649655b90df5b4c0a9539b0fd55df8d1c31e0d5915ad2dbc41e6c30c9ffdf0099244c27cabe03a3d7d527244ddc7ef28ef333b35e7c75bb58521fc53a2f99ea20dc7496ae7a2c8eef9d66da876ae8f30d3ed7eb5c3f343d5711fe75fccc193823fe4a3e2fe8fca37087e024bbf7da12a38f862b45d0f817cbc75427524abe3b5f383dc4d3d253b46f5e403a96ee65a76f94cbf1f6a4635ab9b9a523ee08e56585bfa0f3b4ffd024f99b05cc5f007fc86871e86171b1f2aa4a392fc325405608899af8bb7bc897120c58a40a3f3607413ed88b8eff5149b81eb024dad24542ea9cf7f8cba243e77b94e6d161c0ffb586fee874aeb81fcbb8b7eba269071db9c013a36e8ea7c49d208894b31461e6a03872196c0ed41f952616b685d1f53711dd782fc2e96b050f694fccc01ccf53cd96f0383d54274d04d3377dc3ca72a3cb3b7a0049d7fa9736fcf0e475560bbadc2f1778454d07e1f24bb1765b5f960454f206fb5c57980348a7b7d7cabc4def4adbf565932cdcf9d9954bbd1bbe4237862cffb5abdf94bb95757346fca4d57f499c0e68af1f4da152a4223f5f8d6a3e89a4df264ab9fb7e278fb0e08a7c9499ff7e36e43ba46b0326393c9c947318ff45f8f03d360957ac07b227198ab3e4fe3dcd451520f64822b868038845160013ece9e5408dd57955b123167d398a76b6fd17975388998a735f07ce536cc560679ef81b798cce603a94c010c1a62682b5597d764916e932677a04df7c7d82092f403bf63de67010092b61470be2dd2fda8aefef3d0a3d36905c7ce5e0eff7adf4e4bb01665731e08eb92b677b9e8b24f98c18720487143628ad4bf8cba475fa38d8e667cd7bd8874e8ca3617e5187c0505010c064182bf2f8a766aae44df8c606a379668aadce4feb37086215b81d62e2ec97612a7734656294c330411947dd23e70b26d1e20ca51328c33de33b90e5a794f814e4d5decfcb8a06ddff3a59da6ee02c6cd4da269f602c7810a6ca59f64c659fcdf349b4fb74c79a4aad686385a7328fcf05d1161f41d4acf8ca1906106b2c0cb6fc5caee72dc8277b0893d221370f94896ea9ac9f222183419fdf2c8f5ea79d7ecb9867b48bccff2aa6b6c4f07a5f2ef9c8a0aed5467a11f9b50128dd76461fffe5214350fc0ebaf1eba8a1fe22774668168eeb600c38880b461505bd7575629e9d4f784b784f85553a3b9cd6b68d79d19d3a153bb352baf4534976cb3683318637217820565b67086d217ab1e20fc1cb52a674f2e3fce4f0dc99393e805f6b5b7d1f60bc8b73473a7290d4a573d346dbdbe7db291c15ebb5011a203555e1d9f7e0b9626b9a98656649eeec739726f251228f62f2ec78e6fad347236ad08bba00e8b74ea9a9701c094693da5ef82e2183d414199e3d51496744fd8cd705c66edd3b1c3dd3c780af93855cfc72d9f0aefd801aa746c8722532b28822bbc4b05bb9282a6beec020847e1537dcfd3a9845286e4786c3c390c5eba7cd28032dcf661ce4fbf8e509d4568ab18ba7854b2d1e356e030630345c2193246f8cb80f4446d38922ed0d66887ef24b3c1e0ecb16097dbd7ff638beeed0e619eb6f90e41928c351104d17b7f0399808e0c6f3be0b524bad7e9e7bd36d63182b2ad669f60e35ea6449f3a86537eb8e0212718cb89f90bcedee461ec9ae94fbb429bb25a5e14b67a3088d9df21186373fe6db84267e8cce28dda3e38f5fd203823882e3d5f6b4982cc1e2972eaf6411f9d53634fbd3e7301b2b2cbab3540e297cfff1a6cbaf35bb07c7d1df4bacbe4b328ee4af8ff1dc11004aa99fa423c51530241d298a702dbced5bac9fd5c68af5908d160055c714efc45d9bd7df78f877accbb64fbca88f9d8ad80b1ce5af325f485e85875e0c8bb2d4e0bd3d69970e1db23ae84fd370adb84e366f08b5249c30a7d3de1ce302be5495ef9d4887285a9153e9e4ccb49f184be89f06a59e3db8625c7cb125b8a5eb753cbf0284b5461c17962a527d0613a54dcfb87293ec193ea4aeb0a425613813754d299a83a4820d3000e0da90baf5ab2a5e80bda028b9acb9fde28a078d4fb22d595d53a90cdcae1b4add491ad6145526b63f444dbef724e10216b7e696739c9e952e00e553bff79ab87f614ee3268abd32b18c0e497b986087d1b34e8b1771e7876a5374233f0571da85ea45256f5b17e65d52734c61f8e12b48a7a2ebf86103018b27e4d94f7c220846e2da18dc104a259e82bc9dc6dddc79aa6785967bd95aa63c7ee848ef0d6125cb9961b830f349d8609d5505fb14c96d8b3f68f9fa08629abbd56736f04c24a5287c75319f34242e67407936379b9516b34e159e164345f1d54254dbb9c596d17333fecf42b8d33b3185634d506e50aa6012de8a7c9130962b3a89f8f6d022680cce37303d4c0477a0b8ed0df56a912d56029ddf955dfca4acc53c85b79c9f23d2e55d636c36266e0282d215cab8d07fc0ad1067d56b8dcb39c1eb3a1ad24f9eb52acff35969b2ed42f34f6a9cd00c8a8e17b592d32df63e5ac9c66cbc894dcb3f7c072f937e29890f490ff064987e696c1aca4e7b7871d6e90cd20e026e8864d5528e63289818e5e02956dfd3b16d2fb9f56cfa6f2c1880cd661d74febd74be56ec80795fca78142b6b7920b743a8e596ade432dda7927c1a5b5a7ff6e8d0fd9b4c80c7e42088619d97858314da867326bc13fe60636c4714eb0960a50b2fc4d0375530716ce27ed5bb825eac71df189dd413df42cfbc0d1f5f78cbeb959dcf4b2ab5f8ad136cf29af4b9d836f23bbc6cc8429382e2b59554b4c835552518d8f3cfe36397960712acfc195010bfe099b769c5d310f712110449697a2f5ca0af04f80355c40f57892237a43a6402e219bf4e8695c3f9893a65671d9e22d312de4112733a7cbb46efb440b4f2148d7b407f4dec9bf9fbb90d1196b45ee257077a3ca64adebef7efd26338487d9712f87c59a2f21899123a248d6af5b8b3ae8cbb6bdf69e5567f75b2f6b4871a84ceefb57ade81dbb4dd80de9691b1e7537555aca667f1018b0bb6f617e183a7c8e33eb605f95917c9ad000c52b4675805b6b7cd437744641726017829ae4cd1767211dc26237308f1ac89d652ac6d67a492d723028c24d0bb6ddd14b0489481fcee60f7212b2f6e4b2c0dfb78efe9713a3f921ae4ff5ca51d59a3e787328be1ba7a0f4b87239495c7bd7ed1ab922f37c4b41635017d2ed5a675fe4d48b38d19369071f2e2d2d5499933f9ee2922f58a8c3b51a7ef53f42933476ae956263827ee3151ffbf99cef4411170c441ecdb07056c69f2469700b94c7078c0a09fb6c4e947fd40ba9fc780377ace16c3fe8c9d012c9736ef377a776c9ad936f0039d66cfaad94601a213ae15fdc5222aa32e392eb9590a9f5cf0b7c46888a4caaff111a922b3aedd62d43432163b7fa4270d2b17a8c2b43e92751578068c3ccb89aca8d46229467d003d2f7b487ac5c8c74f70a8056219b2ecf9502cf7b89c3455bfd2366fc4fe1fe61ed5a65c9c5d0ce933752f2c6244234bd34aa7c7a1f49800c211d2df268a44e44f819d8790f0ace610030812c949da80029a66ce45a054f18ffa28acec8056bc169f6c9cb27eba68adc1beab13eb38449838bd049426e9be03aaecded4db5e61542edaf49c8fb2939e6ffaa4f1818dff38090be53af71c101f3c676840517411fbc804f1ae9e1a5e3d2dd9ac8089ad1148e5af3a553d4235f51357377360696513663f6cb176d0e550918e06a0e66a13fa134146cd4b11c7891fe3ed80ed8e92b539c5bc6af6e56d8599ceab33cbd03052ae578f45d27612b88ddbcc3e2b3eac04868abaaf027595b36144a680c15113248956a1af651e5af2529adcbcf8cafa9e800dbdbfab311b36b8c9d976fb62fe2a401e6885e9dd81bf52a8300b48a415889231b0561cba5f4d044bc72ab2a888cba65b042c87cf7423ba3a0a09ed81e9c0dd4c3859bb2ba315179169ec49267ff050e4be6ba7aa7c0b99b1f9d15afcfe38c3240b8865228748bc38f93c619c5c0c5dd35503ef4fd404727063c659e35a447d8be5e6b47937d907b27f6044799ddb93a70fac4a82c4b665cc5ec5f7c90d98456add8ab3a2a502559ad12868330debed658e9318795581b1995b848f16afb2bc21a8960473dddd04efa04f259d3bebfdc9c17b77243c4210dfbe5f230c699b609785b38e5251757dd25179f32b3f549ff9d61e42547fc321ec60788d44f9b7cd829a78e94a63e27f0b41c422f4db12702cfd3dcca3cae77f0e2a5843589bf36b56f6a8c3a80375f448876f9935227a428f61730ce8fa92b10d17917b5a36c6b9a262e2bf1df1b9676ebf7e3549ee54faa92351b5c5e7ab8453ef2a77be932d1285bf84a110e55c0cc916d6661c8a070cdab10bd40931074bd0f608344be3d65c457e5426b123314ddac17e7462ef48601da4fe9f2e2518af986050954814e4e979e5fea3cf112481a74ecda83e6215f227081db3c1d44a5b4303d39674ce3a4cf8763eabcae7a4bcd0a622cc3496533c76cd468d00805a1f4a36ca6035566aaeb2be20f7491f6f5b33b1147f4aeebb4ac907286616a4fac0e29ecf31eb8eeedb2649705a27ccee051dc95b595540e26014b382d0697aae87947411d6a2c15350536b64a5f0892800b5a6c8e83a81f651a303b1f35cf9516c289d7fd1a6c75b2d1168f21c718618062a925dcd7855ef656418c49cfdcb62591681bf3e170af1951322347c7dbdd5dc5dbc34c4e17762d6a34e3b55b73699ce70be43e647a1deb23ee6cf9ae077e3779f9f2e687f25996fd194a2937719c6f03c1deb5e27eb819fa5b8e252848a2a00b70a66e44ab3e8e18a0cc703c6557228747f1eda84dfe526ef800abc2bb186a4aa46ccf6c471e0235150e505f2ad2cad6a84e08cfc0bd0aa7c4804abdd7ebc2942edcd3de369cae8233dd8b5a6256af7c1833744ec805ad539fa0e61d525404c7460a34b8629c93541262e0dda52e477df6f30670c86094ab9e8b82e17b8f42589b06006ad6eb218d86862154efe94b40d1289aaddd17c1b90057fede392d5441c98ccb45b62575f6406a295ad84317db0568ff9fe3cdd670453f4ca215b6ba136c5ca03ac29172d133bad916a9c65c8d2879d3bda9bfae4ddd210e27bd77688bac535d4b6a23e2e6afda04c0eb6b3b0e49e5c7ce3aa0b69195bc1c0111b80c1e960fb7507ece88c569aa53bdda57d5e951f82f3f6064c1e48f258674cc5bef172081b27a47ae612880dbf207a39a13460f73828391a3bcbff21f06d8345c6b0816faf056ae70467c73d6a654cfc88ed6f863535fd8ab81b718ceacd3264385ee9952266fb3f51add3d58fd66f4a2ee7d156c2c4746d35dea96466cbf0b99ff148b7884a8781c649d35ccb34247af04e489496204730ca2ec5aabda668054724583a41229bd4941f796f2da49185d2736c72e2a45e930fff710296690119a3fff41368d78c1550f466b45187da52dd8cdca7acccffdf5a73ad9fe74b8d22d1083a445ab9cd465bad97114812daaf1384687c9795a41c0418aec2e0d57b10e1c0f2a0bc629bd8ba63f9c6f60775bdcb27d63dcb4752d5a2d32d9ee154ee5e9477f72bce72c09b493aaaab3846b27607eda78090f8f427e589b0f1d9259baf558cacb00c4f3c60e6e3989ffc3091085fa9bc642fa3fb8b62af377d072c7785b7a34e5eaa32bb5d5caa71401c4e717f5431fd0aa9d1f302b8eb2749eed220218211f1a5129c252927bd44e0b191ab7dcdefcc552a948204b84e0740c5dbb63f3f377e2907d7cd645173fca0329132c5e7170975ef06bb52ac1d430b973e89fe20aceaf1394db3a45a84d123ed441f517263078273be7d2bd999cfd52368e580e44ce15798c482bdf48622de74ce56f5190e4b35cbe8d4bd572061ce06d7bebff8a51b55d2bf593c6026c7ae0d5f67829ee016d6ae0baca78f65c3c4bdba4a58e32bf8b7152416eeb4515b407f045a189879f35224d68081aa71d22a801067c83b266f3b60dfbcdce95a829285884b1733392f3056f0842d2cd66a3f4692c0b42383a36e797d03eb6edb48d2249f135ca33ffc808ed78976f764abd381a9d31610fb0fa6367bb86cc403dbbb72b15a1aec55c5be6cf49960931250c1512284511a6a733b76447f3520a9be1473db0b286803da1395c03f1c872851b35aff55ef52506f8633554e9aedd26ef04f5f75ba015659d19d1aeb7a452f97ecf1bcd6a05a53cab9c4117a40dabbf735a784283df7f11f07f1c5885b610214920e3dc0bff10251cdc58a80313142d1bc82b54a2f914a51568e1f2f1c185ac2d4f4317e580374a6c39b2a858c073cfe6127fcde844de3e9c4a56685bd4d119236bcd8ebeb3044ed9dd8221a07dc3516d7ad95f38ab17ca8d8f2d66d205005f1addec08aa044c1242fbf23b070f77f5d05ba3ed1c45abd30b9b08b24fde2bdf6c9f33f8d6b5c18aed21d062527213dbb5600dd33babe9783a398575014205bf477950b3762da8025a228d3782719e77ec97aa3fda869a88f8dc4de094480dfbd466e6e907705b6df9b3668ae335657b5540887b37b2bc80370a0e7b754399dce18b52f9f7b4ca53cf3af71654d3214ed7a427087696c7b523abc3eb4f339a05df5d4f1cd76357f72173905da799d645a13c5707d5a4dbe07aa0da103fb8eae99cb40380ebe2c166b2f3e3571777a502e846a57bb9ac3e576c55b11478f68ec781498fe64191d075757750ce7b6e452a1e15989c7518e34ade4ae8bbd3708f5bf9b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
