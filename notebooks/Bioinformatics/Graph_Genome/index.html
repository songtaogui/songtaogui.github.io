<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd6087eb048317ecb254a9760d6253cf9323e3559803781bda483dc0254c90b0d611f91ce5419d20ec4b6d9545c714e4e1123cf3727fcdfa90896ad612513d1d813ffa360df86f7d5263433ee68734d273ebd38c12decdde182ddede76a3678c9d7fe55b06423e23c672e5d48c55e0074ad8d95acd03ab09528477a95dd9486516c9f51a37bb1427ef86287997387ca6087661e07b8f9f1432434e57e2950b6d10e9657a7aa6434d981870e7bba95270b69026f0841cc7a1d1d8b6ccc08fd6cc0f6f67d46fbdd90a00dfd01987db403636c6dd1c9b74f6621ac281e58643bc8c830cf07e94083b41dce96597dae81900edad7f20b7f373c26dd07f952de9c4abfccc8b16ad432fe61779c2fd4b1b36ee40c9b462c213b916fa3a6783a556fdb4cc95c98a49ffe384d51c0d921cb6f66f81fcb07212d10289dafcbdef838d88551cc9ccee8b10decd787337bf0ff5345114c2724f436ac1d54ab5ebb360427c4b5d7e00f87d687de5025b5e4ba64c26656b72a21a4b45927834cce3c067ba9d3dab4f761da06dea824142f4c467d3fc0a98177d31f98aa046ee2203f24c5d67646c69ec811f08511d30e23fabdb0f1e84870b7cbb1fd53b7fdc6e59705e22c6add608c66142d8eee7994ad536d9a77d0002bab8dc30f5ca786c2f4aa22df2708011310d70115529a677f3206f6faa87ee8c42093ff6b6487e38b9c182542c9837c6bd982f1926fcd848f2b19792579ed3e4ecf51ac2f557619d5966d8621da95dbb7269454e84fcaa5fa0817b7b61e819378075357c23a3658e08bd071bff54086e0ab0af15631a9093fa2c4ced1986c779e0cf23e8442203bf995c1e0252e3cf4b3516e9048b24042c7e7fc7cb523a4a20ec1c0ad759d68f9ff68731df1c781ad026149dda5729f1e3be6f8580fa755110917e4cc5345bd6d478667b1d48023c235a85eb163ac56eb1a56f4ba999d7a7b7b75e60161e44c5d4d3511f3af0d3ff90138a5f4b325f35ecdf07cdd6b84d88918460f75dd0b9beae4dcbf77c09758796aae3a1ba3e4ecab5100e86c9e74d18e62f02d3e9e4d9f54af488359adf365ff33b637c0b2949320e4eb07d2fba3fc784d55b360cb1df27adee869a0db323ef22104cc0c05a028e2d14f5fc4ed143010f4562799aa064634df6f20cfd38dd3ca5e44812c774507d8046dfdb046a1231f4e53f7c6e43813b1119451752d6e98b44d54a6dccdf6c6fc9d33d030c31e6c7db4d63c3e2017de5d3b7498b48fee8278c1db9ed02c1441ebe1337d08c29c4ee0a8a3f070e35a93c6af7e0a16d5a9110616e68036c46c748566fd24959af17d49c11a8e76323870256ad169df8722dab9e8aa61e6b35406f437178d229aefb3c60cfedc863be3f0b27c3046f656e611f8cd5e294af80c99285ac209cf3e44102fd1ee504acfca6e19e38de27fd1c273642ba35060a2797ab85432f36165294d16af5cced5a6bfda6eb5b99f660eaf21b08093793634bbbf16a3df099d17c23b95ae2eca6a87529b07e33e6e8137d5ecc7496ca398b390b1925252bdb657ca0ef4952d75e251cf99da02fa4b62ecf8fb56e23c800c19b09f530b1996dc5498d7f6653b84136d60495127823b2ed17b37be116a36dc4fb446dc30550e7d45dc75c8b7ee9ad2cfba31bcdd4bd9a1500b464ef32e2656292aca74cade9e621b151207bfb738eed584f3ed80e22bccf2ab351a6b02908df574dae60aaf42eafb5a4745e8678bfb9f8d474d8d2667e3245e746ccf18c68486993df0513748a2d872d1e7614e094107936d720046ad36c469861a8179c6efad7387922e0f483addabee42c10af2cb09139b9cd8202af26c1bee919a19942fad4a2af419ee65eca561c584d7ae14c0e5f2e04c9c1d284c2a7d33805c129ed1fd6d312c0a82e11f3019d19d819d5b3856f66e8ee07228a5490640c69fe28251041da5b0cb76f8b2f48b1a38662b100786e34474bbb61b51a98568566196411a908276f491fe034c0cc2b8810fbeb3690f65c126049a1407ba34aabaa9e01a1ce452a74e4c5fe944ba4ffd9c8e27cadbd5bc28a0fec6bb8d1b9f7beeebad8421f8d1d62aebb124e2cd767af3711b7a9725c2cc223c1b790a7805bdedd5b605820b69557179d1ef878ff9c29aae0e69ec0be2d760951a01a855a58d56509677b6e7e4bfde05ec4052f44ee564173f6e0181832ca1d30dc21c266e9d00f9ecec00614c14d6c7978dce2c2ccb114c6e1b8c32c29518d757c3821cb1f9e0d259226669ccf0cb10441116044c1bd9fa67a34d2d6da1164e65cd1e98f564e1f44f796de08a602f1ae94dbcf676f57fd42c605fa718eddbf09dbdf6e0e28340b37804d0b178c64cd924b78485713016fe889c1b68c4c646f558e1de3495ded4aeaf43c47eb8179dc0e9afbdd8c8e33f8ea022dd33d77473f1277700635cd32d62df12d99aa225b7279f3e61922648cfd82e5403bf2f97ef0e73a50bc8f4dc8d3b5fa0a8bf3d089129d640461a5cb8272bf933ba8541d91961e74b570f830e350dbde07404ee39b734f0c616a3f6403769a5d92d67fe8192dd91a01cc805b641a4ff1c4b035f480ecec4133c97fa54a64656d1f86caa660ae285405b5d7cb411b126f70142ae22422d3339903da72243532ca8c68693f4c688d453a11be7d6d31e28f356512d01eb95a6116407a29f6d841283efb7b177f6f3922e6c72e05d29162f783299fc2ec84401379a8dc09bafeb18e2790f160c257c1f3bec54e81d221014efa978d6d1a7719ba0880bf28cc46137347a64a4e5ea10670d8668afb9b610c35f9caac2394c5c87fe665bc5750c4b0f60b6830f0021b8244531353b40547e347a3a185531f6f5fd6f37e773c013b8f4c0062929b8e2ecf4bcf4560ca1ec10bf74fbf578b46eff52b0fee940e6e0d67762a04512a766abd6ccf9f8c314834bc79d90c835234c69966ad0195e23b85c37b44b053018a88e2a3c32408710ccc81aa79da6cfc470924ce59d834a0fb62b447d64349158e12a9e796ff3f9135c8ab52e6cdcaed67c7dda07a2508a6f98eefd915226f811e356056f3b15f89a14b8964ecb6b80a4c6cf38d1fa116a2be13401ce010d0cbaca5740a339d2e43950eff3acc58b961960e2352cd3827ff1fd3826373b1cbfa2df8308118fa541b5ee862a9fe40548dc955b4faea53460bb87298c69618f9f5ac93592162c3bd3fc8b82e6d75fd31e0db147a42886aad72ced3ff6f868ea8dc7ecdc8f354edb184971cf4f7fa246b8f3a5bac0e070390e74f84fce7651f4e83d72d71ab8ac859057f8c90e1fb30338d4bd8b2f46178aa7768e09da368bd9389d35989cac2787226e00d37294ea7409856e8ee885c881a3832e6c46d0184dbfab4429bcaf8b91c73c238354b8a95a2e1142e089dec3c32e7a43fe615cf4a2e51e5b84db83a431b4362ef7b964449bc26cc276dd6a594a0fd2fefb23c7a1f661acdda9f97bcfd9b719d3f7e3691e9ffb131dc84dc1e6ad257a29c8f3d4a947c1d2e8e89833ace7068e277c75e71101ff62c7ff041fb73e0b611676cda2b294060b9ba426d2fdc8a019fea7d38fde17e581fd6247e159e135a7d8793da983431ae27306d9adbcafb683eeb57fe8c3f33febaf1bf2970d0c5e0411f4b112899391b058e45a7642be9169545eb0b3ce341f6a62da16b5e535a3fb45f1429687564e6a0d67d1d0ff134e620962d791fd3d430d66300d6ab364980c7eba43ca403d535cd1589a9b3db0b679185751fdd92e4188e56345dbd80a415c3ff354a9da03959a0880de87102e405b889b566d7d5858e0677dd52ec88a78d1be82f188479489e6b06a123ec400ae4bb4ea235b3db8be6d8e23d69981f939d9a13e956224ef7e6810d2895bacd0265d4f0dfbfe0a0eb6af2a0989dcfadadc48fc2d578dbb1d375d1939293a238aeef5c414636c3d3119aa4e5865c934c86d08e717c15858fce9d976cf0eec9aa6dec8eebf183f1c3e701e20f9a573d696b5353cef30d2fb5af6c4375533f301852d97ebff7609c754a7146d635885b911aa064fb3c45172a9f808b22be20ebdfd705cdffd9d4f7acb7f666ae80ff3396a4a83e2a5cc165b50a31002517d8ee22beb5597d215eb15406fa43d75cdbe1f9d2435a018effdf100555e157c7623566c20f132a293a4e6a48f1ef4b7ec44c3585404e6fdc10629a4db6bd28ce904bfe19c3fb8a4da45099e078328798e6ef2576f1121e48ecde659cc6a2071c42748fb49f78b8d964dd77f3156c36fe1f6b55450951d62c80c549cb757323117fbea2552d455ce36ce27db6c2ce3986405a611a1dedac0219b0115574e615b0f42bd5fa2b6679d1b852eb4c364d1c6cb1be4efdf6af0888f15d3b7236318fbfd36109daf990f1ac5cdb6a3d5408e591e695dc95738b1a1bf44f35d7748f058d9f7a2a29b5c9c965547e3f6478ff6d8d3994d0d6ad16d958a41583de0086531c1947f305ab0ac3800981bc004bb5b1951eea7050dccc837262130f5e5963a3dddda02bc411c37cfe09df0be93db50610fe7f584ede8d0ec7c2c4e548854c616c30b9cdb402bcaa7d8a8ead9aa4a240e3954d21440770a6dcdda09474ece3f3c4821ef9c7ea6cfada6ffcaf5aa92b9e9fccda569a457475ac1a32e3086bd16875cf670fa3069c90028da812d4ff37501cec07f1ffb9645b4812548f379f31a3cafa36b19fe51e0e0701c213a7e773ecfda6e737384a3896651e25a9812d506f4af3246383d05b23765e55204fe5c3ff0649178ecc6549a2633d6a5f7f99ebe308669ad34f293ac75af43e45060e8d5beddde10fe1d0cda59c124f54f9158ab4195885c47288b92f13e2311944fc7e78ddee8997ca1aa964ec908f75fc8833888fe8ae367d0250fc43fb883c44e7814578b27f42a526992cf9c69cba91312759890c66b2175e744f6a07bf60eecd4dd3ace23e6ea109f9ce70c0f8edbba109a328d1df32c172aba1aaef76ae1a5d76632a0a6a10d4e8aa30859174d126bb911a9434c3199454fc10e499139b93dc92d2131d612ef9efcc4bb1cbd40dbc246b2a9c8e093e4c2f7a7a9b5428c955593658095d162cd28dc73dc5bce0bfc99d5293bfe0663e01ba83dee74867b3248cc1e1bba5e962dd893a716102040e999e67d1dd45b454cd407935721d77c2cc5e07013efd741702ee167539cdebf776dbe1395461398055015d1b8cdf09dbea268ef93071f448bd92e55bcfb5faab46ee10236894eab24004b46d8a78144c84b43b029a5a0c6663aa8257cfb1b611e21f7717910d929b34c6e18e537e3311fc113e151fc17308c23ab9a713109136232bb201a3b1803008c723633b7022eb2f8cdc977352116c9b1a9a4378ae4a193bd43e64eadc38e65bfb5b8cac563bf918d31fcca25b678ff7070ee32137ab77bdf17aeeb72e52b6eaaecbf3ac15ec94084ce0e5c11c9656187619db2ca730a1434e08404cd85ebd9087bbefa69e832914d2e9907d46a6864de2f6c53a6718af7af2640b9cfd0c85361c8bc8d397223a477522b1ffcf50cb26967af638fa7758a35f6637c0eb7e407d67ca3cca25372259fdaa56dc272ca7205b511633d8238d628061b607cdf68f1e46bb7fb730c2261e6613775acfb38d4dc1bb13cb7ee08e7ea33e7e4c9e92d49eb4352e135e15dcd26f96e192c7a232459f409564c73d76284128d338c5b0172c3e924f67658d07f355d768b8ddb4dedeac2172e1b474c74a7187208355530c57889222caa1566fa6b1a8e0da7f6324ad99d73583e1a1ae09b7eadf31aaa3ebc255fcd2e0bafba3fd8cc37fb49ffe3c40c8ab74776e22dd03f612e7dce0090bd0f37a60ca0a7b4732d189b2b3207355b8f6c518e6b5b148832a0910c335ae69d8b0a0335fad5e3f59a838bee5100aa08eea9d859f82f0320dacad545c7094cba5b1a2c76f12b4e77635c9f4c24124701006c52daef4b20dbb352245b7069f6311ad8de14af6ec89328a65cf581f010e1c657505b584f08c39fc16bd9dc30c43969d1c4fca3bbbe1def68fcc3cc05609a45927b0123e069874f686ba8033f6c90c239da6667ed96b1008968e64a545f5781a78c413f66231c90a648a56bbecdfe939500c35544414d816bbaede3d0dd4bc263e1abb9a24705a00ecee360ebe66d992efc1101e3aeb32cf5f477bfa6af9c8307bf0deab23b9b3c1b8617fc86c0189b1bf3986462a7beffd88211ebdbb4411071ea6cdcc46f0af1131c55392d91191cb0152ca875ec325fd8eee6a7059c852fc1bdbab9788cfd1337f9e2676d045e902ca6c3832d171e7d6a29faa6835c169869384f94d7ea6e40de094c5b02daed3f5b7021ca2e31f7c2b49a626c4f393c1889cac4b0b559fd0e8b0add7097c7a5c997749537e10deb7bbbbbe840184da6b7e1595378a654a5aefcb5803cec999d51db56b48367e1329343ee9ad08a3d896b377bef0a621de44eb79132a6c21ca3e163d971613371453be7e2c3f865af1a6dbb7e32a5b1cba05277afd613a53c096667eac60af46ef2d69cf1ce41186ed39d21f89f3d4fe1e39fd9a3e02099e578874548b5a80da909ca677bcb01f4bdd310337ea2a1afbe896b10d51fa9b9faf28503c7c3758b2d8f417a556969e2a7f658a61fd89dbaecbb47bd37a0f9b80ab4efb806573e3e13a1dbf813d051897a3706b42cdd6c18f54240e4e933cdf7860d8e5b337294d0b35b09cd20df3b4c5f6225d24a1366f3e959505f33ea6252844bc95fafdadb5d1f06ecff432db1c7e3d86f863d90ac61eb9f5c4e1738a8524a1077cadef6b556cc75ae4df5b82b8e6f59bfffd8eb130b570bf74371c45ee4cf91f2d92d71607d568c06217f445753bce458a129172abbe282fd363fcd4caef631a3afae8f0ce0a133f005f74cd9a8de38cb5bf99fc2a60e12c18b8108d3a944c36be9e7102b827a0d615dcd592bef834cc458a30f11b8a37bcfa7ae49e2571ba11a5156368fe81c21b7fbbad28952bd935cb6fe534a9d23e57689ef62ea0516b1721dda9f30192b7ea317b4a56b20237fd7bb6297aed8339784108a473b279ae5d7305281d8b0e0a56bba83a4d4efcd85897f3e75ceccc7d556c6dadadabb43a1941e1d9c1d3c16b8488e25a876151cbf0173f71acf4b107508adfda776d3cf9189bc5c9a08ff61737d61654978dc3ecc35b2f47bd948e5fb37b712ddc6535d56ea36a56c715a6800f72281b514be5a1004cb936098afe04a763ef3d97128ad322f7aed8fe727c462cc164855fe2f6c41ecd9d4375c4a1ee0996ddefa01db791b6fe9d71419089e26cc5a0e4078db1eb872c18b5326a3602890b9ccccaa665d67aad373a9e30c0a11ee57805569a45362988f97876c57b998b545aba45bc39a4f189640178405b0d2fe9219a0a3d028b415bb860968986d35f86f6fddff2e01eea35cd96318ed0a0accc418975468fb2e034757d14985e399c47e93eab8f6c8f17dc4bc8694edb9e398e62aa2d58f087dce39975254e46badf33287b4864034365292ec55ad2d9a1644249e2915cb91714ad7655b72b74d2f310607c451d01d77a81a71c219c72466162fef39ad7a06dc07311992ef69aa5ae2246bb5c4e51a7d65e0b6d53ff3e9525a855674ffda0b05f78a3ea73e75d5985e7106a6f81519efd93b5f4ec7e0aea35573dc00ae1a2f7fe4ee89b50b33bbf1c06ba2c98bb4b9760843c6161812c74a708de03b5a1caf76dfe7cf3270b13dcbec6cecb6ee1d42c8140db639001a5258c6e14c9afaaa35cb569c95b4fd10bfa8b91f3156752d42795ec8ae4dc5fcd11e60a35f0448e8ad2dd2ca32ca0de9af7a30ea6f13407f694e20d068e2eb6db77bca541decbe91383930167e18967d2249c66b0679a67f3032271d76c5d26d6c1560a2d9b27fde56e05db10500dd49488263e687a6e1d926bd1939a62374cc2db95f4603faf9de281ee75c147c32ac1d7b7e8d515e8fef7d8449a7f59d270d15de8c717a5345039c33418f3ac5d8c9c8fdf1f88679a7d28afae3c3b792020a6d49b0b4deacc8d38287d22b0fdef7f2d5309e483ad9d76c672c7a674778875536f3472f709901f0a7965c51034f258690703b4bfa427f1d5522b678b562413420763068811f5c3f265006745ad7a7bfe83f5564a7f73ddcdf903f36ffe1ef5b93cfa2f573f3b076101eaccd427d53830f823af2ff3623cc5d14b8d002a11f2388bc2cc0de7b635db932301986c27bf17b95e79d1ec03557f154abb326200d78e65f5f5e3dabb47e362ac31cf72f7d5c9cc97aa274fef632821428f34feccf3b29851707025405ce0b3076cc2fa151a140ecfc8ce1c016388113a26f0e19e3ea55c678c2f31f7e92fbc395886cf8b4e9dbbc2af62efbdd46b0c1ac2dafb9d125ae631b5f0ab9ecff81d2d9a9f17ae4d12731f4f8114e6f9de9801d4ea101d82aa9bb3b95342f1af813cc267ae33590ecc8da65ddb0bd7fbfa6c53b2b943128895ba55f5f66ccb173103ba33cb4f841a9067e296754c5f4b26d99fcbac534c1f90131b724539a874de25081dcd4781539df3f8ee7dec8e662dd46a2175c551e19d32c3fa2ec12f622456e0365d6d21a4b738735d509fa6f99fc9fa62c85d088a88303c5e510bb21c6b64fab20d1fadc1d7a19f40493943c7d35a4e845eeaebe215855bc4abd81242a76901a57b9b96c300139c3908a3a88f7318b8329d3c09b48a9eba0bc6a834e0c600d0aa3102cc2fdcb449dee59822fd9684528eebd137b1a9af6d1a444688ee77dd37b5aeb0f5f27960fdbb53439f68e9b76fe132e7f67fdcbdb97849add7230a900e90f190ed7c9f4d322054a6a6918c84a575d2dc8da2220f0c0eb27232f31009e493db57b6c7c679e3591faa7464e4f02d0dacce9670d25c511779f02a7478c2db15980244725ced433b82308c61da30ead5933fe15e77f12bcb73a5203eb2c99ce9111202d4b3268ee465fd4a60794136909b80a9cbdfa44a9470bab4dabf7946195b8bf64eca62007c758b8ca0aa7851689ce81270b08fb753c0dae376cac032c5cf12c4fca83b7f75d05bd15b4012c804170bddce7603c891eb5a22cec274f78f4991523d49b068fa89abb20035b1bda15afe9a313aefb58df2737d63e58a048579828c946e5edc1ed86d7cebff5356ef2aea30b7637db17b45cbbc4e72e63dff0c00fefb3f27c6fb2d41728c58f49e501fc90e5e167eda864d242b31845004174b19e33b5c30dc953a763b98ada5086d901e90c671a5de432570a5bbb05ad5cc55a56ca897d9e0532e107adf822fb4f4fbc542ad76c73580055d537fed96047e682bfeee645af52ab70afc698072ee88586c958ff2267cd7b8e5faf403253702caf959839550e1144b407feace590c6d5037af539c8163320dfbd4fc5ac59033bcb6c06e2ff9446dc795ad899f4551b888fd937a07720f5baf5bbd6b9c4f18818a2fc723d6040ebb976d9b74868d2089d2de21dc6cf68e2350227111be2e3db3bf0d58bf42050a60f00e032a907b78f6e89eee88dd76af81d3d926a9e3c97dea116399d92d9d085690c7481119af87d66123677c8a1fddc19959f02f6b026756a60bff23d84065dc7c5076390abd67efcc5f48bc127e6f38e892972087bf95ad34a38d54d2e6218234caa97d3c8eb2fa877fbc0ad0b609c5198beef3edc6c409c8762c8b7d90d72cea3edc13a615c5445faae623285f1cce39d4be5e993be66739c2eef5999e706575dff4b1426ba34a9613a93fa7db31055f072320c1d49e0d1366560c5c51fd3d5b83ce32eca2a305c7b4f053a30ace9c5cd1ef1c63518af01de28f4324f88e7a950b81a8b77b284343f9b55c2f7326c3f1a82079d47d3d90a41ae94633879978d743ecc2b47289c2455c5a4a44ada37882b3c5a0c87b580b21e4057118c42769a4dd1b41741a25bddc71dea8b30b376c18ce7c99169aa761a2130341fa26dfa1ad02ae3d98ddccbbd50c1549656aa4f96e418fea0d60699de59ba68c8d10bf6e2caa89a4cf784c8de5b1a885e1eb9a3936bf9bae35bd15466ee2646f8b0bb1e9f4aabb3f1db9f5a176c15d47ce1bf4f563e754e0047e158dc33ad63c79e71ee57086fedf5f2cda00fb51f8c3edfceab9ac246d3e60a1da1a0afddea293260d2124ea4e14e0a4f5bc29401d9ac80dcdf39449ee762eaa6c1e94469134911fce4b0f52c560d755825c79ea4b388201c101fef07ecb1b404448331ff97b4a97965476bc155437b0e2cb0f261e03999acea12a46ea9e62314fbb3966abbe8d6ae86a9a55201ef5e9831bd44e3e37517e238ee61f98b21393d3f0bcc34cfd148f2c6e4518f2ad8c117db1442c66f4fa3bc5eef85b3a913d01650fc579bbcebe3a8a78a2a80934d5c9f69884cbb3d226e0a3e876b4c51f2d5a0182e6b424f6da8dca9bf2cbf6334370dafba95af261cedde19f4c8a1c208206eeaaf5c656ad426ff2c589fda7d717b6c26d5e0db69d4ba4226d30c125effe6175d186077a01de501bc997d0043b63dfe5e1f8329dd39477419f3e55e8dc2c4fbd5642d1a24e023b71a7df8fbb521bcfcbaa881aaebc971561b10fc270a9a5aa1783e2525a9053657691121a99ebcf47c7ac258ae5f42f2a49ab85360afbbac857e8be82373cfbb50d5f66bae56f3b55f22515dea0dad8e5fcfd3a1782aafc6347c57e94bf97dff5f85db316c6390f7993fe9b6253897e5a72cc061dbec40755d1a179e2cf5e5edf04ff0313c9acf25b3254f87f5313457dfcbf5e326241fe70908fe2cdfeda9d7aa7c3f3ae4659fef61209a190b9f5e88b402b1467aecc7685e3003925f10d554f625e20f78550ef125107c884f55d568a50959bac9a9e524d59d215e64344364af8a3403df1b5a92a69ef41329c055ee8b56ed0d82e588e436e443278218c9348cd97f2c5d974677af7b692b58dd1b8658af0487b1cc512d155cd08ac6ada589115a0aeda15f57ef2e10228efea47b7009a2ba7886f5eba2dd38ed3d3ac35d25edd6b83277ffead15622e5d82756fd3dbccbb8159eb4b998d41b69999cea6e4aa90a6db431bd6d60b81c52aa79ccbd608d3cfdde5329dfe32eb6e42305249f12ec53a509085c3789284f62490c6046eb0b3fad8a93318fd7dfd54eb9cd771d63d3d90e3c2848998c9ea45127ac9967d80c77b9fde3a799895806b67d543584da64537a79af6a9a6190d1cebaa8231e90a1b69bed2c5536b2818177f3286abd6b8a9e913f7ba7c4a49d8eeeb20bb8d91aa8a5fd78467fbad88ec740d6b74949964273bb0f5af2dec526aa15f4d38b4074050cd2ca865e3ea15ae57b78aa07e842eaa1be61ab2aa37640fe68a964a8926dd7fd1b5571e64e1aaf5649efeb81dbcc67f4f191c7a95fdd4a6ec68a44d6d2a7f1de2bc7fb29aa502971a168c29721102c8de2457f92f50e9d1180f9c4eafb963fb3efff0c077440cba5d3df3ddb9f7afd6b6ccbfbdbe72c19e919e67ffab96c5d65b7f9449e10325edc915bb96a36bc9e3ad3b42bc6d7e2236a2a247ae0eef1b70b82cbee1dea30a193540525c9812dc8d534f1518f454ed2647e4485388121c9d94d73f68d7da6669c3c7adfb1993bd58a43796eb027ce18775da4115045656f2e3bb8f25d162587dfeb1abf62b848e11002bd40c0e6a05e1f03e7e262b636a33970ecba966982c597b6f7a03badaad3524107d98770830fdb3d424fcffd809b7c266bd1fa6056c5bb270403c33563c6468d24e703351199240ab9502b3e6073b4f27383304e24a9be284a706fbb302da4db12229ac9f5a5d35c9c73a77fb94546d25f0f73de867adc1b2d3906136c86f541e1a04315d71fe20a7a6ffb803d0fb5cbf2006b0e336f53d8dc6c236794cae293593cb1fc5300df5ceef7983211636c9699e81b7d9ca05193ecde0980df25540909658c89940fa7dcead61933a76e7ba36d579ecd2325b42059d105d942f04d54a07b4d6900a05f1e646b745ad88690bd569ba9dcbd70448025aaa8fd082c6fb9e411ae79a7fb9f83842b9913e2564b9b9f996f10109ec587f26db1da7a1272f0827162a3dcff326ff3f3158013e0f010078b1fd076422835dfe0acc696925f11a6db704430bdc85a4210fd9a864451081f64badb2acc697f6446b42c91103e51773e8234af896f1c40efab8a850ff9b1f50a3eaf8f2e9c62ae82a97af1cb4957b1ab90e627107fbe2d421b2365c76da7fd474374559182167fed634ec5259f28297720128cb318d83aecef7812787aa12495cb5a7efa5747ac32fce4bdb27bc392d598f8d1ed6abfcd10a7ff6e4f290ed5e2f46b57fb264bfe6c8b676fb9760485ebcafdd5ac71f69b30a5d30d410fafd80ee0815bb48d10e1a7359126c5663ca01f1d3d3f690e4889d4900529b9620d50bb074304cd0314db7227e4366414da28534768214748fdec81b749a28d8e544983a9c821d50c6132cdf61e72ceea668d23743f9833142c25ec34f2278387ea9c46d6fa7bad132ddf19b8de05cb3f906e7d124085e446f2a1324115a96f295851567c5ec9952979ddbbdbbcffc3c7d987096462baa4a8d17f2947cf3002c281bc5a4071b69dcb7da344a825e2a4bb37ace50a04a66de8df76f56c38eed4eb190ef97f97840a1e66120342c8bb01c472266eebd4273d7c1c1bf750b7712791a8133c97f23b5afe23dd17d479d903a3c70e789bf0dd03330731884d73c92373326b8833c102f769816466a888ea98177940076aa8f5af1fcaad236f7e58dc587151bd5385f99f508fd626c1d285c50864e24b7a38bfb829a5067ce28c82c14f1df7e983837e3f3e90ce2e6b6822075b56c0358ceec26587145ea9486ffb1ea6ad413abeee2bf3bff4e4e19201886bbd1343b52a8d59a2c8958f939b99b84301b931a237bae9ac777061881ce450d0ae208ecf6216fe66f1ce3685a657a7b10083a2e472c74fb1af3f935641a155ddbc7325d7e3e34d39bf19e1186f39ccaaff2c56959dce2bbe7298ce768d38212f0648b9a2773225721ddd2167ccacac88d99f5d56f36689b85c25a9407e819209b56978e951f4530b950a87c27551e26d893863c4d3dd90f00a2515cd5712a36332eb0c672ca7d358ab11d411e73c2cc3aeeb4d71746dae71ee3031ed40f02181fc6a26f22545512fc570c17fb7b6ac97b41a00cb604beacb468e79b7cd188b4907ad4e64944b8e05fcbb0a2cf7d075ec65226087fdf678cae080b8227edc2f41acde8c22418eb6fe688c2c888667238de2ec9ddbc0ef32748126b606483cf9a54e8bc5e4ea91230d3792c4e92ea0905870e9c29ea7ecc3dad4638bd8e375999bfc614b2731704852583cd569eff96ee32dc13fe14543f9beb93eb959ac08294a438a7934d26e7c35d400e20f9d67317a9e39c165b474a454f67664d791871d49350e54963bcf34b1b2bacf7be68801b3daa0838e2e1d272129b2e312986d3147fc7d7cbea500042ec50c0d46b2577b364815cef89468e5b6402a7139462b925bdde2f3467e56d4810740cfefa7015e31fcd4bb6dfdd7798ab4f1072973791b3669602cc1d61fd1175aa6dbe73f9ddc4ac18a2b023496eee42f9cbee0bc10a25703eb9229508faf9d7a4ae688f7e1350a49f41cd92de458bca58e9ebfd70f0bd845fc018620b532ab027431d9902086c5c45dce64d3377125fcdfad13a364221a19be63b297d57cd03f1c9cea9bf95df53a347805ebacd596d98c0c434064afe32233f373c4b1d9b5752b422df6d9a32b49c3f7bfa12aaa1d3adf3984e862383b3795c9f6277968a53b7904147a637ef0ec517b9810edbbcbd1fb5594586ff106a50bbf64eebd83ca1fe01ab0d2f48a1a5100d6ba3b801b25d6e23f48b179bad3a3168c2eb33fdd475d3ec55592ac6e63a69395e6b596355e22f6b0b2f7a101447b4a82c5bd9f8a12693ec3d4920acd2f36739fb5fa6455f3c1d0af59c2993e38f1a301497ca0209b4dad3764008f6f4920688d6aad356eb598374cb28ff4b80620a9403fdbe9afc6c933e36eea7658689093714dc002b390ee50d687b6096a576ad87d84bfed90aea79115bba60a6244fbd30b03f8acfcc152eb8bb1c53f201bf9fe6760351e22d5f567e098d15aa921061881e916a9393f99671f4a994f0904f17bb93ab77a0d94e4a1e72be0c18072f839f6b843df9683f94c11527c1e485937e9c0f038f799407764803f9a815e9c9db27c52140f01dcf0257070d0ef42b59601820ff1d75c7b0735c9e8d0b2bb22fb38599b3d7d32f77e3dbc7dc5e8b4a24b4a4adfd7c5cdfb51d7fcc12849f01dbb16521de5264ccb9e154dde1ad6674c568893bfd2cbb9ba46c64bd40e05d69095d5e6967535d71b810854c64b3e873d0edf5623e1cf43286822075565b3e1166963b91332987c0aaf4eeafe3d8915060ce02f6f12769aa2a9deec1a58b03c3eab9fbe69940c80ef49552d46cea68aa11861234ad3d472ddf48c9a6ae8f6c6e1fb2fae44fdce7ca6c07ef76285d6e20a5ada3797c65f3d1e11951aba67ebf2fc5f9ca43787f4195bdc43236f6ae77b7aa5e91f9b45e0ec8e7867eefcaa25cd2b795891635f38c8f14276527f96d923527c00794d17ad74ebee1bdee8f992039aa50e94a5bee48783bde85b5a8c4294a24c0fc900209eb362f650d2788999de5cdf32756de35e4f485196fef476a1e1b737c935fbb70f277b6435417d4885ca5f644dc848dd35a7861424c009536156e3876936ab1c3fd2a424f0976f4ba7e318555123f3d637ddaeb8c685529ff72e7515443da17d3ccd63f04fb15808cfce690eacd6edbfac399a0c1c643f430664ae575af0e4cc4fa0a94b65c983af8bd932412b22deeca54553c4df7d534eff1ac2030a193420190c4143e358ea916a2a69bc48211a8c110bd69e1f14d244a3b66cf69886ac5fc29d1d1f2b30f99ab7ae6d85ca7aba0298a1071786c50a0b82c42e0e635ee4152f3659f659036db940346f3217058d72841cae28fbbc21d65154447d9e0e020e50c8584ca15d590c8a4743a91d6ce6ae0c29e2d3b7154948e88a9673bfd280abc9c2b26cb59f7bd38f6a888a32b17bd3cf756b1a2a19fab856027dde17c5303aa7b2cd4afd0d6eb1b1a66d88ef5f2e89663c432477a961701faec3196d633a9155d568885b749b06e2e88de8912f27c3d0ea60a29c3e205e4b8c98ce088d59c93994b11c36c987bcbeabbdd8820051c33883b43197c725fa7d29c23c35ff93ea9f195d2d75ea2141df20e9f41dcc5259532ce9ddcb65a3ddc476319c94978399c76095406561854432118adfc7907e286e0785d558f81bc7c7fb6d3bf7bafbccfa5c1187e7316536d6057480e6558d4497d2e1bb1cd83fe722a0f86c974d3d5a10f14a6f1855348d018858235c50880e0d76b6338212ff02479aeb39faf7bbe32b86ca0983d2e07495da4f0a37cbd6e8ca4e83f8dcd3fd6e1233c95801e11bfaa3aa7e5965278aeec07f466b814edbe33e488a1e4fccd9f64cf37ad84b1f728168816e55cb9f3cf67613689c681c3b713f1aa81b5ed763fcc4477bf84c437e6e4c3c7f224f2da04c9df2ffcfb05a1b35d41b160423e372e3e637119ba19c6d65d8538ee1224c9d2898a7c9be56ef8b175a3033654eb14bc9f35190606c4416e2f21dd9a2ffd6877495faafc2490efca91d2ce40835c9754f9fbf26852cd45ac57dd3c3231286a0449dba4d3030f83884810399f42b79d5d376df29b3085e01c1924a0d700a4a82153ba97a55788763fda6fb895cde7bf07d792902ed457cd87a70f0ec940ae29e90fd6f4a8dc5f875b1ce95cbb68bafda1cd0ba3ebda28936b72a0f9188d9e2ae822724ee3c77425326151af86fee44d1796e4b1cbab053b2d30a0c070bba28ef7ddee8030202539c870bb17de2255ac6bb55479d2f8a340a905ed1ef3230941aca8af4b63bad6c3b910bf1feaabc10b4e3392c465ffaa484cf07b0b3710725bb22822d3260ac55d91f5e262a7500ce0da8c3d1cf8f219ec7a1152e947e66eef052951eb9dd79f65c4986343fdf60b3d7fa3bfa8fe89f1bdcd633c909b40e2d17a4a1e63bade10f8d41f05647ea2db53241f93fe9705d2eb632fad38f1052aff931ec474db1c4b244035c57b59928938c74b6f880a76e5807a921220b4febe48f32e9fa9ec774aef88b2382c13739c5fa0583ae838bd70ae785bdeffe06c07ce185fb5b9889f8b4f4752ff564937a2500df20346840b05137ffabd6d9d5d50136a905b760b6ce3f271c03386784ef9ef60fc73fbedba72a1c3137a1c72629b098f69c97df86281ee7f622414fb954f497d23692fa0e77bf2bed22e8dac13635d478c1aea99e8715f6ed688910b3dc674f6246087f641f4be91b8add46fb3a9ebe4a2a0423dd57d4c664091e74e3b68a31ff1a6f743805e849d49c17f1077d3dd2c3d1632018a81157e0ba8f781356fd4da2e08fe492d47d7a252e327b07baa542bfe21e106d520f35e105fc62afc69ee2518bbe077008e1c644363508957564bfe5799410f4061c047084a7cdcbac4fee7ea2c219f1af848c391f950a8fcff74e745d355c9ae2a268e7a75893537a27240a9ee7a3fc79b1871053fc50ac32650c1825525a55de113fd8ef766319226b8de11508a5a9a95d190bef809e07e089c304a50ea7756f12862e8704b8f18cf6ccd3239d0b10743012f3728408ad2587142bbe6d3ed9aa1f1f04358e136a2d1126b425814868625bac164368cf5494b3c61521b286a8155c2b1754bc6a1610ac7ad2257aa41e909443f922c969bc46b680828e6571ddd78b6facb9ef85b6a0a3f5b61f719d95cac752eb643fd4860e2059684f28f9f1af44f6568bee5c6da7d9121e29ade229ebc1190da74a03aa8cbd24d35116146b1ca89ef22a32659876adff4f5bf645fbb09b1e3a0907b09c4c2e5bd74f0a654796f2899af9515b5f8a0543aebb694a5c0d323f17c04dca7bc98f8fd720f1d1714506efd63fde28c48fc52cf894a9e06117a7a726ef921ec552da6788c6814a1728d0dea47606f0cd28e01e02593f3aa6d0721d358b188e49e0460345b084ee52c3285ef45d4538a08090c7b51c8b1d104fd8c2872e013d2dae3eb7deda2fdeaff9c920ada871585067902f6959dfdd56fc362c18a0a5320e1252743677257ba666609d636484f585ebf324aebe092ea5b53bdaab80697443e8ae75c203fca02d01eb513410352c0b6e0bd36e3f733dcb2afa03af1c7c079cd4bc628b0133ba897f7513e0a32b805968e04eed7152cc728df0addc208cba6138067e7f34999aefc9e1f271d4017b0cf9959a6d625b12eeab63f22db1f02168209aeb032b55be294399bca7eaf4fefc326821cae37d00fc02385964aa6dab3a4c59a9cf311486001f0ac5571b8d3a10e187fce503df3c2685444fba77ee4b4ca6a9e5330af5659ba489fde0e4fad23efecbf569b7e56dde79c457eb474fcc2080f892c7b44f5b396a7d05844173e701f01db205b2deeaf7e05895689571bd6eb67cea721306be60e072635c614b94c42d45ca1d6007a191392b325ec72b9e5d8698d025051186f93166520d11769eb2dd77b66b8470956ba039e1c72ea053d826ac41f5ce382fc18d089f84d713c887e921dfcc266aa231d71973d1cde199dea141cf072877c36b3fca7470058691b660c5f4ac55b94e367dda70c3ab770d20fdfc3244df795019f7a18deb137245354404ef493d8bcc7ea5d5dcdf31a2c148ecf467696ce965c763b10f7d0fe690ba0b50204e9e7d270c36853f9f9748b4d0789d96ddb02c0ddc066e5e203a18a6d9982822ffdc19578b90731ddd85e84268326724754e55eb6aff319b9df2ca24818ac41d1deb7105d04dd3cbe785aca3b062faba4bc2b413b3caab37213a23ac919842bbfa4226d5514bf06cb90046c6fa42f9b65839b7ef3828cecea7ecbe6cc7537937b688f1b4e7911af47f5ddb3ed87d20e13497114da441f8c44a5a8cc5f334acf63f78e8c55940d4721fb4317dcd18af0c3534b6ac5b4af1c588daec02b02b95c5695b5f710b6f07f4d60d912fea7fef8d911f7f496eff48bec93d5f1e6a6cd4d5f57a736f6bd6e85289bbcdb90fc805116e9d018fa56d939a0c9b952f3b0d65e732e5c3b2f15a2c66b3fa1e8b2ce745bfc6931f40d6827e8cee095e75a40378154f554879ff777080d44d86faccf4c8c72c626c9d00cf530fef8335945b5b5cd43c586a57702b00d6745f3241e3ef76cfff0376ecd609ce6496e900462259cbe8c733743962eefea46c93ef96f61c5b5c8a13a8404294385f5d6f9d7884e1be6b1f235ecf92b6528c170d6157f6c8eab1815c71af049a47d2f3406cc1b405559d44c20d3907b736601e67227e7720771698312f74f71fefd2b5fc352b29311ddb01c249c6fdbb7fc02304107616463b41689dec5b5af486b72364fc5b17b94","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
