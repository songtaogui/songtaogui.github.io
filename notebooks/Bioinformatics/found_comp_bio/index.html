<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7207e2499993ddd2ca486c847ceef0066e2189d9df83b508d2f96a92f99f4a600c96b80e38bb659d4643414185e51dbb37824e8df758ff44ef86c57490f1bc3e85d54aedc8d1625fc62dd75f0f23783719544fcd997992945327380c0dccdd7a2918b8b5ce572cc0d4db823b6611e928a9c5634c8801d6ef13c6530fbe685b2519f2d450007cd58b01dc2cd9709e1854fd30d89a121ea489677122bd3428b2e478a8cd09a37b93aed05a42aa435b885c38ea3fa91784b589b2206c7719b26f5567902efeb48e9f8c1e865386744d67ce06675f6e7ebcae3780e5bcc2fcd647fceea72788da9c42a783e4394eb166ead1e7c5ebf14870a48a6f41915c3e734e70c87f7502a8a15c7dfa7e9bf4b84052d050cefec33174b3d0df412868e4df251932572a4daf1cefbe7b17ce0d92f08d2bca7cd4708e006ef66525048e7c7b1b5f2543ff8200302f9c5ef7fa8f7ce48904a90014beac7caa91852237c550d9d971d0ae4225fd33c26b2c4f3723b6b2b12920e075398a47e16bea60c567c8ff58b7bf49630e10fd874aa8a2e8fedb9961800bb0bc7fff670c3ce22decb150f1b63efe9854477ff1aad09ace4d284a9aaea125870b2b5637bf6d9713f7fe1a79602b478973f324cbafd395d833d8f091b5c5abbe5f71d4c2fa4569e1f663d20c2672a32551d189abfeec33dd0e9a887b973e35c0556da6730b98dca41d3f40f06298cd426ef87378141d86596f2bbcac787ebe1aa9e4dd11781b53386121b55856a799202584b9d542cc893ce3282027fae81d393e41224b6add4019c66da37aee1c1d33ef088d3aad559dd8c7cd090205bdcbcf57ea39768ff2aabaa6cd403dc9aeffa86bd1ba9ab0716aa61411d7ec247f37cc2456256334a6e29c9f7c71795bf778b1a13ce2263c90fe8e16cf8195aa528baa85ca68be6bdebec81b3950d42a1c748e6b9f32bae5d80175df947b8f7219d3ecf2622c523c4e4bd966bdf63b511d61fbfa5567b2504dc25a18b4a36a22f0981e1ff94f4c786a6b73093aa82e6d60653fd683aa7a47f59caad6c4beeed01b1c24a3a874f0416548a76e559d48d2505f16a19fcaf9c6c7dcf6271a7d271057b3c2a3046a414155ebb27cfc0aef5d0ef3b841e731932aeb9537a5e7277a6d3ce3ffdbac743c01d248277eec54a2f0c7213e30368160d1737cf5b3d93f9c42ac1811cf9278172ba473538f34b32fac11d85e12a4b6e7d4a8a39b7fbedef603696a4c9f7f0adebf7cbb26ed2032d407b198ceed1c4628d44ad0c566b72b64deeb1bc3046b916f35ee4a3ac6910408ed069d920cb6e54bdd0fed7ef2a0bd99d0eff263c2d3a7582895a74941ca396c79bc60de3d8373fc8ce8e89261120509a24b4c802df31218cd42d39e880a308c0169c09eb55f4cd0494a9386f0d6b2c63e08619c620716c04c106c4177bea6c64fb9c17474ab75ef9de620ede0981154900dabd029cf9aac9bc38af33d03595304987cabe4bad57d3257a5b111cd8ff9c0dc414b5d9b4ccc0f95cfdced84fb5fc858fa3313a7005183d3bf1423771850caee51b2de35ce9839b3e853493e7207a5071c0c4f68b196dd762718fd38ec0b480b8e9d5caa2359b693c91372993c9ef3a58d8b3cc00384104a8ed0e2254f9fc9be0c91d397763a249aaceedb7043d3645cbfaed22d06df7a3a4a2b3c6a1f392203dc1ee1aa1335a14e3d3a9e3dfe17033c1265431dccff17fb8000592cec2d4c92805250177714264e60975a72fbf0f788ff8a311fd7a915b0476e3e623c4d87a1b8415e03b2a9795d5fd08b19ab00afef865f82f5f5d5e09c067303c05c95ff1902d2e590f9715eb34095c22f2ecfaa284b44a2f598a4b35b544a04f15a7ecdbac4732fc6af233ab386d506443ea9064250c25ccce8aa25ba461e288a867290c147c65b0794f321379fb1ac5c41d4ad0be192ac2c724ea76c8b66e7fad176011347c24b9ca3c9ab480740a4599d3f03887fea6f6b5c11f7901a3ff4e764cbdca929ee2b79501af754d026ee150db1af3aa2a4804dce4d6664967a241dcdaef91bdc16744d122b2194cc705a3b887d8370c1b03d1e58a9f505d814fcc6f8aa1e2c318d0d14c8452614028e497c9429290dbfc4e8a9b5030430ad59d103964b55f5052381a125acf8c233af056309e44733778334fb88abb035aa02f954fc1639abc56e4b9eea7f361d98bd71351b2c0f831dec7d0643f9e0a97a164027692a4da2a411d383256be0d761ebb5c35897ff1c0e1d05a255c3c8043a228c027046b4ddd2bb2ef167a4b93793e938b2c26240845e7b9c452317fe18e1de8ce45c721376ec9ddd76cdbb8f110a8145523f6502581e9c6481ccc11209424a996fc88aba71eac80c2c0fd042d66aaa1f35ba14d10b0f4e4e0704f2e0828c4067b992f3aeb32da2da65322086a9453d20c2876e46e23f82be4f4b26b2c9b9c009204c4e0f099ff472ce8a6f94d7d68392dad60a990c7f9ef1c2d72659bfd139c925a0f2a2751456272579a0e3170b6f9d658d700c516dd557fc5cafe0005f137b5a3994df7351ae6cfbb97ad430b8a26e462f568c6f7a383aad21863efd5f1fd4adc3ffddff57d3ee63fc7a1ac8bc1e177209db4d9478158f99ea6f3b1324c7f24c2ea90e36842fc723308904d0417779d8784a5a047dc1196eb4601abbe582b4a0cef6ce886554ae2294dd7731dbd2cf536eb75db4191f02e8af92fe4ce124c5187f6235f3d4482ecc681aed9492a9e41dea68da4fbe0910970133891307b4f0239939a5a000d3a5b365b525abf16c85e5649a1acc34aaa50a9b7343e8f494745ae8593568fd1107e407eb3331655504c6f6d2648fe0f67d410f57db1eea12c12a83a30692de8f3b348357a9085ab68bf3b216b9bac11b333856d36ae07719fe97b81b33ac847d8aae01b83f08fb0833a54fe15c84093689780977bbdf231bedce50056d721c5b7c986fc34e95819579c064928da3cd21fc0b0ed3243fba23d5376934836643506bb5fab1028c68b62c0bcf7a7a61be7293d3a62f0208bb9981269ac8ddc7b74d6b5ebe143b123db4b5722ee47ba1b41f1b9dc600a0a8a3b4dc16a2026985e99af0af238e169ecd784c6788ca6a440c4455c1fdcfb83e26b1de8475c08a05edcf3dd264fc5d6841e62732b1bbac2f44107cc70b96bb1ad795930523cdb21dabeea40c71c9466bcf12f43912b6d3ee7c71614c7311996170fb6fcbddb13d86baae6a777da1cf4f5526f6be4a54c79f49a34772b14ddf289bc8961ec8018ce990f6fb787beb7fda61400d7cef968d822e654a57849ad047cfd4653d0ef351913a7bcc7f9834eaf80193789aadcc5a484f2be41a60a36674a9184874b9af33b6e1de8efccf34e56b419c4ab200fed4b36c79ba82454583591ea1f3bfa606a96513daaf36f2338d3b7dca512de2269f6f8d51558351b32ca6d320977e566d37e7108ce412d36414e0c7491280dd15eb2d672acb4f3b53dfd9370dc3f0eb24aaab3b26c1999482ce736db8fba6614b6304e8ec5e1ac5ebe7b5af3127961091041cd9b5262b4bd3b31b3817c25d76cbb4ae872cffdc4f00b2c6306f8abdc44dbb40351aa07301e168bb43d015f85226dff5237ded9ab2a58f1f1e73bfa297e1249e075bda8a697ded916a215ac069231620654d1039c33ffc0505432880ef24d00c54a5b3d24857708f40daac7a51c2d4461847e7a11f68ca4bac4b9ab76df2a9906676057ae0efbf20f840dd8c14f619432d2e86c7a5750373b377f7e03e1112215c297705289149bfddc7c56ff99cc52918bff15cca0e3877299ee47974b4758b6c63e744b623c28593d40edda5bb1fda337d74ff01f9bd573ee85555cbd82b1b71a9befe36d0333c41566e7c405957f07604dad3189e6e74a465e1f1df27e2bcb7cdd9451a59184095f329da24e1e56cfba751d40a31089d4759a4cb6a16598a1efb0ddd9cdc5bba51e4166d07f49d9ab4a081ec891ba68fb1ce7b418f805204bcf512d89094556fa5517614abe1bfc271613aa0d6e5c9c3699375578945838a7d8878fe964d69f6a78b98f94dfce218fe0bed17919943ed57a4804fa3bffca00c3c5ad60bc4dfda899cfd7673782aed7329c084da233e41319ff5bd2f8bf0b2e8575bdc8c6c5d78f408cb045add32d2b0f0c4734571ebcbc955185ae7b68a32696e1bf4cddbb6667d7dc0f780d417d8f5ff06a11174cde6946e97f229295227d9f1935151cf915105f760e16411d694300790b1f5ff5ff9bd1451413a31e86cad1da779748514dd0b489b84d1e0532821d24510af8f1cb1120d6de6aa87b8e788b814da61664d94430f41e645aa77a34be54d315c527ff45f73db56f7f8b61bf53ed389ee5ad5c478302825aaac43ebdf526ccc33afea9fe86306a4a66ff0382771289838e8c9b6d8418cfde3b6933b7841862abe8ee6f23feddc4f5fcbe4fa069dde994bba27d0dc815a9fe702c89cdf34aef89f206a6d92662821355fd3ace43f51e6cd64edb42b7dabbc9df7b33d6ba7515bc6ab78d9a7cab36369059fafa664ac06676f38f2a3c9d12a8a5a81b5260b479bd861c94ad0f59797cbbe6016c7d85ebad82024978e0412b4c6e090ca2284ccd0d4e42eec20cbc65c7c8838ff1148c76280dd3e23b0fb17c36f581e68a89a78bf3b505e57a2bf46ec769f56712ed98aa81bf68ae1552be44fd8252d397502f4288cd173ac3a884b144971a60b6193930af247d6c48a5dbd899cdc1f5bbae3915c487b66daed028b67e72aae426e9dfc855b5d18f3b637049246db7641e2d6e1ff8532e08d953d773c880c56339a8820e68b8854ad590ec9ed12c429f6075466ed33b17d88deb2343dfeced37becff518ba790215b34a4ae3d30a25bfd7a7effb0352aa74b6b4eff03a2a4c0481f62186ba692c1441dd211cb0af87f6c5af1c7032fe6c8234b69c1bb9e2d85f8222d803538951e23dd1f3b27e90f48ed100ebec941cfc8037067b76210ebaa6d4046875fd71ec9853b023507a3f011651546dd530d3a10251b8c5568a557fdf97c26dac294664b7485e116330a8f9262a39f77260ea3218270ddcbb8527afe68799070a18a534ab3c77b3499f11afbcada3bccdca6e0e57b0d4b240e53ff5735834ddfe85dfae5c79cf5c841bfb80e7179e919cfd5ec9e1e89409169a04c4953ea07d6e1b83fb7146afbdcb1800c3fd9f62e0c96fb5d6f9cc3b2289922bb8aa17c4eb7846396a5605dd059229be5883d63de93924706b1120121887db130dd1b150d4029eaf8ca70c27230acb7790a48d6fb44fcd10e493c0f65793d35a1369c001966d50e03edc5eff1bde1e4a50d985f7f5589fe02b077988d0c0e1de95e728e133dc837428d8b9165c4dc55302617cd83e6b10cd8c9fc2a3b2f3f778c95ad3a0a614a0b26188acae89843b9cbd9824ee515923497e2fdc83f1fb51defd7f8db775c14e73786182d6eb3d8485e009caba4d502a2fcf8b8455f3de1dffc8f0cf16d0273dde46cb92935b56a78f6473f5a98c591b9265536ac4e0a01a6adda444dedf231845ec6f4dbcd2a774f29521fe2238c62eebfd400e58b53672b5e1abc9c8dba2e81cc93f4cec15d76e57e7cf24d6e5c121ddb47f7736509a839d1d3f8dd787d0c46215b4a14095321c4bc10c40faf0eb08253ad9a70b573b2af9eeb0bf8779c506c73d499054add50d35b84853460fec29aa74014cd8b42c0cf962e995aab9d13bda5bdfbd193743225efcffe55e380f0d55e9b1c785557a41eb2fa1f4178446cb1722cb4f8fa6f48acc01c0468a975149a94dd7e3a3fab611711f6bcb466d14cd79880bb676ced09977ce730830f403a0ff60f63972871e446be59dd26d8bb5fbe4807a84c8e573d9b97bba1e90aebbb6b2efcfd2a5b1976b2894566a9137281078f29039aa934d2ecd273ac7ac8f445749b6f236217addb48229c944ac2409b0979a4d859e18837d197952dc517286ea30d50df4ed39facdd6e4067102269d074d99ac534a535f1a50543a52de1d229d3b462562d4bca97e5d79a7e6425307f1b5cecabf5bc696766986c2981d522ad3c555196310bb3fdef0dddfda6751558a23cd9e71831cfe612c53458e7efad2bbff79dd5f418a4a03b9f6f3460740cfbc3f42fa162f52db1ec8cd61db82431eb1f5a49044c5a035e2b921ad474ff015b61cc3bdcd54b3b37400b4345703c289d4d6fd5e4f0b203802e938eabeda9c50d4fb958140be0223f4b52109ed1329bc8d3a40865c5bb9ae2286d985eb59e83f077c8ee7ca96d875e28d735d6109c9c1003bdff7d80b693609fb7ffbc60185047e184bcfa685508a0fdf8502aa2c4edd8c421499802e578cef83a0ca12f17955ccf78c6318e350390d1b8a98e61940be23b2f5e4502a26a8fe6e49de80621e5aa206149a83a414de60aa48c5c952a99c6e4412c4ec205ca0f8471c6d74d4fe4b13028062ef0d579505cdf88e7acf99594c738af5caa04eeea505c2437e299c800a274b8b77cc5f39621d448456f617c16d7a93ad2d046728b0040bf5604d5c01e11fe01546dd2b01ab92ca6e5ed1aea06c5c0993355ce53ccf309d3bf0ed6a84e670fa4de8030de33ea55781b9086f0f9da79aa7c4028b773a0db4cb7a83b2bbee47dad8584cbed9ebcaaeefec036af06a3372eb4777506f19fa4b4ff0f71bd99517d7874f249f808131e3b56fd672059d2479e795c8786996106d84603745cf7f9a2e49c3bcef8b7a53d378d2138fd01796e2a3d783e0ed83877e05efc936f26fd83a89104589033083a2cef4e6548a6ce01f2a261b3f1099318c2e4d26d7b45117698aa04b1f8ceefba5806c8215c94785221722c3263af0dcd07cbb2dcf4f2c606f9667e83d64bfbde500a0aa1a6ad7b6fa9a4b42264a054e67e27abcf3de04f565bc3857d5966eb0317b72dcd48cff287a7a4b892d114be06783616bb7270a99780a12f7995a7841afa45e93f73eb2f5db86033be577bccd7d47d358254a09ac1f2735698c37654517ef41897c6bfd4cc9fb28de22b39b68cf8c46a7aa200037206d1c409dc3c6012c6ee55954702ca5e21782e96719988c091c0147da2e13e9436cc4235ef138c1b8f59edd0b16cca984eaedf2d0d6383f98b20df7c3796e31e448c29443794b8a9ddfc64006a0d1709b5c97b0cf7714aa3109155f0d0d462bdbb29819e8f702fe523dea7ced2e382d6af9e33c45b9f4a3213ecdfed48c8fafd8c6c4451c98a304f1f5fee575767b3e82d757d6cf53d2f1f47d50b4eaf99ed0052cf8e60873b9e60bae6a306b1afc192f7bc48b660c22503268b751284588dec20f6fb5daaf236d6e49e83387910dd582aca5b977563777ba27a9f34065e0f0474e9132bd647007842ebebb42891942267f4c35fc8246ae0d0b27562eef271d0a5ad16b508a8c0733f157e479856fbe28f98e50e43cb70f497830fadc8293f579c3eaa2943faf2d4314ffc2b076641bf8687131adb8d894319d3871094c5a6c04d624706993458453ab6ebea8fac51235f8e58111b64f247c6bf15765a3fcf97539e9a2546cf4049e5f485f3549de285fcabd6a5adb9a5289096a8ff015c8b82abc69738ad3e66e06766f507ee8e5c843ae5fd93dcb534574abdf5f0e89d0ea26366771d3c377c0f4a65b86ecff6a32f1bcf57dd13ab8e751e816dea782179996ca7617c029bd85d0811004189c49ad0b883e6397863b43d3fb234029100dbc282f4671062d918ad66fd63d5f1fa3116fc48bbc722e06efdc4ad1d6ece3daa0c2d10244cbbd598fae286517601e86f708e1ba0cf1a3cb11b90c1754f95e999e0acd1cb99883038b7ebed6b5d491da97f80f0db954feb113646aa1993c665de22b340357b3d617177e2ae06d1a8cf69d145fca747afa8b926e00f27b60b54608bb2187c87519a9df8a897cfc368ede0b2099f9bee8dc8eceb1cc9e45595699a4f9c846848cb784b1ad803a655af75ea0cc9bee259ff0289ab817489aded543a8786c54e93280f34bbd94ebe914aee09123e56f06fc5c0ddcc3a59e48cc6b0ef57c246fe41fb4d8d253bdc60542f3377e32ea96870031177103d70287cd40651c5c734d542f8da6eecc7a0fa28e4351ae3178512ba37c3582c497ad5b0c441c0a1f9e94f0724770cc25e7195312025eb56af7ed371ccc04a4f605284082d9f1433483a5950e044b8d55c0c3ed5ead94278414265085c2dd209938186662ad0f055dd87649d3a56042f556cc8167efa5e523ca06e76c19dd97b401e87671a3debd8ba9952a3b82437b7579beb140709e73433707402e04c1be5ece2a164e821ab7c146435ee951a454e2500a8d9fadf8998090863cb0458be2281f1e1ed8edb850604e93af5c58fe8d68bbdd648eb3d5449b5250bee0d59d0cb2e72fe55ee4f7fca0ec86c0b27ce018b64dcd92af1e413ecd85f748bc099ac5e08afdff597f51ecc4d39a69033fbad3106c6e7cd33afebfe3163e24e2a4cb42cf0c364255d427061c1afce95ad073c56c08c3e72914e598397081c906e4e53bb4f7c10cfe7102afbb1c19a46873f98a6122b6f7c9fd54da5267a45f710652c04cbd8eef1bb93af70ed35c00c9aa9edc1af946c0ffc84be00a94d7e9ba831bd544ec85a5a1b6fb8e1aa075e88535db0b253e5a330a7347cfaa117b4b65a4add4821c0d0be5b217f8cb2cf07cd896ce2fffae6fead4b452e5e15dc285ba3b92ad04e4a570a54745d00a1b15f75074a70610e784b1da8a6bce39b533ac7b80c07d842aa3f08420fc34558f645d9d22cc8a4a8f1ba4f1102f770828454350bc4da69b78be617515bf3debf14115e101b71e48f5c1f6059b46c743cc3ef8de6c25f182c9472a849c7c82bebf935259903d86acb27e3820fb489f90d60f2626c2d8d676e71cd7c99694e492be8cfd991d204f2e53ccae1beebe0e0b1c19e6008d009e3a4b18a878cb89ceaf40f1f29b96f80ff786eca375af07ac885c6ccb63f013090f6c08344820fbece8f4f970e4e08788b6a1df60f5806d74e1ef45b826d32cdaee9babeec9828df1141e8a2a6d4c7efa9dec289e33abfbde25d610c7506b60f6514392f17e37667c4b96940e7e4af11ee630b566547931873d8717fe6206438685baaabb52e071282a631386884ee9a966cfe6faf1778ce48d88c388a51f327a239dfe8dc07fe05ed985513d9ad9d09de0349acdcba699a8b0370fe4dd0f4f652538da3ecc91287256ad0e96f3f8daa7a50bf562f78038c9c67e7a00b9f2298284991d51a75607faca8dc361ad119afa9d4a09cc39d27a338004233acd2f98e7759f3b451587f05c77e7bcacc98f02e573705e76e131c8edf60d617713b4f69fed6e92d385ecf1499dfce961b181be4b54b3108d3e661ec089f281d9da96976d6656474efaf34802fef6a48ac7fe8db6026ce34b91763110f3e04d300113f15c18bf6d36f1167ba3b6458ead4301f22220d4c809835ae59cc0b1f39e9ed308da651970c028449fe48218820d682a5a2c3da42885aef2c89668fadace1b7273d1d84f692ec21e53045ecddb2c00532b14a832056e81300c7a0c895adb1f1f62cda39250b7e655963fe0822b308b4a147591a97996f16b54b2139ab442cc1cec84cfe08793d8793c6c2845e2bd5b14a2bb9be1ee99522d5b3935a819c6192ec7a9593ea858b792a159a97c28b9b9a5a177baad91acb10d9101d8bee1952c9937a44a22f2caa4ad8a9e5fd64274fbd6b0ae6e9451578b4df66d770dfb3e1eb045f76c33e7b8d0e13d28dfff0c96c40f132c57869077dc7b5d16c606e5f6bca921de4a0cac68a8e286768d769360fa0ce5a3d7865cb39383df77daacde0dfe781b4ecc187eb30688f942cbbf608b7d05e2eeda99286f18a793658285813286f9956b1bef39a1352f24770949958807cee83089deca4d13dd58f6cfa7626469db54baa426da0e34e4e947c6e211c92e9b0ed018a5b97e921be81542e71f30e96d2d3d811cf3e02e9bc4a108f92e9bbbd14bfd62f83f4b7981bc87d7cec4137bb38e13e3549d8c464aba5e01b849c406b98885d782a6b20260c13ae5b226b7b84f65b455e99c3529b2c43defba06a6c06cd26aa763558c5a230bcd651bd5a7dfcabcf32e5827f3eee256c92e812e5816b38c455af5a0954ce462d323aecff202ba62d07060c380b6992badfa103479603fcd20ecc9f4baf7aea3326f8b3625c4803fed369f0f7c3e32374ec3af41240084db6912f3c5e4f7f140c94f7f29b27698af5f97d4f0fe722aa6a4af98dbaecffcdc899ff2b7863f08099bc3c8c4a6988b97ff3ac64c16f27063e7841ee818ded1d5faf89129e19035003fd13da3e7747e15679c26c8cd886ed558616dd7bf58ad4b624e7f7810246d1157109bf3c38a7e78b40c3687969a797936c23721f864cfc45508eca49913041ca64c0607a570f3b3a658a5925a7a903d7f8e317c9bf4eaf285f996d11678d9ce5869f7492008bec30f22cbc2c2ad1e98a9ae6321d764e93bd852c0c82f3f50537cdb3a8165800bd0a1365f877364831cb50076e96a63675f76c4ca43011da750d68e603a1c40e1b8f07a2c49a3afcbd2ef423453f6beb5e507b2adf92bb2c1df2f9a4c0f46102b1b5fb096b9b84464bde6baa0a43e76902320eda97c46614d8addc470a5dd494b42360b858651691630b9c9c87e0543dfb13c5cfe78322cdc04ac1235cb6ada8edb62e970babbebace86cef806d2d1cbd7a2d1ff54e1008b8d9b55177d81976794b07f3115bb17514b3ba918f5c735b7895f2f0c820fba9f4964c9aeefcbbb8f454450a35e2a2d602fc96c1213dd2a71eeee0d4cb28291422f1bab9f1f9a8b5650b9836a0b71da964c8e2e360cfc52390b98b04b421624bb7ead2a5510623f033b982bc8cf78a1b06434ed6aec946d3d874611079197031bc861d1c2c913aaf45cd13d0aa5f7728c2c36d09b46fb6cce72f2c4c98275b59c6a639bb268c1620979a68d86d1af26023845a8b8ffa0b3e5985115e668da40e1ff1bd58b3cef291e9ab455fed94718cda758f21729d9c6957cd8a6578846f8a447377a4c11ee7776b1a64d1fd0ab5f7edbc5c350b6da0420a2ea6428611bfec542adc9238749ac5a5b2e86137d7aabdb6454a9f8c25008d1d80b1554b594ae92f1029f908f97cc4b6120874505adedb16c85b78da0d28451db44f8be302014d9d7c3187a1a4a3569b7392c3df79fe48ba68d7bc3116a3b52d33bbb6f69f6cd1499185b68ca1ef6811e110f0759582f6d83f77503cfcf190a2c3d28490228ecd236e46caf3c5515ebdc8cd3a7d8173aba60121148c47597cbef8ccb5ebf0dceb93c6e2b961573a826a4c9afb35b2db7defc922e980798931bfecd8118cb3882f6a12a229cfc072b6d69ec06a51a6a34065f839aac24fbd3189d01dcad6d3ea2991099dff0d792e2e30c6b5dd809e3cc65c5fa5489181778950cd0c6790c288e4b36c4773a57dd89eca9d62f64ccd0cb183b47a106b1f2dfa44e8f05fc07f7115e838cf4b49fbb51c084d4157223e921d9747409242a0a5e97a155294b0d1f9d9ce544ecfbec1081cbe0191ae9f9170869ecd20a4700f94fb354513d8c3cca310aec758b677720259282003f257e3c4bcf0c0476daa5c30d9cd25edb57962280b3006e08ce1d9675445ee01b5f2a37ed0d0a469677ac75e3ae8e589a8bea6826b15ef01d30dced606c26b6e72566f3bd79be3072abe220fe46caa6b97b779295dc9d62ca67b3c6356734b9fd21ea5303f9dbc2e635e4e761e30c568210edb0ae10c856dd55086e623f88cbf9f278400d8f01e778bc329e8ae2da86c8f65e92e5209ef1ec62ce2ba360a552a64b6714e22a53a800ad38b9b729e1ae926f7e82d458acd083d10b1c01fdb782ec20dbadf275e5a92c88eb4d3f34d5739c49fcf90eec7d507d8c04e6cd219acd41f9aff9fe47a724ca4ebbefcac607d2d760cafafbcbfc2a4981ae11b66d3917ce6218757f48bc5318ebb9e9b53b8b72570bff33ba02b349fd45849b19829ff859ef010222869fbe0ecd36261312d2627c9c67c7d7a30f9843117956c44836ab17a1095f871d0a9632d5bd03c06be84ff259c05185c63c167a1bcb36e76c02d74bd8b1d4c875c14288da7a96558cd07a65fd7251d22a5efc67e5b9e1677994958042a927c6790157c83324de479b5b4f53c49f7407673679f532ee0db33994bd2c2e80cc733c575d2ba2851701b618b045259a288154c46a37d640978ff81ccfd8f1f9c41d3f96659c0eede3dbf833ba79cc5a07f9828121377dc327765bfb7c8b63a5d53fba208fcc9195e7637cc0aa8b089e37d6472f6c33999698e783e062d153f6433592d5cebf5af7a31bedd6c0486adbc11346797a819ea27eaca34bbbb05923f420d8fe90803e2fc7bbf6b3940a723d5478f16730dd2688d89abe705cca9ab2aac6b55dbe07cf701c21c3caba4528adafc689c9748fe6732fb5e4281a8945a941fd4c507e5dcdd65798e40fcd303e2837655e9f5ce72b358665b7ee4249948f455120c14826b3e177f244151400d7dccb4019df4f1367b1fd903131fb01221ec626fc4d386981c7546e66b505dd0ba347c9630dde4eff01f20a57ea46e6284e07b99bee440bca0b487adf33f36892ab8e31399765df098280df1f67ab39b092562651707225f5a8dfc5c58af56b60c72a5fb73ee1ba7f1c79f8d776c814d3b06cbc5bb5d20ef8b5c089f4e48fcdb7012ad58fc35cc2f6f66ccb25fb0dd39105787a72f5c9ea7398fe551ebfda18f0a366a8def0d512f9e460ab12de8ab5e7745900b9b8e4267f3ef2f9b05893b6f2a3f97fea302dfaca2315bcd934e06acc509e3ce3027c090bcbedfb64e06c0556e9eaec2f16db03a9021df7a84e896408d605ddc3d263e1b36fcafe9ab6142aed0752599eaaf012888a3c54028293d6457e6eaa776385979dd4b473e525e4b89bc0f327960886fb31ae73c73be97bdd728596b73e49c8be17c9726cb6938f10bcc431b7a5796367cb0dc6f9e3809bacbe0dbcccee227df9a62fda801ca5679d54bec47abade5a8a06d3b8b2212dfe0fd881cb949f4692ca1f622edc84c2a6a59442f741774b2f0193cdb8b40dd36b6e897c91178453c4a50b8f580f60f1e9f6b4e2afba964231e4d86f9ea2ca76d478010426ba6afc5b192338022bcdaee8a12ebf991a648a186877b036e2d8a7bc750004906c98466dcb7aa590fc6014df11103e96f586351d55ff3d9902893c07a4d43547daaf4d926ff959cc04f238ec72f1f7aafb2a7cca2eb1669f5144475259f75e3feca9165327cbc1a48d727d9bdc2cafb8d9e55b1f0a733821b64f1161e2fabe7d22448ce4215d916f2acb188280686ab79f6652a90d0be24db5c33c6402cb0344b0c3c8af68ed12a0f4162ea90a298628da77b334df67f32442df9970f233b516c8a4b6dd5b4eef4abc2e0a43f85728ce40890f1f4b4047f859f1c9bd5c06164d0f658fae904abd24a44dbdee76f0f87180ae160615febed96e4941abebdfc949f7f9444c046f93bd0f27127e6d82c459519c08006ee60993e494bc810f0a0872baa844f90f54c4ee21b92d8286fb7a337b09086b6bea476081f23d1c07fe8e532a71a347623855825f35bd27109afce195dd6cabb1c9ef36f9a7d967de1461cd0d93f406044048b4cae8b8d937147ab33243b04baf1ec9f111b402e2769c90943f481abc51a8366626088f88b1944caf9b83a26fe7051944f138b3642a3cd78cbec602b0991a3922e0b8d4a07871399cb04d04ea0790d4753957e02ec760464e731fc9f3eb969ba7a452735759d79cee0898965becb768636e26917ee1811269799c5a7657c848d49cc3b59881e379013175a9c377d6f7ad475c59cbdfa4dfbf283f97cadf91e7683acd891543eb8609530c85a58f48eef645dc719337dab5b3982b6569dd2e0ec8eab2fc69890ad0af9e9648a4722b8675c02a0be10574df487360658cf9cb675bd6d92c87b3d5394c9293941a1852e0a2f2df7d86a104b3e59700e79f15ecc9742ba4b8a42c0419339258f7c9e0b589f64a2054f1ead14986ab48b5d6c1eb99f02deaa186676a4d4bf1a522918dace17d3fb3d7d4ca6e7ba16aea6019eb6dc59814c0d1f8fc2cd2fe2cc5119ed78b5a3c734663b4b6046f0cb9f4763c1d8cbeb50d52378897a66dd400f6c1adf5e6777b0948d83db6b7f7325f0949724bfc5636917bacb3e9c9c8fb88f5bb21d8b065f80bbf60f80bfb90b6c50b7c04f7ae1d1eceb24357a3ea0fdcee05dcd3b8ba9d9def929b496b530a84dad051f95559f649a90b9462c74eac88596f9d98e1c538725d64047bc52856316c3f05a370d66080cb8a039bf16a30b1575a5a78f1d8e87125f5dbc6f6113bf99edb4594916f7000ddd0a123d78f0f6ecd3edd3e13c4b8bdd52b11f71bf6e93026a8bb8ba361011049fed0afea271f95725d576ff89b5ae484a6c914768dc6e06e68d4c5feffb638e4ae3b0cdd0fce83ec280c3912e85651026eec8e961c7c97654802cd9d4c16f29f32cb1819d167aef342702a4acda5e36c01cfa9bad83eaa3cc4641ae57204a0e31a7b41131d734e22b2597373844fc0396603e2985f24bda92b9183fec612f0eae3a7b16b312b5fda09d9c2d42226cc4f32df82fbcb42233613b801cbd795f726424b683eaaf87ffa0c0a6efc5faaf5773a98587c317e7835a738bb53e44906d9bd8051b6656bafcbe60a9e9d9dd162cc9b68296d8cf5a790d45b40db6ac25c69d70fc38106b38d8c21ff4a91073a0007b0175f665dc1bc05f339303f4729f95b83d8c1d8887c5afcfefe405fdb621e9493c45a57937a738eed85fec889974636c65e250401ee04710a7ccc9ca93cb6cc3e1dca545a714318d1a7704571717bdf52405e45472adb65d8b6848392bc0c00f8ae1738d3897222cf79fccf8f8612de251c08aae602e886422ff93fe0e053961574a8f75f364a36fa6b92b7d46ce464f6bf563ffd01c0cc0433acad0621b42142727481c9a06190522c22608af895eae4eaba323e5a1ad5a65cae1a5786d8a2df0edb8a02597dc431114fd44371c570e77ea2d4c63cdb2fb9d04a95d09d9563ffd918396a0b1826106968ac09d6200dc293d96433696ca050403925288259137ebf35d95470d7e59c7c49e071320d5c578e814c494b294195a88b2bc736fdf385cd171a8ab48ff43ce6cdf06f35050404634e58d2c139c35faf54fd70886701e20fe297e1b845d4b3941787f3a080e9e439079f37428410f23e368747a96d01c97e217b21c2f20b8d01dab06bd00bae1962a5c9ad0dd67a4e3200483269e4fee98eabfc2caf9b3045a5850d3c89933ac3805a200ea5a80a8d5eaa476ea796d2cf99b0ba80fa804565e54c69830e8915190c374be5362561fc60e8801d5d717970171767cdb7956cb8381b16fc3080d77b95f9e2c99e79bfdafe498cc4b18fd5fb58dc26fb8921ca2b02fde5be897b5ea613692536646d55d39d3b4a44701d136a20d1df6808754eb7d7d6a19fe29b4de3ace2de32493275cb7d2edf88043e8d30f35868e29f3d7ece65c31eee70a6468fc5c496ac35fe9ae1b0ce7efc0ed5bc32a92d8fa5028f2675a7206ed2fa0fe852096068b0677b4ec6ced99cb2cb927741431fe9feb967964caef885b439a8920870b5c1e2a2a24a745f37089ad54a13e9db6acd12f47a4ee7d0b7cb792397b7f26db15be1bed58e0a39c36a2eb4a6bea717203330a66fa703b76b95cd1e3a369b8d677e5cb2fbe9cb38fc03fd85e2563fe333c9a41885609099747ea64e9f1300b3c515f9415e43a72112559c852ab523f007729c28fdc8092c9ac05c836ff74c42b609096c6e457fdfb34081569d690bb04813857eb0ce110b3582e7ab4dd702901e75bd78ebe44d999523bfdd9aa450eba7fc78506b285fd6592e5146faa316751245cd9dbf4798ee71293a822d9a61d2a76b1eaaf990e2edd6905e162d08c31b03d91c8954cd6a577d8e671cb573b217eaf340d72a84c3ad59b1d59fbaa92684062699ad564b00e47cd78d537fa55fa2c8165f1a1890dae72f6e70c93d2f50014f6f4c58bf6aea936693b126ce0033dd6defa0474df80efcceb45e95e294454239e518cc57c1ce814758db40d88c58bc24dc8e4636a0ac4081953c6a1858ecd2ec5d8186c8f7540a9885fef72e1ebc311ba20485622fc18ddb49c8ff487ab74c1532cc521b9285fc216e81f7b5eb4dc94e4ad61c313cf44351657dc7f21b03eef6f64a9454c62d4c5f8626e859ca20357403de597dc19a06c91bbd02c988124acd17c8d50a1bf7ecff9255445d5213c95787a457ef47313fe820f93b156688bf09e590a84fb5f843e394e16dd9757fd88ec0f32506f1f2239aae85dfcd7d087bbf02fcdf2266b5975e4eb08228677bb90d427b1b8ecd55fc6e2ddcfb9398d3214949f73979bb50e56368fc4c7119d32a12a4bd0b6cbe13be7e05bb80e287bcae6c2755aeaf584e59e0da2b813ee78d2b5b98bc01a3f7edaeca801db6d2924fa7ecfa8435853b11d8115b0fa611515a3c2e8c6bb595053469b5ba43b416132b6a9d2a251aae84b6f3861a37a7eb54890cb6fab0c87b789c7a3dfa9c6ffdb9954c5a1f0a1833e0803fe7e86ac3199f220970405ca251f8e89aa5954e5f796ff1efbca6bf717cff3a9250c974de3574ee71b0c378b28cd6ba7e992ff352b3825c086ab5ea83069b4b2549a1b57b1d44865d5b98de7c6cbfbb23bf9b0276fd1f53960b45399edf5d558fd2cc450510572f24693935a2032f6f5c11edfca23a606bff7acc445b664a1dbf077410bbb318c1b7dbda76cd02c3038f8bf027049456b757dbbfd05c9d3fa0587cfe9cc9e6121f1c0119c3cccf9bd13a7e1db245e57bb83618d8cf70f069554477050f5751a93edc311f9c6149f7db6fa068f4aa84dd08d68bbf05ec00fc0f30680fb2a3dce0569f7b968fe108359d6ae24476797a21a32fcfb08a7d8fc9152c9ea8d1371eba5aeca693291a9f2f53e98f673bca660f2fd43bbd995ecaba6ffaa0836eb8f795db05cb15c1732860e3b8122a99f6381c9e9baefc36a79ab4928e446856ba3aff2a9bc33b8b61423e959b8a72dc49a0048b4be867eb610e9119b434901cf495f5133f0193f878b7b70ecc8dd21c29933913ae38442b951622e7c8ada85f8468ef26fda08b97886d252ff6948c2f631d490957c91f1eff9e675ceb36ef1949bdfcab954584e99966ec24b505b41b8925ad044c9c12119d20a59552187812eafede38c5a07a44cc908ebf752b86710a0d46a12af8347d7efacc515518385757ff6871fe7b174ba0a213297473551119d1de8c71419620868b50c783fbed2af8b9fcafb64c7d5839a0e4a2fee34cbe9d60865b32634a887cbacd2c998761d0634c9f633d7f79d3f0ec018cc034dcb819c1175a6db66538ff54ef2937754cc5857d1ab02822aae49b8a99232bcedb6ccd0cb9e31e78448aa3f417e82e118a8170068aee0049eede6bcf115e5d70ff1bf39cf00b7fa973d949de3c745c73bd20191cac3dbf8d7c2708dbe2a0654547bffaa1a0f459b42e239b89ee08b53a90783946014d8fa907cc055f33d1ea633233c13de0f5482cfd993977dbb5f7dd0514bb9ee4c7ae17de4bbd330b2ef3e66654f3e3db4393c09403d9626f55eaba988bc8f890561b34fa2ae0797c53c0e2f6d6e42423bb8fe45e7b7e0e9550c3b4237b750455a5d01b54bee4e16572b905aeb9813f2979c52b66331d046fb537cb03e42a9d9d9a3dd024fab1b46ae22fa3eb59f98ba58205c44e3a08950e12017a9768c27b170b0f965a5301d5215a73cd0be0089900a325c77ad5b590c4d6a6f041ea398d1189fd30b7d70e039d9cf1b64b3ecd25d14967489219997b9a3b08bf07913ffe18c17d87896a40d14fc9da0ba5ebd465ec5972695f304c2f0bb396ded925ed1638c39faea5ba602a3d98db8e4ccddd8694bde7d884f2b868785a29d910ab8c241d5cb7eb2bbaf95f5d29514020717ac557bd7615f9663268556ebe9a8ff89b4836ef4d33f859008fe55137724a1a216014f2a0e1ad9cfbcbde51cb90f5a2a68eed87080d75960afef823da4384c4e7a683cefd4644cdbde39929854023950b5cf5e75433bbd53cc3d3231ee3e9f58cda2d4a6277199614c2e11834bd3e3706dd0dcb00661c931053899251778440ecf652239179a5179fdf2a652f1740938df0c99f0903a3ae00728cace95524113eaf69c587bf65339162e5eef2ded4237b6d95cb8066956c9229370dca469319b5a2e94ddf333b9a4984633b1bd4f1a0cbd6aade0169ca557ec76c8aee67757853cea0febd9ec72c72eac891ab937cf483fde7380676562dc50736aa792c343479c101de1522767d7c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
