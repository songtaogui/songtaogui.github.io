<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03029f8307fa6a93eacffc61104a5270cf1b092adeac7f33ba262bc931330651721f756ce1197c157fb139346a4cbf5adf7f5cc98a1b7dde5d2c317f074a0de3406c3afa7af12eff90cf487e568c3aae86f2581e21851c98f90715e7648b9f26479eb75dc80a1704a693462198da16a0a3b48303151f72120f73b33114716acf4db712de771f9de41a4751354a4c7bab71794e5e639465a7e0c7c5a0056b239521f5509d6d43c42a6de04c812cf3ed13cfee09b109fe0e8814b2d3dfbc1f5643f768e04f008e94f890d555e291c5e4945633560a251d45f1141264a783ab4d6966047956e9db213d88cc8a043225bb3aa5ba6876fb6ab0248af88b8b8fe62a2966f64b6f994259fff83ae085fb4911fa860d462342bb8efae3457b79bac3bad657628b47b4e73e8fb8483c60eced1789db5ba184dcf1cd46591c297a50edf98a6dedc12d58094615e6a038a0d500e007a58d1b9241ee9d4104cfeddb64ad467e82ed588da3d032d2d5684cbb48005f44dedd5cbc2f6e3942b679605d280911b570a2c71649ff652d85e57d25d0114d9b7d78b20eba43e6aafd235d98d998fd5d422be14a9632b8e2db78add074142fcef45a37f25108e4f6e9393295d60ccd752ac5207824adfdbbc6fa49f39ab3924846bf7600a3c29648dcf21e4f501824984d2774c6d8ad61241c4b05eeb61b9a631f295049c598d04e7d717c5fb70020e96a366228a7c2287ee9955b35165e99dbae191d6505f294350b81582620eef703e6fd7def83d0880bde45f633dec617eaeb07b8f7eab1c4a1339561d431eaf017be41ae64dc9bb1104de3b775706532842223b32e7604b00e63b9f833b78b51850fc5f09b27bb4ce9814752cad9f68011a0f9b1f6e70106293999e7fd6f825780ac07412b0fa3c8bfed81b0c7481e7a50eab1207c899217fec9bc96e0a0e06258d7aa1db4b504b5207d880fcc6f5aefb92f0bd3d4e0b03cc38fd86ec9d6cbeaee8ffec331494f848e55b397eaedf0f92d5c45c64f5f2f4f7ec08b6777dc725753f5466be3f2ad4d1988f173c0f5cd24cbd13a02327d57f292cea7418991946a8a81d4fea665523700e9625acc48ef2e801ae61fdb1cf97a68255f1a95869246e42ef2b9db23f8029ab7322cbbc1062632eaa246467c9eeb6cbd7f54311fadf605cf542aa493ffa9ca0697424d4914e4207d361e9fcb0a25da0fdc9de1af02c705f1b6371850ed5241ca9f7dedc2e534a952d1788eb7e2264e5a3b4bf409b6936b29265b745fe8fc9260701ac3902e0b1907e28992bc5628c96ef05b2ac6b3208e25b7d980c31d3afabb7f967c2b47d761858f9f7b7a3d4a4ea3856b1316e41d241f67c7a1d6a55cc9f745714e0d35e354f788bc2987ac1a0809d30aacecf0d2935847a16a0eb2d7947bfbb881fbb83690620086dc7d0fd1ba12bec549d92543ba63d4f154885be2475b2f2dc28dd6d6b9edd2bff0a76541a120251f5cee84afe9b782c0ebb72daba7f620c905724fb6d58a95d46435a899096d3aa029c2492a135d3411bf33b095508a0791402303eaa076354af636f33a85fb678f3964dddb3bd9216649b8c521ff737225483d0e2013946eda9b1dcaf5adfddfc2e90dcb1069c82b5362cc9387c37295a351ede229aca1b4cd7e08fb187479c6842931de9d1898050e63615f2915d390c68c5af1041c641c83b684b8708ade272d594f76fbf145d37a908e465aa301003cd4644f86efe050f9bdf35acf57a37d68248a80e970923c32b850092314346e81038b4aba22183287a25c92672415423285a282e81b826752f5d573a0c0889521173979d7192f97dce42777dee08929c1c555a14f19c34c52a74c865da4ee72fa0c2dbfa62e02687f2e92e2562a8914b5772682257d5c21acd14c5616bcf42a4f961f9da5e3869955a64d8ab84ef583bce178c93c66da27a402b1e9f8d82c3a2315cdb0463680079fd8e20c5056a4045c3e208e1c51f8096e32096902cb62ef109d0cf9480967d9a772e5eca6d990c092aa688a705b93d0963f3ccc57d075b965212f66a8fddc9bd5e550c63d1530e81d37f1ddc233693257529b4205f473464deb4b5dc09388131638277ab1aeb29dd3a8c74cf3db1f9b5901ee0aa8e15e56a520b61a65ca6697a95cec31a6df07c7513b27c8b3840a5152e1382ec60e318fc7768de26f654e87e1984cb7b1df000982b735b873bc0a6a66ac60838e4bfe982061d7c0b6d0008bfccb1cf435f121b825aab0407f4f61401ee05c74d15269619ad28d41e39d8efe2691473f4b13fd26c02977e5f9400ae96834abe85a5bfc126e3f604e26b972d69446d505e7673b75ad3c3826b0b57265ac304bc5d93fcb7e16d410e8a5d79a2e554266adf16197d3c8f5adc40303620637ffeb8cc46395348c5d516c85a7191e8f92226705fcb7e1b1de11408ebc45bddf1b29fbef99c41e41d6f312f1d2723d94c832ad4eade1e292b6af52760572bddcefbb471e833e1b159f2f1b0c183f3a7c4d1c59c411fab669679a389f8690c28cb0a2ec2c6db8ce2dba57659bd88d87bde012a1fb460f6099f2dabd328f09bb6b3b9d127775db654858cf3ac71b1fd2a760e06e361947d97a0e854073acaa5671544bddf03f0102716815124cde2a0bf8cba4a34ce945383b194fe86c9939b495c227eb6774b05254f6b513b7d03ac9c9ab320c4e3ea32eb48116e200d00583abbac38949d0e70149902136245b8ef90f00e30ebf68dc457f8110d0198d0da7b4e08446dfeca2895222c92d72b7c5eb42d4882d60d8756a85aa009b0a57d428c6170a0e3c42be2e837094e68c698970494a8e0e1c44ffaf6025c7471a616a2d0f477589fb181bd7c040d8f5aec837fc1a46e69e38495f749ec6d8991bec956d16130364b32b46057b8824372d5aa0952eb469de0dde80616176cd5a2b4f41aba62309a1b7a2a6400d411107803a1cbd2d43533ac47b6f36fafda635b705094b4c8ce41de3fd003d2679174543bf228a1fa892bfe6e7e4d0447ddd81fcf6acccdd614ef2d7018118459f3a8356d48a58e1a639045022c0e54cca801b45c5b701787fe233d2d487ca9174029d4b25f38efaf94e17d9ff19285f301d66d7354c8c0e4939563ef67f7e8f5d9092c18572a7938d2b4985cb9775c327e221eb57b32ed5a489b556bf789ab84e75e84041244ef64a565ee682bbc0c4ff30d0e58eb1bf478042047ea6c8e0b14af2238d43863512700717f91ebfa23f206a211f40207083ce3eb99fdaa82ea46178068b6985ccc0e624213b4041e0890ff1e522456f0f443afdac44069c397f77dad434a545ef72a07e9619269b244d69b54ad4624c5da302903e158e613d093362184bdbe8f624ce99c793bbcbfc2f983ef7b8ac83a182eb7bf6043d9da5e6a6a42a43859220f9757f6d18992dd96b9b28b030d0a51ec5a6140db6cb7061079939354e32e832fa03672a1330110cc836c8569c366f1cd1af394d4ebf918d2c30bcac42e301615906c8082f962e6e9f30091fcc57a1a577744aa149aefed915ceb3b2ae2010fae718121c4f41fc8c444329a36e1587f23e6618c93e221ef86c10e21403acdd239204b8ce124883e1dbbcb3173d3ce8c0f679b113a75d8e9970b9d235814a4cc5fb7c665c2a41bb9f2eb765776fcc2acee91baf643cffdaa0c1cd9b4759afbe554771bd36022703f411f587403cff3b098d608283cfb894efd9df0b66576c5a44929658266209def92a69e081ed407925065c84bbb16cbeaec7cd1cb4e0edafb3c31e1c25c0973a5b5440d2a4a7f89108331f6476625670d16ca16017ac19ecf88e8e73e219771a1de763aa4923dc90404d09a5c1ca21d74ffbcb84a4d3044950602235f7cd9b8bba3d8a7dbd0487e1754a051e34f468914bc80f3bee2fe8f632d98897c8cbad87b77ebf0899dba4215b69a288493dd54939e12fd438648473973a7d535a386eca7a720aa09a1016c2440a3eb751596344602d4b617aa8a0e6d8d0481915d66247a902775dfdbbb791b9199098b6f981d046442de3c5ef2cd758d935ed29aec37b21df2b95808fdc8c51d4239bc7639fd33e5aa046540c7c467ea89d27fecdd53738f07bb754a619e1942212f1a255c70fb3a46d7147909e7fe2590801c8a4c310c769ca61cef5991b41308015fe74adca6ea41b1f89623543206a9b2c0edac509ba6c6ca8e7bc5e2f6842c2428ccaa21ae8d559910b241020930b6dd76293ec35870f1540ab4d5feda4d93faa586e02f90d71d4b8092558350c54226c5bac8534bb59bddf07a666b6b95af795bdb99016f0111170b2ea0366e3679a82471d21c329bac770c3f10f945119dae5b4f7aa8a1ac914320cf62b1814faac7df3acb332fa7b72b62d6ab4df5af12cbcbf0bea4c79e503ddc9b862b1add9a1237850d0f92aa531d6c5b7ed07115af4495ef490802c658543cb9123f79da031f05eed9cc902034eb02c537e9ce44fc20daf90b45542b7c9ee4e240ed3aeed7bb21736aed86338018144ebcc5e172a9bcc86484049dc736a607503855ef1d6cf29e7b351149eb89036246c499187b8363c3823c3cbeb093ba187623c58644f924445d600c460c493d9677e32a07de0814a1156a8885ddb8c8499d3daeaaaaf18cdd4c0a86334d6c153e725ef4b93cbeecd964976a793ee169e44a1c5637a4402793054fa42d8e913fcb77f6f268379519b89040500fb0cc0d22adbceabbe51101ff0981b62fd2ca81b4ac9e6408bc6042b8dc342dfa8bd40c4834c97ef62644cac1882be150db584a77a3b6b4218229088b8412cf4b083e2e824421e4502f5471da9f3e87303432ff73ae04b1cc287cb35af53d3e4ef42d764283cba8d07f34394a5d34cd60023b115b715646822b3372fe9cbc9d91d7e35bf3f852967cd7ffebd4233f779c88a7475c09448387270355a5e5101f22b44cb9edfc6c9f66db206dbbab80c20056da211d62dc100fb7d840b9159a9e07974bb0b13a05c21e2561ac8e6cc02a76fe7d8832e11001209ff9a5d97e36b0eb80a78d5d1a8be644fa6571b01e397636b5ae9c87c3f8f63a5109c631d529ca27440d68c12b328dd92fdab890d7451ffb2d00d35801a0d40d5a38564045adcf8f6716142ab6152d67c39dba1986e8b01a69ac86eaf17046eee450e451146386e3159ca5938d7a838baed62bb1430be414cc4072ee883d2a2268c1a564c628ce2111e9e0d9ff6f366a194684f17cc57fa49cdaf9792f7b6a78ad31890e3a9f30c2a06aa343aedd57db67463910ab88809d03b4d1844a89740ac09a613c232d8a07d710f2a52e294d27c257bdbe6ba18fe5f5d0e514540f6909335167effd3996d189e8e69a266a4d992cfb24d9fa0dc8b54c030f5e686fa86f915e636bdcd400fec42496ab3160ca201b4fb891bab1eec68211dc91a51457dc5dce1c7c0b7967e7cf81eed7a4890832263fc0405ee422960380425a0b546a02a0f8f5c65f0edef7d3b4c1cc7db968a915a32dcd84de623ef01199b5291a6e792a7195b450960dc141a698a3c69ee8a3a8b29bdee193a433beaaca87c7a35cd1e8c64c44f63b5686870714b37b61e04bba0b7efd4e77e5b18e269786a98ae5881ad1697a5a73817c8287b4de187a59c24b3d60f5044b0562dd79852d918a9fe5f2389054d9cd39a36cdca0b9ba5dfeefec0d3502855550b99ca1df3ddb237e684549d793a8a98c448fc399023c60af7164b0991fec82106d8e264d5823f03f9c9fc0fd94e1cfd06c1cdfbafe94974951e0c52ff07c1200c9bbbba888e126db8fcf17ea20d931c1c8fefcc9ffb460d27f7dbf1ae9c135b88190c1c689758e6a20914234e128a45cfb8bf7c545c035ae10fa05b8cf58f5fbdb82cd1230becab910eacea0fb9e2c274705cede3e34e095f071c33ef0c96aa9fb532870f0cecde8bbe85a06dd677161d380db74d6faca904e12c23bd249d5bf59191409521d5f280c4b95d90a1aab10ad679e321312f145b154ba02f60c0de620690fd49bfc7ef4097c8832386a3aee2f2920806149472c54b5a59b016fb1fdd675f832e459e69af00b233b9dcdcbfd7f546fddacf2af3a3d3db208a71cb83ffc6b8b1f2d22a02a6b4768c0aafc73c3c7105ceb8506fc243f954ef3ddc11ab88f0b7d3ee237c902fb7443debb2d9f51a4f79dbf1b6c9c6f58bd682a6c081fed708d15cdd66c7ff376c22a6d0f90ea4448cc2bcea3d7b384a1219c4d49571fe4f9f488f0f6380743c5d8cc20ea59a3314aa0c9a95bf40ab61d1cde20c8b4a7c69cc8a3d45249de8b8c5c29b808bcf1d943307647b6ec7ccafaf486ed10b71be5de9f3ba2368138799756e7a05b11befa5adec38b3cf8f29f88bc6d845e40182ab5d3ed6c0c9c38925a3aea36007953e00cd1407f51bf51cf1129cf05cdc8dc2b8a4c43e84503449d212e9e7f1f9086fbcd3990b47e1502542ae7d9f52cd7639084fb159291fd30ee3d9738be087849615d91bf621c85a937242f22112eb3638fdd808d5ec52d539869417cb7018329cbcdb50d16c350c0491610aba605af7f2f2fe1bc438b10a7e80260aa850cb8c1a34417c634cc2604b69ccff2f31ba9433ff5bb9ab17aff0ecbf5c729d3554d4a4414971637d6703dc63b9b07be601c5400f916794ca2af1f1b9704b94351e0315f410069cf4298d8fb0fbbe3e4e89610755db508b2818faca3417aec1e5632f1d6185b7a3cf86fdbdfbe440c050c310b49ac93b6ec92e8faaf1b09d86ce91a2a24b176243b400c51f5659cc9d6a452a584ed24d8ed2786a7c5e15852488ec766a962060cf5d8197eaabe965a36ff7b31baaff3a0a7355c8efebb41ff7b45132189a94b7138e427bf57b2edf8dabf9262a21ad4b615a33c674282eb648c8697d5e84f85cca9f5ea85a070742bc1620d6bd59e1fbfe7dc466de7c01e4b49d96cbe117059049c7bcf8c4b44847e082d465d17d7d0262a162a57ced389b3f3b05b35eb485421d5bc49e57ce31782f22dd52eca498da9de2e5ed81fa7d010cf8be752bad9ba483ffb67d6db9e204c6fe8c2b431924e4da972b745a6ce7469967599b6bb15f06412dbd054d5e26ddb8c0e3665c9c4fe8b83a9863a6f3a2a19205a98a4645d5c3fef8fcd4425499256b53ad4cb379b77e73f2844c79572a2484ee4da2ead6a672bf726bf89a5b2334757d95dc8f7f2f69d9cbd76ea97a6f3e1a1939871635e35612a5913ac778868c2ca97366143dcf9326737ff180948f6a2c3b0e293aac81605b6f8762be390f81cef034eece44232101fbc64d16df140f10541c3e1162f68d77f5137cec1637c32247d57cc881acd0628a0c2e0b571c1b30a2bb883fd55710e7f7872b284617965077616358f86ebc6bd36ff1157f0066b3526af74dde1ad78beb52c70143a767f65ec3bc304466c900109ff1b0e08bb17029994c35763bf6a7fd77d38b15b3b2c7c16cf9761bb816242edc9f6a7da67bfe41dcac3018309e7b6a6f2661cef3a052e2030c2f8330b9e5c7b10089244e10a7d137c57ce7d48863e5754f53ee9ae2c54ac5a4b0b7e6d9aacf29169467d8fe310fc18df2b77ec78ee743b7e3759ee4c3de7e1d76e8303cfbba2d3d74bb6d7bef5f761dd1877c6b09939e30a80449c3c87a523b8254c1b8d5af322bbb0f1311e9c9b3db4311ab2160f9ea444a3c042adc9f331f6ffeeb56e15d1687598c2631af8a59042aa58b212085930804c78f2ea75728671f454f992c0264cfba8a589aa5f89d50ad2de9684d4056817bfb19bf427a7a9bb88681e8a05498ef86c8b4fea1b8aa48fde965a033f8a16132adb2fc059cea4a4f1a970e4a6d24f4cd084248d1a19b06221675ecaa44fa42204e4e9b84ac9202edab64c7791614cd959e916b29e7f2b2e6dd78ddc7a1d7dd8d87fa13e98eadb488ad754ac6d3d00197f44e1c28e59213f09600a370049373610d7eb9ffe7dba88b1e7f079979d0bc787d85bcee4e01e7af03ed4ad905bedc0599b7cecd2062a71079dddd4622a87ecc40e3579e28e055defb51a1e0ddf9e58d43d346695eecb4a0f1b4c79016f7800288fb0d06b605a2c80eae4528f9a318740d34ada1ec3f6e45df31e568425d1e630692a181cfbeca154e11e3b5dc6cefd0d24207f6d50fdb2015a3726bb7a2f7a6fc7aba265f03534ec05bbb7cd9167d08b0244c5b514ae3cfd0da7882f661605bca0dca2e91f3d9c8649bd59b17dfd180022bbefb88d13be3359eba2fcc9afe667b6e1750469102875287c465d50446b16482ce3e32a0aacdd9e9d5591a9f3415f5441f83ac4a296a44b5d78a388b90e26e173d257c24c141c2325973af266fdd929799ce9df0acfee99413e246a8c24126b81223b0e028f20d9349718940715099d47e2ba5c7fa7e1b1a89e569d5f0f5fd63008554466f714847e5cc60d1418ef5755951c6f3ac9e26e87f0a5c31bf20a98c2ceec0771d129e9f4ca1724f128c5c3ee8eb5c1cbab7bf519ad79deb2b18933dc93d8d10289b4909cbbe6f733fed3f863e1c2ed892c3f11702cd9aab5c8b2f78a6d18c324a512cc17ac562815e1ab0e8532af1d020fed7a5caf91bbbad2f3d7feaf48a1d34774e6432ad590283ff223e2ce6afb650bc2cb61b86a240f1d5c10cef32e6d55fbe2d2ae0c801dc3d316691b2e3b1a7041b65ffb7e33b7fc73f24cab31fd6402a9183e68c7263d25c090ddd22950be09402c01ecea61b8416b66d9a91b728a1955c05275046720864599ee30d591adaa816c4c9f36a3811e5b0be87cb7a75360cfee08ca74874047e716980309926f3be3817df0ed808197ffad2929215a1897da9e8ff726c31d5d1e8ba7a8d09dfadcb8068d7d620bf9e3cc781167ec98be412dfe299ee72266a5f6a690507110eafe1f0e6ea7c774b1929df75970848793c2df8a3e151319c136bf7ea765966f92eaf1a70277f70e1af5055fb4fb5412ddd45865832894bbf35a6746ab20c965b0d81937bced57e33bd2f6bd468abec0e079b4ae934a96debfa6b368816226ea1fb8fc87180023368cce6c2722bd60fc8e9219c09c3887617ed91b795b5b4c523abc62c76716c74ea77fbae9cc5cb698324049a4044c1aec81f76e0c2a3a8d67bf3cacaddec067edcb186355b1912f30f5348452ce9d9ca9108e69adea97503476c2e290605b5ac90d773bd8f6a29c179c817b2ebd287c5adc061c1526e0e729c05b90ea2383eb7fc582e2f1e6e5322aa6f9079624d50c96d363fdc5aa5034ec1fd73364c4c79b775e5cd573818be86bfe362298a968d784b3ca688ce3421c7b3af6fe8b9b67ba724238e48d15a5d81959332c042342c41fdd080c3c56b6d4c5587243e8baca157c22ff3a36a03d217974aaeabdaa48349f880932daedfb37a56e4b3d2ccb7beaefb56aced6de9ab2985165ee955426f8960aa883a62bcb1c47ee2d2184a8789886ee36ced878a0a654875f5cb7d107d133620c4b801b1d7613575df16bf393799805dcae2e1c1cca68f53f1235a1ce95e417787c331c606900ea6e62ed5046dfec11be002780b39040c3ec72a703a55728cadd2dd89fd1eac55362cfbe7ac3936561092e73c0131f87e87ce82bece65f471b30cabdfc04351d4d6d5b3c4b9e1ee2ddd994328d8b6dd12eb82ac7e0667b7c36b34ee8f310a93119feca5c00fed0e8ae896f48e81c1454be308997ef14d5c5110c74d292e2b2c5b02a86a4e2b81bac4492225e3351de47804d4a0c54f21bc5656f1ff2a20db863e3fae1064ad17feb0e194cffeec2309ade4d5fd74b070abde532bb593ad09898b5fa8d8cf15e37ed6d85fe5c0a7b052cf4dcbe668661f14e71240257bf0a8ae489f41caab7cd150a3f7d81da72eb0eda711af401118c06d421fb83c0bb02489fbd18baa3f0a96b54aa990a7a7287a18f29df08ef5ada23ea69bf6943c39eb9c60ee291fe25910a6654a87c454a1f089f31391462770f90a1de3bee156be24c65f46f53d0d2448ad2da89ebb46d407cf92efefe9d995d9286e440ace740df81e34a5c2ed226c246540bdd0100ecae064f1696340065f40bc5c6cc8a42ee11b4be66bf2ad87799bf9ffb27bfac16c90c062c627d44504d06987202bab004fd03aea7d264690daa7660d973f49d04afa8c082d18a1d8ccabfda7d3433078557ef578348a7d2b64a08eeee7128d11e87ceb355a44ba554024134124ee2f14b15ca8131a22ce68b225577599bbb3b0c7551f43e59eea90b5f81ff207ed76565c6a69393338b5eb80cca5cfeb9ebcb517e14439709c46ef8368995cffe26c4012a0cd5f4840633c942df2fe32d6cd18cb47a5d40aa644f21ed6325e1ecfa9d7db22ed455143bf635af5b5390b611709c787bbb573690ae43ed762bbddc2c9d8c34b7571aa49b2e743d1f6f9a809959b49967c7cbcfdec4408175908c8e20447d4870894beb2cd4051c87360efec8fa10dc4c75cdd5cfda8a1d4ab446f99e43dbd3f4e6805cac85e54c9ed8e2cfae7b63a330572fff0a55e7b83e4bb77de3157e71761365bd32d986a1a6fc8b131c75d736c403a97da16feb11f6c4d01b2ecc6987f15c977f1d40187d0937353ada60a7ad577da04d0db588b546156acc6c42103a1b65b30bc33954058681cba7cf831923cb8b918a0d9016a79c92af0286b97702e3e900593049988cc9fe9dd209798657af0a44f30d67ab6a01630c1e23168c90d583d6b38c256786181535a3daafcfce8277ef2af7040307b13b692f3773ba047597d52f1c6f10411f0e6b4c93ac62061b4d9b85cb7a7da983841dfb5b29e0b864004270839a6391388554e3c47f47aafcfa49030dd45920e3011d9291e924e7f8a9a9bed590a2741b3f39de19e86f4874f6556f882da95cd48b8eaeea762bb764e1a7d2d96e682c91250b0dd00a080b13e9417da20d02cfd22b633bccf01b7b96041cc50d66fbad8bfabd3284aff430dedd950d144784103e30a726fa479667b21473f104e0d6d08042195da6558f901b8cf1841d4fb02232e9fcae1c863abf1a8a8f116b4a973e2a514ae68c5741ec192f63968098120c29dcf387bd5f294c1edbc6b8959d235ff4134e2e9b340604459d0a3ceea3239aa14dd209281c5d0a53ea4d4997e6816ea0e022cd69d28082032b31769c4a7f770b59e1b67997078e9645cb00aa9d517f77486d34cb4b063ee545d3e5f8f7a25ec5d0fb6170b74c1d097b584006079a27da2be8e7e4d37fc2683196794b6de927d5fa53e597c9745a3b87f4bb2f0ceebfb3fdfd5778a48e4cdb3375b740f96de2078195c864f3f033905b39ae6ae390c9555d39bf96022459aa8800036a43a2ea789db44b3a4e0affbbfad84ab867a8ee1071d77d60e615257073b66714336aa99e67ef4cffcf0fc7f8eae123ab6d35684013b179558bd932af42f79c9709e006b34bc5a0175b59af1893dfd575e15a1ea6f6760ef2af82655abb4734b7b0be81adab5467a4b4122b1ce018d462dcf02b170e40a55ecf71b1a00bdc548cad91d9766044f53072239a92d7c3c487a07b820595ca313d5085784b25e3d23ba31768be72e882f04c21a303d19dd525e840108619eec074b224a53e2bbd023a720f2eeadff2088c5734a924c59baa725abcc12a4018ade530a95a2cacb7f237c9148ca190afa35a3d8a17740700ada51b614c59aa5ed8ffa11c6045c3f808188b8fc946acaaeb1c73fe8811289fb70bffe979b3726652b1307c4ff487473a7b2eae73e6c592bcc50b162d2d4efe70a71822c22679e9a100588b663422e132d4094d1390f0681650aba386c2eec67b4c9855b9353342d489e5da176984d946839279bdd59fd09f13846152c2665d8724fd8fab4ae8448d6cbf37b36315d92891abab66392212befd64551aff421143a7823ed843f7e20aea9080dd35c7479c00771c29ab71b46ae1efcbf254a03229998c954574fcbb012991baa1e3795afac054571473f24b13120bfc0d87bd47cbfc3101b137d1e1b88d9307fdf98a9b5917f98b2351df57fa6a7d7fd522107aaaec9dfb5459d4321db759dad1de589e24b48b8db1f321c6926256168cfe14afc0af2508eb6cec9e6e1484fa9b2c87ba96299b8e425d8bc838d30da4f3363809a6f71c049ba9e1a1c5938921169c28f554b253cf56f471bba9f0cf9faace3b6901852fa0d00ed82155dd4a471d26abd72c9a6600cb3e28bdce0ab1886a8274c14a14c2de3cc8fbf62f2d917f38e8d07e1425ae87dd941b0a39b3ef1a2e3f44224174381e40b8f3821bc130bbf3ffdd9ca7787e94b3499f38e1b02c4fae997f5a9b163a54601298095138cee9d087f42c18b2b11b63f82ebc8aaec1120fc744c1c33d4fcd29e7695a24f11ea1f97820dece281dcfbb49c8fad9424894152c72c94a836798c59b7ac81689530675e72ecaa9910580d7a5310ae6072022a8ab7a3afd93f47f3dcea0a924a55712b1ca7cf970c2f9ee864835bf07ab9ec366bf49f4deb9fa06e18d16601a90dc1b567f1138d83792dccdb73f65af7a80210ae53319f6ed26cbfa461acf2777696b77141d67559cf190a7a46896196a957d07817fe9416475c9454793a98c4b1df623a447f719227797dfd6632aa95464ab7994e2aca59bde35ab360b3b82654b8f9bfcb120a67704278deb235cc9a77dd0c3bf5125299778a46e9aae8fe4b509aa0e35d864aee726fb4b695afce76624f891f20a37f06caa35d4311371573664e3b87d5de1b8df6f2ac435548a25baa3fcdf8ee973d1c6ce6760d45dbc81446220611f8ae408b091ced60691e83586c7e7468307a99bd2f61f774aabde72f92e07ff7783ef8826220232bb580a7d7c8ff637b5cc14ca5e28961001b42e99983cab3a4c51d03c036cb1dda6d2283eb7f51fbd155b53912d351e78d041cf4f4ad1e57d93c4b4eea7de29c5eeb0b0942f41cb4323f06e78faa38e407e0455808ce1eedc94e85c5f4920a55fb1c8a96e89a95bd2baafe083f811c2db46a70bc702165928eaaaebc61525c3c18ea890711db2af5b63e2e36e7a95d600e4f54c8f091735dd1a33d9faadca6b1ef53d96ae9a80b10156e9da8bed09fd5f7e94303653a5792e7d036734b946dc66da4a6927b356fc8ba4e52c9367ae52d2a20accd67d4fd5c1fe46255605f082f87151b5476cbae66bb6cd4bc08bcc23d9ee86238ce95d3bf29deec5e04c3e6dc880fe2b44ae9b69b6b600a883cb8ba67207f61a52e98829ea1a851a733b7e04eda5587bb79b3aa2ab4e8c91b03d5052abc83dcf84cfd51d82ba14609f4105b60403eeb06f85e0914fbba8aa9c5741369f7e6592807f8bef3cd52058fc7bcdbf0d8d8d0a271d95d83bb8db73205f04a4d1449dafbca0d57dd9636bc6396ee42604b1c81afcade1f20dcbc0deda88784ccb4717e9928d593936c1337e315179c7230c77d23bbcea47b9a47fadc453d92e03b8bf885696afc57111a76256c37c2ab83fb671eb7ff7a247da4f120687639c749ab8f4177ad670a973925d9a03484538c5604f6aaba2ec3e84f6b2575c544ab08d0f486cfdd996b216be01162e6a42767cca73953d15af6a4fc5d3477eeae0d96c6025c0bd3d97cd73a35e38119194f31129450ba83c3137c0c2a82beada879cbcfceaee60ab5cf8b3055ece5d6919320c33bf027a4b9a47c2e2d3bbf1118faa573b8ceb0807ccc4bafa7e42ad0a0439b81959ccecee4df91f4fd58bf879f88e9d9d69aa2e715236a59aff9bb026af75dbd80fceba41ea5db3a204bf63a9b118896fe5252d64ac20cc1f63b33ac187d91529e6f87e1c546cfd5d61d05f32020a573975bb7040dfe586e4d885b9055f61e8d430319471a806270597773e3475f602ca5b4a120d4d4cfbc1b8acd7eff99785ff9258eb5dba9275aaf9427c301e61400c610b4c5953067ed73f63e74f137b2c83c418daef20811eef431a7f7f18a69eb3f060f1951b0d8576a12663f70dc2c44450dd24ec96fc2c169ecbe5901d950f4654ca1d5f937e49146de54031b025f8b556062958247f109060c10f161e868b4927d572bb7dc71b33e61716c0e314ac728fe4263241e37a10e659d4cacedaf83a736315d068884f972e032e406fd5da2c2254b180ec9444df5208eb442eac76bf9e9281f038e37590a80fa4421dabf97728be30e2abe3aebebb3765a062b35b1704e0900db04d342cbe23a0a7625d282b4e19124e4f976096edd3ae4bfbfe61a204a97d62b0916974e480c2ed9e65ce594b0e970bd31ad65db7e82d63718a16c2c16341979fcefd5013c139832b297a188a6c454489c1763c3010d316ca8b2f97d5b540959d9e88046644298a7262f654b943713a8413aae10c9a622035063df112c54dcd21aeeafa0fba059bcdc5acea872f73f2b3641a9ef7871ea0f56e5bb7ddba2a28b61e102a462eeea7f38050a8889ea200ff7807ad7ba25c2fcc6a9e0aba077849cff170eeeb35e5e367ee8ea8d49dd67767757db216fee4a19370bddbfcbeda7b013fc6b482ffebd3b18b4c83c69db0264bc6092afa292f0b4dca72f2692fc71d20f78e31cfeac8c8411d3386e8177d967716e172d9b45b1209354b3d339c347be225726764b535d0217ea310be73a24c5e644d8d072beba3f72f0399b254fe9e452e0e97918ed0c8054bcea3368c31e23fbfc222c630d200f2a299cf956a16211390a10d0034592efc3d35fd53d49dda2a0b5df297471ed6f07bbf103a25637c484db076e58d5444853c25933388f12f44f09c5a0360e01def0e50f945ce600025554ff9d561d899f9bc8ba9ccf235d9a89879b4e08d71649831daa82280d198eca22ac6909d42f915ec0fded69d4f6dfc6be1d0858771d15486f3673c5e16dec2c01ee8a181fd8f3aee948fd18668f76783c1ca21a1fc9eeba605b26296a7558d75a613a59b8d6fd6af9dc15cd793de6c9ec9937430c6b0bab6561efc0f9b1d5568e0bb19b2e373b2be9c9f1feec738e02717ef67fc8bf17a2d730093473c6771356341541acd075302ebc1be7c82cd8eb6fe60341c2413bfff710205b0a9b2f9ab7c1d8fa93fdfd74edf5d6bc047f37fcd6a24bda8922dc432ed71095aa062023615361a507fc7a9fe35ec7fdca568408311cd59a4618a577e13e54b217975f10d77e735a075728f609565f1ce34f14793b08ed0f647451f8a957314fab2696387b8daddb0496a5d75124dfddeb2d286c804998111bf1929463e6c3d430b886be91dc6495aaff8855b7c8b0a004aaa1e4cc08beb85aedbc4a6833392414a2d56d704038794689c21f11f1e2d805f446c14ef96e370714d540edf1082ea6681501f1c05810a9162c7b965a2cc2194cefd57d2821a7793812081844bbbf91a0527d0834a40f33a5988d039454b2ce4f4f62b1cc6cdf4b5f526be511cdeed479abd968d342ace3ac2edf54dbd2788d64d6665e44c424e59193b779dbbe58e2a8d71e36ca53e2845f2bed75c2c0a75a4fd8ee3275cc1f693a4bbba566d8add8adea1e7a26ff6f0afe78a35fd169c6a617507cc98b6cbf5c4f3ee7a51eb21abc9fba8db0eeddbfd3e94f9f176a377639d5955bfbb1f96166472cb28295c237d17efaaa3393e5ce2828158cb9fe32712beadd39f118798952c892e2031085ef40f18e8ccf834c95f9815a319fa6b63605bd88fceff0b59c212a132c50b886d7a26843f9dc81236f25306d21896ae0f1ecea3ccb35cdf5d652583f4847b3ebbdef07d2096c97e45fbe662ba75c9c80995cdb3197a3dff953cd0420413f12301baafaad8c35e8ddadb8a19b86c99191a7f8c45ae5758a8215dac2f1abbd11023578cf08ee0d133688c0ed51b4ca59454e9ffc69adaf08e688aaf92c2dab9e80000cdbf239775e1938886070821c920f6176ab476b4b15130e157cb58dfeb84539ddb1398211992adf204ee04396eb3559d8ad410010fb87e1ce8c84faf696b38e75d9112b2b645cd1f058511ea6694747908af12d4e46e62d669118f5c3b1fd9c974c369b8eae18a4b8982d77fe116517a7f3ba24186596dcc97bcca6af4865c5478b14200d782bd93d7a322b08559c47d0338649ff3c3dba1e8a7a5f847bd7d56b13c09557728c6f5091f130251b620d19babf087830d6d8e5121c0756f3211409e0c01ba52889869873429e8a8090698c71402374ac03cef3ed4a64f5e46a5483e8ed5668f3e84bca31f0cc189ff42df1954611bf7faab44cab6c991a7e00be20e13d1cda1f9a91e3c1903694055c428201aadc7a285311aa78cd4b417f4e0ad19320e8e7c5731926e326302c643b2a491babba0ca8fe7c9d21d54ebbc0eae0a3407b7a0d8b378638f4e5e7103e5364b5b296eb69dfce8dd2b413e5c817ac0cbe7148d940227dd6ec431719060530edf83951ccc3927f722cfb08e2f34b61289c638a451cb15fe3b30dd9472191f29ebdd5f116a0497dbdc0b0e6ae9152e10cbd48c84c8d342e1ab85d4910f27133e2e31e1b1172e6326d88530ae74bc8713b55733f3bc6f1c7ea08e764e4f53ccfcf4a8c7e06bcee46450be81be9afaac6a74bc32cbd6ab64421ce33dcee7dad8fb0281cc2b065a28e0dae3313b7943b3cf9144715ed400427fc8f4c00b870b62e858d091609d0fcac203ae4fa94fdaaf0c631f0a30eb51a1243138786957c22daf1e5bf27517ca693b26730174540a16e0eea8daa348092d71659307c059ca987a4cf06a7f5f189e4f61404865ba7cbeb32676037215edfbd8eee8c0075971bbf7cfff562c7ab98a1a706ecacdbac64312939e1e728fd25676247276e521448e0c1bb02ee6b7f66405cefb3555ee2a0173891c5e7db86541f06215a51d2938cd854f079e56145477d62ec4373357e11d6ce34272da05ab216bf6630f5aa706bbf71768920d790994d77300325b01e342bae3a00307d61ae4d85652ef774fd2785b470478c5d8c8ec131658292211a8863ff4abc0e4d371e2c8d56c420e762d492339722c907ee78990526cd9de4ec6a067f988332e6c39ec13810306a8d56c119f9e879f6ab889da2b50f170299b5e9ab7b36602fcbc4d741c8763422f53d2c35757c29e9ab07bc88f264933b3cbe53f915990764847236964f887aba95abf24143fd6ff598667742df7048bc23735a60763be56510f7fe29fdbb86afc23cdc84918170c162741da5b026db1a68fb0e44e228cb51d9cbe1b0e7b1154c29de47885de933e25528000ac0121db06811cb0ba8027b80e3b144cd41bf076047e27aad40b4987f88b1454d62da81c388fcaeebb3dd84baeff4e2ba0bd602e955df3ed824122dd772880c10f1574b9b47e03c084d9fd31c4ea491cf525967ea517bb1947c3ba19d99d41ef7770c4a49bfc97e8584212477353c058c7d22cff0d0e6fd0ca1f670607c04b8e32663e9efa1faf86a39862f2429fff8dc9c82c652a9a0cfcb6d9eb2d13e07101d7c63e132857e428f764ac525e08ddd1c266f76f66b77984706f4bd9a20de00386ffd7172f53e4c156b7700004aff6ad35b7df9ac1b0ccdaea5b5c0d45f7db24d16f1391098c49e52766e2740e10cb0e1a0f669baf8a472d02ca8e5f4600ebe803182db0e9ad335fa57a492859dca9f71b40369ee5df71b929c7e94a1a2a2991a49bfd2fb27f3751e66e7bb43f98b25bb7e3ede57b1c2da897c05b7ccd5585c86e9bff9f5b0e5eca15cc41ac27e1b0aa622d7c40ba53a3b4ae7e408c3fdb296f951d970b0ce5ce3550423087ad791dec8282f284278134d76a466f12474bac6555769fbb9481d7148dac2476cef272ae80d3bc04bd1dbb04b76d0f57af969bd89aa4260300b953ae30ac86dfaea712cbe70d320e54bcd7861307bc3687ea30cb34d8d19dbd931be452f50cabfa8ff8128e996727d1a74b49c19163908938befd530f3f93c334e60bc924eae093c39dc2ce9475663463aded357e7ea1a91acf6fd18732bd13a875a15b10940de9d3dd1708aadaa53f0a8813a9e3e1c84f3296b5940e877800efe0e46dc2631ccee9a7871f82a567c1173048d8f34d4ceae62340bfcdec2dca15d51783da5edf79142e8db1365cb7f28961d40c425ad1ed55d6b5075859f90b83dee37c4de731a2d096c6448cd66f4f0d317790eb2082f7923cc2fa370f918975ac655df082e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
