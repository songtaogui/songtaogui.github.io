<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41076266233b1a1d1578a250be844126671c28ec917d986eb74659352393b4886246bc5caa666695e93433d72c86272faa1237321224df38dab2f7537edbe392bdd092aea9586d43f0e356a92b8998017506b9e04778458d72f2500ae909158210670b3537597c01c2d44a832632d11172b0752adacd5ed306f47ddf2ceac923f4b45e2c2efb8806388b109f6f99511a4dc5d446be6487399187f9c755dcbf17b35a7d5cbb79bda15c869974a016ba738e00824a14c9d2f00380712201e71c4bfe58dd23ab9cae1956532ec612398ea76701acdaa3fe6d0b4953c4e354ea8b64e9e767edf511d0dc9e1092768b8603d70dc7cbf6cb1654345976676e9808f3d132b9518815752c9fbce8ab34542cc7ae4a5b5e6565c56a8ef7d0a03c495403d11db434d1f1f0b968d2897fb40a22ef6a6f7c6c800923db83696355528e88ac32befe1eeeb4c4bd0f7108f01cf76d007ba0113781a096b4836585142749acf92a45af9879006ae72df5b6ef5105a2d30ee6d8c783baaa4de880cbcbdc125b81914728a93401e14cc03ee58dc81eb74baf2a140a16fafbeed3900ce0306966407ae6b414b921bff05c9f0ea668e556a804d0de7a459879bf1ba408f43d048fa7f2854a3f314e6e54aff7b88fb4a4e3bee3f55c9028ede38282f32d4a3c699679fbd6a02252f9bc977b2fcd04e86838daa68e0236cf1c05e05a7f8ae1f27ca8a26384e41ecf7a93ccb6d87e3f9ea5ba7e98a6b0169e6a68996b5e68e99854c96cbbfe71b3f2394ec60c56e03ffa97fff0ba06499f60786b0b440333d07705bc49b9e7000cc24e609021921509707c4bbe7a32ceea69af8d980f350e1394495254f57c48aef9f3c519301a44e46e6b9f86b85305c31154d9328b716baaa7c4abdab94ed94d533e95ec3a9f1f594af49772088e6723565b355e32af13fc2c8b80384e6bb8bc772e74bb37d5abda5e37619a9aca88d091871dd82d3ec8c1028e80585efb3ab202311112ac8372dae17df08b0ec6ad1c00bcf7d6b16a0e1976bd8f0a45a5674e80247b01df73f55918ed86335ee02232977f74cf79ae35073016a67c9d2ab820a079115abcdef1e59ce1d866fcb4e601730c49f73df3918829c5bf5aeb50cd5a3954b8859548c598c8914552254c3a0c1a1d1ac04e86bd087dfec40c9a49c2a9bdf16f80cbcb8ac9ec04475fd8accec2d698fba054304ecafcc8015b1ba34a9e326cf2d5c7b0a3766185618486b452decb30e0c4e53df469aa9192909fc4830c4087020c3300e3906881861f0d71709c1d956084bd80133e90bf5ff8de15460ebe39d6528fce571c493c9a34bc07f286c97a6fc863d19f73352c151e79370d72187d9707ad232a8af11de865988872e8c00b2442e1282539eea7033e8b9c858ab784aab1a614105b85c9796595603f4e4a6affdfe4e5dba4f475ddf7befa782069073834fe173bfc98e3e00baf16d5d309fd9dcbf7d5efd98ad4c4bde0df41de7f07e668b5ad3cb518fe45c01e1b1f813e4fad7a650353a512f110fcb423aaa5e1a6f814c7e8f048e01b8c3e678b1d5bae71ae46323aade198604f5ab8c26246e83951dd8987bb23b1fd1d312baac67b7f58f7ab522aec11aadb72982db03a63a576acbad5b69253d9ae2a7e79259712d68934ed869fddd9c9eb4258123d520522ad17cf065e1b779ab3dce9dd6826ca426028538bf0096c8aaa1ada0d32d22b43a2c0e5abf8608177aa4d939bfe51f024d5cf4f2c10778e72182aefdfceaba724de1309674606515f490642589181ca15e7054ab2735488f819c5254d05ef981b8207c9397d9f41a746a7b31b8e7769192c1093084786434ad1c8d6106c7bc30738efea3ab97fb5f579a32ff88ca58040be99e5a32d4656b112f269ad5925a283a0d2334a89d110d1a00338b7d3b616d3cedf6f8fd3e3f33f270cc3bf39203bf4440a891c465c9040e635308994482e9ab0a1414363a8e775c16ca7373083848a800efd3c63d47c17c882f04a01fee4f4225cd1267118e3f70c24d9ed91b2db52f5e81afe3f2a8a9f64bf3787b2628c007d4f98e6fb640000b2902a80a4c28a5f99b392e375d2db9831a8382cf1d1bf4477fed43b27b053e2b651ae4a7450c7b1c0a14ba78f1f1f4567efe0d384587f810b56540e1937c9ebbb37803073f752b8a46e03013b121259c0dcc5bbf32941c0fa06346cc043e0ced68e800aabe39ce67358fde0aa155613fa3cb0f787fb498bc2187a030b1ff0bf02b6eba7226348614a72ff37a7e9eaa2bfba25f22dc7cf2ae19caea0742a72585d3710d53c595a0460f27d2f4e938a88c3b484d87862b661d24da749700c3b00d28e641daf576ff3063aba5a2bad452c28ddcd972187f74a486a552eef9842385c087961eef4c186c7488fa469491366a1d91620af084c455e9a146de6d93a21b215118a90711f537f2bfe3fe4fc835fec158be78a4634da031879ada4b59d00589e857a268962d8a98885427bc8da5deb4887ee6a2a52d9a4c5f4ab060388704ea57a98a94c86b89bc982ccc544a2fdd10ec833a833d98441273553c03e775293ddb75135b5d202d277f6f4ac5df65697eb0ff9e6ae7005229ae6ab6a6c6419cc4c2252f13ab9e1c369ce4c29a98082c21cf2422762886b209c54613c4f99d07ba6d595f3cee87a3ed97d9f5102b52b03eaa09635a026578631a384f64673365f1c1a2d9b97fec018d67fbe21966c5b0184f26375e5a3ff55d7332ec22afb5d1c9b0e3961f07b9b449a174908ad418542177c3a671c71618e3d7d4488e3c89e93bd0f9d2c86f69879fafb43cf7be961fcf0e3a34622e16a13b632531da845e1fcc6e0eb4fa38ceab6e9e28dba049ea7ce2e313550e93645f39d5af559363b33a5808dbb58a3ffe2fac6d429955ec26c0f0f420967f966ebc49dcab7210b483f127cc779ffde7fdb49a42891d87e3f1d4648dec588aa779fbe0fac41cadf54f4d299e03c529582ffb403b097557b071260b77254d81a0ee953f939f4e8f5109fb6cd1aa7dcc861c92c149650589e43dd10b651975e65dfba335aa3a04068dc16ff50a27984f0342a6044be3527f6cb049976ec938dd1c1a595e617f814b277c148cb2571701715afa5aa3a963b2f1d3ac5f5d2d6f37e4f49f079be34216673381382894095f11a0273c7cc6547bb8721594f88a5f548725faf2d0ee2c93d24b12fd1ea82151e3e5d948a251c4e39b78dd2662bb7069c707b23ca9860f5768b0045ec82337f00e69abcd6f8703a53943d811f7e074e15d744662072f38f1bd77afa248cb2bfcfe98010b07012e14b9c1af6448f55ac0fd1adf52c50592f6e1566248552efd3d302ff88ae6bff14e1420136395af69a96b6d066532666b45140981d8eb1498f87a293294960eb74cb1762db447b1fbd69a2cfc8b56fe27d28b87533b9a5a654462118fc051798ab3ab98285e8da376042174910aa6262da6b53c0bf09f968e8f59beca6a32229c990329fb5ebe796dad5311fb4ba557b596ed1fe1e442e1a8193a143df322fdf61f0dc18df9ce39b5477c3f97bdeeab5c96f165e562c48b5e9ba06939ff73d8464e6cf2ba999d8b5f20e5e8cadb951e16cbbd926a4ea948bcb67b1797161f0441cfd24ea6cb435fd4dc92bc7d415df81c616b175be63c4d1f3e57cb1ce316edc5fe9e3f1352d21c6084a24192c3ae7a0fe44325b9ea5b0188f1542d834b05744f84714c0eae364a420143c591740fc0a35bea729112445d5c854d87af6e1ed64a1bd23f9b3dd21c6f72f52cd1481b04cd1f508f9c2f5507b555568b6d1eae9fe415391161d9cff5ffa57a1ba7cb46f8a9af0564db0b56b8f87b199b2835fe4694deaba75d488ca0c5f574fe7b898c5fef9fcd0fe4bbaacf071684cfbb9066195d3e7a9eae294217b9212da4d8ed6fd986f81c905d4be12c7262a0da3fcdc80c8dac92fad73a9fdd7892dd12186cc7ad020ebc05c2d6b4acae798c33bccd81a4a09575a0833c52c8f294d7a17313047f146032dbb6d080ef491ac01fc137c17f12cdb189e0dc372e25aed80170377404acc2f7ed249a7df29cf5e8c56c310b8ad9f478e60702aa779db3c57b3536e897b5603d827d8a828603e9147926da2f8bf2e8cad1987f48430b7f8fd103db29544c96e865d6be887ff54798981014eaa2997d8dad75717f8f105d365388a290fa0cf558d2577ea7b353289567a7500429224057a0f1a6238b2ee98b007e1e54eadcf18aa2f5b20a9eec5d6f6106b5a9a067e84423e965c47f49022bf3d3191c6239ee5f3b69e1d0c824b5df154b0f063d1dc9c2f2d190bef60d1a914696f03106eedbe08d2d6f90a02691feeb395b93f984ed6a6f967ffb4b708bff9d5f866e01a1782b1d728fcdf3312fbd43b15d778f11c418e60c253269565bc398e667126cc6d00c60996acf11f46d72a5c931af95c79857ed6501048400952c02bb242ea820069e7e85e9b85a1bd7171c20ec8d979c6f6f6eac34fb8943a6ae455d9b85a50575940eb3489e5e402f4100e346407145829e4e63d8cf31304c14b5208be69b307ac312f5b6bce1e2885d2aa73fc795f22e3781470166a6f25bbc2f48ab52e4f47368d8f0642e92fae23f11a1adf158d9d81466ac3694d80991af8dc7501a4f3a497588a9627b1720ec58180476deb935b8ac8f6852ca27bb1c7fd37f3b8f943735a5423dc4addb2468edb17236f22e639591e2b6d8ccb603b7d3171620ae7673d9b30a6027b238fbaf7787ba57ef12f9254c6f4b840ef284b3a13bbaa4f5921a1c54c6eb5b758a7cd45f018cd0012cfd504552f87aa67210d486d6fed749a5b055c399309841a1c0e96fb38db1006bc0366ae968d816fef0d77a26fc79c097449b8673d2c845ee8cb43e9b1cdf5e77ae870c1aee6e5cea0a266a244e14ddae9d0e6372b8394df9b482960aef45db56ef42b018a98d9f2f238612f808ce17f750f5004d1db31d3e16ffa17de1ed61c787b37b366756e098838762d820f51554dd039f2e6585b7d0f169605acdaafba02042459a63308b4a3effe4ed74303dc046bcf14fad84c1ef3c0d47a9c029b833b6d049d1529a4dbb22919e240960e25857122c164f8cd3a0c7855eb6e2569258b5a11a1bc8481e6369f3b54cbf1102dfbaceb98d8d421a240fb510329ddf499624b17a5902120123e0d721decca0bc21802cfbc980b18959fd8e470c62542ddf78ce2a7e493e5db5fccd790c878445b0a63d7bb2bf96245d6696619a7333b6c3bd294080ecb633c51b2559d0825b3410f9e10be8dbd089a6cd35f95c3390d0687ecb90f795a24f909eca208b215aeb004e9bfbd686bb16a7a0a404e2ff8a6280c5069736c4c3b81389deb5096e3cbf49d6cdc480750080c7fdd33d1f35eccc7a9413243a4e23f2c9778db774de29497b43a2ee4de61986e3937d04117370ece69ded6a8c9ee6937150a1e0b0c16c43ebd58410b189365faa8830eeb444797784808d36d07107eb12878b5b82fd3c8a1b14610ed80f7ee9f7501ce0481055214a2192c8aede5c18265e9cc81b9706181edcb3b9f4d9172b786db5813a2ebfd5d7a9b9d49e3f675e5a8df4ff745e6ec5d1c1f1ea9a08131423cf164c83c12087f19ea16d65bba15ca8002cf8abfc2f761875a0007dc6d0d23505a572822d5d573638f76a2018c5115380b1f66499bab1c4f621ec2c165f76e9536a36f9fb31da6587eb7cc243eb5f1fe2dac8d3a23d203a5e754350f1546c59f95d034f8fd4614d9060ebfaeeecb43c5e33fc18061727893c2494527ad1ce1b40d7ac6ff9942ddfc6e3daad9af67a460afa31cb51b9cf585a5c368af67a980bd0b65491dbba8cff90065e1d3a6b37030b34255661b3d45c918f6cf5a21a980013f808f89f438819e4fa73d5ce4ff76c976f5122417d0019c6d33c65c9dab32feb9ec785858af88dfa8906d1eba7a0ec547670ddad946503669b9bc4b03264643a2c725a3155b6868ee1f28f2fb0c34fce2d116905ef6811c33dfd91da438af62d87bedc4883169470bb880cd524e2e35cfc35f91755737ccf17e34918a5c9954b732a87e4840d0e1e21f2b53a8b645294c875e65c1058ea548a087d06eb1e616305092226d225d19f4e84355451bff2770ee09070348d94eddedec9a50a05ba31c25064d43a589f0e3e73694ee9f1d6054aabeefc5e046904105867be497432cc49d76bc3e9e0008dd43a4e3dd38bb4483867d5e06c662a84564c178c151eb6bc9c0d3a8c4b64b723f5d57c0afb78b3da5c3211bfe8b44956330dfbba970ab207bb99c1dff8b45f363185067de3edd55c9aa98c635c8b29b3ff2ce6d78e36aaa1b6f878d06305fc03fdf1e18cd83eff29fdc134278f2f41f60ab8401706b2531d0f5352be77ee68252103b1fd704eb23a36f60679ee905e278300771cb81c133d2fb0748fce60af7222762943b332c47d71d2d1cd4d2db4c94276168c8e4463940f0229b6aa599e23f66684c02d416ca4f4bdfa7a8a9cb7615bef52b1c1103c492461d7a3665499ad986a88ccb18491cc8fd27f962c9f5fbd1d799cde204869e6c540f11f696a9636163c787f6d15b7d47a1afb27d93d40785267f76133655b80cacde48596e791d5857f1677367aca99d3b516870c318c83d1599920b339e56e22ce14309799286f96dae2833b0b8c84e527d7e1b9cf28a8a78b90f1e91170f64c7bade4bf87e6b2249f003a33ff3c1225c7888b5fc9d92b036a3516d60ce893d36c1272450084ff52c120a0317bcc32a04d0359c19ea05bd8d3d1206868d7c35da2c6629cf47113bf2c11a70347576ecf14a4f0096c133ba54a7be4c5941ed6a8997a5561f62b062ab383079581086af26ce2eb8073cd920fb1acec4e59bc46cd2bd95fa2041a2dcc85ade74c170bc87cd0a7e45c35c62d4cc3f195ead4f2596b188d9f061b78cc43919d3545301f849f90f82648aea13f4dac3d38130835e6c5e4159118707c9096fe206922461baeadc420172317b8fe62d1e45cc3d1c9cfb3ecf23c1bcb059711d97fdcb529eb60778e77854a2e4e04c9b65a17a5949a80a11ec535efc17fb206c869660a2e9a2adfe5e5371f9e8149a5ad45630d2d69a0256ecf3cabd5bf9371ad91f7231da1bcff2542f4108d52cc6ec7f56929164bddd6f80cd7aa83d519a3c97bd52018a61035422268c8b0f52392bacf6c1e87b2c267629dfae577985eac0c2b6fb582fb017428b1a9b837a699520eadf7f1809a09f00d002ba84a6e6b1d1b0225999467cd7112ad8fa729b6d422187e27c221ea68c3f5a8ee2f5e259578e2e184e52982bde5b83eda679d8edbcdd2a15fd5f2285afd39272767049e1abeb94d5c955d3292680bb732c3888ed1e5b210a718bca7a695b6bbb3626bcd0b1258d0be8c8c41186286243c7fe84d4b37653239f15efb62dd55fe5ce13960c93cb56a1a0699a687807267e6055d41a335f0d57b39cb473231f7451b4e3c6b553fee92301050407bba3fe25a7751f0007c5769e025979e5d324a582f1f68ccf638088697515b3955c4ae5cb5d5615bac58a6f4dc7e89fec3cca67fba9a22c9514a615554544b0efbe487e361ec5e9fd68cd78c71bfcdb7ff741695d4dab174bb0f3a689ab739e7fa1a040a3b4259772a936fb3a68d3429ecec7914d06b5140d98e776aec595674d0cca64dfb12402c36ccd4b00137d4aaa815f0d41954148a8f43b372b69ca09c636858c99802ff676d402845ecd6d559561444052c787ba45c15679b03ac371112c9552a92cb5d60467f0752219dbbb3e0c05e26bea66a87e1b6c3ecfef2e7e8a74702f3b94105995756e33ef3c595e0a3eb96beff460a4f19f4034f69e9a09ee10ccf87f607a3357581daf0a0f2052a9d39f74ef0a1b7c24018f324c26307db1de193f66e8c25b2ee33e2c85669fe864399d09f4fe70f073b0811e06529183ce52e82150d64956c284d537f3d763877284dd82db33b669f8113e71d292cac255f81f7692b83559c34c03d29034ab1e1cf861cd9edf98e23200227d406eee8b7e1af33a21b4925ca8bffb6d3258959cf45b40afaf114e9c7697ee6608951fc112bac603cefa0edfb6d822cfcb5e1dba0aae7f4ef59e83e09c06e2c18b3cdc2b6ffa974ace00fd213d4916f075cd7a54311c7775cbdf790ac3fb839ceca5f4517ab195c082276f9d9a9004ae0ed6ba0029a2d89fe0e5e5b7f46aea5c4f2d35850672ba47de699c422eab49752e24df6257eb3af828c22a1534e2ab39a402c32765a7f8b709490de1d8c8ddf55afa7000962ea1f450a9531eb86c1fc93f91ac9d68b16f78232a98f07715746f998799db4171f5b4d70361fbd440e001b79aa1a85fa122363c32b4a83350573749c6c478bcb0a9ca8d0157caf98ebaba7b14c4c85c0d83289772b2e71e5a4f401d174c55f5aeb40c9a9142c060a771e10be2d26d68bbada8adbac2b732f883e56270d56388a74ee773dfa7728704653c7edad778b68fdd4eba86984e93409c5690475ba120ce011b7be9f298c1987cf494b327524fcaaf9c39bfe54a35a58f9dff94e3142e078ea8d4719be8929877c168fd36040d00eb645406b844fcb5b7571390d21ef222a686feb3ddde8b2a4972723ebf488502b8c909fae4d897b458a986ad8e28ec5f9a234af2771be05f892cb19854e7b94c9a4c3a0c239819f5e2f3d8f05406866a90f00f8f40551102ecf4483acfe9990b5c85c15bb319a765c46cd07c6cbb1d6970e7b734f680efb486490bb9456408910e8944454d7abfcaeef3dd4c23f62b47fdafc0df882a7eb2dc372eeea84a790a2ba663c5dbcd7d6a1e6562f0b8a7f4f0cac6c7871c360c9c11805fc77dc2b3dead726a0bb38985a977d3ca8fc2ad0e26d4a1b5b534a9519f911ba57e566fcfaa0c5a31e470062e53f013ea364aabeef4411f6ad050ade0a2328a51f3305dc4f8daf42259e84eb12ec324ab214cf0c903d8f9f9258ac1ff111c075246fd90107560758f1b15018ace71b2191233ea714603f59a13430338d1374c8b32d47e6ebe7f0d02d339f01b28d7d483514f59c0181e35868941a5aba2a4f397972ddd7cb6c2075e5d61f4ebf820230fbd622e17ceadb10ecb282e4ccd12444fe4d20bb288831dc8b85dca6d7818361b6da28dd8af7f2cb1a2ae86ddfbdb07f4d1e3dcedab17daf60480ea70b0ee0eeb3514dca54056ba0e93bc1ba39738def04922b3974bdd7fec8456262340f203dbf2723c1975400f2115eda19d55fc2cca070379b198232badb9bf7325cfd21cc49bdd9aa3a202e03930b1a42ffe5ef193c30206788bfcde0cbe697a7bbdf508faca5181e926aa146ce195cb97f665528b12dfb8b52ae2aace2f005f88fee42f5ce0ecad92c4ef39258f8d64b6da4d21dfac1281cca6d14c942c0ac801940d4164e9f4ed75ae0aa8235b0b7bbfb2ddfe47b2b3fc2b7ee1aaaaf20be4749c0c06efe8805f9aaac3abd1673e34925e26ae002fd5d6e1a0834b1c512c6ea8bca3b854addd8c75feb1bc31473c61dca569d7cd7ba677505dd97c5b4f561be67bf6c8b500fcccbf7538e4da6dfa11ef2c14b1146094d6d2c8df0f4dcbf4e84d78f1de80475ba0ca38f887308400198cf3a8c57a41dedeb566bcee2da72b489b9a266247dab50b5d229a812fcca866e81f79d2456364e11255b9f50af8086f94b16806e43fa3545d4f3507129577e05f61ac12963fc9ca1a53b4510fdc230c2ad234f1262b4c765aff7ad7b325e3b855e4ced77ffd86937b605cdcf2fa23aa6197d83e423e384ab562996bd49a62877b770c86b893597b2007e1294ee0a8f2ed16560872649fc8e2e0f3e62b3720c999048df8cbfcdbd9dfa84efc418a5bd59b945cff2389545b16334813373b82b275ecb6b56d5fefb8e32039d5e9f7a0f4019479a273a2da90cf8e9c26cdddd09c6445ca2488f68da23ad96bcc268d7a60e6098edc90bc72e40f96d505fbd603346a235894e40a2d5aa46c22e2fd1a6f741fc5c01badbb68b7c85bd66489916ef1e52d57613d556fa3ebf00f9725f36dba1bbd4de2f15db51e28f2a259a60b42d3e033ce8a357cfe83cdee0d8e2371a6343f4ef5d65218563c9633ae656afc9f1f6ca0cafa06ae3cb816a264f4d3dc9de799fb018a5a964b7e78a07911dac58ccf8a6ba1ecacebf51a5a53ffee87bb640942e9e0173b72b7b232d273bcbb0c6f97a2bc7a9a9db755e73a9785e46632caa4bd3468042a9bb9408169683067f5f57bbbe4453d78dd9f57c162c479fb705bc42d75dcd65fc8579ef265104c27baa9d59ba6b15a225bfd6027dce1d646f9f1761b9a83fd97b04451f78b25749b52953b77f6273b7e9559e0dd315a14f39a51c58e7650e031e2c0c5c38323ce842dea7ed6c4711df502544593cb228867142f6696874b66085cc5d8595a893cc7883c4fb291ddba41eaf330a1f42ba487800287e7376a434d767bfa717e2bb4c33429068b168778ba118b593e5bce1d215a559b817bfe2042e90139ec64d42580db415cbab399675efac86b98019beb3c4a18710416ce4b3679608264a2f8a6ac7806c1b1e89caa1df0b395edc52441d416074632ad75c943518c597131307657f4a16f08bdb12ccb32fa442d7ad9c738b54099fbb0e7c585f4337ea8cd746ef268d7c70eea7db24cbe7f0110a86bc9f53061e22890cb24277ec7238d6caa64663052c6590eab47a39b5974724a3766f47c135791d32f6c0e022495b3444fd02383b6feedd8b1858b89a3e7aaf66e50c30ca8b9ee84f241ecf4da792db4ec3000cfb84eb7261fd055cc82bdc6e0311231f4a1bccbe0eb3994b831aa84332528a20023a93cae0a3baaf5cb0c7528577f8ae27fce947b05cbb3ddd1d7843f5bd9da5e6c97d6e13599b1e0974c81aba39621f3cf801ca5ccb3e568cf73c10687dd127e00dd1dbc732f65346a41e4b687eb23c9ce00f90d78dc82ad78496b90b31c28ce3b054c2ab7acb415f39070d5f9987786d88ae14acd334a917a08712d5a44f5c688bd85db877207aa5a33f708698724d53e943968b28f3705b2726f4b56e5b9bec79fd399ec784518ecc10538ca0c48816975691d6d8ef03a06f7f999a54db96bb8105d45d4f8bd597c5016bf7b9308681417405a007b26765cf935141e2aee681553df09077bbaca3ce120b958ff073056500e638713db22e18fdd19d6ca29f4a529ad40d8fdaa6ef6feaed53a45f191fb8c7e6e24cf847d42414389bda508889bbcbcd06c1eff0afe498d74c937925aff72dd07dce538d1611f4a7fbe8ccb7b0ebfa62a9e167259a8a0b5a1f77ee625c87d6b9252cfffd88b1087069bc8c0ad2017a62304caabbb621d1d3ee18fa691cf90d580c021b89d3e3991abba0539b7b29a1bce0488158b1aa8f2f463f636d55cbb61b4743147f12a1f639b3ff8fe213c56875538f7df666f9f91d08e3c02712b40475f8adec3a70c0af6c5e3ea7fa4a0dc9886373e3930ecec1df2d71309fae7986596ce3d08047faa3c33c525339623e785040a96bcad245a9dade706a53328ed2098942ff719e4a9ecda8d2d204d805bb21edc22c0b1d052e8cfb56b21ec9af1a44e19c7692459255c3dcc7806cec7e6609536f39f245b8ab6ac177b9ff77a22c5d473395f6a87d9375aa7c7278335f80eec944af3b56491d765da3892e2acc22e0f24be95b7f8a9e142d58640c8ed34a2664987704d4378d1d2abb07c64e440a5bcaf01b4f32fb24ba5f43a7650b088e6fc8512b8adf218fcf5b57518cf4f285bfaf479157d8e82cafcf67effab8220ba4a638712b6d48bb3b0af4c6ac6ef3fd0a13087bbd96f2c99e92539f34457790143a6913f90fa8d0ef1f9e8bc44880872921e1894874b5276598256652f23f2048700b20ef25ccf1798eecc757953d1774e6b2f514ea82fd3e07233fcb37cdc3cb966e94caf0edbd267987cf0cfbe5b435500fb3198dd9b9d3eda91cabb67dd31302a7c36aae606e10be78cfa4999efbfb73b82c8bbbc80170cb00d077dd320bdcc3cc0da4d6312626bd39fe4b94b95ae03660c4d76cc47417007c0c57607c1f2d8cdb7c749fef5615bbba2ddf66938cdb0b5cfc87261449bcd0b1029033bf30acb621ba9b57fb8f075df843c27b43b7b447065f414c561b2925acc9cde07c441097a558713d507985b80d1031885d54f951eeba5441b8aef669236ef53c912687890b43702f046d753b8ce733296ab8865f142988b96b57737e6a2f3ae37b540f7b2e047814d3972e7ddeb42de8577347eb9ec98c538c344514c0a3e8b077f96155644399e0c42064769fb20265aa8606235052f33a03552ae18020b6ad46755f70af286710358b7123f219a5f596ea526aaef4b758f1108f660527d61a11edb843fc13da1d9dfc7bbcc46c46cc23612f18ad13bd1546f6051763a1203c6e1cb08b62ea8bdef4ea4f54588d5c67c3a854d43910314b7be0a2f1033a9cafc61238700a6c869fc165f4e146164961d6531adddc04cefaee6e72f4b8ced63a85a34ab8eea26aa116171228910c010ea73a08c68ba0e3df6d268745bc61876458b741e4cff3de942d2d19625a89fed31c271facda685832c17f4336cb6451d87f5345f9a2b6607afe5c2a691ea65d1621241a339563b916d536edd3075a3e866e6afbc4de55301e844b40ea1408a78e9051c5c0b3eb25677acacffcaab54bb3a5342159e32d7718af3ccb502b830e7fb760bf16f5005dda065df286212db28898981fdde93853f268b5faa3f9add1c77265445e20afce18698c4944d2634c9ce1013983e301e52c3e709c47ad937cec9a46c1f995c9db325c78a827dfa55c9acde1ce4a11e4ee91fea1494d81a3339f25f6e1b64d7c4203baa81ff69d5792d2df4db8d7662413b3c0956bdbfd49d63321c869e05fb67b6ae86d7d4a96da158fb410fd4b825e2d9ecf25ffa1987892ae7208a2d2b5d06095449f730665a583adc38f8ab6867b1fa7b832cbde55db526d88e319b60f1cb60a42641bd876d92c6182da98050128fb30b5f224412b3f37e3e88315f6e9d81dab88a650005f40b5d0c3cdf0621650417ec867ce3746bf4bd805242f1bd7a8ca0d598af5c5b07a0c3be99d2a77f549ba5907cc64e470af8df67d27ddad49a072d86291706d5641b12eedc9e3a365db696248d920da9fc7800b2b894ab82e4e89cc579d0146ecd02e91574f4943b0ee52838a596425b37a0299670f9ad6d92c2b19fb8ce1bc779988767339f31da1833cbb349c754561285dc54ca4e9d543e2a53441b2e2894feffc8037a60f1468f9779ebb1935c41ebcd44f9d4abbae6d2d1c3741f85f9a9a6b015c4499d90eb1a5f69d3b5ab037012bafcfc996a0c9dac08f075f6b03c3429c1906438de25f4a373f43245d7f9c9a02c99e215530930bac3dc6fc190e8faa43cfe9557ee291d544e785bcac9fd73474ef91eab049769c39c3b9104b6a000afbe3a52afc4639c0bbdc9467a5b2086a0c6a68a0b9626467dce52f3a6312c5f5cdd3de03e0cda1207616d3286f0c220bd0ba2da426889798e698759b0188c9fbc51efae039a37cc05444dbd76470df0b99b2fe85ae7f374525fc86457a132b76d5f29d33ad2c516765ddf5a819de618509d98d6751087c902c244deb9e2c1acfd283f84972bc9c5563b0cac76aa4ad6cb61640983dfa86af6b36d13a0ded868de8357ad233798dd0ef45bc0e6170929fdde86eac078fd05e25fc816f4e805d20219c54f660eefa59ff4aae274875524665ca3bceb11ad2014f91ad937a0b77fa2ced34ac97efbcb30c188751c846c128d239db3edca6a76130e7cddaf97355411adc62e6006cd6944e8c370081154dc82c1505612ca469a9d397bade30b7d81d11cce59d389cbc47eb04783d99c984efeb9ae5dbadc66cde8ec2a7bd3f3921ab5459a326525fac3c83dc45feb620364cb7ff13f2d888a4096b0d4c84083fc3fe686b8683e369de50f441cb86b3b7533a27f569b0be8a45dc699e1ca32a1b884a406c6843e4a101db695d32ccd4ccaf08cc9d6cf73b408593c2434623ec5c95484bf07aeb994beaeae31d582685fd1a3fb9338bbac877ff8b4216238f62b1e0aa5650ad71d603c2219ad3bd9764eaebc40d73f62d6a01847e030a254d7082e01c1b99db8b075a72841781c010f5f081122b570dc7e79f233c23ecbcb3a15c9b5b8b1ac439694ae0196d4bc66567d776196a50aa6d2ef59604020d4e99cf58d8c8b62cef99f77a96c9f417bac035c20eb81abeea36653cbf12a9c0d74074cf6618692d968c343be47d71338369994fd3382751c412faeda95dc9ec22faac136e9ff9fa597223998decab593ba8e82b97bdb8215e4bdbd44f7bed572835a31dd0e92b2a7414fb33fcd7feec17cb7fd070fda4a4f169fac2c998ea5bd405166d00702b04f02e39033a2c70ce36c00019b71ff2dbd70a6e91a3e27bb79bfe24c6939d5fb036292973ba904920576178822fdd98d7e0baf2e75bae8396a7e666707eacc4cb3fbd7599c239f018f1b3bc314c1965e8eb86d6a5628088776b32f26bd75f08bf56219f89aa94877b912f18afdb1843e3035a0a9ce95425b6e653c5a80fdc59a8c4c89b2e016d4dd91b36c2081d669a07d3c4c581b8be57eb18d38d3521559b4d1f50bcfac36a6cba9a8d222e7a5e50f85c40f920a045adf26cc8e7c6baea80a0bcb30574c754521cef69f9d3e4010b02a33e448dc56b6c1d735ca914913c046d3ea6ee8ac01d71acd8a7e76d5c7655f4a2da18e1529de3f42451038ec6d34c906c8166968c50bb45f4284d42a0270c77866da54f98152a2876192945baac435cd767e813a7092d4a64f67c98739d811b6fa3b189357d7bd3697796eb46f492cae2b4072c13d1630c5877e22d99ec99351b7fb216e33602c2a819b9b734fa1fc35968c9d3c7afdc6c3c4dd427ee63b34e3bc177b80f4e20850b127f9ac939fd6222a060764c8fbb7b7ec60197ac267c3bd25724ad53f63d3b09fcbedc3cd417c87fa7540a40817ba62f56621c99686f777987a61d4252e7f39c739f56abf2a12066378a40247ad6cd4e96616f7853b2428479460a07e9b015727f81967c5fb608b5f87d87685ad8f2ddb3b701854dbc8b715901af0e0e28d06adab81fd16d770cd1c595aa325480dbe710bc29f1c386de43353d3cbba5cb21d0561af4539e76fc4e0d03f560091a84760fc0bcf80e654d833cf0dd3b9fb908f9fd9c159528c16b2b300a2b539b3c8a315bb45c0bb32056f29ebf31fcd23081748092148ec420844280a7becc18000c9f837522c14936cd8618079a69711b5182e702522bdffaeff8a61a4e935c6fb6c44a240a5ea327ad18d6df107f6c251a9f057aac070d78fb738e3d128c7e072e1bfa730e5ec74f0e441bc67207c213435a64aad0f5337f9ea3baacfc5f7814abfe2ae9ba545cdcd60e346b3f230c15a4fae7ceb3d7fbd3a7e84bdf81c9cb03e1d918141c5fbcdf7e83baa126317be61e9b754d107265b6c388e655d28106230d08dd4ac5155b82379c87c2e39bb6ed9b7e34e73a906d412aa16727e2f053b51f9a8619f4d904d3bcb470e1454bdb9c6c9136f0bbad8cad2db9d34d8b8a008b0d40610dc74980829ab9e705763b22145f23ee34b4689e5bc3a4665af03c18169327807c8123b60ebbab591922a3546f51570985e531f3c80a8ce0dc575b4d3cbaaa1852e8e5654d0e03723f908535c2f3792eaa61fca9c2e4155f5dbfa4e7a135c1f26a7bce00d75e34a7dbec87ce75cdb77717419ca72fa5c7209bf1aa3e4a101f39321a2b73c969f7165b4af5fb39a5d248d59ed8fb3959bb3a442ecf8a96816aafe2ea8ed44dba271fa35a4f9ba948e6d491f51f6c1a7a54fb319c16b6fa46652639bc55f4d2b5c9652a40d6c4096fa923557209446c876291acd6e91fbf438af078edc707eb01ea8861a273553c801ae7d60035ce2fc3254416fb6a586c2380d196cf793479d1893a1e5dc7246ab562ee8dd01db187f992d073b3d15c089dde6840c8d480fbfe414fae6b23e53b3682f59291705e4f9f4b9f7d115be37948151aa2e28666e9cf1af637fdad4c5ec6a9df91cd801e54ff8154c84d39fadfb522959fe120e5dad7c933a3490f372e597fad1ed5d2accde232a6b32fc1fa043e2ffad63bc20ad98b9668d7fdedfa679da7acb53e446ad6d62cdbfb103efe41137e9d833debc277dbbf45324f54b4f795874238a1418f6ef095ebf294e1b101f77fd88f17c6bfcb2bfb2ec203f89d95a375156bab340ee2c90e713ce0006c45cb419725119fa17b2379d75e6f7b1363e82beb4a6da690dade73c1ed80277cfbd959c2c368bdd4c5683f509592e93c0e9e2857a7bccba9dd7b2c7eadfe16cb1ff96b2642e3be8bf55bcda9e76743bb148c0efcf72d0d432e2597f0b27e9193eee1bb9fe6fbb956d08d1a30fb3d85f7ba4ea35149585f7952de7eb391545b90038f0bb1c7dc4b5090475b7504f2af19d3b2dd2223c3b88402616b1f77084b494e11c06c84dc88b59e35f36c2ce1619c61aa332e1c25a985691b81e653f0f551cc7c63bb0933b719f875a8e165f2dc21e9ec0c7dbddd854aaddd81aa6aa6c9971081a54f1ee09abce4f36112f4912d5e5530e018ffe41487b57e0077c55765011eeaf240dd19e7c7aec16578673bff8a22e575a966d59991351ccb31ab74f619e26d53a26c84db766eb4cb93d388be55df9d6c5c8ae82a08891ff7783004d6f7a2f3d3e7b339304c2f2b4f2db812d51ad11785af1df28193282a88c3b250c243b945c390144d9722ac863c557a9bed3a95c8dc3f08d289551404c1a61902c729b24fab44dd78a2a82ffa44f233c1bcae64ebad46a1b16c78b3dafaafc8d33523e1aac344ea54f1a52c2a0618355c3c6507f1edbbdd206daff721452524b0930b70ae625903cae30ef05cf2f3269d1be7df7d09b34271f7b00f04168ee0758cd2f9ea39b6743677fe5ff87a83d2fe9d2ff4fc9599b36aa9645bad7216affc3d48d65e33451082e1e40efe4528a9f955959a2495b6a024132d6a48f61aaedb037fcbd7462b419c1380095d3968078b940b742d18de50aee82a92eca763b1c09b8bed2f561225355e4f00337bc13da275ebd078cf69e2210d5530740e0abeaa1f8e067ab616cd510fd968bc70b6e0ad2e820185a4056a0f75d6a6bab50850a30010411be917fcfdc8774ba81b6005ed39f5aeec7b1712cf6a4bb619cae04f611151a04bd0e1ca6e3e0c9618ff86be0df1c09d1fa91b5eedc11ce3e8733b6226c6c82ba3cf116d76a596923ff7b38e044f631e924e2719925753c38006361a3e66ec71690ecb34e927db4ff0a6a9a0c5553ae500996d845c1870be55f38ced54cb63b0de8ff8fbfb0292e7233f3e9eeadaa54e7c41151e99276cd0267ff7dfd5012c6c0f5bcf6029f642121ef7340ed64227803b608ff8b7797037ec89836e2e61565223628cf24898516cef2dd4fc47f1a7be1bb8f2ae5136cc4b40456edfb20cb77c71558cc0afe2027852e527232a3ff480e6954676f6c26c9290ddc30c49bafc48713fb76330bf1266d9b5f40956036c250ddf888a897fd908cf805bd837ca13fd428bd2fda5c19f8b60523bafcb1f857ebce8df4598a8bef8ed45edea1bbf00d11a9ed12b901c5573a48a5c7464d19042d36772f28a821d203e6d29ca7ba9fdf97b021ff3115611de856f119814f07e1d388de0e3e83798f865c4f73cdedc66b48965fbee7c0985ec11451e31d1bba3dc8af8536712abd1c176abcb7df54b2501f1d9172c91cfef4a1d149cf315185af17d3bf0a32f9895b48d79be64ec7de9e6b9bcf2cb2c6c22ffff535b08e819a091d35cfe998e3103aecb066c73e2633c13cf90ecc68b322380ad98037abf790c6351da004bfca7ca47930b64232dbacda39ed655638e3d689adecfaa35ada665654ca4c7352667ae69afffb722ee5f35a686cc88f495fa610309c73b38d748e770573549d3c8dbbe0466d961dcce193f1d8acc9826ad81c84ea27bfcb09c0a0735bbe6cfbf42c798b0d7b7a57a80f38fad4f0e09305cf6ce7b30398897fd47dfe624b1e9966f51e674543f20b405759afd96564c544c89e61079c665690029d5c738e5b5bbfb2bacbf0a20c20ae8c8129589a28904fb65944b761715b2034cdd91992927a6ff7da20fdcae463b09ae871fb32555b92b7dc8f59d78f0528d8061e016ab40257","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
