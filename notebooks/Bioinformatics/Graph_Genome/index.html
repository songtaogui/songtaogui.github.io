<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5fa8b92f4b3619a8c4ebaaf69ac04253302f90e5a53e38bba06ed581097a88e1b34df7bf9be47265c3a2d8218c5ccee25be8da426b2e96b3150f100e9510abfc828b625f383fc1db96b40bff59690c023b51872c378ef9a0ab2f1929e6f542e47ced90c3772fb3cd8e16aaca58df3fa4b1e5e1d0db7792bdac860b559f50d5879590f46f4f02c57248c1609ed4579e12b86eb78d67aa7a1706196dd4ed7aadb1dc817e42d25eb916d314cbb9f249c666b9bb72e9258a756128db4ba5d82931de031f29f8abfd0f19320d8dd289db2cea76f70f6a94f870fe6d2607d41b15f05721c9b8b76e8df4855c819069b10d6741bc8fe69a9cd53da5176588dc0126b33a1aef9c3e907e943353564e0e7dd426afa962ba7afb05898d4a1e5d263d796b5522f1893791f0e251abe44b637c143aa3a8858f1f52e269b6f207d669d0237b04582247b76bfe74a6be2fcc51956bd1d5e3bb4f6d0afb79ff2687fd6c5c194e11d61ef03029b7c99c36c8ce62adce655c2e7663fea987a536e3fe23b67eae133fb957a1965a5f28b76d516e93426bc5e77a8df4bb4772fa37e408c1ad9d6e22dc787e98f5f8b961726c7ec8dddfa7d09f50f26fabcfac3ff4457fca5e99ed65a8699c5f075adc40058b68217f094e2f477abdd3b1173328cc5b0367bd5d3a25fc104c7f15aa306264d05261e6a205b802465ff0872050636836be0b65491edab116a799775d4a63a9b213a0c6d3483b78ab0e46945bc00be960c86687d082d05ffaf305fcee097cf44a66f2680a385edebaf88ae562d5a019d8c76489948a571ba92d881bf124f3ddb7990f0ab7295e5a2aa16de0f305ec0424f64ef1527de69d8d6921ebd3e34b0d068cadffa88b42c905e21194ed4557bef87433fedde5816fa5826400b8a1196011d52dabee285d1b7b888f18706055c91c825f7bd5b82a62e091373bb241fe15507f1eaa43346809fc14982bb9ab4c357d0fc7f46b66da02e33426cc6e9c806f2878cc3b8136140c859d9c500eeefa005ca4843aed7481a5dffc11adb9a824311270aa43d437f17317a0a6431d0afe2d9a8dfbd6aef4a795d70706ee17f4367cad397e976e52c54290eff6167b3f78bd3fdaed737aebfbcbd69b57eed8d4aaa4c16fd1a8cb37a3118d2639f2b5b53f2ca0d30fe7913fd7c0aa2760930a1c0db457c4da03e221009391d31a5d02a9569923701d7e5c27c7909d1ba42b05fa73b29c59d1989cb31f84e0d16c3a72646177c85021b99c1963230434490837d143c5aebcf2ec3e810f9f3d526797a522aa6651c35f4f6bbe5aefc4f7a6ce99a2e60b6d5939e86b23ae0a5288f845ceb619da221d04861a3e3d36c4515b5788e24c65072e6c9c236b7595d9ac640b972b7f3c9dc46edb4fdb3c545a93c61b4ea5d826c2d9810597c486a9174403838dd39fd63590eb0ec3f952c083c3de7beec411ee307fb90f42be8484a38d14346888393c380ed580a605cb17f43d81c36dfd70ee071f89b7766f46e6acca3168f678affa21ab1f677fc076f1c41645cf5f819d30f7662c7d94838b21bc0794b240017adb736b9b5a94549018284d61b69060b8a0c85fee52092160b47fed369153b92c75c8032cf8ce4b690199ceefd8833a027f6c46fc4cee9ebecf8bb5be66c598f1f87fca9d145364cfafd7374b950a57e0a2fd7b1f5118a9d30ce21b139018b4bf7d93416677af5c2e74529a04bad8e2541731bb568177548380e5be4219a1da193d40dc32579f0ddc956d9f624263f5af636d0084db27651c4f2c456e0160201e4f83a607174f90379a3d663fbae381ead22fffa22ca53de5030030c8dc82c513297e7f0297ad2d6d5a5b57c71b4dc6cddeb43ae5e51911617323b72638cb3b9d52a6dcc3f07a1a65b6cd8e1d75acf880f3fff879bb2fb9ad61d80b276a4b5ec28a8d7da9912a846f2fb8563c01e5b1d3602be643d3432c18a451c9228c436d54a326fe01f253c6acdcb9ab68ad7365b9c692f3b1cf4a4755fdd7955d02f5f2fff3d11d790a726852c54038bdb6ca37ad6a596af0dbd51ff070e469b75c37ad8e50347b1ebdc5969b9f138e4ce9fbfec1b46ef2c341defc70aff9413aa5079bcdf4bb0410ba8f7be7741293ca3cbe6f42a3fbc6e0a82ac2e60e9bd0d70a624ad97411edee4e097095785d36f0482ba30becfefe543fe0c0136794e903450f85a116c08c7a175ad7f1bca197530943990a8bb216315eae570c51fb840213384d1ecfd2d5be87882f662a96ecefb5e95186c92e7787ff063e392204b44e17542c7e388cfe0b8fa3097f2dd70913077fddf6f67a0d2a955044325138330d0985f4e2852bb5e65e1012f3ec97cb0f54aacb9701bee688aeac0b1ac9a3a44d1edcb8b34c51041c9676195fdc3037f56c4ff5a16b46bc68a5a955bc4d28db7dd43e4bc798da99475267cf0f6daa86ecc2955e2bfdf71957e1aa412deb28b52f2d38e8b4ca1812df4d5eee3ce1f8171e926edd5e2fb9063720cf5e17bec990add7137858a34ff4a166c49550b1f14cd404757e146b11dfc6ffacead99d21d2cba5d308afe132e9d17319e718e504fa94650ae9075ac2b6c70e288b22ae3be02a15082003c7c6d0661568d24a622d6a118cf0d2c0cbf69b4128a9e7d70cf371c706fce39a7b4dd31bdaf0e0b3230fd2b415f6434e51de57c7a5dba95d10ac054d4db99127582837da98b5137b8986cd7c7a70c62c39a6db5c5fd5b82e058a49231537343643843161830535363afc32e907e8c4d9f1803a9ddd7cd1d7c32b6febee1082b5c8955e9e88251b401aa563a7ef8b486be83c02fed3a6ad4fee339b94b05f86fd892f4cbe215124850a09eddc2d800dc229fb5ac654b27663edd0a3ab26d8b1a6b062cb7d9958b33b788076f8e15815ab04b76c57a107e4993ebf687b484b1f6a218c1c840f0fef1604bdd0ff75a01a90dea5ad96945106b1e2d808b1efb7da53fc6584145209491c12b6d54d83091e7afd1198c2268348f232794edf0c20b8cae2111540e37dc17f676bb8a65aa1df7263d050aa2f0e3203b0b32c6abe50b82d70f88cca17407ad1d50e7d6e051a83bb66c3f86474424f8332f4425700943a9733067db7e0f7ef20e7f097445ba13e650bd934e0c93113470075a29820670607020c2bfdff91408900721f8a9f124a140ac63c8fd1c25dc576539f96ff95f261e3ada432ae35b07f13f3a651eb58d284505458554c7e1a8502dab4d4ae03adce86d5ab14fab8cb9ccd2c4f88d25a5e586beff8247a5024154446c0aa0185d7e1b20602393991aa4e378efd807af0c5c7dd4807614886b1ca579d6b60c15db8a046751ecc05449886eab6fbaf4bed01d9568faada960c29f7aa134e203ea6a881879aa1d9f5741f4ad8263711fa54c27c091b8e8d318a57e424c0a31aa9159aa8941182d1e9cae161b888ed1e55dcbb48b9783c7119a133f41238e7ddf6d0cf799b303a4d223602b416751dd85ba0d59995ffcd01889134465f854aa0d4e5cb849eb76de43983b72280d4ada8e3f97d979fda0f7c785a27c33146482f72d793302b0a3734984c3de51e9ae7f503ae257e028103f558040b0e6845b233011dd88b30f3bc86bfb21f2a2f9c3070e022baca249d02dd04395caa5d11cc052482844d60054fee5898cad949722249571b178413a0c870e0e8b32e7ff6f2bc5a6449490d010b6810f0c0d065799e824a842d211be8ab6926d9316e92a225dec45bc9985b03956848d3084359bb60fcc366ab36875691022ac814bc68cf06fb1dc9a3f3d6fe1f7bf935b052155f23698f32a7323658f36cc4b8c21a3cc23af3022a7ed05748583ff9e290a0f385610fb01569397e4d65b049d054c784bab1779e650a6d93dff537424a8ccec758da55dd44615c59aa3d3030249b1c79f63ba643f55082260dafebb948b133a226beae3df53b374bbd402f71d4a07c0a0480f879ef367833f753dc199a713df024f6b9cb5f1feceab67773b63e1a5bdb60920edd4551b70915d2f7310db33a7c62230d7aa7998ed10b65fb6618373d62f720bb766dd9878f88d20da9e518184797cf5d6a41841382485d8772d208f73af8b20d1589aaeba786cac1a9e15008a6c4031a07b5f7569abe2551b9bb6d34075a853cc246f7e35032f3e3d1df479da9b9a225335ce8af7b66f73bada957952a74011c3103c45fcca5ecb830615cdc73b1fe5f5304f6cb8e3d0cda1ef914e8e9906b311945d09b31414c5218d236a8ef26df395a7bc15ce6f1624b2951dbc4e92394b08c44745e821c6af0d7cd63c94111c4e0e41d42dc3a99f382047764c56d5d93b569e1e6fe8769334aa5a1d29a7c97732fc52f363abc802bb55138047d4d1dccd8209c8d01bf6168dac3c09cb889489042f4cb125579309bbe803bd21d1d0d915bb926fba6ebc8de43f07e1e01d66f662b7deba8346fafcee72bd40f205a4d27a91fc2711387b369910554128435cf6bdb18aebd2dde406f251e997d50ff442c5a2d3532932ecb4a61ea51baed1422ef18f620b080364acea1e2d09d7d4ad649b805d2cec60356d614bb7902d774295f08fb72cc8a286edb5856e4eebde092390924a625bdd7d63a250fba46a66b111a88914198ba8ba28b869caa399959ecab5d1cd10e1bc7d5e9097a86b2eca520856cb1577fb9b53497ec66a519315b8c5456e8887e082bd551f06088e53b980520a757752bb949114894328d2c7a5ef258a3934b5372abb6a40a016463720644d444cc49f7e127ec2bed399caa35b1083e3054741f3988df78d6332a5ec06639ecc32e28cf30690a6a4081f8534d5d9369b98c4fb472a00a4dc08b552284df8a5086a66e08de5666abab0d0b4df0fe1388655de4277af361df4e694d8ce2ff0f1908b603cb4fa922bf0433dd55d100bcec3cf13f3b8f2ddbc83b8b63c171e0d3ef354555c3b32fbff66e099edb497dd648f5fe522e45e1a812930bdb4b1b0c6c7174afc7cac996f5d9967ce88d668afa212c6915bbe4549ce4fe3a51aa5c79f995c98d3ae0b2a82eabbeed60c565409d878111c83fad038fe75e5df7dca304ce319bd8612a13b8c92bc574631c93c69fe3c17ef1fcabc74bed2a9844370780dcd06afeff5ca465e64e609ac5a51f052afd7545fd5bd12d7339adf1bbefbd2d39c497dee6828b2f2defc3f751d2287532030620ef0d38caac19ce8faa2c25a49bef60d84cb3b13a9ab5dc966334976855644361c4114c2ace6a1377b9b7e84971994654c4fb75a62ed4e35e216e2147c84820fd757909b168e2ffb29b219699b20f5c36aa6eaa5e1485bbc7f178c0ac116a9f0b2e4526e48a1e4945cef1327cfe1ea851266cfeb68b0bf487f3ba290f507bdf0f53324ba0931feed71229a4d477301f855e914651696ead86f8b9120f13f1e13db1ea96db6eafb892491702f8bb7b28dee025a9844c915beccf0b176bcb037606dbb3539dad8cc8ec78890f0ac8d2ca66172be245e99a0ce82f24a81fe304eaab07acf5c1adee85855177fd7a669812cae62ccccafd18b757ca67118069f04ea8954ffa7ab9e435de5c3344dc5cf673b2e27ccf52720ac227e0255d530992d71ee5acb1d739632b2cc0c37b8d3bdb8f7dd11d270e9ae08c0fdd4ff68de2cd576b1edca2eb2076f3a4f475e7e58b5ad8885940120e9cfe15a103a1bb3f23f2f08808ae5661e8f9166651d1f54f5708c8c7a1ac15557931134cd65a42da70b78d32da580f0a12cf89660973b3178d72a5d1482ad978c1a168410f378cabc241da3d9c1865166e0b962ffdfa41252a0cd62e3178289bc947e85bcf437a07e19968a62d60a6b8c31ab6a55c7c34ca81adfe37d9e0c76fdad4fcda7fd823912cbf35ea1edea3a764d279b50a068c2dbb6271adb5ec9166b96c614fb5ddff99833fe15cdf97268ffcc4f9687b4c745f57109a847f3dd264164c988c14f82bf4022f70c60a59035bae2788b197e26dab8089f6c800f9eb61a72bac2ab8e5712bb07c8c6a8cbace64be9eef04e8215e16c72d85b00510b3802c88987261ce7e472caaa27c1d67230e4d7dd7b30bcb82d7142ae1325aeeebfe1c671cce63985fa3e2111a166e65e4b345cdea4a120c26f0b62f892efedf1880babda78b00272a5eddc543b4df3858f0832bee72959872f83a61f199f1ab27306fb84ce76d0ca93e3be7c3c823a4f37ee67830e071c9b93dc2504da504d8fa6cccc187535193c92a8a86fc9cffc73e7b81a99c5c51b56139a6101127fa7eadc1fdc78d4c90f2a90833bce4344b5b488b05e5f7d62d4b930c41310f7d3fdbd889cbc5b26a5b4eb8ba680113da1f4589bbe01bcbe77279347bb1a5dae1127ecf4ddefa3c33fe174c0b3939e72188ffb056d09b1c19830e31e09c4f6a0e66c3989e495194111237d6e3c5a2f379479155b4e8ff5917be28748f83971fd4f123f4eee4c54144f704250ee0640594bc896489aed4a9254b889554fa9d9eda45c42277af66cda120af9056c43cd4f25a49686c2eaad346e10792e893895591157964c6c5c78a2923e5a97d5368d217faaf5fc79e1c6a1712c9f87291549d8c7a81895466c08c6d818e842a4fb3953c9e2d93ade09614eef0ac018ae460d3fb3c81768dc57c98c9fc418bb6388a6bb2632d70d7d27f584ab408d515dbf1de06bdf77bb9100ee3d600a2f738e4b6beb8e6dc090609cd5d4749f63b356a39372d5392c6b06fa4f38bc3c3466e7512b61d6166bcda97628d67a6b98d6c5bbd0e91dce864c469fcb7cc94c557f820b1051d4fd0146ea3ed3cb4d93f66b9a036a242a01d6e834738e2c59869437050b3767137645d75e9284f23ca7e95e266adbb1c49cfacb81e13981b371af251d74c8d5a3f58ff83317cdcc27fc040087e06d58e9592a54105f41dd69c36e3ee11c589ebc110e934322dc3f94c13e0b8241755de22ef24a369e32ac3ec3963dae569e9449145a0efa2e691f3d92f72d1d29f78f02f60fdf93269cfa02f91d4ba8be302d8f5669f963b532447e40caa4baa36ef9b2e5eaab6a52cd9e1f4518c24ff5732b955d1523a51e1cd0333c0aad97c3857722370c1ec1defe0dbd447898d006b72d583f3c957eba74c4db3c9b823e358445e99c10b9fb00c4d5168e74832fe701f6dc63a48bec3113c5a2e142696dfbdd0df81f118a0a5ebb7591a642128e935511a86eaf9642ba3eb1840739732e70577d3af9d2cfc91ca4b11fce1d3636bd2a3eaf978546bde7f7b171afcc49d1edd40c3d587ebbd06034568a28de142d93cb910cbc0580c36ce84a2cdd176f39075b487e1d07e87c4d84d0085f283712ca5fc3ca23f3f9ca9f771d337c84c5f4e1b471bab877a27de7e7bac8d5c4c103c4341cfa405c32780482612bc0da3b7ea18ce764024b8cb9bfbf97b87dc76a443e0a2542075423a60b3bed3fdf1c7da37b2ce1d189ca6e45ba88dc0baa334ad611244a81073ffcb4adb17e0bddcd5280c85b3d96a850cfc83ef577e637949c6c25fbd69414e611159b7a94a32efa71dc13f70d474bbf9e4910edf55aea88ba9207d68eaab0ac02a432f4ae14f8524fcfdbb3375051117f9ffd28f1fbfbe8e67f31aed40d0619167c5c5bfc97fa8f8b2f5fd4415c454381952de8ee0299950faf72d0bff2068df886101a319b810d4f75ca6f653fbccb31b22a4ad33a1caa698b0865a0db7596aa182d993da37af75a4dc5b59c78f8576e7ebd930afcb665c7564fde9a18ceb8771e3c6d8da30de173928b7db7e3d58e09522417df5e1f9568257ebf56a5cd01d8a96b810cdb49ba16f0807ee13c7f1f60778c65e8a39b4a0198c815b0b482a4dcb992695bbb3618628e3e05f7a7e1c6a6952591957a61559dab9ef1613f5cab87ccb7aadd78fbab8fae776d8a39f08f5218326aa606630dc3615f2e96221100ac48b0d80c873eaa1a0f804e6b5d5650d4a31f7d9b39e5b5cb719c98210695d072a1c7cdd97b6314f56e6b2c5115f0fb0d992d58fe7ddc1311d595e2a6a2693f5a4972c4716fd11a560e5b8e619235e68cee783a2b2601cfc486257848505f0f637878d50e2040ddc5f04b1c570303f41259f67255a8eaa6aadab3874147f2af88ae2ba2cad9d7bb97c7681ed97d2d8691a9fffb28e0d3971a3b4fffd0aaa91a362ad80fd67f68022b65fc4a465df6ad8f3c5f56ed1d2ca68ed47ccfa3cac7ea0613a11906c04c36f06b8b4e7b3e57ded2faf4b1887f623149f1ffd1910f8e7414e4c7657d0419a6a43dbb566d35d653115d19ea3d3ee2a99359d58bcf37d7c527dd4741dbae296fc935b295f496d876a5aa609b243ae8222945722d1fff202a882dad3ed21bc2960427656589ec2a2fdb131eb0a08c2002fe291d22d1a8a37c8a361a83e626b825c39026413ca6338f1fadfe07fb1beb63f90f56ff6d985049ddfbe64bfd4d126e1a37b8919c6ab59ac1056522971c1fee44d5f459322ab8887b7a7bb96c7dbb79e43047287a6c1e0040152b22e3fed54ed9092614b9c9e114cb05d02928a892a54e1a07794ca7884a1194f690ccaa7210e727178ea0c951ea97a877bf7249699ae9f0b7a4ac14c8e067d4aa7509c1bb835ef38a24e9417d52bb57cbec946a720ce9344aa826fcb318d29873597a32f42ecd0d2105a32e0bb6e207c6bf20149244fee6f9ca0118452a851b8d3c52c403e065da745e10f7db976c51609320018a1a802f05fa4054176b999236b7341bba6916c7f8365d7d83149e94b479461b940e26ab24f88af31503f5d0d9ba3cffb4b7035eab7a4a89e76f7fbcb608a411b519ccb5218acf281bb6d362dc6ed00f8cd654aa775fd65baef8b33a0623beaae0739341ec30c5ece0097868d4b8180af9338407cd600727078e7f32e771f2af0f57a554a1044858eac2533b1737f5d8903b613b45c24fe2753a0c055476e231afa901d38cf26857a031d771f5c1baf142eaf8b14b7c85b0f760e259a36bdd2dafc5f09653f730d7e7b538d5292a62eb200c8096131843cd17a418c01b57c702a94bef8442dd9074667e411d4db69532e4833f5039f7c7c51da67415246dd9b634f0497faa82d537382f9d0b3c4915b5912514ee9396f505ffb676392a7b6adf66f0fd2b5bcd2753f10d1afe9cd8f72963b882874de48032b7dd83e8a0774dada6d6061b65e5e2110e38a10329bdaab42f3e1f79a8c5e21cd33e0df0fc1fa569b7769b74442164cee5eb7d857a5edca88f3124157803bfc35fad4e61693c7b25080b1084de451abc94646c3d8fa30dae7c8db65b5fae23d837157944b36013038b8024373a95b31c9ed2c08ac5b2da5823f1d937cd326291149010f5d9e650c74651c3dcf4bbd050a0665376a39f63f26aaeb6a8abc8423d43bdfe608fa70c80f98997f47a4d77e9eb948a57b8307b78170e04f1de412ed6da0a045fb6718d2b17eebc9c87574f73edc22bc819f331dc430d182ed16c4062a1f1cd456b394519c79c07ce4583088dd124a91aad53be59ff42a4670dafa8aa26cf23e8ea27b5864a29d41be93880fffd6499bf6e37f9f3091f2ab91d933abbe8fe882eec2353325ad5b25957c9f7fee6c1eafb6b6d4b3e3f3a2c697bc52a29ebe58bbf2faee11b63ba5fc874ed9d2399391515bed6797ed045c22f9d045a0d71a0cef535a61f9a893e06afd13a626144e70802f9cec45df70dbb3a33c99a08314b92627bc4e3a92a13fa035b428fd06ef216d2b17fa74ff8b0210999bf0005e23f25dcf21183eefe3aa8aed3d34e00f8e5697d340d603523d69d843f455b2d393fa087bc1f2135c70d60cb9e73358a5781f94a77b7884ea1d03103c7a9a4178a2fba99b52017f4a32e223f34555e270e983d4c365ca07c397bb971f4f80a859dffa3940a1dcfcf5d20d754e109d07456264b02f41b1fbf922570ee3c4566e8e133a9680562b905473ed5eaea21669a6f497ac7d5e35110e9c1a771b8730b1c5d842baecb0cd8f1ad08dd465d3310cf76d7ac4a4d3ca7664815233bc068bd1204e033a42af6ff29cf409fa6d6f61e0ed084c832c05be3ab1e21601363d6bd826d1e644be183db484056fb656765f7190c624b787b4704d593ada5b0d36128548a31c0fc333f0d9bc481cc90c00bdd4ac579774029617a0c2fb6284584efc363870c3543a430bc043e3541c1a9ecbe8d8f8c703ba8003613f008c4f37dbbd9d5789dcd1ab096890a0dd003a18a8ce2bcda2e7e205f437947df66f30425ab8212e487f23c2c3fadb66fc0f0aa808a253e3de67190c4e614772037077da622a5a607401ff844955869e65f32992fcbbc63ae9e1cae6a519914c5098fc6f35af71b997e1055c3d7d14f61be3cb830904d55c9d9e856351e5cb36aaf52a7eea410fbde3de714a9a7908eaf781857f9b9bc58b5caa4cc85ad7e5dae6204368842d508fbe5303c3d031d29e3e107aac0fa7571b897928508f58177d3ce3a6051116eb0ba27937b98585f59ecc1643adf625afa4e5798fbfcf01bbfe962a8e898ede638efb745ce1dbf1592749ea7118e3daebcc2784e2616c039b8bc678c186f1ffc273c154f85d2d8a259ed16017312b42cb3e388d62206cd4bbaa05f22ff1cce940edf5638d35839f76c2f5bb5b4460a8043f69c7ddfe4689e88a9f58fac95bb4c32d254a7f063ec1952b65b9d24b80790ebadd9d2191564ce84d11152a0ccaf1a16a5f1acfa9e45c3f39da32bf3b2a0b33b8bf4964ff1d129e6f9c0a068165bcad783c00c29c808be400c65c22142be6a8ca2ab4780ffbdb2dd4ad9ae3f3f37d0bc75b0439d668c10f272a47a106d3f48175685ed5bfa61a41e492ca26acb6877d3b53b7f1c320a437c6180212cf67517dd6eb3a9e24efe10870adb3bb15297ce730ba3b05d4ea1837d0ecfba51eb4c24dfdf9ff0e16b1da434ef394b91b22dadf8769243bc5cedade1f3c477032a44c70dadd96b4052581d1a67bc207d11f973493c6e6e9f3511b6a6062c916c2f476f379a26ab8bf7c30083515ece5618717d5693bc1b73601cb3da5be7e42162cf753dac029a1429c87177f6c230f1674f602d00923c00ec726725f581a5b50c52b19f6dcc65f89b5903fb08372b47d5e7d10160d0819131af9820e485bd9703653af13d0133cbd114a088dc7193add8a28949ae55af5ce965fdb7cb15f2f2302f6eebf5793d4274bd0f104821788ba19e2c79ced70ea099277c0d1ba354fff5ee18592efc32d3803d3dbc4568e73a11a78d9efc84c08c77f60013a9269a343062f1ec2972ff5a0560b1fa312192c3d86d146bab8ac98e219fa539064d52a413b4b42c93b0e1b371bd92978ce6d3d5cbefc9bf605e3b8660985bf9fe43fdb348c7889a85b62fd847da5794f206a4e4cdd02e09d8deaaac2d5120709e0a8ef8eaf206fc1a2efa740c57ba7bd47ca9f46027f4db908ee656c839ec1fa5aa5b719929c66fdb3ac8ca88e45757a32f2e1e515fcfcacecb186d0b2611a76c0ed1b631c6cb4eaf0193e0919dc54788bf88cbf3738d85f1f876d72c4ef4a617f738e113fa1cde3f0c8881d255fc7c8380db5c2368aa725f1632e4f73fe0b7a87895f07977845f316cb5eb4a1240ca55cfb382932095153818338508a2b59ca5e4d35a7334c89c278e1e46e4cf727d9d6caf614c4b75a4a444634941d7c3be5cc033a1b9dba36e5b7948b05522863adc00563172ff78b9ecd2f8f915c9814162b287910f14402e152a54fffd2f815ce495e946c67ae25c62551f23b4df15e6ff94cd5b20cb2f447830d87dfb06694b6f12962502e99ee2ba82cbf4032cc0ae6c89ee8bbf85ad94091e3ac25c72c67d70e8c589cbf18e52dc2c1301aa61baa99229bd24f630ba4f3b79cc8c793357b6e17c596bd8143affacc41dc3c1964ea25c7f782a2997a7a3191146bc227e4969ce403384aedc8218f1d687147ec46d8d394dcadc54384fa3d7196b054a349240ffe7bd4169e9a0b151dd3371ceb877782f7079d613f59c5a632a8c1f3dac9d57d50d180fc63d336e77fb0fd708bf788d9819c0dd2ff3832ca804cf116725b5307fb6f36418b04b1fbfafc76f9ebebca8ff06e5671caaaadd89be9df2a4c22db117cf5c508a943977061c1de5fc993200fd66650b9cd018920a15a2b6f10de5276dcd8f9bd0e83439addb46df8ebf37367228db565a123c29593745b924c58d563112ba288c6fff5fc65a0a2c0e70c991d867c2e98e83c0f25d14b26a00fb535658e414d410cd8e120eabcc855fb7973203868053e24e196e0e3dcd627cf066ac93ff33b1fa75d1f8bb8a2dbe51bc1fd6c10ca44514d0a35ec63d700b69d7530e45e80a4146f6cfe5a4b2b7f113f44ca90ff9ab40753eaee791991c0d332b79bc1c492432a3dfb947d311fddcba7e917db4d58c1f296be60114241f09a7ceeb0adca7106cc6c57a94575620d237bb8b996f9b9e4e0981f4f159541e1ec5d7475ecbd8a4f95d3cbaefd2ef52e40910971641c5690adb7f89b92e69b40c8fd67e8aae9f3a9a5e1c82717ce4e1df4d2caf2b05b3c45d140ea338d6f0f0c4691b3cdf4ae180360a42e7e5f8ee523fd4bf2b75252838cf3c22d33ebf4a68a6b371b5425da2d805daf9bf349974b347db9d9c3f80de9733a98173a9eed677d65c5efe61a118f7116e225fabf2b7f6b1a6c6bee30b667f85a7c559de91239ca4ceb3ece3c365b6ec065ec93e20562f3e10fb3f6000ea23d54df73e86d801046e7bf8cf745642715ff1bd68cb94a42627f3d3e5f299d603a97aca785008b277da9760f1c31d6adbb0b994f8b3fcb9aa7c643e8a81adeaaf97581b18dcbcddf02ac6f57bfe829bf7cca0dfb447ff2b2518333ae3037071b3d6811070968147534768fc948603776e1ffbb71b1bef71c41ef64b06ffaef0374fac8b961cb3ba47c4cd97ce8c5d2436598c806e2a5c72ec59b6cc6b322aa0968d9d46213bc3c8386cac2303f8b575cf1f41008bff1ce8fe42d4a6763431a0f8ef19689ac0044e095f658d100fb3b4b29ca1fb2254880c31d2268627d140111d9911f7db9748c575ecae4de0361b47ce78e16f394c95b635f52454f57d89cf04805e7ea99505a29a65a2ef2c7c521026fcc2483f331307ac55c95b1a2239a2ed562de6b58996c0912566244bb67dffaa8526dd92a30829c6b0d160a49e2944a32d0753f77549ca1b9973095f7dcbcafb05d48df553c9a0e5a46c0cf4442d3baf6a65f263c4f607255c575492e6b669a1ff1d176916d306f76bf77e39c0e3673b56731795f870c754a9b6680f4a890cabf45bd4eddd2929d8d329356e9d688a7366b77021b437e4f6aebd0713b3af09b0de07846b948996d63a77afac04b0f00b7b12579d9008a5dbf1c36fda3e67a487bbd81c7af582e86b51f4e78e07333730411bcfff32bc0447c1c31c20aa13916a0ea27960e3fc0fd411d489d68794772dff58645778a226f398f399520fbc3e204ea5ffd7c6a23ee4d1759f80a52548f812bcaeedd0e99925c8bc72198ff62e6f99a833e17e148a7b987587e59a26a99576ddbcaffc0f4aac4d975e9c1893d50f72a4ccd569d3c335c1a6f616c06184cc99ac2ef22643cdec33188f6ff11b48c40ef8fa3646ff7cbb2fc7dd87273380437fd385e81872f95678d8090b1281864200f85c9ce71b3082072d5a871bd203091ee7a7c17f1031c8f77d4adbffe2e25d9777aaf1e98c8c2aa77e87a3225a04e64b5a488f78199b2eba3df338ce397df8c9325de37e2b566f76ddbf074492d6ba5742984299c5fce50246057a171a8270a4da665b7c9f2c7b61f1cd9c3e625a489e49ce901d70e8b0d75485d7f01e13056c589385b11f904427df08641e9d103e48bf2870aca27e0a466a7ec2d956ab9c41ffab0cbcde5019f7716cdda44eead7714da7a95959fe1f8bf1b282aceaa0112e7d1d1a2aa26f8561d641ccf82d7cdd162a05a01620a05d5eccb0fb99a3b8634fca042b3a20671001aaf2831666d24c81b5838d3b6d319daefa5caa176780da15ee257053da02c8ee53160011df853eb1369675612a8f3dbaf2df03a841e6b2ea8a040b8851846c098c4038d55c30fd0f588458b309f0eccd62a133edcec50b5ba595f8164bb03f90136a552d0ed142b257d57a1bdffa1d6dc4a0cdbee45dbf6a2c443220b3df7a6cc3bb2730fa253a3c2e4348e933909c6461b39965712623c9643cff14f1d464d21fd3ee27b8a1b6ee1f0c2467aa699e0885df0e408c5267aff828593882b0907e8c10fc2a8d621a1994ac0834331370b3ae72f49a3451516862c0ffad1f520c2bbdc7b0a87b7da668923ffe0fc5e3e7418aa4c3b7957eda9112cbb3bc094135ca6032dd20057b4dfa9771cd6a7429bfcd94109f2e5c3c018970b19024641b412172df3b08fd74788977cbd30c58094abbc8f5b9727973c3a22b452601f7cc2cfc177846821fbc39001ec68fdaabbd4208893ca11f0f4e597e11c8cc4d6fd9c34f1d2a913fe67b89b9234cc622b7fcba3880015be0ab99baaa27e2bb25715e79badd388a121c6d2426edc29dc43b7a85e9f61d9be339c3138d716db2e191d5cea05ce4ffc7e7b4260436f98b6201254ee35a3e685290e76c1fc61c0da8619bd71a581094ed0d44abb48c7fa8086babed31f16cb3e2d71d492ae308b4a9753c16c6a3a87dd092cda5d3dd9f9da074433525b91e63cf2b1919a167a1d0e254ae95f08392e3864a80ef072cde9a7a4d86b59a5fb2ee3537dc4955aa3e3bd20a91804e1d265a034896f5ddd6ed580e63e8a7b5d53357235017fd9c0f13e4d5a9b9dae6b555ee8d704de0a4754cddbd11c6e0cb7363c769d04f57caf0fb3ed5214d70a1def675f92364b8d8df87b6d8e135d0e22dfa5c995e35e317e5d1ebb50020a8dacb27b99704e8bc740991f43a5df15529052288c7dcc4fca440b13f3694b5f2f2199e83f1437d9d1af30806ce6d5d74d2c6731ce1006bd25956468f977c900d30cbb877f0566c79d84aba6527fef076a978a8dfeb1eb0fc30d86ef3b1355fa2ea75ac5e81b837c8dd2568da18a2ea5404e5410f6ce251fbbf21a706070d1904ecbbaeb25e4b816a2570c3b324fe7e99905111b0eca3243cced2febcc77fe3d5fa0516c245e026b16ee162f1238d270a16dc639e49b9db6e08d29ff210fe8450bb9b08696149672189ad57c62352f56df278ea5418d659af8c1b660cd1c65fdff21d593c6e85d05c8b500fb342e515c4721d0a26af24408fc6527b3f67994a7646c9974f7c1e848436485a037388c9234b8c79a69d3433fcea59701f7bdafe0c5a0cdc61ef4f107b411defa0ca6f52b497b2c57131a63e98361e3196913de709f4bc21883f91a3ae7537c85156d2c04b1da7169966d4e3da3d733978661369a911c7f2d4b13395692cff92ccbcf0299c7c7dad6272ad7d4da855f978bf06638dea6399acc3b18ff0b40e8f53ca435456488bc991b201c3f2f93bf5ea143dec3c305c9bfd7e8bc63b102950515633b820fc749a6c34d6b4d541ca8982f3b49ad83b23d7ba1701981b02ecb011e69d8000ffed8a7bc4e2b25015e36abf4c716d90679ae76833f54ad566c1b4fa6785c772269d6938eadff50c06c7a1232bbe7b089e35db9ccb5d4a96396cce977971fb2c5e37d70020bdc637d9b1fb177f03d34f2120c146ecc2b3e2a42ecac10f1e3b2009c40b2661ff2c68c2ac6e4dff379f91f958cc64cb5362c9a9e5ac1c983af5615c1253c79655d6e1c1660de0430b9b97fc2826bad947c8e3dd97ede5495788c3b0e284d3049ab7ad3624785d1453b29261e7da3d48f79cc3c49f5645e20fa9bf15f71e65b7dc34af0ec2956e7db85b3eb1b394a09b8244c4ed3873d84d849e015565277416580f6e17d1846eb07fac6626d286c42bcd3486d0e5361b508a5868ee1c5ca3e761dd07301e459db1382f52fae3c155af2b77881a46b6c1f3deba5f87929f8ed431f4e711158da0538481eaee422fe5e6cd8e88492f70a3b0b554c3797b62b79c6ed126979677197499c429363e9d228431e08637e0d05ad2fd3dfa22ad6eb41ff2135a54f775fc7c2abe23d8c77bbf6336dc7438d6db7e5270bd3b3ba12d3e6db3783c803e1732a1c7bc3b6933ea0a76e7356cb8ec5dac33338df5f38d7c3c85bc6029ece869cc8a2b65f52d8ff3a889987bf6da107796f0913c443769b0cf3d4da9b5c7b031b20b863abddafdbf5b2da13c5395a48777bcc83f082b7ba80833d88d247367b1a02bd0838fc2d94d7fa4f5f86a77ae81f90b28336b7421d26f288a148a800d01f4bf29950d67848503981e1512029cc77c49fab7bc564f33eadca978392200a49ccf61cb29c01d316206b248e89e47a09636fd35d3dbc8b7f17edfcecae93cefa079a47faad9a5b64fa53ae712d14e9a4a31ead694daefe55db438a465268b86274101d36be72ef87003baf2db3345f3eba43172e49cd15e97de6a7682cb005a11d6f752bc233cdc2f1f42bc4fe44a394ea44e2c86a6b7f47b6aa917d7d5456022455bc129b372b14108b231e93cda756765eaee307f7f5a6bbd991189b13c2601b9df7c0d2873dc0be7eb244cca7bef6713dc64242a8b390b1302934eeb010c84f4dbcae169ef461e22c397e8bd7c3edd977f5a235dd2c4dff71785c2b0544dd01e3f8a8b6f8601f48357ad666c9831c1dfcd10915a1766e4a4342383cc62630f85f156989cf296ab26908007a8243af8aacd294dcc596978ff7ac379bff2e12190f691ba91a70a82d942b4e4b6fda3adb61bf4b32335acdb23f3cc1e97ef5928f8752097abf01e8162a9e4567a0761ee1b021b559275fd57ac549357614ac1571ceabfe867c0a3b95a43f0c8467805b41422e5e26def438346435582d19872ad815d04854c5e74ad860e1dbcf10f39fd0b7f02466b8481720deadc2a47ae2ae6978648acefe9d29398c9531d37b46ba24f8edd970bbcf66ce6feca0b1e30738f8866e271d84f49d9c2d9a089ca011cf0dd02f9ae05e0790089d41d3909a729da3e27189d6dffb5c6a60bb9612bad09bc91d33b7034821022eda34dbe82159e9fee55e69425faf189ccada10f2357776c4a740c141614fdea0f24212073bc8789c19b30db9a0bfddb3fc4f31416b4f81f378f645c9553613b4d291e3c10a83aeb28519d200f168b07d03234267a361473f475bc92cf45d07eba8c71d003ac2263e8accf9f4eb7c77969ff4974f29f6f30911f3e81250b021c78e425bff1d40b6f96e0883785a58330e89a2321a7608b0254d1ff79a582dcfbe471de054136cfb4d51e7840c8c065e153c9d3dc311542d9f098f715e312c1f80585e403c385ff32084d4a26209bdb6ab7e8a25b32b5d4673122c9476a7a5d243d2a8eeca86b5fca7525d74cf110f916a5bf50128f66c61bc7bbb3958e0b8771ff3ca42fb236ab971af1a97b24fea11b2cc5e358beb60be1d95bd114890c013fab387d022aad8652e97167c2dcc70460b2a060dd837f225a8bc7006b9291be1d0df83c8f088955123cb1b68185fc093ca43067a046592c92a5256c871ecf2c8e8a8e21fff8cd7ce06d2968aa922e82f896656dbce540e7f20158203bb4f8f1d34c7c692311c78a5610855c0c1f318b06e6c6d9171417514a7b70f4dbb406eb66d1072cc61d7de190418024505695464fbc5bad486a5397c7fd02488cf7ef5dfc1d8eb72434ebb72f0eea40bb3874ed72edc46615c0c73c801c882904870b9dc0c1f105ef149cc6556965f60a5b75cbf902628e7990c43682d30df4740cea96ed04bd06b071f9ea7398ccaf49465cd6f705ea613ec75bc2a4ece4c110a7055510c1d8fa85f91d3c85d8859de4d2e52476e499908fe7fa68eee8e76661f4a64f4b2386927679803dc273ae1e1b8c3b075cde90e63804197e2788ea6876c91ed1e3d9c489be96605714d600261dd89b213477346baff1dca0e2fe6d3f5099bf2c28c0c9dbe38a83a41ac7d8afd8711f78eb2c5b6162e3147abe2aa1964da6cc482172f12128b3cf54c364eafcc185653fbc89754679de308199649cbbd6e7e3284cf4ee34b9845f604bf5ab3df3a930c5ad393a60cbc4e6f5308698a8f58219e2245b76da43dca2d72b29f8ffc102991b04d4e2f654f65e3a0016cb60cc445172bca924e950e7e4fc8cfe5e19e62bcfd5c528af514b4ecbfff3a9bc5623008523ec5193f729209b25571f3042f306e8b34da2dd9ac1c8502e6b78d0c2eef5f7194b483b23367288ec06e40c9db3f9a8b6139be903cb480861598bc0420aad4c54c45bbee64c385824df17f20020fa51f5f6f75d2cac0f57ac9dd6487b278a90011c17d882789163835359981c07be6edd3ce78b1dfae0cdef119d1a0016f1ff437d374158b4c6a61571439a1d221df9dfdf3af457d63727cae7437ca28c7f3d1529bc3f89bec2a5410baf1585b585b951f975942a3ef1fceefaf7b22c9dba0d3d9e8236045708966c7d63bce9050a1568ddbcd858169f401072a34b26ec5f3b31aff3696a50d11399eeb582a480af39571b92a9a44e603afe8845ec5f11eaef979115a45f76054f38fb549f37e1aecd80f27bdcd5f8ed0605c53e878b55676a256016cd4126e5eea704bdd5c4efe88783c3f4d7b8d19291fc23a2e90409dc16596c5ed708409c4eafa7b5ab8ccaf475a523d10f0f9b9e2ee53d14841d879c4aa4032c9bca80f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
