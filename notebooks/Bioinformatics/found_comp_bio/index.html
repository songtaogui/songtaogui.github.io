<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c5f1499d8e01a81101b37e6334cfc68c9727952cd20e6411d45725306965b8cb363e53fd2403f4ad49f55e35845e1bcd3c934dc392031f49958bd88873cce5166f56e9410810cd356a3fc572efe04343e7cb3ccda77c5bed6b64e0c84057d28e2224298f11913ccc349c0c76840ae1967cc785b93f2eedd853dceb9562d61dfc96c5f1f4f870a13d84f4770207ee979f2f2f50f061a4fff033810f3fd264dba7951881cc3fd3e2e47a980f828808b029979b6f67c90600bda6b9b55ee7cad3e9005199d60d24ffb3fd586160f4e76e31ccf06363b37ad0ea50c8691ed2739eed31c26576490f87315123a9ed53b93676006a8ed7b56bf7b940388f9af95f3f55176877defed65971623dc95f949810d1f0a95abee7e6afa902a8909dc21feaedd1a496337e3c64d3b957729c8a0d9a088d9c734acbcc143985a2e471c87bec27fe1a8115c2e233172c2aa19aab156e18f273e57ee74f0bfbef519e008eeee2fdba4477b27f478da80ec1b20ae611bbb4ebf1ab4c7a5fc72f577e3d9b4331db404ee1f3455a8897c3e90edb7056a1eaacf3a855e6b63f026c736a690d532ddd73ef5f07699fa4d209a27de8e03bf0f0f83a4b253829ecb2d034fd8db23f4e19462ca0b42ce6057ca6634e313849ce2f363ac3224cd3fbe4d1bd310b2c35e50aaea15bab34379c7a15df9f61060cd16c2565ccf1a471836d6b07c75890b8a143464fb0e180e3fc765a63d5e06d37db757159873d91635687c2f9b9e1005baf67a5737205265ff496862ecf5c2228999ced9b20a1add26bac58d760d97d4ab0bb5be6e6bc0f70d6a9d5c3464f73791cc4ca13597662ba405b75ce4a92bb1b9bb01c6acfe513e2ff9771c31401f3762ae3c17a30a1853dd5a258b7c0baa98a94870666ee355582b513d0d89d1aacd943fde9a4e6ea08109b3573b61051b8ea21e3c03d6b44627d13c09209035daa6ae1fbccd396fa336e5040e6e33e2551d7a19581baea7ff51c908e6cd66bc9457d6fe19752325af8671bdb0f3ea547f5981d9342e1d46a39f6210293511b4d73fc21f76bae761c2093eea6e022d1cd8ef5f3e0382699432911500afed641ae2fa2dc237b2269f227061768fe792a0d89c8f62408e5c5a8380a143557d281e1a31ce17df3dab709f00fc81c2439163e0546bec540a6d631f999516edd86ed2cb682d2322a207811dd6670acb6b912737ef78fd11acc9d6fe71fe437b68f0cb6a644a2700e8a04cd130c86cda0cdedd86e15ba42c74427e8eaa442bc8c43a2b9e2cad1a249169e231e50e076877366f42517ff462a44f02a9f728a59ccdb67bd17519b2a5311211f259f1130eeee69ae624f309efe6b3e13f54ec8bff64b8256ba8d43cb64b8fb9d192bdd5f5ee6e1def829879fed5fa57b32209b3d8890c0b50b0d4c6d762216e0384ea940fc65f7cbb72d457e676709248696a9a88fe56186ce8de4353b7c507d3a577d9db37e565e7ddb0a648a619bad9415a5e929d11e3c590494fe03ff6fd79d30eac56577080630dc0e51b166b31a8b83cf56580a58e92adc3108b364d2a58764902cf5df0859ee74448e9b5fe837ebc509762aee6734528576a0c0e425f687150d71683d860d0fda659519a6f7e1e0aeb0fb1761cd3ab637143524335352680bd7ed34e3205671d10b8dfe26c47c323a3b5f728bdc5551928d84474d31555b0be9d3e3c28c91c443ca552e7b554e5dfa953c9ca6645003f55ae9e63733ac04a8a79eacb3d60b8e8400c7007c9304f215dc5e14e01928e481741901999b583314febe646c3f3d3161d9e398ebc6cc95d68bd2530a3bba6ce4bc7bf010f27f2e93bcc001cfe913a61977983ff76246b63388aa63c494c5ea40119f9c07561aa44859885f357fc3a67191ae9d612268fa75c62cc17a9fedea1c453fb1b82d839f373b314927c4256334d7117ffac1a00ce897f415cbb70a4c31198d9c914889594be22997143b37d155aa3a7b2f558771492a3eb0f75f0f37d1dba4c8948cfc0d2cfff003699890b92352caec84df26e870fb0511d32eadf20d389cba94d62db6d200ab37b17b221a7a8b9f1987b31bc12b123ef52f98287d5f9bf652dd9ce89cbcc03296c0e8a98bdc742bfa4b865b39715db6b983f8ddf2da32d313b6a540a8f58fb6071a443d1f35aab7626c41bc8d98eb286e04b9fb9f48af559ab2ad5e787c5f904d99498dc12916a814012e14c43ccef63087715a5cfbe8ad103ad24d0d8e2751bf6f5da1d41cb178921b0fbcfb9d1802235c32880b4c86c7da0c6e7e5a68e4640bffcf25ec3071d81c4db23cdf2a1fc675c18ae2f8a92203b98349a6092482bda0d0604d5929891f53edb11f577ddb2d221a747e109a9bfe71ae21ab7bbddf8c3ab9e324faec01c24450d54598bb0b150cf586f8509f92bf56c95a35e9f6f4b92759198eca7990938175fad2bfacd3980a7bfc42a5a5701dbe940f0f2177f0ba6c9f7b8cfda189bfd9dec00018dd103b87577e958616bdaede4cf61a05d349a8ffdc01a220480eed0136a4beb33631da3faba18b8d0d2d1b1b0e7ffc38fabe634a56879fd16a280730b215292ced07a783576cb1ca4cf3705a9bb46f42bf40017303d601b91e380d8376deec65486ecd564505dc380e7013f73bc06c9a692e5ce5bd26bade3de2bdd8d643f0b13573799191f7a543714df3297d4550d798f969a3bfa3b9811e7e72bfd689426f6a14ed028a7b7e7a82c43893f1a61dd9889234677ab27f56a64dae51f411be1eeb3b7af9562a3c064cb2ac74e5768bdec1fb6bce05de933fd52584cdb900da9254ca8bc4e0663ce0d39600e99fd245a80cede11eab2ac2621d655f5a843f1cfc8cac380e724197427308cd48726e5a1594758ed1f6702a5167f4e268e78db1d8c92b2387160f7976074715ac7e04a07039897ba8bf55f1398d5622560751fc997f731ace88c4a476556d477cd47cbbd865e4cde1dd3ee0a4d4b48efa862ca790572bbf009a39b8c0ffa44afd6ccf72da653841a2cf5fc68a88e8f77467380a75b9303d2a799e3a5e6ed3362a31b6f46e892b5d35ddd9373c0e9b25f5dda9e7f9b9a558abb59cadc5582d37a255214da39d9fc04707c9f3d5caefd089c7461d0f5dcd322784d8994004a18a64d15d8d4b09b47c0eb34020e8070e772782a90d66ebc5a84e3de4655f9f967415d6452e71694aca609bd66d30dfe49066a07ce87ff69d97cebc20121ef88f17233ba755255c36643838f6e66c27e6712f1759e7e666c63d773c09b8802aadb370cffeed314364fcda6fa702c80d14ecbbde9525d97e545ca9819213d20537ed8dacd36793bc1915d5f85660a36d5784816a796f867c044cd7653a1fa982196de89cbc218c483b7c8c9afc2f7bad9841953ec3c2a5c020c10ebcd0507220b4fbb5a7337c8866bdcf3dcf00b6e68427dc6c441dd3c0fe88a4efe974d54750a5568554aa8712dc944cbec25c6a283d4dca778c2bc02fd24e21e65b90dfbbdf2707fb90877bf43796518b19447bb613ecf62bd81e1a4869d9fb3c2b54d1db4235ec15db9c498208bde3d209bb10d97834fc5614cef65c827f221d3b6b9529b274f605963614794cfeff565c6b8f0a09105a7c878b2f57469e42adb94e75a18066387d908d49b5f215a8c11c1bfc212e75910c0ca3ebc69bf2cea1c2430f042aed4af8eca10410b0e61a85b0a0fc23e05734922f428bf7e283947857424428380fd60b73cf4c752cfeca46fbc083ecb7290d17e24b6af6453da11578bf37befeba122be15fd25c0feb894e0887c63e2e4b6749b843b246cd2ba98fbb160f684a6ddfabdb6d19e4898419ba2955dba2dd3ee4c73dc3a974963f8081d655574d075f2a5915372cfca167cb703a19e6ed2a1573b0feb1c3005c5d0bafa2a445c74de04b1254ed8f7586a6dd55d2d460adb898b8a5adbc2c43f45ba24e7795e11b2d6b20d39a293462dda69ba1478e2c0e0b4468538a05c530b931707677e0727d9793c07c627d9a768a61747f9f03233bf410206457d719996d06c1eefb765f5bcf39937bf40b7e3535c47bce179cb2ee2b903bae29ce31a39b6c6efa17b8b4e26f5faebbbba425cab8da365c4df73d8f0b03b92120414249989a5bc56b26d585860b4a4d36cb611220679b7a686f8668bb9df88d4fd43da3f03513a8d5f7bc7d7e07c1abef1477d1c92c91224fd16d54aa3d525e06fe67c369969321616876f49506a06970201f9ccf514268be2036a9f5a1141a4d3f67c8b08c0f5487d4de47e8bd0a8a7ac9c7a0dddc58fc928927cb3d081c4e3a72f03167a3da9d7881ee24f2fc9b3368de3f83ff1ac81b6d2ac23ead7b7225f63ba4c6313947a7a9d3f679efd1862b3c1beb82858a99cd3f091b2393097cd8fa32a5fb3ae18303d046959edc2e0aee55bec9439979c5277d4081b43f6804cd4b2faff9b4897c518bdb3ca993dde14a9a3bb7f5db4331360899b43383db80a7cfee4c932ebdaf3df4cb07a14219b44845e34e354bc7bd7b6db89ef3d6d8c277b2f2a426f86e3a87b2793fed61b6c1b63e1b3f4e969474717b519e768dcf77788ae4ef449714638fd494d755ccc11a347234e28f0c63d2d80e5b125100c2cea96731faeab0d7dd64909c49263797929f4828b52ed13eaee037a5b5fd1a42be502f827e53f1910f8158b10b24e7beed7a6e75f174792581c256ae3b909ff77624e5375c74ca0c09eaf780e9002b818cb0666e4cb48f560d2f2fddb5bd87c91d43251e086e341aa9090cfc2b48f1cf712bdbb14f06ab8446625a7a246ba0a4ea068a13b7907bcf716dccc96c505f32f58252976d7c5feff7673544bdec6953ba4550d3d745e4be08dd92900f8886bcc7209fcb8cbf41eddcac6eefe7ce263a01456294413a50439682813fa4c9e8f9e0ea5c6bb30f9911131e1496d8d98684b3bcf70fd5e98ed963fc4a24ec622256f68e4bbec12534de6d7086ed7b3052a6e82396e42e9efba9b3703dee825455816cb26fbcc40bdb2e2f92032b7bf1ba8c3dd48a35ad9c689d723b8a99062eceaaed5d18c19ccd42cc10ba923aa4461bbe51c3360da754d0dc8f52c9566feb8ba680643e4e414f06a4fcaea853d87a40ae662237036a30ca65ac0775b0f8be9d0ced8ce75697ec0161d05f0d846c81e185c7894eb1552937f469ae573ad59e205f2a35b2b9a48d96963fedd0726c72279238e6bb17b7678ca8cc787eaa4ec4310f33e8bf7363d03b937d3fecf852307668a2af46b86d420b9ceea0cf6518b02e769680a6b890c5698c76305bc31e667a21d0e525302d04016d0d876b862987080e20efc22be4a657a629ebff19356516bd8b03b5b7bdcb0669902b41abbd8bc188dbb5788687522c178f9ec7c4bf5b0f9ab78964b4c91ce5e5943400e259e6d80779060b3990e7c763cdc61ef1e9f00674465151e259eec97bbf3390bdb5fb5b704215a2b884d39718a194966c9f1133a3e6eb2608ceac2eb868364b5a2a9c3d9c0bb22ea12a504ea7f1884c004248439380be0a52763f0b926164c65626dc714881acd3d928dc687c9c429f45c753035a0bd4aad852536cbd95c415c7cd0a6e779552cf66737413a6751e599fbebeeed4de98b2aeba0e55f90e69d0273569d90e21eaa51efc7610893119502ba729fc27850c53d8c6a02170db86e1e3b6741947c053f6d4c6dfe239c1ffc66b1700dafc32520a7888024ba487403479caad12510945b41fa90af46f7bd3226dbbc585edbbb97436036699e9baef480e062b116468aa99e63b12d5e685aa6fe2a9dee8359b5395dbf2684c2ffb072c0b10d46c6c6e336481254ee623fe65e0a17472daed7bda3d088ebe591b9ed52be524d89d1752d54093cf9b72f9b53d5038401635f7fd3016c88dc0d1a8198bbddab12f1119c4e16ac34fff38fb697121f542d654d0f3d729691afb242a3336000c37834f8031a2f1598961de386222aafe30d8d2c8ddb5f34f5d359e97439114a10620d3a208cb906823a6adf1b41c14d9ab66e63d7b9272df6c588cbd9d4ee05c9b8aec1b446363b3210d77de63d45496b9e9165c68ce95436e7e978efed5fce1ec36d94465262a508ecd4af2551999f59e026820cddc1acaf71f8a77b4cd5ca0179d2bba4e0612578a3fb9cd1090dc2a9d89a5a291aa3fdee766bc50b48e74a05dbc141dffa941401e1445b2889f3fabfa782ded184fe6e335e090b87a62fed167dcbe8fee48c2bfdcabeb1c8824adc4b55418c13207fd9c581b90e8bbd595fff1721016ff5514dba322fd0f97d8da86dc31403a9e00e13e4d3b5641f80cb0b95e3a62bbb9f4385da1b9907d42c83ec60dbaf547ae31ee41a49fd23acb6f135b6db1fe1fd5514ad6a7fbb4b92f0dd8f5976d485486de49329cd3b712a416404ff859bb8160870025b17f474997165fa779b5c086d2d3c1f538ff69a11e562fc80ff708558f306203aad94853279c32a1c1994e92899be2cf9df99a8033dc9dbda88fd90426fdb4e94ca1177f9ed73fb2fd9f8727be61293b5f6862e114005aa82a451a687aa74bdda981b1aa7ff409f5d875074e0ff9b0436935400deac7aa3442de8bcc242f8057e898723b29aa5aaff81da8f709b060201e970d77abc1cf62ecac8d0c79480f4163dbed5a42fe1f5c623a52031175de16baea2222f774756101021f8ce1cd7863bb56a35e0a9c2478942529dd8871a4583762d0b0c27502a00f354440df98d7ca2a9125ab6b91a305f9df3aa29886b8d153cbed9c689e08f5dfde9b6d357f84a91c495796658e34d76abebf5b349c085e7aca9d327db15ee88b2f725b8b0d54597e6c1f807b89898c01a032a956db1e58b367c2217ae1f5fcd446d32a82fa34b7b9af5728ec8f05c2e2812e7ed00b6a13c3aaac760996daec4e84d5d8d9a443c23ba00527dd75fbc0e0bb91af9bf5623470f047f61c57c6163757dbba94dfaa73bc6540b606dacb6a6319739ff39bc64b9d0b6a4a13d9b85904cab978c1ad20ed591085a5088d1c38d4e12c44caac63d6216d7cd1b8608d6290cc0f808bcc1f0793e72f6852b5c509dc4b0a03f23246abbce0db74c97e3fb4b5037bef477716332bbdcd21b83ae7cf1af70a147d4ee4fd12c9fb19e07c5c31270b855535111457e24f18bda4be100f4bdc25276d6df2ee6eb9a464e9bb8dd5fd6367315b70f00af86ef0546849cd98870cff81c7f19d1cd32e43e4ebbb35e8009421b6ef58997c0b9c1028ee44dd769e21d0376c939960c77fd16f09e05430fc42ef7e7b07ebb2b69ca1d732c7900b4c5a06496b5de9885aa46e459cb928ecaccb1e808245b19add6ffd94335259aa97edc5488ab27ee0ea46ed3a2644a0847f94d78fffc3a9cfaca18505194969da763b359d42fc8d79d6ab4f0b4669bb52ebfcbe531da18961cebe0854720260f5fc078e8b74474bee8db1c41057f66dd3167d70153fd63675bd520b870f9026c7414b83660acdae2c33cdb375e03063f0c167981b241733d44f07d58e46035f54ca953e9a31d98945416424e7224382786a5c6df2f2ce4d23610e4b8e43858669b5fc9e7453e906c49c8d3256e22e6265a8c89f891a0cc81698359271dd59ede88e93f127f93ce7b244e46f61d02fba193c0e203b141f22291f477b00272975fea4dc3df425eeb902c616bf8dde31c0db89fa34393bf96983c8c08a1cf21b17efb959448e0b7d52ca61885b1dbe6a158cc2cc88c2a6d1937a7232434b82df050419bd22b0b92652afbdddb87554821516baf922712c845cbd9d6551ba8e7211254b19f621ac87b180173e0a3ed4b14a9e01f664cccfcdba13a5819e65b017904a1bd4ae95197599367ec1152088ffa8ff80a83e0ab3bb9bcc2d9f573dbb0e21121c927f3fc9c99faa4ae2e7407d51a4b8668b07b90f76e5779796a1b370396038ae938fc1f2009d70644d39cfc8ea988006bbc457073546502a12df76a1af1945f5c49a824f7f7d19c47b16a3ea2b680f71d2dfecf410d83925373729ed1bc165ed2b70feb37dce6c4b6fb65bab0283d147ce451a192c0d6cc50911f974fe8eca61674c4dabb924c41fa16a13fe96592cc355f2bcae072335e5d4b1bb0033904ff71d5f0473a110c45db10f16cfa1249a2fe2a3054ad33a6ed0be1c8c6275db37bf48be6d866290195d735df3e0622f40cc5c87676360979c6f1d7171218182481241cd0efd2e277f043ddce3b5922deb0b549ed22466bde1c4bd820768ee6cdac9ac57f5cc0dd261b227a522dd6a73800a301cd714926d9967a36e0e6a6b05301ec5482a8d9d5f28b09a19ff39628a45201fe3406085a13050f007f962fcef20800228e84191b54021aff9644329afbf5fa1b369137c992f4a44ab7acb624d73fe421ee01f270e2f777a32233dd21d427394e340d4bf156be88b076d70db8950e658457e4931d25a9379833650f7b438b3c2cc442d707d86d26bec2b08f643be2ac585cf4e7af33ee27cae678ff639aa5298c54be853b00fbbe53f9ccd7bed0976d70c7d75c9ad5e4af0e60d02257346cefb3c5295c8c49d3b483109e4f608653e5978eecb36f9312bf8ac32ab8f69f589a601b639dc00f9b844846548bd0580ecbfdc1686aa582ec92e92d94f39e250b7ee8381c75810ef843a8b3f5a8dd0602a15a6536f6c5eb7fe657b7aec3b0f953057838af2525a77deb8378095ddcb0be968f90454fc55a61d473857a0b122561244a78aa7b7345386e7fa347291bda6d91f382ff6941721c149cabf934f9f7b49a61b3d5f1995a34f635a993ef0090774821979fad9877117d5493c7a9026077cb0bceec1b4180d826840b9577448dc4287fe04ad400e2cbf45fe70b8b8dcec292f8fc1c6fd58db9108d76c92bab1ea107e6633a862d5fe700ed185abc9e5144cc0d0cf8b7d9f011b21849ab086b0198beb6acea3616ca2d2145065e399b78be87c470793637f72a6cf6ee718cb72efd79aeed6b8b37668520a715df60f8c098ffadc936b0beca0c80bdd3090df716eea061f8dc981b2b31f5130ee27686c1de705685dec541440ab52774cfe6f553f3729edd03940758c41a6942704a6598f9cdb498aecfe378cd2aa3dbc44d7cf4231e77cfd31ee37b6af5402f249c2c2856d5d44f0d262076735831d6bdeb41495f4c7d1dba1f3b0b9263bb6389ccc17d65608de92b097062295bc08912dd5768eabbed6c5d94ea8f49273a93878b658e2c0c2d0a92a24b270b94b095c03bf4f201f95152e4b77437702a6874aa23991b76bc46bb9ef43135f61114203c01cc72f8c321717b295c9f65c4b6662bc14d62bb2c392bf63dc700926bd522ed8f03eaec5d5ab719e3d92a391b77f5201190b3b038a9b3ec80aee857b1e9dba5c9769269e0304a9130f3760ea8d1fb51eb9264913425ef7ed4a0f45d160788201ab87ba16b70d28237b271bd90426bf8247353ab8779eb5e2833fa8954d2bd93173cd2a5205304ec4cefb31d631d6f6082768b7f1c61d7a088c1c532bc8ade2fab5e41ede9ff6bf99386e878e50a3e6fbf5750968a80d5d24b440970d26562b6c2320569c4b90f58afd2d7273b8756cdb7339f8986e6466af3bad3d13ce486c9a4201a26fa0951e22b238b95ee842157a2317b71feb726115a992d4872a4b3d28fec69575e0d875f898bb23a0e3946b15eb01143ee8aa2de84e0355766d97bd254ffba481d7ae78a1cfc514730c3826de031943f66fada3c81c32b2dd56c7471c7fd4b3c1330672f76ab78a21a084daa86ac287bff04fd862f77fd06b39403964aa67cadbcdfe76cdb70613af1fe5f9d6bf294098a819b4c982c6b605fb7c05392d2bc86d58df6f0b7d033ad21bf464763e323c9bbb58471b0781ae9be4f284c175ae02a6fe41755ece419ee6aa31ee193a9fdfd90260708c62280a198d3f33517dd1b2444638b988b853cc9ee0b54e1819668253d41e01a7625ac7b6b2f8382b7989cd621c8795e1e8d5c82798f10b37c634b4f5180cef5c90ec5aabc74ca0cd710f5158d5b48700dcb3a9c26288af62a930ebb765a570baf47fa8e6d3cc42079e2ab6b7a0aa744256726abbd5ee99277b42c1305cf1d4cec39c8fd647adfde3ab563919eb84c0acd9a43a4e3ee6ca471c9bd7ccb48dcbc1666fddb6e45121c98e6e1d880ab0143118dda482bd71d51c76b4cfe703cd7bcc3d9c05e3cd35911d26472a8f1162ee3d18705f277f9051f9075bfde8d4014ca58c85145f7f7fd7d924a96399ef887b94da5f07939a96b17c73e3aac0e661b30e96d3803ea0f2cd69c97f851d29f5c84b94e76e04605a5803d659518100a3b584d130a3c12e2df1c4aa652c4b1ec7d68c5eee6bd71bbd69d97bf6a4decd3d43b725cf45f8ed45d01841d880bf9bbd5e6ab52928c0d59ec07851450afd1a0220ec787b3da63378146438792d2b2dc02d1cc9b75b926a7f8681e707b64b548815d29acaf12cb272cb7ee31be9334409675d260a9063cdecf81ceda1604849cd0b4d6b1ef59c9861addd992c4c3d34227497c25fe9b0cf814519dabf543137fd5772898dbf8c1af7e926ec60e5c168abcc1fc5f6a81f4508d6c56f7a7c43b249a9befe1b653510f52188e944dd1b0e4dbca08ed8738f2439914a85989ffc9550a06d51152358f395c16977cc6a7ec333a0ab451815ca1249efb3d708c374169859720c18c785e6b566f8a5ee8dc25c9faee9d1435adbf43a45c19d0ff27dddc05ae5601112929a7632207d020f1bd45d8522a9fbf1314aa631299fc4465b4cb7cb52a0a7a4e97bc260f9845e6774d3d391286df9cbb4e0749381894e7e537da7da3541ae544a96daefc56a7b27e7662337b5393fff65f4a8e692ed1f6b3c6c0d89265d89272fa80a09a74f44febd38fec99b99d00986bfad943dbfe29d52888c3768d2484897fe2a7f14c12771d7e90b8b3913ff14726d2182810cd09d2b14244485be27e3d4eccac747e6f67323b5cf5f30761c07b6854bf1e339bf9c0f1db8e28bc8351fc706a226a228e89470a6352bdfb1fe1b189d666d1d6afac3d9d61a6bc00e0a295062411db29af397ffa529832d85e29ee4c70179964229fd981e9ad562db54049d0af892093104b3c8daddb89a8fe251dd9e032327ebb9e1b39de456dbb598d6462e2d3153c98a8030375696561d0b2afae1cd7d5a0039de40d41649a5c452d87c3ccef2a9d3be5079913e21f0270009fd01771e3b796531b6cabcdcbb99b465a6b550b2bb120b371dcc6931a5223ecd445ab14a05f1d617f040798d4290eae14a66032d2a2412f0ba70db7f76765136fd6c1ed748c226c8781df4c2a1ce209368c9910f7e35bb36d118f37c867765ab9f2abfbde8d95f3bb2d575217f3ffe2e24a6e516b076fae3c2a83b2637f9ec10af4d4e09492d02b9d7d325d73e882ac4179e922eb79c5b1d9cffbd62f7458c9d4e41813ab47b795fda833a5a59f9aeb306bfe0fc164d4d71ddc95a0e02c0f7f7ffd99417ad913c5f2c26145b80d87ba3e2295302c3eead7162ba223af8f0ced62fab1bbcd05e8074f0dbd60582b8829e0e1893df6b8e44a974a7a8687ea56c11d2dc475f71e5209a7410f2c50ca9e1495c50cd711e6fb5034bfa10f5eee659cf21ea580540ffda80ae6c28cc105b304cee57ea62bf78b243bb7bbe714df4cfe4ba3ece502a02a87d2290f6ebd4fd1aa0749ffd9d0002f6369bd2724e19dd0ed6202708bc9865e4800556b522ff64bfa0aba7237c1c1b3859fc621660f7be08de22beabb131999059c82d7198a7cb76954a05acb0984c91c325c3c16d26fb18fa673ba95d8bf2d593a3dd8c569adeda36310a63707ef5e9aca2569a84c130b912c5b17c878dd04b4ffb3a15d1936b8d8f2dc57bb1657f2805699d9d7f84938fa0bdcb82da8a8765b98759282d451afd70a4952eb161ed8282208ff8ccb164f356a752301b2c59daaef511675201a2f0524c70f23e29b9d143ef756aba4f1d3f1af64b93d46098c83fe71754069fa3a57fadb830727d9c3b167045edc688b56612114ed3cd371e408d126adc3811c6afecb76eea9870e25ce408ab88def228c697b3f5c9833feb14efa7b21efb1ae1c78b9874e297b9241b43bae1b933b766fb5284915fac6231743252d9b09a8022ec3997d57816500c209799da9bf1eb2df723ffbc9448867f8e0097edf6ffab5081d4c0400d934d9742592a85ce830b249909020e68ea708e80f827256703f4d9f9b279eaeeb93fbdc2fcab7691239ddd7eefc97398b6fb1c58c2b71fcd0047ad9129d0066c0818053db5ba19aab4f68a287f1d2b3628d11b9e7c36f1914ccc40e56f36d664630def4e6c5f1bc0590694e1f7c5602f33dedfcebd67dc054baa8beefc4dc823833fc298c94a8a9c723ea83a209b18fd4209b0fcdfbdc3ce2d47be5e8037155a5b1ba8724c490d768a70a7ba23575102cc8711d113bdd269ade0f252f89dd5d5ee5a353db18f71e58e748d370cf5d59602b028ac47ad996ee98db042596505240ce5db1059ba84bf863ab51c3f8992a323d392615b4cdfc890fe4e303e3425496c5487f709f2b6fa18101291ded331be5ac2154fc752b0e59ad9e2af9b52773deeb2c7eddb76e1a58b639fadb4f1fe8b1d121cca72966e41268fe293d036ae17451839788ac65f802d67f85b697eb5f1b6e0263dfc0e195d34dbec70c61fc7f21d6dd6ff759d8e10036d9dea6f135676df216ba8015b6a633badadf703018b4aef77a2ddafd4ddcf76341f1304bf1e876958ea5f7e98b02d36d6a4195cda363ee95eb8553df0c011872c81b274ec135c476f63691feb72f9db1ff3bdd22d318b28e67447efb29e2e80e14d022090e699ce0fa9a82780b92677259df63b4febc9092df29e0def02c27bd4a2078d4cbf29d21cfcef3af6935d7df9ee068eb77226aff864a3581bc6bf96c98e9db909a65704ab8fed7951178b500c9413dd9276c0bda09bf456fc2b6fa7597793a67082229faa429289296ea657a664a33ee625602004fe0ef1703ec5871b73ad4f76f45a070e926d96a07622fd59f338805c67d7145299d6996a0b980e8a7a8e7a62342f071d32bfe748d1244b3a11d6ee57230835b63e025e24b194aea655fd6b2b7c275304ad617867165db0331c0d838e4b5e1ff1f2b9ccae2720880b7a3e5eac5f241a9dcbd6fd0d2df7f0f561e0e16ecc99df04ba65f4f8a0b551e7063e0fe0d3465911846ccd6500fec5bb9d6267d02da5cdcdd102665142d4113879e05431fafac5632e9481468fc8f7073bae18e92f0d35f257000d214b979b41e414b7ada90ec11fc410a834b9e9d8c8a765395dee4c7e4f024d49bb2e481e4d29277d9df6055c1f05b2ed8750c458bf16a5d36fed0e7b8dfe9d3eb6d08e1e00fa13e54fe6f7652889036b014e2a8028baeb17bb8e407fbeecc36fb93e4b11921a94b33eeec8813872f1120291c7c71b03d169e9b662e02454ffe43ad7cc585d295f1b5734c6d29f28a9bc9c3959b0e8f00a027df8974a7b83129378e1c4d258de9b4b7f823027d62a03cc6d6cee995a5f09f2cdc3b4e79145459c94178192c37045d15e23ad696e8451e4efafe47a8def55d02f7928463bfa3ac538d837d4680cd44d0d04ca040f8df39ae17c91f0c74dcfbc0327624b0e0017ad5bfc704f4ab3f5e81a20ee4f8439416b9c8162bdbcc4c25be7fc83628bab4e90143b855f7ae684f2c6a3df9c61efb50d72ee4ffa884e48668b12103bfb39f69bf7d04e697f77e289cd50f87da68ba6f2bbe689ef6074401f30fa8a5861880004e9c7dbea327441ce01995a4d915b7b7b4babf2a23404e9082289469933d8f70b0249e071d0150b057c9949d2a58b56a8c5329a3d5016d287344828a13b7efddc3786885ed3b77cc3f6ca7c9c57391ef26633e1d4cd1c4cd43e787cfb1a799bfc3937c015c8a1378ab6d518bb35fbc76d3337671a62a06331fb5165c53b728b120bcfd05efaf6f0366004208c578fcf3337f07cbf9faee08b1b551b98ebd98e144a77f7a27bafc57635c72469cc06153d0075d16c006b98ece9a227d3ee39106ae63222858ee098a0c4567ace041ca33a9df4e6993c406a107222ecfcf33a432ff9e950cbd7deb24c834f8234833865a0e540b160601ca75f462bf03f535cf1b70255cf6b1b800496c937379ba72093e82e2fb96955458d20bfdd78a93db3a519cbabc8c9158e7cd07e11a94573d77769a4a29632a62fd66b71d8cb1ad700e0a0f45ea3af5f61073179aa448e2ee8e44f2dd7f5c3000d9ad7e67f9a360040711f49df560bd04a35259bcda9c7779d05b3b79fe29439c38ecef3a3ec35184a40513b5c4eb6d1fa30579a9cadb333193b48836be9048535979f6d1f4eafbbf8fa7f5b756e914369b2bb4cda247d17e0dd709f4749fc0ef1833c8ee57c56eeb900703bb33c6e71f6899a75ec2360f08701553464b366b5989d937b0524cdc07b14ac2674130a7a5dc605cbddfa9020a30650ac377be053ad064bbc2e9b7fc2f519a4f39df971e876073e5b36908b026c854edc1a18042765523923da66b747ec896fb8210952c4cf156aa0dd37646409158011cadee3e62567c706133a6d6e5a34749c664f4ce6f4999f4110de664db35f3a1fba811fa157c4351c8b86012c714e7ec6043a360f3a944a8d68e33d7998a13ec0c939f3423b716876130d1279d16a9667c5fe36b96abbf6f3304d693a238e0aa2e77eb7975110388fbfb5c4e4b7cf22bff4fcb5a17221f7b76ebe237544ec16db5b3daac2d6026f3e9f02b44eb850de16dc71cc4b16602f17b7d5302f89baaa83c1bc035aa63ddeebe273a790ee3b876f2229a909799e51f3606591a68605c768c2c244cca6df689c329a65a14c3f28d8e5acf9a86b81f68e126e66b1344982db429e6b2c8102853a233153d109154cf16a21adc05ee28f66d6bf02fbbaaea905f8c7cc0f692416f442501cca1f7da092e3a84dc8ed52be894f2422033da6f3830bfa35ff234d755ea8b910fa00c95822d989083edd00d5ec540f457a4d9f6ff02b1175099e10a10cf94f1b706f1e6cdc05b888549fe9cd3ace223ab9b42452739e1cc529d15c33e9a1cea11fae4afb3b3490aa15d61f8a64a9851cc9b076faf2ea7a503369e294cc07cede575a8fa0fc31f8db184e51ed94a2c4d84721b587a6fc9b9bf56a066be538003fac301a03f6465948d5130d4c4d79c01ba0be2536805c6af6bd7aed10312e810d0b1a976fb1a2c65a31f247d9d51e052d9046f9dbd04ce11473f02c968e484e750e5d6cba28825662e69c9917791549fb8744b3a2ef57ddcc59a1ee8a39dc07fd76e3b3fe28a2c24c7ecaaa123d60a81a96adf91c1a897ba3765887bdfe1f85ce1d01fbf50295cded2e5da290851f797601631c41b4f36ece108d22e725338f99f49f9a438cb1c53fa0cd80eab72e94ee9176779718f189c03cd516448565ae4dc15ec0b5ae9145460bb6231264df5a4820f94f954b28647a2267b7a47401797a45a76a060a669d893a027f6ce50acf96de0f77026ad167c135f1bc459590308c5d64a88bed5fe893ee1d67dae35268e77116229272ac1a2f901e146e64f100f0ecf4af570cc7ef7c35035be55fbcb79fe2c7ef381cd3c37dd66aae83a1b133f2e47b77b9c8bd964db12c258b5860afd588920e4b38022fc25b1ffb54d72cefed58112511b1305f695568e28252528f7db34dd151084b6d5cb689af8d6ba900fd4fbe90d13d62715cfe8032f6f511b69a3e0850e99f052b8dee23c76d827c5735f718e2c9d0faeccb65e2e4badeeff51b7e126d6656ca47cd72ebc752a1d252600c4f1d939082b37ba245a7ad42ca8b547e4b42dc25c680d9546c7b4201bb5aad05b40a210f72259233a0c95f60f6a51a45bb53b4975ed62f70fad3ddd4a1f87cce986910d51d38e48cd18f5d73d4477d25fb9b9fbef555130bfb7e81da152cc7590cae3bb774b0dd128df775235d507e80ac18e3bc9c006f9e7f21402417b973c5e2fcff2c24bcb82d8237aacdbca691be38026c7bdc9aa999dd99c98a3e8fd2cb8f8274ee809a33640439af5fa689a1ccbb13384b43a8e00ea6ce620a2bf2e31cd429d5685a2ac9d3a8d0c0ea5cc06b248d4b38dd5f7bf879c71cba93a32e81975171c522f7cb7603711e08d28ed1a2bbbb311008ee6190896be9e66b2a379349b04b0399a4919819b6f6d258fcf329d29d28dddca9bfa138da83db540a3f682c49ccd749d534cebce85765bc972441ac0cfa63775cb56c662fc33cf65a0dc20129684bd9bc15d1e9730921c75069d5bd29aec0b522ce6d401811f693940b8a946e0875b3623173aa80b9a3257758b9b8d433ca1d9e84f703d2a5dd95f3f115accd9ee3024a8ab3319d34eae5b99b3ec0e81ec89b043b5300f6ef99b2e3be7ab2517ac1955ed2a0b94995217725f68e87b500c65b429aa289137db271814195547389ae1b842ae60377b33a0bf39916fe36d6c246fc305ef93bc744315fb3e8d0fa2f78c76b036bd1b56a42d0dddd74aa17afa8a4bac887d155acb3e1b26607ad98a5df31c992529d4d822b20042fec757403447f1944efc1afc739f00425cbe1fb04b2b4f04b6ca99ebafa0df37dc707e3df493e230d8a7ab823a4b34c553b60cc8355a56d670e0f30d612a731c87809f4e82375e8c0326ffd9a54886cc2848fc5301b8af64721a5b22665e08c46f60cfdcf1a9a8684e3c2843491319d5fe328d6d9ccf28e5ca0759e6007eb661ec4fbb1748ca9ec18abdf2d84c3bf4c92aa8a06648f5674b9fed6dc499edc8e23795454bfb930fcc5ed7c4c6a91ebbe6366998a356ff660a83d52d4ceb293fec791c4b8ff2e2ddb03fd966d0c8db5ee0ec6c8732b527a7bb8aa0420a2a9f1f1f8c53caf6346658cb6c7dffa3ea22b4337f364e983a8533bd106c068abb98a9f4855859323715b004fad574ab162d2422d8926ce5928cc10d267b9c5b2ae6437213ff9a1b742785120f71065fa613e5ab08f7a1d78e43adbd692558d116d65b441840289101219e26507c262433ee9dbe7878a520537208f0505a8bf5f8255c7defcf4f7fc60c9d7b560880bcc6af77a3ee82ec10c9b71aa5a5bd6e2917cc0b1564fb23c3b59b171250cef8bc96602b02b51070f015894eafa3fc8b0c0e4b141c50c059b06d4f58c0d2aaf9661029a0ce9f95106c84552a040a3abdea36f6884ba2c06d18905f38e2a0858a14f706e1af2fcd2ef4c5858e26df6b1b77aefdabea6d45b1355b25d00c8af4fdd621d72803bd2af6613732380bf914554abf1fb87bbf98f666c6d8c2dbae8175dbc7b4a8d61cb26da094a8c4daf9c218ab24be4381c9fb283714f7679fe593c2fb3e49d86c0cf4d89e73b0370164d214f3f85ec7ae39b59ccdc1652ded51625e60085b0f76bfb9fb463225b8031b0a85437dee9777390d7e6a5525b529e150bda03e06fbeb3f5564ef61684891de5522ade9224e8670805ab201e225763804aaf7c5be4e9c183b755f144b3399e652acb9853ba09406375ca76db20afa59226bd4dc3875d25ffe5941140effb8a9cd8b2e878b960de57c089c12aa158d5ad4abfb94aad8cd3e8a0bfb54570280facae0f18ec9d137ad413d7a122aea408c53b9cd97b77c84db16dba758676638e89a07b66390f5ea3448edb5ec45c426052b63e608cc7d595b0dcd3389d79fa1a5a2fa4f431772b6c8e53aa7366453fe3f3a6f95ca2245ce9d29d37556b17f10064c528d7b4a10263e0243f1318afa47be34b50bcceb8c66dd96580a890510c41f10270a40e935c3cfadd816f7ac3f87e82a96e2e07b5483434e793971e40fce0a63b5fc6e9a4999a673fc9e0d37492ad52ac24c074c3ec93a7a827118893481d907a2741a917fe17f05ac7e63da13dcf968a4b15bacc65dbbebc47cebcb6cfcb2c083dbc59cc11adce0ce41a7419cdb8af907fdc0463b366f1abf82250e6b920ac0399d58a45aa3ca922a70676dbbf7838100ff91cfbce030a67fa6c4128b67c9cfd0c05dc30567cc1231469e081e37a5fa7563b501cd65f15778151802784f584ffcbdb21000427b6786a170a02691bb4e1dd9b82b6e174278830828266d2c456208a99406626d2efb9bb43dc480f18576c1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
