<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22bbf168b0beadffe7581344ac07a99f7325aeb2e026dba884caae779d4fd4c0128e0b251d388bfd493494ae9d2ac249e529943336af63ef2e6e98f01792c5f5109fecc7231d85b7adeea5ff0a1fac2bdc98e06a3851b0a779a65a66c557db3e4577df7b9a1de3d971abf4b23e78c675132f379b3308d3e90c048623a81c30507b85ed853e0b22de604c9615ef035f792a8762ba95b875d65c9e9009ae70b54954f53d3d908d24fe9bc1f750a2a5decc5e7612ccb27a74569f8ae935e07c5f3cc9ed759f72a337529cd6abb48304f77cb94258d7d2a7fb2ab9bb42bb6b0424bc379fc7c61fea44361f0ced94c28b01fcf51166cf6fb7335422194726f7955c70656b0499345203d577918c1afec05e7e3ef78c22f892bd44b33e99a0185aa9fdb04e6b9ba0631b992551eecf34d4ba2cfe867d8450c65fb719ad41f8e2374e264e03541f3ef810da175d39ada511535d5838d8dce99952783ae880b3345eccbdc33a6f711280d2582211612123130a533bb83522c5d7c4e0095bb6da6188d731fb25eda852e848982f0d8607ad4763c1ca4b73d1af0e2e7693f6afdd5df27d033659704e365655a3ed2b3a9fb6fe54d6536cca9592d91456995b6d083e605d4d0a76019fe12183724a499ffc483b8746b2baa67415400e03c812cd5360822966e850ad24cbc65855f39aabfa09b933ef4c5885079aebd5504b3e0fe51c937ba4100ddf10c432c19c35e4b9e8ed1305f5db225d037a1de8fac97aaa25fb59a3cb5133212b5370821f541e87c54518575025f113479241901452557c50ee3408a1c9eb9c316cf741b388c5b3ba5109c9dbe745769b61d14a5ae26ea43d5a4fb07ba5ace88c0cebe5df09aa3317d57a564ac5bf4bfa0e4b3539839dc2cbbaaf4bf93d27fc9600678d3319ad1cdaca839fcf881702f0621cba7ee7bf1ce1adafd708f35743a30cda6963ceb6000a0a539c658383b46c4aba900731ba187e4a9cff1a5195b53d968f362f10d613aecc69046e66d3f3cbeb31191b5a40a1c02a76cad1a8f5b956a5d5f5a055e55d6b9ed96ee609c9177972541d4fece369b0d92660564bcfd4564e936d12e75555e5ed10007fd595e62a2216bbeebf6416f7c69d616cb947444b74228b345a3511c4b3d1613adee7a43fc50ba0b78fbc04327e0db7cf48813df7b12fac8e4e9ed8f78b2fb8554f32d8e89a9bec636774c350cfc1d75a1f1c89a2a98aaeff87651ec547b8465219f955dbf527e9b46654711bdbd5218387d7fc0873501bdc85bac99dd7fe19991c77c47ec9dd3972d75b0c2054ba192c082f1da2c57d1f02e562aaa7da3689af2c5b09fc21625a14b5dabcd4f569f1f2c7949becba2297e0cc1b32b5df4d870df86366eaca2300a7e4b7a4500265b47d814cf1329a58d41e6cb278fc8840c28cc93f93ba4130f7042feb5e85e25c7d745a7be59ebf666f8a19b269e343f56e84232bdb27586faef7658ba6992fc7a7309b5aa70aec2186da4b995c26a1a29ace4ccaf573a2ad211db270f40f779be73cd40a4c981a383992fbb23e3af55e0afd0678a49c39ddba4571250bfc9c9c3730dbc3dab8def70597f3790a4aab75bb11d64266407c55e92d2686c88b5d16fd764fc10febbc9a604084835ec8ac59723c4837f8da5485a9d4ef8f5314970ee4cf0d25def9c90eb1a8dfe1e8752d1bc4e9833c097edc03eab447a414398421ea5a16021746560fcd28669c1a0240e33f133d9d5fccd608e615a7f0ec734b6820bf4fbc682ea10fa23990230d7c9c517ff207081a63b68f03d583063160c45baf034d712e70452cc0792fba49c6eb2d8fc7ee24048951e1244520c52b77cebe0020969d45b53a29a5064d21412a87e7168db49b798a3725688eb30b1995aa84be963c38cf016626bc589118e939df76bfcca3a85852f5bb4994552f8a5db9113c53ec5ac7ac70a8565a280ff3c9481a13dfe82e00337866b92a19e8cfb39540750abbaf0bbfb0ba2a414a1a41275084b1906034c6033a31897022632a3f419797a011f263b7c1f5acdda1e4f300737a01cd172a3475118ed0da88ec604a96af86f76ea0191024d7a695044544c78cd5f016af5ce4904795c5657d4e67df5efb908f9c9dd6e4e0dfa1085ad9084b3c3656c41eb970f84996de7cd8d51b5ea0408a2d014e5ead1c770b022b70ba05a0ad25f7b13d535cfc272100d18ae8774147d72317d6d3f9f9c859e360785c51b1207f9ef0ae04db4176106b50ff9bb84be5522d764ac8ee5c257510e035717547b11a1c773905ba2bb303f59b0c9e1137d76c4a743b472f87da5f70a0b7c7b543a5d7af69d12283a2975e884e247af0ff27d112cd22e22fba72fbc207dabd71d8bbe5738b50b687236393629ba39d642184771dbfb09a6f95819758979c886e1a2a446c2359cd886713ea101809a40cdcb12fc786b399309dbe8bf1365be294915e1d032ab498eff90cb03b96a9358d8cf4f68852a85de002dc1e7ea3fce2f5d526d0659c83365a0e60d42251b1464198365c479b0a25ade2637389513268ca6f4c656cdb4a12edea4a992b74c4e8d90290004aa280d0798fa15a800ab6c49c60dc67dbd754e8ddd0f77d4138c6d7b96454492b0b2dbecb55bf323aa28bf487054f4a29526db5e3404b867facf5d5d541bd35528ac3c7da868a9c8a4ce108570804c238697f56555f8bc0893868998ad3e86af3fc13a1e0f261a96d07f1452b15332e0907ed98bcd6c0420cdef1fd3b4185aa9c76981da947be8a06c66b3ee63667893944f436382f69e0d83776aa7953c0c79c0daf56cca0e9a8cc55647d5bc7102b10659195dbdc4cea15a2b03df0603e9319158fba1a31530a38fe233089b2e7a512d7541431a89bcba2e6c3ebeb7246d0de0a735dc6395b525cb7a2b4193efe53cd3a25f091650a27a7a9e875de67d778f40938adcf164b5530c024ceb1110c283fbf279980f9fc24cdb19e42ab24e282fd975972911f5de9f2bdb0e1532c6c4502bb61420559ed44f80be7519969e13b83e49c45da33129a67d759785c7dc3982fd954005d181fe6f959e7e16903061c8714be10ad063a99d50a40d153b3baa28d98dfb268a692ec25e8238827003614680a6ddfb3241514829e11a8efa3bdf1be7ab8770bd54edf471b259f0537b2235b806d10241ccbcc0d9fb956f93ef007f205d84a16420127c32aab48b0d85d110aadc6d26ad38a5019f2d79d63d620d37350e80742ad90d08041a483600ceadc41cdca5a0a7b47f85ed738feb6ec0d7546f1d70fd8f97ad259663433e2ae3d3cb111485f8e20a5a6e4efc1d4e6419daa727ba0d326479c32d53ab58566f006f13e00e1d4ca0792d72c5b2333df6452f3932e305aaeb78968a45f726ebe257c8e4713d230321e6356badb7f5225e13cfd713f98b206473ab320b37b66f592f37ebf3513154f3a6eb57a558657da36223d26de026db2125ae697828e3542d70a64362ee08a53742e45be5f1c01011647a76315fc0fbf181af9a5499dab94edaf90f627400afba6faa8deb8b0ed93bfbe1e4906d40b26c0682bcbe57a2fb5f3db1e690ea36434f16233449fbc26a11bb1fefdbbe1c41e4ccc2629580e900a4cc63cbeb2c751c7164d47e1b1138bdbaa19c5658141be14cc6205dd63975dfd15770f7678128d2b0a61f6e54c59ec3192b09dcbff972483f796fc637fb8e17a8ec319729a23ef86042e1784412870866b776393be12bc2a1e1803ec7bd83ce0bda2d732e9a0e15251aabe29872db268926cf22b72e3736df5c5a66174a93be44d328432ee1bc87d690d41e27818c8a12a1afb4723394290f4694fcdb73d8a8d369d27180c2a03996ec27ec37151c69ad510e912ffef665c74c79c8cd6e4d65d4c6f21f4812e4eb6f239a8a4e19ae08a530a03ce59112e43872d221242985eeec6ec31dff9fd04f6bc940b5261dddf51550cdd83aa1f2fb1944b8786b04868133a1d52af945d541284135817ce4c121375ddb7a1e90e776617bc21eab5d178a7af3dd05eff91f4d14c59fcbf980b155b4f17eb2bde36b016af552010364a152b8e8c77ae37b4a44a5fe59dffe2ff29da72cc05c286f62c5062e10952fb25f46ec9250f0b063e3d476a2081ce9caebd38d463f1f2d293bf0695b058ae35e0e34efcd37fc3ffdea11d15abe1f3eb9bc51a01014c70b07718e8cce0783de4738e81e433f61b30ea460c7407de5ca167932ebb435cdeaaebb70b594761c249a103d40faef8891a461db3eeb89202022002c2e3f86219935d1d864086ad48884f0f6e95b1c7c4c045347054700269d670a5f9eab66502f3ced21747a4fab18c2d81effcb6f31a2f0c0b25f0fcd1044431a958aced1dfa28a833aa87b47a14d48aed4aee1bd2b32367dbfb5fcff96822b61087bb56d6522c003604a451eaa70bd6fa37476b3a3ff6698945b394900935f693f4fe19f908540d5b50f3ea96721a21b69a9abe0924131b5107501be51939d37fe221de4f374c5a07bac58262959337149cd302dfb4a23976eed3e840bbe6cdd5e7811b8ececcb73630968d09e2fbe00243ad0f1d93b0c24dd0af153ea63ddfbe1a0c4d10a93b7716c0e88965a970c60aa0555c9c57f0a2ebd70f8b371f6a08e1c3e0c604ae242549bbbfea797d056fa8183d63957d8816999197b8089a090742a8aed71a8bc91d580215d10b4fa7baca74fe34b4d774400a6af3c5ff1aaaf4a6b213eac5f04c10568f0f3c35a53793fb13525728ce4cd2d94ce9fa8995fd6c81bf0aa30dfce3b6298bd6a34b13f3e76a14186d72305fe36ec8bcc7688fc7f83fe8aa4f7233d8f0805a1f19957fb80f9ff4760670e0250a55798bdbbd3c20be0c9d5ea82df0af2516bee111e274c0d3de68efa5ffb1a50e0651e3a4a263e35330f90601d1508be89c4099313bc5b19f5e94788ed9c451add9a881f7e9311d9a05af51b0ebb9a8e5a156bfd7550a4e374d204e050b4a46634f90700140e022c570b1925e3e1c2cbe45f46deaba99d706eaa423d9b2eae184ef9fb4b0f8e1f8e87bb6cc29d144dbd2ca0c601b1e82ed5c664ffe292a3e782d31bd4bf53be044a1404650556d2e24b6f2151095ecf40c5298e4a6679b31511c0e3993869a913e934f0b16bd13d69b1b3c31268dbcbac448aba3b937fd3b53e368aebb28cfcfffc1ae63c430c3c5c74b8be548012f2accebe0c2c07ad4712479eb8c7371e8827d7d8fd6e7a620bd40a54fb1a2e2f5c6a1e4fc07c4f81c830e6aab925e3a875915d215897a36cb48f21fc27122b6f6bc4aab3fa0c74d6c1be245327486bb0fe702225672bf913ca9af4bff1a8245b4739ea699f4d62ab11c8717f6bafb2d726f1d6bd2d799e62f75debac66cea6cc6d406668a3d778a3ddbf8b4ccf8607385f746a803ceddb15387bfbcdfc0c7ce1f9246831898b5bbaee2524bcacd1b1c5b4893d44f8e9ac3e96adc99bcb9dbac7ad2bfed53ccd452263fd53ee309f1be5e5604e06d86452a89ee5c23feda2311bd3d20cebe8670c1ee91c85e30e99aabbba083b1f365425a6d81896c23c3ebb9d6e267b7b1feaeee4d5db0071668e499d29797c68535b77ffe13262ee2720051f7bb3912eb98876024c12fd4a56fd5fc6a7e62e95bbe51185e61cf075fa22a51a0acf71b08bb6adb22ec705e656345c4863087d8088f73f44c3bf332c810fb0c4a4b53f05c10d7a2451e9715b816b23774326baa4fbb88486dc286cea05c1934ee19afa88ef673fa8a5cfb99f4c7d7aadbf4b6ae5423b89104efebfec55287c0088230fe43062a6e47947f2cfaa66acdd6e58a1e760dc35134a806041b5336150753a876a7698a7b74e1168e57f49dbfa41d22c0d5b81ee3ef22769df66586fc1c3fca6b751806c0ef3f81f17548bd73ba876712dcb983d09181726606cfff98585a3b3a3ac5b70497c412904f45b1f0f830dddc1fbe8947dc37f69c4ad416c81fde6793281da6f690e3db5bf6f0ee3bfcf5418c9ebe4cf54b114bd573bce00f258795ff5d5646fbe65db0a70327c04ac7ba219afb5f471f469b51db731e295497fffc8a1a17a62b406f026d2d6f9bf88a4313feca03836138c3591706d705025f958ae2498d79c17a670b4d8e698f658a2049fded0f340a19d7a6867c582594abc4b4810e5392e6f536bfc6d32fd606393d51e3ae310f7785b58713f59d819704c26183273368e856eacfc489716f27e2e40e2048c8622b4101da87354711ea60ceae4247e431b1bb035f6a5380eb365bc51d76128a3736c397c971bc80236ef1ec2b0f0676d1c057061ff77d2fb7f312c615b804d7ddda6887f646b4ae16683e49d49a9fe57ca72baa4343c89d55b570ad17487741bb5a886d08085755098731e986ecd8056721098efaf76bb6a2647ad59187629993560396d10e882ee6f60014a387444adf3e4edf8264f1a216d9414936245adf9fd5f646c6f78542710593f9043ce31386a98314a2556ba7f36fb9ef7f01f557a47e4d3dbf42581503c2dcbe9b06fe1efc7f462d6bce6c7b06ede19ebbc8b4fa6d4a5f0e93b7736999da4c47735135f874addd36c42ca21c59d830f9e32613ae2a60d19327d46482ca2782834de0584667f4855fc77212a946a5a238ef2334891ba24362cdde83778eace2d4ef3af9e2bc9384ed611050beb7af9494cd4396a8505056523a3d95554afe316803888dc1b32a7d8f0613e89a2caddd180003d312377cb009013623a8e4df1d8c442a73dfa071753f4700326404ef4d5fc67a8aaa4bf8eee1834bf39f96131c5efd8049a715f566491696542bd0de1db173fe96e6a8b56f83a9bcb6a3028a599f4193588e002267f1d6dc957413678bd9d801b698b238b8c3a59450840a164a54919a4768b073227e1bc570d9f6c68a3dba24ca4d074962a9ec650aa0a121a3cfbf8caef945a4f0d773b498371e0edb9f4ed4a9ea524c3bc08325d4cdf21e5492bbc414e6b0f7cace6cb6c0b7678765bdb66ae85a6912a5fe649b433a268d3e73c5e3fff081e2c8bab9f5ed1ed8bd6b63701d48a6bfbbec98660501c2c280cc2e30ffcf4ecee29e4e1fc53dcbbd0a11654fd218b6ff42fb277196ff4d9b2519bddd74ebd0369f8104b13fb3514048df56ee990502b52f046fb68ea009675760665f07680749e030b1b18e95f39308649007260ed281ae0ed8828b87b08ae85e971c2c8eb78a75fe2f7cf350144f5b8ea4afa3802145a3e02f792ed4db17aaf926a9ccee2de3cbf07431d008e6ea5f93661aec51546dc7435cf0db42f6ee82f7d5363c37048edf35645a1f4d6fcde4d961bbef67dc1d7fb5b429b8bfa101168df11d21fc0700174ec9869cd2d3a84755bd36edae03f890c5b9605719eb937025c37fe8b789d793eb3d3c3ee0ce96af31a2cd805fc238b7f6486be8a4cecbb10f64b32c7654d0ff1cb819cd89f41ee8e9d7d87799fbd527ff87fd82b8b2dc2e2a527ede575f217f082e2951e913ea44b34ed00131cccf4f3193540fc4921e294f02e529d1ca50cfec491723ea7e1589368190e26bfa36e391c8904f16defd91af5549bc8c07f29578194a570a43ada0dafaf52988bc0c4f0e4d69feb98f1b804423fd0d28a087f746c7caad8947f85cd5907fc38177d049c445cf4fe8ab8740dfe03f030dfea82baf64e72cddc3d8017e71c644b0c14a12164c1b637f3a324877a324c2f4665b7a599637234f58a6c2ba75e71239a3a05fed1d0a3d275e6f34612533acba828d096f813a89e8ad37dddc6eb1f884a1529d8834c816c365d643ad9a2b64e61a24e2c2e00983ecff8f68280825d4af3732ca162db5c0477ba31b0487d2f3239a5455c3ac13031958712fba17bc7637db1052dccd62dc1eb8ae356fe28fa2fef94f89b1d7089dd717a9063f88c82fa663233644aa737c558dbe42af60f3a8f375d0073c663f730030c99fa196988fee542eb242a59e72e35e26202d6cf9ab4dbc492b72136b6816347f0a8e0fccffa4bc075f8846bfc8e402b6d1de39cc652a5b9b19e9419efd30dd6874d2895842d7c5ca3b70d645b4f7bdc628299fe4d3301315d171e0860672dc1acae042b63d090a1ce2dbe290c74e098636cda37e8cea36871bbc37620968a43a539031e7060ae054147da9383c323e4a042dfcca05d74033b6ac8522ecf556907de279e498cc0f62e00e8ebd9498d132fbb72d74a32c8f01aa311dd1eee6a9d57c45f736759e40ccd2b918199ebabc4614b03709c7eaf5b8d0ff80ee58228200a2dfe17ce4f3825866e0b7083732329f52e496f18b0251d08fcb067bd8160251bfab7907f7bf842fb4bbbf5fee01b10f0bec15fdb00c12ecc0f84638cdf0e9541c405f60b1380b610f7853f839dd79e7550fad9b778c1ee229b3af4ce596912e6d7aa5179ea3697a2cbed42f88d76018a8e0e65cd03c6ab1a4788e4435c78c3c0cf95e82b05532f9c28898b88ffa6e791342c17b2391d7e0795aef945e418a421c939fc44153677f6c8c5b12a75cd6a7005cf3607e8d3a6021041428c6dde2defc4bd2200e70243cd709e899c825f96b88166f4172fb8f62be913c35a2719e48c32d0cc4cdb46100d5187dc3849a15d6bbf79a75868997cc5ca3b74a5218730b9e5b6a65f1c8447e3657b9765f3f260f6defa89fb035678cb4e8005597bae3eef0e0501231c7abf0d4d8bc9acd56225c79700ba7f04a55e344c7ae99bf14c5fbf9339b706df844d824b891f96087eaa9648bd7e2374c1bd7031c5133d5e551b6b7ad4e08b9e1b09befe7774d8ecba606a7146dda2a05f810ebf2b19b1ef86c553ea5fba1005a527473a1287fbf566619d5520a6e683849af9b2e77c8ac10acc5ac0a4b3cb276025f48a837ed3079745288ded77b7450149d5af05b50228c81f21db22886e69436b46ac8caf2aa68fb54b5aea374c4c1a0f8723245e8ceaf0426dbf0b86494fd8aaa3745c05555fd6bb9679aeb6ba7875414fab8c063a04ce2d43d8dd0729bfe87d9c1c8db09ecc451008f592756375f4ed235e38ed5c576432c4c76af647cd2ca2265ab00287300bd68e93c891c01f3ef029b6ead192b67f94efe3a78d82f8f0c8d16b24ed9ccf264f59e0dadf7d5e6761b5e195b2f477b33e81ebc84c7e09f6db5798fe14f5b873bb341369dd44b8ae03e918358bf603a0265bbaef7fd3b11824de42830d344cf280527bb985c2bed2ca62dc345c24fb0dc9fff215b5ed8fc28099bb69a09203ed6fc17a1430f0b36d69f2957bb23edbd9e561b320a3923cde684a77184753deef9a2d136f396cf116ff8fac9d9eaeffb800a4206a61d0c9c1e34f9c71926d7c0101b0f28c20de5cf2ebcec9527f702c6c2043cd1d58d8ae3a097e116d09b5ef3e8a090b9d9d1db394226f0c84441207d8ea87c497658ff73e272a6505a256ecc3943f376b1554a2dcb32d953f9cde42440a97fa41997d1af00ac285cabf2a4b8d12d00c16b5c55fefafdcf16518fe5ac18debcc7054a0079563052fc48a1b95f53134c22c839f2b2c2743b9d0d411c14f592924641ca9f69d6886032fbb839db8e52d72afaa3abdca90402ff56c59e777bfe5dfb560d64e9322fd67f402d9646cbbb837b67cf784edddc42b5b506f5355ba88dea856402bafb523220302273b507a770290a14fc4a88907e5685842476021fe4673d02fc8acd9885b8a8b33d4d582efa92e1cdef0ecbf374ab07b30f2b0744330471722ee0e80fd56f08ba81e835b853c0b5cbd9d99942b2f08dc4f149a8e2f058cba040817792d252cd1977a495d65aebc9e86922f15491c2212718fcfddb1b8eec61a247840609addef55d371c0c4a1b894c21bd995f07bc2d06382b438c1022cc2560039a854c8840d44f1f0af99a7fb308f4b44c93cd1efbbe9d4ceb629ccfbb8b2e7ddbe19384b089aa4abb833da707201fb9a460bd1bc1f3110b32e68016f970419fc275878c0e4207df4e53563072d7954101305ddc9b1c523463788f5c439875a6f64952d45dff476f42881a710c2416b93d4ce0e91d217af209e8ad8934f889a90ebcf143047f093ed7378ccef6c2fcb8c92230ed49b6d210d3d5fff568e78e12b64f3c3f08017f3af474a0a934e7bfd454d427551a6eec394cd9c432cfc37bc642bbc197b0c46d92411f49d19848c0d3adb67e1f1ed6a7c83ead5b256a14aaad29cbf203d1c1786d8288eddac2d29397576be467268f7b2ee797c1988107b4db14d611e8307afe9947628678e8b89e615e0699f5326fb729bf38b21920a2fd09642fd7e3c88363eb50088dccfcc2b627359d27c497ec36a1af0be643b45ddcf0bc0b7377ff176bc1b63d5cb972ac10dcc6e718b08aa4a4d4d7e4846e81527c17505e8bd6c778f07e496616e450576951ce1ecf3377f7a729d060a53b0f1aaed9871849161a41f14b655f32212a004ac23a33de768140bf781be766da8d710da9379b3bf3b53c8f3d292c7a18696a2c68eb0579980b8105c783e93f76abb116e941a5ec97ddae5a7a5b3ba88548b438dba1cb18499f9de63c75388b368698b7130c38fd9eb48d427651f41cd9efeb4aeb10eb7ff433f144bf05518446de25ef050f8dd1257e991e9c971ef75e8fcc3979de7b76b8dce66674608c40dbe96a624acded9818591c2c85a5ed27a31b22201624ba39d072a7b7c30a8bfb5dd6a5f90452ba7e12df21c6a36fe98a59065f5baf2e7c9b9010781cf32d55262dc69d30a10bed67fa4219afd2b78b3357071c8ac73dd6c20f71603827875149291a8a37cfc0e755fc8b0caefe106ac2b3bb3b63e785c04d8e49458504597005d6d7a608b9a3a0f2c1fa992e4927b0d4976bedc4bcdbbdd084f4b345ae83a3a4375f16e9d59f53824726a9f9415b00d1b7a1d57fa36d250354cfb7265cf28a15294536be3facf349d6a0ef7056fe129ba0787b1d67391209e4d5f8e801518da924ccc2a362e21b2ae62f33c1e837e5c4cb4663c5d4dafd215eba948702559deefea24e9525864c7048dd65f19e32ff66b00dd3c140f21e1ae9d89d4780244a2bfd69f95e0f9b6204af3f6a5da922c33a05cc12ab8ef1d7e7ea2c58e4c39828a4678294176af5b09e07050bdca08fdc1cdf7b88d5d73f6551cff3b2c85b7992eaa09c7c8c7674e21d45c608c4523f3c3ab70a7de810b1526aace54c37ea2957a0b2de29ea0c9367f73e0b60c5ff808db3bfeb0fdf8cd66542e20459df79cf4ee7e69c6f6a90611a08fa9c16e13ba2ce6ac2a41aca21e8520f492f2a85fee937f4b728d6d7134c0936aa218f4a355bcd20068df1ff43164513f88aad0d618d47c032b9348411b248fc5091fbc9f05d0220d4a3bf8b15beb3c5ed883b979f84a1430ad1791402264d02bcccb572d9be8d54bbbbbd3e9f5ed12245ddea5970557ac65e2f83d317f6cdce28fd00358421bf385bfe024a665019fedf49a237d4e02ef2a4a2beb843d52795c63f043273881b112a6378b40c04ae4ea1995468bad65782873fdaee44786de88f6a6f95b0224f16fa22c25262bf5cbaa3d209f82b345086ca533657d50b5f37e76a9312fafa430c38a1f56062452f2c17b4058c0ee136cbf8300ea48d07895d07821d8e0b8b2b4ef5a28bc831b0e8e316586f15c7a47f65ce12c5a07e2d5a209f44b2aaac08cea68dc548bfb64f6d691a01ccf26b9de089b87645cbe427244b38724682365d4e16cfa5adeda30cf4105dd9d5edb7d0b3d1200019844c996a30837f7eaacee11af386589cde4f6868d8ab73afd99f391bbbdc7433a2aed1f2319d5cd9c16df17f2784d435632f68218b7d97707fac627f1f29f3ac3f8620c90e95ab1283e1642c92f939419b681cfbf1bf7461ee049fba7506a2d04ab4103e11b8bd42a5e51f4c307491cf6161beb8ce9e093dd73d40a193b6f8ad8b824c907489d12960d79bd78fe4dab8dc07a98f031ec810fa1731b783eb5284b9ed31f075db91f25b251d3980c21007cd9264e25b22ca94ae06e41b92028c2ce2c606626c70b30702ae19007074655d91692f7149b5241fbb4deb0a1290e73d0f6ac6e7800a4e09c481b04636753f67b9156fb5420686fed08cb4b9571115777196cf8e62799ff9123bcf1ad5683e2f64b4b698513d9c78f07132f59d76f9f6317dcad20a9024b7968392d1afc1bbb06f14224006c3d3ea8c22821aa4a8651cefb0ee70719f40f5ff3c2e57443a2a89a295e5a7c5317b8857d1491cba5b6dda2c1e4ee2fe9a65edf978c03f3d808068d0c23f4197d6c4cd459f4c4e3c15feceb329e9f269892ec61236171dad6f016bdbd862e29f5b319effb6ff81c132fb79e8c7a4b3cb065733ceb0a6549c5812907e7c864e8b8d953d962749622de947ab49970b6091b9aa7bab865d74b651db6e313dff9498c2e489c4701c002905d82dc52ccd7608e80c365423831e0d46f5c127373dd6af3404981b7c8effcf8a662b6b56282222708dbcc1475a7a929e86f4628b2de309df535f1292f9a3ea089fa0107317f652d39174f3bbb3f3c6b6c1d6f47aca5c74326f9d2d78873878f3af7a24adfdae26dc9c79ff8659bbc90500d724e6bb6e3b759c462b596ba058c824d4cab84e528ae224783394fc414d23470f1dc113933555463bc075ef73eb4f80a59a63ed1701f535d859fe336c7e7443a0429a1db013e2cbe2e13f95db80b759ecc1a913ff1051e92bd66590157bf0cc40273604e8d42208b25bcdef8797b6b8171b3acfe633863c56b3a56b1cb6671b2b812b31e0493ee8ca7f0336a97ba8a3ac94e5a86e33a719b3d7e282e7aa517aed6bbe05e138a031115e41886fe0934304ec3370d552a57df794958849dc1323b68b4cc2be787c54f95fb7fde24fef4e877a004da8abdccdad4c39855a9dbff17b2af934d0f8bd907de16d9206125f3593cda4b2c7b406b836025d8d2db9a7404c1bbc64edc2e5e1c0ce3170ebf4ce075f6aae3a67b1ccac0ead16138f2a1f1ab6ce7b896dee163a43cf93fcac08aa5bafc2a21d6277d65c23dcc3b3562ccb5e6ca7ed69182bd6f374f51d7fed0206944cbc1f5f0abc250fc92e5e1c4536c6ad329815476b4ebc9ef90eec39d7b0b75b5f10e1032854c02bd7ff4db215c6813c8808fa9d320dbbded500deb7d1df642d7d106cad133822c3a3355abaf2603b0c5a6b35d18cdd196a4b71136802bc144d3cac799dee95babac934fb82431e68e46134317d781e95a5aa42256c2a52627e2cbfbd6754c0ac05f5b6d1cff06421841d7da3f904c7ad51de986ea0db66bb6ca2844d9b4f70de4bf20db1c7a75d5d2f379fde080b143cfdd318a297d590f06c2000fa7eb1914f7df80fb4682486c32e097d1363f5907f4236a92cf01d71cc2f11f4161cc2e1d3c657b513469c8a028002278675f852cc1c77e87e8160ed0e1c838996b0c63d611cb47b7e8a8d7729c1854ae0dd9326c5983c387502f5e284517af23f4d7f6e105e02d950b5105537af26fa09f5632dbeaf509f53421ad9bd1ac51c526519be76e57a9d3be45920669a1f0e20c2a153320a6b237f27b914f2b1349694caa8b11bf3dd9eb6275810635bd1ca5ab3bb10890ad18420922c7b9d90eb81e72396dda334a7d24f8a4929021194ae34bd77b1bb22d38266a3dcf0c29712453695f9b9c0e55aed2aed4cb5d8b4aab34af87c186661a434cdabd1601c5b0cbb5dd3afd2b9fb5fefda681ba4e1b1b40a719b870edd99b38f92720ad4f682fc15ffd5103b67978cd9b5306bdad9a18462207b191bdbe038cfb501dab5f8f71cff621785f6093a8018424d4f3eae24a36645cc89c012ec92b2aedc7fd2d48a8967f43cb405ba947bc4cac8a1b68513de44a841d5654a06933d52611e9d1ecba72d839baae372d333572f1dc464643ed68527836739fa8cabf48014877241819af0c110219560ed48f2b4ac03635437fe669e3a830bfbd1cf18230b573fe18cbb561fd08f26eb0f6dd56acbffd55b78d13be880d98e9390717248330b5de9c666e1ba4024347b6061960223ea40e5037865d851934e47102f059c2b6e8175ff3691ee358d515fd2f1808b9992fb44b0880a12c54ae79faf60bdbea85b439a244b94f435c275347126e08a8c65421c28700bd3b48d2b5a820b1f0fc437e5441959c81ba11688e7def725c5a7d69b62a8715db1af6fe84821e54179a503aaf1ad327d7a32483d23973d8c37514fcdb46ad6e4568fe17353ccc9b2759f9f47b1c911d22dd6babb0ad99c069ef30646a9696401f1a41d1dcd07ef339965f0ff49e6993e744072771d4e62a628c226e679830fc41875252d523d7e3467ac3108539eb0452959744176d3a3c9a04f713abb73b388f81c82a0e4e93ada73c3069edbe5d3e6655ee5470d4b82c3c6d9b57a0234a9ef14f64c0ac6f53f71e1b7b39972021d2d91c9eb7812f1d8f3b27851f491a8cd3fc269f9a8f08f681256f458fa8aeac1609637dcf87cb2aa7d8a443a5f80e7f702228dcb4370ad7883e7d8edd0d4274d1f6a057d89902acf7646a3f2cf5e9c7cd89616271184e7c1e84ab3694544fe92ba829ce6c683165e0d11187a0875455d02560081ad998c6599a51c4cf147fa4ee7c813367b1f27fd252a028c63542cad47a8326d2d195c10d0b80d81b69cd130df96558091516d96db72f8b62aec598d48ee52b9692ca531bf53c762af9fea31c06cbc79ea58e6108100dca17c51ed779068b1a32a9a266e74064be1906f701ce1a5b27729b7fb12f9f9c9c6fcfa0df22035e03ccdef92b9523b013af7812229f8f95dc6035dae3ffcf179f7b7af03587a18eb805fbc0974b23dcfdc9fff2bc0b82e66277006e52aa329f5831346e3beeef999b016e0e3068249dc1fe1295e105772e022f288afac42b10c834e4de09ab533ff8207218421152566a9de6079101087ec0daaf92974435025841c0e6aa6edfe7266defb55ad98da996691ce99c8141cffbbf75eea625c102c507508e7a121d5af72788dcdfd15ef5168b96a699acae20f35c703c5bf2f94dd71729415ae2d6522a974bfe0bf627e18c16fc7b4644989f440b56dc5bade4e1b7944c1e2c77e3d5a8a1e4c7b3636d92e3d47b440dfc141df45a339f6b644f89baace9bdc440fe871c38a881e4f9687252f6015339132525ff280f942e46d6bff165086896d6f867f2bfec6b4345892f486485d59c6b6154c7f43fd1e7927cdc79fd5df8527b5900fd9bb2463b296703f58baede3a1c53ede56213751f3a52501b65f252d759f986d3fd063f2cb8cc6f11181a34e8fec1ed715a2bd71914cd7790420cf860fbb5c2b63d7851b2507b7372198979af885ecc1afad6311870d962a91c5337c25eb1f90f1ac6b10bcfab0b5aa86d04600867fbe2dead848d3e853ad99c38d4cb974de1fdf8914526fd239263c4b371f6abbc5f52dc896a168d868fa87620874694b979f13d2ab30e86016a13226e9ad59161bb384a4017192e3912953d8d96e357874bfe3a7bf44add42edbc51731806a2a9ca89b1e3cecef0f319f14c925c607c51f8e792a2b182acd546d960dfae29d282e713926a0c405fc9808be94e8693e60ca19a42602591537ec5c98fe58eaf8b24dc202b105bdaac7c5acaa22418c0afac388d1bb033b9b36e7c70269d90d862328963c4dde4c78a9be0992e9bc334f99e4df106c6850336b88bde4f7f677ed97e8b9126f3ceb4a35cac919313a51ac1f85f18c6bb4e20544349526de110818130f5e74a5584558fc1fa3de55dca49a20866fc14ec07e6307d0e6b476631ae866d24ffbc56c940d68717a9aafa9190963f9c5440f7b60f26c7fd94db80067420a64a692758a64828c7ed8137384c1fdce06e6bac694b48a8bf898d421a7b47642b5bbf56a41e9215d9eecc97ca6cd90bb18ecd464de84706ab3f783f981f4f4747bf3a8e421b06ecd3170f133aca67a0351f00fd59dec6b4f03edde05e012d9818c16d583659ef4bf44c9c06b0438bed196b3cd5373b9c30f967e85566a6b86ce9de23ea3641e113aadba534c0fb9934cc850c9249d7c5705fde7bd76f57fc7b589fdc4d13d6a7b5542cfe0d1d776bc2e58c1f3e2e32ffa96c5cb437e9836b90d62da284875706ff1d4be98bab739c95ae77e56a9d04df68e36b0d04268b3eeecfd8af04987ff7c14873c3992b0b78e887a5e051c436596cad862eff59beee729b55e1a9bd425c7184e12f120669addff95b4e98a1f70b61b260a497c57ea0d329b795c1fd4bee9a55a400624d364a3395e09ac47fbca8942f136536d2c2127f8ffe5cfdd08e80e952eb4e75affe0206ff51e6515082d079a7c823ef59fcc473a863686aea85a636d42415acd24ccf69c7055b4af8a9eb049e7d279fb195cd459da88ecfce5671781556bfc1f01e44012c455208be265a7b8b580a1bb6fa152dc6c688289890c31adeed1d533a233e8faf3255db84bea8623f316d770bf966fc3499892fbc97e6876e93afbba3ec23e3212fc7eb46b9a938b4f3a4e9f840dcd4550f6783722c75bca1fe915a0ea9b00252aea385ae6f56f096981618e583fe62f843ba0b668702dd7bc0420ee0fdcb6739507ab7f7f9ad397e969e21b607c14e64bc82b5ba67e60d385379e7caacbd3f15b156b703e5fa42f50b1d79f4573804f11e1f0d2a03c6b8ba0d1aaf622de97ec3ada31346d9a48ca34cf0f0544fa6d606166aa347c528a7b0a466fb34c93e97d98591d4c1bbdc0d9db5df345acda0af5184f0fdec8078f876c1cdc5a81fc5bc182adb5bce7cf343394de1a4edb96ffe3be86929d750f3ddb2849917bcd4d00b2dcb30692d5d7d82c22bc3de5b1d12bc90819e5e936040908544b230e61cd04befc11150742a8662bea60f0e1ca5a3e1848632a859879b003d86bf2fb90dcb936955bc523e429cb8fef035e4c432e0627ef86794fbfc58f4dbc85034d6184cbf135a97cb9bbe1149970d651ff7b873254b30aa081021d8854828981076fe1e37fa9e5452b472efbb8732559fdf0e8c924b997f4e6f0cbbf27ff6884fa19ebf7a15cd8b8f00a1a967fad7bd5d89d23d52d61597686a616f67c52c8db1fbb27c65705dce5dcc9a8b4e023910a0d2ded3f9f638200ca8a9185bbf7965be869a948cd3f91d9ff3fccfc2e22e38188d77bf90d9a39b2301f0196f773f40c38e55d80061b0b9216694389fe2cf35c000d07cd3ad31f4356e8a26808446dbe6c34720345edb9ee2277d03b6d6eff839b781a9ca8e425b1a63151c2b253883e0f4e1ca86cd049a343d1ae564b188ded3c7eab83211a263c424581f4cefccfd1f53cab95b95387aed08f87a9b79092eeb122cc203f56a06f47cd14b6820f9a6c6d046953ca5bb80891834ab91811614c2529f4eac89e4d1ebec072e0eff0984812503a02f9454102b892aec46f92f8b03e77d87428ac2f3a27f681232737c8fba70ee675fc19497e24decb0a4a4d9a18dfc99d0234d6cb4968feb4acc1b46beb7852613720276d7091feb868e7eec5e4c4b45f4c16826b099674dabf89325d32ee3447c5b8b201a6aec108654d0e992930796e9fe0633a39e04d6945537214a3946cdb2d6f8d5ae9ca492ab62f3876bb26bfcb6e85c4b789e44cde461a043a9588ed9566c253b5f6170c9fc3bb5c9b9d2c7c80651233cba9b4fa28b0171b95f8019fb9206d86ac9e65bd414165e7008aab38d2f44dc244f29a562776a4ebe37238470145983806f0ab9ce51c821dee96c006fc2becc8852e2ea1e70377603a76f0074b6c80056505e7d9392c75ea3da873660e9d12f8312651571f15538fe59797302812a26b9f54d9a5574203584eda5dc657502ad73f4a8feae58415c5354afb686185268da2f032252eba1dbad281610636447c7c84d9ff85520ef489267345dc27e97d716d67ec48fc0e3167c1b417a87cdb4805b43ba76d5e66e191b2cd01e5ff9e429326e33c1a16594bff371baf3dad483c77d1cf52c7c414a2fc3722a44e27183d44a2fd1ac1874d9eefc1614157fc6902a7a0e1bfdc7fabef86ca19a2a48dbd8151d05cd4c735b26716aa03c71178d73cb971c3647743275c89aad54aecad2169cc00d06fac4ca95701df68f01c984e15a2c0dbed6746a6d93153db128c03400bd1e33c711a9a24e8bb6c58022284b6f52efb6c73a9871b19722d2ec8cd3dc6b320c0a413f85e97497035875b94993cd485b4b2c9541bc56d3a1378838770db2d99323a591933284ed1e1baaec93762340baa0ae8d59ebbb79886508d974ff51762b8a3ecfbaf295a606886c1b3fc5c2fc068e7403d1236b54d8d9a1d3be057c6a742d8de45f18adbe495a9b45258e19ff1465c2648f55e1c008a2c6f0a47d3f671ec5959fbb4c6ccd0e93661f3ebd79a0f5f8ab1aae613833886f4d97339ce36f1bd0c8e0c972e1fa0e09c3b784b554a7cfd49416a2ccf0bb79e349adbc875bb14197b7b5250b8c7b106e98692be76a093c09a920aca7bdf297809efd2836e8c12de171e31f7eff7c7a74692709c905681307403edfd50016023b50d850d38c2bf8c43576664269bbe75a04d1e27f81c38099cbf66b91c723d22fb8d9a4fb6adca6589fea30b9e9fa3246e5f7a5d340db4148d77b3fe87a8c708a1ab7c5c0adcd56b947764beb0f19fe10b8e07a01b010cad5bb7ca768c4e9b79d309ed48bde1014c08b755645f076e1ed2a12779b282b43c192b4dc1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
