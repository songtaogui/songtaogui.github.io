<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f8e71c7197425d87b25f5107e5856de2b7ab5d188195a0522f2225e4dc9926c3812070139d9de3127db915e1dc8e6fbbf513d0302df1f5b646068f108b6370db0342a9dc334110f62d782e40aadbca6b016879b58e72fbf85aa81aa540ed785eccae6f3f67d3406d4ffa7feabd70b37826c635ecf700d3d1cbffb69e78841d55e35bd3102b97a6f6a8f07eb2b3df90dd09b01f02ca92f13227ea28ac65c6186470c15de6ebe0116c9bad13f19e2546ee3b164830084075b588e148b48ee133055a15b9f87a3a8ba255d77759b2ee52604b7cc2703226858148430a351ac4ae1efd65167b40f4c6c1b2fc6b480735b9af59c4edc864c070afc1068cf1b13ddfaf505f903043f0fd662de5d19d62d1208a3270a9c412c4e5e567151dea0dabf8c4c5e2bc337c12b6f5808fa25a6a398a93601faadf3ab47e109a2a3f05e916be43134679a3426ce06abca849ba1c2b054018a8384ceac01bcf49d098807c2dd1425b2028cf623677f0237872da43fc442ddca4925e61b7bebf98efc62fe9346495ffd52cfbfb70bb6a8d5147be73234eb5d2c2011990f2a81da85306e1404b85a09907574ed81f1051780945eff85c45ff6dd1ff4e7cf9f6fa5ca60f9964100739b14c9a8a18f8e985092c9b987ee129e6a2b180b9cb614492a761a64a862a9d08f520f7cbd960f33d7372627f8e6da764936fb9b946a30ce2eb00ec50e77ae3005e01b4994d712795ae92b75724d25ea130ba2d18523965b9a914eef2cc62e81cd5c05aef0884cfeed2f6984f0261067121244d19361afe098ec772a9c358162cfaef0716e278a97e2889167545272984a319ba79b7b30dfaf63b18800eb616d17690f0fc2a2a507ee8eae0cbf4ac3c11968d53bd64cb106ae8711496e9b067fc7decd11ff681f527017b80cb43a9e6cbfcffac415cc3953d227a23cac13a56550a1c3be882f5acf32376f645d2049c966ee4eeadf570745a00b6cbb288f122fa89c863e0d686b09170439f6dd5da0bb7ad7aed3c06a9459bbb15790dd7fc738bbd610155664947a5267b0bb2ac4305609d1b9588e71bdc5598aa3f7a798f5816e25569322378f7bfc0672a2ec153b5307d70ecf198423ddc3fe0d3261ed5c3f0083b19f51020c0b246f7d9d0d70ba4901dda93b420f33e5f47f85ca0aa59925884b490e967d4ac8cb0857eaf3fc9662d27442a83eb26f0cab4196892a3f15e88fb2f1cd93099d1f618cfe5746a1428bb7a90671fa2755056bf4fa0b216a08b33e9b4def5a26c2e58af73fd5ad78bafc293f2627708625fde1df1a6e0a79a282042b5ca81cf70fb6220a926479339646a4fde9f8eb52f17c12ef51bf9f9c5847cff51744fbef49d82937cf95ac94d6137c85847971b6613a7a9f9ad6286ebfa4fce736210b42452cd0ae4df7a0609975e266ae484d52101eb0201ff115f22ae28e78082c3889e9db24d99b93cca88f44aca48d6049ed2e49fd8b13df71e7343dcc1de507407d03712d6b904ac21fe9bce419fcea7a2df5d8bf7b17a149be8a7c5c30756cb01cf63b4b56d6dbe2a7541811ad1ce6e77475f4e2b595aec6fd35feda345abe27e869a3ac184441b2dcd758ce3ce6126af48dbc567d807202682565b2f2f29b13a93168c9d6bfd28094de3785a63cede6d6743903a7301c0d9222778a376c8e7304a2773575def9b8e6e3f791b4ca5b10252d57071d6a057919acc0834dc26c1b5a49aed2693f53c330ff97e3678bcda28aae733f63abe9b7c326dfb3861ab41722272146a8614f44e8f0293fbe7e8ab22c7e97e5ed81c622ad423bb1f9eda9aabc2fbb59a61b722fb3aefed749226152ad0dcf32e5381becde577bb871ddb759ccf356dffd9f20ed6189bba0f8849f2e3bac18cc31f5004476c9b5590f18a9efbebdee9754518e3f72f6e1bd926ea50fabf337c8426a424fa1a8f047a7025a3c2d5956d953e126fcc706113e82db82bf84f75382dc24f9e48908f95a7c6933451cf92a5a8968cadc3839d926a6ca8d4ab73a967fba1c115ba0c6f90f3585b02b6e2f583d00b6a675343a39143a8d613364c95d26e4bcdd11e2cc873a3165ef59af07f8938f5229bfcd89ca800962e4ba5d9944fa746e8b9905030b4f984175564351da48116a25df3433194f3b639cdc304510cccab38d0a60cc4670ab2e62f38685f28208320235ae76905eaef148b9023d797d78b4e49286fdf14501858d28acc0a4f6b46b9f9dd0a0992c43cb879a33c6a14b91ad71dc37f7012d8d657cf0ced6f818ab9a7340dc149a1b86eab9b9a30151c4c1a6dcf216f636b65431f75e385be702146da59ffce4128a3ed4e809279cf738e4f94f88439e66f8d556e5acf78e576aec83fdc6a56d6548a1e4353fa8dedcb5c0dd254986145ecff69c46b21cb5f50394da12b42f9b4edef4cabe96bec014bef0e4d9c57893cf4529289fbba5860d17edbd7362f481b7d0fbb502591c1b1922d0a0ff6eef2d3aa400d2e85634931a432e14dfc29f6f105678aee76b208bf60c1194484bb42b09c1c0860435baeac4bfd627921fb25a2d700e1a10893053a0ff5b6ce8ea0dbe632b1ec68c824362cdd4a1be19e6b762fabda87ac70c59fb58650c8c1a82b9692693510cb8a70a48ec928f9edd181665d197c12d45865fbc5321c19e5b2e47d6d4f614e453a1c5c18ed642292a740018f01602aa524d01db6215f8f935d79cd0ee14a1cc4715e7e3468e5ee184f5eb1137bd4871bcdf2a8b830d6f756c19bc05b08e8290cefea4df1d99ed1e8c4112a65c83631c5c524d83183ae650e26be47dc9dd979dddd180544e01ad4b7fd31e202b7dab4555b35c999c58dabc2ca3cc2e7ab2a91aeddc0c93198dbb673b2c73d2ad2b3448c52f83c52adb39735cc1ea2aaffbe15a04d4ee5f2bf8781ab818937bf5a2f877ac2d2efbbf9a186d9171f0acaef0e2830633cc36f4cb7844398f7c97af92f55183ae4a0bdda3243c4801f0a45589e007405ae68d6fc0984562be6c74640fb5bd776fcb131b0ab86eed3bbb86e03f866686c79a2c7768c10dc3475875a8bd35110bc937b8a9021c41515b6ac7346babee9da4353f0e854758fa3f45df58d79fb194bc9bc7d94502bffdd2765e0989cfcfbbb8e97bae9d232a033ba0aab5a78541fba0748e82c0b7994bb51afba79b4686b223526ed6fdb43dcc0722a653db21b64912e2f5e8a1f6be61ca59aaefee5187efa385d9317883fd2c7f51c2cd53e43d7a0d0c347f2390984cf6f44d1797748af4de532628abcd78bcbed222afd449d7ee950b59612042ba3a0b3381ff926e79878d9f961c3cad5aab5461d19bf6a80f0126f3d43c10cfcf70a30b1ae405eed7eafbfb6b68157758e825e84d7cb378f8e966e189d71f1a3ce4dace661f36f3eb28468c41a07af400235b9da35901c49d54d881825e4aeb92e069f885fc0a8d8847be44f2caf737e253b179c8cbc02fce885a2ffca4c51860980d174c3893a63d1d938ce01e1a12e7ec5f25c54e702156e90ac5b17f7585bb40b5d2808041c6699ffae8e52c05d60f5845539fcacea3d378fdde13bc79dbaf6bf2006dfeb2829d2f6aeb76de0f81133802d1df497b7e06ea04c7fa1bd99060a5538ffd3215e58499f5135da41d56eb052f6ed54361f433d462f9ba96c9d70f77aebd4c1a66d1957d6eabf5a9e31e4009d8887c6e9b83c0dd883e8fa60ae684e0c1bcd9c9ed2552d51082a5ee90eebe6d0662bceea4f3945a7cea343f21d6c1fd8fc45bfcab4c2d6b085bd1a658c4a91424268fa892f6aca3d19b29d2446b46d08967180ad493291566b9b2ee974975b04cef9ff610f837b38fa39d72b81056e9ebab63c28478b5980d24ee6a2b238045dd25a7067d70f9bee91bf9969d18dc4e92a77958ee965f50aebb950551fee44c646a06afad782e8c6efcf53190249828e4930e2aae2b0201ef95287132ff896fba432e169889eecd4b60aaa2dc2a41ceefae156314e6653412a6b9a96075e4cf0979abd277242805a9f7957f4c5e7482230aa92471c39e471df48a4f3523edb533c90debe6702845ae9d6cd477cbef39c56a4676d7e85cfbd9e17eb0a46c235e8905154f3b4c4a47af6387695d906d955464a17d9b671e13536313c305783e88c3fd330a91c1b23241643f9a324dd24c7363595f9fa25129c78204dbd50fa3441cde33c0303ae6733e1d55a9f2d3b9eaf210b5557b0603886f929a75e8eabf47619475be148536ed483a3bf33e5626da52d51bbd1ce9cc58a0ae89b33de4fc0731113d4307df29597a0a6e1ae2f15a33774c3f7a31f62b300e9f0786afcfb5edccf82801b06a61de26ff04e1152754e427f6196b220337f0f4ec2a9a68f47cbb59ed37a9e883276c67257aa3c5551b8b9182b84f6cabcb8f6221e81152c12ccf6e6f3b55d1dd0e9695ec8c421a6e90b727642c25b14e7ad125ef58c22a8ec17bd5b76149c1c21e9e2872b09a92210413dd7011083603f2910334a313c15e24ba7815b93c73561eb40123629e15c4cb71ee63a4c34ec2ef8528c9808b2cc4f07dbbacd34904686a60b535e3c96060a51193be4da069fc406dc20751ddfc8d61949b91409ab2a1a89091e2470e180193028200d0320702d4c13fc1cfb6308d10d8ebcfba46ac49e069746512c8e00c23ce9c12445e6bde7bf628842d9ee711b37c1c2c9f518fb7816319465e394990d53b769ae9273241861a0fb057a5f6154e155ceed9c1b18afe58dd167bc6fb0438461dee78361892acff32f6e85bcada80e20d96298e8f2be238ab8c65e5b2aa49691f038b29f09cca007a3045b3ab44fee6204b9bf0132a49bac62cec7163af189fbee7f8a07822898924949cef74cdc9c884065aca9bd685e6d80154f1755c84d6c980e71cd0eb42486b2337475050aa3bae3ff5e154b64b6df4798596b50062c02c0a3b2da39f63a48b6b159d7c0be2ec0b41d7c7fda9e6defe4329c95314beb9fe41273d2a38901b3c73f6761b94c6247caba2f8a47fd1a1f14bf9600f262621ba1a559c5c9e4bff15cbd013b09cad83dc946720d4540a141280ab51061e7acb087a9547a43573be0542339ee3d820fb9c7fbe6609a0c065ed1f6e7b79d7f315006a5c4b9dc56d4c031c9997a92dc5b1841ac51fc836764abf0d0dcbccb529e23feb235de59d6516ac7c914c2d2939b10169f65c85ccebc09556f2f227ddf0316831a7e6766780ba42238f461170682ec01a32f368113ade7f1381bd23e00b76e85ad4c7efdc5cc32be6e3328318bd8f733976de6e405340ca5f3211de0cc893cd4491082dcbee5df87ba43dcf001d059ee0d8f36cb7c8e75c73833b16ad86c6866393c14ccfeedbb99abfd7ec9bb5e03e21909cc50655e28bf2a754ad13a7dd4d99811405e981064b7a6388a1e3b126bb3100acd08ebf9cab94ec1e352d34d98430b0f51d7dd375bfe0ba01aa9fb652a87b8c90fb7315e83e069c2315809b10e76fdaa0193b627e6642c61b8df809a1b0dea433bc623deb645c925d26cd7b63d9f18642974e5a98108fff4d275a5e8077d9e42991cd1e9cd565eb9cfb53de0ede75f9d8b54c157a5ae538c610d0c6427592bfd491c871845dfa91949b14fb217d905b99b136a5da2452fb378eadd8ead1cc33758fe3119dab5812c022ce4178cacb7460ad5b2c2c93b81396bfd1ba2ecf516315f7db90d6cd895ccd775a4e37db00d7d938366227533ed376b8bd2704eaf0f43f99d03bd2d4bf018f408dc3cfd15e81eae74fd1c5e1df93787478e3197e27bb5d89996a8590cc419374106f97777c02a187ba0b72b74f76854293ab8257ffce1864148bf6292e23f6971db9a1694824e2177fbf25812420b33d5de048275bd8a383885dc17530acbf0c054c12e56c33138a6c70ebb0d6e20b183672ce4dd801602bba4473a72da48fcc67ddb489d07cfead8b628ba03c8dfc4b1b972388f9b3567ec7dfece745c7734b98b8264802126fe608d2746580f94a04ae983acc1a899301daf9a252c73f259c7b6d83b2b3d4e757b1ef32c584b66a197ade6ea3911c2c531a425728c94b346d4606bdae43663b9d5539ede011bc2122529512dd5ff4af789bbfab48aa5d43806a36d19549979b247247675432d1d1e0b047d91806b190c3019ec07e3c6450693533a557ba6c7883b9495fee8fd00630bb5086565c37cba95de4a3227f64c4eebe7e0d9a4ca4aa4ce98f21e3cbca8028f8a014780774ff60aec24a353c714e861b03ea3b94ae35a3e97754948c7d919a601c9c9a45aaa82f87943d8eb190386344727da91b84a7c5859b18bf741a7cddf82844368a09c7eaf7c5ff5b3c8fa9c191e222d7f3a95cf885dd0ee5e674374b3c691a90a0deec33216cb64bc1b961184b4dc531fef55e58c89ff577a87ae62f797059fdeba77d8e4cc4a4f556c911693d2668df0f965fbe36989bee63882fe19c7771bfcfc7b3d57bc6f7337fd24059381ad9267992a9d46e1c417a11c035afa095c356e2f104c25ed0cee1a2fec76cbfad094fa6533d22bb1c386faad2bd3e0c66b5e93714b007b6969249f022b7c0716660d2b2a71178799b732eaaddae6dc4bfa99b13f1a2100c1e32637ccf0a3e4cbf012b7d635c001442efaa53471d9b97f0d0a15e39b4db40b10ae0c7c45264d89c292a7e5b0c77e3d99d6bda25d66a7c2165c6a14132e94aa74b089f1f85681365636cf4e9e23763a145ff1ba8e125b2aab0af88ad6006a8a42980c8d27156a4dd390afa1e14347eeaf65bd2ddc9edb7e575c99e672712aa343adc600101ba8d87072c416949448f15d07b328f3efecf9598ed0e9480e44d9b5e98348864b75e97a514640ef086de5cb83177f2557b579ef2409ef3aaec22780d1f989f14ec9ade8831809de439cb92feff50e52fa61bd00718697d7890dfe37edf2d066f9332ecdbda7391092d45cb6a378c4919966b219ba6b1572afcd7b15b79ffa8656a3f76fc381da7c1fa727be34c4359277544815434e5894fbe43aacb0b39227fe29ab5f2d9e4feadc601a326091f80f3c666cf6e69432249829d23ae1c4ef6a858b7d2e853dc694d051b05c1cfea7d4b8c0924064bbf21f4a1a43e445345064594028cf932c430fe1b0bff344ba88a1336ded88ad7cf27a9589688e98c82d42f9af8fb71a7fa9ec6c92d8659b8570236fd615067505c11fcb1842567e94c22157109fb6af56da5f51abf5022215e2ec2edd83ca2280f613fdd20e6e058e680967eb79aa47d208b4881a3dd9ead5e380428d19498a823da162794fc0959f32bead6ed1c47de03a5af52e384249f1041fd0d934426f0c0fea8e32d2ef978a214a2b349102cd96a28c9f71dcdd33f738ae0cdc90bbed661c837d06ac3a7d8a54a33e601eea0512ec207d87726505ed262428b525aee1920af23d16b2f80dcd258842b59835581126d05fd46550cc6c67275a0669fa8f48d7de8ffe8ed4405c8e39ca335ff7c59dc37b4ce08f6706a4536e8a985e74f2a7e691efcde578a1931ec8745e64215f318387e0516a4f5989b9e088b80cacb53137fa60d322c40d86e81b2a8c8a16a43a615a317a4176a0f66e77a4966852aa773772be929abe6dc6f6718b8766e339b29027cf11927882fdfec32386d30409727b5f2201015c135845ce0fd01af671937925245496864cce213bcd729ce7b02ab3ecec8db90ea57f182e2930f1e2d5554132099c247c516c5c739cee49dd1d2c7d42d36d14e39a72bd68e9074c7f6a2e4df453b5d15cb8c93e1b3ff0e29b2c6670fc38a25011cd315513101c1215666e73cc6839ac1677c6bc9333131835ab634b258bdcdc64c5020e9d0143302a4afeaa0346cbe196c77444c39e416c763e4623dfcacd65f7b302e6b02c5635314230c164e8fd581636cd0849c3a27f5d615b775d58c0a069f5d7748df3381f56818819be6aee027a3627be90dcdba3fdff0a4f884a323d57fb50ed2c3a98158b79e5dc268c94307972f4658c723e04fe314b7a7e6cbb65043a4f058b97222911b9eb5006097d14397dc14357049e803c4998fb9c7d15900b8258e9c70e87fd90a55a3bf4b3234c1a83e08f2ba52e7fd71e4fee01934a55194b846a9f804fde4f9a39880569b21048db7c5bc58dca368d7d3046ce13c01dfe3b1802513119e6f1cadb24f17c40fb09bc6e619e91b226a3650c062bea0759cc3ad2afcc95f23b50bbb611a05d6579871cdb822016f1eea9383cb8b6235617ba0d99ca5bef48e31cb6077deee7c7677a4394245ba5660cb8c5f6cc1b386d7061d7d65d41e37009a7b48dc97ae9f1c984a69329172108426fe36599e12ee308cd3e1e12c3d78ca39136de01cc77dec607f7442217bdec9cc90cdda95df38d8759f549b3ca8cfa64609854e7e34dec74e83109367e196c0d79744df9091bf76cb6c3894f5dc46b1a1288e8bc4a652c924018e577ec24c4b22b58013ad15c4fd91e566229dbfa405dae0882d408b13162d5d553b2b6838b314fa55de4cc4fdc2fde2234d165173b0280c9bb8d9f6b5ea1d3c7a3daa39fce31bec2077d1f286ab6fa1fc01410d0e0688dcc6cb9df53205f2e74cf4345fef29e4a2465544fcd75850991d27fd53775d96c7c89f30d4bc051f6f8ad97b7d1aba0e59dbf5c852b3e650b014b315f71dd8b709d28e0e88c8197d52c59cd3b484edec91595841d3c7ceb5e5e4004271ad138925264f50ae543c1e0978fb774471c3ed205fec616fb227661b529af8dcb5b3f8f195649f87eff840ce4667e7080adcbda5ae0ddcb2fa86594e288934a5a8c0ee1a5773e036c2f1eea049ddec6c17a95760804490704fb3b2ca4cfa88cfe1eea69e2a29771ebfc7fa38bebe551f94fe8a40a9e5698434c8d312dabbf6eb8c2e60ca3c430ff5009a7a44399cf19f10641e5a3f5df7740276b2014275afd8377a2abffb2895cabe00d0df8b7f0dafff5b7cefb83904d34063302d872ba9e3283e1218acedbff77f45c8fe59c3aafb9bb62e35c8d5b4e0fb85b529b6265dda913ff0a186165e998656a7f8c55a1617b1eb656b17ee84aaf93421d47cf4b510c8d588e8a39dff425a4282051f273be5318f8aff9e7b7924d8908f8490d97eb1317ea2b310c61c57d321d704f5a41f34bde73901e66f3090df12a0999c459e9596944cea8b10b7dc76a278fec8bd76ce4258b4280512c0f912a70874f52148ce0a937116dde7a2c3c89959e714c67cfdee6ad53478efbdc223ac1d5c12d50076b01493a7abef8669103c5f458af4c1de92c16abe45a1c0c6803169e42982832747ed330555f01d12f3b4b5fbccfa4d22c9fb9341b80e754f7492a22d8db05a11a73cb44765c1ea602a491f1390bbe3e80f2687243178676d7ddcf39bb2042d64aaf246530ba3a9ccc4ce8d4d14269c77e5e86fcedc47ade3d2f6852446eabc6bfcb44b52485006b972e17435854b6ba931bd36e371094945cd011523ec2388c7757c7309aabacb10f6dc6008a5e99c20c003087ff44fbb1044659bec7df694aeaa513d93c018617e2e6fa1e8e9022baeb2541d599b0c6883e3fb664510deb9aedccceaf0de5991b431ac300a6826d5949d7d018d0125cf43ba36a7f6a2dc4603315bce687a436f695e7786ba588c9860d57c87089fb176063bb975bb96d04f49575073f5d3b536f4b5172ee5d18deb051f2a83139f0b210f2083792919c276db6840d614ce457d4d19a98498194d77eadd6e0de6df2cb3b4cddd1bceeddd7d463e1c03eb2236bc80a1b8ebc78cf8d479156e704e53ee9bc426d8f66da0787b11db63cfbfd7a6a13cd1224df1b6c1bba839657a424f3b3224ed4273662138145a125f383c238054cf09cc699d3a7cd625d8a4ac9a2485fd806b2b711aadb6a2b62e6ddf13fca4bb53da834028e66108c25defe359bc755f65bc0c6a5af4a98bafde302d299d919a7e5701776854e8a47390b63bab83236558f918eca0ae39cd479d7c0ecc3d82d41fde238c7c9f10586fa2c4659582c206625fb90c3aedd88d4fdb5ef2239276696e61588620a280bd6caf2742a8be5bb78dc60fc0878cf200096b975614c9bb4ac579d0bee4e69f2e4f6f28a534bc23d8719663b32563d061a64dbbe32121d7a71b0511e0a887674b39bcd480ec348cc11820cbbbab4c0ac44c6ae59d4b0b64b9b2f108e2a6d4fec36896499f8538f3d855a0db5362941021fd85b489a8bd8a3164c2c75d552a1a3083d5e6dd9b5f9bca14a5712dbdfe1027fc3462b70ba67fa72ea757919e0b0710d8dce030d3aac40d19b16215fbdc039a7add7a7f12a2875ad3460c2c0fcb8aa255f90c7577cabba184fdb209eee40a2507b13c4bc443319f6ee80c7889e727726d5f7d850f975d009439689f1d3779214a4e5b5c1d84d4935a88e203ef5f8f5da8a3d492550cdd3e11bb2479ef1d0a88d9cc0fb4889283885c2efb03384d9d82a53d44a84132f35080ded9876ab4dca275a685508e245c2ff15f3e9973e46b904ac9d0caffafee051747af8ec90778b6c6aa4af7e16af5b99e95bb7f0b469e1b3b75962315d42a4e197f30af776d3b9a10a827103beee6d00ec0fbfd4cbef7273c62152a68c2aa89ff01b0e25b097779c7a1b6fd57e792da318ee36ddb2b6fd0eada8aad8147fe91d6369bfcee7b8733c1e67c81346c72cbc532d74e3984c2149904e29b5e3e3de852c9d8fa2085a2a5794b9c5839a3ace8823f995ea5f03bd3c8482bfe564565c60851488290b77cd8af59a413c4ed9d0a7203af0cf497487361cc95b1da0739ac8c2ecc060d25d6b7139fe2443e81e72536d8adbdbedc81f8b79659bc24b7e790f17a2a236faa5d6142f359d58cc5097e49e28334053497cc553ddb7ec13a3e58165fde743692316923b8b5b5f8730bdc3f7b5bd300d5128f680520e22fc72faf31c8ab128e1986bf77cd98ac233d4bea2efbd9650e5a1df050564fac50d859cbd20cb6f2278daa5f65d8dbb86c2b3e32d0b51e3e4195513f72beb6b5e07360313981bbecdf66abbf910ba34b16450cec9511d8b386b78224afbb66929f331294fb96970358eb3b5ec72795b0a8105a4ddbc20b77c784903f325305cd8b2533c4c652849bf711de78fdcaabb9122c3bcc034a742f9aae88c26563de99da153bd3d0240f755b3f72599392cd1e5abbdb6ffc68901898088cff954242626e6df6c48d1c32f756aa98389f4e602e37cd9370746360065b53846324246a5d35b61edbc0cb80481ec13023dc7a840823e4bc8179e474e68c0b12322e36a32f26ef5fbb275c91d295add805273e5b1fe2bcb257f174d5d08e130bed70e8caba9352978222afbba09b816ef1915fa77257d8843f3f3eff901531900e90a34283a0b76ae8375e4ef4a72bbf7c4fe5421c881f88c1db3813f755fe893d4552a5f89ab0093861ad37eef82ce30e1d77e7c349ee97a2baab25a40bf1fa5252451276e2bd315fcc1cd15eca71fb3e82e31e5936bf3ee7ae56acce6f8d6c52d9af8344335b7fee626f175db9485567931e54863ddb5b43d2e9b2869b60adfbe0db022850715c0502a61d72d30d79dad1494c57742e3b2c42cd16a0b50c41667dafd4f85e233bd3636ae935b99fb3e759dac7d0a39a1f9d5566435e67734a54a274d9b2bd3cf3e63db559b68a7fff8524aba459446a317ff1d093052841efd7910a87d0daeb110861e5b709e7142fcbca77f240c8cc34eb9cc6a092217d0dd6544bdec76c02d8d2a9a83c6583cea4ff674cda7e2b5ba030fea48fb4a51a4d6a8190b1f02997fbb7a68a760754378263f829fb644795dcaddd61a5f874a744a455492ea445c12a67c574d3957b8339b4beb1ace86bcfb08e8e5b2b795b30894759c1f65d649ea4c9c53f061a4628cb20cc647f1404e4373deff6b25f5218d8ee5d92c9203133e1ec20179d91a8b5afe782fe6df36e8bcc7f32dd43ffd5c56a0a452d0165952fd08f9bed96e5a6b3bcf4ec369420b7c87116c6b7b1a394fc1ad31bd6f009d31532d0844034b70d84b595c25794f336cc9ad48f9ece36682850e5094390152f648dc53f888947b7f5f2c6cd62728ca19b7dca5e3767b56a41a8dfda70e5bd59c2afb1c68473ae6b3f7d02b7a3676ce00ba598dd7320f752c8bdb445f9e11eb93b2006355a9c932bf74dce2e2f73c22c2ed22e91ed3fff147d7fa56fb007e1a315064638edaebea5267a380e8a52eec96f782d4e18ff2781bc7727892ace71cd067159424fe9cbcc9d5303018aafd6749a0bfac1e2ff74da13360f90f6c78ee2422bbf5799c0b23c87a289097665fb9f7e18970833064c07cbefc31010210b29cb7156d350d550f45c581a16451ba930b1e1fa283d4d65043484644b2ec72b34ef8bf31088842def3b583797382157a29dba8a846fdd189550805224e61bb9539b404b55e27c98d7d513c10496ba663f6598c35708d941c4b3a71f4577c706f101836b172dcaf53d87da0d86f5095c3982d621bdac7a72e424969db8d393023e122fe31b70f08edce80f2b74e0b19fda1cdd85791abfcdc1fd2d060cc20e511e76ce16697e40bdcd86cfbe3e3d7d0bbd58504a2ae10d190a92eb34e05ceb62a07a8ff21b414ff49b2270cf2f9272e9391b43d42c20f814d6ca4b6e2116f9a68f87e98343351e8656e7d7fd24bf99f6142746160d113f66d2918ec8cddb8cffdd6ece0b4c847e44d2bbe5a3b81377fae0304352f104dad3a8344d7d7f2ddc57b222ccabd1fcdeaead7e71236d46540007544c8808163ef2ff043dd999091b4074f97ea7c1e0de8eff05ba258b1f74c91650ad23b2437b622dd5f6f059af6ea29061658058e7103a51ab3086cd19b53a72873f0458f6a54a7d91e658d13d4bcd82e363b5ef0b47d84129a384b881f119b2a22baf96a89c87ec466e65b111f8583e8c7b188d40c083b0daffdc2d9b721d2cd7f2ea90226403113ba14a5796f6c6815466be18ad9e13657a2d29bd61e6f85b9790d159e77ae94298287389a2cd435344ec66f61cb11f6852968788116675602f6b7a91e40fc7a7962d2fbaf82b05b35de046793a467673cce56207ddf96d770801ab12fb517855ea4560ed728115575be6316ba2b44c0886611f6e3169e8e4fe6c96ea71b56e7f10cadacf816a5cede07da334d26b67f259aec2b9e9ea9f13602fdc54f550b2d4bff4ed444c79f5f327f91b011f7c524c49d5b986d3a0cf033e9c3a495b0338f3be562dcc067bd23cfee0589cf956830be7733d41131e20d34eeb4acb1cc8006aa8934347bd111f2109c553d9e35faa598cd95fb69496a122679d8ff1b10749f4383b025429a9c7a3d9392c8afbe98a109d6e74667f2e9d7705ffdd3ccb578ea1aada7a1d1eac76ba336d3634b1fcec22dae8fb71237332b48301122ebc79363cf7be67f281b6aef5a11b4b45f987739b117d24c6dba88133a85192cd72177c56d4dc4fdfda7aef7b73fc09503bb5defed4f68185498622ceb82c5eb7d8728dc590038311cfb2f11eb55158f046f6952a18ca24cf1e49508309ecf93ade5b379f610ff79984384519e78d6166456c363f70937e2ee2494925688bea92675c8a1fed39e33c7e4cc07f99d4c4205df85051334f5a898af0dea5b51d884e0d4abf5d4c66a76ce3ccabe4a0d146bc5fddcc0c7ccb2003f1f4deac5847170fb757c84255e4c716ba46761b16ee17db49e8687158c2af2e36fd7279e33914cb74a957b4aa8efa8250724455eecfeab90fd4bd6d59025f8f1f37fa71d4e440e6097d2548e1aafe8305436ceb549c0d32cb92fe8ee5f4d90b6da97bfc3a6969852f91767a818e422923351ebc6491eb4212f7c78cda2d7e1d07e014750b75ad2c41e52bd63e11fbe07055ce7b22ca296ebb76aa4060e0e23f6cbd59e05ef64bce434c24e2f9ad11fd09494708bf577938e57843a780761535a40165b8eac9942fe89bd3816669fded53447942ebd0d01a455f90de32e49bd6be0ff80b244df4f91b830e7bf71a6fd11ad2d2957def4367fe0a142ca1fe8ea08f09cb0328215d03c9df2331fc213b6eb8518bd9399103282781400ea8a503c65a2f9b69f15239583d322b1b95d91d6bc8c8a574cbf02ce9371bd59479452cd55ef728e85da238f62a351e3dbcc6f826dd623e04c428ca34c86e3754f24a54be5a2e69e6de95ecab27862db03103d879adcf4cb8d235379bb6ad1b5879550c7cbee3e6f4efcf28d2ea31d5b62e2596e33db2de5607d586333a27e081d569a7bb135ab3799e5b2928f278e6f099f0976a1fddf8a9221b593cb3f0a76c5a01a5050c05fcaced36854a6ec5066797cbcb69c3a5051b13dc8f092b4c96093f0d743524d9325e30e5772a1c9285e5b8c7e14751e8e11c1bdb3afd3869fc4ce24daee7092898297fc9e408712e2a5088aa4a51b3c92af46bd3e127504e957ff64bbabe9ed77cb5ea0b4dd4c1d153bf80acf6455ef7552397f0601d56e96f117109e14abe1fbe1572fa1a6c5453d9371c1221a86346e32c0527172b9c49c34b9432514e4da1f0a1aa6cb009743ede84ba7f52eb3e7b7ecaf34dfa860ad5eba8764a6f3cc6a9250b299bd8806d1a9b15933e80fc9dc977dabdd9022e618eaf2718cf569f863998f21bcc4fdf1d24ca3b65ec82225af64c34fe9450c441ae30ec6db8438a43c95c7cb058b2678e83a8471f244fe41e1c505ebca2f552fd6b2aaa0e881a22991959269d3b2317b91cc14a803ff81b23fee864076716b910fde02b765bda61c5e411b4a166ab3508a1513518b1ed9ae42c90f986808c7269060c77523c8ef38ba8fa3ceb7dfcf8054eb8107fcf9e66826800ba7687db18983d5f0f393c0bd2c6e44e3a4e453569cee92e3b127c230734d6156267fcab6f57a7e75472881adcc8bd44de9e4492d0ef7f59658b266776ea4290ccef4870e4f66036433dc1b5cf61d915d6452364d5f8194c14eb5d265505ee93e2784365c0f2f610dd72892c20b0a7fb7ae25d5db9e792fc7e1028e902e83bc74dd3cfccecaf2e56ec8641184295fa3808347e4f0c17e35de4b78de7032646aa0262141e0797088d8d0cf013a373768b1c5d9a63a6d1ca8d71499890317d95e30178188318637cda8346e6c0cac250a2a6ffbff95c12834f8992a7cf2a043d8f8730ca6520c490098a8add3d2646ac9d1428e2136b8b2356c719edb7456aae3d3316a7301b2deb87e97f7e831e646aa489b626cef20e0665ecc43944706edb4ea5ed12e361c7dff1d7800c05d21b823a998715946a1aa31239c4431e350853e8e91c588be5535c6cb7e7c9eae501b7240ec2a731f69d2d1119badc92980e2597a3812570212a5af38d1c652209a5d4f84e226cb3ba5a33a34efd379f2bdac07011cd8eb74db26e151040b87aeb7782fcc8c7529437c2f43589c866c6f0005b212aa88851bef2d344fe91309d0d76486fcbba3390cf1088f63b34ce7f56e27082ae2f9de515b9a2d537d0e7c4caeb75706079dfcbbcd2df770fdf7366bff20f9264107d6a4adefeebbd758214e5d07dc45209c64bc4bcff01dc7bd7f1d44dc3c4e4bdb479e627fca58b2a1920920462578ace6a69b6cf792b42b86904be1a0463a06f6c70c93f80c63c2c48563b595ea5ad78c0d3310210a7c38d461366aa79dbee9ac57b2f937e21bcb7759b0a4efe8d57501568d7c2585718b6b4064372ea216b27497dd183e7ef7b00bb68b4f6c75a0da9313b6b35eab346f80987c522a6c65b350292ba5e36ec487bcb4a6d4adfc36b7e17df8f8b184b958a483134d1c1ccf57ba2da6440170ffc7af8ec568b1ec2c411d896a5d32a99bae41292eb6f95b03d18e7acb5295a30ab503b4452d6248f088078bfa4397809f370f972c6ddaad145e8d00c549f5124ef8fb61c659539e4c0ebba39c0e37510705763d63681a06099ebe6ca26bfbe48f6933ac00eab0a5e53c3d1f623a71b30aad4c60eb35318870ecffface520ae80102bbccee974ca9b70c76eb8e7d1674cce086822e985e32c9e7bed0814f4853b1044458c80241b31beff8deaf068b0bf04e0ddb4bf5d288b1d31353d8b5d61bc6800f995b45e826908c291e1a619e06d5bf221253ad763a387915740cc8c1cfe000bba2b4f3286b46dca32db2af793efcbd8b9924a5825c437c6ae4e3984adce23aa185084a709951c81d0b9a682e480acd9a01b62ceb159798f77e058d60f1acca1b9f0983c1395bde5cd08f587a1a17cdc2fe60941bdafc6cf8b8931cedf8b035d060df7d9f343117ce5d5c407f13985e9dc2402b30c20791fc1164df860751a231dbab55d331dbadd398244c9fc50f0861a21bed8000c1f239296137878631cc9a8a6d3098375d7795a1e5c85504c210058accd10c298dc03ef5d6a6844b07dcdb7e7300a7f364785c080b50c51eebcafb38c442b18f44345c5c1403b56c7b1db5b473768a52559be54b0ddac203b1876aadef98c9b2f2f5178b370a694ddf0cdd6198d6c8c3a661d9e25de1fe5a2dfc808ae8f4528919aa8564f61a84676e644fbb7fb31838366989cb6f5e8c3ddd28027122a7632fe5075b9736e96a9fdc403e174a0eb0ed6275a33fad1f270f51e3cde2a9a181dde000fdbee7ed4e61e50d33a5df19fc55675b762eee114c9094c4b37d02905993de4ec86912df359f5e378a7fcbb7ecfd34cff5e21f30fc1148dd3930fad45891c18d04cf74d3f9e1c2f1adb51dbfa410634feabd49881276c0da5c99214915c157774e5318cc65e0fa1308445a0a7aa84af122f3365f24931f6e98c2f97d675e1ea891f59a5f1f45223f863325b3402aa00256627a2a2995d67a36b574560342b24c2101685ebe0a0f21ea8ab53188974a6bf9e3c2c06cbd7c1c9d5eb58a63c8a7760a68795f2434574af4a1e8211c88b9437a4035f1e7d65ff67f75e173dfe1fa5be93ee5604fc7ef97d0b8a8baad5420764c774103d129ac3c3d3d396677eb20e09919699a3776716b3d062917200230add2ba1cc98a41462974ebb4c376f987b2b2a1eb806443a701d8ea758447105f947453a11b8e82785d75adc3252aca886bc73ae3d99d22d8b20a4fe4ea6f57d37c061e6f87a70d428d8885b75abe25a7b1f42bd968a40dce597d8bbcdad8ab25ea7cabf3f59c0ab6a5014815b0bc8808718395e02ff86a6d81826e7d078d7bc42065344246ced606d8711e46a5f8ba6b1750da9c48c06ded407bb78b9993c1005a9fd5f78bda8af94fb1e7cd69ea33f344bf72dc63164639ca7fda60400c31c297376a73195119d9dbfbae48bbe2a118e1ec97dac943e2bcfb4951018f7d2466ae453435b318c2aed974ee8b8b3857b6ba82baab7ba5fda5d2d0daecb186ac7bc8dbda5b87483b024f8b63ffd3cb45f0eeff6ed0c5987e5dc365a05df9a3a6f9a532cd862db297a0ac41a0f0ee733859d61267848898684c2b4cad28ab64319059a67a732f20b9bf4bbfbe0248553400509aeccbf45f4acf5c2308a60fa33b67b8482c77e180a4621ba0e648650495a505b9e8ab1f4b9e2714234a28d88343520d4a5c304f7b340885dea665436c8eebdceb9a38fd01d5267454c8bfbf1684c2410813161711099ae6b0cfa7690db1e2cd027f89ee2cda6925e5c27e9afe95ec58b94d445fbafb50098b646c6c6c6f33c406903a2a72863eab32b8dddb6a8d4e2831ff2b0dad35d4a8de667087fab326d53cb15437aecb05204a7aeb4d5ea0c738912d88f7d95b8610c48c87dd46d13382be9b1b28b3eea17419b6979480225849523dfe7205f23e52ffd6d5b4b1933f675f148f6c7271b457a3d96bf02ecb57e642abd5d19704bdc77076f8143a670014e875e08c1f48a60067df8afeb1d50d9d9b330fdc8b46df25ad14a16aaf3ede3d1b13957690de0b42054db8579fc1f257d127899ae5f1d4b084c44931a469ee7252b54a052f705c5d6537725e78c433948fd1d92629a612b957c0f4547854b2d02e04fe75c839643df41688877d94b427bac17f64935569d8b0f91a0af88307b804bee90d76d3b3d14c91d48457f5ff37454a3f376468f0b264088515f3e3324cc8bdd788f113bf051d6fda3201e76ed8feece860684cab7c9a186f621080be39466df25e760959a69dac32b5db9bfbf7b33f87d73bae4d8493b3977f690912bcbd1fb294f28bdc4454fa528ada79703b7cca31da9c2d0a13dc975d53791d15bbdbd030766f900f1630f89f822e979802bc1f238b964393703aed09332cf057c0c6a3fd808be101e22759b5ccc38aba8895894746fb397db72fd96234a90759fcce0c9a4b293d3c46038823f6353853bbfab4950bcaf41acc3bcdf7b42a72d372cef4484776f82d59bf169176a4ca90fbb4c0a081547fc96c0ead7b724e1dad66c72057a6b752c292f3b505e57f874083ce05151cf6ccf990b467a17b96d7f5e4cd2340254a24fb9ba42e3f4b366fc9bb0e5b1dcbd9168392167a4085b7df88bef5abc3a9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
