<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"360f5036f464cce900bbb84a6f2ab70b6ed9b2bebf5e535675992915273dec17bf4802b8d5ddbb234dadcea4c661dd3e6ca2e5bdabe592c3461138defb04f98efa148106cd32a8b92902692dc0c42f10b9c7f45a300535dc59e3bd7d9e788a5edb7d0e91d0b6d4fde9d3e485760d3242dd44d96ce75c7ab6165f2676b8bbd913217cb038307ab9370038acd3a82109694b388e27ee602455aac74da4fb4c4c00b2f560b6776197e4994d4865d883ec08ce7aa20a84b3be15562a24bbd67bd26a5564ce5e650d5e7011b95250045ed103cf11e0787eb8b137813e6a15f6fd729186d427e643d2d9541b10f282f1deebdb3c80e0e39b17d46e4948280ab4c23737cc2ef81877c1b549175d26181a786859c976c03022fe9b53c3d8627ad677d62f00af4215a5b169e9a3720bfb37270ea8a7ce6628f0f3be62309d91808c7d54f9eb7283979c1a17ecb2830471859c3b05de7bb86d0d2c8436c477c20e379dc22b7624fb7815a061bb5100c788fffc25a1c618c1c80c1c2075532ebb25455a0e4440024b38b567b66b26aef0a26ad813a5d14de913c334dfbd777c40b3c38a7745ad4122d8e19ea22a7dca8fa05a6fca2bdc3015c31f8da95d5ede25a797bb0519ae7e4e38204d38196ae40bd32d807995796278b82add776f374a1583bbfb613581ea6f5f331f6e8abbd550cb7413bf62099a2c569f0fa5772575ce3600def87b98a16cb5ab9a1aef9a4d5e5147fc4cb338dc5b163b9aa7870b06a8b0bd908eca35c89e4564313dcfda7640a2ab2124156863dd61152a4a127ddaaa71465e702fbdec2b14913c3d26c2b2579412edc359fdcbaf2da7e50c008fe420f4b12a7d857fe922a4991859679c86af241ffb9ee4d6d3d1f3cfad805e2dd29fba8b5867532c15e6d7e46aee1725802072153c4dc08113f002b89ada43b2c084c05f47323f2cc5e43d1c1a2604168bc752ab133a32b7b999f2a9515af62758f9f3508e6a24d4842eea1ffd8f9b61d62deb1bd3c0a088b77be57294764ce0f7277fdeef5be0f93434100a96530b1c677e0f8821fc8a3f5955bf9afa0a30fe1c0f662baa4ef29fe62c8692ca2b682691c2e37d12516c7de6264f2f77449b414708e4cdb80ff3d1e9ddcef4e1f6ce93f21c23f10098dafd7b28ab2a9e27469106481c3f64342f85a8f86a6da593ed35db058d04c8237fca88de122bf52e209079f130a3a7de50c6e03ef9db87520a54a3ad0dbcb0972d06e7e838244f9d244a719f576c088faa6dfaafc7413a908661e396937a9453f29ce52c8c5d079cca96eb41c2104f926874d0f59bfca934e1f4776f711dd44731bacd601940dd12bf75eb6422052afbcaadf6447123098d86d42fe2ec4f1811ceac6e03f63071152394fb3065934f84270448093bf1b8e6cb4b17c2ecf6ef09a0116a6ad6ddc9ac5d8aaa5745ad0939d90e0afb7e18c6949ec4c0060ed90b210dcc876aae497e880993e8d556ad4b34418645c14442440c18cf828dc2dff766959a84a9a0cbba82cf99413bf827a72e9370f546bd6a0ade3c08bd4eff47d2dd8b7d7880164d399ac442f254817855f98b07c26c31bd113b8b473ff24e28d0e675672f7e29fcc70555b40f2fc70ebd43462199d5b4d801c651dc78ceea842ca882a8dae3807c666aa4f17467412aa4620f75c318de2d95f2f69691789b6e01cb98845981721416b3a5cabec35c9d015996eed7b2e252ccd8d862cab9b48e866017e6881b90b1aa813258258a1dcee501bb8e70ad36eb51787d30ad422b1aa470e9d8efddeabe185a5d0f69d97c52d9fdc1a7c3affe8f65063cbb882c6497bf20c7b9f52938b2e9f91be1ff3e793244ab7995f052cd2ef49f05ca9f5bba66d6fcc37068277200013f9ea5d2f97151edd92614caf797387d4649b08de6db403c2a0bb9e6d9bbd2842a044edc15bb557e9e04b80d4e8dfc2fd4a2a0f2a76ee14a07bd05f5fc93df9f257d28d942c56ac5c827220d0d76228e1ac9e9b7721e1d87556498a3da61194b9426f23ff38c284253995b573dbafbf84836047b33da546a0ce059648388d9ea1b40067ba6345236ae98327bd187bd371bbd21918f04e7e16d7b0817ccd267ccb4ee9edd820ab39ecc9c069e5bbeed9c8aa907faaa6e1f37e571426173c26f258e01a0f2af1889fae385d290ec98d213be062e6b6fd5731fecbf309f5d202b97f7232e4657278ba0712cfe50cdceca8a9453728d7d98cc7aeebb84ca01bda8fcee46a1950c80398e13375aac1379219b7a78e3813fee03282f79370f8c20e0d0a343691e90b7145410725694b55cbbf28579adc1647c503abab75d13bd21fde112357a7e33b6501e11c9921dac9e7fc269c6526bee49769072587ea6f272513a35ed1d3627cd540abf556f4f715af67af7a5c75d39d10d8a19ff37ed01c3ae67ae02ba8e7ee64168fe44b9f76cfde3c56739732e7ec73ba6461e9005e745d5a9c6c9d5450a07443503aae828c1264ad0e6fdd82deca9a1b18f31f274beb24ff92ddc792ed1e39a753aa940bf22d5696ef707536da59fc28d7ac9bae9741025aa315b27fd84b5a4bc8264b6988e40b8ed4911df6e33224b7688e7af43bf2676a45499d549ced041468f04bdf16a6698aafb84dd9b323b0f77ec6a6bf83612291f7a9ba28cd1ec67f00ff400a0bc500e41d0fe7855252e634c406917c41ac115b0d0aa6af3a85f83254c648b065d24be97f1d89a3721780ac02dcdac5df4622ef3995c7a6e97cb11dfc57ebc8755f0ec8b9703f0befee7f94d4cd77b6a822dc230400a603caeb595205a4edfab615bb382dfdd59a80f07c0cd8054bb03bfe6322d18755aa76d3678ce8e0c97714c336565ec2e678452083306c7267ff114b4153118e533e23572c6deae21ef0eab9cce8b30a30c3d200bfee997509f6aa3e2e90a3fcd6972aeda1dee721983089caa7b1fc71f84e8069abfc0e260fa33083c8d5af32e16e3ed93f9afe36067894b784b8b7158cd63b4c3fcbdd3848f503d5258ca32348b1f29d5eab461517c10f3342fda619e3505fa1b27c1d563327a1209430bc0ab804499cd5040fafe97a74005c6aa9e1ec9301065e60865bb0ade766d5667000882ebde7b12edaa707fb25de2230feafc9d72acc15e6d4b77484c1cd68d29874c6e241a8fa4404984abea04676aeb654c84ed90a755130bed40f034312918bafc1edd5d6e15ecfcd74900a3e7fab3256544adc11a19d0eed515ad756cc11530b13727b4a2a236405373279952cabe60e2ad5f631ab94ec8e16e1cbf689bdb2295badd226facc9ef2c0548755b0feb588b83d41972498dbb5ca676ed46079a8703b588666f429007902ddb99c19da000fc89a08650d95d9bf1ae05f344143fb972209a7499675572d4069c673bb525f93063dc061b45d03ef7326bbd885e5cedc7b07363bb2cebb74777090c4e781a1ecbcf55dc6b852246aff4b654aba104e56b991af910d9ccc0665d6cfcc4e1bc43e0ee88200271ff33b49dbaa72ce6cb65663c86f249b82e06a5f4ab9554a421ab05acf1a4a328d8284585411ed91e202f9bd75af9e4e57db451381ad7bc6e11cb5eee6b443281848bbdb85fd178c92edd4c7409091895dd9ab44d6e5bd85f39ae2063c9c5a4a9f164f1cc4aedf7aeb0baaa1968316ea4a20c05ec4c78b607ad792969e41940e480880c152174808264f1b1dc41bf36f3a65c3b1a3ed03b62ff67ba841464c553a3b6afc00d650e2efb9f6ff29c57e3580f8d9148ca545dc73628772e901f789690460c9a7c5a3229bda56a42177037c08b95c3fcd5a25ea8368747064eaab2580854d04a6822916dd709eb7ef07d1bacdfbd4d88ef66ab586660c7a4554feece0ab9e4b568b05f2c061596ff1f6c86f5dbc596f8cf5546f61c5aa787e9fed125459ce07fa2978f118bf009211e000106039dbb2ba4c266624d576a888c9e733450bf29262e7333705191838b1e64af4bef6da245fd1f15225f7953fe3cc1284e58fd6ab79bd3c2ed957c70a1b65528f26e6007375d45c8173dc3253cea0170965d3b73e61141155f603bd1a735c1b66ecd399dcc32a5188205a651cf234fc6c0994e14b91c8a45ef91ff73ec504745d1ef3ad8e59b1418efff356da9b3fbd520ad0199eacb48e075c0f085efb506dd72144956e7a058e6dfab17c2362a368f9eb4cbacdff0b195daf63ad29e03f6cbab9328abbc656d7fe2751d54add7e9af12efadc01f1f8ff090a8b5c58356f7ae23fbc7ca49390d7d23cb6e25ce09bf8dc72d9aee37a83671302c80cdee08d2bcecc26effacbb2585ecd4e2a9c758c6e4fdab09c02e57a53d4a2e3d3b860cbb5a6ab11c30b362f29c5a9d9c978f21fdeef8a199f9daa166ba36a270eced6fedb6ba58ebcdb68a283653d566a523e9ea532637d4b55fd30c870839c77df59ea42eded3d61f2adb689ccf686d03ae43dac7889cec677916ffdce24cdc1811ffb03a1c4b0d8bc49d0f20de0f9a1376e9d983eff9033574f693947b72d5a0646e811c5e567a4d4fb7b81f4d39c32a6c615d8b05366e37c80027210b37efbf9d22950601cb722471ced58f947b4ef14243223a007b120d6676ecd18f186780207b83a4bd5f0ffdb1a16f3688b53a108bed8589db131edd01b39dfffbafc466bf7bbdd5afe83beb75e5beb417857906cce6bcc2f1f5022747e0ae34f83e5fc1080f894cb37c46b9c28532abb6b9459a50f773ca8662339809edfa82ddeeb8cae29ff2281f62dfb62725d9c138babd9971646f59d3e2e095cfb9e7a854e527826391df17366f13c08a77c8f3cd238c1e1394033fa271c83cd54ce0abda28063fb1fd0861b7b896f6f4d4635945f3a6ac15bb81acecf8f5d25d3e0a1bd92b4a7239e74ce89ff202c878529c27e704cced4be0187983ca5876fe6a29a9f574e1558748f3d8de1432989a475e8736e9b5ebad7ccd3199c437fc0acb8bc12bd4a8191d6a29a673b134bb1f1e8b79ba36281f18abf4da25ac22b5e35be6fc6e91153c23a3dc5e823915b0d71f61e3641a573909d588fe54179c65c3e4d5fa30f5b6d43d218eba16d45ec475c05e3884c511301d0c4063635432c954b78e52512af1a2d2fe3da2c7904c1375fd9768d5e3a3d9cba8fd6474301d9d802271794d28e54686fa867f1b7579e016f76270be46974bd34883a74828fc2694b0eda1129a9d26cba38d8a092cc71599d3b1cb3f812c5e7a3ba83fa180c0377eafb2518ca6003cb26dbed8ef17b15a2bfe21853af3e9810f8aed7a0ee94342a529ad5c1e389a1eb2cbf62adf2e240eea01c57646aa1496c5711a2d49109bca37fe93e6dc43e204a516e2fefa2a5f89a6c4abb69e46eff3eb5bc7b2be8bf2612a682e04a4d837d53aa559ff449e82aa0e04b955d666b1b7bb75402be33cc8247a1d3a2380b5ad9f47ebea66ce37984ac1bf97d884b63cf87c48c73d6ae394303e669fc79927e7c92ae2fba80adbb7d7575ad89360f1c6f56d9e94f309507718802c0b3ba616989a5a21228d5d34234383fc923ee57c2b1ae5edffdf3793b6462c6da10e39272a21a5a4301987e4e8a48fff7aca11caaac7d3527ae468bb54abe749be43c3c1573f9bebd19f2db54f855ce92784594f08549bfd71e4f92b3c09a8e3690f2eea6824da9d2b4eb6b22ddae52e2093941df51d274da339733ead97906752437f63e3472cdc68db34be146d9a6d693c7bcbe3e585a7eb7bfc60f62b8a09f852737180dcd1ac9af0417fa97bedb8469e34d315f3997b1a77d910d0ae95ae831ba9ad3c0ec44d68127c7248fb8c06992ba9b32d64ead43c5dbf9b27390fe8ad2f7a69a1f3263b5d2d0f01db0046f4f142afaaa2fc73225867e72709a166dbb4d5f0b81d0dca630c67c2e0a9c52309d991792b71f7c8a2344d358296a662c36ee8983119abe45bcc2ccc42a81621974b61a7850903ec1897b75191d3f7bc1456bcf793a96dec0395e922a4d67ec27b962ee89423990efec0df241b5373acb3dae810638ab3f729b210f2658891698c093d639c694061c666ff37a503318f45584df1f1870feda5cb0f1a88d3e0a57d47f42bdc4c357a4a9198a5f6fe7116abad5411dfa392e10a9e1bca1841fc159aecc37e7d16512e7b02a916719463eb8e286eb59a8401d415c4eb677588ba123c6815b54d0dddbbd8ffdd82e3e6fb56e6637913ef54046d4ccd8a2ee79767ca1797f8a2136c948e870893f941c714cae3408298258d9d2037d2d2f00959f215cbb7d92ef08c0cf6fd3ef5699ec28e7dd8e97b56319d8c530f39c11b0433d5bbc4bd218ef6abc56b4ebbe19572da130a2703acce88e432e76f9dcb687290e3ba2776505c06f98c84c3bcafed988f09c20ef845680e8b61483f92b5a639a8e7d46c7aef3fea4eb3957160b1d26da56f0889ffe3ebb0ae41bb1ba9c72cfbfa21d5027a51f4198a3e2d1924f726ae7cab2296e88d81fb838e2bac1d7cce3ce6e5273f87e3901249434c28ad7b7c60d2abeb93c495a54115ffeb996f02a354b82c8dc83f06a6f8e400be580190858b89dce0015eb2d8f5d73bcd4d667012fee2e54243e90c072a20aefd712700331b87d714c9ae8a4ce7793588e6791aede930e8b2f23116847cbe2263f2fdc0155a653efd637474fa13893b9f83f979663f4579930d0e9b51146d7db4583077f10090f58dd9253110980d877dcd6e6e548e1484a40111e15c22454c4fada7887aa9c7f59af53b1da17f072668b087e7ad853695e4b45c161f9ab42e0fcce63c091b1bf659a99bc7bbd43b43c614be2473155c8680bb84f3b6f38f99c4fb63d7cfe54dbf09457a44b8ca2065c660e576086fda5694ac3379237fd79860b81762762267bd068cf08594254e30287fb77af90c538331866bf14b3c60c30a2e78133198ba1df4b212207f1a55c88ab5226fa25e3dcdb4e1dc579d4e3ec70d28e00b273c095699f7a022ad188c10ef2e1440295a466a04025f53c5ec8a44ccf2c337a87ab765db2eba6982e32aea8b639d27bca9b6da12c1e90977346ba43e72a34347f1c74a7eec35284b42ca471dc9979315ec65f596ebdf4e602b618daaaf8cd035775d5c84a8cdbb7e67e342bc39069809216292f1e7934bdefc1f63f6c383304aaf2d761f0e13b9c9977a613dcd1c2ee5c3abe0c76520ea537369becc73147838c80baabb8fc0b072227a0354d598e5c14e1871068430e866c62e72bcb8173d8e79d5892e0382d3e1041a3cc64015feee63a736a37a4a474d827d017ae81c60ad894c3001df8f3f77c2ac225a7f0bf9bdfe09dc0e121a26a5345edcee711b230825bea73ff04ef9a34b946c67e735aa4e6380f3b803c126d9e364e8dfe9d920de60766e507cf20d3146a5efe3501bf6cb737b3c4302f0a1f2521d553680f140968642049043ccf5eb9b019e4e573a41b1574692fe389e682693cb42eb7acef024a475d69a895cc41c390a488d257dba40f3869ea2a1179d778fafdb3879645b6dc056343b4e2f10c0ffe1cc2f2539c6305391c29246e813f389480443350d7cd0f85c0ab0722aa3a03ce3cefdafc852425c6af99d3fabda62cf6eb4031713d7f35e35181951a7203c250126490c645b3f9b5ac0b5b04f05d9563893f5d5712256baa17a8874fc047b26162067f59f7b7e4e7b2a65ed4330950071fa3a293d1d35946cae8d3c3003ee9f2ef7842fd4b8c99bbf1465d3a460ff4ec4ae18a43441e5f2a83557e27e52f92b32795288dabd85a9a352b8e9740c02bd9251e6fa49ce8ad37cbc96fe1fcdd37324201f3a55a3694b16f4075025eaba4a0a9051a2816daa341f6746f8ae9cbf0885eb5a78df3aef477e1bf24e5f8051a0a65b6a65ee2a551f688217cf4ad68da44294dfb43753843b61efbf2b15d2b5476612d972327ee5bbb41b22cac3a4fcea3b68a107523ea49c835e2106b219930fb4e85724b2f593e0c42533aff51c101f800945385a16342842357f918bb290e42890902767a7fc6757641eec3eb1dcd684c24d3870eb3ddb6aa9085fc8474aed7fed6ece46718c7a5d39f3087cbff566f59db31bfe737ae795e9bebc2ffb360606c9c80538dbedda10df1d5de56c67958d75815d4bcb1ce42b6e03ad07599223fb679fe1229734f92c55bba1c5da88987f8bb5d42cb520c4899cd6de9c6258ab936f6ddfc613529b970f16d4dd9ced96cfd284c4ee65f5dd53b3b8e55f6a349935c0230cd1cbcf5642bf771e3624414e52d8a9fbe4ff9e04c988ea5970ae94210f4ec5d0eea6cd009d9753afae9dd8da05cbd9e5b399041808843a7ffe5cdacdf8177a3f20084efc37c27961d790f0c0286bd15b376596444d25b7978e0214cf49f5459fca950e24846e7d24d4a6b575a6908f35f550ef0a39a54986cad96ceb3184b1dddd2b296679add3d3cc8d60e2657f4272d73861ecac29a245ccfe87584f930963d7a2e041f9fc48cc2e576ea09bcbd2b826e98683fc6a9ff84807ae4832d9451c6e5dea758fd1e6557bbb5e598c99d801b00636339b48e00c5180800ba4cb051edc3087564cb8eedbb83b5ddf42e9258556cc3c7a4e56b122f6ffa5f33222ea71a39f9271dada4ef7a30d06ed8c9d30e88ad1865b481b84557f2c8e9247dd10031552b6a6865b1618fd7894353cc186dac0981277af54f6ea75505e520fed4072a4717512b21fbe436c16c70bc5d89a6ff5b32690437853f3b651acf492dd20422ed1a0ade2ed6d9d43b44b3de3e48924eb46d9b6f5f74274330affd718dc11628b11614a2c5695dd0d47a0918bd235ba1de04cebba6e522f6d9430d900c3bba93db6a6b3946165baad9c3afa3680e86c856161cd1a76cfde564631d3d70abb0459169aab709bc9aed21724f6d2ff288fcda4920a8e876bdbc16f06b6031e1c706ff33b2b01dfc08a3cf77a7dbcac8abd6c3933493383f582141dc1e7dd3ec5d3f4b31899db78b6c3ad548ca022811fe7281a39695420d672e4d1db441e575920dd06dcc4d2a2c93a550e1a5a7d399485ac07419ce221626b6e6454119ea5b5b171a865186d0743692a37c96f67f9bbc1f78f268638ce6104e2a4c24f60f2142aa8b6a75978d49e7e56be9cbd5b2cbcb8123a39db5d0947d4e81e06aa8f71e3f8dfb1d0c5b87acb66d19858bc622cd11c745b1e1b6a7ca3f79a4a00961e7b30b9726107658df8138026dd8ad7ba161de06223927d03a10c452d86de58c7f025dd34aba5a64c9525142aa8474d3ceca645e1900ba5ea4377f72d48e3f470a36c23f59d9961c145912f0fbdc96a5e18059a32a04b2d4fe6aec8e3a0a5fbc7b39834006fd8ee5f6a90f73019743dd2d9bb520ebf141a11b1d6bda40e50c09bf74e1507d3f54a988de519c11f1ffe6ca02ac21de69dacb9f4a48a395ef3d679ef895255a7e26723f46b396825b0fde7035e567f8724d561f209c7e8c230635f16aa691edcfdd62d6f9c8da2d23018f5d098dd2a783c045057f2e74caca088c8d2650f8f43c86552f59cf69dfdf42513d1b6c84a0c354debe6a415c056c8f0fb65ba38c07c957fa5faa66f8825ee9a9665e78e7df7d14f3859c59f2b35718d920e93c34b05617083ef6cd195a721723143551ec33fe65a99fdbc2009fd4725cea9add9936b62b6b9b451b028d95519f8c8bedd5318bb19a9451556c890fcfaead197e287f777865cb1f224727d4eda53d72ea2dc8922e8a914e39853b0f5ef7a278f5504a148dfa8fce478b8d7833db57e795c8e30a47232bcb5f217c97e8d5c3cfd8cf5088838905e4c5cf890eeabc3d2a806863ee9eef50ddd22ae672b701a85ea6423d9a9f8536f7bfb492d8a31cf8fac6a59e0cc366ecc344c7c7c467002a7cfcbbd18470db3cf05d8ee1e204fb360beb21186f613090fdacd0c003a1a71985ec8881a1e30b192814e01fb58666c4bd84ccc693573228c5fcbc7f9b36f5b2c52c4c485b858609113606e1e5dacdd5b1792d8a94da4841f03b5ba11288efeb09f139b47455e2fdd2744eb74cc62b076475902d8b380a9441ae82a7b2218a35c1e8ba8996791dbf1e208cfd279dcf3af8f60a5eb5b0e89ee52a00e853b563acbf7e8debd4119b84b9f21bea078b0b1c1db7912828fe724352751079731d8c3af1a34573e8b5083ef5fef1d9a9d01fde7a7ae1c2398030739c0db572f3fe8477eb32d1fac115fa08e78c647f538eebcd695b68efa0367b14cdfabda9ba84872dbde67542be69500e5f60ca38d4772c6377188b5df01470e6acc192d48e3577dbb6b88870a2aadb8715c08946c6837836bce59a537571ce84e136ec68dda59223c417abfcd8423cdad13d061e8ccebf14f695d56ceabb47e1cd1bddffb3d89d27e7f63690da84b36ece3f7fdcb308825f73352ca786a5dde1ac2218aea6b8f397e0b2a5f49d2edcd333967290e06d3f8f26417e18cf0a311c855de47d9e08eca720b93584e09733e17cee3a6dfd68c3b6c5bf3fdcbeacc452987e0b1cb046af831804f6378148c53148a5f23f2329ebecb50c03d145a4601db54f4c190b3e4ce8fce8c8eb7dc10bdb4dd15745ecbfcfa28db58b58c425f3039bb1801ab6ab1968c0de0d7e9f372e6d44f750db8c2741b176ae7e3c40e0995bb7edcb5cf74e694ce6b86a355ac1bc9ae449ee773123f28af6bdee41f13a7be0f945eacca9f2849040ed7214c91f2f2240d50e5298027351dd25c732a2bd4e02ae53d4d95a672b2c835e4a9e6df9b8dc75f8ec147d3672d09057f459b300714a10ab7732dda1e02967b0def4737478fb389b256f85f58e906bc25e72fdfa301e93a502bbeb4101ecfab69ba1dd466beb7bf4ef9ea4070cbd0bb54f5e236af00902286d71c68b2b0939b481ab350ca9f889086e6fac793d7a3577be8f3aa51a2762aaf84e4efec346de66e28b8e3d79fa3c90fdbad3621bbf4b5b464e89d86c1811ac621856b7f8693c502965dcc9ace9600be82ef359c9608943f305ca6c31d360d5ebb4a65e8a22e47455b8ce37f0185137a5b3652de3e802d5521f80b6cfe8e7556fa17030a418ca7634202b726bdb0e4aad2c4112dc27fd71c2bf0344efa2c437898ae62b31715514617c09fc18d422019dfbb6d6bec5b9178dd53f281e2f4d8c6669babc94bfbcfd8944b2653171019ddc7266e47c4902c4b3be5b13856ab47dce2b18b75b5d03fd2472667bb30cc3b8aec2b1f206506b7685bb7a47f23681b8768c29c60b126100f3a7da9799451ee991456598c2c4a7574be88df7a7278bf0e4ba96c76d44c18da26c239f501b2d86abc5c1c007936bc1ba8588d62fc98446270b02844803dd7033b1543bb29d5e9082ee74784bc43aac1b691c3ba773d2915b8f9096fa289d7c96fd7a1c6ae3f7a322c51c445ee38d102e8354881f776871744fce69378623cee0bc126a72cf7fdfdb48dbd5c68a31f677382f60bfe4e35489eb73a06cbc65ca7bd0a0474e0c7d21f4815029899d460ae5438178b0a9e10b6e1bbac21eddb5412a06db6ff938b13dd0d2d4324bde71cba1de8432129213d3a3448dc831076fa741c6408e40a920c5e44db32b91d8caf60b8544a008cc2168bbd61bb05d8446b166175a854890ccc5e4358eb9e5fa5695d26ab9d232dafd4e7e6e8b35a37a65e11dad5553b101bc4a2a534086634d6771a73d4ac8003070705a9f5f70a275d95f84427b9ff432a0ab54768a14ad98d4e60b8de12dfdef6655fd946da3b3048389d83af4ffcb9f92a2fcbb12932f0c9590a3a2df2333c8a43cd00953f8f8fc59252346bd97d35c130b923f75a9080e88889a030d558af90ad6b25fedd7115545f9cfa1c536dfaaff95c22003f9ed4cdbda8b1552d9e640ef59e535cc46a7c0225ed211517110603070473d67776b32175d69880351275a09dd0fd84759babd3efc8eff116bd0d97dcf17ec27084f28bd012ab76d93aa8cfa1bb60b7f796587f8360886aa45a97e530cd3f3eef6614af93ef86a24d2ca8a08e0ca379f306f69e501e86cbad518d1598c691738bb9e46c19f7877eaabb087da80518eca2e26c54841981690c9af490a3b258e23b85b3465d6da0e015ee4f00bbcc60b3eeea8f3e4c223383a839992131042ab6d23524808684b601a6da93217c2c22b5a9b1bfaa6c1be3465f7b96f86663970e283e21188b69c5331302af1cce0f0cfe91803dab743ace67d96177de50741ab1331f384ad9ad99a0c0b4ea24661a46c1feab93cdd7df451f0a1b9ba6a4b468ee391d38a529d1bda018814bab2b0c93808175122d977f3b9454986d5a231a9bbe7c0caa5292106f0840066e99c17daa9c8fc1cc86b0b12d06d93b4ba9539fde8ea0498cfb519bd202ef5421514fa0a16345d4fb2ba9267220d7fdbd0620b4cb8f57edb462c2dc597383e9978d15102eb595640d2912483aec1ebbcde2919ae11c19c6d6c0e29e6c9c0c73eafe07f1f0f626a5a544b28c5073226420aa6c2c87b620ee0590718fd3c580307be977ad4f10f5b3ecd077824e852c800a5ee178bd586e59e93836df35c28d76216bd5e60a6ceecb024a075948a876ffe94f12d32aa5f38652276fe2978e7118e181464244666f046837c72986979a8c0628bb07d09c3f135684303dd5a497589d0b6ef64cdf5d9ab80bea22e65a7a1425231a6cd30a6424000fbdfb39580cd37a021b3d28575c3187304282054cb663c7c43ed25399ac829674b6c000bf90b4ed54a9649625f4debde183e347c5d528f2ba0f15f993ebda3871819fc64140568084ccff03c4a2521276d03e3f812c76ba164a4b2108f6c7304c8f129d0859a65b67f549c9fe4454341e3ce5c5537421ac9e51bc04ad1e1f889bd47764e8c6222ae362266fc4f9eeeccb46fd0f1399ebe49c5ea9e8efad00a800b093f67fae4d78bc11a18317a5012501dc00cce035aba0658e70babab32d415dca8e36cd40f54656ec3d6d05730d5e4ef7163ba58fa255db78a0b3e4394e52571f474ef89523ccf62378094083aea500090ca8fba8097c7c395797bb4156390a44b2dd650b79876b53ebf78f8eb820f5086a3f6a362806e9dbf86e75d62866960ce3f476ee5eb2647c41f7a20a566fcdedfabc65d31853fbd69a724ff6e81315dd8fda33aeeb33179483576f29d9fe5e08e1205f3d6a426754c845eea23ee4f6ed2038566048ec3d18d84c0808b08baedbfbacd79e15105c587b942487618e16a78b6ed65c2e1b491b2df32e61a57fc371aa7da0cd509ccc7afdcc931f607b328c7d44f08f62258bc9710d1b1e5a6ca7fa265026e3176ffac9145bbc49eafec0184bfa7efa6190020fff3b64d376ef9a6e936b02263e834d2c3a4fd5914261d9a2fea4703487747839e93165d25f3a4e0879e6869c578606308bf0c4e2e932b893174f3cbfd413d12513f270af24269e1dc154af628986e06161b0e15b6406608b1ec18d002fe3a77e8cc5552760316c17841f4f41f12535320118affd165dea80c64cd8341f8d4e7aafe99d2f6398fdbd235ef8f8457b4b523ed2d197975023ecd54cf6b5872d509494ceb57813d9985f2989b7b08bcc3be719bb59160f6c05b25fb1ee16dfb16b1061edf1263f224a5655b673ded94fd41d74d1c800a802b413629d45023d52d4c47f6b14c5d0aa3b230a565fd36e204a3df5793f6864e35e3563f3ac56e9953ba72c94ced57571d04da50e3d078951198f678affab18e48e40dcfd161fb452a287e7bc110c0898151516cf53688a14ea51e4e9daef5ef20787c79120a082555d9d968f9c226129edc1ed8d056fe90dad07c0e7e0fb8c19e46901cbce58a3ea955ba8dff87890752595bf636d7a91d0b6b152bdfd90b3eee8578c3aa97a5ac6e88a94f186bf8eb5244bcd4c6a405136f66c462467f48870e19de76572895ce3cbc4b6c3c2734c328ec7061535389667c92bf838e403d96b5d25cafc3d70825e1b07add831aa2f8d311ad6de9c28f5c47e7cdccb21f28dbf83cf5e34a1b8441d7ccbb6eeddfa0074da1f87ebe18759ae94fcf26aef3e9b884425df3bfa00d801b65f30479020f19f2b3a6bd025c2725026a669b07746d646bcf231af5dc690b82cccd2b45c1405e9559384f2ffbf2daa162a07f5ffe8c20af4387215e862a87e4605af6941f5cbe6124bdf65a6e47b36350bba4f2a395e615032bfe296964a7d938ed13675f1f6706538b607d85bf02442bc992a2af2a15921a4ebd55381b32e10f38d202c372cdd78dfc0589397c65b5f0d605472a26333d96482a12f4aac1956ba0213b2c6f8c9f2c879e4a31912e4e5409098ef4f6f664aeaec72b089b8c42c542e31d7db87ca957557e170c9ce3cdaf2bc277c284c11c5716b47a924d64d80d02002e47e3b50ce132ceb24cba3183c9f144448764c39b0b941e7dc0d7ec600118c8e6e3c96799f10e2544646040cc29c4a41c47c573dd5435e5beadc859c610e5a0524b872e51a4220bc270eef040298a199033c8b82b7a7b031737035d8266c0b26a0d192a837bf52fb3b39ca974223a08795a8021a49714d4105beeb59c8ed2e0fb41ff7e4d6c6ee189828ccdd735f56e9692d046d2870cab642147c3cd5b8733e104fec1c1d4240e85fa84bfe1f8dd62468ed080b3c3f9b87402c6c0f4780c90d7a29f47fdee94bfaac2dcd443e011f17ce567b8ab5a1ea14c2ca6ff3a3343a8bddc4c599c0a92cd0fb2a271c8a71592c71b0d5c96877b4421260a48617daa875e32f89401735c42c6ee32a50aac0cc4ea268d0a59c1a704f8b5bffc30f9fe4cd613b91c1ed78c015f68305eb5d933de1056b11eb9ef9fea7ae87d83cefcb819d025c7b2e1c39e8242aba1ee1c36383f78d94467646061fc5f9eb86665bc3e0ca544094b4551ef2e2651776c172a4b4d3911be334e15865622136db19fe2e36c932e3adc657ba022fff4118de116035dad9e7b17e181dfbf1fbd23a618fe2ff8f8c791d435abf2afba043ef325f5dda5fe6697ee38c11c8d027510810cbf0022e531b8a52bf59f4b2a4a6dc7df2abb936a84b2357933422b79639ece9b77f6006d358bb3bbdeb54b122893f53b3e4a93cc7ea914ed61b7cf2fb6263f0c7647ce0139175015e2d5244be71578b3eb8144c8daa9eb70be6c1caf557417a97bb3ec8cd6e054f0d736ccf739359ccd0db5fcc1e1d11fb749f5a114a39436fb02e0eb954ec2df091298444f841505958d8e3d88bb0adbca607252ef291de598bc845d60d78f4ca4cf87eb027537dd9df4815359b592b5bb1ce2142ba8dba6737dcf65e916446f30f73859df269cc2341f1a7d37a8befc28f5aa002751e2a7fa581613447c64812c4619335249c3a1e0d31cf3438200c29bf2a2c71bab8e90eb4285251c8ab4d80e96ba67b037377773f24b199f369c1efaa42c458fcbd36e69947f6b1b86ffb70ad98d17a81a8572d30ac1f349ec64d705eba1731a787373a78477dc4356ba0c74b3d431624f9ff6cce0db87340fcdf84ac9a5f563bfb41dc1d26a76a913397639d4747d79743c8dd28a8c86c0aebefd5ba29aaa44b99c7d8a4623e0e1ee0120614cb279df7d5f8267d0729676f3ce785c3b6d4a158ff7b6491bd52241b26de31b125cce344344842a0498bd4ae3de8fc7a5154b183e0a2f495c8d67abe8e98bf020c2adc93dc0d68365ace4f1b36404ef9a30ccd51e6a5aecd1c5ab252aa636a081d355ee6034584b4fdf23f3526a6f62f942d706fbb2e051094fa4efbe91cd11f9d6ec85e772107f949290a868cff8cc220cd3e1b93a1d8768fd66d5b3bbbaaae049cb9eb71ec856434c3d0eaabeb92f42d37f0bb62b2812d71c7b5581f7e235da47ffabf5f0885e87984ddcb863414be887b7cfa1f0e2e70d4dfd5b11e0d841829a0821f537edf39c1173ec1d29ccd20d5b36d18340d6c140e9f4e45de3c339ce58001c918f43e5550aa6778946c2885298c2ef3618903ec2678cf37f9e3f3b3345731c63152c32d2e179524bfbd5a618c98aee7702ca173f790254a6bc4da16a020bd4d6f032d6c04b3c314a07b7bd286116d502880f3b93535d6e037771a60be12bef04b950b34af099773176c229802c2e0d9503437b5e8f755e2a2376877b71bffc045f157e855cd0b9beb7624f768401c63509872cb8e8e80e111f68e8eafb122e5360621047013556e28623df6ff300862bb1bb941cd218c1676b8f871e2431699bf20e78bf5478547bdbc1b225423d12dd189f08d1dba70a08a4b7a2dfbfae2c52c1102e3e5dabe608704412a1de9c10ca481c5a3c39030e36f48571e8a1b7b5e8ef80ac7e9dd6d592828a76615928af77d4a48e94bbb8d3561bc5e6187996cac2d22265648aebf7cb03beace35c034b822e318d7a9c174619a8211ecb497a3517b9d2581cc387f5f4d28371872703b73eee7285c6224e907ee0516f5e24bae92601af97f7c85b2e73c4d42dc552a3adbf917e7bcd50e4b023ae7d56afcbf90e922bbaad62077b34e3b58bc12106d1938e80a8aa6e6f9d0f325af5756f19100ce88eb5561d7a702e4dd4a5e1cd84776af30a39e66fdc6e3db20d114b78372a1e356a23799eec93cfba2a27fad3975c2d3ad3904a51b5999e8ca7c9c7bb06a15c43942a5040ddb8684a60079dd28868f997e249b8fbea557809ee905f9ca9cf0d8576eaebd149c375523e18d168a87e91e8342d7ad533ab21146e34ee3ce0579451495eee77f2d2e22b0c3c7078889be044896b3c64b8c856517d857c819b01f93a7233fe7de91885df883a8d5a831287255b5021338065644919b838a85d1a0b2f40587eb5e171c0f2d390e54749667729dd8fc34ea680af57fa734e67a460f071daba310067db484164ae0bb9fffc0deb99022cfebeadd6fc10a12e2904f70aea0e388f73c31c23d2ab72cb3851d622a1667ac7ed76e793379fc8cb88f50db6a8da8711251912b0c85c46c19e150c6a3d2b03ec314c779750fd8d501044f662b3e4736b8944cd9bc7efa262bb81bb242e471c8875545cd9b98195a3aaee93a68feccc93320e7a326697579953223097ed0f59a9f17cd9c5ed62055cf7f9f003799852e1fc17205dbf3ff61db98720298d9357a04e40493e516f828fa0a65a072cda22fac12548f1922931976def5fea0fd695a6c1d96c1a10717e838c5205b07777f3bd1477430da77484a20f339a43085f2da38e77983de212d9be10691b8385e2eeb245db8395f1548c58bd989ec987bbf37ddb1a47fc2d251bdcb7998fe427594cddec5b835e0336324d978566a3ee2deb95796a30d548b74ea24013ed145ae8003dab87974914f56b14c10ef0a835b6ad2a30971edc761eb37483cec112ffc41be360301cfc03a9318a30e6972ba4617b3e0be164be022e80d36f1e17b78b974a25391960f890a36d0186e89ff019be5bcb9d6a985e350c4f4c7676f8fb50911747291afdd3ae7bcba0d51a4cc1df67611286eee90dd9f4ba72144e135f2296274ae9e58d45f59b17fdb40f01de213fb8c1b3a9bdceb6f9b08e2ab89dc14543ca093d785ed24ce60ba03501b6d3c8f8b826ab49c24ae8c5e05a4bbd9e77c632b50389350c356bd3da72b7247541c18069f176f8b2befac271cf75852b7bfbf8f3cc678181c62a4e0160597c6387a053b57ffddc40c0bb1dc1db9da78fce7620a715022a9bbe9027e4616fa979e519477d3cea2ff1908ec663b603cee6afd3aea1823f29ca1fdbee4076334474cd0a309caf44447865a0a3888b7ab3b38a223e6dcb32179464fe0259382f3b970f5760a7704f65da5159546eb19b5284a61453cf613db630b8825c78699070741b76b89da7967534ee577a89c69f5888f63e4066d29d7a9fc983c39b86450bb8cfa904cf5fa282e82aaacad965240e1c725987b2b716bd089a940bafea2b55e7e9924be101f8d2ad481a86f74f7372c68942fe6e09499adb72f404c661f44d36f4faedd5283fdfa31b63663187a68ae7eae5b27f979dd198c05c2a4c95ece329b51c9829f0a0dedd56abb25f9fa463449dc73284c98f59a5091790c603b7eac68035f51e54270406fb81987071ff0f4e243b04bd7c468e3aab47837c58faad2f41bc391bd278c31c033f76a3e2e85a5571ba09f9beaec932cf32436d25c2b2214a2e4b45f83f7c4d741bcb1e628e98d50dc5cec0a885f4f2d29b6c60eaf49f7d81419cebba44765dba97d732f2663dfc61e8df3a597c721e7db973b58e90039fa8a321a72d160c2f3268d11d5aeca7a9c023830e5e1f14a6e13476f9a5a60c3f083cac4ee24a224f897d3530f68a7f3c93f125565302d3875c673f0ad3238f35b118cd96bd422799381767518e57ed396d55fff5015b3a00086bf44519828f2b4630eeabab1a7ae96fc57f6ac84cc8e5d494a072f9ef087c2fdaa843b0269aa9a4c5d7f627318491362a44ff30104a7d0d8861670af43d545c2990bbea3d994630c69bc46dc2b602608de2f8285b20cba33c843f90c9d751891649e1cbbba500ae43ea7877838ba67867c8f23e4e09ed6fd039b1f3e66e9df8f35fefd8c7549f8708a4cac59a58f56d46dc29ddbfbfc4c2aa513e26c229e7f52550b8606cbd0df8a43c4dd2c115c6f37a8a1a7e5f9d006e87536fca9d075200ad1bb70fdeb0c704b68a6fff01495010f0053962bcaf96e6d9b8ae27962a0f02ce2f08f870e9dca1ebb10689b325b6b7cf018c62d62cde6740cd82e583a3548805ca7438e690c53e89bc8b55bc4a28d95ef81f9813d6f2dc9b8993e5d3a5d1bce177f140f49d9dde82f34ab374ed78ec90e344e499a3b32388277507e8188fd8ae904ef8d0f341200a94aeb148019a21d341fcd57528afe2012c8f70324afecdfcba419dcb6a5a5156ea70c6a11f25739c88000a9ffdb3f7383ef181fb8915e22ff90ab9ed9234f68f4a84279d71ca42ffc655f3adc82b278744a1537554da0b7b7e626088269f5d156ea81f437605302cb038692cdbf2422151b3e3b2a510cf35dbe6f5658f7134b659e576289ddd16214fedaebb98e929285d41bf9372b6d449da921a67b9188adddbbc0979d02073676bef3b53bb40682cd17fa5708d771106c447b5d6d0bfaa7e6d1949fe1e3d7531ff5b324eb4fa94fc3c091406e02c963d394c7c22dc893f7c8c552a7d9f4e07afb7b44f5cb76accb38f2825c46db7e4984a6410cbf3a5b02fb86ae5abfe6c71e32cb69ada8bb6d747b365a18b3b99be259257c4d3a62db44a927eb95677694383aede7207787e9bc16f6438ba9dc99520fa28ff4c0bae6ef7a7efb1e94c9ec835b06f5363bee62cb1fe05124c9666c094ef2cc78fd8b4d86253a73952b5527291a6b9a62e44c678406b846b4f748073050080123142e6eb8d6a0f2170445241d0dd7d32411e90ca0d01067d5c556022b569e5976b4e5e3b6d071fe2ea035273f16e3fbf54dc7e7d279bbacff3214a5209a558e7389f26ad340bea7fab316aa455704fd73e779ec385f15b0df9bf035141ceebfd249c204b02f0cda5db9908189931b9dde3b588aa0524f64baa2fbc81c6e7aa6f921d3f9b2fc131a882bc92be6ae5d67c13559968cd1db76490e68e8dbb10736e1d9bdbd92c9932df1e8d5dae6418e39449d2611f1b7d6390553751bcc2ae1612c160f7b3ff4b7bd89c9ca91bf53b3344c044cdbb4dfdb1fa289eff8c1a3eab80a2b23797e42b56d51c51e2e3d63a22b073cae27a3f7ec6be99ee1fa11b08feb3378d59ea8f1978932f0894a674a907dbb9c4a5d5be3a8f91ac6eae2dfab71d193e35507eb3d062ab20871f14918047c3be4fc991b97bfa918843ead02853e96d39b9f5b6a51b5ce38a172f11345cb036da5582951260aa2b2b9ae77aa4a8a01c8e0e9bfa5f1263d339e1fed6cc07bd92b99e94a2a1078b664df793713ddc9a64b74b910d92cc22d0ab2e66c61d0a1a86cec2e9d145d8f0b316a245770b59ec65f6de83dfcb5a0e9a7575d0049a402e9a4b664816b13bbbe056e5e8a0e74bc1b9762a128c9ff9178241fb580001477c89f465af7c26800a7f8b0bb5dec0821329b6e143b9e56bd13a17bb5f7389c585d4eb997ed34e08969c2021c40f91febed5d3557a0bd3ff711645fd276485dc73d5839b4fe492371d879863f8238c6187d4996fd4c36e496fd147d2dbe9689742d588fae53dc55afa33b6b7e6f8f685576818458496bc5e6c999732eba850b286d0ceb6ac3a83452a8ce450b97214778c0cf8fe824dac68a15bff2c963d570097c382f9f5edc16eecf183a68fb21ee96d803cdf59cd01a876fed14130e18d55a37e7b6e1a858200a45d93a0800fec88a9b85eb26a7b7a202c8a19d8749e4bd25db9ba29e63bdb93c434253d551f82d275631540591891fb039db663d4ccb9a5c976a94b1d407bdaef475f488ac4f913eb7a2f5fc1012f21031f9c44409f78be520ce88df8930e50607ce579fc6be03f3425c4f4a8bead074090f1fbc69a843fbe4bac765a106593ff1f25df44698846472642a9609eda52e552e745aaa4b4afebe9057f8f855b09c9bb9778800492cf103ea482dfb3029418b6139165d5c93d7b6620061645c118b74a9a99a9a070cc5b68120b4ee9cde8d96afcd64ddc6e3f57af9c8de3795a8f9fbea14efd17ecb229644a8dc7541626c1bc0dcc1d2bc6f22b5132bea4d0c215ce4cb58299dec331c2180e56d7e5625712143046c0065667654fbff79b4b47733e48702a0e38b032bc46c14c6fe57f690db0a840d0eff336744dd950af8c0d48ef76ba4e78e62fc78bcbc28d81c4d2528e999514378ea92385734d0d8ffdd03a96311807168f4e2e912d46e754ed5c2b6ea8421804d512c90611ae27aacfbec057a3621042b76bf0bebeaf4651d9355a87bd596fa201f2af0b6af11863d6172d07fd9218c26554507d58b92ff5ebafe28dd5df8dc23444c777b8e71af84306a9b61379e61a01a29d29a40d2b4a85475bbee31b8768313c0d222afaa767d18576d3d7d105988c4b2ef63925c887ec8d8c168a00b562c0bcc73fe9ff53f1a66b75de2908b264b04396d3afe5d77cfadd6075ac028f53b9ca92c17afdb644e47282381fc87718a803314ad9ff445973e13501b1d92a310dd54bad4c4ea44c3eebb69a871fad1a5e29617fc3adb144fa8c37521770021c96b9e1993f535ece1a52b77c82ddbb04c20797140df5212374a5e087d1a3e1d525f2a6d3c6c21e63b97b9de388b35fe3cdeb4910e7c71e9374311acad4f6e0add0a9f5925b115bf32e2962edadd2ce246091f326e87a10d87d3505b8689380996a2bec6ccf6afe4f7bad96edad0f30256e70d280675c5deb1291624658e4039ea25a6fc4ec01792ec6fdd894288bacb427efe6bbd17a40e9cf2a16e1c900b75b880a17d1bf6e94a302e0bd786c9ee6efe29cdfb146c8de63f00723b918963794b8c3584634a721b1241becf83f685fd3589ac6e0e0a12d86fb41ad6ef48","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
