<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79083c4001607aff49fb6472700ef9f1e939892e5c7ab7396fc599c63a7125d1295db884310683832599021607d80c92a0e071518abbe266a7eb59dab637e980a12ff7c331e4fb187972284819e84280b5ff34168445c9998cf48e5dd288f5cae490c88f3f67d25aa0374f41b78202a5001e3eb220e2e83b3ec7337ede65418df9af05d5563d519758790e01addc1e01b45405e95c0a7a337c2de559a89d3e8683ab752591546f046ee9cd7eb301bae52e17479f00dda5339b5cdfdc5bc76b0c661cd1c0212d7f4d783cd7c4dbbb38f91484baeabbe9a97f4930a898d54182d69c2977e3144c102a1b66b9312175598115d9b052aefc9398a0a66453eab1b4bfa2f74c6885a59f26c8f38d01a2a19809c9b798b74d2a88db336f0bc14dcc9c80492c1aceba6c27b218097186ae64dd78a0a9b932749d5a692d60a62302c4d14ed5ca30f2415a92dbe41fe3700ce0b588b35d01d42a7551b64ccacd72bb68fd265bffff399e224cce78c3d49427898c11bcd0181b700c84a4a329b1a092e78fcc4f2c930f52b0fba870e9ac0d9ab20f1330492d32a9ae4bd3d10c55546401cfd73f0f9c1ff6394f38a4ddfa6ea071447c3034d1920588262df31a126f1ba35fba2bf46532a4ad986ab5fb36c6da540fc131657d6059b7acb10528aa2c49319bbb464b4ccab7a7f130ffc9255bb2e52f8d894691325d2a566178c4ee5c01346c1af6838e6632270b0ed88596799c6ac13bc2568bf27d56bfcca84d9fc1f1643d4893b14f547888d7473762dbe5beb89492fca49035bcf73ca7d0a7127767dbfc04c3fb6833079f04e0971d1fdd19fc37c4f0b6666a0e30f8950a2006459eb1900fceaed3f376814e81819a70ef2843c2be3342a0f766b788e9d31816d34f4d2bf98304e8acef58ccb8c1a56133e165e57f6491cc70f9691bed55bb05d4772c0305acdaaa360d39ef7d13d4cf374cbe8de846280cf6be536d9739121e8cba2b3baaf23e2b091a8ddbe30a799d501a8664b7188e933ef7e4c9a43ce0679021c260539714f973b45197a0a870f2114556eb2403aa8452e3a80e19031ec5979432b9c2059676d2f8974e2b179a2046a6ed06857de2b68a5c1fd16fedf8994d6a90f0b13af37642a89ed3049ada1ee05b49c8cb6d042f7efd8ccaba69d606837e3028615c93c0c307695f00283043093ea35bdfb8fc4b8b1c814f20684753ac4be9140520d08ee4c59b9d8cc918139aed1bbd7f79054cf2fae788d228fd3682fda400db85c94b36d208689a32c626488dad0a9106274f23b449d75a4983171583f402e222dbd3b44c1b901c6e7245c9315b84c21e4e44fbe7607d176c8a8df50e234e7a1c557c345cf1e57361ddc141037be356409916a47a3f3a7cd17b3bbb8f828d2228764ed7bc1d7d8d052e413d0feaebcc2d4a02845d2eee7384e2f4262df9749260f097be37a01ab966088b78c3477e1da6efd6e1b1e9bf514f8eb0e353bbb4fda43adb5739dcad8f1694bb35aa51b430b15bc7ff6084ce2adafbd4bdaf02b55e7380ccb4c4a3902c8f9a28417c66389cc5900c1013fcdb4daffce4f6334a22395a907f5d2d4cde7c79f6d3aef4791b3f4dc0176e331a0f44d5496d7b0749420f24cf432b3c0eb1beca11d4ed0e5de54793ca0011dff33c551ae83830f8a3f3eb15ccc4c59cbe145e9406601507212565bc8fa1d28564ce58de933f12280dff67624f049a380cee6ed53fc262236868c31f142e15cb1b2b1cf6e389bd93c189b44185257e663aa112f6636ede24cc667da1abb51a305866a969ce8b01552b0df7ec382cb74b9f5e405f95e7c01ad32b0f9f1ea306713f943ecc709051d20c7cd6af31b2e99b5c0bd33dc5e84aa68a6f50015245cf08701b9bf57879f47a9d1307fe0c8cb29c54fb802029c87b6f86728248cf5575ebf3e14cb820c7ec0ddf9996795818ecd520b2f7e6058538c5785415f430841d67c9d31cdd5488a087f8c406e93938426966ae182efb8ca8f9b54ca17517bfbfba5ffb448ac65b8d9e8fc61218b73c7352bbf7499417a9b0de21d46c69915e1676e10480c6c51fa6e4192369f4ab9f76e4957e238abb5a595e1af691ad39316bfc444fdb2bc863f766cb7368daeb6a3735424ce9a4c857e72438def7595a23b891824e76963f76a3abfca3b815ff92b84692e1af2cfddf5221aa1eeb9ee8bab8e6681da19743c26d73d4d7f2aaead41b876470fdb12c06349686256388af446fe5c87169cff9fb52cd9242c6c797d84147d090b9c0cebfd9cb1c0ba5e276599782daf4ec156c81b40917c9d7adfae2b26447d534393257dda3dc79bd3fae25a19c6622a833d5c551da3150c29b304845827bcc448eb109515fc4361454aa6a3b2febef9ba73d10d8e621593c89678147982f03a6b756c6e9e400553c8f25d91058e3d9370b1952a06909038ea84527ad4a510d0f3b5ef8aa8e8310b4cb2020d353561ef4d7f3d18cbc836b0c165ce3ca98e88c49668a035d4149459e0489793966c20268c2be0f2495e541df246c6c882e19de5000b888e4ddbd4f3e9594e9e042667b3864b2cdabb4c744fec6c078d714c3e419fffed6320e733c3f7cfcee966a6b72864b42ad38fca2618e4a5eb588f4b42aaa2f9d23719b246435645e9556adc1b797e2cf3bc1626409eb113d97be02933986b42af18415380b134da585eafa795e5033d38eb152b5ec5ccc8e7a7148aa7c64fa6ae342b7af096c936212dc5fd8fe4bcf2c9b41ab8fba433a68b1a647d80b1c6d00a7f2d2e0d087b819ce212f7c99446494bad6ad3b74a4cf3594543f95cf30a9e63e8e30a2faa9504e444a2670b9ec0311aca6a9c52434cbfb7f06bfbd2b8c7ffeb785ec026b73da4d626d7a48baf40ca9f7330f04c311c827aa7c38f7425145fc19cc3b2cdfd7c05166db7882924d68dd621b56a35175d52f8ded71ecf720619898d1286be1a32e743a81bdafb2778ffbc14a9da8266bd64bc63af20691f8b9445f06650948b99cfa8bf9a2b55ada6f5d2602e0f11f1cd8683d5b2a6a88f64b9c0d07452bfb81c1cdbac68df5771bd5442fbb5adaf4d7a72558f25aa5255fce84ae14298febf7e6f1cc7eac6bacdb2f9f07eca78cff7789b91d311e065dcbb050c6709682b1a7b011b1104b91ca448aac8bd9c885643429dc51c4799fc592969012882e8ebc22170d7f6f24617b1207d1e944cfee9bc4301a888e94284be8ebb84272a5b5b1ac0722ea9bc290b92bff6ae3b51157b43060e0565c11542851633d1d55b417904b16e59de9d77dc7e4ad21d367ee2ccfcb2a0ef71244750d59499788f75daf0509f05b2deb035fdec7ed47778eeb44270a19fd98855582e37b13e8ac9c4eb91a08aaea3598ca2059f993039e0700ad099c45bb8365b5e351ff929e68a03ea52352acf05c3f6e0c7ec426dae12063a1f21ae6f38422fb366f85d62f9a51f55f447b3d98722a3764c783557e56cc8e8505c90ac5929c04abd8646bb2e87d320b9caffa9e1daf9d71627dc12af364018b6c5bb9a1a474b7800830bbac2ca22ee22b2ad9be571e3fd1d73330e8660716ce4156ca93e234142d706943d86257c9d65f8b075d988b0c41ff1091ceb60ff7c5dec60825c8a4248b4d7104db8e4c5aba4324d28a9c1668dbcd52f184ec9acda730557c17b341e21bdfce3d6265b9a373a75b82beb9b91ce38e3768324c2b696278ac03bbecfb8e1eb1030aa7b88bd0b4e14c709e9efd6ea4b3f56002d9142d2894ced32319a14f01467045245d224a9b125a9f385d4ced63159a8899dc5397d473be9a28579805b5b5a7495084d214f1fe2ceff1a777b8b0e69cdcff4d600c64e8092d2e5f30b1afa0024ae52759a35a7cda80c54344fb1a119a00fdbfc1a01e74b73b023df8c9180af219692cd16de5bbe9d1c59325b2460b697f5795bb37e18d5deb3c73f4b0d1285dbd758eeda4d1549ffcc5ba88fb7d1889afff2f0d95debe20acecd50d2be5e8c6b37be6340a00eb21ffc7ff160447d8d4a08e1677d349bc5ee3324598259331a76a8c6da507077cee884a14522821455fee7cccf8bbb02c87c8be776c43bf75146e845fea986f8e1039e84ff21fb58ffc9e6dfb82451ae9ace7433c9f88b89a2e12a222fda29c6b0915695ff0cd418a85c148cb1ca3ae88a7b78a41119f53880fea03413578275f9aab2838bf52f2a4316636240bf58aea0f73a9117d5d3a4c83e15bf06e57749a66eb4cd17f9b1bf525ad2f84d1aef93d07f071116cf3ae38d1284e026df2aa9b3fe7454fe19e81745b85161c235c6d79f67e7ea8d5df0dac77a050e9b3ff7769a39bb40ca12b9b9a31ab3922b174fc85ccf1674afcff69266d46907669d65cab11a78af90b2367baa3b5ff6107b608d7bc701c2d5d211925f1142ac5888d6dd111d1204461de1507495ac8993054065f4ba0dfa2c3a852299fccde0777428e813c801e2c4c3236cadc2585f5f220ed6d6001c9b606fba6168baf4f7f999fbf08221affb1d6dd3f92042bbda140baf9e2edce363065256c93495791f6833acc2e5684c7a1005e48e08edfefff2db1d63bb05538525217cf5bab9a26c0418c8a5bc05c78c3b5e59e1f77bab0e4f565fc522735618dc3f38f58a2044f92b7831cf6fea53c938da980e06ba4a10444fb47de43992830ac7a3d84a298d576c7838dc359eb29533515c23929a31959d39109da2939b8e5792307a2a1c439dff51e0bab675edf77a8334677b59031ceab2c786d38d74eabdde63444986b99f5ac5d480448baffc468eab13b874f10663aaa2d6596a4864948959de548dbfce4f6453443b1edbe814575cc6d26392e3aa973255f438942a102d27bae6ca295c9a56538d734b74d9498d7f69cd5ba3e74a417d8ac7d2b2bcdf4cc0b474258fe126917da1a8c5ffed6356b4420a79d9a290049662aa094c60012c0ca8b353f8c7ff6b9d909fc22158ffbae409907e92a2558dcd22cd58cd32659ae6897975258ca25e3d610432b1138aa01849348a2a58f7e909b76a28f7ee3829e798c74771c7329f60ace734bff5d6ddad27652760a5e76aa1b04aa5a76c8b9722f9d4854bf2dbed909cb44d8f7ff52b98b6c9be96cfaa1445a3db9618dc133119711c504a4c16783b214b8676d823e6381ff7b7cd12b1f001a2322a2bc9d4f7f1ca65b4232762080f8e32fe068817df9d5ae728419557997cbca58876dd4c90334e90fd6139055c023596f34b623798857f4a3b2cd3e0ce8b02792827477d99aba7eb06c5f114fb0f778e6d375a52796b3fb16e1f3f7bf98d5a19a06755a87cea8d74cf38b65db1ca06f970d4bdb98f2e05c41610d9d23ae4dbff342af95b878389b405e0cf859943259686078156b405f9f03d000ff33b418dfaa46d9be93e5d9f0d8edbb7be2e05d04fe38961aeec5f117fbc6bea2e7fdf3d8529cdc6e24f7256b08f9c53498974016db9a3489377d8090c33baab10a77fb2484d7e871869885436d767128db1256140fa5a7f34fac9a50c3d09ed896864c482f41b4a33c1ae9de1c36071681baf9be83e615c2120e38e9634bfe87e06bcaf8d6d25126e6781d2c48e377e1cf49941653b7d7d96dcf142248c7c876094a98a6fc574aec5cb991a28a8b7e5cbab47c138644db1bbae091ad64a15001f892999a93e0fe7f0dbc72746ab65a6647ab9b9b6baf3fbf40660632b81a8356cc05eb91205c1c29404f9408cd86c8c42b9a9997598d2f09ce04b57ca85343322f934f9d57a3fc63d7aaa6e50801b6466d790927a080ec5fc2b8a16bdccd0e5edb493063b97c4550f9b9a5c4d31169e4dc5e6792d8ce07fb723c6ebe7f481006372c1a2c4990f52dfbf79fea6c78ae6249a02eded7c45b391f558d3af151ed112e945eac580b87c04694d50f7a63d8f2814ad23e4f8c404db9499888a2e897645df1fa5f9b1056c9f3f58f52750d24695354ee30d076a6a035b45c7a4f29f6b999aaca54c6c7964d3485e772a73ed7df805c37d90cbbc97bb7ca9a5425c4275b52592a91b971e098196580bfc5a80e3a5a224b3072f0ec87bd1d2acee45df9d5007f6f9909b3be84e7b20c61fa69b98afdd2436f75828b7884d7f70bd59a4db42e71dcece6f0c4d9029f1e81259a4c52fb4d9412ccb088f7cfd95c7f14bba027d585a65001ba2720a17dcaf81adbea38fcd91adadc58f944a2595574918c605eb38fe8856cb440a6ae74b593f169a546edd604076da0c839fc866cbbd4d680ff1bae4ad3f7caf00a0d25e5f4b13ebaf7bd1c9d84810fd2ca0150021ff9fc0069f1c5410938127245e6b4d5da214695aec8a2eef4815d9713dae18195f28dbf007ae3e21d1a97a719a3fe82dc4436ee9488775acd3f7ac152a970c4d47377bde12120c33d8181177fc5cc0193619d598678047ffdc740c7dcc87b549f8a5dd1d4953067a552022a064a343fd22702e14bf0544125c41347a33aa6cb48d3cb49d20a09a9f744152f1d9391462f9d2fbfa5f63d9c491e3d774afd47b092b7c69847fd23c8e5d469470ca5ca1cdb387e2cddbfaf228686b20fb72328612cd5a625293dbb344cb5a9f37ecac1b41852757c7ef5f042fad3de18110fabd82ca1285e882d41674128d29c13fc5a90b1e9e9cdf79a7fc5f02b371c552c748dc1b21c9a9a8be2c71f31099d521bd89980fac3538ae2767868f0e9b9a207ab245821e30ebdf298c895cd7a968ba80fd90d38c6ec0dc01cf5d1fbca424cc6d008967e11759442ed32a799e183bf2c6f5657c662866fd1c39e78199c47d1957c82b32ee50b8c444ce54980d435dfcedda4816f8d7638526cdd6f0484ebe8ed712d350b546dfaaa938db36788dc2a52b95afc1490df7c6f8ec276c260591883adbee436404b19edd6f6900c217fe4e99b3ce8fe16775032391c394798f4e728f28d9c1fa79fe6c86eb0c722609bd4baf2cfa3a56a870dd74b016a4be9227ed5fa55be2ffe59f746858b5998b871c051d0af618c9d735dfcccb19fe6598941ec11b36f22fa82ce28e03894b2d93537aa2c7bf114eaa4396438abc33db0646e602196040f3e13238309a77d3379372ddb8ea2a7988b3da8501bc27d4352b19b60617f909da978ce87b10e02968df43f2af96b1bb5ff95397b8aa9f7745a17cda5533e02983a6b4e24985548d4c35eb1776d17b1376772f1c3dc75f7547af402127cc28e7212490fb27bca7104f8a72daa71561906ac984d3cc183ba79cde1ba284b401c712863442b6e85746b694b7de9e132c9d58984d305692c73ca3e4f6d333494ce3354c10eee7d2792b591b9f2741845d32fda27473ba5d839a8e2227e26a38f12d751b4425d5c7b4bf326a94a82f1e17e800d6ea85f2367565370f39d68a97cf8be196c1f0936746189725d7f9b101522e7d108ced4214a7b97fb99b13aabd6dd40739c48d1e90ad0ec3a9dbfc0615daf85a1e63e02eaece570781f0d70d2ca47170774a1622633290ab458f607623966c50cda86510f66f8cb55617f4739e69b9ea823655aa20f9345846a859fd397d216e3f698c0e50778331f9525f070276059ab1b26ef61b889a6b4a0ec8ff038892a7035b4eb4a1614e301f9c835328d2aea5e3477b5a322ccc3c5617d74fa1ebdffce4651b6dae83900d9bb272e3e04b7f9c8c2db10aa5982dbfd975877908140b617d6c25cf9d76b9f21f77341c98fecb584ba1acc7e9a8a21ce6d05bdc3084784d22e8036d7befb02629edff17e48035e8010f41135cdbfb213925f485e156e0a592cd7c7afa4476ae8bf86d9b64a2a5f0a302591c775c74e6ef6dbc34210d5179858da28ced78c4418efc0bc27affd61270d6e2ff84cf710aac1eee589a16c61a4a1f7f5901c0d534c224c61ffca48b295b03d73e62ac97472c90271ae7f66c49cba1b13fb1ed65a2a138a41b6df9349459c10d9bfc49fce628959d19df6bfabaadf5fc768715b341595fa5a74f656224e878cff56d2797594e0f15bc1cf4d54486489aef2043ffb33dee063ac065d8b60c85ddce5a3061c09b1bbf04c14f20f318ff4613c05ac17fd7c260f02d780d1e6c86c8e11ee6409a15eeace903ecbb7f31ca9a395d6704f7272c96ad0ae80be4f10edf14ae56c91be2e31fa1015525aa7cae18f815ee70156d197912a912ec300ca1b2874c29fdd8850e15a00be3dc5d40b9ef5b3684a109e6fab8b73ddd3fea24c14e38a0bfa28d98a13703714fd1a9ef394eb6bce4c52dcc3bdb0666404e70463995556d835f15c6d0b68714ee0842273f4f3d20ed232e051865e107a31aeafe970688f1a082eea24363f48f4cdf3e0d9416a3c3ae7947ab79971f79b8affffecc9049e836a4128081a36cd750eb6dbb48722b4a0e2812564e6a5f49cb5f4d23c46e966bc902d8536f39dcbd23ecc00546704a483e57634b515cdfb2fd4051430184674665120298530da583c43902bb357637a7733f0ccdff93b10a3a642d41669946341dcd1fd4c4ea4f94c28a76ec33ed26eb981491bc41efd7ac4b9d4bf1d289ffaddcb28b4706131f9e1773e3f1ddbefeba6017d802d806bab4dc3ce2157e67d5350660e593dda87e6a19fb1cdca14c18d4af747bc280afd291f357da54d972d78da22384795b7ad308a36feccc1df8460ce323f3a35b52bdf00f10ee934fa30cd36ec748d5084101568a249dcfedbd6229130b1be8e851ac0d4aa409f6c1eea7b7f47a0364ad4862c7a9866dadbcc39e2e5a2ca31e1b69bda80fc774255176fd3acdd936df1c6a41d07893737598153d61c181c0e73fd4bd37ad10e95410c4ca43a423f7d1fa9da8ddb692666fba03c67fa5cfd1acf3babfa6faa96d943264665b3bbc132a8ca89ade54723f7888468019958144b29cd7f5117328574ec82fccec26f7ef299cfbaf8d06bd512d5161cd5de20d16276022779a2e4fe0ba3918f618bfd1bc9c6b46f601b6b74658e623598e9ec7924990516511f8659d7338623db1c05eb1ae7c3157c3a305eb8a4fa7abefeb0b10c05be92ee86a97dc4dae3ef5b9047c17fb2a3fbca175238a0cf0a3b12014c2047b263b477d502ba04113830f41d1cf648448cc0c9b9fbc48b75647c83f3cccdf5cee2334135f864e972eff7656583d0808f65f95af0488cdb1d3a1544798303ba4c7d19da32dd49b805bdb8b880051a35be9df9a798249d5bc14c9c7de05df44d7ab2ba7761a8ed997ac99cda6c4d9e22d8d1e76f645af68901f8cebd0e8fd50bcbe6c5b54152c4aa15609f3306cf4af13f9b9b4278932f183ee0a7c68ee66eb793c4ff432cafb1c84841565e7ea453f55c2b7f663a36db53bdd3433ea93dab1e2ccd16f3d0e7a8e210843849cef80d57586b58f219d8f8bde227189aeac666048726fce9877354f19ccc6943ba74e10ecac1c5b2b7f0b29040507ca0c0770d3604dd007684407cde452a3b9803debd29fdf568a28864c8fac27b67f8607c644614ba6f01e25c18403d01a3aa86f2779b5faebdb167df0b3c2f3314c95f183c31917109ae67b48a9b4d6142ce5bf436d62097700a9a85ed163cb9a847baccfa78aca751817d4aa723c7091f42b7ea6c3386ffac7d696f4e8b26e08b4703631b982e5cc9f2ada12ad9956909180d5ef04ca632733794e2869246a0ccbc72a5b397b7d8fde2b76ae47081d754bc9f0902ff50b0797b5165c521a6bd2125cc96ffed16162032e8116283bef52bc42983a83c35900f7221710a0d176d1a181390f4d392ad754ea1ad02d786c98fa29961a63ac88b562ab4ef9cfe39546ef4806dcf42ce78e38789d0c174ea953bd1de12e433a9e3d59283ad111e299791b950e14203d805301189e3110ed7b262cf2114130514840625c42d4e0472ab51af2c31ee989c91c4b481f3b43d4b4d569bb064843fa90af60eca871909e2e5ec5f9f21325fac668d674ed5e38935a93d3498bacc72e42605d42b0588255c5ea595ba9849a240ac75c8bdba0751d532ebed6fe4ebceece588c8d3830d4e566d15f798168af6dc1d9a11051264e31c283724df941c3b225432d4679ae1cb103c0fe92ee9feae2abcd8797c13ca43098427c3cb2cb6885c62c80628848cca68496b89d48f4bc2381e498b4f5e10ee879554cb3713e5487abc4aaab0c21b2b57c6c9947efdc014bacc8297f1c5d1b56b1dc9afdad7705246e9407f4fc36bfede1ee53efc88af1c8dcfd0d583816789ed57b9081b541505032a02dafab51ac7a185d718fdcc6578f4d60918ee3ebf79b0bbc43b4c09bf71adbc7d89f6167673eef771f8090978d242b4cb943a41cfed664efed69e8bf0661bb1b5d419161c45d0077a438a8df72a56ad14e468139d7a3152d35f4510b072deeb70b66000b5e213459c90811d8ce205053562e8e62090e7cf164291e01c371adde8309c7217580898b7901b7cfecb6118ef805d05c2ef78a139279fe9df4a42abee705188e364be4de3d3f9b83605218831abe23ecf4b65d6f595c8c8a45226d3fc24e7f3805ed13dd4038aa1860f5e4a1d12cf7a8d5c402ae08f23ff608f7dfb6f12ab2abface29b2e59c020554ab00794ac855173f6ed276046fd0f7700dfdab1292f5dceef346d29dc3558015ad01eb1a054c985f426bcb8014e11d210269669847c97ae65fecd4850acbab8b1b588f44eba5eeffc57e2d5fa460158c4444cefa3d9f8545e38a0d9a98f6e5f7644bc6f88753c1d78baa274b5feddf5e77b5a3b2e71e8ff1e8724a487c99c76deb2acf8fafda5fb126c725fcab2002286bac31b74a1121216b3ac8ee784304ad7148e664e1798653650aac98426c01706a9c13b18e56efc06f2c37f62a92100aeb8caefcf45283c58e749563114420c2a5b3701d72bffbdaa4c69d25f312bb06829202331f6bd19b88d009425f5b1cd1b9104aa37da6537ce3636ef00bfe8eeef478a4a0dc97773998576563855d838d12cb67eff3af3916cc4327ab2bfcfb7fca6da9ef75557b94de2fabb6fa8cf2229489195eac51ae8ec221758c65e8d92e7b65803b521c9ab002541c9d969668bddfd6a5cdf42d1c88899800f91da167f1c2400a5858d0637015103a7b2f6c4b309cb3d21e9dd8ca751d90a9373a1a254f0f6c5ed85d39e11f1f2f96647b995882264817a287e9f386d2ad6444ed0d664c371e94ce6dd1860fcc9f2c37b3213d19a8c501e15e388618ef38b7adffefe975b009b3d5935a25621c9588385e64c0646a4dd72743b3617ae96a12d46eab0f986366e2fcbd24b15b5c6fba7c4ad6af59c13acf79a163d51406bb1c4e1b2fed59325d0aadf8a24acfe57bf9b2e844faba556bf41711fdbdbdc8091e480a85d20b37a3acdfe824ff1b28cb491e85dcd4b3d1c1316348534028f80bf8340cb838d95c0a6abc6019074e49e6bcd2d8f6431bb531289b8114dfe31df0fbd61a9747e9dc897ee5684bd474724a2d48f79eb8c7a51949bf4d49aa72355827140cefb1480ba82f01e49c1b1d8553058c4956ae7c7f97719f295dc31c7c0e1541381747385ff5f619a0be9856a181dcec35ed3412204a582264ee416ea538aaa7e69310e2410edb3ca7c4b25d067b2632335603b6c5f1ade75cad24149b3acbe9c73cf740161d8462d99b63baac91c3d3b06fa85d5095fff0aa6b628a66138cab86fb9f0be1e852b03f0c59c8f94e456a83a290cd1cc389095a771842db7d66213f8d36825aecb79e013a896cc53d8bc67a4460b384552003ac06bbae847fb03648b0011ee5b3804f23d519c6274b9fdfec044e43d58e2853d417c61ebe4441558a72899c857fb5ef2c2c874a36297754f403e8b997e5556d3021098dda7261d88662e822573b8c2ad4b3de30bee4ee45aacb0b0ed3db3b63f9834cf513b996da43aa9f4229a6b8f9a5e30974f5fedc4be8d4124d126535ab2e5f786c96e8da3486fc54d7ca53a032ac53d7c46053b181b7053060d24f909e99ce85b76e1a0b106d6a06416dca52485266bd42828040aed00de3bc62b289768c79d801a2c216cbafa1a9088bd96de1cccd134b16d25e101d11a869f86a801025f785cfbf91d1033365a33b36f60592ef86bd578ebd923a23d800999848513d87056ad9b7f2506952ac693d0660aa10e439a9cd5bc01480e450d8f2606929845b3967776603723c0ce73340b439a5fd70821942a0d4a06983a11049786d796970bc6967a74f86ad098c24ffbd08fdb84c3d98c42cf94369c701204425ae34c49011ffbde51bfbef4c7056f88329a4f76e96383236a9b473f4f47e82565184b2dc98e09776396d7119b9cec723688a4e2bce375864cac646ab525aa8f940d80e08acc1ffb46ed4da0d209a3c8ebf409d3f9277a82f375402ce84b3120482ae46659d811078c02b4a0e9910c0b5add63c26bdecb771ceb758d43499f81813fc66cea54f2d17cf4a82a616a03d64a8338f95ab65290f51be41aa65238a3e3cf668b87a21cd7806ca3c040503dc3fafa4443288cc268fb09a839ae6b20aadce6b9b3a54ef17c3f4399e4caee28ff3dd59db65ce08f2c0c1ab48927403ea6cd38451a4b5ac16ddd6486e4ffffc3d545a0b280c687aded467c8a45d43b005b7b6d740f7b8c9d63fe17ee04902194ed67246ace5c7fb53bcfa2189e467b8bc55a527ebf1f9b8cc97a560af24100c8f4ec11b0d9f89bc9283ba11d017e19d28ad8e5719c3d50b45a6e1f38fedd5250a489ccc647707550ee9e7cb0653fc544d57132471b731d7036fefff80609822e549bfb642a336b5f447a5df9a2b10c1b07dcde190558a1b99095948e2429798d989f76b620d5ceb323abf69474c70557543c9dbfbc16660d1b9ebd25bf68ade1f9e995c2c51063dc21f3128fa541cc0d6eafcf393f0796ae3ddca3c0d6d3d40dfe07131d29873561a4513dbc63e1839d9ad561aab0bce2fd0c4dd9433c71c413a0fb96ea554e69b24e4c976471bab52273ed00b04fc64a3b285a63c7db089177b1f2820430eea76b4b8b8a03e48710c6509bec90995689e91dc0b8489eca214db6189bb10681b506f236bfc88f9c1ce8fca62195d5f94ec17af8671d512e9af285217f9918129122a2f10f250f24f809233954371da2eea763809b8442081b89f2f2fc1acf09d2ca06157f63d334250e1a55a205873e8230858c43b8eda01f1e3bdafd8cdcee0bdf82f30ff92012a3aeddc5edc80f5a149db390b5eb833b76c22290a026bee81c6a69c86ff5ffe7315a5be73c38830eb485e628d409736fa28eac6ea06d6990c5db4d9eeb60d075b86dda5bd782d06613c19d5ff9b7f1d57e34869f570911fbc10a2f6503e8a5736a32783dc187c1604fa3e14514fc2a47f86dd44a8b75bd8a0e55ed3a47b7e3c2cba8c8dcd7b65a66ec9f6a5fe1e23bb568a6f267ac7e702e2793cbb07fd0bf8c1d144ed73ca53cf4f7baf7f4fcfd033420ba169040403e5035fa91a9363b4a972f3954420a54d644ced70d31247993a7b2ccf5bad23a56290e0b6b09c22d0a3c39370659311c13671d944bd206d8aa8087305c79f39ba0822b458a2626381626686ffae84c9a7c340552268e1d6064cd4bab27f32948a5c5f1052a15cc89dc333ad5a245becd4a7d45b25f446a1bffa3d7ad4391c47e047fcb19723be3e96bbe5fffb741a26173d4de6a4a1d19f72064e276729e6bccb549b03bd4fa1728ac4811dd3690911c60131ce8a7c462d925cc88a6d866187a9bc34f6b698ff22a81706ea5606ce08ca1fe1b3f85f9136ebf3607ee1f8b6cfb030e86967c4c7d49bfceb8206ff7ef59b689004dca196b915a6ff25e27791e8e8c4c78a446b6190027f56335139b54df8f6606e5a7dbc691de56678ac7f33040c750ef17797a4573af7dcdefb28dc859b16c97b885d807f583689a15f5774b4f7a6dc90a2b9f51197dec74a40c7b58d2be38ea3105bc28e5853fb2b24a87b7b59f0166cf9ba18522a398764e802d897fca71c5e31362ebb442c3a6dac638767135bd0cc3b5889c57dc903be2bff0e6ee4150ba512804d79882803657cb45bfb9be423a895bd10efe0bc683f46ddf4791f456a426d823ea123697f7ae0c7f2d4c2950ab8daa719afd1851799e3c3f67ebe69c04d2276e890e23fe99fc2b0fe72ecdb74c6ccd95179fca70454476ec1bfeceacf18b90e324fb36e59357828db939bec8fdd88115ff6d116d4c7871523e09dbadcfe5b5e35dd7ee7f86069243f82b139e3cfc8bab04e2e333a74953dbdd432e1a2634a9c7bf73785cb54763d15979036112e3d1a347c30369c38aa81bf6b524f57c7be2431778c48f1a4d4d374eaf0fb5ca6058a960f49d0709cd90ef8cbba53c6ab330fd52913faab9d53034fb48a566d68ac677471ea60b8fca0f6550240d7a11c11b7ec583527716c242449981f2413ec3b5e52e863beb26e6b4f52b732de77956fd68cfbe04ee79e568ef02214b71417c70598bfc91403b8dde2fa5cce5e24a546c061d091a123ea7ca04dd54488fbe87726cbfdf2e9a6808e1f82596d9977c24e86760561cc22126ada32f404e3c1fc4f2536a1b87be5577a6929df7bd8fbd2efbc3cc4ec752d617688404c03e664d78bb907ffc2a1f3df0ac60d959bbf7276c58077d9b05f12a27945dd295575c9a514af9d25b777c72c6395f455985a6d38f447efd3c17d53938a680475772c1f4ffea42196c7acddeec16ef33ba7edeafcb2681a57cfcbdb55da5e5ed1e2420d1cf4188dc01a68ac78387546ba6c960b9676f76341e8e5f4987689fbb857bd3c0a198c1e82b763ae30a023365da55c6c8efb1c29c279f1226d405fdf013efc76e5af326e45b7b94aacaf08636290ef83aeb71a93ce83b5fbfb92e5827b79228141901668e6105b1fd73516c15f23e7e36796a4b044ef88afe6ac27615c1c22eb1ee48c5a7724fc7008958c3b7d9496a3b72b798f4e68b5535143aa42c726b8d6e32e4d90112bd6874af08b15b5fd2be34e6a0afe5730e5dab039ae5ec8169828846c2b93c93a02d65016a2a7ab95068eac96c94445a904ce2bc18c46ad4579832f4aafa8938e15fadb9b3a14e51f9fb4da815cca88a62a6aa79630138750c3bc327ed079ab299fd3d6baaadfb0e8b0502e80b5d50f59f9f0deb039a2e1ddd803d41a72e20223a6cdefa086681bcff72b02d04edf15948bd21b39b1c8c3ac24d87c9e1f8845eb82b0545b9545cdcd0c537826e5276e6fa817967fa26967496988a1b355934c3a2ddf974574c4b7715b0f373654b5ec23690b3c2a6148172838810a68a56cc7bced04edbf19c46517d0205bbf094c73f90fe86b69c4e2d8fa83845f66f39bbcca6b3c42c2e46eb949a71d221b56a0f3df13df101a8ce584b241dd824f0eb82b9b71210bc42ed6ebce730f7467decb1cf82862683104ff960650444119d10de6d80c4cc14d90ecd2add51d2c995ee3bd943bcd2e923435fe055270c80271ecfc98e4729a20376bb3f6fd39225555964158848fe61084eb2b18b7c180d288865f57ff39a3b43416aa3ff3234bf32e166c05263c668522dd83c43ef33ac771e745934bd5af310ed0d4774a337223eacadaac097ffb2150c422e194576a39286873f0c686c6a927d237d1ff4d9f4df5321cea6dd6448298449ab4d3f6749f2b43b4aea6c96087f374b04921fba8b759f9dbc1449e627e3ec378c7d655581839a2a3af8ab2b723124ed1b049f005ebd4c75d7f57db4d474d589cfb4e47b9313b80f46d3229544f7cf6f85670cb906a0ce95aaaac77900def03f4ce4af4f805e166118a65c60eb226fd416a434371d86a7b5a1697c5ceb9b5b5df6a647dfe75aa553b47e6bc0f3132dbc56a724b0ce6d5fb191966281258fa03d9d991566e10a1bb476f7745ae15480e65ceec7c0a816e41c700e6b6cb6224371110bb60451836b0c87b0742f0d7bb5ff744216155f6a640aea42a0ac6c42bf979ec14487929e6895d3fa25f58a7b01d5da713b98ce9ff1cbd818e41c55037fe89c60947c3de38f7c98713f7907a526f406a693a9e5b045825748312bb895b220cbf5ec03325137617315668d45e99c37629af960329542e6129a16d057e141ac27bed8fa2102aea68c3698cbdeb3184f26e24a0ad20ae30c5b45f4cd9390c5522f926733ce8f2a2c8b85a57867fb5757d353416bdf25155e75731a8d394ecdcefc629def7933627ebeaf30be6f9893e8678530c408bfced7fefe23c380b835cef518cdf6e0124df97ec0a76485e6c361032425d8d57fdb4aec8bc2f1bf3a4170f78b6526b101beb4096dd24fe744548d63cb3b7d4a1946b9a18422f0fc71d4fb191ce61b8b10139ed81b875cfcfdd793f6c80eaa89ad4fd80776c4e99e238d1030d0af20deecd9cc6578ce9df8577c7098bced4828f79808d1f2511d129d163fc41730be3aca147c6698301fd077858778eb2d40d28dd43e7b2f80c8541d3df26ff86637751e32e8cfd2aa2100c27296d01cee70ba82cd53efaf73804ca25e95ee1356956cc59bad55a113c088bc3fa0d250b4fe41513488545106a61b940f6c27b9207d405f50013c99fe1522649bbed53d3f331f806f9575a882607a9f149539b7533de29d2a62dda76dcfb2ba6b915f38108806c136632cf2d6a95a9c24c485bceed3ea0afcd5af4539137eba2116f9e49d4ce4a0cf58c0adbba09af509d7fb44e5b2a21261f6458e473f3cc1df24660914f61f73f0a45b764f198574c7dfc6fdd02e4d7ac7a165403e9ad4ce2cd78ee00f27d5dd88849b4232aca0ab4e9947295037ef2f66e214bd027b8566c8cece31d4de988bb5b2fc301a4374a94a4c2c010b71eb45a8919d0a2c43ed6c50ec2f4c752f51db61692c84dff34fe49205e79729bfbed4bc28ef579315cbab792a7c974042d1a72ab59c8ae2bdd4237c6268da8641a8dd8fa74e87dc55a09bd579e8b7e36cb8c9cc982c9ef44c22fe0f778b2d9b34ad888fbf5c7fdddb5933727fcd42f389aa5d9202bbe8126cb1dbf63e92613d36c24615e963d074a524cff83c331d68ca284bd070ebff87e19e44dab264a84ed0a7211716d7db4e628661039d28a4a1fd5683359a6f85b4e08d89bea4cc57287089fc98dccf9da71be983632b8d50bd3dff43bbef0bffee93210cbb578bb60bd062b361f835366bc34b52df909b7a8c51ea1768bc7f5ea76cd1d8d8c0c8fa0b63ef019c0f66a3750b61b9441d7c58d6fd529fcda9a50b482a1fd08f9f38e7f8c8f8bfded33030cd6554e7bcb3461a136940d1af0ceaef9ad8ca531c54e6a3268611e067735c42731800b969669a8543a5a8a7b3dace5b32804719dde7be6ba1f922e93f7da7bba72f2775c6e4658b4ed934ed2c3a75c220ac52643b440365b079a4df91447a482a0af908ba204d575bbb802da5265f36ef6c46d536c76a456d8f2a05fbf35a8ae5694bd1ff21e08151974a5415766bf5f500e4216920bb91f9089609a168a526ff42466f7cbaa8dba6692f4ef5c8a60cfccf4fb8506347eabb7f3761e0756042849ccef4113cd23c529b57540fb57caed67b7ae958041f21e007ed971741e4b2140bcf2376442ea25dbace13a831060fbe65e4fb6abcc3fa64f52bdf442c83715d104c61af13ab3787d487814665afa9298a98df3e5e4644a89d5fdec116cdb690c9146a1492e93ea5ed2e57e068ab1e2a4a4d66c0b47bec63f88937e7467233c06f104caea7282414ae3599e07dd3b9e8b3030ab977bef1e93f3c8d9fe72a43a83d0a4e6c98940787b27c858554e0b795012c5bd393a6f2b61a30187a16c3f03677ed570a6e287fe439fb748ffe59ce00425455c25c45dcb3ec1063a6e70ceccbc8586c810497819165c5d4085756bb45b66aa10c2f0212004cc6dd9dc390a4e8b0db296e9cc903b5eccd6b1057744ca2c525558400eccf3133f282238bdf6b5b886f2487d01c2e11fbad7364927f32739fd63ebf80afc90132adab9363d8b228422bbd3f9825f380d466680c5638ebc83a21e6ab9e0bf97f294f55cffef267ad3e5decdbaa6a4cce8bf1cf4818f01417ae8a19a95ad2881b20128599fa5ec9469dc4039e6b2bee1fb8a4216662d6dafccf41b241df9da53a8a8909e1d3f1215d5e12592f1dcd3438ad7d4f65ace1946463d4b40531b54bbf08f0e0fb72ca721b691a815419173abbdf1692d1efaa16cb01976d59446502754a1d4720106df53faba0cce615a00b4f7a18ce6860706f4dc7d89657c20079c7fafeefcd9e1c73c674473c385813ff6852592cd6ee722e96f4059409eab3bfb2309041775ef7fe079643","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
