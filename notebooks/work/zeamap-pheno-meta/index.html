<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d6b1fa912876a8bbf1cdd8ff3dd852098b9720a202040bd3474bd1c03932106e94706cde96b8b55a92e1cdb1647389b4b78ba5facce6845aa5ba1073ae399e78a940fac0ec51dc08c674820308eef67f0f3ee2b9c476c236f94116c281c667eab584913f7d59530951f8a2b93f3ba4bc271943d9a7c22c206bdbc83bcb11a0c79a1465451797aab2a8dc12f35bc966198fa686c1d671e77013d97221216909083573e3c2c0f8c7db7f4e3f245daf63922ec9abd45b0ad61a5f0be96e94c51b461fbb2026c150ce783ac3ff25ed803ecce388a5ed4a2c5d6484e0cc861cac1f23315b442c6194f8d62174ece254383b6525c66bc3fefb85b87c2af6f4be7dfc73a0273f73d472c024e674940820e5d412a2ce4d3b637ec2e98cfff369d4dc24850550954759b9a1bd6a29d15138775d362a12c30b831f7d8c52c47f05d15ba34ba90b17f10af9ed496bec116ab856fa98406ff0b28e57da4424d98e52d0908731fdbb2d967248503c5d34c4a34c50134de2b63b675749d33a4c405cddd263a7a8aa6777b28c0d3eacc6c3eaf833cbdd3ff5e9a84b6012340bae6432f121122e3abd5a77eeafc8c184849ead3e5d965ae25a8961ccdc81736a117ca1efcf84097c3dc6e2ea2f2482b24135d48b70cde54329244a1bb7f4b89a106a8943d34b7fce34fc22d3ad9eb2411e5eee61dbbcaa683cfd2844ee21ea0a60d35290c78a2fc90880a1e789bbaa5d193bd4db8890381c23c3106f2674b3a894c35dbb0f45ef314a650426707b9fa06929894c1a6667e48caf990f9802144541756bec5eef638ffd30c51b37980fedacd69c5a6bef52fea3f0983287390474b86420bbbbf7d21d7988e9255169acced5c45161208623e9e795d1a97178ccee3760d3631e9f4b4e802c3bef8414832800e3362b1862ec6d437902bc2d119625f88fa3d367fa2c40f2cedb4e5212066f5f6c78d2256ab6901865de5558e87ca511ce002cab9b75e3e034aa5494fd37a9ad6dfba7af8ef2003c23d15aae2182743aefb033fa9695d02dc61e839dc45dc95b7cb23c3a13d2d96c8f23b35e61d82f3ccdb7c8761cf93cab1832584cf6ef5768122fe86d722fa48c98d458f6dbfa97db9a14c659ef0398adcde6e0a8e564405b11c610098a7d5503f02405b5542efeeaa73848fad0a70ec2e41b655455ac8aad244bf8eb7dc5069d6a0a94331bc1857f5803095322a22fb3c87aafe14ed41f9fae76bbfa72583081ae3c06078bb3d4aa9ef2ba33702028fdcdab3192ec3eae58961790e6059aa8c269856e1e98c32158f9fe4227709f21525f76a39ce76d41dc9b8cddbc22ca7b94571371f481213c84cfc9f935427c318b3e91bc7625552450bb3cbf045a6b6ceccd35287a2d62cc5b8721137811b3dbcfe8efe7888db48e8078c50f2fa894e28f1cd3a88c35048b4305d2e25a7d454662dde23ee5b6bce18bde9bf18772b685d02755904173109179881dc48a4bb8715bfbcb6c5d7d7e437debd7ed61dea7c5055f2a7e054c44b4e2792f867f5524b15f7f5a8b9551cc3ecd1fda04fcff01a4fde9357e5fe5ec79f5c5f959ae6ca048c5105ec5fd5893844f706dc31a93924c2fdaf9074c3cc5b66146bf4fc27d2a344941dc91bb0591bcbf762e957ad90e3b489fc4c5256abcd2eba95da2f0d541a9f9ce77e076d088a88a40b902affdce587f4f8d14b373fbe30f6e7e2a6f90a19c8b61978ad4596adbf4d86e1b1c616c00920fd23de05d144931e693239d2f611403b60676c3f298051ef61844502a612d90129dd13c81ff77dcaf2ca8c3e0358cb2aa89e3d7085c399246f665beaa91991998fa19c29beca0ea45fbff69330005bd2dc894703bb8fbb347c3ae9fa638d3eb5113af57a137ad5b08fddec8f7f926a61c48638d5b634a0edd6468ab01f946211d5df9b0a094ee33bbf839a103967952a2a4ab9e161d537429fc37302f98a7ef9a67e17eb2d972ac5727ad21bc3f3959a1038b55d5a74b6ce5e5df60b9e03da2c51b29b69738925f2873c96865a00a6d5a224873eff5fa59d253aa3bee960afdd19d5ad74d603d0e864480bdfa2035794ec44f42a0e1f96f0a1b11e60010a776e97c8442ad9b68ba10c723d61843e2065bd7aab27a6b8cf62209296481ed15b4475b075bf343d54c5b5c4777e88b78d117b7b2c6f5b5e611461f3425a96e39611cafa452450a3e6508ed8d785878b4cae54abcc6de9504343cfaafa6def3d1821c4e1638d7aa84d7565531f2bcf2d36687b130615aac194cb1314bd7e0874670494de89db07379690264cfa5581cad6563a296e768881740bf7211796ae44769172a59d74bc2e634e9c21fbfbaf179f826be74039400d21c0e29b44667c039f8a8067a9d616299a2057cd4c3616c4a7f37a0fa178d4288ce7e7ef7659579d5ba8013a4f2ded30b70ee3d288c9664f6c9a8b840960f826bb67c0ec4e857ee2f49d9971726ef137f7ee2afb46bbc0e7600669b13f932dc2953508bc14c25ed0362a41565de2d48442b6d3667d46370ee8631168349cf6573437527080364e75a988839f70cbaa93fb9a7eee307166452af8fd82b070a0e8eef355d2c7cf48a19cc099cf4887e8905d9ff4421cb5acfc6faa3bb8fda9563cc73763a417233896b3092e858e48949d458ef4f6eec7f06a62ca4eaba95497fa503c15400f4c4b76bc2d4e33d4b8ee27cdab8c88ed493ff0d2cf328f6b5b3cdeb25436e6776814c66650c3142e04528d23b6228dfe8675c7ebb6d46cb03c6c84779023d3149d8f65d2a0fb1c52fb4a935a511f09db0866fe42d75a12eac7e138cc03ffc9dd163875128010718bd8b97fe5f73ee1a0133356fee40168b64a30a55a88188577d3f52c51b5328d1495810f545e502fbc09b4c806e81a00dba34521981235d13b8211c8d80a08b405cc1439c45e6c3f5e9102ad558593bb86433a5efeb52513a2ee7bd20d0f3f5f839a8e2d790fff3b8ed141e59d4cf25076441b0653e8730b81182f77a6f6521c2133b2e2f0261897ba800382a458029a447c60d4b38002fdf6e269ef402ff205d01b607d0fe1e1a88e400545cfad9a9defbdd17464afe15da86c30b325a1543cf6383b9d7813ba29a1b6e361154299f49418b56442514c1c6f71d1c3a3a77422d1c2af87388e279e77bc66654c112fa2f59eb001a1b9c8e57dbc13ce4c7f1fd59f7783408f44d397cdc7d30b1bc01a19d2188e9d7ac878fdb4a25ff933d3528dc10ca148c3437a541d104f6f1f95aab679be18419d0be5599fd604b704e413a93c8e7536c6bb10f75ad07a7217c5a7653bcc2139f76aa075176c4e4ee346d1743354291ef6b5b9657da381f0259b4cb83b2a7be47816f8400c93cc6566188a7ce2e0674b8f5efb2b651ea83b685b1ae46b77e17d17bfbb64b55843be057067e5d4105f3803e80146ccd3944ff80775b041f5359428af2b6eaa4060ff06a0b6767757c956f927b2a7204375c00bdcee798a34c4a365fcc361855590addb9b4161df48259e9ee8c35b17ee5b3c3ebc2c0ed558f0e2c6d8b1e7fa9727ee1b4231f24492e4a9ce1ca0cdb4c2c3d957e0693299c5a820da05992b965d1a8b55a26e015aeb831dec2f93050c126c825ca99723e36285320fc7fa3a134c969d9bb9cdd484a9317c37d9487c40a3ee98fb424514850870ea354d7a0df28cc77036291ead7569d54ce3621b4a747a0508c0695a86c060a6f403ab38eeb4e5d2cf1b794f35be630f00a375f49957e1d0702670ec3471839919b50a884c8274b11f721308755b4ce7d1df0e10e7cdf801ecab45ea3162a0c5f2376654be36a0456f66871a16a3628b856c8c04086dbd10806b1b53043ebbc6ff70ea2642e41b97c3053299cc986c32d3f5f54f2f29d1e80e5c45f5709bf5fa10f5ee31a153178d6bc6ebbd15d6cbaae61a2b965afc575985341d9e41dc0c13f35e68b9393665e84c1a6f8d93cedc804e4901540b2f90c360ee0d2f6e4e78131ac57e74f00642db8ff16ae1f70157ebf19d9bce9f5d1923f60db11293ae2a8a4092424111df1a8b642a9ceff47906ed72318f74f8505a7f24d3c6160f855ffebd9d6c9dc9f272a53db5750f6516f84915045b48f79706905b677e145ebe88c08552b52aa70f6b9fd994072b68995892bdf5cfa28f812c2810cd4174a17fec5d68b127acd75b9ddd8a45149c9e00a36010da52cf9177983145c8a96d93436e482bd2aec63db0faf4172fb87bc1e0acd83904d0575b1ad55231083b92c681b80fabafb93bbf9128b06d8dc132cc3516266320db375e1560c733565a565df8e53ce71e2fb736eafad9a94a85b77b6e4b6f8beb80b555a3ae7f9b4d281290c0391ac76a4958bd7f24d7ffb127a3834d74e012d70b67e1de966263d715006aee79dd216eb3648cdc0d35ab9825d05f978af6aa32f312d33ec969a7a498201603dabc24b753f5e367776041bf123445fc4b4a9a99573be0a2f9a65d04117c7b896303a98be001c30f6e2f17364682dd71351582277174cdb66a2a4ea106a1eb72c98944d167e2e50dfde59d79c9fa4b50e3114131809e3ddef2965c0d33b7186e459e189591cae4820e55a123263cc4b1add9b5c8397f1c80bc942ff35dd20a9261dc083d8d11a8d079654e984fe35a00ddffcaa988eec0f2b60b7c30bf81850a2e7920ca8ff25320b254184b91eac27ef81c3453b718ed2923680ed7b13d067df650d6e205c58abc3a08e1060ca257ad28ffc790b8245c90bba1e2ae4dc75ea9ec9a1b86b3121f577b6f8e0f27c4ca3252ebacbfe3974dac78a9bdeac380564a7d2189df119966c51fc3aa45b0c388d9bdfabbb836ef6ef42faef6e25153cf2fdef552283a62cf48fa839f28e9625c4abfac652499e41115d8904651bbc90b4be2946f45a6f64315d6ce7f340d1ea5889c14435c8d8d0a8595a8842e21550d8d5042062f329c512977c99359318689577278f7a2f02ada9c5588b5b5696ced29c331eca7f2a6194e396be32f01274f4302ac28c9b463e3c38a32ca25fc6c17a55a361dcb55609ae977a159ef81edd45a2cf91296b6d37e7432e0fce39ed5c5d48aa98b7a5dffdaf0cad3dc6fe279b36f5d172e7cab461ac7eb82c75b7df877d4d28332f8e7d2988c9f25e03d7a9c70dea299ab60b0a3d9e5b6801824734c63a3bc728f2b2f64fc3c8f481d13314732c0b1995514e3a09c78e76be9d5d56c42dfd7cf594054b97596abad8fdb4006353605ceb5fcf9370894d3eed8fb123f49e10518e49ce78422080f1c2f2b9854eaa6ecc32ed4d97e35f88c84463566935248ba4c3012e1d13d79ccdff4f5987bea4ab132b8f66659e7de76d2e9ac250b1b93ee2263f633f398e5f8dbd41b5adc8037a9b4d93c74d8766c1ffeab7b3ff8fea856279dce8138143905fd7e892ac18f304ea84ea319e4bceaa8526cbbad8cd95f795bc3e40480d4b267a841677f13d5ffe0a8fa9554508328af367f327f46a6662bb6ad538093efa455f3596a597a77348e59423fd6c92ebbe379120a2840a732ac83084fc9474320282ba33034417fbc436fbd5cf8ff168b8876d54df44c159d06e3aae2cc0c163df79f436a1c13d42f91def7b4205efc8062953a534c647c7eb7c8b1394b1a1d72520c9199a8b5350de4c4f8de35b15ceffe5ee1124fc6bbfe43279ae27d7354b910cebb4b73788a777f83b9d2c25ed665cdc9076e48c0802a6c128351f53e4f556d39918d16ebf691e4a9ef5cb963e3934e6ee194b6c9e83d56559449987de8be7724cebb43bb8d60df3b4d26e4c32972cd8127974e584f4df0b192a22dcfffb61c16133b7602f67d10f9f5c3580b5cc2830677cb4563fdf71ec5d49d6ba713a0a89c49e33a02f0fd6f33456e0688873d6b4cac95fbca4000addba68748c612f32c839ba0dd9837aefa17a636712b447c51669aaab0b2459c80b1cc100975a5d775fa33d7f519f538227e7dd058e7c738a7b0f41c3b46747252283e1c86c02e9351087dd1fcac6d5ae569f0deedf31824d69fb4da3495a3c40f9cdd0ad78a9e4ed8e57038bdc278bf3d7166d7049d56797db77a6c5bb8fa4721d70d30fed3a0e6c9af0e34b43847152ef0e3ff613eade380c6c5489b9e313a3dd5d04ee0e9e7aea5b3858432a88666b0e45bfdbfaa2cf66eda94d002e77e3022d40636ef219379ad5952ae723817f1a681b9c40159945be80d2b0ec63f5e407d32c5cd4e7a9cfeeb27019b7cc06395dc1f6ca53d0b31bfa479f59fd9fefd7e3b238832cafbff9d04e34f6fd27a2cd6611d28f7012b26f0abafada727f5cbb50c27bdf847222bb90103f7f621670844d463950dabbe063d5688dc0de1ae91fb63b21999e6eb58e95200ac1ed963eea9c49e23b097eca29e2947b385a67de16245c4470cb3ec07a1635cf4e28126793ba600de4d39a069b5b5d11b50628207c187f85d26abac7f06f8ab844251e053c0ec5b6f763b5d64d9d9a88bff25ebd4f3e9ac55d28c2a84982128ab391bcec09cb9935cda28bed4cdf181989d5d16dcbfb9711a71411f6f74567f5c9052083dfc63c40c79629b98512ef10145781398cdd925bc861fc6c7b2ce5317ec0f0192da2eb03d2a9057230f8b7eddb363b988b21595e31fc63348d3e9b61686aa5c982ca69987fe47d08528ecf651f4650a3e30457d8c38b5e08817386b50a7de3ba74c61a62f9dd4ca022e1cc38f1f8b417ea02d39b7db4d325824b9df26e3aae60409d2857686f7fdeeb657c6fed1247010d1a109498398aca23972c730e1e3ac916d6792f51449abc7dd22490d269f0880cd393f80db5c8d00b85cce6f0600500aaed6a3526107301d255e0ae04c79f060ddb92365925f08a1d8700795926c94fdbf1552d1a7e8562766e2eb09e3d739871cf0a621c307a69e87c0d0e29c40645bd07f9caead6bd8e7187eef9e23a1f2b1286c803e8337b1eb500dd11c0bc94ccc0f91a030c45ef27122995fce3e01486445c38a5ef05785643e58e180e25654142230a3859d7ae13afbc1fcdb1d407c0b98c9391e6f441bdfa30869f8e76e70ffaee4cd0a6c1d8d1c1d51cdca750a73a367d0006d760a0aa56366087a6384ff6987f529c2095453c1cef91afe52b10fbb269a10654351a23a988e3a35965219fcded30e1a3a0d1021a61b2d7fdd5c21521b75b8dcf74bd8a75d1e2e123db3022358640030566910f38cb18453ab5d229174460bd08c15a8815443541e07a9882b5489d2e25d2021a74b1d5d289ac70ae97d08d4e5bc59694d01a2b84486b07c27998d063cbd9ae8e6ad2d37eb9e0a1cba709a06d5f42b78e8c3fbc280f248b87f266a32a4911dbc0b58071b33d7089732a52256111f00ede8f1df88335539f50dbc3febb92e3b3e840f48097abe2fb843b06c28ff27d5f03468adedae500e0c39f671adedd3f67f142d3902e0f328602aabe10adafc40ed597a75737cb66db3b0023b6aa92c2c9f7730cb083be49a2471cd51c01838d0d01eb99628971b2563ff34567c84a328d3334deb840c0e3cc981261deae8389e8b3b007b838a5bc2c95854a32bdcb95f0d25e2bb8853db7bd3e92e6e6d070f8af0f04d4c474dace55936ea9f32c6afa190b11fe9e363feb5b6d8ddd252a3e993c6b7cf29159169b3434b6349fae4ec4be3851becd45183affcfc0ca6c0d1e85a5e0ba37f1cbbc199fba5f877bf84cb35aa1a1c2bbba4fa7eeec3158dfa48a937ed456e84c2fb12b3e682965055be6b1a58b2a9437d52886b8be15fdfe2f70e11d6b770e8fe6d7b293c85e1de0e36b68cc61a9e0740fa3e45884f42ed59e23065c65913ad1177c168b6d1425d3c7c6c9db5391a15b76e3683938f2e957a317d9281aad9d6476f0b159e414a27b734dc98e879fc221f0b950459ab08e2332bb5dadcb6125971516e11d0778a0898ad7a29ab44b3df10e85995db7c1359d0d285ae7952729c374c0cff23c4f63fd517ab488f9a5b671ed7708a282e55001c451cd3f07bea62e50a20241d0c4decf1288fe94f38373dffbd8a0ee738d0b27994daffd24f081b7abefa921dfa10529a359ec435776c09180c56ca956318d432d0cdba6748a398997ff9499e81c5f36b66a2ee48b81349727e8944ffeba0a243bc7a5c0a6aa99269fffe0d4058b900d0918c67830758a92a6a7b780422a18c274632c9b3d734836f15903e9d37e5a0d90a6bdbe4dd310ec3748175243b2c9f0b35bc87664228f9163ed110a5abf2f8a54c93bc3b8a7bf6633b13f1288a31870d41d3963f8da1cc215e73ea41d698a5e9e49f8d9222e538c36123e4a05b7aee17d0680a083a7dfd23d88e831b3af0b84d9b78620bd20c7572610c6c42450b06195525e35e5d58ed910e85d91e175cfb72cb599dbab9fd98c150036acc99b16647a9fcc6915442d8713dd826456fdd89e8b72e11678aa7b9ecb6dde09ee11363cdc0800e9bd095a03f9a3de891d86ff3519f9e65123cd6b1e84bb14dcc1ef80fedd3af21b117e1d21fc23a96ab90d34b5d190e6996ffe683db9d507bb1a32323dbfd0cb8d6b6b4d08d1ccd0d729cf056eac190c416794dd0fafe2c4d588e3c4eb1d08e01113cd38a3defff285346c8c79b6bde4e58f8e8d5283431b838adf5ae9f31905cf36c845dd699483eeadbd84dd1011a10acb13570ed267f615edb2bf15410901ef84f7c5af26e5f602f80c42249b1051b3f4fe60eed8ee67ec908bc7bb9509d64c3e6ff01acfa151663d86456a073480a6c9d4152aa1ef44cfd30234da1d7ec2377caefa70eee9bc9af72b2d5127c743bb260b76b288e31029e89cf80118b1380907a17c0c6ccd8796cd28f6d40605c553df4f7186a4eba7bf39f5dc517a8c9705bb071480a92494a9575b4af179e3d8290059e288b28c3265e1c2691746ea5a70ef03197180688e5a47ea0cca233face48d543254737b22469b2fb6d7db1ebeea796ead346d2aaf6503e3b3597aad92a88d044c6da60eb7f5339aae92280b2e42cff060be85c0cde4cbfece74d76dc410abb8a6e8a9ce886d27de9fcbc4b44047b36695a111d54702075b1f6392dabaf0d90b6f4a11de8d1ae5b7ac9882e411134db8e3af492d108eb57a567b82720db4c5e3fb1be0798caa374af405d04ae2cc269b7cf2e9522aef4abd68140b5b07437b5d09a844469fe344e22dadf31f84e71286ef0d65e3bffd58f587f8f31746c6cb108e8ce60aa66efe4dfc08820624cadc9b5d97ac82efe2a0156b8d2a737493f603a3780bda2d4490f878c0552b505a5e3f1a9ce08f4e1ab4e48486bbb156a1e2d078abb258c3a3dbd7b00df18cd0806c7628297b8ceb0979506220548e81795f750128c91ad65ad59afbb07150927871aca93bad0924786fccd78beba03c39f9a507685c4eaef0b22b684337b50d93896c6d2da69eba14a78df54aa68bcaeb3cab073be577f8f887c29fcbcbe9a7de51d4452ef745ba5bae6a05eb3fab1e31531b3cf4e74ead6ee812ac01245e45db3152dfa52c7b2d587d6f1af348ec120d47c03fd6d7fffa26b8fbbe9b0180344d341421ef3bf07e20c3c79ae41c1f4e8665b1b3fcbcb7533cc10d6a840ccf7007de304616b1673ab88b567a892b4da9fe5021faa6e6cc6790cf8dea44c5ca03c84d9e9dc65f9ebb196b065a3069a87327f86ebc674347d4e90c6506a6ded6b2d9cab8cb9bcbcbb9f3d2e8c941690dedca910a3d29347fc58c02997e0e559d0b2cd66d491eb77c27685d1b0107478899f4345e2c900f299cfefdc5f59ab17205b22de3ce10834631828988cbcb0e314517d3cfcf4b29946ad8f1bb92cbd8fc740fda8048d298ebf39e5014c613db20775196016768068a2cecd4bf90024c74298e54717f6ff64d47c9e9210d4087d96b20abe6b506b3a5602397ea388236531b04bd5c31c1a85f305d6d919256436564fa841baa2a0efc88d250b0ddec791fbd135f41f1ba64cbcee597b62de592689401c2ce0de8f5f0c43e1d409371745fc52443036a73f621b0fa76c7a6ecb8ab39acaa2ceef3f798fe3ba9a9952f210c9f5ce43bbb8926d3c0e6ff5a105a53758261127e48d2e2abd2675d5d217b215fbb0e79c84a4a1dbdef4ee1ffb65081c00ad268be582a627f001b015baef1955a61709628eeabfe87355a9e8bbad4ad3748d8b0539e5c9d558eb2c00c3372ae6ee364552117852411d99016f6b36c492f8662300b3dda59f0c918878568bb9e3b59d997f81f7534b0646699347ee63d19b8e3d7fb588e8d752276edf3d1a2052e68c760a58a70fc02ab4637bff041951bca9a375f1d6635ee11eef491d813f874f1fd8a4ef8cc0fcbbe7af291e8962b007401e078a690522894dc227b09d15862277cbfa3b317b70a6c00542f760f971ce32a32b8585010514d80ae2f1210015e954581ec60726b8fa462401128fbea493cde9bf60c35aaa752a338e8c8d3dcdf3d560d0d0030a8af4135796a7fee97ebe4f0bc66ab6a7e0f4fdb383670237b6f58b4c7586e5c044d640238cbbe9eaa5592d0e38f8321d799c559a3d06c7898c4234915f5efc838e98275e69a388a483a98d85eca8768941c3db6990ed77b0f6fb026ad3daec01a55987e991cf228ee62e842021d8fe056a37950474dcef68335ddf73f10c14c6e58301017eaae12f12d9d701e41bff138de6e0a4b38ef45f0c694f1b9f7835f7f2a18feda632728817dab0aeb1b43ba4e044444030c5abc08bccf0c62d526856647289dcec24937113b0d0bd75b3bb1b8f6004c0489b9ae02f952d6b8add6e9eb414ddba10b766c2a9db8e08c683de647cb333d671a9a805da33c481c869e0a0b281d7fb37c2c1aebbf11c92f646d49141de21bf50954401fb7b3d7e33c027b4004e5619654cba7346be02e1292cf77ce7a8361470389940616fe733d36e864a80f0b8f20d4656ff1b930427431b0bcefd83f39a3cc5d0ebeaa5999ccc3e62143776a9ebc14f65b74f1100b401f918c0ad322dfacac42a639d2f65480853ef9ae37c1fd71cb94d058b0c83292cb844ca1e834f4a54b4e4419e1e5781c06d4a953efdcc67e9df52e6fff717560858c5b1c053a84480b22d9a7b0eacfb2f4eb2b1e32bf45dfab2a602c2f04131384ed4bc2b73a7bd2456990ae7b034914cb2245319b0076263084f685cacedf90c4ff55579ff15dcce32168a4bf817e5edd310b88061e7aef986879f2c840c8aedee610e97afa587df686426a3e164029b29281bfa5f339c9ee8fe2e0e2ab9dac63639085ee2415b2f2da172bc210b0af8d6e987bea4a0aeb5b57775b2bb2e40ea149f1668bfe19c0d4cdcf02ffd76ce35923d5ed2dd9086639c01b43737d1d509e83fe48d54c2efb729355e783eda5f15ddb695ca407608f808c1b4df3f650a56ba18b38882e824b06b52fb49ae7b086889f06c0e3053716708fdfc248843bdb555b9a5bfa57ab6d1897417d790d95ffe5117f04ceb9a9b3a0843283f68b1a6e17469c606b02f2ee6600d689c274d870aceffe53e9b359f27a8fe794b3e20c48e293fb215f07d10af02d82597c2311688ed93493f5f5128019a90d926c6a5dcdb6883205af971f1e9c941b1addda3e36c0a27d95f5bc612fdbfc5abcc613d5df93b4586cf5251f562c0bc1edb1dc7a5f7ddc523a664ccf118d042effc36e217661bb5fb902705d06086204c9c09edbe7315711caa6866f16f1a6ea22f3f530298a75851b4f3de454221f43aa1c4a70660bc23d5036c46371c7b99052ee7dc85e7c02b2af833aa2bf224e9086cf3755fe5fa79e4d201d90f4098a996dadd2c69d9894873e184ba3250feb0c5d3064e1a2de621197c73c5ae498bb5d9caa4e6bf5e159e1c9e1c851ec31ebde29ef92b4b6e1ee65d58cdf3c7600ad797e1536737b691d28cfa2a15f5acc1801b3b6bdd33dfd9cee8e58d3dbe446048105821b30036b1123e713b4ce34b5a1757908ab4d18516e8a4631c51f4fc4236152d5df3b754b3e690a0d1019185ced574f281dd339242c40c8645fbf49766b9ca855271dc14b2991b71dc6aedc4d45586a2848ae814a266eff7f8919dae417aae740a28c4442d346fbfce10a214605b0f8767ff7b0cc2719a481067aff5119546fff0bc94e465f7006dfc21c07f82ca2ad9b1799d43696acd0da5b2d3c0993315ba326dbf9c855f84421b5836f7a680b74426cbd3c124012fc449147ff51fabab80fad74c31cdc1932acc9b1dbe4a17eab73e07f4352fda9c3fb2fb5485934b61851263d77adcc437b1a71e85cfeb7ccae771a011318b5fb2ec074cc769543a5b7ccf007bf9abe3925830999c0fbb77c733ecee1ecc1aa73c8815c02e9f1bfa0d7739e2925c5a418d39165430a8b46ff766ea8441a2be95463c3d579f8de7dfe8c089a234e3798a121b7ead10299e6a2b0e4137e72fbb9ea77d3e9e60accd28c52033d5422a405bcaced6aa990d26b1d1a8beadf96ef9faa6d7d720bddd2f554c362fa04e42dd6838413ad46f21301c93c3785b10789d32a71ee6b6c2c1b432c10ce7c03a741421ef971e2ed325f59e81294e383a68af777a2f231e07ebdb53b52129bee9d52e5e228033b47bf905cb1937e4a688dfbb7acee075717f44db13564d5a6449f90551638846fa76172672e63cf023b44094f6a72e128dc0f4d516eccae278f652c07e828349fbf144e940e635d60c848f943f41403e98cbddde81e06a2fee55ecd98ae2bf0cf04e22d737a459e8cd63d3e77f8c90f08873d6517e2d8ddb61650147f38d8534732f8e528ac347b718e8680df62ccc21781f08f5a374b1da0c9e96ce602a2c519b78c29d205a2db06c594e901ed50fc0b43325fb6b09e70b7f3b02e627de2293bd15ae75c48bb15ca123f26c799dc8d2e2d86775be1d17e73ca1b706e089785665d351ee1012dea71dcf67689b9b7e9480801abb947d65e2d2ff825cd3529e3674bde91df5cc1be0e06d5a5bd7782caf18b2fcac71763217b1eeca86cf2aed1bf7f191eefec29f1d132365284037f2d246514cc88137ae59efbcaf2a3a43d2bee437b2d8595b2158f765cf9ffafff6d0f776d5193ca9385231ece8cc1fb07f2941c9f48fae1e0b30b1833c6b0264638a2faa7feefa7489a0507167880f5a2261b633f445e9b39ec48a9e5cfd67ef9cf992f5a9ff61f68d5fe71cea4fb4a17b8fa68423c79e2a73a04a7fbde82e74c3f64b6e9d6d5945084f4f3aa8f75f44b846d0f681726cad892bc626001242ba73ab243c694fc4b80362506d17dff4d8d756410f600d9cee16af5f9cf3b4f79ab4fc7c14079505a0f333cd94bfdd8b07451a635bcecdbb4b3a4a8ebec6ad90887c39f6e91fce5c637ea6bf0716e8170ef12cac1e8998e67b439e6b94a87090804bbd654d137c7971efa7196f925c8f929e6682c5dec668be2a76379d398cc9f0b2f9d64f80e8c42eff9f72821c1426cf14d0905858d20f7b669069101088bb5d356ff3905384be2a65bb0edd7060e33ea3e0594183ae391a15b90bf24598debc5ff3879939bb801f1df63a6272d268029137f491a95eed657e40a7d99b5c040325854059fb44e3f1121ae109a2b54f226919153337db0170a4baf82237e39e26a76855891393845cac958d4a826582dd990bf74c06ade294ba5f7bf74d5ed24aa4f733a17eada1c5c6aaa864c24997eab29bb07db813ff4a461eeb0eac42510ac4a66e9631010b60134fae888cb73ede506ecd110e4c0ca9f0591e5e1599fcd232ac56455061885017e10ad58b255b11f014a5bfec71baf1f88765b754e6352a0f30f1a72cc2c95a0006b49c155c51be45ad03e5fd0123d18cf78a6fb67d01b96936eedc71b0907d49e42ebf7bcfe2bfc0c7608cec0c6f6b4693f6c4f0215ef85049face1e6531ea389275684d1289bf5cbc512a8fb80d050a246af32717bde9bedc51c804480a1c87777e4f7969938021e20c6cd9896c17788b501ca94f49d8f16d04604e4901907b4dede3f82612d1f0f4988ba4aa50cafb5b3d594b0c15bf221f19c42cb84f2360dd6405b578f3667ec44c85c07c0e26c13539545d8a02824da632e2375ea122e9c6fc86efc77b84ff5430bd1d213fcf32c0d67cc0ff47b40d9b83eb764ee7750881940613e90cbd85062eb9773193d683726fb2eb3b9f550ad75009b357487b4842f7377687b75c1dc78944e6235779de266d6115a2cbb9e6900b66e35d4b8a01661c5ca4ac0b1af20b5648311c3ecb352d06dd78bd4587744f887121009c75168fd417989250f4cf8be5ed0e2f62c52e1f372d245554582dfaeb225b79b43c996910eeac6fabba7d39ae76e29aef3129aae7fddc129a91d736ac3675b9038d6c4c3865be1c87be8beac5778a47282ec1e81d5de7dcdb2aa1454250fde9f9e0ed754ad2fb43c8d67486ed36b59cc9f946731c53ce3d92014228702c1c64f5c6ea0293a450f129d2523b3545e3c45715237718f76044f62761174a4b2118dc02de4615c68de1a062a84434b127b409e6c3b5ccca7e1d9b97899f371f425a9c4bc4267168ae4ebe7978b3bdb12aa96668600975bbe7cc5a1d32ffc308afbb9e4d0536c66db677bdc7f137f747d3f973f5bef80eb7fb09c2d2409a1f91ca97b81124fb7e30023fbddb41bab630892ad85bd0b120d9b3bd61326f6861e128e877afcbf083c0aaa269fb9289fed5630039dacb0a1fa62cd36a6e8695a5d2f735a0cbc8cedb7035354f319ee8ebdefafc6ff33bfb5c588072769bdf44742f33c9229de10d4e7a9c52f4ea63fe07d139fc8e71673ebab2ff99d61b61950728698955f1b8651cf73c83dd1e01832cfea58dc04e95efc54fdc0a68028d8828a3ba599ac2b1f9584229b259df7e5ed43cd0b6aebda88c9f8b729f0c41abe2193fe874c95e5fa4a0650d22b96979a4d8141986b2db165a94fd28a5549131cd9e3609cc4b387f87f713aae41de25e560a8753d67026b5bb52daa8d8e1b01bc5da212b70807f92be444d601976b60f5a82d4a8e6ec4a360ae97e57d319eb23934b81120acc3b590d15cb5bf47d09d9a6ba5c687e59ad4cd4520ea57c484d9db8047c4b2057722330a2efddab2444c94380b792427ee678f4e957523a09e29c4b313be1e6700ba81f333caf6fe911d81a28184123511e0a74b4be30768b5e68ff2ee8dcf1105f4d416dee0adfc9acf1f9e48eb81fef719c50ea4053ed1b6d306153aa5ae27814864cfed7ac26e4c176770c9bd0af996936e7c4a5cee6f2e9f2d17a7ea09d6beddd4b3c5e6685b4f3b4cb92c5b3faa449c73a671a4df9204f1a0f998904660c816d46456e3194c9068e2383b51f2c5142ea608b240ab6ec31eccd851ac8039d1a7594b26b7d1c66c2f1e7ea8e6480fd5ca37fab83de7da406145196c7115991905a184ef82101a60b98f6a56610e8d8332095ecd7f0a6e1baa25c708cb0a4d94807ef5f9033956ac1fd8f4fdd5fb10cd7d7426d85dc90108cc835598be8dc30185090904f3108f4870d72da8b9f9aaee79708ad67104ff74dc8b9cf8aea6121d1c41c2b71d1e57014559844532b0bdf1ee479c8a3fe906271cbb954a5f29ede51c63716c7b1cd834c77a990482603b324053aaa5d10bd193e08f0c8fd05c44b1e0a7160672a97895ed917a21a584ba45d4842a8e6e210e0adf1b40c92924acee8ba41f092596f1c7bbadf78a31408e7ea1555308fbc2c253391c81b76c88538b3097ef15ea05ba0c3642c9a165f69c4c96dbcac3107338270b9c8c1b1feabd884a550ab192726623cfdfe8567c95f0346fe33e0136dd6cbc80ba56cf423ec03034c4b46385815d2491eb0f760cfc927e86faac17f895009ba01dc8c898d9355c312ab1571f904a9d58bc96c679bc1a6f3cc4120417d4963a5d1f17c145afb7350afa82c319a9ece9effcf1d7285356225e75ea8cc4bd3a73bc3d9f1531f3bb1200d639859c9deb125f5fccfb96241a36985e1e444d44b1c5f0aa60f3934325e46d5dd18f1cbefce84395fe22b74fa5c1c4cb36645dbd6249ae5b42ea2f7282df9a75191def4f3861ed07fde555613266fb25e7c66485252733075569f4a9d338625e02f4e11e67b1e8ae91e634859f1361f41a205d6d5ac63ef9aee6d846462040ef1bb9cb2b620592afa44a2159077c6eee50c95e93c3e5910556758dab61eba26f9c7cff189d1d47fb736fe72b76060cebac88623ddff0993992cae9d3a8e37928bba12fe0854426103ea52a61194f487f743ea2c30cc062e4f4922df584d75897bb605dbf8ed9862731e61cbec6827fc0bf904314f02ad3ffc93402eb655fb7892d1b9ba1795673155e07362104b7ad49c92728c783dfe1ec885877ec3da1d4c730de59b824a0ccfed5aea4fa46e10041e172faa7958f468ea4212f16013a0285e7faf2b810a939a0ac07ce52535e9abef98161d18426f991b8a819060a2564e6a1a194f8c7ce47d55c7f1fbd70a786e5c878529b443be0877b5b25974728976a423abdf7dfcf37d9d3084287afd62356b457fe0ee8d28138b548d45aacee9008e6c8e43395d57f9bcebefa0e452fa6c447685f653bf70530143956f0a65f05bc4d0fa78fe5457daca3195b7f0c4542a4cc14c42f392b5effe0688bdb7ece19e96b0a3bf492a10fb3eb0a4219e62c90e8e68984ebe5c14b0571e4ddd982cd4d9a8fd160ebbc29fb3695b3e63d099bb50d1912df9d3681b85c60445c319bd9e45396b6dfb479982c6d1a53f40d047fcb6c155b2650fddb7112014d7d27724894e305c544ec9477c7efddbfef919497efcbe2f46ea94725bb8c2ccf2d55aa60ba8fad825fa5f9bd061de1e08f7c8c01c37f66f3a0f78f2dafc564cbc52157458f7c1e946a4bdf2060aa3371a4fe5800d17256f1e260f8243471a1137c15b3749f370fc05e9e6b2bd8efb2bfcf881fb3fd2c0f50941cdecf5ee98f54b5ec4520614d49a6e9c27d78f8f3f8484618b4a2f8f72e882118dc1d36f29e29595b8d045aaf18df76d0aebb4c29f682db0544da23d4d2b9669179f6859c630ce2d2aab4eb2453a1818e83a1a7a635929bcd2511f6c130ddc0e2040f0daf53ddab19c6a187dc80c4ac854d0ce130c9ffb8775d1b417a6ed0ced8697a679399efe65ad9a7571b0c9781d1906ba96112d1541e9c6a530117f3cb1cfd8f8aeaa69fe38ada8c9439c44df50585ddff39bad44a3904b4b9423c3b88ae5b4fe018ae21bc2ed023070f86c40fc87e59bc7d18d29a34edc53ceff89dcfbbbf28f1e7ee066e7ca92b1f053f42bf644194ea0d44ae9aeca01f1bce16954a82ae1e2d55ac05bd78011a5a04dbff32cc424377e5f9d52cdbc6ddc452ecf2c6d835c6691608abb1e3901134bd43f0b4e83ee370037a28338429b98b7c5336b3114913bfbbd488158e4244cd500db60e92c76bfe058fa789a7c18487b1a25e38e204d46db799e290cdce0c4db9d5e8dbdd3ffa9d8456c914c1a1ed57b37f600d1bf662e6f5ff87f65222a5368d28347a1bcfa1513a1135c934c3e683c528f05a933173e07aaf59a8ba8bdd7dbcb947ca35cda6663ffcb1e277d055c9cf227af1ca0fea36abbd50d114f9329fa77fcdbf5b03496832e699b57d7099ed662d22afc3fe50f4624d544855d0b466c1b4f491eb52884ded8de136450773270758a82a42ec1a54b173cf0bd164dccd942662e0fbff7e84b0e5eb0518e2e57083d497517187de340c6c5bb2dd6d91cfa34ce120750e0e3fa919053310e1549e25f1026e0492bf536ec8571696df245f906b180932855e08f33c257b12260032ba89d7fba334c923e08bb0121881d08e0b8305d889177b238e4d752cd7093f5b377b8f54eae1a4b740951eba9eed27aa63e5b82fab409c3a2401252ac726d7b7a3e51f4dc168569ba99f2b71eb4a7d1b81f14cdf00a96a2d5ed9d78b242eab1c8f92fa7d34241852eab6198bc6c721e7dc554a7b8473361b0c0f819f81d6bf50937c5ba2656e305f4c58ee9f0fde3abd5450ccc2e746bc62aa3c6d94e36d21567e035c5bcb3a4aeb3fb41bf5aea1a20e5d59a9a7d256650725dea30521af40011c386c4cb41d094e3d4eb6b9d8783dd67c79d8b90cc3856a64fff429855f3f93faa8746a4637138fac1db44ecacb2abd9cc8f4133bf64d9553a3e848ec0e2a0be65f509338385e34771f3df21b69f2d62ab3a446dea690ff0ac4e66d19f4c8c1cd0ad3d3bf1b94607a5df5bb32c73032b2724bf09b241f1db645f911d1daf6d887b98a2221fdc78eded007e2b0b697a4f2f940e5d374ec5be","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
