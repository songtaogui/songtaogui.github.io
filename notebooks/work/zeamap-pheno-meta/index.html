<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9cd6b352c8d0e8abd9b0c4669f8b8e738c4fe688ec5f62cc2f0635ffafdb8f5d94ffbc4e65516aa0a33dff752217279ace9805118d74a1f6cf30e09a27ab1ac156d0b1beb33ea79a821f1b706b9ccb72200b208ca37e9dfaeb4e905754a87acc2d4e6425fd68055357bce7bfb5f945d58b0fcbb96ef940c45d9d43aa8d67c6941ee8dc5d13a9aa18099199797137bdd5c9c87ac916632ad9fe926fb658810094e14c49bdae1468a8571f14d14d83cd95ff1b2cbd08b42de4fecbaaa698101d18c3637995007aeb106db0211b53b7dd1245efbf26878a459c442f50fecae783d46d6f2d9026ef42681cc157667c7bd2c19d93a77b87f44816f2df6ac120b4aeec7b477a27e25614b1bc54f2dafba2b12d8ace339a82f3568e5a0fb7a23f9691e6d1add7ec22aa8c4cc2d6e4d41f74dd586d08e6fea23424bb219b7b856c35a7401d4f848d90abeabfbfc91cc9266fb6ead9070cc88cec77c26b1f5507ebdcb18aa956d936b0779272746f3671b7930209d445b01979c75443dfbd855a23087a2af5e0db70ad75658b0b701d1499f59efb8d11a967430d61ecbb9df99a2b6de4350a7be968c5ea850737df8bb97c91b0f7c42c38600e1d724e7743890f75944cfc7b91b5862662e8fe716d4c41514e505dc2b775c6d3de18f71c34de1ca595cf751e1023fe4d94ea5819bdf135ebfedde452489ae18a8131349f622b0266455d0dc60e187c75397e7cd4f03fa22898a0a410f9074d9aa53020d3725fc45bce90eca5e12a4b8cca22540d4a37ebcf6dc1ea7015899954df89b61ffd32ca6d9e1b90bea60b80851ef1a26748130439af8702619e9145958cf47b6ee2fb95527d0b76d355fe3860c2d4985ab2bca0b5226aa61372e2bdb895c748d3722b29bb0a51a611e6d782066a330d9b81cdeeb3ea893be945f0c4e95219a279a09e1f9e7a59eb1e3c7554bbba5e8998cdb9ff0a23efc66f3c58a1e107d4fca9da1f3c06e52039035ca00166349ce8dcb48c54a8f8228bdc0ec901f9aa389004cef6dbd452906a488291262af0dfc4ab16468a458ad37568ecbd7cc9596052a42d47fa759627660ec5649683089c6b9254f466f59eb1e1bd6804aefd7022e3b6cc563d287e6adcc8e28ba13fef177386957ce55e81b24c1f7c79c76e3c4a3b8b387daa4f438b2358c50486f28dfa92b3c8981c2755b5512a3e2c15c9b60064d773d48ac537aa7a76ffe1bc67efdb084b57122277cb9d6ccd735ef8df032ac70c68084cc7cb2c9c0c7880cb3d1dc3ff543f0fe1aedb27756b2403acb575bdaa6de16f4c946ea15c4b2ed370952b75b679efee3848ca51ddf19bc634e774d0a2012785b6839e4818c3e581be59a14e9980c381c4b1527e86fc9c1f5c4aacf1dbd23123670e37068ef403b6d3c91444ea8e70fe7398e1b34bfd6e236953427fbbc13729374036e26b047ce306dade0b9bbb073960fdfea45c203acf9b21df339a9cb4a1cc0c0285a7441d6dc863c27f39e0a989673b971a03056c1a80027ae6241a1db4358224866c9d96933d95666fbdcc938fda57b580385473e672abd4cee61f60715619e855afc4ee634816571e860f9e0e71caee99ae9d7812a4cce69dedb0fce3b1a88bdcf5c9ba0933d1f22c3a73cd7701b9e34d26ca7854210683e091a550a1d158c316084436281201e116aa07b01927c21eb2f7fde7df17db64a9005e2a930ad0bd9f44f94be8d30c7d44f3e607a5cf0c022f5db21313bb82fd1d93c3528326b2ab31a74f981cec9492eca1c3c759d1ee6c06f66998572c97c46188573c153a8aab726d2f0b44c9dc76d2e5e51a7d27bdef1b720ee8f636036208baf9f3fd361e090c035f56bb44cfedc2d60e907e6b966d002f5b105b6d05058249acd13863830e27806736c9d9dc155e706218cd2ae2af6cdbfe97166bb3aff378984ac8cf19a7975a8dd11244863f20494bf9a781d1abcba10116d3677ae9bf30317028262c00e0594883c101df1aa9dd13d10ef0c33daba12e5857c167b6d5e99e5a3d058e947f343e8f67d9e474811ffa7fc7bc4a140be40ef42f21529e3341f7ab43b07a8991eac891ff41785e20a84d999adb6ade87607cb988a3817e2b422a9f5554ea53d1d77550dee5f8bb8ece8c34bc34b6377c4ad9253fe69e82a9757e7e84662a1ce9ff5ed13fed3f5ad7e84a2b25e8e180ce5604a12643650145cca8af80c08aa4c776cd66d76b28c97a839f68834cf0d91cd6f7cecda147fb712158d8bd1b936df73c778751c18e7898b050def4751f29a30503a9a51570efaae5346002c39f27a3a25e851a408da8ab6d59f90aebac1e9b7db2ab7b15e4cdc1f25023ffe38310ef2eca9ed6d138b9e30abebdad1f4178c5dfbdde44f3b2a44c2995c7a3bbdb76c6f9157ce078a2a26eead8ebaf3aa7b6ee1cb7e1d6706c587082b3be1268b09ddafc4db1ff779bdbaa66eb3a337468a6512497a3f6a52deab992be83629e79b0db2f5a542899f711232043d3905431fab022f3343ae86ea6c511c8cd7b0d1cce08602f3bbecea0132ae5684b3d07659a97baf0997570cfd00fa3ade2d25687f3dbbe1f9c231e442cfa7d11cef1ddc93906dbe0990b8c27156280331797dc14b7d16b405ec01e7f63f60f22b858b11a194f31bc7775ddbc67d5c7154bc4f077b44b9fb766941f0b94157820b895784c3dc7e3ece43851ca4cb41e5890875b3e71dbad5e31b77d34a2b9ec14aca7e525f16629f03ba976dcd3153bd16f98cb4ef523b2cca2e74ee0df7c8d354fa10f8efcf4213df43b044b4178484b37b530cf30d111570844f7cf743b85c9187d3fecf43239da442d6f5b73506d33431c49a671d33423a2f95a6fc9b3dbcb8c0c3c26ce1e50ef2aee908715d0ac7c3e666240a575faf5d9fcc0aaf6f32a560fdfdd55fefbffa8bda45ce508231eb4ef2b71996c89cdf3a790cba1118e900614dfcf05708102943b665afd6dc84b288d1e6c3f5adea94a2f8b025e613f084427b50dc0ac38294464b48b0c8969a819ecc909af85e268d3c1db23a10f70c67990cd694e0e0e3bab8af8d602f40bc003ca03110a3cb2cd7147c638e71e3f5b20e5aadf28dfe57ee214ceebca5588797a1bc1be15e5b3a7d27f59f7983d6b5780231060b15a97a51eda73e18b8604928e66b95ae71dba90dbb9733bb2f726cae9a111e167c44ead27739d4b2f17b64541e3516a61187324c8b80028c5d707d6ff34056c8b24a51db0297a7558ccf279a2701671af7e7d2704c82592f14a6c083d7cd67ebd4de7e3b7f8f66befff1b1a1071a41b3d9c0efc4f2ac9954e18ba1ebe0c700823474a85e963369d79303ba5233f91cb685f481c9f099e3dfdab1c1fc9f52eabe375fae2011a47205197dac8dfdb42a140e1fc56afb469f54302f2c925c075415ea12e8083c4ddd45e90b15bc0ef22c2b2c6de18b90ec31b02642fb89215a459a13883a3f6993177dfb0fe7050d96c2db174feed64d993de2789ab775a09ec1212f12edd9ec6490686c8ae5794294f18c473e730fdc94dd91b8bb9968df821a687fd622e357848704af44a552502b41f5c672bc1e6a912bbd81df014b8939c3aaa49675a738090b5946de4779aa4666a403e880d2328855630c9f86d3107cd347675d3aa5383a1e2d3ab6eb09a3272a611cc0ad5991e8b88a2501648607dcdfc18437481d258ed8ecbc690253920c0f1de74aeed79c3fe1ea6550b855c232a450b52309d33800d30aa3665d6dc0b8be84e613c53439c9c4391fd77dea89afc4ded606fda8b4bc135bed81559883090b03c05085df81b5d650f40cfb8101539511f832f0f6cb12929187ffb9dac86a5c0b94262596ae859c210b70f669dfaf242eb6846d46fd1a1d43a47dee63001da3537d3baaf9de8eba34a459a7c08953ad82bcfaaad7ac245ec83350ed5521af71068afb0ba5acf642d6281c37d1f62c70efc624e10399539f58638c0e18e6387dd83064ba82c28deca05bc41b8845dfccc3feb47115515a4bb8f7d9e9a607cb1cdfd219c7c7d841a27ee01233147adecc1c6016be7f8dadda3e5929fe4149e28ca22aa53956452b5ae9a26aaa3170689c8fef9ccb63ec0bd79417d3e5713ac977d1e0a186bccda918f0b517c180fae266ba89a609d3b49f764a736e360484749396503c45ed155bfd8296582a60131335a94d26e56ea8545ba73a53556dd82a3226ca473ea7c1284637f3fc0b14a67734f735c5073db8b2274dedbdb45d3b3a649cd52229f9f1ca6a56bdfbd5b09e402100609c4ae4950cc15b4e376e0d1c789d6be58d54048b512f9cb7e67d5b297b5da0a2660c4d449ce53e28b6781230c3973e8d90480e643c5d9db0baefe42a92754954544ffa2e6dfc9271773aa37cb8a913b8830b128bbeababad36d70ecd2e96be88b7585de21aa6ef3105532e36e85cab2a4d30c45c912439d803c78202a3eac62239fa75ed6e77e68037b59ee292e36f5521be84bd3723d228e524e04ab08cbb2e393d9d759ed6eaaa9ba32d93ab44c003e9af03bc9b7ae989f7733dba665c442645662b36d8b2234d2647b0dfc557ca504509159c4b013607df858f1d0e82310d902092d7ed7676d85fdc53aeb1a61b690ba9e7099e26536b46ed337ffe39dd84c2a92c9b3b6f0e21c2f018c21a75cb0c62d2adef1ccb92a7e8a1c648a24c44dac9a055e9855ab3544da2023685326cf01bf602fbeb127c2d79bc44107de459055913c1c826dce4222dfcdd34f19559fcaaf998cc66c31125090dc9e412aebb898d4814c428b8e93898a35489cb9fc2ce90816f0ad92c9460beb5e5d3e15f7146b8e97f3978481a06f4cb21949c90cedace6069a721c889eb1ef2b052a03ba01f0a5f3b4472e5cbaefb69ffb25aa406241730798443a0c735f8aa736a494ae040bbcebee0a4ec30656224b2d263dc88755f936d5659d0247ec5d96c50765c2a08cab89767c225175f4f7a458d171383ebbfde57c3e88ceefa88f590bf413d8c10c8952194d1a1d7d9eb820bae63b3b2504af5ecde1c945944b27bc0ab5eebed5bbc99c0a784f7801f976af595db9518cd35ef09029d7a80eac739786a9f0c071146a3d58eca7678d52dbf7256ca60ad19b817fd68d6ad3dbc3aedffac05bc49f86295bfa63253d2626507890e373171002c77e52cc2742acde72c31296c7d60179ab92734e55c144b92f0e386d91d7a3b1a65925a861b2de70cd4e1bde0b13629135f1b90da500f68e70576a001983e34f5b1c35c2344a40b27f8869e01bcda23ad7c715d2a2ab0c3d639ab7695f60e851efee024e6e3609ba2e6cbd58d53db68e8cf746eda93f866fcadcb063d2d982f6c36080ee41efdbd637f9c7f230b7e414c6e7c401532ab6de41e5d60c245b5d0825b076de752ca6dfe6800aa16d1c8c042c4629de6643f39db39bde1d5c8a551cb1138410ffe5177163402d2db687acb9d3b84cade4b4389eed9ed0d98e4b338550986bc688ebf699feacaa05db516b1069160a6ceba5cb969606f79f3f3365fd4ac777b917333e9b41238068dc2e425a676e2997497e0a6d3a49ca07da048ce1979617683ef91ec3886fac558939f251c57ef95b244dd4767327ac6ba34ade5c49568b5f51b78d8b52ee166457f3be6ba608ecf9c86f404db0b541109cb604137f93eff08b5c827d8494517be1b4f4b7be7471fd36e59bbcf612ccd7b51670d30a98438d6c6602d3c7a2d57ea66be1daeb178aa2c0bedef33bc0ac387e56dd944a447e755b1479b923b9994be8d5e61fbb9a26f7ed22755c4632b3d2629243817064d6bfa860f781aee4d28d247a803946a19e3add5d5b9f02bab694a2f8e67a3bc0eceff5b72b2ed435bb3ef346fa3aaae46d3186a4a83ec7b036a1c80e684ad5ff16328c95b7785928905638afe7534c20846272ab1c569d449b3c1f050c13cbf11ea1f029dc39a362c2376d98cd1dc5da75acd7c7df78643e7381712a8e89dfbef42bed5bb3d4f33d2c95acfec1c1e35833ffd7c3c58a3d990e9ed8c1767e04cdb1b62e1952be495d1cee3babb094fdb9ae31ddf00e98d181b0a4ef37457985731bfa9a960ebbc5b65bafcd7921454dce86454de8e49724dc07a463f86272e190e2f8cd0541bde9ab2bd31121589ef6c92dda9264848951be1e969a7ce4da05a35dc50907e1f64bb64d899f07157c954873a4a66b8f69541f33065128a027abec503b19356f93b3654bcfe356437aedb0ae0d8c9213f14a365616ae984cb78088903091eb5b0438abf09a12b32ab76e40fb3cf48bb5a9963912d3211f6179e2481d7760cb0028e26577c23102cd0eec9bfe743aa22d32b8632b0286eaa53c7930440947311df9089c89abbe81b0c51e2a3eff9dedbcbbece00f9fe6bf4e6f43fe4b059be2a3ce319dfc44bbfb1dda5ee109ce06a8a2ac9b8e8ba4fea59d14ad51f081cb368747e28304f9d2de0927e92ea43a276abd15df6a5f766c1b4e37c22cc2b315f7d971b8c892f774292dea52ceab6802239e0f6d8534231adfc82ba5e8c2308fccab07ff8aaf0a139ffee0869ae3b55ce8f9ee9bba0b997c15bde44afde7eb5bc1ad1e4a3e0f9a1d8931eb4c1f9e588143465a5d0655544c1a041f18ad2fd17a5f7e026443437cde69b9a528c08222c699879fb9a3bfc467f378ed461aacfcf076ee7ecd57b21ada1f341064e0b26e74c42ebe21ff48bfc8c78c04ff7eb7b5ef1dcf388e5724270df9cf9cda902eec4f465a8ef2bd0da90c33787d9bfdf77632127eb241950b41bb2c4a6c3f02ac2b8011f4a576fa83b15386c5bd983bd11a28b59df6b3c5ffabf95b55029964746b9415f7dd7d9746ea9f67957655fc0fb39a946c6480d8d08209b37cecf4787c948dde0e478a0188b33e5dcb81bcd8f99cccd5dc129e2e66e00690887879fe17340c93ba24e232604d5772898e20a7bc2b3f368f06b909ab45d60e48d46eb1c19fc02e3212dc5b773943beab9f0f469d35ce445176ddef57d3d5d16e3e72605610fa837f42266d89bf3a6d65502b7dc0587c579a62a113b63fae5f75cfcf002cbd5ea570ec5b2d14a89ed97f4670bc2adeb6709418f7e164c0ed95ec79c5e350b9aa358642857ed23554e903542940aad59b2123fe68fefecfcb279300b747698bde314630c271e81ab4871db43dac5e76e07bfdb2567dd28b9388795c87dedd4593839d872d745b9884ee9b4f545ae6d83fb154103c9fb742175ef8096b40e6f71351ebd76e8020a163393deb47bc29484fb049d9e77802e68f77c1eceb4483ddcd297bdaab867600a347828335ffa1bc5ee37fa3493a4e441958918a275dd0a1a9b7bf7eb191ff176f0e6ab8e0e34d3f67b6ac41c38a523119a8b2f50761a1545a632d176e6d913f3c43729d7d97f8c2fc58ec101ee4eec1ce461b35c5d8082c32e582fabe7126ccbc88ccc55a62a76743def579ae2c2bb90137522ed25d8e385c87de75a2af9531b1e2f1c9361842545ca33417319cde10801037ca130e9e424c6960c45d9b4d82cfbb1e8b53aae5c9716bf1d3feb59bd81c7615b642b2fd80ce9ed83f0d732916560972a40343da7efae6d352c5f1b239a870ca482d32a3912ecc6d0c6bfd5efe5204dc2815975862d2733df737b5dfb874eb34f6b1ad0d1540cccf80c0bdff5fa95c57c5fff42e2d0801dfe53e0440f5fd44aec593355070cb9732f8f475eb2c9ca01c39cf023d2ea4f7fae71f6115fed90152e0b092ea92a213baa77f50f6de48570734f56d8321f8a65fe66baf77827b937564e1062f7eac18ff477e379b0dcd1d2051890d7d291a49a00d4ddf1fb941576a8a4bcd92b1c43769f3a8956cd429ae03b68384f455707a9b15870cca59c9cbd55281eb37cedbe216a14874a20eccbeba19d61f372bff18f0856f80493feb6f7fe12ed4267038103842fc95f6f017aa4f05fd02421a657d2798678a3768fcf20fea1297c6050c402e38cd2486f043d70d6fef9cd0cb7dee98f24bf7ec7eda2c7758fc4513f65d5e64f2fda131f3cb9c8d373c3c8bd058566aaa8c12cc77caa97ca51ea3a7b13348c4828b4da6a1495ee9be82b43d0e57950873354399553b5976791e4b37421dae4c10b5ecce7887833286d9cc56d9bce2083ea6f2eb6505462a209eb97abf3c9ca286b5ec902a3076e398c12bfeeeb3a9aa32d14663a034d381406fb742373262d991d10b649b87054dfd71968122f9f4d178e0ba664a3c20a893c738c503f1eeb3235e34d49dd5aba71f7616ba969f51e477189227e811831f0cbb36d97cd39f4e04f9c62e0a9975a7bf8609faeb2357a1dcdfa29ad26ff4bea5b3c4297463a8009d1750a2fe4db80dc8282a00ecc92e68c5fde429e19e0b4ba19c532d5356302c600659e8f11e8121203dc682a476ffc042f2434399b93ad190936c00ded1881b4e8957f6997704fd531019d1dce0f0e92722aeb0493f40058f9b41039f0029784c70d084d4dc0c4a5034a46a98a4a1fa9e4c33ae5c388047dd8c8280054a5430f95c0bc3072c5da7fec2190cdbc03bc2abef1c20bcb68e993668b54dd7cbf3225fa909df7bac749db9f4b4fc76e67c669311604b736020772ec61b8c00b53cc0645f24102557e05513d7f9232117d5080ff4fd924465f546b168e21fb12d399fa0be244f8cbf12867693d33442df9856df00b38f011a12ea3c7d7c273055fe849f0e5578d6330474df6db354901752f5abda6ff4f9d5f25e2c76d775be8d45588678f1c286570f263efe0bd6edbeff6f8bcd02a5a1af57133f2677ac0a03e786346d847dfa59c2db320780eed504a4c30d4004877d401e4b104aa2d8592eb6e093a986d018312ef149d0b21f0291f2fc4e8748b5c5c6150ecc7cf65398545f3126217b12bc68db1185fa111c3feff894686540c59b14e7974924df58a246efa5fa09d0dcaccddb7ca6bb9b2a20ba1b7e5c50c7eb4ee3b4c60f5ce036ce50d42b982576eb02d790ef424773294ab7ca748cdcecdc15236551d28740a58f0380f38d8e5b1f41d257ff54233efd1566dde6e321519371be8318ba0580cd5f76fc1d2689e478156b94dba035150712c109147cffc96a25ff8e87aeb76f63fe6ecdda7afdedf023c48e06c85683a00a79530219f37b08a53f1f47d4670a887bd7c40d5b81062a71b712917806aa90bae61ebb5d62d170d3d6f0a8482cc35ebf247201897a25ff414fa6d9f845170bcd3f44138813a568721d54f6c8a6dd479ebf8c865a0e4053ef46667ec933253cfc2943b99e08b75de46bc46d4eb734efa6827b4c9e80f068974a004114ddef955449908410fe72080509135acdf55dc383c898ea142b1d1147a5ef36f9999d2e682a1ffe3048ecca5fa058ef7b52c435d29e150315a8b8b28eb54fce339b9d41c255171c45714c99956c004b963c9b73d2334c89ed3d0a2c8c0923d30b7d60349c86296f90dcae79e6a17694206854d49bfaf498ab373e743a7118522b7250af4053d40d4ac1daf7ba0e1841e5395bbdd6aa83b0731fbbcb2a748046de98de41483293381abdbd9bd88f0d872798c18edbe1eb35f7a7093fa7fddcf799e1f3ca8681a17986acd56b449f9e31168a4c33f00f4cceae1198995f7d4ef5443a76c5da0d07de903a615ebe10d8376a88db356608abe380b74d7c95b523dd736319ccbbf5c59fae2194858b113fff14020b11c45dd3f1078e936c0f96065c5ec094b902bf838049f64df150e9f2979dcfb4c59d14783b958ee6a18f6252045e0aa15e21236e604f6c7cfb405bdc29cc31d0a55f5225a6e73b988d68fcd5480ff6937204d2264214278386f0a8f30e70f20e1448c1b0177319deedf2041e37dfb7c3ff8db2a22a5d78a06400c534f2cf487a8d28fbe24a0e928be76c423729aa5961f8897fb42021f3a20314045e3e9a76a3296e0007c9d0718fdf74e907eb7ae846b4f61da67650a77b2170b5b9db96091059385dc27315596869f970c411c49827768d4324f4e2937f80b993642d85f20b2a076bee6bd4ae46cd551021f5d33c30e5362ae64638267994769e3635c0beeb6c9ebd32941ac48795c87cf99428fab2616e9f0bcc7f3da673e821670b0fe8bd7c311ad26d71c1e4a5597c1b5ee929a48548de846681b1ed8578354255f904baceb3d77874664f774873189f0333c43a19e5cbaad5b30cd93859de9203e7b840ea10e165051b52dbcaa09ec2b40fab5833a2972465f6bf158ee0b804ff2c99e81e3f8eaabe4b027324e6161d53a7be6d81f8795a9756c0ed360ea4f2a4645604b48b42846f44006b10e8f1cde12f5f2df9b69b792da5a702ed588528f2ca914307c114342264128d7a20d41756a02252dc091390f2ebaa0c168487672f8e9d88728c381d59d4bb00dc858d91cd1c76bda0a8baf86a136ae0cbdd7b4eed30089c819ca373e4618b997fa08c5ce3861ada3a7df5ee9efda005de1ae4884bca48c6a7d3f7447388cc74d90f7e7cd21ecc638f3ef67e95372ad0227a2f9a7da2162313f20411bfa8221f3feba356c1792e2c51135695e974ec53e56d7e0806204e5b16298af69f7f3f17e969ebf31bf49e8fc97414aef674056d45128d935418de778d3a635241bc0747f1697fd902918b6e455e46adec898fbc0a3c202fb41b7303620833c5c2f1a9cca8be6c23168fa9320646289ce319c2dcca022bb4291f8d6db470eeebd5a4978660680acce94c6470a3d1b64961da693ab7d7116579ea6a42476cf79326163c5d5ffd1a6d49a31018072bab07c832b125c8c2310f95a2008f7949606318b3d8eb098541ded5fe02a8c034b19f15491cc908addbbc3922e73acf8bb7787e1e534cf9e054d3e5874a977503fd93c43098bdf4f461f0e15631b286fcb2996edb48ed5561c500a6c9d945e42385108878957df6af88af34a21bb86dac602085f8103c32fb15afd3f93baf259a60992dc71d2b448276ff743aaa0fb105eff03711f10f8de0c4e2efbf0b26fe6d69680dd846d21ae78f394a5ef33fe10d3c7eab32720fd75fd42d6ef62e0a1d4964d2f7278fdb792b8e6035b52f414cf87d56bba2e6d1db2bf5b0de84fed96bfc7043f9a5426717d7be162890282f024b7f5fe1dbb0ce5072d1da55eb37eca70b262b7add91a46e37f398ce66f00ee9bc98b7a7265122ae64666cdf3a644948eb733871182491a7ac19c54ad4c4b3d6642524afb70c8304d174a6148aa13ddb5d2da8fe0466778dc30021afcc4f12816e81c4a41fbde67cac57c2670d681544bc150959018b9c4f4204e7943f878cdd991c1e4e359bb215ef816a2af601a9afb89534e4b1752e69e2ca74d380f75ad1c433cdb77699f586fb35e94716d5fdba5ffe897684af34748f8d1a297a643acbcd8ea9f6f97b901172a0d4a7b1b4e6673755f98b4b2f43ac8aebaddc56ac5254e7773c2d232b7ead6ed38e3d4f95d6d29fd408ff4c7cc45b152a589756b61c537e35dec155fcb752015d59a1dc435b77d1cfbad66672dd4fb760d7fdbed59b7a473badbf88c38d73de73ac5557cd91ffa742af7c27c4339aec79f79cc0ef913e44d5a57eba034db4ca9967c74a99690454e710a3ef4e4de36ebcf06e58bfc4a03ad24b12eb26512de2c0402fa2f26df62fc0e5edc13375174c52cce2f839d877658b40fa95da52b91dac9697c11fd9b8094993d7613bc960c391616ee59a717c6b0adef8e643cb5d75ce141403f23e2aebf9987b628efec5edaf988d964716e9eea4f8b50b14cdcb624e29e7bed16584081653752c6154f44b9974217e153d52f6d961830b397abe861df2ff52c00e8c75f764e16edb2a6282b4a72cb15023bccb62fedea176e2f1218be2510b73f60c5c6b7f7a9b1a98560e617dd2592d3f71b43ed3a4bed087dbe0c8703e107f5256038b9927515a374915136d833d1287a66babdeed03df4ad278e916459b36f99a17fc506a4dd87d38e93b5b7cf7cbe7ae3bf1859a83665a963fce02e5ec149a372505165c716f4c82be6664f53c97e94d962c3d395f1941c84b08eb66d3ff13b55914b08c030781ac7d8b14d2b5485969ce2cc3b7165b300e9807a8cb75e562be6e42ea2efc3739d293f15a0e7d6661f580b0709e4dc27d83f279f9cbed63c983e5c772433c9114873db0b5b173777a92dc220385f8236b0e68b71c138bfebb16102b4e536a95261d9f20da7e88f960edbe7175652e101f1e5503a20aebad30dd11bd67c8aaf4b1bb68d9d89f07ca151e68e562f41ee7c25d8eedb2f8f5e44177d7dd71160b8f6b45e82b2a86039abd161a306c3b33170bede9bb84c963479777cf47591ebe744fdd39168ad0fc3a6c7b59e71d75e24d4f80e6e558f2a957c17af8ac4e94d2aae1e0335687f59296500dc574a73749b53ea42d3fb980e437eaaceb328dfa5668ea3c5a72470957d355f7d403471587aef29fbb5b6828313d907820e2e1718964879aa70a4a7d8204ec825373982e148714fc91ae0c579bb8214668602a3be1c080bc19c7a9c3445306f97f8a9252a696f841e8b73e5d30e9760a70780dfb5ef35e27d59581323a263b96903b15a999c910eb877d7e6f33bef5848fd301857050851b3f69ed1cb8147b8456682132e8db694007aaf39e1885f002f8f10b9a31c54536c098402af62553514a7b4b0acb68615211276065a32e8588852bea974c19330f9361fe7b2c8a976e0e75c4f5fad68040b809bc87d37bbe24dfdfa12573a3dabf17d7cf63575b7e1010c081de6b9371deb4dc5c66161570219d14627905149bc33ce57a0d5a8f5e9e36a646360052b03639083b51d6f905652c47ae759c4b6fec615d3f5baeb41710460c8f59d50a749198d1efa4bca661e81e58ba449476922ad1ea15901bcfadb428293a37b2730a168fafd184438c21aa123cd5f478f90cf980e6f78ef8813b68c5fe72f9cf3793f6f22a9110b7a1329bccfa54d852ff5a5e5ec085ccdf5c0c7cce17170971c6d48392e46c3f500ed1dcc79ed3533ed4a0c7d9f0c4490ba470a982a67e2b8bde281717dced47bab9f43b886425dabfbb2ae6712a9575b7dc476cf6879b67dfc3abff0d3e69af1beb8c68885fa87f11caa93ba2d3f716c82c14c5e85355c8eb09dfeddd4444e6cfb7cea36b8ae14512454b813b7c8c651d6f5c9dc1c2689a7d364cded679634e76d4870189708681d569f9cd181edbfc89f727ea27f7325382445d8a47840426efc66e719853514f99153108ad68323c62d541a239ee0a69bf87b8232f30d97985f124e27ec84dd0d4ece8d1349b26ea95fe504c6991a7ed6420721f7369788f104bb3848681c7f000edde4d14070cbed11b4544710bd2a62743073a6e0412ef3feceef1a05e92adcbf9d267c8c158ccaa9bee0b70f447fd1e4edcafaa931dcd395fd1e0dbe5d9ebfcc31b0bd5a2390edcdd21459e0890a3f17981d6a938e7b08f5607d022c16c3f85e4a2ce874e426dab403d2f6bd5ac2baa84e8cbbba8b9d699eb72ff7e733b28c1f18e1f6031eb7e72c53c1421eba2a96ace937d1361f1d9aefeee43a26346d3579dd99ba7d87b40334b2ab72ed8ed681ec1f617d5a55b018ca1411d43a4864aff8997a4db8777f66eb36c4906114a174fded5f55771fb14068594eab1a79c2c76e977a18cd284bbe56d801d4df2de6f59cfa877a76e6d3aea50088ccdfbda37a184e31494f4df04549b8fa5fff8d6c1d2caa1b30f38800a9b94fa272892a6f7dd5d5508551aaf2131dc7e0006962155620d112997e6cf488573eecd3e17278904bfe3909074c844a3da8abf2c939e34306b62c3275732009607947e6e5b435a34bdc7ab750cd797cf4c2f0291f3d214fcf715615dd0a14d25bc6b4253fb98775ff72bf8de92095f056634ad331c1ca978630dadb0d9632a8ac8dd49b318cd1e44e486276263f7ed667a6802deaf4389526720e2ab356feecff6e1f42c6ca0b134b231512c8629cd1c6f332de30b5e842a4df20388ad9141c5963d354ba057564a78bbdaf3907caddc4bb2c9b94f8298c8cea3532affd5ba4ecb1ea7471c22523dbbd41adf61f9d12b07ee082bfab4d4a5c37c5650b1987dac0c8fd73849fd12b438642740dbdfd132b205f848a377ecc3c2188439177b5fa951021bf5edc02bd008cd5d5815eeca17ac05b38bdb80615f724ccc236bae96749f8735e57e3cbb6914ec909314a1a2ad066cb93647c29c003e841e0b9fa772c3cf4be3f0c330098d3e5e805869e8196c23d951928a18edc6229a80e3eb0778588c2b4fba9cbef45ca14ccc1246787ebd2aed991ec6145a651842a68d46239cb7687eec93659adc29fb7474a14f805c448d6381e8ef1f9a65677e81101bc3328d481258c30f9ed739cbd81e4c9575d2b422e38324192cdbae06a540feff713816ec6fd5d1329babd4cbeabe710df8a3fbc5aae0fc313dfb46872cbabaa8c7a3776a5aed786b984b0516e8d2a983b6874140c8e51967aedaa9b3949f5d6e1c0900a30126084d65ad813fb32bf62c28609caaebb01031254b63f1b8f622f8c9b7ff63c435274b9870db2824efe43785fca72cecf3289829736af430b4914a6447a90831985358081882e072e7affa415d6d1ae327cebbc83e2c805ffb331b3dc597e4edf8ed4583de2e3224e56a3714a06158506b989bebd3a28c1582047f9cde633d01386bd4582722bb8c6afbc7e637190ca3d9ab085905eba5a7ae8703ef73dea8c4884c0800f9c29c45f2a0ddadb01906cac20775eea30bead7bffd2e110843e6b9e94f2edf396adff74456b2e49dec5f2e27c0ad3adc4aff11df2ec3d22789bb195ebc192d4ba559639fc42711f808118b8f4d57646b8106e58219fdbe752026c7f1a3bbb03dee1e3b232adfae936d1468a729dd93bba662b7566f6c8a13293e3cb4b8493311281b6520d2ea2591c3d39ef906d3125feec4f6c68b28011c79d4a682d811c9e4c48d72cc8581ae0f12bcc9ea8fd95c04e18126886bd478e75144c407881c07cf085c85be54813a4116b9e12ba5c6bf2d5e49af56e8ddb69f6cc29eca62608eab329f8c3a01b533e63f806be6b1070700b1cf1bd44827f57e20e3edb7b2bf62b6598865d35a743d32044bc8760fc18872d048a0f61a8aae4ea10d9a42fce91df20c891a742f72f844e596bffe77f0b0ffc45b58abaaca39082233859d915ed52ef10228163c8a8fa94b6102471f8810b94a5fd94313aafa33ad617e406b7e51b9dcd0b5686fa5a1c88447576caa0b50192a5476774beb586edbc292e4d828a07da3c52399b85cd4af91ac180df1e8d1e437ee1cb89274b575cb8f9aebc0257d8e0b2af1701f8780a4ce63c9ce65b226e26173d727d8d4fffc091145ce2f7a299b6508fc2bb5f98bad0e6be39cebe28e9049d4c5e6b613c7f31b8ff2bc689c39a223eb51abe7578ccb9057cdecf3b41d8c618110c0fd58705c67bcf0fc98dd91ae68ededd62c4291f8d27f7880a820e843afa28528a5dd77feef4be47203c3d66cbadb79076fb4eeb831bf27588ed18b0769fa90c6e2b1ce98f876cb01a6a7730f441576c82cc743e38c7db80e634f123c0313dae5a49062b230a470e928b498ae095eb435001afa07a939f7098fb3bc9059240773c28d3658c00835e3269aff9b4a33dce8959b7d703fef47c32cc6991697486d37fbb51f623e33b460bcd83ee787a4c72c198010cf2d7e9b5d64898bfc5c2cdaa0e5280fde3ddecefbc9b46c875170ffcafed15d93d53570d5cd1c990b33f968cd65306fe80da3d38aef735e09a65e08c87ed84752a93e7fd307c94f5f8c73613b37bdf93b7c3725665b4f5d2face60e2681b14900bb1caaf1f346bd73b37028f12c3882f2ac6d576d3b47c9b3ab2ec07db25b5382f381b8d5222d3ad269221234c18f1018a498a94917d1fcd8b3a9465214f0d14a35b9615bcf5be2703c57d481196a3a1babffc147ac98f7833aaeb514981379baa96b553433553b8f5f38644dd8f1de6331f47822b9fd55b1214fe1b5aaf1e531a8b801964103bdb293993c754f84ed386b943ca20e1f4d99e04b6c1e775c59d6f723c92cbd686186a1f2b4846a2d0eebdbb797f735ced26fb20d5dee8f6f393d97c89867f8e00d0cc94c625038c018e5979d7ca4d3c11b2740ebef0914f689ea65a43424ef9978c0b8346708e7db1355b126cbf4f562ecc41acc18c954c98a206c587663bfb55eacfaefeb341fd66fd1d37fe2ab96546fd335a4911eca65017840de12b13c2c3effaf175a24c4d781eaf83637a3727ede0ddde080622a24a0cb9baaeab541f8e3af41a1f04a0b240df6ac70502b5ba5d9577335d891c094e12b9f0a5f82c3525542b033529b83957495e1e5a34e9a196a6382cb2adce8ac7d842dc0d705e488fd8b172ec4b14732e241baf8ab9d84d3111b4ab9198ac660cde8244463a520b06fdcc821b46a1ce5cb18703c0cdc032a5c00d99ba331d2e5fcfb35342435bf1b87ea4162871dfc7adf4cb47576fcd6d8d97162a46a2d70aff70193a7e5139634dc45922d7d5a158cb016007b602e1e97c2a6ac687ea38ebbf002cb62107e11e69c800e46f9ff7e526a833cfe80f44ef8b4b72c750349eba3c6cbaac981887d25d57eba4b138bf7830f128c61a49b57a749be80045940012c52e856d6ff8ccb97e93129da9b69466720575b0281f70d0f6c1dd61b6c18f76909c43e8b3de17fccbf6093e75883e6706c426f6cc8664f026091a4d818e4879d167c3be86f6eb1bcf3e83b3845ae3bc20e882158cfa3c6478509284d650a643cc565772624972f05321a669fd673fb4fb5183c57827e45d8d10867d670bc066772dc4277c8940eccf5a0fafe289c8ea89b7b9ae8acfc841cf990619cb7d641dc5a8384f810ce766e9dcde6a32ed86dfaef6cade9000c6b5a3ba35644bc1804290b5ae19a0af9a63b9baaebadea8244865d9ea741ce5e779aaac83ef747171d433434023000a952e6a2a8e54baf35c4c6cbd0591c2848111b8d255263f81cebe51d77939ef6dbdceb7ef6b354de7659ee352bf34368b482ffbdf621ae9511fcd98f3329641fd79565445008ee578d861019dcf9e02297bfd085cfb1cdc37389cc249d1a91ee223a167c85284d04a01d3179b8ef2bd8d737509bf7d79aaca1ac720384bff3e067f6d35d0a9cc73221b9ad493f1ab17d24a50cc0fd1cce98a698451fe32e4bec928d080b55ce9e88e5e9b1853a73feeb417631183de62f94634f6deeb30998423d0ab9ebfe37c0cfa4cb0cf8ec04774be78bf21289a3b0bb622801827dc87073c32f2470adc9146d0eda627381bd8787c97f1e2b4c336c71709c299f2fa9889434ec3e7d32d260e23d39f83c93eb664e3cb06561af8b9e14693ccadbc2d66be1ab1338e30af067120d4d177551b9c640398ba03039b6ef384a195dbdd19cee0269388cbcb9a0831ed94e6e9def08fdd2807aae8dc9b3a108b8808e48f62dbb722b72717d47c7b01491335110d60d5a3b3df46950517a201e314b84646c59ab3fa65be06158fa36fba67ba3a03e9c1650d2ba38830db44ec0bfebab61024b495c5df25de81d0329215fac5980475dfc12ba59264bfff1475e01200001537e8414b84d47e3d001dda42cf0263077cea4fa1b7325973b0187bd5a20cc793fdd336b74de8fa046312a8fb3d828803ada1d27fa158983a66c3f720c524f95e63db83189e038fed1300c8929eda75b56c100a4abf87efaba2667e1687f4305863f3fe00917cd9034f627a3c140d31c31a19e387b4211b77512afda7f580120685e688e7cfa4c261f52ccea96b2427c332f8ae767e70152a7c1a8b3f912568b172e9f48f7c08d2eab68066004b5b4862bd4152af3e8b94acb9f65ae959764f823ee08090d83b7afee8a0bb19a2c90751d42220969eb230779a65e43b32c77304070f64a08bb84f84ab844adf2c1a12265512533f649af49607dd0dbbcd45808695953d08e53c5623fb81e6f85b620cafda84c0f6eee53c4aad99c5fe27f8b64eede0b313287a134222df8d97e9cbbef132613d05f52332d8b77282d86813d1529081fea1c5cec77f31f8835e6b8537369563417791df9dd3f043fcc1d6baf7f6d14efe342be144ca8896cadbe2a0052e05b44348a0df2a8a716a351212cf7af3a221bdda1f6b152b0e2dd2bffc718727c82706e0ac95537ab4e3ed19226cec50422c7354352e9127632414797f50947d9171167903a1d32c04d6c0660db5df31bd9a8366ef2a959499aff1d2a36d77c7b7fcca","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
