<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57a4e7b9caa4421d77fab37477a3deaa2bf1d7a83d51bccd1c79568ec72bb7077f4adbf0da9ff391d5e90503ac325aabbb50e18fdcad6ab896c01a7c92320fbb141d3129d04bebc91cf6b14ad64c1cc1c6393116c979b756848525ae4c2e9ea9958c6b97f6704191e2ba61d434b14315b09565240e4387c4f5144758d659eb3f3a4c5e90f5b6368f30d7f864af0992feb300a988d7d849fb5989a2944bad1556e157d41ce32300f194cb9eab1d72355ed5463db1040c76ba52a0b1ba47412f16209645f4ec5c2d8d814bc993b50dbaffd4e65fd87161f924f40a75240b94fa76af59e1ad77b212ff1cd8eeba7f7544b1d978b5a808ca298d35e7a6688331a479f891112f76ab9bbe157df8967b514c95a5c26f36ad244fe15231ac12045bed83aaab2367ab4f5ca98822dbe7bfc5f7b31fd0501f5b675c0941f018daaa2562a5edca7765000d1ff57ffd6ab7663a3b9559b607444b8eecd3d125bbdd46eb53447c432a2fb58528978975d2221a7b4e9cc3d419594d0bd9bed7c2baea6996d2083f61b8a6a79f872ca478788c74495c96b51359ce9e028dd6df23779a272d30428180f3de69a440c68f8084df1cb2df803249e7f31565deb47a99b02421f776fbdfd6ad763353c866a2fa92ee823bb6f7f70f71f08c7b3fb037370d7d96d9fa3a1c85147c908ebba99840ccb938e9366ed8557fa2f2b8a28cefc60e405fcd4a6c01a60c27f687b45af930919ffb7612cc22728b5cfd280cc0409a89a0fd0564ecffb2156c457a673e5a9002d23de58c7000ed040430752db57c49a448e4fa4ea906b9ef9a0f3acc14ea727785d5d7e65028c697aded4e589c5e1f4ec98087bcb81005f22baaff0dde04518ceb98106230b24b291f132c01e065b8ab55ce393de98ea9788049c3b717d74bbf66df0950116b54efff1739f210c5feac1e19d2e92fcb79db14366f85e207bb653781c90ff7aab4a28847a41b8d78f89fa6849ceb2b534ce6596ed7737573ba8e1edf56475d0e134b4e12fb9e0e4e86592bddcfc4e8bd5b45606df9d01e642b2faab7914f5a4a4987ceb4391c1511bfafc907aa9dd7edf235ec229164da5fe600ca043106c89ebad9bcd0614fa744784477a30c99bca6aefd906a6cd6ebc3265d88ec59b4a64d90b81c43c4b03b951979e262d5bbc8a8ec85e89b1bf8cd1730d0f4451948483799cb29723ad773b88c78d9ccc673e692751df220ef0a129bc18785ad3468ab2e632ab5b77e9883fb7ec721185b918efc8d22fdabc3f68626850b0d00f91fc166c25daac578d68ac1153ad12c7fbc4340d4ca14f943af13a679436e236cdcbf5fed981a09473491c49354140f36354329c75677b81f1254b73785c4f60d94383e8c577532ed7fba963a7a1b031b41274623b8b91d1668af00553c911ea716498d518a1428ada8c0e17270267cbd408b413ffe717dab6cf83d71b938ead97729e6def19886578091910510d3c67fc8224c2a5d6ebd331ceba644563a744cd44657a2c1defc81b48aeecb05727270e203ecf1d42621e3a995035f33134953ea769edaf127076ac318e01fe07c5690c44024b6e17eb77c54ea7fe5009a9ae1d3817e1a236745898d0029698029992df8105058681de071a99316c18ca1be45e3c95b8b0a11f26d10becba2a2b334bfc9b84cceea66bf4fe2d855b7c7e60feb88975a9243df963508d1361f601c4a3c7033cd5ba30c705758f3dca6d5169d568f7b2a5f6134c046ad125eb102c2c511a73bb7ec729d51e949756520b8b3c1a56028328a4496f4677953ee0757ada89aaf6efb3c0c1ce92559593fadf7751f7c894e15ffccdbfd60b199b5c40ee2da7eaa5ebbb9a667d1fcba8f8764d4b812b3bff20bb5693502adc1d6d9df3f18414a2d678d077efea753b9a67d51710b72abc7c3db2b3abaa48702380fad314167edf581749a3655ae715455b11f9b9f39011796af8ade20d29879e93a5a81e36fa1426cc69ef51a1f3ca7eaa98707668bfefdcf34cb4726ac536d27b438945a17de54b671349308f9128a4bcade58eb0da5ee99c7580474883f96758ab86f57cb183530e4b28162a5087636351f2bd952648459a5ebff626f9c4ab797dac33cf0a9766136176f3d6d0c41e0617b7cdcf1dd75b31b8b0517987878bc1176b5a13594c0417f958437ec4f4522d2b003c374fcd6e13006ca6d11483f37b60ebb2a672bca5faa177ea266841e008b008036d51dee651289c72918d60b68e45bbe738c5502ae94b26828f005bef557d1e5aacb87eda65f2178fd1a5393e02ebfbe308e28bfecb43a2314f411ed707788907f308eaedcb97a6a83b0f4840567d447cf0d52acb573cac4d2a29430c0b0bcb505e3f6b82fe975a50c8f3173b52c4d31b1c290d11afee310ee391043918a8b387fe923332a757b5ee6ede5ce70391a9e7b2f35c773c5db97088294a8365dad403c02b6086742fa2131e644e6a6cedbb0036fea5e014873c61c4c00395150f1dab04e4edf421d0e102e7ce188f8d186b481b0ef28a6f7e55f157710d5fda132c7feca232feb3c5697e7d8558d152840ed02c4c77a93a10e4ec8c7543d46508cb4f280e67bbdb1cde6e860abc6065a86f77742c2e2521d541a047c769401fbeaa755327148925702477a3eb7e599b0693df61d3518ed95ee818f27ac8ddd8edcbfe71837d25efb2dcffc7a394e6674d9b2f2a12033a45177a815893afa478dd803e75f41a23c8497f481dbf0d9e83e3679ef2908d0d9bd3af4f82527da97e9adf572c6cbcc88f51c7454cc16c3bff2322f556cdd272cca41a151196ed7f0f6b110f51a02c9d74e80d88c320d900926f43809c9e2395ad8a29039fffcb22cb1cb09c92d76568b9a5eb47f876fd13886b4860e7f3491df90927aeee837407dce983c5faa3c9475d1e5683070506e61ed3999fe5bc54015d730fd9dedbc1c87c0eb95b21c2a72f12ce4ac6065ed74a4df0854ffa25ef11fbb76c3811f2a3975ce76b02fc0f03ececfcaa1528e61988e435ecc661b9137e11bfcd02fd5e609069bce610df5331bf8a88d3d6d90e69d5068ce7eddaf8ada1d7f827c0b3c55465cdfe39c23d29163ddccbf6698762442e81563e16027246b026d3096e5b802ef393f6ef44b3d28c619653ee6786d3c7ece9cec75988690dd7940ff3171e8a457cd074157873469c21c55cfb4c679d20fd1a08ec39835284c4bd5175ba1fd7b13799747f5585ddcf7b1beabcdd3c6b9ec7d7012d8d7f7f9b47727ce56a97c717b00b3b6e81848c37b0868b148014a7a764c5a414fd109013e8e16134512db9bdf6e598e2be80d90cdb84dcb9be5c813102b5bdf9638cbaa9dd824e875dc6a4b8c398373e460ca5e9ee0e48141c9b79962e5c63920986722a69cc49fff3345de87323eecfdc3d4f41c4e548c55abcb75ae34e5a38066ee60cd76cf4890f8f3f5aa4e45821afa51949e62e8343d4d64d63c2143c3b7ed6b7db7c25d769ed2caf9938e05a47a41246470504e1e0684ebd6c48d09891607313135f7a58cfbe509c11eecdbfb9a9575892d27f7cc55f4f14b494909882ba3d0e88b778abf80561fb764d32b4f851c8e7bc2feb1692022aaed38c99f0c25aad3f9eb8c9454a5dc6261ea990048cb2dd8d468dbbeb925d54fafa5552344c6aa0048b709d444737ef19312489d369d185bcb905dbdf9a0ca9be5681d76c67e49a4ea5c61ab5fb9866d342e2065b8992242de250c98a73656ed417a165ee05250589916ba6fb587566ba4d1ed31ece7c062318d8c3516888e5091ccb467fb29c84b3e819ab3420e06f64ce25d1158ce86f3fd83c6dbfb38407f63a7f428e493bdc8ef385fd74d208d4cff372aee97abeec6176771145ab761ca7fd47f13b275012d7f347756fc465941018a4999bd7b28fcbab724d2c86078be613c2b7d192555979cd0304b5b1c9ac6dfd3e30a1a000ba5cac713f0b224756fa9f3d2849fae727d4ba4782889e7a018e32b0c4bc8c4dba3f1f213451fe7d0fdf8c75cbc861307c4541264f490b79c3b1a3ae7954ee6e01f83a4d9706cc6df1aaaa8f985a833647a8e713b24a1072ef9e84204e8a9a0301fd3f5b850436c3bd92355d56d00b7eb52164d1960641ff5aece9458c6424c54f75638b53a481c30b7eaef7288217c0185c0e8679258b6cc70ca405a7daca9c5686e6d05a7b9a7a6a206fc22d05ddc8bbc3851792503b5d7f51765a4710a29ad67b492770f7d1700758e3f1cf81ee90e05f9352eca3e5453829636c0a96f1f19eec258ddae8952aeb49947822b5a216fb9fa3e094b87d57943a647c45b1315f34ac712d12c9b276784751c41bc9b48104232e9ae4ef8951c158fdba58f99c5e2e60952c078dae61d4a4981a721cc97d06d3047f13e91faf273ab5b45b8924f5dd5a75c362ef9a2df9f5354a7ec1ed89007ee77e9ba7830a94022124768abc321e1e20382174280f8737acf1ffd837b9d6519e5cfa3dc67e799ac1c05c9b78aa542b171a0b8e43795e1b5ac2d957216cc02d478bfd949cb55134c165959db5941ce330027ac74190dbc41387a3421e95f2e4d107831bdf3179ec2bda939c8a6566576f7983f7c100e54f5fd31f215f0f741afb812eb01e533b60c33309ea5c0c728a86270332693b369312b6351c8312c3368a307e8124544bb9ceec9b8574ff2edf2031767ab78ec782a4ae193a23b00192f07058ea4f871422eb81cee7a83fe042144168a0bae769d8cc1660e13c6d2e7692ebf81ce2c08c96e1cd7f4a7ebb8ea10b76eda176f1727a5d8d34a0e4448174567c20afc9802d8c1bddd5224d9893c5c06841e253f50383899e33620fbe458884c44b8fa3f630b5da7eb48d06219fda45369ccdebaa753235a3e31c3f1f34cf8f252b8a61f1a386ee2269ef7b54e2bbe5c360b4a994239e4fbc16b02f0b48aad2266aeac03ffe9bc1fbc677834dc556348bdc98bd7d9fa15cd475fbd7422f51ac15944480a5346ec6e2e909221fb064316f9dcd4d13e19ec9ffdc3b02a36ef5de7d69477164f6a65871739af6bf3c6db909d8e35e035d6ecf752975e549d7cb99b32f93befa0d090b0542f5d1439026fb7cadebe418c22577991b39ce90726aae4c924226933d160ce4afc019bf08ef37df7079b6bc0d815da46c1084c471dba7a11d58526594e4473338f9656f225cd418d0e1aaa5f3112f9d65698590798aa6bd5a4974c5533d73554a1a554e6e6a74577e677803fdca723f64a80a4cca5d3236e981e12fe30b4c31ac09aca2e0373789e2968a2912af4dfec112b42448aa242da7daab09742cb901c914db4e24b3c077faa2c8dc87b42bb08bef1779901d6c8d9ace99007311d2d44815b86ac67abceb22db19ee21b83f2df0173d53a27559cbc156d0663485dc8d099d933c88c65b51737c48eba33f3facf0d48283433328590ebb2cf5d6c1b1dcfff86361aee7523fc9a54d332a4c4a6b684e0c98f162ccb9f4eec44f53cf96bca1c95d922c0845f572239822892dd5a4c2e7ad41374c362684341d39a96bf47cb28d8977661c9653d90ec4f91b90cb5df874b9698d4b1f552c7eb5b6ababe6b9aa280e6d942669f2043e3d212c7a213c283d627a861ffde4d471cefa51cf65e352127f1fff399cfc1f7009ef731e562f7a839662efe408e47d931e582de778a331d1d278778ba9035da68ad0e248db9b4562862138f6f9c235477cf994d6a1c2aeaba40834e2a3b3d622ea0b346719d2d570ddbffb9c7cb6197cc5da4e824bee682a09800b608f81aa25c037bdfd3bbe248ac7448424a5584dfa9c7551137bd4d865758221098e02ff63b1243935d90eb66dd63eb98b5a0ebc746bc5d5373b9eee0271e7575f0682c969e92d050709218df97a39ee8cd0aeab584f886d912134b7d486c990d24209b717ff73a9623aa7f051b88098eb427710180a94702c2181cb6a4adbfa5665536f2344a8a9bb87b3266200cb7017c01b66b02e127f672b5c1526c2938c0a8d4b9ee5a6773a2bfcb6a13058b9e9a878cc3645f30429b177ccc615fc9678fe16e51ebba2276e7e1a85d718e82222476f078a5b2e0979449151b93fa9e910d1c8b7b8a610393235f2c86ebd61e1e39f6e44d03f0ff4c894ecf8e71ab05c5523b66eb4c06e781253b49db8e1fff62877812c7c3a498f54f08fdfa1d1b4c08c71c70909146c50010ed039621e071525e32835b09d5d8344ff8c26e7204083bcc2bf7f5a8cfb0350317e111ed2441a893371123dadc13b12f8c6925c7bc1d24f5c48406e0bdba4edcbebfa208dccb8268d1356c1c6ff36ab952e6bbfe600d321f18cb668d6907534b59e22a3f9b3b7bf7211d9d37ea60abbc4565a3a661505b6c8ace98db7fd3ef3c761b0382cfc4567a0c9243d97137e94bdd25ad4741f1075609f14917f2aeef2adb109599b1b8022be644076edda8aea861660b5fe9ce3b7d9284e16a84ace1f75d4c8bfcfc8d9afc1e6ddba8f468e544c3aedfbfff8a8cc4bba6d4a9bf12a05c27f0b5223de185135de0a6fffa5cb2df2f1ca0a62f816ac43a760f608e4aa9c9717049bb9ac10e351d6fe00d43ed03305c751d7b76a3974b9dbf889cd29c3551f9329444e33d70c12cfb3f2ebc6325e286cbdec1ab30175cfabb22cb8e2e193b9afd7cb9c0d4f602770b5c8e07551d9e5c42d4a6d567148e3baac9687cfa112c523409d2dded5b9319bb728b7d0fe6792d15cb99a5832d4b1e5e661887ad79db08248e8d3a76835ce2b7326096deb6dbeded8f388dac2f291fff188136cd9bae9631cfb8119136ec293f8ffc793a744e43bd36957aec6da70e0200bb4be2f1ea6018dc8da7cb883e87a7ac05739c6038743e4df480f64fec70b052534fe484a36e4cf6f5ba6b994cbcb00367e0057ff702433b98c12f991c4fbc754e32781069d332a496b38ce3d3693fe4d0b68dc3ee78892471c70ef5abfb7b016952bf58e071c4fa4be172a4e4294029642ffb8c660dbfc7724a2c9f69477184f4d75c473e4f99efb8a8ba07eeb26bc8e78db385eff5e752f22d563be1835b9892032835c552c6edb14b8a41bb214803db181015358fcc9b26f9b83417c1432c4d51e77ca0fd8bdc4950ce7201461cd586ec2ca3df06b402e361729d501d4132a104a58eff79defebc976e0a6a10b443b5a7ad1bb90694ae536030b96ce15aa550a703367a04ab18b6441baff85292bfc1f09d5940fa3d7ffe76685aae8654da3de24cfcc64f9a598827341fcfdde27468914015a4a2a2da7a445269ccb8b72014bcf462d5b58cdc38d1cc68d5c7419ca40d78729fd1bfc04a13f4f911345bcc15ee273493c3432162f525794d272833f56c99daad3a4d7890989b6b5f9fff00e8ffe370e98c67e833080689c5620824e9746f789194ee0c3eb725a3d2b5086dcfb6d317a5b1bfbeb103bcba4ca94e50d67cea53f6812913343fc54c6f6168f30021ea1879ebadbe9fc558e5f9a0886dc2999dc33ca2f8728366e7140fb670301930b0d9abd31a79c886366678a95799c7eb373ef11251a6f5652a8eb1c3e1687f8fe8dd9225f9e148bd85f71511354a650ca1c86b67d1c5eeda3ed1bdbec92c2b00f57d2555bdb447127f58d844c55c4d8b2a58a670ac2081fba599106270835bd053d87b30ac5c2abc5b139265cfaa30b480b1788451b9bd668295568227d8e923d9ef736a8f82d4aeca0e24f98a3aaf3be51d790ed65de09d6d2e6d6425fc4becfe58037194bb9116d914c186fe7a27db585206a37cf82a7cfa2fa34b6cb056baeff1b22d24e45a127cbde0dd873945b00b6f806fdbb414ae46e9ef7c4ed2bb210bcd60036e8bacff6dbaeab458fb5f67b1b737c4759702b30801fa94d30e64ee19e2831eb0c4c67aff652f758488e0e12870515fd16d2e9b5f40daa5b3c8944b752f01f5904fdb2db045d34a9d6b85bb6dc15e7ec1fb171f4db5cb03e30bfb3d50c535efdabcf53269242d02e055c3b9190987f2f87d552ee0af8d7af1bd617a6a3ba8cdb44aeb676b73bcd267577892ba95835819c8a5694038261f583c7880466994691142197df90a3e59cdd0b69298175bdba8078124ecaf51f6a23e2d0a23c4c37fceb2cfb07e90d0f7d33bb7471fd1df1ac381689bdac26ca2355c1e0ab354aa058938153bdd34accdeded90371e8e179ff299b690dfb384f3170a32d66a2890f15f275782812693415302c37e3d1987d78f276b3cd1ea27ae2965f1fdd2b165a83e1e0d762a3a92825d1c7b434454a5fd784d15c9b1a75c6a5f91f0860d18a99bc23a796ea27fb6583299aa2dc2fe84b50a482379a8865d9539d95846d5a989f8c7420261632922d19e98dff83f8e7d3a1a8995b2cfdf88290e14100c237e4d49bd686fcfcf35046ec661d687a1ec6e75131c38fd2f96fe1ee463bb84ea012646f9048fa7c8d36df602018203ce8c42decb82469d91e1dc93ea4ba1738105a4b60b5807691d23fb34c625c0ba796ea5a42ee757c2a8d013bc1201a1ed50c9d7c5552f36329c6dc5b37d8400052367a53b96fbe583ecc58711ce7bc41cddbba0fc561bc73d2194b1e188ff113abfdb66eba6d0d04c47b69bda7b0b6e1bbd502ca2a34349e08626b61abe453632b1c9db90bb324a199976e6012d8ad88817933fe8d812f1d74ebee46fa1761d0ce6ec906fbd3d4ced918d68f9ef30d25e5367fe8cd73323f1961df0c371740c58b4990ec3bfe9cefb5885ac22fd1163b69aa404674a5282cdab3f16a3df1e623cce76b527ed604b010b12572aea1b42ec0a64a1f718afa519e2d1f2bbb0c0e1810b033e35de871557ff0a865cf19ed3331d1dac4827ac6e6f5f6f6ee503fc881be7aa65784e8b101f298cb12ebfee78f25084b74b421e6c6014165f8e71d5c2e4b547fc2a276df534223da50732e8dca52144ea841c0708d36ed122b04ff9ebdcff1f351f4a9877b485d34ceb7de3c5de451fd4d6cb21d9d15cb120ed7964633734dabdf3c9c15e1e31919d8f61e1aa5589c7a4031de30be3d9bf356d30a688b51140d76f293f808757d315b5906e19b7821a5cc19038be598d33bd0d2bc0197aca7e5d61134b400271b69989f582ed7d1fed557afce436c663251f4d02b6f08355761e21ad7c67b95fa3372b8c9a4a72f7b60571441344bb1ced60a55d5eb19dc43f361156c6793b3f2a54e65d2fa102cc73a05c1a1c47c9658c5f0eb8c32d56fef33956a43dd1b7479e1f14e56970517ad42c8f74954702a9100da333e0b0366619969e95b21c863861250755a24a85e72304af2c18eb28e4bf899862e3babfc8533271a328b4c65fad72734ab012ca9ad330021d166bd3288a90a01837190b7317a4122771a0900ec834d87497300357fc647323e24e5cb8aad2ccf7c989d05532e4ea12934d1e57e0dd85da9e68cbe736d47124cefc5ccbfa0d310f859fd8b76682fecb45ce9314f945dc0c910332055556eb9956eccc9ecc50c2ae612c6ff7beae5722555f2ac406da42765942d3853600f3f40541357718a29e0b9ed863da3afbe38b6345af4c313821d724f2b3fe278afee71098698a67a9d91873f0a15eaa57c8fa6b65d8ccf55000b987c33b88f6c9d1b58d430d30745c3a1a9196243a0f83702a695512568ac2a3528efe555f73c5c92242d08cd10297fdf81aabf4c7caef0032eb7189f97656085d3b3c51b880a805a71f7dab8ab4a68fb8bbf58600ee0d385e063955d9f266ff625c8c551a9e0bc09c585f3baa0d567c64bf67b277dc0765d1aff87c06779f0d97d4e071fd66d0a3cc280a35cbeefe6a04ea6e311f3d33b7cb9ee7920c9405ea8cf775b4b7f7a4cc1c89182a261be0743c333fe85fe00de050701cf3096d431c707a3f35b6e0cf13a38e5b1d352283f6fb3341147550c97e5f9e8db134885a642846b3a845ad2f9a521c6f0423b03e0ff2c9a2384df5e118e2e1d17063008d7b0d991798a28e7b943a170c94d886dfdc7fca4401cddc7da45be8f1b757c75297edb94fafbb12108b156d20cfdc88ed846170a94a645a44a523ab62ffe0877c81cf3c53e3b68b9b210700803423545907223223414d5aaa0aaff18f091ceaa323d6752e642609f9e165f912b6b91392eac50b1a79549f5343fbdf08e891c94387d897212fffacf8b159389bf8c6c8c2cf8ef958bda656b464cfa13fe578a89a2d6f7c33a1bbef8643a572e77254b4235a5ad3ea34639e6436a92e8f6026d4a3861069876c3fe09bf16876ca33083d619b76fd4768412bdb72a1d7b9b341c0b0f994892fc753d0a3d7f838def9955ff5e26fa3678595054c126243433a5f21c8fa8652328547d9647001b6e188b7bd958faf291c4e2e8cf0b9f1ca85ac0de858841b147fac20a4d996c9417d3df4c5537c5091b31e95e04f29b5e1d9f75b7c2338a0b31c1aa629e8098d5f517cb2404cdd6fc9d18c79dd644da29c7833f58205d7b3fb778e5854ec15167c547c97c3c500c3fe3d93b3e25b4a2b23306236a7c638a0c18c33dfe512790ed072208b4326d5dddcf20d393a776128078b32fd322defe5139860cdd553227226c1014bc5273b85d4659da0ecb8caaf3f582028ab45defa5906d29d1658120eec6de6b7fc3c5b68f0e94754855108fb53816449501a8573534e97ae2957135630f85983b1dfece335e12bf37f15e4b2e8b48ef682dee3c8f3fc50dc4f47b79519a95bf556308d142b84ccd1e5b44d7bef3381742d7105f34b095eb9842974b39d531977ce62f32fad6623ada46ce1a79de8ab123239bc353e7bb99382b2bf3c7a3d6a20a0eba7889f3db447d510c5654239a3d42fc641f02912ed05cefc38fa8feb8957cdbd78d48f1ae5ded7cf469b4a20c64dbe78d291b28778325a11ba9857bff85da19c7450dbb02cc5e1cca19dfd9c9aef7cfc893891096b37e3ef789efc02997ae144824fdb4f76af9412dcef6352906712d169e758490b1d68542217fed0057d5f19bc8ccd9b831128160ee27e7f6d02924ab018e70971231f0019e9c7692671d1478f9d6be123f79986eb425972a3868675923406bda913369ffac8a4c9192676d2d467828ac8874e079b6e5c5e5a748d94df86ffb527c594141a0d7c5abc2126d98f254719119f07fb2219af0023f81f42263d54927e2b9f3e2562c205efff594c4e59780b3d0547b0882df1a5c659255b3f634c7fe3db4f921b3d629fa29b7cb9893dfb78aa2c686d7f4ebbe813b991a9d32b297fc1f9b4067b691c36e3ef74c7663e530e7da0186d8caabd7f8d183841304304908db5d1f3bb7843daf9c69f65ae8e9d2f403957fa5595142c5f6125bd8e5462e1a2078d342f5a195bdd3932e98f78100283a49d87c876b4eb2b9a2298ae49fb61546007ef9d121002eb03f2a2b87b26bfa262c9b7b72838f8f9f17f21daa2d2857c95db229dfe15623f61805f66eb864a33c1f25f1d94fe5224053072d76399e2e9166ca7f4206adfe9f06b41107a1b2656b45147ec665b644aac21a85977c40952cef344ba1653c1b6fc95f9d1ecfd9e7f33e2ac53a49ef18b9ce05a5dcc945de7550b545e9d93b0fdb609e8b2e582f4ac49ecb3b2926a56efbedb765841f8e7f06d25550462e448095ce5a2c9db2b9cb16449ac458675be240341f7a881fd0ca8f3a8f9df8b40a810bb5dcffb3bfe55aad747f4f081ff12b9b4b5afc549b54f47c320075057168b8fb4ebecc44b00c4eeb3f65e5e70aeddfedc64bd21986864f0654d9292ba5ad6183c073fbde25cd6b6080371841661442ca0e2a7f4ffd2d27d615cb72e207d62e6b2760f9a22ba9737bcd0dedcefb65218a0ba19dcb4ea65c4dce0184da8f5988989bc960e95ddb783a84b24b764d33035e3453df8c7282d061257307a5d10786b2e777b98581bea7fa543e61c6b67c23441063249bb224716fbbab5413932cd544398bb6f32c60211a7d43212ad493c8be1686f4001b5af4e22f9eeb2f943e78bfba915c1edfb6e5dd8109f6703d108928ae2a040e0e080d1055674723cde9e7a68bbecfa63e00837eb1c8b59b5be269414076568e0712f6d6cae34f24aa15c52e272c249f664eb5c2a9773b7a49bcd720fb812fd9c858143dc303c736896680be948ed9ec190d63c98afb88de45b88d3f982afac2d20716be3a0debcdf46c64ce1331f35c5bf1a0588555da956b2598908fc730db6b78e8fc1d77a7f3c47a5a23f59dbfcec7f41eb49e6f0acc3d707311ce8bf5f5e94e1463f231b24de51abaa0360daee1c258b07a65ecd683b2df3bbf186b338bc3d69b0de4724567bdb16a16c910512a96f35db6a90eee1f42d085471877113c2cc0d4b38222ab8c98bd4bdec4511920cadc466c451a5fb4c6ab5e1908e91902757c98f01e78d1a18112190e28b460a76beae5de9dc12d43fd7b85773b9d5372de18a56ed6c479b387e0324d89d6a57b894044d23df3acb634e5a53584a441f606ec9136d1255349ef929ef24b5b649de8eb643b902d41d505f56a06633f1212708b93225fbc37c1ca9641126acd286d58a9fed9847a215ab88d39bdbf4344f5835d4fc65d211d22501c6ee5f7ae5b40fc118e75204e029971142624798bf4d6bcaf3b1b2a4897486dfacacebb473d6d1c602943f20e903b7c669bc098a9b7f60f8082e7384fa3358222772caa8244fa0a190cae66ba84cc22f52be9ddd40cbe7a446e0b315bf4a2d26b21071449d831876a62b64be94830cecf488fda83e535765387afa6aade79729807e69d6fda0e62bd2df9977920bf1f0d2056680e8f48f42c729c155d9f7eaec2484efe4e8f9901ebb009128e6cca150029c3774f3556b854fce92d26cc35d35078fadb2490a2cf64e2370f1b5e32ed08f3c6566ef3e9f0c57b7ebf0d6ce75dc3899c649cd5f51514a463a8a49b66f041a7a1fc4443b6e11874cf6497160d713383dc6a737b5a017414e37dea0de1e6dd3a041634e5e3ac59170e7dd7a154fcd5e9ef4ca05dd18a13fcfb36b8b940460a49640470281af03aec8525e9477e39dad9d0e03696ea2769aded21ef0a4b929f436a51e6a93b0081e1578cf347f9d73c1c3f440ff0f113966b6c002b77c9f15c765226506a83bce47d415a1e0579b80330e6f752d1dde504d7a0063e3bac8f04785c839e0005cf302456322ef393a4f15a1b0dab3d01b9608bdcb0bb31e142e4eea0c111a25b4369951970af3de3ebe42714b76d57039aca9fef9c78386f7fce9ac1bc818dfa5a0f7f832faf1b8a58f62002334f2b9b1e1410428788c6a313dfeb8d19eb800826e020ce7306f31fed2d7673bec36edc5187e004bfbc3ef96bbfad05e2804ed8141d0530ed46719172aa2737bc5159c2d40c65990f98a37d7c9410c67fc53f5e3fc2f41571177b67dbd02242255c084bf74092f9615436e47a36e72f609d5beaf985937f892b03a97026b80dee47ad89f688d75b6284284f31fe78c44713a9ccc19610ffecb1476807dd7190de1e691e56e8a156466f2af7632614366edfbe0c5137d5e46aad6c304f6d2dc63453f4dabedea17dc75511627158e84a1ddf5763583909e2ea4bce3a62ad8c3e4354af8f13d41d0f9ccce969237cf2b337ef19be784599fb9fbfbc4cbf9169066fa9406fc5abcd8a37be83040d574a00ee6924c71ad8c94ad0f24b53986354a0fe8ccb795b7f6dcd943035fdf3b14fea9b1724fd60e4827928f8b17d0282785f111dbd7b246abd4dba930fc3e2c6db2fb25590cfe8e6a8610b04bc79750e023e9e7f0bcf0d589525bbe7333fcc740e32739b1f24f35b7b2a463e624c3f5f46337f4d77409ab717129a7bc869f2dede6290970047217b6ae02481eb09a9650873f7f529977468ae2153be6722d3281325f5b40efe023e7250340f7d84f5c809cfc640750f41158a8d2692122e6b2d8631799e98dbe751a1d27bb68bdc402c5fa1449df7eea637fcdb5cd9a1d6a98e1b0b99dc95a87d97739a5ca9ddd68ee436ffeb506e94fd99b64850dee365de01518528b731deaea4478c46ad32609799177576f4ce18b3062850fb4ad89ae77876e2e2a8c33c7f5851ad7bc08d331407182d22247bd0ad51e52649f206978c2d29e61222323c23f7decb413cd008ff7b70802e682852d6a368ad07680a825d6bce8588ccc96428c90730788c4c267d318d703da133798005708bcb41104b98a5d9bc598dcea685ad110bdbe08cd729f801158604231711ce068ce3fcfdd98d6ecf906dacf9874f61227fdbd70d89d1004c851010f5b7ea2f86b317a770cfe66a21cb61a8bfe2c3fdae3c2655e821a799b4098fea1fb87449e52a90859d814d7aa7e9f2fd69c08dcbd30690a6edb332dffbf3326d06d472f9a26060426224b48d8e78732a86b4ebb759633416e2fb990c3d43df68178fbfbf752a10ead05e2c1de217465b218b7f352114b0be0050ccd5b7f99f13802b278660b75c254b8dadd1c51765033537d6abc6821fa64bd7fe0e12c91b635daacf48de6103a187316951497a5663165edaff5e8501a85cf0f5e62c81cc82fd0cfeda4fc05e4f797f2746781c88e259cc62bfe7d53774e5fcc4703697138e176972e36221945dca9ca8ce3b1d3dce2b4883af3e7e8417de667013719a2ed102f761879e695be5cd2a691f106e68ab52426d751fb1b3f1897a16af7771ba5c71aa831688d150b22f63c59bc31ef10ea38eaf5bd81b8a692ebeb9327aa44f2e950ee70c3c8b2efd0fa2fad2544535503ddf624df4e105fad144b29f2ac43fdb0c7c5728cf4b7cf153e2f7e7a2d07785c0037b15b39ba2483390e3af4821bf261720874549fa9a45959d62f7df011fb1bb13a76dd300d9b38a5bd940eae4afbbb51a88df55e9e22bf521bcda42a76f86b155912698b209714ea29d848c8fc969de5c63630be1a73e34a72d105db355bfeefea11ad428bca58098df92814441172dc8b523cbab76198307fcd76cf7c905e5d922045546b2bd3be7c41954bd31a9457b284449ad5955f552ca1dc0b86034152e8514479d961de76856fc06360fa1e7af399979274b45a3f319c51c01d471997069c7f83c9f448c360a2de8396c0b1f0d0a497dda41394c6c60f7e9597aea61f3597d096d5187edde30272fca8f2122b782806e8c7619911df874cdd06820f765970b90dad733160470ce0957454b82fbec9ad33d93099af592a0a8c32eb3114dc2356989e5f843dc2f6ecc6acec8730c9fdb0e505138df73bc2a4563e1b12c3bb7c0c4e634537699f77efdabc647d306f5a033e1fe6df5acbfe4b0da11a9fea0fa3efb94ddddac46b39289c6de7e1a889c2258ca5d57d584c95479c61b1cb73b081c53598b63f2cb8bcfd309dee046ff5a45af0a4db854c540fbe0ed6e2b20d4191f4f1e6e3a5a7219941e8cdabbb10c4284715ddae606df4968d2d2d1b7d307ddbc7560a5c12dd37bbe7bb90026d7eac4e1ff92927319ca9523572508bf6e8fcd3351f38fb9c17a1c7735c24c234139f90fde563714439712bf618a466c6e2bd74e1c9404a1b491a42df0e32d4cb9f45716a73dab07c3099093a91e56075e8b285265d168645e18844bfac644c2ba70385d74e90e0d3fb7b5ae350c7f96b6b0d8a72888c22e188cc20b1cdc7b04615b8b93475393cd3a1c0f47f9303fa3de2a17ac3f5631df0117709c037a9998360077e9e35da2531d218f643442f393d2ba65a87d181efad52194f3634c9fcf246e46e5d4a23120f136fae6150e3470adb2258766f378c4cdd711d453332a7c73a8e996fe1cc2e39934f9294c2cdead01a80ce660332bce75432cf4d5a1e3c237604ad275f526101a60ab0bed9f7c0350779eb11414fc657448a62b4871e0d3d1037a46a0fbef450848f5cc26d432c6f7e6a955011f089cc2934f211c6001814d1e30cffbb58febe3c2532793c588cf00ff99f29711a76b04635d575a8d82ae0d29ad39e914ffb09f7ba439ddca8399ed28131a15d28c2dca99d34560b550639cc09ff938e84817d68b9926ee6181ca8107176d4ca8830a4d0a5d2ab6276de2e57bb695ef0403dede66f5a586b916f55caf427bee6df365dba42dc371691df0283f9fbe90c1a1383f156899aca76a2118ba22cfed9e39d1f2e8bf510f24313a0a23777e4bd271f6c1aac29d82e9e8c8bfc842ac3c0de73f255d86d1476ae159437c482e4c012419830604429665c64dcb7075cc7a19b87fbfe4132e482044690cfe51529513de54c714e1a88ee5e2b44b2233d414d339974ccc21e0451aab6861fbaa627c4d80d8175385a2469ebf52a656eea55a098e36ff2e195b863980d7a964ecd2eabedbeb0099177036f8062fbcec252de832bc5c6cf41f7a41a6e2158fb717499437aaaa7446922d5a4704d9f10957cb62d3755623010210614f66823103673658781ee5f570ac1a574490b91ea1e450f4481560cda8204f140d7e2339be0bf212018a9f8f287617473bc36583f39d6eb6302be92dad40d443e116daff96d6232f8f395a6e0b34156ae52401121a9c5efc7d7417b7243f8ef2a68fb5ba5863082532bc6792621e45aada2c7cadcbbba78f54234607ed81ea567cef602f30d2fb7340fbccdb7bda1857cae5cd55bd44ddbb1e81c03051ad63058aa66dc9fc18ca335469d24650cc433f31c4a0d091018a2d1c678a21a0451ee9fcbf91ec45e8725df5460adec1b7a2073eb605a8da24738eb3f1bfe59f4c175849a40ad4fc5e2b34101eb16cc5467f94e6277871940b5073aaf76a8c8172d3ac796fbf692545e0df2bb358b079878fdb75859a6826443573e521154f3b1bbf505869756196804f28457f9a8fa515942967db5164b3673f9c201a36c55179579d299ce92ab38589c06637efa1954a7150b1f3e4b68034342389079d55c977607ea8edc3a42c245a3646c43254b32f6516560f68115a519282f8d38b7fa81a75e522c46d4e7610fb7275b3998202dd75bed4ecbea4f00434e8bda3ab2806cc4f0f8688095dce2aa98f3d174437aad7f71c47b1d899841922f235f962695463c1f77b5ecd6a256ea3cb34f5efd9fa66029b9b0cf25fd5953be4f2d0af8dc46b216659cc51cc43fc97672b1f51741753261185da10621e6fca7ba125e5a03dfb06edc7a1b3ab89de4220b0ba84112f8059e7a5781860df8a7058ee7b8d9d5459ea0608d17a5dcbc00b473b3b557c913e677d3e109c840799eb4288e763901211087754b77ce839d98ca763aa268e38ca7de4627b4ca11486fe47a0a610fa45bf80de258c076808661f235fe7aeddc351e45958c1059dc1910bdf30c76ba3c39b4aaa5387727109b2374b26ca3d9967b127e0864c525ffc2177ce083e9552d089063499afc58592affbfcc7bd4aa3c36ad6d3fdfb8feba2459792537c3267f79a5cb6bdd299f60ff0d135e1229a0bee331ab27692eb8b87e8ad47001445511c62b8e62c71a641183887798f547e06a233f05eab227e010f7d24c0c74f8f61b5ad25dc66871c0f723e02a8aab7799cfa311e02bc1c255467a9f1ec278277b25949a6b3520d58178f485764023790edea890920366f33781d93bbfea78b09440e8c601a277db7aad16778544288a03fcab7339abb0f381f87d7d2dd8ad3f6a6d640b6a2eae2ea63e7fb3e3bfc1a575893670d747eba9e26edcf0e381f16ad03cbc76b606ecd75e91457967c47e9ca954b698dc9d29ccb0c81ad97e08ed8e335ef5c0c96033f6eecae4fc0c1cf60884f590f2d58f0b7af97ded1690c3f5b446d483eab8afc365672a17cb54a4b1a589a68a3ce49fbf054cdbd385f003afbbcb1d300cdcf92871eb03e570408228609e1fcd2053b05041bf51919fa661fa8997729ebe2829369250a22d9b3071d2dcc80739d8a9ecfa2a605feeeac5f97ca12655b8424df3bba90172ee5d4a4ee8ffadb61cb107f47a03cb777d679312e498e586d55ead86ec86b95ab2ba1af6d139f536ba66dfe2f43ca18b6dcc1df7f06534fe590f734f9455d025f4bc92421a470998b64203f43e0ca81c0c37fb720e2807118d95de82c2c511d3e1b768c443fafe88fcc8a4ca775300fdff906b313a7898ddf0f39cf0328bdd78600447bcf8c42bd51c3d226d07baa8ee14d099a62ad8b0e0d4ff6b8cb6e7b99e3d06c691fea863916e24fa03c1ec5734e3b5bca08060164da26eb9203305062ea91402b07a2867b151c7725fbdd727af83cd8837f1a8cb1f71393186b1497a3856c4dee247d44f63680c5bdf87d25fae3e90aa8e2010fa7862350d9c1f56beb20250600c1aad3879b27917e912a6b05fcd4a864f71bed74c06afe33e0bd0add32301068f4d954c77c0dd68e67040025521552d6d8543b2053d1196d2582eae7aaa2bcb604521cf55ba41701e21af0eb2ba11c662df98d662b7e5e4d554dcf150d03307085dd12245a62661420a2bf6fae65e9a622f38794c59241d2086d3c7352791fda9bb2ac15f30eb3b0c587683371de62f9ad0683b54dcc9f68a5876dc584edb6954b357c19fac3a89a55d2ebc3854359f7d37300f3417627db68c7b4aa80ce9d475521ece24565e9624cd3494214ab5672d3b4b82f6a3e9ca3bec2ff8adb98aba7b49ac018246b14412c8c09c3d2097bbe74f00b1cc30f7e61fdfb8fbebc97fefaf3134c23a03a26e76ace97c021dca6cf5d1c08b081f62f2a20e95cbc2cc868f8da0c63d6bda852b71d773ec59a4ab","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
