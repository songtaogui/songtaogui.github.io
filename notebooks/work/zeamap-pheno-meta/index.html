<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"967b49a942e7e65c588e15f6e9d5fabb7860d15e3f8153d20327f11d6d0f8a2c5e4f66513f98d1fd8785308ed97ca9549c06bef80a73d7832c7ded62d3656863a4cf9a0ddaac1712c0495b521c59f54a1a2ea309e1c0794a29b9d5beaf57cb1b9d3c9bc6f51e4bb99c337a7709e6fecd93c9abbdde90337fee833db0897803e131fe58d110c9ffd95ba7c85e031f19ef8dfbb253fd33bae2be1a2216ace5efea2c4ef94c9c262dc2864896ab4dbb01e41fb99c8d0a1c1707632491c4d75d6157017e25a9ed6567d03b380bab1d7c32d49c11a791921a95ec94b9e71d3762e10feb8546d3cddee5a17c5d696962bfbe472ae8a111b9de4a60cbacff646070bfa28e61dbc200be3039a42e2756a6fd922fb88b47598487c2c4dac9fb0ff388e016e1367459b5ffb811f724a0f54b648f326f5f76c15180ae155b3ae7a4c40e55fdd581a05a1b95016c1d3405e9537770f6b2bc5fdbb36fab9d3131c8205134cdd4ca4b98abf2de163063a53c96b75c30732f6a9d8d918e349e2a92e47118044982aad3878d4dbc9e779dbda15a5c88fa23df40370547531c05d4fa807a106c9322a0d68d07c42341f6ddc7d7f76f5d3b322ec375959619ed611ee91d985f35a0ea5c5daf8b71764cab6edd0aaaf2a987c405b5499435c4259d53d17c7a9a8741261fd2aadd4b27b3de4cfab7d8e85af4fd9f3ce4fe24d1f30a50bf0886778c4c027a8d6bbffbaed5846953fecaaa63e095f32ddb57f7283deea47a07b1cbbd43279c9810dd8c2aaad596ba7eee75aac88bfd6799336dded216874f97e04eaf40f8f098edcdf71418af13bfe2e9529c11f071ff3fb53857eff62b5c30f0a58b4efe9025532d1cf1cd35fd8c4c699c2ac17fe842f07b90c624ed820a2282f6dea446ba22b7853f94891a50c419b1836673a46dbf0b8be4aeb93a0557196a8de34464d42b075c148f7d7868f092201264fb6ee2ee88bc6ecb8f0eb806e1da7c2d248dddabd823d3b839546cea8b4cb76685fd3a4ff7bd2f4875df211bd7c9ccb88b12359d3755a6e84dc614cd656996798a52e04bf976f59ad0df303bc3a333d4be25101a934a7ab278ec38fd49db487035d89c5d97c060fd4f782c2c630946b8c05948f644ccdc08c7fdebff5caf78fba90345bad167b9ad2daa3c5b35f4f0f15fc2be03faf494212966ba090796d9ce5c70785b4e60b717d666b60bfa8051520604b8fccbeef880369376b8e5a4d1d5c5b3c39bdfc4f788d846bfbea0b452d5db93c3eca8df009c17a2eef3d5d842e6deea24f9b419e5f5d819ac2c9d8b5d88b0adf0442d3c906a5b3279d052cb798af5208bb592a0e1da3b9c66b533c254144fd89db18de1e4314382b216271b5179387f3754b08f8e44f049e202d3b67293f90d179c41dcc76fbf2374de71a5ba691e8258a587ae8080faba0792cbc416653b2f80da597a292e4d934d72d060c46642d7bcb1d144e950afd417d2f47b614c8feb84aa8f4b624d4769e6f237a32f632263a0b0d4768292b575e54d2677a36b4709d5872a77195af9b92aeaa59db45885983ebc636f28f2c9c642418ef331367638f9d0a6731c27892620ccf1d3e1fb5e7506f0bb9154490b9ced42668ea67c4d1fb94db8e905a628bf4a2a7f1228041f395217da9636bbd80e8b57d48587f7efca6b119f5210de1cf119bff7e8e0dccf50b65fef708e829f7eef6b0c22ebc06aafa455ddaa9bdbbd4b6144713bf9608e818a1415bc63902ba27a63745955443cd4bc0d97c32d607dde0e3735491badee25154ecc1f58a04ae03c1e7a7fcd6b79e550395b463825590b3d450abb64f92484ef7a6815e6f66506cae71831ffe0e8350c40ed6159099a1deb0176f34a7e61687752233580f99723ecdd9e5f95028e5f15c1ae858984e40416ac46bf8f2e015ce75424c96108c65857e49e4aa8e9f2756cbbf8e10ee16236c5c416279fdbe306ae1b0360117f5c404381b6eb6027bee8e93ffa26cbd24e9adaac64c9882e043e57d3cf953eb5097b1eae5e61897dbc243212738c6f86ed6b528e9ed1c806621629e15435bc3a875e1d37222e21f7d93beadfac97f56eb847af409ffe45916ae12f0f0eb8278f6ea9aef1dcd650311b40906a1098159cf1b05295da7df4c8b51fafb509f54b951a80e309b26f98141345a4a67a6a54e1866ae2a2a93cefdbea2b39c9d617ffe6649cc0df8f5a7913aeef2ed05c9ae69f70928d48afd691cf897d9df33d6ebfdf13a25b5020f1f79456f1e870a174819d6e80bbae1c5faa9262491dd5b430b51966f6486c4c796437611b9852ba9552fe5a4e1e16fb8ecb9ba83395377ac70130032f2628db1aed183b23733c683591e34e0933d35cad2c3ae63b61dc2695fddf7a5c0591bd80c0aab4564d3edd7441741bd9eeb8edf5a4883fbc19a9f747aa17304573eda43182ad28c1672b7d61ac9c45bc146aa8beca549f1be0bffe665b52fdbb1c45d5a90465636c79e62168cd81158b835825998fbe98a336d63146b151d768286d04f3632c8ff7ae9870a7310635311b67092e2a59b0eef2ca25808820189bdc3c6ab947888ff0a90006183ecbd6391aff9bd943b3d30ba30e6dae26b6fe989f6d96701a77ac1bbdb202edc68520d87e42560265d840384b99a7d9facbf46286fdfef07f4dded57ccebee5ecb068671f37b465bfbeaf658a3b97660cadbd585daa89d166f33582c2fbf06606f1d0c0f83b98982ed1979fa70c47c4449bc9df4f665a7c40948c3243c81857445cdd6844ffa849b20cf71df0b8994b78163355f5601ff474e1f509f1d07e65c6fe6bed5fbec9b7e2a8daffbfe6cac8834c3663276714b3c97b8a8961c9b52ba51cc24c10a87a0d9b6764fc53b785bc27b1691513f6970b39ddd5a55b6466dc4d869e97f53b6ce50b96d38f2b905313390f35c7a3fadb8cc0652333c5cb65d0d41fc6c2d5e6625c90e24f233cbb0532579afc330077e1d077e9aebccbbbb4f7c9133bf5c44ae2938538469bcb2d05648cc9241f11ab1ae2c5a403a0b2a1031944c6d100bd5f5b8904e5176a09af4940fab488ef03b63eba2162af81b2e1ab658cd158c56fdc6a4e531e6f3b468ceca013a59350bb6627ad981fc56c5f741ffd73c9407183dd1cd59e14e449c5968d4e30d1cb5fd56a9c6d689f4aad99439352cd442c5bbae604278728f675ce1620f0a860bf9043b2efcfb9ee3794fc1a7ba07234e88b02af9624aec108d87c65d540932b7ab6ee28adabd99c42156bd322882af42da473605082491a824e00bf9d40ef58eb01d399d962eecf3292ba7928b21bbc8f7258f13d5f70dfbddf5f76d488b0328a769a7914704b9e60f9ec999d670563dc5af3d1d64ade86fd916d8c3e56b617c02da272fffff523a806c7d152bfd0cfbeb29c2a0cd5e0ab66bc3b4f3157d4fe3a295d3015599fd04b7674c0adf869bf8ab943dca771f84e35f70121e0a39438b836358b474dc57e93c1696960125926f62f2caf008b891c702418ffb9d1bc6771447c4842470c757c390147401ff90c75689f9c9feadb5a0b19364f0a77f6d8e6fe542d724019012f9b12e2001424b13571429c7b9a1ae62b920ab6927f661df02ed41fd783311f6f9c2847aa71fdbb40d564a69d556efd2a84935fc19e69b677acef30bc7c8386baa5a865b8f8af0facd9dbf92238996999e652c778f516387729caa8785b9465d23b11d28ad6027f9941f5d3260a23e52e6e46a60472d876e9342c9a41fd71576f73e468952b8fba7fe6b134ffc78f47c7ff601e6b7178944cc2fe8c4e0f209a049ef189c65e4d911270a123c16cc81b6fa286be6dec9d09e62d53c48e0c6e5fb86cf6d7d9e6389c11ccd0e2b15629909634560f9c871a9dab2ae1607f65a797d9b8608dddd53faec1bfdfb5efb76db43764eadbe5e30fa2b41a3b372b684f3a100e7ba4898c765b449b6621a1d967e980102ab2c2c6ecc396e4038428aa50b39240b8ab2eabd07651a8de49188532d920c6c7805f7d849154e48ea8f37a4abf8a34549a739796e9a18b60cb5929e46c40e1828906ba81e5ec21291efbc6566996661ffd6b83f45a194af54d687b99b0c1193c8ac966a2719910a9d80b7db2c7cd0bde9140b09388761c041f08a22a1aed5c8ab205a8c983d9c141ceed61a6e79eb2fe4e2ff75ae8cd424542878bca234fcb47b81f5e7ffd5b888703986cdafa5c055d7fe531774872b4a8a1ff0ad579e57fc4d0e0045f74e88b937071174f2c241e9a9b8954ef7f57bf3fab5fe0450a71ef99546ece2a1ee835742a54caa70f396c96b59f901a5f27d52d1e0b70f17f99ce62b1061783f710a228710c552391aab2b136e21192670b77542434e3c35b7258698022d8921979eadb8f5c4dc729d453a51cf375320a9d24fb1935055b7874fb3a3323c22a607676a8fe855ef1d2966336fb90953bb0e626e3cd26bd5e4058bdb81e5cd6210b5d25dd2dba96f539d8877e797e2d2a0fa539400d614cb4bc0a3f47b389d2fabbc714102bd801bf9650dc066dbb6dfbf4e7b58e120d84eeb82b188f9c9604be9da336cdb7734579d8c64ccb829173396e93a4ed92dc73220a6e4020a128993498d65f8a8825519f806c43c085d42fde1b703599d424556ab633428088427d4c952ad348ed5f8006f264cc6455be3b70f27ffefbdd7e49337de5ce54c3db5a1759ae5dafa11b2ae4c6ea86623771861b97a75841a436e5fdfe2f331bced2b343407c7573d439a278cf279b74179abbac357c14dbc3bf5c8c9bc88f33d2228b9b20b2cde0b87f3bfbe47b72116e841542d631dbb53a26ba00bdbb299dc8139bcc8e64341dd36f736697af3e3ea23e70e5c106c9ebd912966d4d5113172b29e122516411e94368ce0aca2d4d1d8bbadb5f0fb8681ed6561e971613ed52e0883d6df946e4ced32f0e240de7a3ed1c79576672b3485db1726032c455f9465e1006db326ca081b9b69fabade7fb9cfb1d988b0ebbb828b501c608d69ae1439d7f0fb1e9a08a1b73615f876f49afc39c085d9100127d0e3d9b135cc776e7d40f5a1925c618c24c8b8f9f1af005b13e6f5db76813f8a65a7fcc20a339711eb60f3d8ee37b3b538605eaf7af903d0755efbd88bbc02199a67b9f093225771b1c8b9e13e65c36dee657ac9cb1992762dd9d58b9d8b89fa38e20b661fbc15ce0d116e87f9ea8f8ace655f4d793b4cf21f2f6d916bed26cbfd8e58fa245c90a775b038b6246d9e7a0ec149d3c690513078cc6f93be53f094f3474cfba9362e822c56e0275b511023ef3aae9877bf7293369c5246c1100a3a39f26cf1a84551611808e4fcea3f58e57cd0eb2d277032482c5d3f684681190689c496a2d6be4cb4af1e1218f84ea56d4b1d2a506bc3f86f4abb533354edf2409df84829b36b932b4cc784c82c5249ebe1c181d13d154b8b8832127cd9bd442a800cd8e8355718ca8cdd247f0741c8122c42baecd631868e697be40fc8808c860983f2cc760ff77a988c521311419edbcef42bc8adafbf0f05f22a4c0a08abeab4c7273ad605408f58ecb6409817c7cc8fb6f41f4bb7d57dd33514b710a9cf0d041e6d0a9b9a3a91ab9ee0c2e3dcf0cc5556c3a68bf0ecc35f764a280feac14a8d44e366ac5ed07d8f7cd1c5443ac123446a84c5aba1a731e5b240a15e16cca788f6be99a79c7260146b21921e59f2117018d30e8af7be77ce2195a8a764e42970e8a3eabfdb035fcd91cc22da5cfb451c2868a622ffc6b87ed4e75dc8ba8476b6078f258a7d3c16e326535b7e13d4f9fd2ba477567d64d7747562ede0247f0419165bb7485f4e004ae039f0b3538a7707fc2504ec9846d68c9b58a572ad58f5f31bf407e84c3684479c72a11c81b810c5c88ccb63669513cfa58aff8010ce1ced474f56f9fc58bdd24529628e93e6fe53400c5c382e29b265c426f8ead9ffdbf0c5d5125b363103af69053106567992fd8c55b77f13095e3ecba11720483d110c76e20e369b9586479365ed4f69a12d6584147a00d9779c90ad7c01ed2434dc8531f4d757a25a319c26a6ce082642d8c2b363ed43852d95318f2d02132da4dac91a81a3ea533dd2b968e3761d5d092b955f48e8f3bb0fbe036076d44ae914292e9265d0e39198d981a61d16b701d87d31912bafb8e73978f6af9e4faeffc8e80b7d0c472f8592820bb239d37e041c5be493f3bc7eb7df5ed31b831b5e72e27d8c9b59dbb7f27561ca10b58ac5d06403b21fa6348ed90dedd4d024e69c35b5513505f4bce2a56b8e78ce3e12fbf81df11f20179e7a03217805775cfec5bd339c8ac3313a3bbef6f6adf6546d16f97a4a390db9e4198479e33b8e923b5d739d9c52c46181b4f560c4163b5e02beee590fdca23fbb87dd52a17da03cb6e67f5de1019385383bb899fef7849e1bad090a348942313e97003e6d97a29e886e5fda922ec0066646bdf5261db367d9f19cce00d4b6ba87f5747b4d8cdc6c6a30f429980c96efc170296e2fa32b3e752298daedf29a3130c6044489fa917a39dfad0513038aadb12115437a05ac67a840762671a6bf6cdefb3e7c1c9c288922b21c25b9867370e31d37ca32305edf017df4fc3b0a6ba842ee3093687527ca96f0b69b65d691f3b126f766403029add574c66fff65e2905448064ea71c7b173016cb494f5b1282c08a2f071e19eb4f536fa9caa19557dc8c665a1047fde495dda9c901da055e88daf71af2344b392b798c5849b26fda1a3c11dbbdae045be3c5466f69c2ac79710cded2c41724ea7b87e8fa0b29fe64f78253ba16e269828740388ba861831a10dcec11cd030cc4bd312f1a8ebece5a03bd95d005f68dd5b5eb82e183814a690f48174a0d277d4f78fdaecb6356566cef6e2e85d8cef14fe546d2ad48fb84ddd6db11c84c3efe987365bef7f6d0b389d3d556432a4efb05ecedef96d6a31ea4eebdbfc66ffca65faec1d9c9515bbab3566c354cbeb27c918cdd6a9eae71393eb5d6205d35d9cecc639c4af7e82c831b41c231299a93171d2279224232ef892ff6751150b3397f16944e12badcda8621c3351954fb666e77735fad94253e6acc6780e495850cf1d115e988b21f9131c15fcac8cef520671cf8620d5770131bde1c73fa0d08b7bcdd4b19e98403bbc433d4f5238e35fb4761a750ee3baebd6418f229d520c4b2e8e8295fc3e0a62b214716147d15c5dc3aa46728dcdcea6d9ab38d6aa53dbd490900b0e587b57be01f14eba395c6d62a284ae835185ab71873e41db6d2de809439ab27f62471f7a66c3817c856ad95b243359efc37a96e26e20b4eafb285543bcbf0c8c5e84d2e584b5d56d125068fdf1730667fa919839c8b2c1d15d97b83e058dcc6bd8451b8b2bd396e8c7d1506d9c68a8f7aa63d21d139bd3b3c2a5032fcd0105e92ce5797d1d62ff5db526e662fa3913f1691bdb0c93a1895f9f4dcbd3275ae0c66ddcd1e392a09d9b4b11a519703ec788f7206a69e7a8a891bc70e2e4ab155516bb03758d46f7943d631a9c55a090167298f638f4326b2e12980d2cf8fe62aedc4e8e76ac1bdafa3bb19dc13c19bea6147b704c00d3ba9ac5b726782e351c01d9f10066a9b6e00dda3935d2dbbecd3c25dc5060bfc06a5ae3e1e84b4858f1f7c2cc25f8ffe0a8c5892c0af8ab5f8f16515b3a0a478bacc855079000c2808ec869c88343aa08a6e8adb4d4d65da9ac93554906da60cac5533e7abfb474cae55cadf5283d9c5bf659ad4a1de99b3bede7502cadb528160e53fd5c6ffb974749c4d2207509dbc89e7160a1aadb014da99a927cabb1eed923423b200586f355b1ba94cec8e64affaa64cd99f0498b3fb9d423a2822c49433c70ad414f2999d7a3ce194bd7101480b1b567253fbf8627866f6497b7dd6e7315283a08f63d526b1798e65e3ee495b76f81f19c492785ad76dac2b296bc4233f1c560ee10e8abcd35d9c602d11f98754508a51526bfd970ef59265c4703180831653992ea5ae6d2fe16ea50457bbf2ad38d1bcdb2cc1d0a40fa152bde55bb92d9d5c04abbbd9eead0fa244c8e2671d7ce8ed3bd4f2855115b052ef3d6ce32f896c3878e3a41cbe6a540dd8427477c3cecb0f8ddef8ff87737fb50145c5a68075c54c3ace3877f57bb8b8e6e6336dac59d4b17d877dd98b13a3106b447dfef86e2670ec914dc09fb3a4a610422aec6c2dba556daa2d8495fce6cc566aa8ddc0792fbbdde991d3c5a58a2d931507e2d0d156b9015a22df18bc5eebcf180aa7b0bd03ca42547a2ab2cbc0010f8c3e06c56df8d2511231791d488d10215d1eb199d00fcaa1a91e87c3e575c9bdb42932f7f2be0ce63c19614339cdf69b956fe5b4101533b11b71f7fd03810a438dde7890836b142c7ce02d1d177a2d35d710a84190d40f15055ec51422db14a380147ff9337ba1a62583a731d4e6302e15dca809acde4c7748c90a4b0e16a1124ba7d5aa7fefea70c48bb70f34d5b074d0706735deb52ae428d8250f534607d723ce65e1d581af6415398981b8f191dfda8c2bda635fe1353b44af93cc5e78874144ab12909259d3c787fe4d9589913fb531dd2d197af5f0fab1712ae78c5ff5d7aa9e309a32fb067fce6955029c63aee0478d5c98de056822f34a0c90bd2615346d98853ec569b063cf54b0bf70eba0accf4208c3c6d85b5dc43f74ee329e33b94392f8a1a0e64bf3d8f3290b50a2ed0a0cd05daee0ae104e6e923481e0b9dadf250f5a36cb1c642740334814e82c1cfbdeb61fcc2c5326b3d14f98a5d6f40edbefc686c6da28ac202782089e00789b830e59e9b9ac4b68ebb91f1f9bea600bdfbd0336b7ca952baeb5ac2dc6583e15867c6f9e1f643704382e4aad331d1c37b8753c2ce2b9bc67c73fd27ac6ba928e9336f14095e7371c05767203834d0ebf8a4fac106c817660d6ebb00240ed8c4b8bbe9e9f4b746a6019bd48e30b11d4ffa959483e680c61b459d0e85e73c21b36cbc029c20f6eb97dcb250ac4ea2b839c48389f96a763ec44858e3ceac7254bafb6a2c494b4bfcba87e42d849689b312f9c7299e30e37c293431a18e79d8e1a7e1e99c4b1c710d47d95cb8398337586d52e1538086f3c0f7a4c9efd30dccef29d76d726add4343cd7bd40f9473d1f1d18de72df57077049453df178557c8ec1e1bd95ca562c386d70a78398596b70588a2cbf081f1db8d432d4f8ae24ced5396d8946b67396a37b0d093cac326c7fc821179a932198c8663554815c979e2fef160c8ac1ab8ca837ef2592545a7deb26d61f331e158e5db6973dd81a2592505c5572c99e2324e088b4a7f44e42155e0adb051c5b930e917454a4d2f28c04435f3a7c5547fbb22e0b5f9087acecc2eeada6accb679cd9e760653c36e243b6a10a7f7014b08b8d9612b982f64957603f6178ccb9a0c7b49f48881f201b088ff1436785aa2ab00e822f217154d95b3fbe685bd98be36c71b53c4d39598387486fa9bee4fa71a759a200eb56897b4a89ec0a7b936fdbd57d442db6a2644ba8069f6a086f92df0b023300d0f1877df0e7a86a658c5914a1fd729ec176a3f991bc2cb9dd475aca3d8612c6fad6f58bfa8bc60571d501986f2b2bdaad66e2dbd417979743d72f47fd7f183c371647a8b69a1fe8469c291d084b9a01d96e50aefe44238d066656e28eae6b3698efca61fbaf2fcac333e650f95e8c3572469d4212e1c326d3c761fcb49229ffa465dd52af6be20420f7cae97e04a92484487de70f5175143d7a63a26c65235cf2b4f6a4001b9967553f36eeb96ab42ef6a38a4ad234748965d72c04c9bfb0590599409eb83e36f4422551445c3a9ab9b814a55e924d082b24417d866585c25dd3f19864ed2cd8c85257e4d30f76c56557655da3d2e3581932ac428a4b661cece6cc98c5ed3422aedb5d2bd03eedbcddc6fc989db87f2ed99d37f267ccff53a0faf633ebb002dd0cc3cacbc06149643fc2669e2f2526787e0cd98b2c38a899f63e250c6647086eca7ff30a2b2f2d251f61398f9b19daad558807d4489c1cc990a2171c58c001fd6122e82b4dbf40868111dbcc45b90b176d388275cfec9291102104f85ba6ae310c5c470197165b91a4b07f2cfda829465315dc8c0ae488e81f6be335c46ceb5988907528bf5c884467f476279d717555bdd37daf1c37548cffc264b8b6777e6ca840273cc0fbba4e2ae8d4e998e1698282d0c05d03eadb3a6048d649df412c0b92c2f273f3036511ea4c1521f04749b0e9b50c8cf17910e2f6ec98694bd226d947d1f22695c8b23f953ad10314272856741052743a913ff9b5fe55e09975bddc74610dc8a6e9776ea85e9b325d6d2f8e34dbd71102e2e8e4841c8f6fe1509cd2d4e64f688a030bb07f95a3a841ff7510b2b546e4a79def3aadb88893e4e68b5d72d2787043f8e2232f377a42a638601da4c95b5e5e050ad6210d0bd02a8e4107c140b8db54725923e68300a03e8ebe1e2175d5a0a5d996dc962c78ef4a620e47d5c5e0420c95425f8d950753037f3ec75eb97c2c361acd18d47bc7e4037f299ddcb141ff6a13a96feb064cba883e68c89c7c5268c917d313662f274802d308acb9cd4dad2cfe85777e4ee36921de65b3df8fe3a88be06b1d8502512cc9537f7d2d40bc712cca80dd3002bf76add6f878f9b740c37dc6792b1f2f58d6b23b67340025bd69e42883dbdf1a48736c69e529945325be4759c15e7c20c86429ff5372f6591fe2f9815060c13e802d0d5d39ad7879b419b2e5dc18ac21e5ded91eb032f5433a6ffb44019f7cda419cccaadbcbdf54c1bd4c69b149fbd14d831797259321a6f797a6402d823125e525c870c964092102911586b872a601fcb22ca0a4190f6f6ac0d394b8a7c28d86cc879b23034d26e5903ee8892c411da8b7b1aaecf5d4dafeb0901e55cb8a3251b88a7d8cea39f1fb7438d665c7d739709fe964eb3193addd71ba83049378865f384c06d67afbe26f4aa3f58af0aae63f532c360c3ca441efe9e575afcc7678521510e6594adbcfbd3dcec2323cfce5dc60fe9dbdc2992622e13996dc822c6478e387e7c142691fadd0a05bea0eb9eb7d48a8d04c75da017fa3ea218f09b564b5661fc3402cd629d9d2059658148c11ff5bc36416e96dd25566f49d26be1ad67d612227fe4030000febe493fb7e04e323daa9ccd6a71e44e977a5b94b4a48593ba21343c4507dcc2c514b25f6050fd6f5b2e81af40b8f1167e0160920d5bfb258b836032b2806773aae2fc0bfec868e94a8fc695ef1d0386eda361189c774fd3296f67a0625b2f5898cb29c2299e2405a7767c8e8f3bc5218f83ef289e0508c6758e88e119fe802df40dc89c42d88b5c273eb1eabcf9711ad2e639f6b0a6ecc802169fd2ab3c167e43c9efff749241a761db3433e3723b672108631d4493b662b58b65f9d30858d49185aced7962f2d90eb2467b91a6b066e13c9a5b553437b1cc6f5ff40cab759d2ab8d5faec857ad0024c92353a8508ad8063bc56d357dd63b27fd08b02c367b272aefdb12eefd80b0a8a84ea900263bdeb41c16ee9800e68e753adc25027d599c9ea2124df2722086b18eb3b12bbc69bb226b12c0d31a6bc7590675eb0959998aa6232b34161ea62052d285c3e4a771fce878a531930ac53d52c696a9d1a04fffc500c042bd0e6ff9451c7de447753f57a65c311931338765eaad61a55afb22d77c6f7ae29515c4271aca836b4d73f33b5a38dbbc66d7e1aca18ed2c21c845ca4e64f8c25280d5b14bd3bf44843268ab5d721aea9ea9c3f6ffa6c6188a2d1f9cc907029b65330c1dc241d26acf5195d847b83ff518a9b06099164b1dd3d5cb1667565b38050346264494881451b689c866d273d01c7d8d2e47962b0bf92d27b0568a6901f667c8a0fb6baa404cb10bf18ffb8b8585c352c525a88387c80790c4ef5cac0aa7418e727cf2282428088fcd149fb5a5637ca790a7d46b4c95581a7fbf1175464496adacabcc9f9f13ffd252c230ac1ab24c6f6b130c80e0f05cd088155c96ab95f57ced0e9ad017b2afa83319cda52e7142b26a2e71b73ec3ce9dde1e9a9deaa04a83efad3054a972ca932b53e8b5c796ecc5d8efe707c827f927d2566bfab7ff97f26a052c00ad0fdbfc0d415764960c1085e6605cb524b1379972cc62be9dab2632121367f1dddb0a1a8a9e610fbfe52907af827dc7c321b36f4f058966f580f1f1b0f5740db9baa6f9790f5202af66e90614e542d6921a028ad757c5810972425d165f938106f47a493591f841b6fda7df410f03d50dc460d493fec18bdddc3d3e7bf8de7bda40deb59f7ba51e3fa770baffc3e621b5e7519419d7b20223a7c15cc837212a489615cede042632f7ba8d52ec5f7ee900624722b5c4eca21cfe9c90867c168435142b4ab0618200b422dfbf6404262c7bfe5d4bbd1c6a6b0bfce00090d53d1fa8e1ae2283e3119d0bb86ef3682a79728f661e800d25a19523ae81ba9d5308be9ab561be5833282a08a37f26c4cf690845d589febd251fa0a2578b36572b24f4939b6e92caa30f8cab9e662c0212d4fb3dfbd1a85e6b10e51d78b6ff6327cbfe0c6b3f2fb727d5db75b8737e086e68f8e6fb68420cbb39c80e3c2dcd4565f9fe56d705eeec33214e03daa0217c1a67130c755705b393348cde61775c7c36f70feefe131068ea079e8393d8d8c5418805ada2527940e9dc27bb4ed41ec3bf6a141ca25d7aaf6cfdc4ddd3554947328cc648ecefc2bd876e4de9774923a70c7157084850a0adec32ece0460f1c85ea88a5837312880ab46211a34ee64c496e7359fb952876b8ea52f8530747aa2b4ac578d78f140034c49ecfe31bec9afe19fa759713a106e740862676316cfb2c96d532a0e7184a7720587ca6ed0d764d76845eea0db7811476b4ba5368ee4bda24a72de93b2121a7354fa7151892e98460e89869a945f3a283aa0829dd7058b72ba76568289922aad13e7a1bec3709ba49fb41977532e58af87acb9eae1fba4f11620c66ba840d4050fe816880e3b85814c042a91696950cd73697cbe6ec0ff30b7daae3eef82d4fbb9786a1d7088dfc736c52d5d82aacb240c200d9737021c05d5a247f6570d9bd6a1ddbb8877ca787dab4b78bb233f35ce8b3f908b5cb4d32f871659754b388b103fb7bc8ab8f83c0e8052e32fcbb629c37feba411948b30105fdbadae2e02508f1d145c9939e1979154c5d8626647e78a407f1f4aa581eb25aecbb3db0d5a471e281add4e115ab0b6ac19170b41699a68682866b797cf53cc8943ef04d87dce7a2b241318bde5c11a702ce3fe7a1c7f1fef45593fa66c0992e05ebba8093d4a6f5926e4ecac5140e8cf05b71df1c58871d1bea958f40c31b7a580bf305ac6c1aede79dbf6ff800dc2fb557d7c710dd054bace126743eeb5f8e83592251c7ff496ce4f81610d1586ff1737af46251f3f1164ce5bd1717ac90248a4c246c6ad5341222ff5a97c4492ce9875dc71e0907607954c3bf8325cd3eb5c6bc16b39c8e84169203a5db2e9cae5b3aef36a00e1c4162548fd2581ecb8595bb110c7cee7222e173b4e53bba99dff4fdec4ff99be8015401d22fd282215ab25111007bd456a96673c5999257ec307cb5654d1818f58c36ee0be6d8a3384e36c0700115b6e6d3a33194d2e3342ed897126c1b361ffa0b026927153d6f762c3179142397049e31c44932cd7a1380343aeed26909ebd8ffc6db7a40826e736bee9bb736851bab8cb5fa6febef791b7be6bfe55bb65ae0e1a8dd68066ae38de95d0a7cf646b41195d72f31ea19113e26fceb8dd98708caed567dae08d90777126f143726683036090041f5e5d432f445762606715b4001a868399ce03de6d31f1651a4a555f16ce4068a378657d924ea850d024557890c17c894857c0a8b6c49bd8e50f65af5bd629f2f5a25f6f9da7c003d1375e407afc2dc83b7956b5c61d9b3ac5f95df380d17fda4a5390f6734856bd4c6e7c0a12139ee3355fa866bf6dbaf68f6da9be0b95e02b81c6d30471f1970f42ef5ae98f3edd93764faa899fe399d09807af0149ca2d0d7cf0700f91a9679212c12c1077691235a429d2e1cb8dea7e1db34a07ca89b3b41bc03cf499ce5b692634f1e88dddeba84df5d8393e898d36fe41d3d6a995de24079fbaaa60d0dc08b6b11263a6ebdc0882d56905a7a2bc47f04ae91cec1ef239f5da4fcb489db310c884cab943bddbc71cecd6c551599874f2b0b7845a9d4fe64decf672dc35fd27ca7d54955e3afae68d7992f0860905ee61b798d6b472ac5d52ee2cf91d36cbaee0f2c6168f91c0e0ed8369b6a63808b174cd9ef635f6b1c2f28267f9f9c60fd6d9af4a94fcdd24572a470686294c25f86078b1ec6400a5b1de4c20cff2ababf7ba474feeff85d5b957ab9cbe973b4a8bb9880a10e5904c64c0328477fea2acab23aa1959b591942f219db630a1d3f169353fe5898eae81c5a045772c32bfe04f834b870d93257e01a8d43f2b93448e997e631d43df9c1750f7c3ab87f8fda92a8cff6131b9614a75c18078f5cd45f3b6308f0d99b1e46a6d6487d6e2822c6b3720b9d18c4bad0c736efa16d9999334e4e074458632b88156e278ab6f90ca9b5b6bb422257e70068a603171f38d518ca64ff86437f997bdf0b91170d96b454b2af3b8ecaeca6f3a59a46f523cadfc8aacddce3bd2e1749805c3d02083c24c8cf03038e7484b58677a9dd255cde05f0f267d0d4719401e360eb9918daeea91275c48d4d459d40d18972af38bd7bd366d8e6d84b7506c80f30bd852f47f802ea94ea35b5d5af4e6f17a10934da94c1f3cbf7e868bb45d58eb1f246b9d6d6f188770d64ab94e2c42a1693af16cde10ff5fe93076b76a2fa3c24269a2cff61b24f73385f1bd141ea69910b00e64897c8d8d0bdd1eed48bee6f70354f848ea327921ea968fb0b236cfd011717147cdc4374271d00d6ddf40d8a678014112a87112ef841d14755ade48f688066d0501a8873a389869ffa188a32a24056ee82f716cc74d3f3f36fe7df71a4a94fca2090229f48fc2a63edf1e3c72238487e936b57e6511553016e7f74d58064242e019b4691ea42b5ba0a9ba73e05763d02d4fe840a586f73cd3c179dbfee4f6acb181010aed5c907ed8d271d16ca97f039757477b3e3079efac0e02967100a0405fe5050630a3fcfe1b6959ed7294b636b894e20189ee2bea28ee1607b155f0a2b6c52d38efe5da7b6f7f9a069257371d39afff883799d9308a744bc0614b111892ccb2be2bec78527bfdf5c41e5525f7da3bd1fef1b5eb9d53f347083eb82b94d2a8f918229ada9532f1f5abdcd248153ceb06176ab17de0d685dae94d025f75a2ae2b2add579e2ae9f48bd6ea024f997b8d2d03c91e659c6b5fe72d95513492526efc424b6390467219f47e47f6a1f82559eea6d41d9985acb874ec3355bb0f1a0280e13fd3b79f9933a7ce1349eb1a30c4f14dc682e9042a6c7b92d7aea6eecba38f542a6df97b822e6f65ec47954e1fd8ada352623306bdb1aeb2ca33bf150907fa608281103a6e45a487de66da0d22c1a9a52588b8af6dd53e5d1d993ae1741b72c8bbe5c9fe40dc41191fe9bb121cbfb716be2621648877ce3901b26d2b41a6be6c52d4ed57414d814d3f2dbf9e365b627967ab40b42e67a8f6ea44de51ad3f45a9891adb22b27fe5f974fe9671ab7e4ba7af29a40d2c8b9987f534a1e0866063b1a868128e6f926f7b88f2da10d5a9a02dfb182bb99f97c21062d3365cb48c501bfa229342d8a5daa139d2b5fc3e42d1c3e1619a363d1a3b3b2ce07900e622b0783790855042a72b232c3fa2452a20935996f5b65fedf845ed27207f59f1a6c0a1cdc6fe8e56c786e0242302bf63e493b9738b8f7395047a937333872500950d2cd4235693a0598d1006293459b1510f89493097785944e123981f8dcd3ad9e28a74ea6a22cb67f12290c686f15fb3c4a112c0fa64a42252dabfe9e29fb13747aac7335f9cf55477860c826e33439b5f040dabee509bdf41571ea1df5c4916bc892428d0d3df15a1c115d5fb1a1f26717864b06861da25853eda67534331e0f73bcff9e2d80c66d2e21d52480b3d3552a8193b88bf366264d446b8f6afa3fe1d3fc53721047c13df9dab2dc0a50c9faf24798bac74a086fe42304c8fc548bb41cd23661baa9c3503c83bb1209e2d769d163132d78670c6e48196530eb09da9e5220bec2a309c68c97eafbd503cae87ffa129be161f8b741f440307acceaae7550f5bb4f00ebbb458de356ce42087f0d555b31c0222ffc01b087ef5d169c02ca6f697f55008bb12c7bb109fcb07065e128dbb60ac68280583f6f8906a417cabb223ae2c2af96dd292596b918710fd40fd5be02de012a1f37a94b202f886235d44d444e72cbc9a4bced8c3c84c03648b898f47b9a5369946ef7bd3969390ef3912f131a78875836750d16d9268ea1a28e96accafaa6e3674a03b8a28839a755b7c4f9c6a950c6f7875073f6258ba79c00757028f3df6a7b05d5d0e0e8f591d5d3e2be6cd55fe7606fc265b3a5f9920bd88c849edf4e7d24cf92cf58eb546a4569568ec616bf7a364472da8e03dadf0f73fe5781dd3ebe03297e8ef30c893e63e623e9e230532f63d798b50c0ac18015f7dc81a51923771d05fb029a6d4f632bc2d9deb76acfeb363aac4ffb211be8c6c08d6235ca85db4aaae3a43f943c7bde672b5b2674c34bbe671ac9ac9ee54a78ecd4aa797f44ec618cfcdfc3e6943ab613e93fec6f534f73448fbf657fc09fd21208eed68c81aa283306200ce0e58258d434bdb7b8fb6aa799970d695ca323852bc07f0c3a4364fd7166f000a1c6901598c723ea967a68b0f32d9120d17568a3b30d6053eafc8138c07eb72d6505c9db9834b0d124483319bf96b935133e24a84f6d2b47b7fdaf897ee760f559781a0f07afb6f2c1cd0b99072c433d37f5aeba84c3ad6ae376f9267cf39ba734d38f96b8c43e291264b2e52f659eb354b4bcd53c6cbeff8131d4a83515dd994968f97ca4f0a4c6c2abe99006f1af5c0f0581ecf3b25502e9bb40715e8ebdc810a9a0165b27b478e748ea08601cd650f9016185ef51bcb354e9f8691368f69f8e30857e3de0482d998432a49c16c47063e87c6e924f60a28d3b8a78975e5d5b9ca4856287c60ad23e281fa92609b1773d2b8e185a2b9558f48f6bdc0ab2b1e8572877339a02249ac3b542a794a831b82a4d3c3d77fc1fdf231d94414fcb559667fb96295cfe2dc2a7f2e794470b463bed016af8a6d1b267ddc483b4adfa5f46bddf4760f83cfbebf907871f97fa2347dd125a1af36c253e2b62b5baca681c6e83fef41f3e2f7aaa5a249111fcf4d8245d0500b89f2c8911814784808b04d48a32fda02eea4a0e560bde8f6a4055b6c9e9b2f09c117af094d1dab97691413202b3d426f289d4a6d42292872f97803be0cb7a730e6211f5060b3e3aff196dd27c9e06ea2319cd9de3746f81c5464da62accba3201eafc2613a0723f5b8b99bed302f6ffaf0fea37dc23c6a02619c8e789800055ddb2860c56cd73e400a6124aeb56ea06ef920eaa52ae6ab842cc7ea0c0da6870b332dda8e3ed9b1be98b07d39d549bed4a8a23b6ab0e5f9e23d07d3e6a3314f9b5ace8fa42b1c96a1090af1b453367eb02002e429be4412c4007c694a3bc430a94cf213a971c14259728b71d890f99ad0667f8309ec28470eb6a9f885944f652b57fdadb7ef09bf7b1225430bf19a292a8ff4042193261ddbc9a5b6972399aa1859f0b86a8f17caf6461c1207afca69f8d4806370c979483153706c16031c2094c42decb3ad7f49666cb94039b9a3037f96657d313939f51e551415a98db56192b57c7a7e0e22496663ed348cdf047372c987b378ca61a1167efc73277df3cb83cb449e0bbd59cdb4a31adeab0a9e1d27850b6f2cbed42f083297f55d17def4bf49e244e37098c6cf1b285037ce4157b6ad410ff6ffa0586865062ce40d6a51e338f80893879bc9a5a8a07fc87e8d99baf6e59252616e1da574ef233ee6bd80a34ac5ba832bb68c1f220876f570b2daf8828875046f842b54478481630b69eb888a65229999bf8986089983fcbbba261342bf39f7d38dc468b43b46500d76ff43bf61ed17de9e458017d1977dd68f80df97f48f868621f17ac25586eb2216c03cc03a42bec215a84383d9211d8134f1579a215c85e2c6a48","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
