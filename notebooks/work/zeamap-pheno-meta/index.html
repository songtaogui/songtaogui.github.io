<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f66cdcf61def1368651d5e51d4e72376e4bdec81d4ecedbdab35144c43a38ba86c632bbd60c0134301abe90eef0eaea11c794fb6e64e1520507206c21927cccd04c856565119ed2869e77bef2fc961e6ffab5ee69af93f041150ac3e23e004b2368e62b4c90ffb5ebee2f43c6f235f5b6737abcc0968c837501ee09aa639ee54783db8f2ebf0db7ce7a582efd19771d21df4743c4dc37676c21fc931509c787e613876027104d8377977587ef9da50b2edb14b11c941cbacf8102af0f50f7f2d8fc358e26f8cc66e3a9a5bb74b8151b161afe1b8d016df1c42bd13907672d5689b2c290577a2a44b154e60aaff6bfb64017c2e4861716e4587bca049e27b0795ccafffeb3349dd30bedb506f3c461a2438be5c9297c9762d83921f14f81e25076614a39317681da3d19090eee827314bb5ab0449e2018b795c8d7f39b71f2842c755ba0fd3d8fefb74f65b5836eed919653756b60891a1c7a076f6c2646b2400de0c3a2e87e36d083fdf86af944c519aa3d54325c41d765000a090a0b0e5b852b771a26ca68a0658275d48aed9da7ca9e09d7789b8156dbff6d5cb912442dd02f02e8c0eb620e26a5df96d45a3d7ebcd5f6a86f1acc5579169421c7827ca1b22a868e62e8d0f9bb80110fc950e69067f9f5db174b574bf258200d9d5eda4bd3688bbb9493dbce455e612e0ac7920a667add6537da5a593d4c71e1569fd43a9a2b07a73496baacdc02e78aadf045415981200adcd483a6b29fee02de912227c76e5be1a597d44e46eb8dcf6ddc26ff53c525b3ef04877dc580ae66919eae8de185bc27af671345da2650c4daf75c4ceaacdbea0ef8543ccb13457139ca62506a5eabbc8068097d32b81018354394ae90cf58b7346d6e0df8d53ae9b12fb4c752c3ce4b36b052e1c17d640785538321a23dad70554a123ea0122414079cd30c17490b24976cf36c1f02b821a6dc62477a11d36bbf88886b4119b070128b78a0ca17a89f54bf8a1246630e5590116e4f0d361520c36e343266965518d045a67802f74000b5ded51b6f2ce82cda20d9ee0a88ecd2136878bae8b3c794ed3d9d69f96cc07011a9c16943ea2391814c7e2e2ba02a0c0e574770b3f8c3d4cdd7c4ba4eaacaac6dab86b15cecd5025a6caea71912a8aa2c19772cfbfcf150fd1f36cc45f74a40d8607f1c1243f22af99478a7aead99e43b1ef6352c15a6df419726f0a37ca2ecd313ed81550b27a3f324d82ac27461448d8354de22d09fd95f6cdd11d40225be256da9908fce668461bbdf24795e2f148536476e506fb492691b13538503a3201104cb4a13ae7a13bcbac0c442f676e5a1c0fdd32c52393dc8670bf40182379dc893b3f6c0085eef933a9e702c75ccfb5bd0cda7cc67ef6005bdb1b6cd0a795f17bc2f645bba04177d667121b3b4d234c47ff9c403c66dab282bc467ba8b3a2188a39d69bf46c789582a81a7df409f7fc25804a83e167b2f0cc60c7d7c4d83558cb29b3fde7ec3e302f21786fea1861936d2ae14eb3957ddb9fdb24ae488a39fd124de3379421e46b14f09b7d090fdc1eaeff701f128084d6fb7bfa474f50839f679bd45fb2e414930b9668769077a046c114d87b62e9645898c57e3479804570fa0e7ad646ad1fbb50a4e700aa684209d18b994f2b8015770c2c4500387042fa55d32f9db0fdaf752cf38c9ed9b389938d856087630a055b81cab48794d2e0df81f36eb9b454a17bd90838f0fbcaae5a870b9a0b2e531728fcc0b210c4f92771af1d216d7e4087d3eacf675aae6168825945c35d2beefe1023055fd53c5787d26bd4ee3ea4fa46a810a7d7258d9e1f79b84e57e0463cf901b89a5833e441d0ba643da4a28c25ae190a5cf55566cc17caae2643ed5be864943ee1121901822f60b8f0265a401f391bfd8bccc4323da8d1656c78a43e7065b617e9380124bac3e47d77d5cc05a03d666adfad2168751a084da7f483ff55fea3606ac617aeb35d0abee67dd2c71ff60d119f3edfe7bda17e2f33cfc9c05fbd4e8eee82a06f0955c27e3be2b42630efc3c7024da1a3d604248e6a595a8c96d6fce5bede7f2a42e029762ade7892217894d7656d30259f583a5bf946dc416ffe80a7b48b1acc856cd60f112fba032f6eb3f36cd88fb0e0404ba02a11f8bea136c465898d7ef251102131ccc0b3d15e500ef34fa8b6acd049c499c4bfe6b1fd3782f1801562d61ad586a3865972cc3f1bb8b28262b1b135d370016e3e85daf15d305cb57305d49b401262bd0337b78f008020dc9e168e95a8427da77c3db427d3a6096166b1529a9d7e522bfe2d8fad7d5fa9585cbfa414895a47956aa15328373ca24e374298a8289707452d43b8c9ce8dcf3bf9417000fc22ebf2b0d97f20f2d8b44f484ad38d764bd7ece444066b5e725b732174531a9e312fe56f9a4b5f2272c9a4f221b7437128785017c55d1f60c37e1c7ebc7f558bbdfa6410f1e1bc613c1eaf682690be2d529cea4cecf4b3f8456666107843422e9a761f344e20c8b4568812db3fcf51804c0d78c1a3cd2e3ca4ebc712ad7d94bd09be7038e072d547065936644e0337ce37be4ac3b2afcd7f50469ff15cd5efef75340417f64b43ba28f96c883fb0b0729b6b54e270ab25b00ed30abd6133973fbefb10f54a27e00f141c6682542b970e292bf95c74d021ef4f7bd1a26c2edb7788f287dcfda3f92503c495fce5035ca0a1d3515f90c67a4c716eea6ab079d9a36ebd5ce5a1fa69d5f5c0a160ef8220ebd1277578afa1b31909af0f4d72059e46dc1d6166a5540c45bc235c0abcd0804e02005f6d9038119f48593ea6a8ac31307e3d6a71f75e8006b91be7928bb332cc78519990580d3c469b4c0d3687e1286367e59691ba7cf663c8d28a7a74ed2d0b204de1e58e38d5413244515ac0489e9e3ab60386d1818b4e7bb7d2725ea6b3def7b4aa6b2f38cfa17764e93a755a3338648b8dc744b868d99a9e92d385e75bbc716daf29c92ba1ef653e36df559a36f4fefc774866ef67491e6383145e2767bfff9f0ad97a707f3bae1ad580959d4bb390cbfdf289b243766704a9e4e4b78713685c4453c6dc4163296ec04a03fdf12f118a79cc38de8c4aa2f7a67bd074f093533389dedb0997e6aec16f2a6ea5e018b6e15264404147b94b503b124e0758e8059a15411b3996590e543d134a9d93f1190da1a932a1e80ede8f05e4aba7a42aa1c7f449f63c07ac7899701527fad8d3e67f8748660599586db4e0ca4271a2434d702df5a87d0fbf989fd2343201f776444e2d56196938d267e45e82e862afa317076a12a3c206f164fde42dfeac80f08d6fd2d94e1972ebbdddfe7f74eb71f24a265d56d01b21e9f2fb156cab99347dde8ab57dfc7abab469216d47a4d44282be9898fc21fff4bb9e3ed1930b743ba2aa38c6ef464feb327eba41c31c19af02dd30d6540e7cfd2073d4db29645a90fa2c30aec5b40416dd4cd1ad3389bd6c91b0cd8aacd94410e9bcf246fa510a89d11e1360384d4638c212fb2b58d4e9c18fe6bd310175207941c68ffd9c0d932a90a20a4eaac832d5caf6a9e33e64a9af2408cf43bffd2428d2c116675de9d4c1a3306ab6d84481727072e83cc10e93ca65ecb4d9d023ccfe2566db5ddcbb980edb3c59314f1c55823321ba520531e110db27ff8cb4cc1351ed59f8267df90dd8391058837df245ec2102360e6bc8f159c0ff50f17f94a314a9e1705c5e8cd10f7c5189dde4188b068573527a2533f1b36376eee14202e2e10ce86875c2ff000452bffc0d92a2f6098c2569f099a71745441ea946bd759bcc0ea0bcc3ab272a271ba1a9464ceacc580fece6170aaa045bb7cab9b9d35c8bce3a5cf8a3fa2c0f919cf90cd9cfff4b2d927d71f41be3ab7375fd5afae992c83e90b5a546046d89e00aa1eaeb7b0a0275f4dd441a4d260a73ff6357e73580cc782deb68b4d470ec081d1ee4dea67f01955a39958fc306aa9be4fe6b8219c40be2c3495a27a11bb20e5e7a8dc7c46411347c6bef4d57bc8fdad8d65a52eaebef71ae461f0cfd1a3bcfbdeb419c33aa943beaa978bde31c305a75a41e71ec3d5d04864e97a9a7442e09fb60b32f2db8902136b1e7724951423bc5b97da453f9a8a1e0fad14b6c88dc2fb8db96228a19768d925d87f374361aa1f44b05564cf10e686657e43fce0ba0b8b904b82cf2447a394afeca1324ef944211020556dcbd7e78a6f207472b44e131d84003a00f63515715fa9991e972892e18c315284fa3a4534741be58a2507519fe4bdd1d2ed9657b3fee4c112f351d3a9a577fe6e69194b2ecba07b0d8c4d3a3e9dd2408030251d1edf1925f07b7edfd3e410e53e1b80811811a04dd8cdb1148db853699b24d060d235351c761c369d9caca284433df9b00a0dc6f969100c022f62055a1282348b62a9cdad3d0f4bb528653dacf261d96d5d705940be69c47f9e413e5a80fb25deed62e142b7619029746653a1ff93d5d462e01ccfa510a3ef06f0eb3007d8ffb90672bc4faef2d46249ae10b913f66b0c010b5466a68925f54e64dd16473ff5fc0aa68daa624a720581049a199b55042305a95737cb598b0f9bdc3641595759a5ddfb5ffc497ed6971412e6bcbffd7ead7d3d780a1253f647df9b4e2d5f5a21cde3826abc9814c5a9f7f7e5f7fdb60f393adf9d276cb81bd575c3ee2127b59662fc95d0a460d0fcd9e9badcf198e2a1773448106133e0caedd28e96c802ec91190f760153cba8389d19598aa57b843e31a76aec81e37030e6039c29bbb97b48c3840269a285ff6fdd540e0634a336a74c393e0c3d547477248c8de7ccc2c24f6523f987a7cdc510622c5c3dbc4599fd9b29c6947073b07dfb1840341aff34991056f0d7ca1dca2a2ad9c423adf1f90e88987b2a565d6f452eafc635c913c852d27dc8bf7fe8c4ae0094418f893ddeb35aef3f97d524b4e09f376bc78cb11972790c7e35ea1fdea96397ab7e0445e3cbf5f0fdeaac9001fe10aa69a6c972e9277d5e41ff09e06692aa47f5e488fb605886b2ca38b8410d7f3546c07832b5f61997183dea26ebfd81da8ffdbb8c654f3ae1ba1398c8b732ff811d25d7eed29711aeaf803e7b4e8bca45dd9e54a7c62511083d786b13d47be94fd53e368f8f085200b6d9177074b034de3123f60ae896939914c58add9e56e529e6ace6961e6ce43e91afae3521c69c182154df7f149720d06044520299e1c3a467192e4a1977afd1989c2b10d90642b3c7d3a7f877e7e54fd4e5442b8034a60c5fdcc23e66d66ef4ec3959c4351428021dc89616ff2234411cd393a93e54d7110f12f130ba24180983e9e6cc53371ebaba237faafc5802faf56347724ce43dbce70c1f367b47331e6294394e968034993dd26b9f97755b6436a4408d8bc632f0e7585ff5d97b0e22b745a12e09f2d04fff02781242e6273e2de99325e8300212f173c8ab21dd7358108df979dc3c6c23dd07f0e89f9b8f8c8e519aaadfc357e945d367e23e716d50cc913f72ac0e888d937e88f629fcc5567eb2ba72cf2753f2509d9862385e185777b2b70e6aaee985563108ea33b9ee66138a645182998760e0a414d51fb1eeb8253c5d329d6518831044e64834fdf3f52635797791a1622f2251862822463c829edf6cd4131c83b1729477a2cf810b97156a1c475f81843c577070aacea5d8937bda6a44571196b765912059c97262f27bf99927c1be6d7b98c3acb10987f3ddccd840909b843ed2513e759d0c6f02d0c78e958394a4249d3608655a52643ba7fd46dfdb0b8c53ba161c44c3258f0b4450917f0b6c5c7c5a518d3f3edd981327b57a0b38bed5ba15e19aa4d01103437b0c21ddd6835be1e9b2756ac126c0ca4270351a513e7b20f4765689230edb5069e206761dcff5bd592279e1de2860b0cdf86bd7af0725d3f59fb86360ce20b5cb9a8871be6adda5a650f81066f24c8b050245cda2da5de461a978c0f4aefee3d98729e7555645b401fddda59c43af00fb67ec83ba8d850ac6095199673a3c0a2869eb7f5100fdf6a82479d2ded6e83a05944168ece8edadd49ccda4a3e50bc853a84ba9820321f4ae6717daa653fc5485766b98bb3983efbd58dda8072967f39122de5c42d8f026989baeec9d1f075b9e5811d96d9c64e3ac761a0ec9d0bb5dd14c018fbe9e5a7650ceec788c47fff887f61363c4646871c037f29119f42e116a43101f76999b840b4d5c5470d76e6991930af2a10dee76373fcd201a8d3bf14dcc9f378496e2abbdba9661b8152186421e97d68f785656d4773118fe86599d50305781db179215969caf9a0803d31ea21ed207e52351cbe1ae4444aa996b3bb1466125f8148953ac56759d5a95993cbdfd8bc087747d8c3c79fb75cea81be6ea4d5e494db3f17e2e9fe5b4a518fb05e6ec8d08f940a052dd59cef81ca45580d7e807da9fca9a06777fa1b4a651f7594e2d673bf6821eb7fa374e7b797f2727afeb74ea0aecd1b5ec5b33802f0e22276dca91b5e0dd33ecaa6a505bbfd96a510cc1b977c6f3f17cd7771307731ed15b81e84fd7ae1b549729635637fc2a94982b1aa2425372afa499b781ec8002d67577ecf348b60802d3f768dcff63a7f2515c191ff368eeab1603799bff88b88319bca6562ff329099b52298d181e3a90155587816456b1aefaf3f4f9acd1c3634af535434e08df481fe534934c571c945d2c3a14f4c7e70d5fbcdd851c58855af7334adb407650860740b0b17b75fffff2a4003dd9975ff0f6a17cd77e53388be903ab1dd5030d3bd054403a1d786a35063ef0b5b9e639270e42eb39baae15fbc1f2dbe359b13ed0e086148f0bfbb83461f019bd561f6c997ffc911e0c89f56a8efa8640338671b703f53190a16933ef36acfd64ee0ddf7d167fa34293887d5f07da2290b9a32c4db6bb427a9f2c75e3fbb9a41f03711f072d4c3864d8c8324d85fde14aee722b0953481d3112b3cedcd932ca9c8897bcfade19062530aa9d27c82ba16c8aa6607bfb90cfde33f8c96053db1cd8ecf9e7ad68c562c00ae44dcd2c20e4dd012c82b6f3f38a21222c6e93137b4f8712af68816e5e4cb944c1b0d531731853abb51b0f18ec4b847e69e0288c1f38f775c10b4eefa7f721e1d51af873b7f2bded78befa9374d33c27fa57f1969cef673b176b504a538ab61267fc6b10da8703fd04855b2e4b0cbe337028d767a17c789ab8ea7cf0dfd240805ecd25cc4749ac4f06e17318780d6b6a6f9f56b18346842faed2a52ee4e4aedf1d859c018968e2aa826f24648842192ba075641bb0dc578adda31df10b785b4efde7cdd6d7e65799676430653c671995c8205fbd5bab5c0c3a6065e893c487d3a537136d4131918f2433f32d9aa7977f569f80ed38d5b6b1d19859e05152f6208fc4cc8cd9ff8667556fb875f6de0d89eff0f43e6777b240d334da5faae8214c200679fb1d2cad7b401915e61ebe576576beea185a0db5c0efd4edefd88e2152d2cbf66753009e8106272bf15ba134ef737cfb4d0410d1bf29ef7499ccedace3dd002c181c488b7ee2a10498d25cbe4f1b59d566eeafec07387d8274e9d1e6997c0ca08998df830cf07d6b345bca8cf70144af7aed3b333e200448d3b103524e3489af51a94f1e9897ea75b249602ccc81516c9e1ccf972d70b5c96390ac0591c4ec12f897e16ac94aba4f35a60db12756c57545b6ea4f1e696bdcb22855028849dd5a07fc3ebf8bb98a0004134a3e30895a0cb9da0a580f410bf4cb5b997485348496df92cc29711665fb69a5e82d2a252484ce06cd8e3562480d668c5cef0c26fd5987eaee2d934b3e0d877b7295decab265b3914830b44f352c97721709637d9aad1231528a39f66ab8e604fed78ea3d06603e1c6dba4bbd0db768cb159dda23d4c9475376dbffaa6481cd70352480a0a8f2844f01fcfb8d3a8514a4fb26e15836277f6e5558fb5666b4517942e6458b536fc5d97e8cb8dcad219f239b455fdb6ae98c712b2dc4aa7a0995fb234f66b9225fc7b37cec21f09f9be42d2b1535ca070a1f17581340210fe401305f5da9072695a0850d3f73387eb78e6aa496e680538ccc1ac3279097455253bafe7ff9a2e4223d26991fcd3682015faee188d33ec9521a992db3b29d8efa27d328333c70bb694f7b8013a84fee76cfb875413d592761602b1577ef7c4d7920e06b89df4dc3de06fb08cce7a4f34c47ed16091feca4367df3a0438d0e04383e56e73fc5e4a7d0b872c1f5f476a9f6b5a127b4c62e677dbe1938a237d5c47a35e263fbe725b7cfb0fab125ba7412aaad4c71c6686589533eea598cf7ad88f862620db3c8141f3755ba74beef49747aa114a79b89c4f6c513b49ee4fc7ead56cee5c280d870d31e2d9710bf7d4f799322044010860799ad972a91bbe644bdec3cef59840741fff337ad3725b47d9abadd6fdee2ab3baff50a4a941484c46f7db468ed522515da64b480c27158295ac0d001509e96aeda3954daa113e08ec98fdf458551bd5cd9e5880d477f7660dee1a21e52c7dee476db78b2ce81e5ee94e4a1d6e88ae43ac7dd490eb6addb5c272b3de93c79d14f360842e5595023381d96de1e7e59e8ff636beb7a58b4df05f8b35ff61f0b428b724141c5cc6028c6f595fdb64c72d3ef9950cf4def254265c6f6f12396e6f0d1eb10d45f9e6d0cabc6dd301cb0a442d605c0f0643416941de59fdb8972e39272d6a836effeed063d32e9ec09241ffec27f483d902f7a9cfd7d6747e17b18868e5bde806b06d73cd4a525e445cc10961720a56e79de54519f6656118cbeb15fa21e68843dd2a5e52d69a606fe22fa3110af98a50a1d7896b13fac6c5e54072933ce0899c614466c80cd9b0e85cb3fc140660d8d4eaffee3417c9fe7188cafd372648fcb4b3fd13b3bc5014bd1a51e2ff923c0e0b68232d73effb018cc773b25bd62001dfcd126f4f544f5f330a319d63ecc0e4ed146ea34e353d66dd38f05e5f5a7a01a15b5015d7583492c84aa80805db1f2ff72321dca95023b96e89c93405857b405a3463c5f239e88316da7f95cf1b244297e7590a24a5c0d3c67d1a32d25843252ed53690db3c43080a2f7553ebec6ea8ce89349417c68cb51c38bfff9cabac524b810beec67de1dec66bc75d6cd13cca8b909ab5bb7997625d78a19a9fddb7a40ff72abd8554cdb02751866269beb4aced4e459fe24ca431829f0b4fd44cf9bca6661b7f46fef957e0bdce558578cf72e74e344186ef46e8fa70937663ba717136ce27b076589557890ac8088b27bb4cdaea130f332f16a191e264afae358f1769bf2d70a6a509a0d40a5e01985697d8bf4f134c68e122ba87b6f5afb0345ae2d44c8a7f56e74e4c431f541d8cd3ad4519980de5755802d6e8daa3cc89ad9b45c780a58307d189e7a9cf4d77c9bff95f38fd78874545ed7df63e07222593b23468ff55bcbc3c9419b9587caa4917e89fb1d6415b2b53d22dac3bdc25faf6af65b7acf070a18245758a7e2d3ceb3a1c53a5fc08449c5305755ade6131cb27d64b00730967225300491e2756f652b8de9204ecb459b93f8549a28f3285667477d25f75c4d4b7d776965fe3debb5060995249802a2e193a31becb155e0ca85f73142840b65d2e3ba174ddd054565fd249ec9919ab76102bb8e55b59810cbef794d2e314ff59debb4e9e5d8d7a4120eba2304dfb2fc29fed8ba878c04577eb809ade70b7e4f1e38594ad0ed9dc828190e1203bc7f7cb0721d038a0c4157b083edacd99699aa9e01a11f5fd70ece311cee7b782e30c62317c4d27d2fc098405cdf9710ff547acba0b5cff49635395d99b4df5cb34671c91ea76b5f3c905d920202ef73b97a4405fdb61bf96214f628aa1964d1ee10f7fb8abd1bc124721c2490aefebcfd43015c6a40692e084e726ab1272d1a0d6ebb2d663f85165205aee6bcd29e68b202f9251a66874a2f84e11b36df7450b8fd08d3072af63f8add1fba7a1778cb82c151373a021d29cb71cdc54f54c9a965efc8b97fe026c4838ee3da924e5013e42fc26f07e08b835fa0f32ee161038fbfea9320a102e6671f1ed580cce145b476667ffc55080d078462944aafc486de472700f476d75fe568218dfc7910842539df75f5e8b8364fd17d4fb59cf1e311d34e557376eb75817a595ca0e837d89221af397cf23807ac5e5c18dac3d5291efafdb3bcdc1b524056e009fc8062aefa191b1d1a6a9234d8bfe6d0a644490e9c0b5577ae32f874610f3ee0c8f39f0a920c8721ebdc5f2608823df3c8a55379bf6185d191922b339ca7dbac0b5ccef97a1214cce94d7a5951ac3bc758ae327f02f2f973e1903e260290d3f4fd5e6de43c4ef0cec337e368652939c11dcb048148540fcb479404fa80e7deb245544d84ef5569599e5685ab6f0097897cde1c5b9cf5aa692316b276bc0882843b387abd049ec88b9027cdc193a77d823a9958ea6e14b57afdee09f8773a6af60b14a4e98d4643fa3d7ce4a1cbe24c8ee936ad3c1a53d10f021440fcc647dbe072cd84525f038b0952f442de9cb96bf3fe68ae433c27240aabbc51dfda08b462162e995b80cc9fe13d4d8dcef08d41358edf570abc0d182f490dedd409d3e6c5952979d1dc5f3f6f779908aef7ba17407c9a0869053b5eddd2c67a9ad58999573b3d853f25d23be2dad114483562ebb58b168ca6a8218707b3ab74acb219063f729366459beb3e51111884c97b8fc370efc8d751ceae0d1cd0d205ae559d91e7cf903301c681788d7d7b176a4b62636c6963ae50253f30ee774b9a260f0c7c526ca05edd12592984e74a18b48fd0ef9687f753c4a9753bb4adce74295415c77702ef305317712f97c8bcf87eda13c7a02ebde8addd1825d6f6d9ff68907ca2fc97f9b445609ad4ee15c258b83d0083db8ff953f4ba430669154bbf1530c9f1356cc747d40ddaf887c57de177dd25c62e862aa1f5a8f20ff32ce54a8adbd452b4b1f0df1330940ae045bce4e1a4caedd02496d8bd0a8e67606c926e5a3afe5410a150e5b067f0a11e64552c2a26192abd9dae09b239c11b27ba26a50b893a62a1ee1c8c53940ade4b1a938b4c4ce90e6acf3bae18273a65f457f0f7f39754ea7228d50978f4c4a6e02cc3c0ed36afb3c5fe9762e519d7e7d7dad669ceb9fd380b797c99a337965e1268030d1cdded8a0b93eb60c3138ed664c133a95a5981c385a00b8a3ea1ec33dd13bf899613a1e9adec8354dfb30bc794886463e934568b8ed9d275d6ae6493b8e29ca5ed3bcba246ef6db26f9e446a78c7c556238df82f62fe84f45d77762dfb9dad9ece130eb10566263176ca21891206238e014f32d91d8bb325a1fe12a9ced963696de873427e8dc0a5675bcb2f55d41a59d8d984fa1ff18db4884303a3995d4321094a76eb9fb9581c9475f27e613013f9ac6896bd6ceb69453571b49bcddd7046da1e168b47e1c3b77568dc5d93d4b6989d4cf70829ab04766f45945d6a67cbe1722d5e782e8b02115dacf520f4c1b8e3b5d3ec35ec4cae00964b4a17841623f48ab69d6a4202d49c9fe5790c19dbc23ef5c144c41dbd6dcccc4a74e106cb56358851c91b5ede3d28f867f691205f65fcbdb8542096476ba7d385884146b7e9609bcbf2a1b692428f0f75d8532778f42ca29b19c1e40596c4a64fec4788e9346bcd6869d40f8c69990a774cbe5d78720bef7cd96393dac3fce0f3409c06cc6e6820d58cf46eb1d368e15b711a733874a2243ee43c8ab490b8911f924f1c4271736526ab7da68bfc4725d1014466a8e185e6ff53783739ca1f05bce9b8ceace9e97ab78b9889a620f50051bdef68a7c6e7751b0a248865f79f35a4f7195fad0030e97a8377762cde543168e075558667f71f6917c908a5be0d379cd15769c7ca3209aae22eb0fa69fe084087345c8166b718635c3cdf343841cc44924acbc1bb1cb5409be0e80bee5250a26151dab2d8334bf0dfded07c7eba04d01c720dfffbf293fe822b0e7e3dd7bcde2222570a58bdc83cac50346165784cbe25c03b1c0e07d20a37f557a86eb4bb850a085a3226f40823b4603a26f12413d21df57f6628fe24a0992e4c815a0309d734aa2b7710eda4e9ab96a24ac347040d7cbcf3b933b45e19ff653a5cb11870d397c4eeb5e7aca9c5fda50d003a58019e372e5cbf91779b14e602bc71b7ccb0bda22965be7c92617284f03349e9a0e0cf4453e3951b081711a3886a6ac21151b18ff92f48bbb1e1e0b231f59d980ffbfd7c7e7faa90fdcfc9aa8a9b4ff63aebf2d65d8768127f39d2052e30c5d8a2329440c1c4f77602471c2a9ef366a57f963e32ff0177c9db5d3a5ed0973d2d6eb9db73f3990cad9695483352944dcee569543cb78c1164089351879f1eea3e882b20d03610e54cc2421806b2976046e25e3a21ed08d0ce0d69e2cc59cf1d1a58032a535e25212de4f892faaa7df7a1a56b6d7985eec333545b97a94fee7d8a81922b3aa7e708fa45272ff9c5d7e1270a17a6683a0e0b158e7caf78e25a6530f75e44a7bd92676a7d6e67fbd9744bd406a09d4e766734d98c575c80d8dc041d37be3b7b25fe44681ed71f6618f82f936d9d71aeb8fc5c6ca66ec553804cf2f1a4dfdfed5f41300eb70d71ac6ee13555e5987b3b37cdb80cbb01813384f1409e9b1fe968e63b156980ea9b36007ee758f447d7c229c5b2eba8302dc7ebbc360b83a0cadbc518c2f15a6ee6cb90a9740310f0c4ad694f3babc3258d584ad8676871e106c1b01bdd5742bec5704eebb1b932e39042f82ea2cb56899edcea998f05bac8fbe5622cb9c0fe96924dcfbd1d26d02da40bc670a62e1ca45b178219ff625a4956dc58dabaca5f40fba4548f51339fa09e2495ee49910eb0e5306c7cb9baabbadc86022ed5dd73475faebf90074bde442b9c1f1f47d9abd3da49a7c49355935cb6c8ff26fe52a21eb3dd40114713d448cbe4afe6edee9011d177cb7ba6816ff61e43aadfbdf6a69eccf31ff9603dd051181fbfa0022c664aed4efd3a098780d422c11981313ab6e932d8b596f9ad12d552c4178b7aa9217cda28a450d7d10a73493ee1bb3b5377ee2c15811d2fd470287c780a56db1829113c4d8d91d067d2c8b7fbed6274a9b7287b369bf8e20800284120ebeb9cf2f6b04c0b782576bf8adf7ed625ce03ceab28e07595353c29622e1a1184437023d1483d4d46ef4327b105f5b8ed9262865160c733d7830e13ebb340980ce72d816f8b99c3f939ced48ed79510acd8e517184b62ef77bd4f721adce113f245cbd55dfe5d3f93b8145106685bfdde99f238d79b52bd12b6158c37747eb7997cc1bd34331cf77a844fb0592437de78b2003213bb68a5dcd2b5c065a3da59d1d2f3c623dc4070fedd2673771031d22bc6d162f66d57fce96c364f4f7b868e825e0f4b80095884b735d903af883d395dbccc4c54e8a95425f85a621f68c18f5653ba361ca6163bf51acd0cb61392f50c640389e87ca9edc73c9bbc32c4aa00da4de74d8019e63dd40526e41b1be0eb57742e4817b19f6e56555e49ad6a1a780ed17c5fd76820bd86f343e7ff43b3cc38f59150d9d6627bbd6cfcb15fc54c1ec9090bbe1da5399edc813d6ae2e500fc195bc9d5804392d2724f1cea178097be545f6f1ecc5a5ac6bc98bfd9a887a3ddace49876a45d2dc1df21ecab256fdc1cd91bfef968e35bc98ee8c092e5f8c01eddab59023ecda1a4e49f7b7b6956aafc301e8b963113bc40ba6a94db4b443c41fbcff086a4b8698f79db8b3add0537243f9677dc479d97a5fa10b64c3c029dfa8b2038abfa817a54c801dc74c6d41f2ee98e4bb745d3c581654c4ce6017e295e28387094df06e7680a80b364fbcf1274e119cf0dfff1f6abe7f258a435bb9b4f1ffb7fe07b7709bae94eb1b212790e118f76beab0b86b64fe5c5d8899bed338ec862d80c148c188958aafa3ade0a55a9560b556e8cf21965da26029c70ed67d62f65817f73724accd15fbdbd4a2c07b32da34deafbfdcadeabede309622a0c99c200bfdfb37d1e84f0831671cbe6295177c4fa471d96a4c67b9ed6105e6b30dc0e4f0023c71ab3f69a8dd571243a025522a0e0c61e18e509d5f938ec9a31ee304a645d3b926cec28c06ed7eee78e36322436619ce2b39cb14c9457038634b5455fcd02c107ae6d0c4526cecc4fd2590d99dab69a95b6004e456fd16032dbb08a9337bd76435b75e2c1270fa2f0ceee9b1b0415e5def81a58105e8bd125221bef25220470fdb593fa76fa48d29efae226af9e1042490e4b3bbae20be305701d48727589a2921c2a910620770f8c159cb489a3decf200d602f3eddaf0bd602988b23a3e1fca34d744e44e084c4303acee3db6f46693b826e16f464e64e57c6e650375680ba0435c3085d79d23e8685312a3914cd1030d2ff89206ddc3b7d6e5ece27d78f016385d40c63f6b4739cbe6a204f5331e2895958679df09d95711f4df7b132ff534b9e75429de509945665948dee596ed4892188717b74158e4987b9c60041fd453db2cf857d16b9b38e4c0acecf9e8401378bcd9f2ce09a3f293fb59f89e316b526761bd3b3e6ca74fad8c5ae68af268beb35c473cceea37533082e4192b0bc843417d5a7731769aabb10899e03bda18de4fb3ee316fe71beb0b5171b2c327dd1ce4d4d4672a74560e456338b4644ed2686f8a2859a8898e0ceb818ddcdb005516dc9905bb9d78ab55cbb48682ed5a68949ebd3834520d15a94c3808ba96b5f3a4c0d97791b0fed9456a22b618051127a1a6284c0ff0baabc61ce2748657eed440c326c0f32f1165848190b93b1a3fbbdce190f51f273008fc306194fd07ce4fff59ea57aae2ac060e3f96d90b22f7e48127af6d6d6e5583aacd4210c9e0426ecdf19436bb9893c261b1252fbb157c4f7effe8a3bc0507f480e6f68f3d7930eb6b6a85bd8940d0cd5fe8a5bebd00474983776e57844ff1ae619177be1d64454f244a0d723ac852b26da31407e24455dc587b6f493a75d8aee7fccf9cb665d5d2b200f28833a992b754fc38ea3133da8bb2923712b5c0580f503db486c1cae85bee8b6029b5ed23bf6c8a18105f12ecf1726deb1471e2764a63d8e01494446c3e98eea9270fec0a2ea712f1594add02701bbe25d0a2c796d8049c712b8428fdc4f69bf40de612aa57ecdc6d8c86c7b96549d502c158027457212c8ba7240d38b6ae52be2f5b8c5ef002dce8062883953f5775a328a89c12508ee2ce72d5ad78ced0a8b0d3925a4aae4a27c00263bcdbca5a8e898865ef2272a459c23219f87db54e70737fef616a1c901d5b233027cd323bf8be93d408991c204be55ac90aa59ffe80517b1592a9d1477512b1626272cb93d253bfea77a0e9f087dd168bce5fa431de20fc29742d1feb0daca7dc26effbe98a4322d0de9d80f664d17872271aefe65d3104426ad2b40a6fab0c787af569127751c7cc5bb63dbc2de52a1c902c4b77ecbe010997132d1f9e42aeae5b7876f7a7aa74c637f66f8b6bb84a057d7c1df3af460c79ffabca1388a9b3015f2dd0603f3b9379a8c2d52b573810bd49da1043824536701e03536fa2a741438b12c78a87c8896ace916d7abc8f42bd695955bd011df73520a991854fc16698a8aaae498206efb00792d6e61d82a3707638a1fe26c0dbb4aa4959f6af315a71dee7007ea9c5f00cb7df097e75e80ac55c204a7b12b1b56e63e63a3f1ddbb719ad690b782da5a88f3fbd76ee70aa946dfaf09f8729bcf37f1e115ae51221b4c60a446dce4b12acbcf66eb3d9b9c9ba2cb3289387733562cb653781e1daa21d011f124654f556a7a0b60ff1fa946e4bcee0913858efdda851b61aeac57ec5ce427fa34d2297b49c499d77911aa0be4648a81fd28260751ffa39b7837b189432578febc68d15783ff0c215a49c75ea3ff522f65a9a746b5f8f534bae08e1367cef8922645bfe4803cbc050b9f25eb92bf5754271e08aa0a5e4f4fb2f8f9f5f0a029fa79f47b5a1257e664a1dfee3bc96c0fc2f8a5ab0ba491add8b4e552fa70b79218e9f7b8b65e315b679ebd27cda3e3c384035505bea2a0f3032613eb452d865fa816fb8231f84d02ea531531986007af474c4bf0582d99bc9103a4aa5090435552185a9434991654b7b94d52062e8ca01550c305dacba25c65b89e5a1c22d6b468111402911b224d49ae9568f353400d6428126756557da2349686518e55874b9f62f0434ff4e9c406e22a6566becd974e8f4aacd98a4e3d9302d1effb8f985602a29a275fc0c0be05f418a932c8c05fc8a022ea43c8ccf3fade4151ba267e6c73f7f7ab6a38a4bee6f8280537452b529364b619dd235c062f3a7ff225736c2d631d806b616ab52c214d5f934a0379fb82edc6caa1dc12a724a85079dee0a10280e57f97d39d75cb36cdf31e0c071abefd3ca69e7f7f7a861cbc40527c85ec25769743e802a24da1b83e33d343945fe08854450316c0fedd64d5a775a7ec52e2fcec827d430cbe06ab439c2a40350ce7c693a4e74471c65cf595100950f9a03d95c59da1adc5449267497e940b9243d78350d354327656c37531126207a0a3695166d66b260acbedaf6bde5139d23ce10b9a29a8b9a1d4b072078ae48772f7b03023d2352a0d1f16762d8f9d7a7cfbeb9a0f840ecc028237cd696a33cb9bda53dc94fba21567d878d381fc9f923ca0eea77158b381c53cf84a980f95d94f9892e5664d2a379c9d55b4c09ed77a505ee5cd2f6effb1f7f4332d15c4fc765ab0254f16670edf55c705a0f316256f537f189b1113ca524d87771b1763a4b9010c364da90f552ff348b111e821a0631a0bde2da044981712b42ee049368dd9463f3c35d1925a5e50d63e10c56f097ec5c8617b628b2e10bc06237f0337aada2d67ddeee3f96761cdc545deb71993fc1301f1292d32dcd1385cad6e1f4b464b71ac2c2ae0ae6b0167c4502377248ad17ea7b487e1f82cf5630cf13cecdae244cb8b8c73171aa5732df199feeaa08adbc129f146d145dae12b1cc69bac599d886df779ddbc83590432d7a0f2c88b88edb5cfad5a51bb4181591d30fbe9f21d8249a52e4999e63ebf0a063f58b2a9d4b218a106fc03bdf5f3117b00f734e5e4b335d6a0cd03fe237c7a0ac6eb3f15b898f0423c914cf60715516251bcb964f78daf66ae3bfe45ef9d67a939ddcaccf511dce142946da4f9afa15858089a719865f2cf10e20fc2b8e1fdabed63ca255d440ff5eef985bc355451b256309151c34103dad0d8f27080b869ceb1c5af6adfb5b1a0088ad681edfa8389db399aaa39a97b8e5e0191469f34fa4aab2bc10057054e0427c85eba8c5bea29467767d429abfb8578f9536ec4761803ac7092f917c11946edfb51551a937707e56715f2c390980b88d5f5a8611585c74769605f0db4d0ec02c0d6cc23ef17d5d079694e8e3e6bbb17d795eb86d9e0ceb454efaa2b0ffb5e8868675205bf5e2d127cc05370775a4f239efacc0101b5cd4e423c9dec833c6165a4261246cfb836f8c42e0633a52855a61ad127d8147e2d7dbbe55ca46d14854903b2d098b45f3b209f3eda3278f46af7be0987bbfbd3c397b970cc9d36b196d116c7255e60158e21ad04830e958e92e7b313c10ff46a17ed956f68d5245d505f1d5742b6e53d4a20a690581ec3d265dff1a70d85549507dd044e3188825ae2ade6b010c349cd310ee9e50b323bc613feafb79b9954d94629fe091c2a1412c26e791ef1cc578b7878e373f38934015921c6abea3b81c9070e27eda5309cc81601f4cfb96c37a83ca2d3df36da1a609ef3769d558d0d32a2102248d85d20fa6ea2c69f4b94cafde234259503e391c91a8a85d739c1a666dcb0de4a8458b170ef4b1a7452ba8e7722d5dfea79b963c37562c9507004868ba0c0b743fbdfa7fd81b3b08e62d53f57cf5100aeaebad72311c574810d8e83469299414a8957f67f7b6eb9f1359ffd5df955cc82fb35ce01db50e674805226ce5205a9d57261c864113233cd4d3aab7b8b4ea975ab1738ea815033e01bc833156ca5a62b0a3e265b8e708739937ce9c142b9003a7907dd105784c5e482aecf045b933c6f71d9f71fb46f24071e2ad91c3bcd5c813185f97a1d50cf64ae945bc453b8acdf5bd2ad370a81391aeeeec4bc453cb2430b7d6eb429e32a72abb654a1e4c939dcdf3b0747f97cc5c5fe22a05","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
