<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"748d99fe9f1afa0d17ba427eb71d57b10b61df81f449d0ec8e3b4788164a4988252976b22f2a844ea632f4f352cfdf2b2f99a27523bfa94615791267de04531a17e3e3e7ae994a52b019ebf999f6babe5e726321152ff15de3cfce387581452b354ecae08138d0758a8068e7fea67a2881689a0fb0ae1e3a21324e6edb03982a7ddc01abba37227cdf280914d43b2b9ccb8c951aa87d9431480f882ce3da67e7ba670dba1cb594463c5ee67da1175b76bd2f82bc6e9965245e448ae1472499b698f858df0dc21791701bba455500989fcf0507591f0d513a2e76af6fc349f11e6fd92f528f26a57b8e46a8a63e434d4af174614673583a40ecb854a0aeb88495902fdc77e5331183607e6dc5285a200ee61969f2eb15d957cdbdc5b03b8744d09e6dd6af95d9bcc07efc72a27202daf713c6d074badc01fd9502977822e9d683465376f87479d3f276595d9dfe6bcea31a5c353b359247a28387c01c3788abad38f4daf2538f374d3baca39a7b1b59255cf82856c3cc8247ab3db9d2e1f0def6243e6a1facfe873f3ad012a13bbe258bfc09906b045e38e5917930f18eeb42ab758d22d52fb3519f2f15f39bf8beed0545b29ff047776104d34221e7d323405cd73575a89e076bdbc17fe3a4cdab8d3a868e31f60f16e0a454c44b21f5adea123ecd74a0533c8db0d1464448e3b776404150c9b2fbdb565bff09eaf9c625182d9ee25d28c35578feb16ac6a7586fbd8e33174f30e44b91e45c1d70342302bcc65e3e7a9e25aefbab796a5f9010b1ebbf70b9feb977e8f5586857a9a26d8d6a7fcbdc0fd3a3783d21aa6d57838a2c37bfbc989ed947789a74524a2da4b3f2af4dd1902910949dddba81ba9bf060fa9e64b07b0cc28f27a0e97b01f8716a8be0c8fb73d6cae72385b03252770470ed31bd5cdaa64d7e2947cfc553da5d8b8690013506dbad87bb1404efec605cdb962f235a1b6404f4c5c8a1c7c909b713e0daab4dd368c00b6d4804485280f3cbafa965db2b60ed8ac014671cd5dbb89095ee817d75ebbb6602f417759d457e0ea19ca6273a2801b78f10aaa4f43c021c644e6848547d1ec1289afaecbecb7e0456c6b39967a552a50e8a4ba9f8797c32c414941ca22c41988b816e05f322384519bdc5ce1635571e390ed66924d3642f83d75161199fbbce42d965331bd577f1da65a19017c11cd440cd0f462cd466b30febfc3eef89b3a6c6ec841e13e8a821ce0c16e38f4e6eea30c38a3f497e66199cbe27838fb9f65d1b168d4a4cc36521af6737bc6a9e70701120e156f325a2879204b3735b20ef6efd6f2e16d8809353f3f61d7b25fbf919dbce28b5cfb449a0f1918eb7eb870f85b160d2da3aea7526105d859f3edcc92e4fda25e630581f0d5cc15860f867f04e4f5f6f6489c8bf7e9a619253b47ec5ac200f377c51074a92624cf5875c32959dfa96fb1acc7526a460565390efcb37b3ec3209a9794730ccb82cc3b5ffdf2a05c6449b44f323ef56dac5e9c6aff7eeb96b249d330d89da010a72cd347021a0749b7fc846c18ba8cae25baa062a29a51e3128b7ef3eff96637cb8bade22a9723ed7978334191dd0ad587c539cf7fa5a2b560e94a7470e9a1b76d48747d6a4806a4604510c2ab017bce44415d49aceca1281b63a9c17ed5d766c9e72fe1a1add74841f881d595eaff635cad6ee6d171afe832923f9e3f11763d303dcbc60c7c62afb1303a809d5ddec006ec833af8b2437492753fb8be38e4bb0095f8e1ffc60f365b1531a6c4a797c75f2cfe54f8ab9a4eda49888bd0bd18a44322d94354b7b643311546f09befa1f32b3043a465f0f3fddf94c6120d71f321e52fbe82ecabb779c5e6aba7ed6e227ba6f498b22db53c22970ca0323731b927a2a8b5436891372bf4209bd645a882daf9390f30d916b1c7056c7e86904cb1d27d8fe06e4c38e5e3fffe39331cc17b470b8de2bc7986b7c8a159ad4c68b8f6c1d7da02f5037c9030459c44c57ef75411cb0b987b7335838d3dfa52469d40adfe99f8548fe5998ac2041e35617ed8461a666d591ea946ccd5a6c9f782ee0a1c472936524b514553a17e6a0000407ccf5de2c8fa06d10408ccd1bda3fe2f38fd5893ec70fe6ce231a4498545373bb2d08d19884930d24c54089256aa49088a0296c4edda47f1c83b201b9cfd0bd95ffcb25349afab24a902e86b5b24f4fa1192fa8397377292ae9b5a923b1f00b0320952bb576cc3871540da9385c1964e6f65c2cdfa1fa889e4538088599ba221a57370bcd8ce1610aeccbdc60e4952dd3a7c96886b0af3f3e4a2b3e5c51d59632ac0150bd7ae688f51450f4cd415cabac918852a13dce430f98bace314e29baa389fdbad64b822e16b5db1384bf8adaa61dcc824467e6ffe3a3f3909d1479e66e43e5966a36bf7aaa18c9a3107da85694d988b2296dbd16d12ac4196054b98012a09b3430c9260b32250615dffd5504efff1d610d0e18eeab1e95bf1a677ecc65f0ffcd0b7881afe4794ed83da6878988343cf23cd4e07c8596b81d4d2759e38ff70feb56c8bfe595333eed1018fae52b1f46bfe76dd3c1e15830a8ff55dfd073ed39f10ff1e831e6cd203f0cbee492d734c7ceed3aa56c71e1f9d9a8c906761c847ea838611697c0b60fdd9e9a7e974885c0608ec5822702607d1ae8d818f99c4e61dcba1afc427ba08ae0838669b96c91b1042cc11fd811fb81efa3ed05ffc685083c73655be867e7855d22a0d10c41c12ff39d593fbe7cad02fb8a64292c97ee282f5150dd6c7d943f17a88b34d0a24698130c56bd2768d3113ac9a9b176f61b532da6574484dc2a87ce79a8586f91562e367a5406494869e9b06d51f0813339ffdc70e617b41a6b07aed7d5d0c4f5b1379e21b172e6d0a1b230b37265413169d41cc7d37adcd9d844f315cf8bdaa8c127c89b88e567fc8bdb7420094cd929cd82f64aed26b08e57e5ee2ceca4419c91dcfd24bed1707f9d690b233b596fd1517b9a1aefc2eac97d5f1a5fde025b5c5fdedb0cd22a155529a48f733167eff6369fa749df43f62b8ff7514ea23f13ea9e924605f1c618dc3c198fdf2c09cf499b8d3f821cc21e721e7d7305eb1a924a3a82ea0b5bd1c7d5daf5ea60c6c881c73f052f8473c82f4a16866f88cd97b2b6901ccc01c19e1bcf53bf397dfea4c7cf59f818e623a31c8fcc9a97c790dc31e1b6972a439c6c0126d633a1864186cb587691e63422df7ae302b3533639a0a47a0559709ba954bc79e70f0725bde7fb7cffff89cffacecbb26c1b0b84fd32fcbae245649dc18a57bd0086d12e8da86b6aabfd4a5d6dce4c4390aed60dc076d4f0dd42799e588d886dfc47d528b4c8a5f96e61669afab46b519bc2f488669c686f6815b2b55ba40925e7a8bf3ba4fb9d496a7d41e8344de9a8957468319ddcaf14e69e97110a5d0a1c335dff60f1594a5491c2b2e6b51a5d221490f6a26ebdb23fd67b56d735cd9cf6d84a396e8a093851127c82f05c07f9c6117af358aa607563a4291990097cb0f7a7f5d9de18cbfeac6efa608f7bfb10efdef0ee062711f3143bc51001cdd0efe841dbd424c6792906d78c22174811c0d8d86949c9d45be9bf01009f6de8486a9f7e82636a82d3c2b28f9107c20aac62adafc9bc3381088d0a9ed87e6b248f82cd976489cd021b4dcb26dff161b87b71669acc7640676cd5a970d43beb0b272381a3bb702e932e65f639bf16766f05b33282648d796dcba22f8343b95969b0f3b591348722e88f06f9ceb935eefb5fa30f664e280504952f62d72140e33fd00a5ab9aeef4d7b962af6fecaa7e6e318c96b769eb56aafe5564bd479d66327f79cd6eaaa0f6e6463e840ea4676090bcbe19b1a54e497877965b10193de8283ac023b0a2482e6be787fd781f17116ce72055942619df1d42343dd071c9fc46d2de45bfc027dbddb8b0fc52d71989679eeb96b1f6fcb21c470e4d992d0516f5f8592a70baa818d8e34b462e268391134c97ec0530c1d404a2ec4cf8d57c796bd1a80478491c6863f46c519d3d2d8f4efee2432e7e3435a6522a1daeb27ea4dcb6d0b94beac227c560c6ffbeb57f71c8b96ed342019e027953198ed098a4bd24a5a8644d26985d6c023275f51374a14254756c407a8afb76dd229447c693ab6f91f5e4aaf7572d7c16d20b655a7aec97e87c21dba0466c51ce67906b84a72a16881394efc1d1604548e48fbf5f45f6faf3806df699a9f1257b8bf912dda717f53052d8fc7c5e082fa89d228f0d17d1b677020e8a3b30a9c3c1cc0c226495c15961741523ff91a37d499eb51b4be0a33a4adfdd30fb621ce13e1970e68d22faacbc1eccb63ab91c26cabd398bc7fb765f4ea3e9539a7a69d2acc2fcae3e27d50f7c8f377b99677b0cd2a38c0d35d763f10ea439b5a06e243a46826c9c7e0b4b558d007334ce18ba84308a90b936ca9a97924ad406404172d07e9b9002ace044422c37e3449a69eb51c35f1fadffdba2453b5840d4f64a99d7a30fe7ececa93eed784af4cfea7f564a27f6c1dedd70fa9d61a81c1bf08ec7b57ec8e947c227c74da9b588c511ecb467b8e93770c2beab4d5c67ef42fc4089679152ddd8fc164c29be06a11a8d65a6b532fe4d97d1998f7cd5a8ff7212ba3ec9c3a5ec134ec05a07f6a0841ea95f5890882b506dd53b55e729c9744396b4e45652c6f420432fdb8b0be36e38acbf5be8989f858ca989aecadba207bda9ef11bbebdf36bf81648c7e18b7eb28bea174f7633481170eac83deaf84596a7d9606190fcd06d5eba830778a04563417aec3e06c41ccd157ffe1432b621a18389986992160593a78af491e7ac50908ed68ce7705607da5f4589e31a7578f72dee1a745d9fe5a3b8341783f2a437d66e955270f98923bb4592b94bc15bf74bf5f1913b810097eaeeee5a5504bd1353eac7f357cd531de957bc343e2ed9315b6450951d85a927f89fa6dbb9521e292148c458ead00ed092fd941d8ec435fbfeeddfbe03257b91aeabe7349e08f3004293a48f8784ab01db49e42a1b0f5018fcdcf8de1afdf3bad7d40a44c9eec0a78521a7cdc1a6af9e1f8a9ef37bd65394be47a9ad1643a5c8c5542e661e18a4f3ae86dcb5db5b428043a6822d292465d525319fc9b4036809693b76557a2dafd8a0b3593d2db266cbe80d7bc553f73d406ead2cd3ab7c2e710e4716dabfe0128ed613e945f1b885aafb5740aeef9794a2f6bb0452aa73abab4e6faa0a53fc12fd0406245fe551a4708b3762c3e25fcb72c1aba05933906de66e0958c50387e06f21a7cfd2b6d1abc6411aafe991e22dd673b2e932135b3e6bcd7b5616f406ca4ebb7cb192f065ed3aa6d0eb6960b143b8027f7536e735f09f6eb2e133385beace84daed95143d73b37ca67d37112662cd9da08fd6c440d6a483025734eaad469c408590db95f9bd0bd03aa8b27ac39321643734aa59c266e4e8bff295cc1bd6208615f8569f5c01e5d00784589bf8cd2040a29445f43f2b82a9c640c1361d3bcace1b90f949456a449b97c9cb5bed983fefda2037344a6e3d0cf28292acad06a717bda77897a4f594abd443aaa1c303bf8ed16d19e26b1a0db6e1948ecb1ede7b406393ee17c089913adbef0abacc5984f67584e0644ad5372da494b03aef70b1a7817b0cf487bdfc118eb50879607b9b4b498e929ae0fcf7c21650efd46b38a96b16697f26e51334e4ee73aa69e88ef32731b6775cbc43acc18f515a783a5d168370449040f2d0bfd170c5a6177a3ecfc00ec61f9c535a2115d4ab816d4df5e57dabd80a5c7d8ab21110dd47e92e3734085d6494c38e7de3624e016925bd0fc85822ff2ec32b13f0d90740d26ae5cdccfc47d17a06312c887960fb732f57cf32359644a56e5bfd63544ee43dc650946ffa3f661701e1dcaede51b049b08da632f4af5552da1f778c9c5ce96c8b5dce3097e4a0e51213d7823dc74a7fca11e54aaf4a83b143b923607d82639fd6e7cbd510186ae69095d22be01957e440c4c36ec7f98b46765688c3b9c56b898c70b6d4c7575247cbaf4bce75bda47f11c3042afa481ecc7447e336d36f2d5c67be828b69de6d6e49841db7dad8635a113735d5b240ec8d544490c5897a146768e00a243836c5b1292ca7d5e9fd018760261d385f895a141efc024aa1d8b1c58c556b42aa16fd121a8388773720843bf939dcaf28f6935ca4c59a8702c0402c7b27e71ba67596ec634cabde2b1f21ea77a843051c80891dba218f0582e4511be9cb76673eb08ee29e7cc19b4e52a92951af5cb7f22cd09f38d82995aaa03d5af2c0d54d47f9b80ff0b978cedb1a2ae6eb279ef30afe3561869f2546323e91c621892f3475e32b0f747935397458af28d8dc69516be1445e909b83f7958d30a6208a34f2ff27936d30d28565f3239eda0cf732c125618c7d06dd4a799044606e3128730c84c768f24d580089e8b4426f2aa1de7266d0c93eaa132fcad68e90285a7c652d6cf2dc8e3c4f3fb20cabb52bd8aefadd176332bb9d3bb7531a928206f908acb882f4af51236f2b819f06838b1532b2a057eb408bd6903fc0608fb08850915c5dca633d066b651bf2b4f46bd820fef51cb0930ad4351351a11bddfc29c3b6c45db36bc84104863c86a28ecd67748f0fdd4a27612dc07b62eee5cf22cc94e9b850ffba6e39e45aa71f12bf4eb46986e204b812e47d01ece1d441ab251241096caa44b79832ffa1bd3c901a9152bde604aa473438d90af91add6e7f1f277e39f95c46ffc193a117501c106d55c465114e02ae4da77b96d61089aca9194d602503a71b33d22c58c218ecd6c87837ce8ead34db8035d115cdf4289ac190147922d5a63c28e33bb4488b52982e3f799accd737623e76ed537a7b14b9bbf664ba2dde606397028870825aa1bc2ed35308472e2a3cf1f6c182532c20163aafd878228233f75b2b7ec0772253d2b344113fff14191ae0650f65d7d2105f4e184782d70f90491e4ae849c9a717b403d5d6a924f62edb8df539eb96740793b523fdbeb1b9ba986694d2a74d3bf7491a8620797725d5ae05f475707c6481d10c9f5e39de17f7ff53a3e547d5bff1030eb28410c5efd244be959bd27a6c88d9a8f299516d603856933880611574daabb9dfd040f5e63d89c25a2e9903e7b7940839b7452139ac11cc60317afeb7008a7115e47d5d4a0fec06884b38e93b7f41d2ee9c5a878c5b99a5121986349b9c4e4e5389938d7cbc5a164273ed6bdd4d0a58ff81c6d0778828acfb7f224a18f03ff6849b55ba4be8e23c7180688435dbe7d9266327c4cfd7b78a1bc3e076464612fa398272fd8ebe7efbe6b324a041158e221295e43c937fc63bb7be2f9aee7ecf5134b1976a506d062c3594ae307d2cce1ea9b13be0c0fd97497c3f8ff443e729ca39cbf844b0a3671bb93580aa860f01cc0a49e8c1c0fbfa98854f28096f8e814033b49c6b47c20e1b4fa6873d415a713a02a7ba3590009d4529c8615a26ab0fdd519749471dee3efbe850d99b9503aaebac2725967fea85f429b57cf4bc757a58408ebc6325fb696e6cbc63ca874224eaddce15c5e557e5c2a8bba22110d87b4faa942147cfb3f1d3d69ed0c9ab3a5a02ead148655012227970ba11a97cadf2443d1b9ba95aedc2c45fe1b84a323d63a55519b78720315b66a6c24741b896c06c0fe2fbd6dca7a23b438a77a1cb91c30550577e7c8c9e582eb8dcd0ed641cde9af22590e3e4b1714e1c40d0d17637011b8abb19a40865518232c19db46099d06fdb5810373c7ffc632d5ba3edf973902f661b0c8f9fe09fe19a4c24889f2d0da9b7a265629bb2242b412633f4bfa8db05c1596879c0b9150de23f0de340688c5595929099a82944d261c2e0f5862b66e198a142f9b15eb058db020063d34eff32b59663e4f83474bdeb189fa6cb31f2948d27420ae6ae605afa434bfd061002a131d647d444b72abbc4f9cb54edf980f098d40b92b844ee6633a3ec6332baf3b0cfd4360c120dede1249c1fe58b98535fb437eb401ed2503f8923cde8f9d572136de852915b9d2d80a580b0818c2a142fc99a4fd8a983a726498e3e7368d1728c40ba155214bf1be8cca121105063d036321f9a7231d1686526114b93ec3a3a418c9eb3bead7e1718090d09f42a0b9c968f83c228ff23d7646ba84911c2c100bf79e04feeab572906cd08e0cd3474559caddc6789df83b9e7940a04e77c74aa9dec5b5e92510e0b20464e9656a93e75e0c4acd647a6892409c30edea51ce295e1ec9d057927aabff88bb48b4fdc1702220ce16398834676f337497d536030b438c1f3d48f372f84fab3f6e8d72221972ef396d0e792302464c77dc57d1660c9c350056ffaf05e36f8cfea025e4a98ff810687940f682c80a3be4801d512ee7923d6b32007c29952d92d0d09c686fe537cb8ac965180106042e3627faa8d5150a2d50db3420242a8726fae2ae25af5bf055510c1e91dddd6c381d94bd83a47aab801999b43ffe7c06e628960bcd953d2d8d5ccf089c9617bfb494b136f83a0cdfe20f0895fd6ace3518b833c526394806c93be0f6207541377849a8c9a57cfe61f3ba36612d22f08ec914ac0f36d24d95cda9c7ca7c217582b4ffc0390c7f3f66dfb653f3e0972b08e3354508821436c8849995baa14f91af0c7acd5744dc65d687fb0208ebe07d4860e12cc11de9134c1e08cbc5e5b1a265302c5d8ec1056490613149aeeb947830f04ebb087ede2b4e1be11faf4ea3d350823d861071f03bfa4e5f89747d8faf7e2277c0ea6ec6a82ebdcb27df72b8cbee786fc67dafd059f89aafe989f1533e9fd18f6b5751fb12c024526c6682c98621796a17e29ff0c022d7ae309bcf78fab28685032235325d578b2038f18de60ef58d3e0c0713b6b89ed192d462d92085b5e4ce6fead8e119d941029b6e23f2820cfc76f9845196237b30b7bd889c85f6ef31c220f8a6892542746eecdc1acc464370395e96c658fcf3b68adaa8e48a1941a97c569747015923461df463bc51749dd4d9dd2ef628643a5ada91e6f813c24c413dd6c8a73118d4dafa21fb383f6f20d2d0f6f04bfe1396e0ff42ef163eaed92172c5699d252fe18ffcf007ffce6b41a2d99def548d6d14a643129689ecba5770e2bc98bfb54ec626d5a95789b825c21c52a010427f2b55e00b66f38aaaf49f970f3550e1650456048e46d1b255c93d2daa42117c1953d7c44aca3ea1252f4cbe8e6cc822b6d5134f2ae2282da6ac8ea81a290f2cbec60bdfab753e8c1c4ea46e7eee0a8f270aacf735a7a2abc331f162423dfc67bdc0856ea163b994df615f7759c160bdbc567712e63de68e8463aa9ba12715a2153e579e419ffd51edfafa9ce93b214e29ccb6e650f20b41adb2a198e8e66896cf2b14a9951c63f7e00b1c89c0128df10f4b2ae6bcc40232ad762dee9f4b00a8a3d7ce93d41787273192424b3a6c48e3e9499b8910c664d708be5a7f6680cc7a23951035ca6fb263a63c6cd5abfa536892ee15b18369f4feeca0a5e230b8e925ad2a0ad61bf6ae75dc3ef9022ef48a635787a880d82b66f9b646b0a4a1daef762c4c89879234b6208d0fe9b1ef1f8e69448979cf815b1bee9e840273c63db96e9711a0674ac605400462337c7ab09029944d6cb83a1cdafec0d960485bcfb04e886207eef42a2de8289be04b95ad6a24ef4ca7c25a6c226c9a26934ea88addb86dd735e6c520fa84ba62a87bcc1a15c6a5017f4a3f921288de5d1863d4c1caa9508492b1847a86466554efde284c791defab9cd03ed633188b9b3a8628d716f0de913079f8225fd3e4b180fbdd78953f1a0fa6149c65063ceade18f3ce7bcb92e2a0298846bc700e08ea92885247a266027443f9177b7f6c8a99e85123294cd027c2bbe112494b99ca2b84e3bddac9f36faec1b2e12051a640db48b31278137d9760d5165b41374f3a08ba8758448e2e83824849db29eedbe3b6550ef29ce3c25dc68e9e4bc99a7cfa61df867874b7d3665bc92fe68f94a48f15e78ebc30a2ee1a5447f7dbca8f4aec927d6203df28797505b37d1ff8c152f75e1a62853b962c3c3d70a002c2c1e2d30aa3bf0b326738dd14cb4bdaa2d89c42277ae50281b4472db323eff5b9a3e76c02203760c9543a5aee2ac988548010f38a01ebd8709eae08ca63ee8efab5d11f2fd6f5c73dc4bee8758e8fabc4e4f48b238c6156f8e244dcd5b4d26f35cf684a5a54bb19bbb7e7ffe7567a9ee91e43314570594673e322269bd6b09c67fb125136f52d4a906eafdeaf12a58e9df997943a66fc0cb7d660164a6f10de99252076afc58768f79ad83a3b526117174a272d4d64594ebcdbd92ab22c2ec499c56c2c8945712570bc90924a65f0976095a9f9170b349a561661566fa739de7e421cdb22f17f15a454aa744ad53bede32c284470e287be75f16673b12076656acce98932d057a31c5262fafe3802758ebd60b8c68dbbab361de390da128f869a83214a56d16feec526dc390c7993a7fe9566822696a38e98613bd20db8d01a3c37f7c1a9b60f5121839da4b23225d9d3a26bf4ca97f10b7459a286750bf5084f07e2e7fd2eb79546e80d400eb669fa59add0a1e63d5473aefeeddabcd11ed55eea6f543eb7f62af4f7de601bbdc79c36b1af41c2a13bcd8a324a6c7fab58558bb0833a98737e36383b2ec2fb2cd11e813278bd7f5fd33bc32fe0da0df78b284eb67bb43aa178f1c2d0e8d267d6e5004e3a8ffd1ca25547bb5609f8e18d9b2ff4703ed033d5ce53b85c8edc35d2de524dbf39f3dbdb1bd328ddc4074b6563592772bad56c8475e01685b06e1ed693fa862c9b51525d3283b9c31690b69d47c81a47e38a30315f4323adfcda7924a93ff760dd86a5f6b428298ffbe4fdf4cd629b613ee5d73f6914e1563d25f641361c85c5909d4a47e15d0e4e53362b7a14b5dfea4efb65a441cc1a07d83b1e1b7015926e20e06522717ed3dacfb8cbe632e8549927cc722aa9c94e9db0d5e7191b6cffbe7b314ca6ef5974ac13286eb8185a74d8665b682c2ae0c456bd93c11abe2895897569a1b4accf501a7448ae4c101a374cbdb7e21077eec9494f72550228e85bac873bda2c8dc212dc8a636ac51cfb7bd5ef2ad62b26f53f407652e76ec083fdfb8b9e1df73f6b9da72d4ff06c18a28c4ed50d8c8da3bb0cfa2a2076da54b4fd04d267e0368ac7305bd57390628dd8e30421ddd60427f00d99a6e0f233abb74c94f819526cee7c29861240db6bb8291e045320885d61df472c86546638b743f0e9b10d9609a25dbc9d30d33bdfc8cb8bc5973b102b1f9e7741622ff975d7a6939c68850b92367e825ed4649624b865a79c76b0f930571cffdbb52f9449ec3b3d0dae281d3f9aa36f9c7bfa0fdc2734411e45093987e074a945627889496237be118d0daf6045b2503ccf35cf0730407dd79221cf0d1420d4d97d5edb83d445d303cf389722fe965eb6d925b990929afbd2e1cbe826c035f89e9c6feda3dc71084ba14ac5e5f36c5b08c343374bcecd5b463877749b46b053cded43ad2e1dd5968719a7aeb9ebe984909654a3b854a8639819988c5fb4d0b5de0528616a2043cfd5f3273113d802919b00de35321a2048efebf2d0adffa89f9d635e7b2fd2d8cdf5d4bcf064ed6a15a30e643ed374c64e44537a5747cff3c0353674234fb9e144201d4a8cb5d0ee8cafc1147c706253c77eb2b46ae87a860576296aba643b41803796097d392dbf1c71e6298929c404e394134d4778e501577ad17d4b0352807dfe00870a8b299f74e9a5d966d9f5dbea7312fbbe06a4de1b8845f6a1b49ac860569d78630b05734687fe756ab87219d495877568c60af40bc79fe2933e717d710937ba02b8b7f9706a3f092c3ae8dad8c702fa27e20803d30bce380e5fbe0ed2f14729232550ffc61f03b2a649a78bffb687023e9779feeb837ef51c3c1a7fd7aeb9444f753a381d757a1c5111f9ff04fd974aa4fdb1b10e920f7d8145dd84a86e7044c10cabdace4f5a3546b207da8141e01840f7059f1f4a10ceb718fe26c33783affa862b19175c08b50697106a1bb54b68e2d761d17a64a50cbec76a61b0a55ad9bb0d1bc4f0583b680c1aae5c4d7192c7ad7f1c4d4a6ac2de4d0badf4fcc50e25cd6e825317bf08e5b9542adc95a9c15bde6c4e9ac7d024f5a1c8ffd70baa7135d4d8ee30a9caa7516d9969325c6007ceae8aa825ea1d179001fc4fb8cca4c5cac69ec4ba226aa190ca58dae1baf4f8e01f5447666103aa51239fb98f5e59bc5a192cbeb6a5ddd2553a0061898f9171d0f56c86f0112293a4ba730c5981647298b66b495ee6a59f6ac48981fb0dbd485de498842a79f4a26c9c45c2779df50607ec996b85b0e05bb168b7c8ded5d770a96e2da9f4a9d1010515622b3922b5590970f48ee133af51496f7227a475f2a3daec7f0196f1f2846906eaa18bf83be6d437a50b0477b24c739946061d5b5b8db342dbaf966ff665e3456f865fc9b457059e3584a2a8f1c7dbcfff8e70982e0ef4c6e0c7ceb3e0e041251212373f12ed850da7ec872536a428eab5ac43af4d2e03a05f1c8dad272a1425ab08b5d7d8a327b47f3e79a6747088e3c2d09c74d39eab08b5695a81106a3e7860c1cc810e69a73f4ff9da32c989fd272c775f8b89ec98cf81607cb6f78984f17ececb18a6a4dbe5df8f6dfdd0742d867fd454bddfee95043151b253d2ac6294f904a2f1c55771ba7cc5b68aec2b31a6edca08d01395cdb4593b7bccad62c22c876f80f41dc80e9eded5c42a288f19c7e01cfa24dd1bb7326e1a1a44e5f56300f3cae8fcbd6c668085210fbb235af2cda373291732b10c64c9b0aafc3b7b4b3cca8d1cf23dd97016172f7b0885365409070f44ec183aa174ed80343fea1735ffc5020a4bac4b77c7a7dc2b68e8685eed46166005b42acc90fee65e76e144d18451906e5bde29f95a28945a587432142f5a8fb588294b715cd73755d561352d95a3cd645813a50ee166dfb3334a7b75a4c9fda6b2353a512579951a59db8130f86835e72287b92d022ea0e4a4f16215ac94dc7651d0e74186567e79e44d96dfbaf1b8207e9ee66e1ace0852b035097a607afc941a0eb9db7584332f590b935efcc6c76f22af00e2f973878ff99c002f540c16167e7480ccf3b50988c909ae4336a557bb1acd9a871a441b03402822641405cfac085dab7dc5d6d40b28cc87a84196c39c57db28372b272568a189d8c76755830812330101966edb52c48e57d288f0356c6bc9399963454a75a0fb76fd7a8480eafbe798a864d6dabb39a1106cc43585e67468d17e972a71809dbe0a2eb6a0d0023aaf1ba2692968facaa8cdf9b9658c505906fa707496e33326bfc00e8d30aa6040268a04aacc9af430927afc84c2d6ed3a533e67e30bbcb13817c6712409cf4c5a7342ed506235bd64bd4138b68c52df96136ccad1b20aab3bc71049f8f6a30ebc79f30ffa07a7eb3b1a285f23607b2161de6c335ab8d370edfa7dbb03f66bead16407312e8520989300911ffec56d4ea92a134e998592726602c83c97e4f4ff5c3a459af0a64a58cbd23d94081e30200ea537a2438755b297d49ef9b853d91df4a1e6b7e13c122f753a79a9ab831441a91d241e357acedbc25aa86b69a0b062d4d2bac8b45f52d56798d1eb3bb8e3c76ba45aad89be680bb5ff6cc7a7a4aacedd9422d171391f5b5a88bb10f407cea77bff694ca23a836f49042d216d5114c966f5dc2d1128c7eca84293ffe1c4fb2d4ca14d5b8119dc3fa0e24273dfe3efb47e94ffcc93978875524a70770b824b879bd2b480504fd3b05950689634ef88b8f8c318797179968d36cdef08dc43da26e2b3990f41e2a38b268497c7c80cb432f757c5fb45f67ab8acb5aec0030f245a6dcb14d27ac91bf88c31349b6f734de0c9362757d8f42fd8e7eb3203f6e8e7f641c415cbc214ddc54305d661ce6cf46d0a22fedcdffa59d21e834e1ce73f0f422b90ca4ccd9f7fb3461e45db0b32d31c8f8861627246929481770735a8225ebe3d65718cfc6638b667d20bfc9ddf56c470e1841289a309003fb32740bb46925d244fbed99b612e1ec7cac95a3359c7e32ced2eaf3e03ee29efce775196deb04b0f46c83513e5b532f969245532f5b53de226fd87d709fc408f58c875c976350dbf64805402c18534fb21eebfd552cd2f12b22d832a05868013b6aa8e04eddf4f5e1e427ccdb94e7e5db8243d282c1b5799adb6c4084954b2fbbc46af6e725da64acf84dd0e5bae5a1ab3010c5848c82c4d5da0e558dc6c1fd870fe7c13c76bc327d9a7c941c9a21771ff78e37bc6c21ab5ae8d0071bca2ab662069ca6712575ea1efa1bf8d8a8f516e56ccb71530e6fef3700454de18fe9f0ae0e03fa09eb520e2dbf1c77310e3fa4fdaa664be6ebbdbba9e504910b29a842d58603a8f06256ce4d4c034ca906581655af539e9c8f9f8c99d36fccddb5f5390c8d22a50c264b9bbdbc777ac4e479a2e057dd17dd00cd1e181bd663d9cdf279249df0dde0a4a2749fe7ae73f52fd60c5083ae1ad3d2e28fd4a97078e0fe40ff93978c4fdd0ebf0fae456989a81059466cd731eb89a817c9eb2016df54b5bfadc7b70ce28de028027825de456124f9a415f1fa555929edb81acb2c3258c33abb787ac630943b8ccd372caca56ca18a4fa0d63ecc5e763f1ce147f8845d8f1171b73e0f6a9351fcc10e6324b2f3a29905d338db9155bde79c279c32562c4ea90de5a5b09a2fcb246ffddd45161a2f70fc580092618eb5bbe5401b31bc033f1013a6f623c93818038b4722495337f53383ca7d894578520227992d298253946bd05da2459e6d0fce8586827a66653e669db2bcb3866ced032a6777b8c305770901389e47f0b18755356ccc398bcc704f3f366562a502bbf66b9bbf2bef06e3cd880a9679e5f0fbb035628b90acabd08ca29e70341bdf1c90d34826fbdda96768c7c648f734abb3b3787bd45c717b32ab4f33a8fb57e6b87735bfec898c50bdad1b1a60b56cf50a8b157cf6d76154373629fed3f9589ab23d26c1f75c6fc5493d5ababef7189a81d5d5193e49c9a0971e4a9d5892a25b3624c428f4f6086a78990bfe32a1a8d47e29f50e9c9e8b4b748f7edff050c537c89af9a38c45d70e6c48059d5bada2463aa0977557dda1bb1a2948fdb993e426952ec816a0d8c0f8e7133b47b9c72dab14055aba205624af25364190dd5d76e30ec323a58b88e2521fdc4a04b0e35675b8841ac7c29397c35a2236c087cb6cd429f980d6fd543e58f1526f9db068e1c3666e044b2632c86c447f1a821747102db8a95fc6a059bb00539593f89faae05b49ec0866032b7dcea3c2dc8f5d6079e52b271ae8a8efabec54759fb57a0eb8b5a5d4c6d95392e62b5614c28ee56f5a725a10fdd9db88998187da9356704756b88d974eba57ad7d997ce5652a632762c95cf54464c4c5b7728f0d5b9d0c11162d6693ce6a437b6996aa1e7eb44a4fad0ec3cf5a23b62defb9064f8e1f9885f7cc9861c40bb509c97c1f4dc8a81f656aa912d18beb6fb9d5cc212feb2829b66d9b1b657d794a1e1623f7db51b894b6a4ffb0bcf33f0a735eac56d875d59038af796387ca608a2c33b74bd3c8a2f0ad36c88d0d4ae601dcd5c443cd52579b6e02b6b1262c26f0bc570610b51c7ffa237302b73ed9a2c11617020860c9236fc84d1b18f04b137a7079bc55c4c1ae6c69dc15eaef0b708588bea041b73e6229c7ac21c5841ab109cc7c41187abc6e4127b30141eea25c7e2e387c7d2c99c46f33a6d801042a8473c0af840c71cc3b677e5b6c5acedd1d583dce64da1908ad03f18a5c6ca4d504ac72f2befa8f5f201b7ea7836f56b910b1a97be60b872c4bb2a0bbe213f7171398fc045e80266d9c6e1df18f57f1a433106eb8c620f00eeae46c37887fd34d7514849b428e6055de2e072ce4ecb4aed03972a66f695c80f8df93642bb799aebdcc3ab2e55f2daad8bf4a18f4195d8ef7a01d5453340fcc001671c515efa7a896cff436b94c6fc3aa9f10ceb1f54ccc7bfe201778da541e14669f71be1098c24a7331dbfeb915ae47418ce688306600a37541d94274b6eba43ef7f0079c1850be3215190327d74af2267d7c08f4f50632ab62ff22d51c97cac777df80776dabce5fb1afd4d89fddc1bd981b86f0b932cd5c10fef1eb2bb9192515333189dc6e9a57cb1c47391fe612c4411ce69ccc3b89d85ed44c4f0e48cca6323d5f3f620ba73dd72e44a852cbdd282d2bbce321a73308f7354bc58137b705f525426183a7e8a362163413d821292253674cdb6d50a0e67c0a3ac80aa0b4634b82cd2fde41d3e14b5c9160b582ad94a3441ef76e77459678ca91cbdea7ddb4acbb95eee35866b5c56fee9abce558fc6d26841ea8cda82f2d033f818bfc95ad40cda3518c8c73ab6a53716effec27fb45cf86d17d80930531263ef1d39cf5da9559347346db9913c560ce504f8f4dafc232f16034094cce01bc8feb4d0a44c63decd652e0bcc11b62e51e833089a60d64ee547d46c0c8afff8124c5eeba473689613560cf81f0e51f994ff1b49d298df6f4c70193eb52a5ad08d6bfbf9dd11b3d63690ef0a01399d31d575ef76247c0823963c9c2d420a29cbc1c779507cb009ef50d4f4faddf9822da1c6ac9f30861738936dabe7399a6dee908d9ec11d7945ef32616e7f9a76cab332e4da50ae364faf78893eef72ee3032f857324d90ed069522ed6c8b434d85ece1e2b2d9d3d722b18789ba7a882ba979cfee2bcdd5427f7e7799b9b27fc648314741f8197f4ae4bce1f1937da5fc31fe93d6bf72bf35eafb62e7de218a12d19ac97a182122e343a3e8787ee6a89f97121f6669f54b4ca1539c40080e362a046b3ae3c491e6e2b0da9ceacbbd789d991c71937804ac6c71a3eeb45f513c5d78e9c00d7d3f05bee80069ab8e08ffe09f25ba34ad23126ee09251e4e427bbf1584b44eb99d2304db50d228cf84d92aae55918bb76e2265b0acc1939301d359f9de871f422e54a8d9340f61dc0bfba362dac995482e3cede176cefd069930233f1b12cbb242965e3dfca522470a7c7c13871a093c6fb98db00f62f85704102ec8b9af4f09fecebf2f26af78c56fc165eec74daf1bf100a8f2bff0a6653e26d578c79bd3622c0e9148acff52bf6059eb467128619fc6ebf6b89a394289bbf78fbc8585bcfb990085be2335e95e716a62112bc29b795d9042ca6aae5d1972a548a3b324401303c457f19800f29240ea87b33c1a43ebb6297c4d0cc60e344b8170e3303dc1fd467a5acf51552a0dc28352bb3bfccb4c5ab471a3705dcb66bcea00a9ac1f8149094a902f503aac322acf08f9412760f632a9e5d0072d37e8a77a1330b0c628a72877879b10ede4fd77098521d593d961ee205a8094b6986abff8f0a6a9ac061b27cc6b1e367ade5dd4b773a7e9c76e4196ab8f734afab2954a5584b25e5f45215f2b91a1a16bda2f58ba6191c3ad15f93381e9a46e7c5c3a5d17887c01bf38a905343b8682f3a14728646c3ba0e55becb2b834def175151fc1be3717d2b97a96b4fd40e78052f1d3bd99f1ef1a244bc51f4f4ca027de9ec14b60e3d2dba404473702ec22da168f5e355a86a8382fa2d00db1fb6827dbd92540735ef76ab56292f3c7aea3d10a8754acbfe754f82134160284ca58bba4a7558e37c06449ecaf011c6826a6da391f03da0e8409cf9d2fda30063e7015bc7cab65df476a9453571002a9c8400a79d7fbf984eafe7d84198e532dcfeab2a485394cd7967453d2e62fb5535b6e0eb46a10ab726b6ff57f614912e769d17c414b1760890f75403f7a7ca0603ef4a8ddca50995aec6a56de97971e748f0b7a5c07dbf920cab4fa85a32d3bfb3186dc0843ee03184346919338e9895c64be60e948ae37f62d510db333921dd934d5a6ade4d3ee04437c8600abfce0c307121a015c484dc32a2598789e2dd5df4797b9bb7b6338ef9e354116f98175a7a9acb7bfd51a131d4844b31731bec22d458cff4f1c628831db210719cd5ccea12ebf7d0c4d55b0a306ddc4b79fefa1f7db587f40e34edc13a4d6f652ee6999ff6d22f051383da1832ac51ba275b18b4919e8536cfb0d30bc95335c0d5c1ec110fc9b63117897dc6551be1c28f05be7e08a77acfdeeeb1ee87670b72d0c28eebe91d3cae30009982206eeb39ff14180e64d8487cf78aa8948a0052b9bc2d438ae2367e84e4fffd8546f8b6620837923122da87252a70923cad576b1bdf6f8d875c19c3333dd16f8bc899be5a82a1b648094f494e70ec6d1d43fa7ff59dd71d1dcc1ba9a66f37107e63e7a5f2c14548b1b4e8f4054612d790f57b7481429dec107d99270a19e4a06678b09","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
