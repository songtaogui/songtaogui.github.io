<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d8fad49e03ad8b4c1a88be80057f160f28a3fa21277f706084b62c9e02ac59972f5d4bafbe5f01ea735ddc0ca24ed350258e367c58ac22fdddbdca89020039a912303e13dee91619bd5b95d2ec75c95eaf0d0f7151a752955524463247703724d27ca77f88f0054087536d13a3d046d13e93950cca9c423b3df4f0abff9ea9542f6fb6e80e638d4aa2defcafa4bb09b5b0abba372ea3f75559ecfc0b7e600cb419f12ed476a09306453d806401a9015a2a9536d2eb731490cc8eccb4bb9603a83905204a38ebb370552fd52fa1ac06067215927c06c84e6ab861cc1b779c04eb0bf30310a42de753fc863e4219cbe663453f5e2627af7981d394b41e3d23433ad7a41e65baf09fa2a0f3a6a8fa9f513abd5dbd06671c8f9853d28f36e148431241270f6cef064e77cdd2ce3bb6ba30bdf655150bc1c0b043dc9c10b72bac3dbc28bd80df284a4065abd5266ee5dc6beb7eacb2f12850dc8580250fc0aa3d928670f1558a701f4c3d2215e5119bfde8ec19518f8fb643a27072a502db5732e52606624e11d7f87d6aaea9eaa010c4c8fa5addcc33fa0a0f021ad07b414b95c50173cf7227ab6467ffa7f76538231f12ee67cb592aebfc4003b81caf4710e672d46238788c3faad06a1ba3327d4c9e0a365170132f289eda6a779d3993192f7207fd343bd81d0512cc6f789d21f85d2f0c3d28cd1c74fca35018878f47472b9d0ab7e1759cc0540c476584a74c5cd9866c4a2a2f3b358daf37599414b98c884a969ca9ea8c11fc447d03afad71682e7fd35449b1d823aa42278ceb1ec86acbeff4bcf65c37a51c6b0f6f809aae5e74aa8917e98990684b36c7d8ba1e4bcb444e636bd99ebdfca4401fa240456a6efff4a01cc9ee1bbe84c4e7cea8afbd37c70e86a5e26da3b416247a246563e8aba6c791033e75262a091c7db7abf9de75a6c5cc0a9301c2104b0fda62024e9ee5baaea9a4bfe555a1280eeb11683d79534cd26b191f3440833ddc17d845a9bcf797079a6d5e0aa1232184a9ddac125cdc16ae8dadef811acd1522a7b65fa5851935c6ac66dc252310ed3c1075fcf5e052a171c26a83ae58a3c5f384077a7a74feab5e8770e9cd38b01470dbcbc9b26bc8d3742031082ea4985f4f3fd92885c2deefdf82ced5f1cd62c46df7b6ee2521ea910bd336f4da875775a86f78de5f1b0ed42567a6d00df952ecd87eb73e0c20325936f5864a1f32b474ca5e68eaece467eca80cea767108ac5aafb692421c58af15e512dfe7a20e2abd340257718eb352d445e4f5a5758c93fb3e1ea314935df0db5e292c5d2ecb4d23ad103bf740a2426b32f6863d20e43d304904da0e81b4418edc9670abcd42bac425c2ae0a7ac664104cc4be0f8a260dfbc3e51996a162f709da661b2b12a1f7abaf6f30cbaf2cef9fdfe4dfde3bd4776e9ae4d3ebb1d8de6b1eec2490cc157e57cc5fe81e2c8ef115df45da0d852570405d6c58a3321f0b18eadbdb0194d528d7d2864b327fd7b55c873ace076bb6055c1dc774f0a44d9ce1b6ab5445ca0642b97b8af5906e2a20ea4f4be03717823c90af26b89bb70a8c81d1efdacc271d33da0ed80165cfe159834ddf8f434e36e23b65e96d1d15a6230826bd01d6f094d6965d5620895e2e733c8f62ec5669b252dd4e8d0f01ad4a9da35fff64ff822e412b41273bd2e821d4d06f582a021d010641bd3f41e4a2bc444e7ccbc9c384f3a5185cdd8c7125a419457bed45f53dc30fb0b5d174ab9ba78bc2083acef8097a2ab8ddc728fbbd68b530e832a86a1adcf83488695a57671b9205891eebcf47221b5e6acbd936350ad8327f5907cfccfaca2920e1bd320e56ec9a7fc659fae40fd03dbc21f2bf8d1569890b2de66be51b66af1749dbbad74d9a486a4f4cf2a22070c8143394e4b1d85c8c58c8603f7b77017b6a98e745dd6fbd129796a91937b1df47a7828ea266ddf48a9018e18a44c985f950f5a2aeff7bc7a15804af76cf17d89456452128588afc7ee14f3946dbb641130765e8e81e23f7450e06fe01f583ccb3b633f2825bd9879f3e94c4eea8033d9fd72d9bbd7bed90f6811d19bfcd3c3926a11e36a627d1a0e427bdb09d7de29c53f5a84c0a324fe576427fb4a03997fd0bc296ae7fd168a9f7d0b88a1377208a40c4c9ca1a0681d4fa52860829bda588c7971107de238fb0e31590ef9f2ea35ea9d941e428ff6a395bd96f02f3e81ee3688551eb73baf5bc76c7cb89c8b00f027f3ab94eccedb66a22e707a50442ba4dd43a70964d907bbdccf3bbd3c79b99a5fea1c377d8918c243e0f3b629e697dd8f9bf2c29dfbbde6c0ae7d6e7e5e1cc0d99af299a83eb1d67cd82f0c146c4a7c955e9226283b543e237d2c7901e5a34a4a961c950e1079e0bc86ca0344bda455c2f42c92c65d8df73a297ad40d6477260d56be7fa9778916c3015fda6ff364ed62d34477b780656258aba43d54f742ccd39d9b4e3b7d21e230586c6a63d5680ce4b96afd0467b325dd63b132b5f31ba618d8b5c9aef0ceb8c0849a56cb511d91beca9480a50f856ad195c539c5948c686393216473cd72bdbbd2819686737578ff508ce3258a546ec40c9aeb90708c8c1e4d0f7f1aca22a33f75b0fe3b09f94b119675c5f301d20c9ff5dc4dd03fd98d3141ac36c651770219b63d5c85f1eae446a497a729731829e87bac52d72e6da1e3a8e40311a904b5b60fb0a47dde783e0ddc9207f7d5072c30e5e38c3b6b6e21ab34e9f769fc00c2280dd774a1c262a62262d5d87797b76af19717cfa68312d1bbfce031a7b437f2700d1e3db8215b42c09f055ab55ff8863b33c3c605fc1c9020d5c8b6da36882578c86eac256a65298cddd522408a72785962a9434f34ac592a21a86dfa3d90445838300306e4dc0c20dd2a183fc25d2aaf52f518fc0c908e8b3c660fedf46d651b0e8c8b2e7c73c738e2f91b1542f6f5270a20924ffd957aaba19ec32fe903b3e0a9565632c84ca19f35ce13e2884f2f167a83835e06e9e0b9a93b4e04b3978813a968433b8ae212fca5ab6fc1a041a2c04ef5879522a84cb7f4c25342e087d19fe0e0faeff2df2d096d5b76f24d5fb9212c57d5f50ca785ba39cae3cec2b3617baed95282d406cad7d3f50c3acf6969ba701f14af2e7f91d5bdf6dd7f065e134cd9bc70f867a0acdc5bf317d775edbd0b98c571785af25f54a91235f0cec36353bb42df3da113e5a6398a0b957792034fa4d49cd8d32958e70ebb3a34645fdf1117a2edae44797efb8913aadecfde738e600275b3a63ebf0a238d6f9568a7cce6f4dad337a5bf010771503f9bec904b6111f81da25262147fcc25db243a60ccd9b6a7114c58184730c4b5e8a59499852a4f2a41e8297f6c08603f3e604005858857e7106a1f8c2f83f4d4e4ef052c71f993dc16c2d10adcd91fe177f476b8e0e7752ffeb6150e036ef08c26cb014a9a047506f9b0d56d4a4eb857eedf32ddd98f2900ea548443c56787cd8be79d5f33921e6fe61b82ea438857727d565ed6a5235f6e0e61bbfe88644f0cd4168c0c8febcb00411da5e7d2301fb5188fa9833c989b0e4bd1e47d658db26e35d0b727bcb713af1323190dfb53fbb2e4cd4eea1d070f119374388d54cd55fcce21922e85fafb93f414b077fa60ae5ded3126951327cec0226d6f7034a8604be3090bc49dda33d1620641931451b0ff87df81adc23b4d771c7c1b00c2412cc046c0c622539d74c75f160be3d36e206790371408de76e5b1efd261327b4088f1cb7464b88552811aeab01519f1f9fcd26e030a66435784615958b8cf2417040d848b4b3d88b28bad70618b9481b39fe6fdc5c74aecf5dc626429ce5d8f24aa67417de873c564694aed2583272816bbb556e6eeac66c58f3fe86767537e67ee94e709d9d0ebe6a09a2ca032dda36d1a7369a086905bd7b33cd1beaaa282061f5a1099024f1a4a9bfa7521aa8f4aeb8f09afac3589619917e2e6ed714cb19d92d7b7ce57ed7401e2f154754d545346b1f0cacde9a4632265da6743f4a0eae5a8bad9b0665d60dafee1354edf3faad569f1a0211395489dde6e4158dc0392eae81de08aaa99c1ab1102356547467ba21f8e6a8ffa1bcb60d6c56b635c416ef6ce6386fd9f3bb1eec96c55111da8e14fe87f4cff22f57e394b68b75c49eaaa88db91b133c54b09e03f3db342a8bcc250ca6553cd0f39aa36bb73cb1300e6ee1200f289e663163c5e6435a91533b1f5e20a2e063f23dd7e8d4c0609cac130c5482a12181d4cf81ae5c1f1b3ef5012d7b7debd4fdc6b2e087a1da4cdab33079cfb89e9d002070945def553e142ef6422cfc2baa790c2dc4ea58e652c946bfe2baa6f795ec7da585080e12fa1d9672e5bcfbcd86396771024d25dbb71217c157b78bfd68961c254d2d96b52ac2e82a5ce92bb2b43a08f661b97fb781d9f239acad17122f29af512f53b1b9fa9e5038847bb9591e76f8b9749e044fd2f0f47df4f7abe27cc91bf620a9ad0f165977e476466d2a61142edb253556c6c72b2e7772606865bc7cf7f040b4e0c3955759079d7b6da0348c02f1122eab3e899f211799d3cc9e29983d6cd8af38aab0479778bfd82cac4d2822fd91e76cd10eed1cd6ec532586202896563f1d8b7778ce477b87cd45ec14645ed5133b92b1c982627ecd0100266f4dc08ee6e7329a4725ee585088de27c7b0268f318c1d8ecc5e8e1bc95ad53109f04f488352304622f398dc6137e0b9c6e7360d95f369b38893a7b36b191c5c8f6de025cc1f1ab32783afebc3c1569cdba382c4a7463d5db356cbeda63c0ca39944430c4084d506d6c4b1383afe45746910923ab9d44ac9b0e37e417bfc8d4c0dacbdec264f9b59e2e89cbfd0a6ebf04b5dd80949cbc25f33b773d60c6a2cbdfb2b520b4b1404226cdd1107d4d52ebd818c3e8851c63a0c567a32012faabb2a72a279fe9a409388fa7bec02c2c753c5e28cb1d9be5917c5c5f3128dfe9a29943d28f924708d6a86e2312218c3808e16eaffb92172d0e4e441842b2eabc479aa2a89f4916a4139b84ea855f199bc3f96a79092d3176f599b7e890b84a48d3d5a36bcc55f42dbb169e8e42531bb23436f23bc5155e21750e0c2473d703ab7427a5eedeeb90fca93219a40143797534198e1c64300886a261f5f2adeb7e45ed4032c18a350faf9c421bfcbf9e574cb88d2667c80cc257a7d1e58545eb2746d7cbe7d033acf11b533f3be61e2283f1eef0d062fc4ebe373dd5ed102b47e5578e633ae19320bbc8d4175c16c8ef553311b78069b59f222bc381a82fb07749e072e167495e6913ee0435b0f73b2ce4bf8b07794909ee8224c96b0d74d991162ace2612640c17adf18fa36a011cd809367c37db167db833be60113bee702cb98d2f4219b2e32a3910658c5fa95955a48eea05d29101036466a3248e996dd1e4093159ec568028aebcb97008a4ad6612b8977017870f24df5b4cac6c99a6464c8c39edf2c371a14c3bccb53cd5785e828fc64ef55b565bf553bdc97599d2bcc70be5457910d32a59d4e029a16bcf09f9cc11758ea325b00c76859af3e58040faf48ddce40c4a44f236f732a1891b2447a507e7276a302596f9ee4fd99ec275ce862daa27e8748adda93e1bbda6a45a71b4e49d4291a0fdb7278f3807e22c38718d247fe6b9e183f426ded067af350df6351a54f2054334e1080c57aba14225af0b5564165ecd56c9fb836567177aab547158ac81f2fe74e78a1b830bb587555d8b7a0bc77f1778460abf6d775e6d07f5587e968b2a4054de7d0d9944b655c371ad2a6d835819d344653fd8ff0926a6c72f03f7506161f6347dacae107564d435c9cb082f47e58be0bcc164ee304c7ce337e143011ddd1928b9f030490d7d48d594282d0e839dae83e8bbb779a60d5548d647f1ed5dab322b45e8aa0d11c2ae57e039e6c05a79f3dc80171ff816c467ca1c31e7e0123c0b973e0e8ba402ec980ff256e015ac4b167c73ebd6b70077b193fa81e7d98480f833224b4a6561c321716d5f372b30949fd8010060f6e275914254e84af7edc70e1a9ba1ebada837f283de0817cef486dca4b9327ec6d38ff4f2c3fced9f48fa3f5e31d293a648f41e8c2ddd017af294577f8b0eac073176e10583b983cfaa796bee17feae194dc97ab5659ae08a5f09f789ec06476a9256e6b3594468e4bd53aa4fd7d29db2eedb9724db668f7a3eb5eb98e18fec71607ec5e78f1c42018e1401bb297473f9e2065f369663b40e13ef64161982134b074231ba6435b75d50a37d4c2bed71b33ea7fc4b993caf2b9253defd7b9ee37a848f7359e988c490991fc756edc2d3c2e3c15c5864a50cfbd276a94b466da2653228bdda814bbddb82ff0762b9945786bf5535c46dc2b2997f74c4523bc22a91eac42f89c479a7f32c4041c4f8e9a8a4d83acb0bd111c2a5f65cd6f8e5428f009042363b811481b4397d4b37f2d6fe0bb66eef9568d9c2f262620b81f3a1d9bc0fccdf70cd6a808311d9374bb929322574f9227a6a25b4f570f1a3b859566973f2611b4f27abe10ec9d303243e92594f411648f3b088174ecaec5d4459a999261966ea9582a499942d8f590f103bb405bf252ae3262892e0a4a938dc35d06e7109c01f4e2963731ff233adac9d78fe33ded28d39b91bc4a1d655ec061b7f76bb0803466a35d28b34668d463d4afdba8889dcc72ad95cbd0550d00a5c51f782f2f301f74397c8242638e10df24a13be17fd4261422d87622f9a8456196d8b17d6985e688226dbc33566957a9ffded7a164135897c944648655719d0cb71e818593c7f89299de581531fa7977c276cd4fc35d294b3588f792f87555040b74b913cddead0c7a0618af11f44d44423afde2a7bbdebb30d6ab08c1cf7b1a71d63c00ef2a05190c9504f1bcd3ff8e834dd69eb87515663b0ad3fb512de323b768169d7f4022a0f956deccabe88635289b5199a83915217f112814c296d936a12a9ca6f2bd11efe815ca7c64678c74e38024b535ec80ad325ee23be610dfaf332d0ef385d2e5d5c202d802b0a87e7bce5d3e4e2c3e17779b14282fc935731fd88ab9d2f3fbe576c23f6305e3fef19fd5dc65f68bf2da9eacef5a5cd4dce0067fdeb0687ac78e482b148cf11eb243095ccad92291fcd8b5c563bba5824c38a7f8e6c419abc1b5e40a86c597cad1a1a4f9171634d820b665d9fd3bb323ad107bae6c4d81327a4ba10a653ba3b656868b16469b1741210c06d69f153c7845dd88b00bbf942097c967e56a0f2c663e2f9ab48eb04cd17441414280a2f0f0c860e99612b5797d67f90dea5c0077b548a088e552d7ff9aeb93eb23664436cb0bd923bbda6e9a9eb70393d108d5ec9c28a403b9ede97bb51a0855b4385ba817b87edadf9a8c3b1e1bedbc64f9005ec79cc5a6f860f82ef15e54aa89aafaea44624a74298e0202176299992a60f135e4a47431a39d8e3c7e30b1561abbf9895fdb50dfb9727db0b6791883e7dd69d13b7e0a01c1b579df7231709116cd9491f6c751717cb171e229cbdf8087bfe2556a100cd20c5140521b78c75a33a57f4a1c45ddd9337a760bdc8eea7113f2cdf99495a71f65e446b19c04dc5c164b6f4d9dac31dcd8c671dedfb44eae86c0904ce291b86e61f317ebcdd015ff394fad82375fdf3a57527589dd6eb6b07c90f72c1b1c3b9ba303d890a7817b7769aa5444cb5cf7768fc4bab3e6892af25fa5117a3ac224f9d46f9ead14bb78556d296aeb4598d127dbdf5175bd876512b2f3194a371075976c7ab7972dc0c4553af5fc640177366190529cb8244d49dc9d98ca9bc8c68a3060b740b18dba123bff981ac73c151c18ea2ad91a1e194e1485d3363a847190e3f8060fad38a89677979135cdace06fea7e8d091d56ab917e86e005a043d57428432564da10768e9406665b7b2befcf735493aff7ee17a68d3bb86577b8670e935c14c59eccb186b0f788ed87426e2e3dddf7dd16089f4f88eebc974d63734a31bf518b13a4a63649930b6570ef5a0773b14b89fce68d16f9bc3624681184dc82adf75535090bf0044efdd48835ee5e3ea37e5a6b622bba8f3c5cf919fd9d569b0dd8791cf652c9803e519c3cd12508be77420ef1683f666ee5e42d2caa540c0f88323941de4610486afab5fabdaac04c0fbe0b8b4e0adfcbbb7ac094de682b436bb3a184b71e3814c513ef9940131433fc9c755e1f96c90a4e4e670a8ddf11000b535af4bab53280f0a9e4c2fff88c0412df9c436e25426f55a8bf88a188003c77e92f011fd44eec5e1d3c2b125e1a74d68d6201049846f02bad65ee84e505701b2c2d4c1f9612f1daf8b04f3d5218e330bda5a3ba48c1bb0d65fa92b10366bde23b18d26fdb7a2b3cfdb7ab927eb567311da4723f8731021cce89ee86eda8203469a92c5e94b8207468f0f830123836be0e08348d871a1ed41b679f48024803e14bc8a8fa558ed62ae61a15ed6932b9fd22100bb1169ed197e939c83fa9ea97a81eb67eda8bfcf262760d58d77d2021d9860db9a662d87b39b9455e7769b1b4e6cf985558e055a1b7e6c83de894195f6f552952e7447586629341155b8cb038d90812a96deb75cbc1171e9706f2c4bb132e3395b8e07dd3432c13d361dca86911202b421a57461e7b47195c50581fec1090feec887db1407ee5ad753b25be40d9345aeb842c796f0cb98c1d6d1cd5a864b40dde79bf4a4441fcc7d83576de8c69b2ad9790509c751e248dc2ec30e652754a18818ca51bbb5d3fc17592a05c8d974c8f38fe369b66d2e58269c4c88e513ee46e3626a1f38f1b780f88e5f347e6cb30a52eef120faacd30201fa73eed9e0c7ba3ec4a8342d3234da0dc64a7a1e04c546bfeb6f99ea75211f4bd6497fbbbf72bca430f2310cf456f3a458c3affedf97d41db43c1058bf0707d2159df57e03b430a462999f0ec860aabbb3057ca66d1cb45171598a2b2abc3d34613deca8de50991f6575aac3b5ed2958d2722f78ec510c80431b599706d23a3b543107e27cd43ef9ad4fc104a1261bef5a3a65fd7cd5bbf7acbb42de4b6352b3268a14f79fdcc2a64ce0775db55f23dea5aa6fb756c77d6968b751447ab958cf021057f10191bd91e955ebbf6acb0b21fd6ca48432bbdfd2ba3d661aa85414b128254f59a2c07de20739191f6f6a39c76504a374e0a527982862e637f1f78fead66a1975cb15593b96686412dc18ceab2aa51950c6a8ac1c0828ea92daf4d51da5cfbcef0177820a82f47cd950c27e421471647bf13b6de5f692c86ae866e8fc3cd5bc9d097a7f74606667e0d4a01851b357d6b380b06803adc1d669341d9e7bcecd02e081fb0b2d4e8d56a80673615663a4fc9ef03a908303b6e1ddda171e78643a8887f22a1f0f6ce15687dd50cad61bc6ab3ff5da179a1e9e5d7842a5e3f3a59bae5e79070a0f60af2fc12956cad235435e5b9e20ac406e96c28fb3d968c712382278917607b95f85a4ec87078f27a5883d59d0e060b45f31376fe820bd0900828038dacbe9ac325265b397429da5e0b1c66f1d372b3fe02b2a22fca016fc8670f8181b98fad4877f819f6b80c5361bf7f8f8b9a25b8624dc84d308e2cde184603224b96cad1bf31ff856d16e4bd7616d26898061f614024ebba1aafca44be3db4776d0af9ea8a686569a5d86d383fda669627268596ba910d62350d41c019772e0ff42fe63af19b5e773db04f4ec25705f90e2e7bd217628e27f04266141310ec7dd271f93fc7bbe70cd9c793c9f3e6b034332d68d82bdd3bbf6d09547050163c52b7ae157e504eae2e7d7df7705c9082f6c91cdd2732ae4a17aed9111fc797f04e71a975549e799d95868f420fffa645d3cbc66b11fbc38d80f766ef7d8aee225ab06b76ba82150d6774e04853decd229ff353b3fb50dab27040b66a4f91901a5cdcc5f525395d775cb4af3fa0a721de345f23574f3c888f39e71c8aecc22092e769daed0281da21f6033c2ece964621e5d428d6fdfcac877341c3740599bb5a6d141fe85d708becb6d4a5e6c7e169fe09c0e05567c82048e4fc12294e5147e97a40b8e17b64a91a2ebebf647c6657b536585a1f3b0bf3f317030ad05ca04b12ae0e4318d2c03d1780dcae05a6b8ef009e824efe6e320f4e5bbdbff9886799efd562a69c6561ac947d0b2484b101e079a16eb3e0d33e3daedf20ab024d6140f22ad3670c4034f2626270accd6b623fca8b224c8a07dd1f6c471dad320cce6f57f389d93fc8a27e24bc90ca96cda425f8c349d8b035182c2ae13c1bd1ce5cac1ed860f5208b08fc78f346138e351a1d3107222085d3cbafc60a2f210884eb298c0e6a8f08bbc6d8375798d770d40273d494a42d6339015bed9658ca4cf4ed41340859f7a55e624e283ed9f3c5ceb07685f12031625a9d30a1abc252daf57a1a8ce25873167d4cb68324a92bc6bece2b580127c6be1ce12eda0659baca242ccea3a60d9ea56d7356c6470b8d0e92166b094df6cad9db3ce51375bf5b53b2a052699b41ac81cb689175cdc0c8acf748bb43b2bb8b5837e71ca5a5454931f940c4b184f74d6da0649daacd23acdda30c0771c74f81b9193c1d880c951b7fc4b7a3f4e29d11e5dc24b2ccb0ed66bda53b8370ebf9fce56e4b91ced718db8c8d4f7d3a01f72eefa558dda613c13b0aedb8c5d49fc1f4501583d8f55c632f69028fbedd0c120919651c648293da1a3f0b0489bb0c715ac4b3430787c14908b709982e993dd737bf34035ede1accd211a447803c44ebf80f318673d12fc2e22c8fb9270ce787dcbf3a7dd903a22bc12c9db3651c48c65ce4e1b1011305e465ac8049952404cf98c5b02ce0e69e19eb35a84918fe93cb5221e82c5dd0adfa6f9412186dd3f649ce8ebfe9d28aa9411d371a05717e39018f33c4d90fa899d1572506242aab7830c6bee63692950c14b58c79be6dc6f7653ccd2afbf8247d112eda5f06bdc87971b08558700eddeb37387772980b09e6deeb8c6a1d85803960c551ff09994f2655a15fc45f82a763242835fecb13d003cb6f845a6b6c032c07d6920e0559d26cacce8e6d46873092aa20bf4408438c4c60447ebcd75b207a917970576f287aec2f6251daba824691ff45cff51a34ba6936accb768a33c4251024b1a16bd2ceb6dedfa8484c4d1e1effe97c21779a425f0d4da939395508d187519a158d0e4105c1a38f87ec9a8532b5b14ada8ffae0395d82b09f3eb953bcb9ba9b33e49b15dd22ac3509f5da54f491d0701e55b9545434f3f75271037bdb49ea08fba12760f225476209627a6adae0241918f2f704fb4574dec72a3054542ba31f78d618118d36c1af7a3fcd314aafd7d5305d9e716d32673a919c6f384a8e859ebe4b1f85b7a0ae9f7678c9b554d4611d11ff30f40c90c9c1f7c94cb799567e0eb295005b02459ed77f0e428fc8e05574600fb4983dc7be4108ea708cbd8a223ddc6c901c0d836734cb8a346ac3d975d8853e56d9a964b88e23dd511ad628c147d57add5f75ab324c1359c5ca52a2dd1067b81a0923dd489ff430cfa3b924fc2f278564105a226dfd9e4b26881c9303efaf40ac1f3a56667d77ad6a7ae6208041f765b13b85cf069dd1d68fbd89ac876188e765d932b7985b2b4b0fb52ef3e144bfee3e427d39332642374c967cce749d4894900206050b2d81c8c8bd9c0672b39b8f0af918b20f97c957bbf5e853ad37cbc27a7141f2604f8a97bc13e87ddee64071e46118f524a50e27190662f96c79032534c178ee5a4bab8736b239befc599905e8e876fe11bc5e5c553d76c689426ea9d8a79e300fcca2a41a1d60570858c63cc049dda1105ca5186fc2ba4502ad5c989a79caedd5a5a9afc3fe483ef54d00836b732a9bca7f36fbe56d515110d7b628cc9c50e8c10e6be714f5c90365edf460924e26177999cd45772e15b57bafc4cc97b911f9e19073c5ecd721c40752cbed29d81709bd0573fc71be439b7b6864bf801d20e7cc9ac7b0cd890e3f2f4d8f4ad2c910da3d15b384a79403d9d98c38e1913b4af2bd59c0d12155ea4890dd2486d660ac9b2730063406db244c9ff952b81f4f6a45636f6dc648279d923eb3ff1abb159913b6a40e66f0176bc0114eb8a4dfa067c860a45a785d93cf7b7efad27acd6bd148caa694e7290085804634910d862e13ce7606caca454a1a94b66b965810bc3266ab8fc98bbe6be5aa66b878fb6608e615fdb569b2b49cdba02dcf197177aa787a0ff8f56c0069982bc1648152dd66d8f46bc264201c047614de72f6240172ad8f92fbf9639c55651086ed524c5cdcf9f9d4fc3c072712d511216f355a3c60b1fb1bac24d80e4f5071cbf646c244ac74f0e08986339d69a99409f4b17dd3352b5af9d77b41feee90e48357d250c053b3ce94eb5b00f25d2cb31aebce5dccc098423bb97f869160ef136c5d88a2bcf854d52579eaccfed22a92b352fe5c5bb5e66134aad2428da1344af9877dc2b8075556873f82c5cb7c44c090b1c731c9ea0db4f44df05f714da619eadea123a36f46752ac2dc2f6ac982b79e0fa1beff7d9161e0391a4bfcccacba86442cfe70124cc28904136e0934424fa94285a96d4d77188ba15971a543342d6d0197ee7ad151220c24f0c15e632979cae84afd997a4493867ce3b82106d8d6592c64b844a68a7230720ac560545657f883018a3745d743b41bce1b6fe9963ab5dc6c000c749592ed6e1ba190147e907bd3d9247232c916314d151ab818defbe8661715d7b7e9613673d907389dd377c620f26b2d29ba99946ffbde1a84d892a3097a00245495dca60413da07d0ad102f52589e26a7a0a84f227ef56dbaa66354b5690a238f16c01b2ce20a1ef70addfb8733cbd097e7e70abe80d8ba6ab9dec4e941a408f042a924fc5c146311167f5ac82bcaff8a4bb12e3e8bef0b8e4e9cda9d2aefbb4725607929cb57a1ffe9565cb15dad2c56a1c7fce8f4a3f68cbc225caf9224eb395294b57a6db7763f58c79b5c54fca1340ede235801d9696b704a19e57c40f7d609004e23c6d2d7731dbdf8275821c449ce9000e83ed679f46d04c7613c02962884f51cc8c203f5be524faa322660b43dce6c062f1201500eb3f2dffaf9ebcd1369ff7ad7e7f6244f9ad966f2b72d9409329e98a5229ad42417a6360f5e11e47fc85599b4b15af10d6abdab19ede0f027526f33993beb067231ade30dba329a28c91fc26d269263c99d5496cef4f9590d9691c905194ae6d32bedeb66d0ed3057cd31b552004debaf7313b8d965da783e17ac226d299b0daaf137868b80b21d44fdf78205201badce482ff967b8cb26025171dea6aec2494eb4f6f28422a1c88d22d033cfc833a81ddee3f727f3d6cd0929e170b2525be1f769af5a08fc0c88d55d650c59ececa2371c73dfda60268376f5b43b9ba34ae6fb39b2fd00bc2cc264ad90825fa98c4fbb64c7dff664f2cd74c9a138ad3e3ad4f70d3325f3b9cd30130fd804545fd1dd7b6d9ff8d5f8b8d545ad522eb1fe2099af4d1ccab83bfff4cf052b3ddbbf9299e9e3769d48560087906fcafa6fad4e479c34333eeacaa9fbe4d78789f39ffd1c1a36922b91c584bf374551c4ae4025a8c464ca9b7c5bf29f760055d3869e71b5b09cd0fc398f8c64db9aa1ceb976024a6b09b45b3b9e1756d8d18ce847d1c5a02a5872dcca1e9b4fe193c889c41d187e5c4ed168f1691c1dae5b782f29794501836ca8db7259234961ec6681030900d7da8317eea3185af90c9a012813c91758718f9af86781a89d6567c078038a8c8b88fefe6af8b36a9c0784b986dfb49e29985d7fe09519eb8d2f95ff9800346381378186084f249a1062edcd522fa6f464485011a1dfc6e5fe682b480ac61eaa9ee5edc4106c2bfb7d29e23bcf221fae11775e6ea932f37b4f4cdf026e447d5662218686a1f4fc05b72ce978133685b3b108d2dd730d25326bde5bcde7eec65c6b2fde13e1ce9e4951a3cb61196bccbfae3a341777ec0d617459a75a682ddb91f0468563f384e8b2e6fdbe1802f309165ee523960d66057bff466dfe888e3eeb266ebd33b1e5caf22861f99910d28ef28c12ac8649b63587c5aa271071f34f28804edfec09464cf3c2c6d9f70675bfb664ad39e6f6d7588ff0b7774826b5a64d8de8d62e03cc9c48d313078ad98df296541370de48321b8b77e73fc615fe2cc6d84eadc27102b65b55eabb6eca8343a449a6034eb400f55fc34dad89118abbb74ad53312f633f1c44490e4ad5dff575eefd17e2025771bcbc2161b25d999dc54c259cb6ccd5c5078d2e221c9dd7a9be9d9e8e741aeba18e2df4fa3ce113d135c05b43e7331f95593d2b79710a691ae8259671f54f8c244e869670e395e92d5323b747f72dd8fa4170f4f28682ec82b4f47a93a8fb40786396e020bb8819dc77e3a5db5fca3a9c2179717c303ad01f24f6764ccc20b806990a34c64c0e9eef9ec392d14151cfe4ab59de4299439f2ae98a79c584e39923251e1b6b0a26ab4d4e040be086266699f2d8ff3ea3a3bd8292671a470c62249810068c0d59c21ceb6b12aac2227fa5cba89315dd072e68a6dcce7ea29483d8f50e03dd456ec441f82b7e4442312c371a4b05d93c13666236f80d876558fe05236ab0b93f3663c0b7fd753f33b75807155f753e00a8dfab403d7b835031ace7f5f52fbe0567d5f28f7d9cc33379b58fa67d12311b947c64516ddbd986c26efd78a7633b7e6526e4c8db996f8deaffe22850ec868df8a8b80880df5ae7fab698632921e83c21daf0aa70d1e2800b0797163e6f96a59d2007b14cdcbd93cd247de2501bb0943fd809d1e11887e485aed6e6efaf0d9d4d9cbdb818a860e2c58fc26e355915f583a709a4e39e3f37d46c29d7038f3e02042dd042f0c2935789dfd912048daaf3ff8c9175fcb610d478319a728fc7351370011707915228b99e858c00741de2a8290a6d0b6d221a4ca5f67a2dd6b62cfa9d82c71f6344eff475dda8830d2dcf86adee12873c53296c60f00e5649f1e6ba0b2cfbb9a70f61c924ecded038feac69ad7b66f152e7f65e4e74f52fc5dae7faa57481c6ee334539287626a4391abac046ca8200d8c7ec7f924f904f7e97a73271d01109f3ed8e1b0b2d68c81ca1ee99fca13ea1d22d689f88de10ffba0ed2e8660b19d7b4187bfb3babc6996b2b38dd584c432a371c670c13b8724d30b604e5aeb75787a4c1b42d42f08fe7d68dc23b2e5692234c86aa9fcb773c0487a5c28d94b0229346e323f07ff3a9574aae2f166477058d9c98faa39d26b20490d5f69fab44555c453605fccfb925a33b68040c1e98e7b948e9dbf585a2a5dcb9c6e34af175ca48d83817cec91862579262e0eede994b5c94c34e92e7f680a8e70f1cc99bf6507cae147540256d35ea66d3a6eade5db39b9c1be48c06a874de5e005f0cbd39f17d8abb11d4d87d5d43050c7061bb189ba39210aaee24631e21fa13d89232f17d1f3df05cec2ebb8f190fe95ef200ee9f047b6b9d62119e4e7efcf5a2efd529953faabadbce98550204c3cac85591f22db2d99c7fcd804365998387595b7e5ffbad63a42e79546fadf9d3c6d0b1ae39dda2eee46d7b8d1976772296b4510e05d23a8345d6c2d3b38c12bda523b7a230458cc98e1738eb99bc4a2a3eb98a7de87b341f4faa49acb9b575599b02b9ed2f40aa6b6f131eebbadb9ad76711732770def841ed3ddf5320b04c80b9e8b1d62cb855a77d88399a6de5007fa7511f4c1fb10c25933d3b73afab44c14710b3247e71c84aee4ec8398d063b8eedb562f73d22c57c6e023f8bbbdf9b9f552d13fad769a2a8ab055cc0109526d780935229c9ffa7723361bbaa31ea353720778a3d0185fe81966aa60cff9630ccc4ea042b24c453061b6968ff59886269250b550e2515af6883315f63c538fa634115e9479eae949fc67c56eec32022d84f03033f4c704c097234d9f1d9d8b504eefabf9b95011afbbd1109584fcccef2b03cca16ac25e3d62ed27b78c7a3e56d9cfdc512b34afdcaf973861b67e9dea4038f1c17e5d8f1a21b8d8ad5453c18f13e3a05660a5a89e9139c341e2a37e7cd3d59610466975ca4bdfac204b1d797c48487625b0b5145b991b69a518c4a87c4d46644134b68da9c9da947dc3a96f65ad3b17707968771e47c9e83b3c0f0b69d3e50e91012c77373fbed9f060b74be9a2026aa569d024e727d21c86b491898d97ae07b718fbbb4039309fd7d003d251f8db38e8d2979901e174cdd5d0afda497e9f7aabf9783fcd503bc2d4505b1f62cf8e7d2cf77a1b8511b7aa99d48ad8ff70b9f263585e4eea6e4358364e9f24b2e821a0908a8569459610412519e17cc53f1122a49bc28e9c6badcac07775eee72e37301732a42afe5d2e8476d4abe640428f943c76bbbf68826d2b77c1664f966312b6aa6aa995dfaadf08e5d3eab08b4da46b097d8a0d4d92cc3b82e16e5f91c7566ddf4466448ff619d14df198251e5771c80a556e1934f5e6efe70759f259994fa009934e91273f13a08b2c6d8eb3947d095068fab17f19e4a11f60b1cb77438a877490717693eaadc8035c9e561412c4da705ce19e1ab8e94515980a88809d6666de14a5ff3f36ca5df5b34d60be056d8b164a08ec88ad2decee488daa9b7784ac565e0c14bc38ea00c9a6d3776edd787d9497f0c57e5df3af8a0837dbbf19f08def7047d76fb5f1fdb5b3728f35fdf5ee4bd9715f3dca873c5e25aab3dc76c963ca940f2599341b59324757819ec0426ef7421563e545c725d63c2e9dec73f0d9f1ad29e14e5227cf64d3b3b958c5c33c749269e76098fc2a836058117500ec54b5e0c02855435563e756f91d773added594e03270576b1696f569eaa1716ab16ea53db269ebe9b85219f5b9863d48a592c71185d220f8965d48c5a463d80921b6a7610ebc2ac2d7e73e62fc25882958df497cc7455965d674564c545dc2b046e2aa4e19da74309ce08bfa23be025919420d2fd66a5485d42a66af5147da3ea62fced55ac5418f66148d33dd180cf8d0fa079f5043f1f1a98a5f49e715e9714a5acecb27d606f1cac8cfead0b1c7870fbba4943c00f12c466f22553bc627fb70499fe4350b7f7c188173eaa57a88d713fdfee4e309c170c0439a8ec1515328c5d1380d1fe0fa4395cd60859960b6c50d7207db5512d5622cac0af098a38db31de44b7cf0a6e4bf373f4dea506d5aa68d0396855722f8f967807104d9611d6e4fc2dbb07ae0efced1dd025fd8017f3958a5bc5c3fb43af6a12a76ac176f46f9ed62b22bb6a2e05455cd7ff4dee88129a6101d49a24149e8cab7711c2b5da3cbbb6491b201aece0325e47d505fc8b184758d7e1cd66495fad7a96ffd16b52232369342a0472516432f27faf959052744f82aa94786612f3b2940c0d9d2019c752b646f82d30adc1a17597475e4d2ad986b6f2b971f5b5f63d5dbf039086dfafc8d50f6fb04f0c8ae94871bae667c250425305cac1540ea9fad299db9acec5b2f4d0e0b64b21b3256b3f20157b7db163cf7e15276a0d5befba9dbec4ef8bed96b41b4e20c0325cc8623d9bd403c90aa66f978eae16d7ae45689d275210869db29b57c5c3a14236d585db7d51b696677eb94ba399287e3825ddbc895781e3c2c85ea393e44f2cb6f7e7f09af6500a8d3d48aeff275a642564f278703fc88de212d4414095beea39d63bd97da8f4cf243dc232e020ce81d96aeefba926709d55374d8d40c218323fdc763feb9375ce3c87649365eb451a48d36dea02f9277c0bf815b0b64b7430eb8b49366393e4e287a46079e05359d06f47b32861d21cff8f823826945e28fac21d82d3d102ecd0fd2f0ed49fea8318186887de8e7f77be32275ea3f9902dc81b390e36dcc92691127f33e2f1f250e9defd8c4fb8c43d03fcd0212fb8fe0840ddf248386521463804a1d0a69f3e4cf856262fc9b38d15b5124048c116720d9aed15616ef9d89b51a85717aa975cbf055992a1a43c8ff1ad7770cfef792853a6c80e670459827bb1e526711edfe71802c94b60c2f252695c3606ae897546622c65d3d3de860f55a0df2f8389ec0a57d83b730","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
