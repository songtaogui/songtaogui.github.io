<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce79f5f9cfad69c75632d038801093c74d207451da34fc060c4fdaeb4a6596c79235d11dcfbcafc07f797a087bc0f26b415df8d798e447f1e8f0f768d77de7137636888fd854a6bb9740fb48edab6cf9c20610e955e86bcc8661aa7f81aa450335ca23212c20a25e9e68ab9ac26e15e18b006118437011c604e99081a9993490b6ad285fe1c04920fc8d3b38901bc783abf9f9023fafb8e6c335548e6e6155809ae4ce8b55d8e007315b22317de3a98e020b1a960009371ffcc9753e8603df2a8f3be221a013ab7c3591de737d2a10bf8b440311e579bcdb28c70637063004467e301f814089bf2e507cf94fba935cc61ac77de2f5ab3302854d3eca591ef9ccf46f338c1995c8d95cb5df9589d20398b6ee77617beff7b2147e85f4584d03a6e0d609ee93706bc9d6f18db52ea6ab451714b559d31f1391d6673b9b82281ea4328b4e5e2bc2a580dc7762c0ed9c461595c94bfd42288edb5359f80b1f6c709b748ea8da46fb020702fa649781d7ba517f27ec44b25ba3843b9f0adbe6dbf2ba6f67b82b96d5f7a63660b6328efa22454d8023bab20e95b6bf91f92802ed4be42bef3ecac81504ab066d50bd8d1cf615d2322783ed6aa6e37fca763d7559e581c1094cce6fd1b92f02c78ad42d0bace3b3e9e0141426467b4223e521bc6fb616691011f9772158e0100b5ee2ccddc046ae7f54d630982d0b71fb827216b598f1524de2362027c767b40ffb5cad7b2f0ccbfe4237a2a9aca1a6bcf4c8c5258a254859e2f28d89cddc6325894742ed7dd377f4a03baf602de221064f16839cb164a562488fc15e893fc8a47349e680f67819582c449d7de1cba6c686f80cadbefb3faa25c537b024c3ee098f3583dbaf579e26dadd6ff697de75fd03d49c227d2f166dfa14cdc0734a79f13d1af30660ee91c94b169d14eeadba7fdc2eb49c9f16f8c32a049f8ffe997379d6c53b186266680290c9b897f948c4a487f8d05262d64ad1d589e014704967e6e915392437ad98a9d995d79f232bb267e2dc727a97be49ac9f53a4fec451cca80f3a5e3102a175ada13c9aa94c6d883a317fbeda6693837bf6841400580c393d537ea4e7adbc7f08487b8e9fb97b033ffce2a46d46abbf2a3c4d56ea449bc0657a10dae0f74cd3d89951a55f76173a56ec64a1c85bb8a739f3291e5ef286c5bbbd2b592cee22a1ef4141eb83b2624749b9fe13470f48e310b3909950c8df61257598b25116847f315688819e50dde8fc3cd6b631c16458c987539368b5d6c4ee72ba6b41bc37b090016fdd57d99a67e5437fd2a873b2445eb4b30bb747ddf397f164c0b8826d04a55ed3d52cc138f989f5534306a2097da623dad2bda12a0ec1e9107808c4e302f921937ab2a78594a16f7bcd8f2ce1927467e87161164901e1ecd01699cb228a9e59973699038421caa66efd03b576bb7ca63ebf077dca19f94231d024a6e6699f6a66a2d240014764fd86341023c080e4f44eb33d7e5ff1cf83b8f9cc63c292cb5a791505ed87c8e24431a616cdbf516f24e5c80312dbe9ae8bb2c5efac9c005edde6d76b238fb0d7b5f48566b420652c71e3fe5400d1b4df51c2dea714c0b6f4e6d39def0e81d8cab54fd484286d83b4d56c64c567bc591c39f7c560e840d0517f972c8c135f5a244a741ae0806db6f5e5c2f1f08d18da20fb502e56f398e3147e6351fd819621df7589d33dea8a6bf9383f3fe6f8a6df5de92676c8726617cf41fbebeface890040abb5848254899987c352f487f4618cafd51c9492cd639374655e5a2212c9d367504be0763346c7319eab9cbde3ee5696928eb5495a8a8207cc0c1a2d184560ccd7cf74385a078b5be8055bacd3b27d35246d6668b1ed1d323986d52ed5a149a81235a0516e2b48e2055cd98e8409f26ce09c362ab89e34b15bf3646a4680ac2d58bd09f290c64c00cdfd8874dd4c38fe6a51644d5dbf886077d6dddb740d141d45e63501ed960187e68b396547696e6f379a98701cdeb925f14aa3e33c985a895fdc266a16bd509f6066cbb0b9e19728ad209ea1ffa3bdf671c264b91f2a69dc90101001773775774bcc57a47c23849b5d7221ac9a34af3607edcf4a68f6fe4ae75cc10799fe676b1425baf6555835c076e02254da71aace53b9c79befec2e757dda02ad36f63134090a8e7a0188a948f81a2661e6c617e490da58b9d0bce543b590f0a730d3d54fe5dd7b9a70323988d0f96e37a05409cec834fb0258093cc75e718088d3fff64ca34d156f570090571d09236f3b5b2487743dae4da4b9004431a079ed40a737ffbd6761e3281c5f857d2a00a528e47dee4caac868945bb41f803dd997d7aea05094c7ff2d29c8673de7f792391485358dd5496ed0117f703c6851d678ce97570057fcdaf0a09f680d6e92a9af92d312a99461e1d835adc6e0bea9728597409cc53af01184f486e823fed0498f29029f2edc79fee3b500f9aac5f2ffd882bfc81c888d8eb5876a10a829e105d5f5faf3146f18a0b49634376a6206009afdbd2a110dba93d7e6356ba8d7aaf67c6a65ced5775553f3cb3be4a9abac0d417c81e017717580c16624e7ac59a44bb6742c12dd0520d049852dc7aa52836daf841ddadff0f252000f4d64f3b01045198b11405d6b03948ad38ac2c3eafd8eff8eb04fa76c3f7f55d45af8ef5dabf7f0a6ad0b10e0eab4422b5d0bd10a5a57273c21c820bbd47cebfa22f57b425596d4897fd137f56ec719f76243aa01494193428c2ae9455be4d2e6f921ecce22c9c72566baa3742d86af21c598080c84b97b98f81b8cb3b3d51feb94aa4f0445921573cf3095b14b69d6381984c375612e020e50acab903d7057f24c032e762f018e01d39dc6f2e140862773d70eb0ccdca690fb09edf48227d2b115ec3c49367518488267602fa59cfc763a8b66b07e5cb5114755bbec735463da5f907a4f7c1426d6d56567c5f11fca03ed13f84fa36bf23909a4660332d109b2e2963f4302081235835019b09c80d6e1bb848cb5d87e23ea811755086f7678287ba693618da2f3fdc65cfe6f80a2a096e88c0ae8c212082de9cd21e67c89b9d06ad3f1c6c88669d7bfba096fc1ff6019417bb7f9685666189af7d3a1e1c4298c67b2822118e8070100e57d2acfad649500f3ab992ca9275a4b842dd1ed6617ecaa8dd275ef6c885b5b775adf153cf4b2c935381b9a9f537794ab3511d9b23c60dcb582a67e1146ff67221420839b4ec716db6ae279a1363e986a6d4ef4fce4b33b606967c5b50661045be9f297df4e5250d88dbce158a335bb0ea6aab9f20cd6bdd1a159e9dda7c960fa53ffd3c6911ccb0c0255f01a458db9666836af74839554ec5662bd5f58c793e10fc31f5ddadaeab2219eb43439552091363de72c116bc6c168451ee3d4f5884a67ef46be1c655d67e3cade1405443cfa1d71b64671be5ff379b06f523b8e794990d6a2d61b9312605818870eddb9e108ff7637f8ceea5d9334d800429b0050b19d81696d517726efa201ec1aa901135d17d5b4538ce79ff2992e808f6f130adee15bdf8f49db213e2fb4a115fd8f9077677b8ec3a63a238dd58b3954eb9f9dbe944c6e17a04f4209645d008d1df6c527fd9bae3c2a3aa3182d88aaf8cf139cfae379ef8aa22faaa064cb1b454913f42f36e66de0f32281b3958dafed4fdc20c0dbba31897647ea2665de3badcb3332fbe5d9a743224363df9c6b9256e5394b552999a9732c9e9edd8da62ec976138885217a10c535a61934ae712b87ef71fd7d4230588caa6da6b271057d188edfbcf96e2f434a0a261cb582c0f6e2d235ef0e9d35d031a185243a5f0ab33f4b343ba97231fa1cea4264071d95858c9a1063d31cdeb90cbfac078616de91280e8e3e2cba53c1b65a8e8bad14fdd1195f6f9e94ec666fafd04a53916a1abc890fdf68bc3d95ae11648e0c4c80adaa01a339cddc6da0008f322662798739ec188d9b0db6551a2b02a6c7a96879561d52ce971c340995fd6932ef9b4e9f22db760749897b9da89bb50f2a11b7494ef56a077a642c40e8074b1adda118550d9f2efb1a389302eb6a5d20a974280583adb4b55fe28b21a53f575e6bd51291dbfc37ae89c5167ce69e3a34f4ef01b2c857309caa924d7c4bd3f6bf2ddf4e9d6d4b3603f2c7413ac3759657757f54f0e0ae582a548d6ddfebd39ffff4a2b16277351b1e595bbad37e187083037627d7575266a17086946fdf227cbb9c2e3fd3b8031ed452d8fdfe8be65c4e6a9e6f2bd53ee2201319cb66880d6a109d88b505534d7853ad73c50e73feca7df2dbd45fbce3911bda226cab94d1d18308382c3cd3543c6544e18d902f4bfe2da36c38b4f367561571c33123c6b205c099b1cc1192015c70b0aa7f9111b92bf4ab88527915e94f4860d07c3b9bb8794b6ac47d45a7a0db8a660e176a8d3688174fafbabea52383e95d8f079ad190c5b689076327173012fd16b17ab9cb28d919f47860903610bf94d8aa602783fad3f8d1598736826935e4e006f2ae27fcab3e06da6d3d92689bbd44d50a497f6b5191d17396a13d5527fbb0c3d946cf22e968b2ed618421bf25e4c19272b37bb3593da34ca77cbf79da1a721658498d2a839f377db96e2f4d7b2999f1b794eb955eafdcbe2f36e5ae00694f5430ccb83546b529eedf5e417ad85fd096a62069960be877224b97d40014a4ffa28a77475419fb8d9d5127800721a5ccb3b0f88cf777d7b87beb7a511a99123a6134522b3344f53bc847568dfcaaa0152273609d76436aae226a74d6333bb4d565eb9dc78e4887c9eda0bb1ad59721a18d2daa5a8629cb3b5e0b2157b74552d7d00e68643732437c40383f362c9e439ae9ef42db39ea0d81f7ae8c2f2715d4ffdfc18c39e3efe8fe472d54b65852e88fa4d52c56e6befa1078f7776081e78ef42e1310ecd8d126ce31febe35b8e31683e1fd6207123aab3575354ad40047c157d05d4ade3b853066ecf27bbc30c996e6c6076303866e1e0424f66341ab153a187dea9f05939a4d217926c3a054073800b1288a63b4918b3745596a34ce6fa4924eafadccacfc46b113c48806bb826ce141364cfc54ea6e3d7d5f1808f76a1c2579a3cb2177e6221c3fb71abe157a32365f85e8e7e0bb31dd385e039680ca76e547f3075e1e4171e104171bbac5f397701e502cb680821d9904385f581b9cbd427f2d9072941997ff96ec7153cb915881e79216017c91136108601f399bec7f057627b9922ac0b73dfde50c701e14032f7a5554423b16c368ceb080f2b22a9cab44320e5108e0d50d775ade48666c2587639fc5447948ad322eb3ec15f651c7de424320afedc2a7a501b1923fcaac093c605c4636dd5eecc41ad9db3ec1aa07c9d67010cec31a80819c45fb80b816f90a68be8bae377189e9262644bd419851072252c7dfe7a2fd19d83417fc8b5f47464d7a21c3278a69a336dfee5ee89dad8f5de0129b39c21f63701ae8cd8082109970fc356dc77378b40c77bc2f5810289af72afe973b3b1ae84c2614f2d81b7fa3d27309b834d4bbdeba28d6ddeda4a3c521db7c5232f544dc00e920fecc30c274c6d140412550850b59be568ba5c6b1d1b92f7a8cde062463be69d4e5733bbf03a56580e9ee50543b678ef9e4d72df8ccb40e70cc0fc4448a85762aa38babc9a121751b0fffda67e0994c343801d1eae59afc1c5ca8fdb8c396f83056a2feb5ba10e4dae2d8e34a4774eaba0e9163516b8a5d83a13694c4ff77590f7d0590fb947f288fdcfda5a1baff6b9eb19c8989a7c13583ba5c0d9de8dac56888106f055cc036322814aaf0b6ea1f2d1bbdff964555987bd4aae3f4befb3d68312647cbfbbb3865aceac6f848097f2a9a685db3e7799af863eeefd70e8f014395771708c5b6306b133ff8c9087bb19ce7b8a409667f0a0c21871b1ed82919a7a3c73bf4c0a1797fb16b156984f0749e43e6452f30a29f69e6be5e858661aacb9cd6d3d064216be0c5a82ea8dcc3bc2806fcaa0ddfd2d63f8a8a3120279b1bee7e652b0452c5732f5e12e2e1b973e80c4863cf07a7e7e9f1605c0b9396409f72801b1ace713922aa633c5ac9bde3ee5bc1da85cca43fe3b80c5afb67fbe7e98b79ca3b9d9c182423412fcd8f333e0458386232d2e119ddafa9fd7f7f7c05ed9a14675a91d70ece9be0c471107b720d07170ab3cadc73d31eda0269a5c766cb072007355c9dbac181827b97a64665f1b56221236138ceed6174768ad8fa2a63ab7f2a58f4376ca99ef7be4165de7875d31cf6b054ab530bae58e46e636a3dd19afee4994032823137e1a99e1c2c88595295b3506b77f5e10ebfec966bff0c2aad554bee2828459987d463cdd10601ef88677d1e7e1a3949600e07ca68db480150fa6f33d61d5757a06e1ffbdf8b36bd4f450b7a774040b5ce0e1a810b96c4b67cd89328897a3ff61398089f5f3db190581c93823caab3defcb63c182faba8272f24af463ad505d5045ecf781e3eb2b7b9cfb3414b7d6463853a68016929ddf518820fb8c8aca01bfc05d50c170bdb15e6da80a7b4ce0db9dd811ec508bcaafb557e163bbac245ebbf7a9c47a335ca84038c36c91ec85e4239f6f72cf114107af988a6c277409dbdc58a283c78b2c0e15f0e13fa36980aa2f6aaf8d2d85c3307bfa553c85d93dc0af5653f774e0ffa8d9f37c5ae0a01f5194477ba01c03b4d73e467523346ca03013ac063bcc832236ba0641ba5ec1d6d893bf28915ecdff1d9fa24688c9d29562aa1e5e953cdbd08f1ba94a83cbd888759444f2ac0b329ec0495836c39a8af044bda02b4ee2d4b8fc47a7e4733245a29536f47ff7bee6c9109bb3e2957d4a9213779436abbc4dd301d512ccf4923b93c44f2562abea8bfa18f4789083d5a1cf8ee77f70a2d5a2003d898e50704301c4215e2d66f082cc518eed271644624282dd24cf84b66c13fe48926ddcc0d4a7998e9f413024011ebebc83b4170cda146bb9febfa65da63e19621d174e6c33d90b673e457a41a57b583cd60d77b7699c8b53b52f41aaced950f1e2e82d93641ef8b8533bab13c9c8b9b4c5bd808d92c690f3ec95190cdcd701aaceb309c3084d10d8caa858f84d4a7f29ea38eb98651acc6b80dbd13ad05c7612b019beea20f1a03817d0a03e6033ae3437cb14a67c22f75629c1bc1ef6eb5bbbae18e00fd4ae0a236061d191087d3286d897007728e260cb5a547563206b23e4b4d53a6ab2f3005397259c17b489680245e1ef8dd856b41d7353d5d49ad7951302b010f9407752c75346a7c10cf0b6ef15ef3ded07b4cb702737a19d45b23cc343e6ac2c8aa3640b995688e78730a27682af9aa966309bb81bd91df74120b9b042af8fbd731648543e5ae042f653ab0871d283c99d40cb817ee81ac8e8c820279a5d6e61d4f5e0037dffa790fcc22ce9e044b44445d140fa7ddc3cdb641a651a1796f69cecd1d974af963526b643957bce4ab988d3e2c759966939bbc8bd1f159df2ae048339b3cbca5424e13c87782f85b24d478a89cbc1485156d4f127665fa34f5d18c269fd20613dce30d29ed7cc3e2db62c1050b981c0474faad565e458b79fe5b850d22ff83fbdf45399cb89b9e87d62bdbce1bd3c0c823f86984b41b184566a4b958246c2a2622f1ab41b59968562fcde9ecdac7a12718d562b194177e6e25e86703ecdf9e6427237f4a88179bec205b748e626dd103010e5fc6604501168e6abd214dc4a1a854427fd953994c5b78d561c3965e0bc8bb6087f4f5cc79881d04176fec3513df7fcd537df2a996af3fcd91a802aa8404b58b66c39a21b205e247a5eec8161071078ee5980bc295a463b464c46db33c190f1df6e617c34d7ac20eb24422c9f3476245bd785e83270de4d574831253a31212b50183093c64f43588779e9d8e29eab8fef8ba553db4143c56a8d61816c98b3dafb84ee0aabdf5abfaef048deaa35472ad6f99026bd77e9440a143229b3c2e3741066dc20b3c9ba03d21fd048ad75cc2025b6036b8135044bdd2450109130bee581f2b6f2fcdb8c78310b080068d2360facb0142ce5c27081e5bad736548b07b14367084b4d2eeab6142cad72c4f8698091229e6fedad8844401d6362d23d5b3c4ccbb92312208d050e3004a54565669556a4282fddbeb16fc62523000f30a03db2c932b8bbd90b241e13801e16c87c669af70b5ae4d4602187a45079664b05cd1d221b48244fcce28f68a57f6a62cce4809df678b7ae3c2d2edc35625d9759ad1a454cf67666ec47ac100ad82d08d001f368029c3c01699ff39a32ad1a44d023c5ab8cc39c598507030c27e4521f76e67a322f6bd2894278891606b83bf79bc8cdeb6ff3d61baf09e692977f69dbd598bd50676998b8a081a73489899fc0fcc80857a95331bc36068707dca77d3923160b9250ae54bdf116b61cb1fe3a422197be91053e7a79b4d95983c5998111562a6d3b7021c491f9ae7cf9798c2b2a7355ced001e6ddb977f42e17c7ac924ac916885260f6075f84e1e5782563b08724b61d77a5dd9b2dc641be8cac5321dea2080c3d510348d30ec28195169a520887a96f974b4aeba5f60ecd5e3ff8ccee79b71c55ec68c21fb02d5ef7f54e0377e86954d144dc9826b2d795dfc6793ae545beebea96dc570362e873882f0a6404e6834886e74d66470c47290140b5e7c67e8a468707cf7d5207f49f5054c09d66a0e644302e3f87720c09c19baf0a6548471f29426b33dfe37782857d0e027ff4f7df371dde6ad242dd2f5fe639dcc6dfd8cf33d49ed3dbd37963eab5e931176bcaf1b0c701a1582a3578054bcd6c32c1deaca074d35616933bf8581ca119f325ac7bed278f28962e94ca14346c649a0b7fc204b98d62234ee350262634065f093105e81f8698ec3daf123a60e444aac665fc98f2e3f80724ecdbfc3d22c1e633ee3248a1990ace866fb39db5ab3edb9468cf758e5bdd832145e1cec8925cde7c23978fe6d98ecaefa9ae2d82b565b3753a929021dc1dca338221e0a07da3c1e73784329fc361d8ba08c519a056c143354bbb537623021ccc73f9fc51d6019ea712bfefeb947389baab9b5beb3b80475a6de51a408a76f2107217d0f9356b8591182619b6130db30d4f4b61f73efa32c04bcfac5a27397334b0e423bee57914fbca879da17f3faecb82747bb9cc1a154eb2fc90b8040244d12fe81feb4cd70c114b98ed72f523941ab7f6dbbc6e3fce4fd0f27688a2cb2bb77b607c9d4b6f326a5e336ceb5fe5ba83eb29011f617be2af25e3b3bc459d853eff3cb56c0be631ae8ec53f7c9e1f1bc5a63a1c7a38b488bbc3c1f2f60749daf11e5cf2acb8b4717ee9248b1192ed28d25769c0a3202884fb7926f018dd9831ecf577a67bdbbbf2ddbaee525e554c7f768af51b481a409834b4f64509d4a8023d2dbd90b1b36fed10e53d1204f073c6ce4044e53f486c272dd804899547d0677da5108f899064fd1e9da8679b0de4492a89d5af6bd2413de95145c91b5f103724d8f54a6b10dd4cd88c88850b8dd77acd9edd27b2063169b2099c5d0211795ecfa37b55548947fe4b5d973b77c2718c729cc0e6de57fc28a21b106885cd3fb2c70bc69ce6653e1643e2ad9dd4c47b13eb345ad7ff6b67e92eb8f64fa7ce7d1d4252795cf33dcd89b3f2bcbf8a7889c6d90127faf8beca9a4a3429ad353cee01f30ff2e7774252273b00982e128871f5538ca19032e08298ee8d5d1eb1b5c4747eb6aecc962541bbf99979e5a71148da581402fde187324b695726af38b3532b6b1faff03495fb3a4a0dff6586a494f3e3fb1036f321235a0c96fbbcc4334f0fae47d800050a3e7f334b96d6b62bef103b2e45446cf5542de355050a27486ea15bdabc23bd76d5f2ade990d11b98a5014c02969af4f5a4595914d4a5b5aef5c185fb85e8dc84d00fe0d3a75bc0fa2d2e0d2909123ad7a92bca8eff771232dd1b444777ed9906abed9f824bcafd2a789466f869c04b8a0d88acfb12a54f373b04df884efb59ee96a2527673ff2cffbd4d88e6ec896f93fffe3c84d4c4d23affcc91bab787b950ac8d1251f8a9bf34c97e354354438f32cbc3f4e437a1b15c3faba9eea9a90f5ac5ec0d25cfe426f95227348e535a11aa334fed344f71dee90594832943c540f3f598021a0dbb05f5049ad3593c05f9c411852740f3d3355d35de67a9eedaf884af9b3322217477dbf60384b23f0a66289d595aa49f5c66b6efeaa68d422162b8d96943b1a354e7e4e80d5feaed883c3f0131e8c5d121f21ea9ffef53d7b65326c1a04cbee1a0b08ece2fb9fd653d19bdaf1ff80cbbf1aad4463c8d82e37737af1c9d8157bdb5e236b6601abce60bf41b215426c3af377e9f34ba99601980d5640476da358d7b839affd58686591114934ffdd926976b3929320bbf1435a1ecf61f94e2e05f86194ac34f1b8ed86b05f2ac1ebffd306cdbdb7450746f1f1391c9cdfb13c9bdffcc353bfc33ed81bfb18d26952138765459e1f8ed0acc7918c8dea2e55de3f4df57f4f2385e4e3ce736d888ae2e931f8ad56a58e26259496151e84d38291d962f0c4274092386d77c861edf799d6f83bc14be988223e6198d74204173f809a578babbfa07644cd358a868236b44979714206ea0f67b124e5ba59cf9f8f079185d0963f4fd61dfec1dd348f6f32f134c981c1d39d09d9a49794d8dc15e42c12f1c579dee9fcb055f7a10a42ff95a58845a9539a6cc678cfd238e5675b25b44d86e81ce12e0d980237992b534d9f740e1502e376eb1cabd4e9bb3203a9527ff9dbe88dae374375e915b4374627163b1758174c68a210f4c5abfc5de6f59598561d229304051aeec3b7db68fa2094d4327729ee002916aa91561979b676e52e49470f1af6c49cc50016c862967fda857c02f5cb9086c7481706e674f2338c88caf30767ae6fe009f97efcd7518b249fb93c32399e7774f8887ce3bbda8316c7a20ef533c0ecebbaba980e6623ddfe9a698e68a27a303f35ada69998674e101c4fbeda0e38a08defa6c2aa306e24fed8ff06f0d1eff6be71b15ee0ceda83ebc9235bb69057ca99b45e30da517191c5f09a403bb3fc939e21a7e55a39df5f6a2240ab631aa2e8aca6e8013b8cfb7007a5316df60933192b50708775e12c634a5f87730255e010be79fcb9110990889ef2ae94b0a135cf677d191d604723fc387606bc0fc4e976f249d3a216135cc14e12d89b34ef114eb2749be65247cc5114109881a4ed485d4f3e9f393c535a064a77b805db01fb3aa37dab7e94533101cdec80061e2af6ee5bad65e51c0f43bd2b880088b0cc8d6b7163eec6cc0a67548172f354b289146fa067d880ce68ca9b5548f1ea1101ed92ef78b79c767cd74b155bc32928f11a1dac0fceb88adaa22315ab79a060c23ac55a5891bee252b0e58ef53b7181c9d5d4c589e93ab96e997b3210b7198fb2de9c56aae074222ef27334eccc170ad0c9841be65a0ed927c17fab22280b9629acbd7947ab461bf88918b16da0a10fb08194b51abf08e177fbc8ce92a7cb8c8b4e7aea32da6ec87d18b6cb3321301ba4ca8d4d152e9049488c469115bfc8ed22f62cd9bb742db9b026324d98482392f58cb8d986beb9d333b99246d7123f72dcff31f933abc6093c7036d39bf04f0d409184b7af904b76a865c56779aed02a38720ad62310d15fd45504b8c3c3794b35791b1d46b1208c27fec52b1768d6178932498b98518c249811d42b632ef9aa48013c52169ec0f148a746f1cab7606786978398af94fadd86dcb878babe01beac85b6b39f7135707899ce3087e697b4e7dc88d1fb79d8d2a8645cfe2703e681472aaead65e2809d8e67ae543d48045d55fe189697c17643e2ff27201162df1d7a425ed129ecfa7b981e724e0651a084c89d0b62a059dc4b57e987a6419fb1d43b89bf0704ec938913db98bb2fe633d78f197e56a913c128adf33ded8c981103fdb4403a0123236904c0baac97f541712b11f602da4454829fbbc2d28eb8f87cccdabc0cf3d2cfda9d2d37a098a967abb31d7b9ae02d8b28775b6aa7351b9b10c6aa5555b17f7f2d2ae0864f119c561e2da89d57a0d03af0e5e04005b98f08d44d40e34ca9f9c098a832be46015f5ed31b377ae761b1b07eacb9bc00be181b9653a942e22841022894082d933dbb81c9c1584f7bf384ee00fbdfa519f182c9dc0b21a193cd0535764c152f7cebdfa5a545ad006ccbe061b6b7cd09cf180f8e9f3fc7179a0257fb1bb7acb452f83d346ef902cbd72a16f2eb5df510f6d5883995aa74fed83ac35a921e66d2e832e5ed105519c671b5c3aa586bca9d391a045c2cc23bd40e89412bbdf78f14dc11080e0e3a6fe6e6b70839a38e106053125f8bf0b463df9332af639da6ab180c9794be74e6e52c235feabbed3797cabcbe7de9891c2f3e987417d088190cd049b53fcca3f07273a112eebd84c3129645dad3f10d5434a3a55ee7701c55c5916f1fa69f04f1ecb9bf9b6cc1ac991a256693f538c0cdec323e1d4fe458e483d0d27a5b6c2dc8ac5909df351a558615229c78c1942ac362ac0c28732d61730f0ccc9e2394ae3ce5c0437cd1b183f99adff1818abad71b96845eac85f8b91fa7521bc20ef761718d634b5996356f79aab2865cb0d7c22436220ab5f3b70d8f410b893afb4d0767c9c858895eada01beee87bdda0afec4bfe50974bbf2f32d44486557075c9a0e7a2e6dba8d29982f2c1fc81a58d8625c1cf0586af9407135c0db1ff63209b9934a48999c5b8d3b9aacc8ff613e2764268ff4552d957e40119ca724417940a39d47eb6da5ff40dcd35986fce2a265aaa640d7022a663757a41abcc2253917f8baf313d381060075e01bc29783c425131107a5d1d6f5ce985e2e74cac5bd438ec45ef32cd624fbaf90af39fa485177609bf06c3d61df8978df6b708f6c2a8855ebb3a4e99973f44a1d06fcd5a48b8ecaa4d50f6424a959b2c748b7607287ba80e4f743af96726f256903b7c0d92c4c8adb4115f9bae03a518a0b5d402523396143483b311b90955f4320b25247b46a2a47033a42d4b318945b56b787791bfab8fca53c38b8ee84e73a9b9beb97f3bc73dc362e0bc80f5679c0d308754e552217cfd458503d9ebcedaba9e18f1ec85089defc1140a859e5a6e3c1c827edf1ad3b0a8397feb2f60e66d97aae3ef55ba5e234170bfa3259c8237a92bf124e6017a15e7e9fcde3526c61ac0a1f4fadb5b2d7c94d71f8c76dd3172416838ccfc810b9aa680f86175ba4a128291e2684048e39bc0927b3a2a36ad9c0438f8e4f0065dc24a7e6a28878a43d94713e57898fdf5654ee020ce6387f6897c115dbd1b63e4331f5baae72c759ae26cd09041762c56d8c8395715fb951f357570f560feb41e8cd9469cc50a0308c9efed5fde10fe505826b82c386b548bd170e2fd6886772f95420fe128557156930e7494490c27d4ec67c93442d909d5bb222121a71979a69c845284b423fb4e0e89873a7aac2242a5b7287609930eee25b490911720e023d226e1978ec3f4df8252ae5857ea775a513582f1982384bdfcde49eedeaaaf940b31349613725455c65f25e0fbbd32bd55c1a89b329fba042a19e0b50af2b36807178af6d06da27f3ce435e69a7c06639e88620d7ec7fc99e5517ecac4a421e8e224806c32686d0dd101d69939f58e233997ec35639988992e823f2df2973d2efa6000961bc9bb5e9d25c3fac7c65c1938dbef999b72c74cf2239e65b4f3980d447344925fdb60873a1bcce6a657cad5288bb5704ff00a99cbee1f084e2b758b4630752a8482b9c1edf728b10da9be3c2fee2b23a8d17b466bc96e3779ae631cf64f683c4b35ddc72a8b97f96afa903239a87adbc160747d9c76e040ff8ed3accd9014a4db3f214847432af00e28e08d965f51243db507cb4a037eea26b960ae3d66cd5d507ae65e94e000f7d5a5d660e1a7e6c1a33b4ed71c938cf19a3ca92c2315468c149212a5ada762e7969f0efcce10a03a8414af2bfc679d7a90eee19ce4dead3528460dd608bcaa4b41e2ba78cfc2365069c25f9fbee1aa3bd6ccbae63c95403568a4ea770d4ef7fab31f2cfd23db3c8b874dd6917bf9d6a14c5595066c315e0160124da94d73ee608d9423bffd491c67decc164be12975e8662610bf98f714b96a343a6b4c754e61600d9b3d904ebfcb8b3f78080910be6143331ef0c4e156b0bbd07aacd20e0cd3a020e32507534d1c5943cade99d70ac38cddd9f417232ad89932fff6929ad141f9ac7dc22c2083ff5e105e677125d3c6dbb17643257156cd9bba48dd636364f05db7be47c9e985ece2612ba3d472fe6ac2c5c69dfc2036cf373bb2c17593866446595dcbf669c1eb55c5c3d2d83bbd90533d95a0ef8881aa46108a4c764a663bb16aacb75103a8ebd17a50dabf75189d47a952ae8f51fab265f3b327591e83ca4858b74d195843701828341c6d2777efebb8b1ce70b8f16d826e7248ff364b29f3adb21c28db483960949e70a5aa3b50d47deca4abc908ab9be471e25b1f5b2103d2e2bd75243de7896caa4837bb93b7c311f0b4e95d9ef609b5b61749fab516d598c3ce156c77d85c7e84091b7d42d43d522294d8b1235e875585a24facbd9e95df8f830d51acb13f819992ca9bd1caf851edc1549b66534fadded843a29fc48b49200bb1961e5ed3bfa573ba5f943d5dee8667122eaf984af44657ffab8f5fdbb0e1f80f99b4cf334e36d1da58b5ecb9a90c3a398f65fb8c6e8024dd04c52b626f2e635147e31d2aa3c8bd7972f11c64388f2543fe0dd735d9b4aeef9b9a2433db7e68a93f9157e7ef1ae1dc0d4059c9aa90067af190dc08001658bfc108368d80daa1cc53f655a386c5b316da4ffa7057551616cbdb7a6fb9d6feecdbdd45f249f172aaed4e25952789a9c22b5cd61cc5f05ab5e7a1c04c8563ef8efe75e0f98ee5835448efc0896645989c9a236f5b2d0c72d1428902661af8ac9899e84ae9356b0c2a279d61d4ab308d594e59570a2cdb5d34860d3e22343bdf6951e4f6d51b1c5e102d79974f4ff1ab8bda1539e92db810adcf7542849e9fafbb5a61a24ff3017177f04fa6b7c6d9bd263ffc61e4c80bf359d7f47cd67c4ec3ee89e547a7b547fb3477211fd368d13042ac816656cc457fa5289f3a4b68a4758b67976004b981c8b3bd41b3b4d60f18676dbb41e357a9c424cb4fcdfb2ac7b5ac5990c68ef30349032ed197829a478b5dfe1be2615f9109c3f9be8c0d77fc2737e431f5a2f9df836053a13b2e1d4c49fb154f97369be323c2c1b56360b796bcbee422fb4ab031c17965036692a705256ca29b9b89594d186b6a0cf5ed76ecfa928276f815ec66b3c9c6bc9ec4d81545530df2eb16b0e427e93e421c31f47a76f513a517ed5301a2c274490bdf5e2c77277dce802bb1eb75296bad902da054f9a8611c5d9a7b233522098c2a5e42c87ef1c187d2544a641e0bf2352bd6e73939609b2372c2aee72fa85d586364096656caba639387eb58ded86fb196098cbb475f14f4ec7d8969daf2d13d794641bfe6276549fe8c78478d1a20afc5b96a482eabba316100cf0291a2e608df02700a7260a5795956d82e434bd53811d5b6485e83dd3371629baacb0bef649b5ae0745cfe0ed48c807b4661beb1e892d99f18943df4bd18647a037660f3d1836cda54bc83a01240985cd11295fd1f7e58ab336cb7e43c4a91d52bb35da6521f8799c129d356dc3b023d9ea82cb9dd2d6362f9a5efe7fc472916e58e596d82be6f8ba749c7a15ae8618d5d01c529d72aea24555a73fd549f784da90de412080a862fa5da1c724c8ef0a75532cceaac26b80dc46e44d249c2eb086e350a91232664bb9af1a140364bcdffab8170e00a76d26b295cb1825f5e0bd5d80dd20c97b1a19d7dbb9a17d5be66764eac4b329c9c1a424a183f51960daf8c91f3ff3c0924be1fe2b7415d5656db43f188a0cfa0f146955d0c32114ca70f7d40f6de905d62f7d1a0dcf7a13e3cc770e51195e69bf801bfd9df51cc8d260d1cbb7773f466b76d2516b2680a90f30503352515d52656d5d9fd4c51a7da948ec098eed847d842f3821fbac36e77ec8c7401d27f60ff82972c3c927d795a04b800aaf55a09aece178cc172f811139af24e1c6ac2dddc3a9cfbd7cafb51aa9d841e4585cf79ab17d39568c3f11c80d309203b22803b041e894af1e956dcfa70d22730b8935014495294ce0ab42c456c9ccf971de9a464a1a4c7fb7e2f9af59cb5747d3d40b4aa66a13fe847a5b41c75bcafd895240bfc3483a6250ba93d02ce64f7ccc350ead35ea7312d54cbcb6d6837ab331df28f2ede6ee7ce7ff16b80c397df3633514e502ea8ea0fadc2d8a7c6a834248ba01b9d6e4814c0e987091104246578d2869069e98b3fbda2c9deba383b5bc692a0df1e390eb9e59bbbf437704177c4990a4b47b57ce00e86273107a2d87cb09740d8dc00bbb19bcc3d9ce96cd52c0bf761af91586b2779da4ca4c359ad8163eecc7163ec846c7a5734c8fa0dfaed4957effa44862176ab325e3578937431138c0e57eb766b3b188be3b48a4e7a80213674831264e1219f745584b8ef837623e652d404562589a4a9992ab17f3b98249e58393fe927afd3d1f97cc824040c2055b24908a033b339a4889c4bc058045f7d00542ef10ed5f21196be603fb7d7f0544932811f1781008031a29516516efa21f2b622c3b948f1a9dba2190f6d30e186d9343e68df10162ddeb9c4c63bd2603a22cb8848af614c0a682e3ce4f92c140eb000a72a764a60251080d2c731578e9b319c51e3c5a9652c309fa5bf0dde1ad73fdf2c4f1ddc82998c7a4eafb9bb4876ce22023c90399390f4835fd446217147677c0f8665600371e2c6d6aa00dd4218b30ddc6f06390dfb925e7434d577b6ed45e8eb113d4af8e6c10e3e838cfeebb42df66ed9647ce152d6c721534d1860dc1fb116f7bcb94fb68bd7c6c106c5e3df938160ad47d677953ce4036955836874570f080d4c64a6c500c86496af1b651998e04f5308f1dbccd262a67969f6874121973b8be136b97116e9dbeee20e2959d28b5761dab2660b4d548cd9fe62b06e59593e1d2365bc647fa70fa16f1a3dd8d83c611cbbe3d637d8ce0ccb0d363b3f1288ef8f5fec1d925d00959f80dbb3bb0604d6ab976304c3892b964ca7602abed51e002522d544f9e4bd90ea1e7201b1db55569c070feb5d7e67982dabc681f7612b9086cb28685b510679a335217235e7685bf15a10114a483b7acb5bb6f92dce5d45c2448fef96d1ac07ec5763c2081ff691ae46122746a29388fa9cc28843961bddf13dc5dbd24250485e0fdb7ad5718ad3bb49341dd25e72e90d69031ed0046740a7e1b8e6780dfba6b33365e994ebe3c69eb2d2989d3ebc1e2e6db560426a30e777d098df7a6a206a41763c8a1b9efcb5281182c912d0d41f975feef10aca45ed1af97e3b4a8f5def14c4cf8bffc70b5f086a247d6fc9e2d6b20be0c209a5bf4af6104de290649d8679daa1030ca4217459744c470766bcda62671b53c523f37f2b9f186e8a5a49dd44c3bce8c8103e4f04f2e3069a774befd1885f9f98356439c523e09f9c75ad2616a743a3eb22724ca9b3fbfaa6f214d89f8d34c5efef99fa85c7ddbee5fbd4648efa42ca1403157fbb92636b0f6c9a81df9fef21d63b46ada37bca028ee479e821e92e7516c71d25b897a3ec2b0da6af4b91f22883ef564287c9cd54bfad05c730dad45b56f5c9fb16aa6a8ba388c80201382d39bd1c934c3fe308456165d083ade27b08b9f6fe9a6e9e5ad36a5195db4ec98537a96f3f380570e64106c078116af369b6c1af842de33337c7241c4f8f8a67858e997b5d3e56344d654a2c3cef33578de1c374270c8b06bef01c6cd258e4acf634c5b7bd300cc0be9b173e0a13f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
