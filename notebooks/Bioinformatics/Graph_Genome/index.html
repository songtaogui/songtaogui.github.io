<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71b048d17f06b2370c4a359f9eeaf1a6bbdf2045e1d2801995aca803fa894ce56727f1c044d978b817f9d906c763f84d650ba0daf697a4c5c73e7afc0e6d4eb529cff308f9ec12ed09b5670403e1bdab4a68128920f915dbb7080f2263f41d8a3368fa3f21f55c0cf79395ed4954a41d7fca3b8c788a7ed708870cfb6bde0839aa78caf886df1b3f4552095510f194616f4d9101f698101394796bbfd75bcf2960cb94ea34b23a08fdc7dfc096247450427ce257b7aec37555ac257bbdebd174cd7f45a7ce8405477374d409f19067ed6be324e855c432cba1540a82943ae7bdd231446a91d8559c32759a05da82ced6804b4fa5bda200e33467daa5155735f5ccd2facc2206d0e09dfea97e15f9496e462fb78a588658a34130d3a3b7564c14d7924ada0e4f44b980af564dba0b052b9807a4d59bcbff0b5e479e9bd5558dccbebe59a11b00faca47c05823f93be7b832d3152ec14c34be925dc6919425096300ee9d1aeac44d509e4ebfaee4daa533b8ad02be6efe89e22da20c5d1c18654338b87aec383ca9f39c422a62962c740e8018c1e2ca1d54ff52d59839f86e350c0c2fe04edfcd17c26e93553828c309268dd808f1f017a61a4ac84af6dbcbca5dc2808eb0d68f71ceb0cb4ee3fc49e6e1fe95566fe8982066f824c0afdf4fc2e2b5ba2d9c0458a411b69b803230eb632ff10d8d979c8280c8951a91a0ae016dc9170506f19a341c0d7a89d9ce42af806a09ed039e4401c937184eecf1fc4f197734812e74fd32ead13e943b0c74530e6cdfe65b13e43e0924e743c5d0d0cd5cff2fdeb58ba86b1dbbfe03dbd67cb63e5717a192427fc859a604e6f59d578d02dee3945ada30ac3f39919fe1e0fed8c852782704fef29ef5fc50d403ec42f80097a01f48c8d8d38277d3caf64887e19ef840aed9c2194928cc3cda4990633fba2f55f9e284a80543df514ca368f456c181a871a1d5125d06acebdc8f2d4ab763138b97f17354a265ef0305bfe3b1707c37074d0130305d05958ac5aa9a5d95e11fc921051ec98137c848cc2830e740256d4ace528e1b6e11bdf1e1501f4f32dea3b28ce7818e3f0c926ecdbaa56fc9815b3f2f7959f38fbd2dc07d4889bc09cfdca8eb625c7939069dc8ddcf834556af33fffd5024ecb2eb20a4baf15b8a8ce747759236828e4e34e02bb3b646a1318ccbf48612378a9ec69dd5f70f4025991f3b6725e4006eaea5b6d60f4bd224d873e0065489c65d0df4e8ddce114f7a746c590cc1e39b3ae08c562c409920b40932ec8d3dc46eb246bf1f0fcfb4c60c41cab22c6cd8365cf2a3b36f68f99b3a252de839a5dc6bd10ece1618076c77d690b2ca6cdfaa2cef96f2b53e032b44207d93d8aed6deeab0a3016e06f35dc1f35536bae595d2e061ebfb1754a22f391ed3550ed8c390af8041f7c8dd0c812c9cd87fee2d690fdd3468d2320b4f0ee54016118f2357b49371a078abe92b9088f84d0636051d41a8d91739a992a7d1f7a80dfc0b0fd2e705f342d91baf7afe98117ff6fa97d786d99cd02513195526fd272eab8f19b64ccf3fb67bc5ee9580f48275b48085d77d7b77eb28bc9a341f6fbb2f480f652abda99764c514a2ecc3ca67a2f909139dcfc13e313f66bb10f266d8af23c07b3489fcf2c889d5b98a8429774664ccc50fc36d78a83827496b54d4e233eda10f05778bd565b32536d2cd847fe2eb2b83d891cc372ef90b4954bac81678761339a8aa2d02fe4356c80fdc9812550b1200b860cb82475f9447fae29fe54814b996cc441b1a82f5dd400847aff614011c83b6203499c6e4eb51aa7b0ee1c968b4bc7db54ef88d9b4b26b0798fab65a094b46f2a6c6c8fd1d88926c6f9b243f3cfecec6fa47333ee08fcbd92035c371da388290a08b093d24c8880d119793156b3209073839b3a300dd0fc7fb21c27bcaf7bea2e24d3a38922bd7e1f57f717e814769ee1576333141895fc6ee9f6875329b0fc334fd7fd1c289a589d6cf2c46503b89788227daa2ad45d55a94e0226d26d6ceea8f089f9bbe3d14aea794cc2a05a1e383ab817116459e963724964ca0b0d872667c170fb94a0de3addcf6fc2834d9e37f67321914bdeb86b54e76c74d1a53ee42e4889b2430203fac085cff3aafcf03fda2252f6acea38e5ce94272dccb2085d3f2f95074d7a533fddc8e333c66d036a5a6d2a626bbcc2d2b6d5f3244b8f47d15955b35ce14e7a23237035d1dbefe21a9aa56a16f6b105f4c7762cdfe8d9ee3f2648048797320350a0fdc43765560116ce35678b97bd7bb9efb723b3a72941fee3a7a9ee972cf588e919a41e73c0662b614d4569732e5935a8934d5e831d12e44903c2fbb550f961ea3d4fc193179d73acd10030cc68c89511a87066b0deebc5aa9162068022395f90bfa1cd8d57b3e3fcf44d50b1029c43da93550a6b3b04df88c6d1d238c8ae7f867108e7c1bbe2a7267821766e339a461e21185a2ea5c88d7194d7e3ea99930dc89974589dbab910098f3c3a1c7e01e3b6672d0dba66b9e980b1f1e081d9fdef8ad9eb912618a906eb9dd1e6fe13dd5e9bc2b7b11a943063231217fde0d4777b49ad408f99199c6ad5fb099af4c5080123792be1eaf1ce61f2dee3b5e4fab80d4892c85772fe313d441b9002e26038479d80a978a9afbaa754aab71a1d30617bd911a4bc137244c95e5527a81e88160b2aef9879e0bed18e020d32aac54bda0a4d4d86e87672615a9052f2e3fc1762b55ccef8108c96eb8a67e0cd9fe27651f756768b5fa89f173d1858698cf3553928bf228980e3bc4ecb4c98d220ac47309e04e53a87a286d443a7fa9414c15afea62c261155ab8fc5060325d1974317d913fa8bd296435ce67712ac5838701ae86c072f96c49620eabce8f76d22778f4cf658c42b10b4b7937da751e6863fef65b2adfbe7c9d2d5db9d41d513f115e141f5a9f5e8eae8c3b9ab6affca6f11061000ef8f7cd68f606c489dd8c60482169a1552dfa2d59aa7b22847fdfed906600bfbc53a12eb9264c1559aa045ab31228c9976460b921faf365774273dc9ecc8f6972d228f286a88d918af5e138d776a4c904896e67377ca77c5aa7d084e37005d10615f64d2d222d8d75d06c82c909c40ec0ab853325d14c171611c5121a01a6429a8d8ed9f178d599cae6161dd656593f05bf7a190746ccc8c108d434b3921026e8b0e36c346f156ae6765af0758919cc7ef9e8d07b265361be9398a8be0878824681b322460629238443ca96ccf458221d766b2d395a355885be775a1eda2d1c10bc1ef92c8e62b844023f260be4a86958bcb67328e3363132e97812c0f91f02663e141e3e1f93b4cb618516b1683b36c97d0813e070bf0a2510e9b12cd0303d6bd1a143e24a4867b3c826d57c2f1e418cd69e90897c0b5398a47e9c68a1b6e776428824c1e4e2485d9974c197f74514aa7d453ebf6baed436871b726492471fad5b780a8e2180081e55df3b5394be4fa2b09a93fd548267f720d13858473e223a76b4e0abc89cef17770b20128849559314acb0bcde85f01781b39ef9ab2360a3fddbc8ca8cbfe265599710dca052a117edd966c110f79052e1d110bc3ee9be7fad044d54df3be213bae8e637284477bdd34aa1ca155378a32c0f941641cb4b321edc84e6b3465bfd48085abc799e9a24716b3e494d9d6afed1cca6c3ee04d4bc6e28d880bd2787b9e87fb2d48ac421b5b9255fa95f71b73ada6af19a4226b36d43a8c5d55f0d8a260b2487cd3f07e81294259c36892893744773aee13e473f6ceffe046b2a465b207a59ae1f1c38436af33febb3a3accf05364e3a35ebdf80fa7ba801dd156cad5dc4f7ff9f3248acfd749a5471a134a3876998f7bdb8537eb6fe05e0d41564889d118291280ce60dc7d9b7984c1713f7c85157919815ab00a7d11941c99d84ba1e1851519a687e9b50dd9e48136e1de309071a65ff591f5d176d8e46f921b69646c60c002aeea29c649979af21b98d5ef605b8c5161cd673478da66388f8cf07dc988d7e80bf0a7ba782839463f87446ecc6f65f295cfc8d5617ee3a939b0c056161fbff267ba301b4e8798c301a9408e048d39d95b22a49b8255fd333d7981c4cfc12a695b2b4a538b215f229ebce47b9c235338a1210ee9b7f9ee3fdc07089d08c6dab952c1ed4417dd955f0143cd1e5a3771936126179aa98bca0fb3e358c5779ebbc57a0d0714acf0c0440ef2b79a6271a357aa825f40380ed1d3e298f359e49aa6a26d69caec9223f56df216eb4046677f71b015cdcd84508a9a3876990aabc3b135149848dafc84b77540468724c8a93692b88c0525f96abb6a51b714956880ad12db9513fac80ca74604d85345acc2878d40ffcbf352d6342deec3d087058b7bfd623c1c1fa505edc5106500f624902c72d865cf77cab185aca0e94ce059d3f5ee9fd42886171e0b74a99be793bc2dedd6e677ba0591d1cac9e8cde56a62b7b5659b7f4f8d34e094c2c4bc96f7026592751a8f513a66bbaa5667a0d20029a15dba24f6b47ac0bebc5b8ee7603d313a5a2d1d83e577dc89f62453f8971e3248d5fecda28175b083271ba0e3c890fb913e5e30955edd11684d84a60f1084342e5c5d41509a224c74321cc63d8dd1f0abedbca0aef6032e0cc16749c463c2aa84b212910c77653b095784819cfb781faadc91c7adefc45ed4d8329af97876385262db2962ac0eae670f601738e975f81ba5e1b23719ee69217e9213de4b9cf85ea4fb251c80ffac46987eb7879f2e5a3ed5b480434192fc6488311ec4ed8a86157e1e1bd133f92e6ca6e5fe295bbce87befd8eef07a1730f81666d46ba3787a652fbd08066fc64a3b6b675f3a5f5a87590868dd439dee741caa14a3e8507aa3f231c55fcbf2fbcbcc2869d46bd0812bc75421f0a8ec60421b2bab62cc113e0fcbf63458ae5b9ab5fd9350774219f75e914f1c9a5ca8d6d543ddb5fa115e9a87499fa0cba9d8b27d4deeef954a8f3c9685d247d60e1c629bd2e5a65e1bd3087c350ec096b14a0386151e6bd9a0c79b8597c5c7e6f042a5927341006d5bfcf5eadb64bc63403f03ccc109d22c248de9abb538b948110a4e66e0bcf6b4f092051c9b0fcd824cdd3df4f6c168a88436204957b4535a09f869bcd07f8e47248e3a05613ab861699769104e7cc45ac7f9b7b194e3041bb01e04906f78d26450fb78349ef363f20c36f315c6da7eeddd5d7158a09e01ec0a32a01aa63b2457fda93b1d86c91f693009da3f7e85a0ce241a7924dfefb4e4176acaadb7ed862ececb1e48af2d55b57d98ff30c391cac9cc3e0c26c1785c888a26424dc387aa2ad74c7548e9f73796609b7117af19c4d4d97c09dade1e6d7ff0bd3bf2b5460428eb788fb77e62ef83894438c4024840d4bb2a659089fd3034e397c4f1f122ab08979dbfc652ed919b014da73d5d286d5320c92ee42d022cb8fad6b507d4a2a2acf0efdec342acaa46fbb094475292c4c6b73c408118640c453fbaeae27fef69b28781c45b9e6d75a5b97507dac390e25cabeb2cc3aa317d2b7b2bff1be2ed43c67feeff73d95dabbcb0578e94758ae5815784f24edaf5a85549f1a671239ca2b38e75b631c76dbf823a3e03fceae3c58c6eb0024d25ab7776bd33826b0fa92405a6820d7b3ece95a8afee84753755a1a6965cb516ad0f1438aae9f10ccb8dc530615f40130208ab0968b44bfac316f5f6b8be328553ea8c0398c038500308806a8637deee0f77097db57c87cfc74be7f8ffca0beac68fdef6841cf2403cf85f16b653600f815cd3c5b41bcd97c5424c11ee6238ea9ab7fef231e3640014813529465de69cb0ec81da5078528fec2004121e7926c60188b3571b4ba4ff4a4e211519288e34d2e855bcdb09ec8a2aadb04b7495a49ebcfe3218412aea89d150139985bd0ca1a296a1a35f01c9e4dd8d5ee75d4eec59e0d07a030c62c1cc222f5c8f2a7322931fd16533aeae7f27f589f2a4dacee353a3d4ab1de3a8ea1c58df8139a729b800a271bf420f22178229e62940bdb62ac648cd2bea9cf1d3cbaf9e3225892aa5877f410dd78336fa824a6ada1a03eb360274080d9a4a87897f3f964ea15747d0617439465f6d4df41372eace1ab18752b2b4d6b34dea876df2826afa39bbc9bb848173dbbcb5e412bfa586e199942a5afe74dcbeaafdcf97e249aa5551f20f546d0bfda3f134d9ed17c6a179e0486ce40eebbdbe4a98d03bdddb4e64b30dd92c785e4388149baabf12a035bdcd7c787a8b4b8a451a7c253401ba73bf32fdc20f7693e3e822884ba1773fd6e0e56c48ae44af1f6225fcc49787252cc3bbdab48cc0b738d366718b0984eece3cb00517d905a6bb8034c6471f04acbff049d1f03d9a1d762bd05a66bdfa1c08e17f937d5333d8d20997c2e21b2cd7f9d07bc09d206ea1ae41f734b06fd9762bd63b8aa281cf0f1104bfeae204c334b837f6ef178c7a043a25e9ea7794380c36148ed87bb7346aa68a67639b0fd65548a690d5ba9b4ea65895c9f8443a3bdbc857e9f36b9f7c7b384fa3abe2e9d863c9c875e927142d019032cc12e8f48c7ed5699499d960abd8f8f8c8323676b8793e75adf60dc3cbaf3608f15da246a3aa92a2487035169fcf70aa9eb1aea8d869deebf40729d3f9247c3769bcf74fcd1212423fcef0dfa2f50f4cbedd1e716fad44c678c2b63e350540c27fa66c0cf7608fd3d865e13486c94353cd1c7cdc0be03ecfde4a03a698cb2fb126cf877f198ffe03abe143cbe21bbcf3fed959ec7b96f84f5b787c9ab900b07afb61286e540b3d92b034ab245a1762d0cdd169831d8089e1cc65ea1d47d0afe9ae58d871c42a6e8269b31a34768933d071e5258d7e0a47a18a2c76468ff78b1c5a280fbdf4eb794abf475b6ccad408c8d72826846a53d7e69831d98cff4699ec84a4faf6a4cae7911bf252ea7f28473b5e2d9b362c3c89c5149e97972f881357c3abf6d28506404005aa347e8450fcc5f609cde723ed68ebfa79534c938fad4b3e31647c217a5da74b23ac924315b408a910cf6642358f1a5cb30bb63106bf31085ddb992dde76c80625bea916a88cc4c654dd98e3b7aa6913444c2895296a05ba77c7ce29db6b1a6cc6955ff890bceca70d0e81bb8e42f7fca3fb024759786f93214becd42832832050847f5daf249f77bf17ac320e50c70f832819d204fa28f8767837b962235875d048d40f5332d278f302b2a95c1b902910db0c61730749dcdcc607df2e8de849f8e9183014a2b9f133aa7dac10eeb7c3fa07d3e56373af9ba52179a8a2223482dcbbbbaff44316652ef862c7209327b9f5c47825eab1aec0d6840c31d8357f68b8c51031996c4d939ca157e5322a2596838eb5f0853537422745596a7fa287ce66fcfac26c4bd1d2e5b607b728a2b0f292f5cfe1311595475d87d55d2fa2e1506af720b05a9786fe09bf5587cd6781117883f08a2d9b1c2396d7c8ad7ed40f2e73e80bae88511443db421ba3141b8447b817f334d0eb913f004144ac14e13272b81f2f97e022cd1fc67def6948b011a9cbe371e42d026446f33e55ce61df147a1963c44a436aa5f8c93b22866f07dffca2247077c309bf31e6857fa35ad4a7e1f5326189a1238dab709e8e6c38b6ff394a955f81f481d3a492848bb21b936b17c2977a8167d2330f9f87ae5ebcb0ddae0c171d98d4c7d9c7f504e55ccd00c7eed2d359d2b7ad4fb2bc460f813fffd3bc25537758ba57969012ff260efcad1f4a287ea3b6023c003abf7ed4c855e91e71a5397569aa6102c6e0c3da15348e4dc17887a64b63ac012b7f41e019735cd2c1f5230098ffd72ec66952e16a163dac9bb6e285f13cc9af62a156f458fe690f1b34922cc525b294da7e0a36ac543d39e814ea9051de780c12d808b8c39370a2db6d4344a28213824640804f97195ba5409bee373d7f446032d0dc7993b8bfdbd193bd94ea47ccb326c94250668433240d984f07aa6144a38483429335a24ea9c01341553221c6b8b336eefe73a056402419e9127ed56d1d35355f995a17dba13c48cde69c6828c3c480873ae8abfc25917baf8d606a59c6b053fb9d497574ebbbd6369e53d5b47e293a81f3bf7728c5a30871e8e1b95bd5b142138d8675e103ef2ebd10ef63358b00bb1d5766d40d3f20818b60d212affbe71150d8d278ed18d4b077efd236c5c2fb105d614fe12ddb7912f6ef796a1f74be9642054805499c38de714f4fb2d6801e4dca0c57b6437ed4a3cc872dce2f5c04186f43f81e22b1b9fd8438bca2d6eaefa079cc02ccc39df5f889460df9b2177699ffe0c4c7f6860dbe4a8fbf0ac98bc1ed7bfc5f82eecd64ee8fb412f5b851e1766c30cae52bede1f4ae8be8b230d22d757d376bf540d0aa3ff8925dd2f873e7ddbe7d6657bee62416d806ca863bd1fa0f5bee9a90a95adfd4bd81b58f3e44937a57298620faa01d389bc910481bb418edf7556e56199b92c6ab750ab0961a53de0940e4935e7bff410cdcf523037058fcecdcabfd54b864198350005809c625cd80445517f04b20b61c8f3deb928430ac05d62b07c0cbc2fb4da08816c30feff0383a04469ed489718526e5268d27db837718b13c671968f6d36c6ef7d4bc8adf4a3da708519f8e35f215c41cfabd99d9656a923e4f8211f7b09152ce4cd44acb2b753c5aa47dcadb6a1f15c5fc1a82bfb63614d6ee6a25b6fbf26e92e51a2c2976bd5d4050048c969254b185eea1bf561f8b4b59f71243dd6e128cb4fd8234b4cdd5708bc2233462add512987ac2e3d9c578b3c53f3bd7691ab42e9025381c9189246ca6aaf0141274e2736e08237d5ffd4475dc4ec1c5b86362a7a291fe03fe392fa9d490b8dc82bac5fbeb397d14ded7ff0573586c0727948f7283ef128b170af92cd5e60fcc7f953af308bee583915f6cc6adcd86cd83e8ff857fc9bf9e9e74b063316595c5ed5e70c328bbe95e759e85e818bb9da6909bdcad84b31b50daa8b3740a947b34f0fb7d32413f3a78f1920617da672a84893ec3728b83b77c4807a8926f85e1951a0c2b07180d1434e356009290cb833bce109aa56d49c87c25391419025d4c47b437077df0ed0ed737f4f62ec6680c72de93afab4e124294bee8da35b85af3a2331c304ccddb5daadd73f40391b4cda617c4d80801b45b145508cd05803a1f06edd3a622f0a822e00e5df78717f924e8c2497ceabce047eccbd2fd34b659f137db4d5b01e951ec151b8d639fc1e89e07151e0367d256a8ba74677ee868349a4afbbd7ea8193bd4f12bc9ea0da5d2041e2dfeb2be5e6aa4c8ac2fd25bc6ae909fe3336e5ba2b35f6ccbd4fc4d5cf4ea81dd26b21c52affe9e4170c12ea71edb27d0fd8da237607b693aaef7dcbb704f29c589286a5ae8a907efb64add0cd59575a2af8ac3964912355185173b492dfbc174a247d1d44d40b0614841b5322f6d42f092bea6e7636d7b8dd2362eb35e013944419fae0edcc0e0ab1fa812892a12d2a8492208b5fec1b071e5f83e00a0672f5cddbce7cdaefeede8ed709ca184d6c9757a2c0efe566687c4790e538500bfeb05eab718cc1d6f098b5221df68c9fdbea3a261256d7c16acb93688fd8f96fc64b928489f5396f17fbb880ac3dc6b4dc42a3aebbc8444c1c5e36e71244ec43865c9830afe22e270b4f5ab606f03b5d3e8f8fb14b8cfab501d5e14f9729349c22aaa2ca7bd7977e5f52b98dc63e29bc560c0e563a02b9b86d02b3eb5bc333c9a651a1bd963da14337c32e1099766447de7246517ac0db4c65934c3d74c52892957e6dd968d36f9b1672a0765c017702d8a919899a3109ac05cd55d928ced3cd6e61d03a15b6699f67ab0cf89696f1fa6b64eee358ddcdc1264ede455c138492f8c07b5b561988a547a540a7ad629211e7c224cc3396a547f0cbae6d2410b62b0ee69ca4a6524118a33e6ff08d75d930d1dd516ed36d6db4bd2b8fa56f1ef6ff2d18550099cff1ef2f42eb2e6dd327e88f3e06fa0ec7735a175d5fd901a64bed904d4e572c1dae24bc8ef7e0fcc18b8f782af4e696500420e9364fdaac12747b02b3dd24b80d4bcafdfe3f34c31fc90d7b339db3fcc5defe3337d1aef3c56ac0af69c7f6f628927606405a613d5ed80160f8143bf6d8f0b84e6030876916568e6b05eaeb67d236dfb226d7cc35bfdbdd3dd92089770114218276428c63731f91f17acfd26aca1d30c4b41a64688aa0a2e4c202924ba43a1fb23d1d795c776564e9bf2eb554950b7280836cfc3cab6b17c6c556de1fa2abbf09395f62d7b008dfb72338b6e1839c6adeaefd2aed514f6b8628a6965e6c01c3de69bd7750ff88549ebb82f564775a6272eb87a76b7468824860a3d82fe5720cbb3839538b4b3f58fc949ea7a6a2bc52dbf9e9a5227a1f2778a5f8c671244827259f549dcbf59d7e217b5738f8ab87c179e1f08cb29c892abb6768295c665e958eab57e23dfe9a505a03e13eca5bc3bc734e9ebfddbd0084e724f67d52112bf3aef9d8426dab8acec866c5dc09f751cb12068fb29e374331c3bf155a3ffe64fa8a2036a08a8e604324f1e73b39b197537fc7dcd9ae1325a4a59d668ee38ffff9d954b6295a87b3c117e3cb9e494455ce5f2ca38d92ccc5661e5dc082134892e9a85c8d94ae6467dd0a6a77e05554f610fafc6ec737f1d56c661f6939430e2b60768ccceb599403bfba823f31b5d8c9e13a648377b6554defc438a3af8c6cca600eef59a914e98778ae5bf36aa893a6ccfe9ef65eb08538c3fd1a5dbd60f62e5e9306ff06cbf85d78bfbcfbd202fe0e503f500ec9b7bcd577fd7738afade05d93fd7fe74b7d49a9652136a2e1835dd226d6458073f4af3df9de0d5c2702adaf5ae01b78543d05f38856017bf30970383ef940428a6f59f9d87c822ed8cbbe84b21a7d47806de4f13fa61bcc6c78739df40040eaf22da4b68b26ed70a5e570ad0c96c8d331f9676bf4fa1e9a5456706db750e7edee0af371b33138db4fdd978a8b9451106c34cf628ecd65b3edd20228af9a2c5d518c08501f11c2ae390614ffe903e840fd18fedc4e8f856ea26e2478daf406503b08260bc081fb3af77f6c31aba267c7752e5372fdc85d5be6c351ffb97598b90cfd76a71a813e78c14f144e6f783a51db52cd68fbf2175d6b0b371f67eb2d4435946b82a0edcdfb2f5e1fb755725c550a5b0bb39c50f235b9d34ec2da2d46ce671cc13f127e283a11fbb0399e05ca86e1089c25907a04e8612f7bedbe9f4e3eb1971f8fd90208a25c21624d32423f163f70732a726ab54946cfc2a3c31f4cecf26fd0922fd4653364efde0b43b6b63b2b1d60cd15227ae5e81d85c318f3b0de8d2b89a741cd2eb638329f73a47519839970c0c0cfa6a531bd61be9a1aab31a280e1dee4969bed10c0d28be1549a24e27a373df1d2572d0f6471deed5938f6c6e3dd073f48a932bc14302571884d4a7a93733f837cb46363d6792c4289c3f0f38d79bdb8efdedb97ad81b51416c87eec1ba84c08e07a8587d6c6b3aedf0c1ffb29db285b0afab976620b0e51e7548cba8319719c65dc95793a6a028904ccaa6d13a254206e653f3fe3b18a2fae2bf6dd31889e70272d8ebab1ec90c28bc0b3d0319e289a997988226884a804b09902f69998d62c2bceef44b3ad676e92ea1be8dd92b866436c70717830710881d51c6f6f79898c5ae07ca74ec3f32de373fdd3d40f6d9267ac0ad521636e05312e40463a251b916cc5ba272f874ee436f703d060f073f9f19170210961c4550787feaf10b297a4f9a0d762beef15fc9c7713fddbde11ec64a0254b7ef25d299b562a148d89bfaae34ee3732c5eb55b547fcd38fcdf52216bed91a39ed0f2e14397de5f321e241af30503ec76653472186521c81c3f2fe85e932fb519e3c46282b66f46487d5e3a5ee2378fe4994acbd6d98c1748415b002ef6a610b534326de93f150bb972cc8dadf0140e047ca4b260c7df47861586a0d54eab9d9d5bccc7aa2ffb04f49d07babe54d6d59cf54bfbcd953571f03465653c4145329bc331ccf68e70bf5f84d7f960a55c85974d99dd2c3baf7c918d5bc2b895c89475dccb1750f2dd565b22c1dcee4e17e56443a4f778a7d1e0447ed208d62f506b489a719df5af0e1e261ae131c643467aea97af944c026bc5cec9230367f941627179d0aaad27a5b4a9c1fbd255ca67a11e06e0bcb842ab17d02112971ff9cf2c396c6d35019241ab451982b25ccb1168d0a30161f1f63eac9138905da1524c434ae3312c8f74aa716ada452629fd6ed8cbfe39926e82ad4a20cfc2328b50ad0f7cc39c55e56db6aa5ac66c0f368e06d8a0fabc0cd17a7c3891298f4754964591b032bd0178efe1ccd31d9cb117030b630a3d0c87d2c7b6fb4c7eb68105f20b2dce96b14b20370c2c5869548ad9b0a2ffb0bf11158dc320d3c6ea80b2e4dc5a46535aa481feed9cb212c286fa00a6a624412f0b49323e15e497de8115f5327ec8259e818b5566abb2eac3c73d25ecbc2b2634153bdca37d304a8f7c2b10b48467ccffe523fb67f3936a43b7c74d1d4c756714b2cb38019895fe1aa0b9387a16f7777ab52284deccd4fd887bb3badb93b084c3bd14247ca915a4ba5840cb2c013defb68a58f874eb3ef14e0e366180f65e4f46276c5edc3809b035f7b72cec76b612f105daed0255bebab8a902deac79bac4379315cff1d5f006e780c0fb9fc5b470c1c02b2ba96882e6fcbc6c502893e2d7a5be00b94e8199addd493c982bdf40cebe2c1d820323e6e9b34a871ff054c01772dd459c725e21afbe6a447885526163748df247bb7940182676b7005f59330d0aea1cc09243f38929d03c3638999f5efcbf6e183e01fc201c3e4589017b3ce7a8b2ef5acb18feddc5f51fdf57aad8a5312c977856e7132ffecb14690e1ff0528f3a6b6cccb31152ae9594d00d9f4f9612d5ecc58ed5d0b7d519a4499885a572bb36004a7a4347a82ec74f3d5f1e68bfff4c849fb6ef57ba4f13a6cf16b5a9166402f438c4fb7ecc41938f883a1a4b6a246dc737af7de1b680842d4c429da68c79865f81cdfaf6a7c8c6b53168ccc7884674e7783488e2962b8b65c14a2756744e9a06c0e8f92b40096168024e9eb0bae22eb79ce902f59121e5f8a08394fd3735362cd998b7b8842d7f6d830f666e664324cfcd23d2e6655a5f878b900f619a196225bff85eaf16d4ae4ba249f3a2a53333a24c57a62b8673214f6776d3ae74755b498754a6ac9dd02418ae245838a10e8f75647bc778e448c32e6a86430dba039ec61f1aef5d0c866544eed17bd8d3673f731dc6d3e227af5311ca39928cfd96948cb0c255a26bf494afc9c73fdf903c00afaa91101c2b1ae79a159f1da0a8f6ed0bbf913c7bf20a5437ac47a3a652775d34ef53592dac8531307e7229469664626aded477912754adb5bce559d0409b843bc56aa05c3a5674a23937159823703f0cbe2d75ad8223b034ab7f31e98c6ee8ae19f80dd09393a1c842457322b1d9549a63d92e297be2fa0f95a65d7267e9b16f8bab812ee2deae9f74037346c5f08804cbb4346446429a4096e078d470108ba205edaa12aac88a3a202aaf936fd3a530d37a9b22078815144521445cccda5ba274074bdf9f676d1e4c453693ca03a49b120731f911d93f163df57343948ed29e44b931ae0dfb84acd812895c58025b87651e6f7b4c5c4c31559fb72fd4d31efad9bf8efd08f534d66aabb1a1cf02a5103f766e2f45205309a98cc523b55042c8d5a4999088a261dc6d1b370f1afda995321896d4ca1b36cc20cc91bac47653e7bc8e1a245b21981bee8941750537ce9252db158cfeba0b0efdfd6f1798f182665116e1044882d996a155601f5cb2bb6a702b448128fe5bb29174605c8d1cb078e0251cd32d76e4938fe1faed2955114fff30b111d6035ae40b1b58f8d583645467e13bcd365724cbc25128009ab02e689667716fb6db705962c9edae564241c509f3d3800c0705fcfb302578cd6000d4832364d813d13b267ed68725d983589639f34645e2f3eddafcca5fbb310a1693a574b36108ab7f943129ab70a4ea008ae895018f82fca8257438f8e02027944a0f2d1f12b3814cc86fad6954ebc2e5aa6f06e92fbb89560627d3549eb0edba7183246aa539a9248850a3a6ead28b850c373544bfe4a60b82f89bfeaca01ba69e908b6867c3f21618f9c0de07b8cd1e1eba9de8cfac93fd8f7594ef0d8e81a492e40921bd1a78ec39d9317ec7924852f5d87122453c0a16149d9f4fdcd18bed2a8a50b4d54b3442f5b4e0891221117ec80a3ce5f475ce7e829ef01eabf83b15f7a344711f97d6050002543779f1c21c51878ae4dc8c338aebf06bc2332e2655ab2571bf116842fa39957ae212b8a71babb3cc85cf2666ee92c44308f8b94cfe33eda8dd05ef5555ba745eb87f7a7cf7496f0db6ee1ebe94fcbd7a2a2047a9cd3ff06b23ea62293ef131dafb85d17844fe83d372b09a08547d9d35320412ffb42a066362459acaea6d0db176edb8213a16624e3f32ad1a39c956c36f7279f4ca49acddfd0a17570a30667e06b4a4b78463c2a15edb202ff8b5c383ae6d780aab8fec4e875ef90605b153bc06efa5a1ffe2c93d7bd630af1e16f33099708188f80d330353e2f753e1ce28bf25fd61e732815d31fce0f1878432b30b2c969b3c0d2e51060259375ad06c1dce73c244dddefc205890b587403118c00f6b5ed2aa5ee4d27874496dccdf949aad03e6767cde7d4c673be764ca00bf80fa94a1d8160bf98419e69048f3be8dca1e1cce9b0fede036bea940ac29341cbaf0404b4b6c5c3e943001a7000d4e3d8519018cd6e4a808c33d04355814a2e610a64fef66fdfbe20d9c89bb53e8820083cc888e790ab198df12993fa0457114c554f3e0bf26a0a20c1e9a8f964517d9a1540fbdc244babd253629f39644eba2ee66ea4d933f05205045aa68277a3a89a47ead1394ede690cf4dcaee1c7cc8b425e320006a2596b70fbd93f445b269a37ab8891fccde3e7021056b1489a6b997b21272a715ae59404c542bb8d6615b338496ed5b6682b63d51bee77c710dd76c1257df6e5098c590225543a3e62279628399d1c6d7756e705076f586ce52bea48dececea5321e96276fcad6d0bc3162210855945f6aa8b81a5fdf1c0d5e70545138baca7f28be15763336405706ddf32e791e4e4ca1687359d833ff23d89c3e8415ad5385cd75063cf810731c1347bfc0162f7399f67bc2877128787afe294734a7a6eaba5c39e857fc625814455dea10b6ebf1aed113feaeeecd2d502d5ee51b81284019ec9dce5de3790bdc019b0da4d0c19cffc455a42276df44890c7d2b8f2d9288e132c8edb845ac658668e065b6a4510bc4785f7b89e70ce000bfc620ed7186153a7e331584c61465ce1be5424264f6fc3a2b02fc9c5c7a586e2266f508d8cfee434bbcc7dfef8cab8e66cdb65c0a215ae6a90590ad2cc439fc939e7e62a90c9ef2e471fa38a0c42aaab88810733db2f25185b314d14c0d6d85a7a122d152f333b84dbc7ffdc08ef302b50ef346eceec38361e7e4216cf042d83e73eb7cdc1816a8bf3f15615945a959a48807128c8c4e07fbffa600feab87663ceee55295ecdef64ffc6d638e0c80c6a194036a2bdc73e5206d89c4aebb3b82aceea4ded64b494e259214b36fbdaac24842190609bcd2a5e4fb8da9868c92c0e91e3bb86dc5dbbc0debb0036214f8265a2fb83ef769a4db36c77ce84e13f29f2c0e03750fa7c0c7af317a105de803452b68e2173f2802d0615c18da873aa460ee3f9f82297aea102f8d1c4e30773f22f74cb74feb10237a8c924329179139fd0b4662f298d472dd2e00538d5ad4276c8934bb714f2e0c73071abf00d1f8010d7815bd2e67351542edc433a786a900c5a3c12d37ef2a3bad63bc55b07e675adf204441d8b9a1a80c9c6c85e173d281865e638b832bfb098e97df8f51b8e8777338cb5e4b1eeafd8f122265ae084a80437b7d8c7942ff770a2c55bb157622228c4914ac687160140b52ef802c102a70c099a3e142d19e3d819d3e51d7866be0f96680d0d98d1094d7cd30b11c019b1ac069f02ff071435985769ca7b8b98f110537ac8e7fb52bb82704f3860b123f6b27115e7b2f9bc27fb77a0bf581ca5c0aa571e6e5b9424c71392da33ef5f83b166231f71dd628eceb5cbc48fb92cd27b4304ffdbdd7e4d0b52b775dd5aa4690972b3f2ce3148f217739438a850072e7586f1156780da2c864a497ac9a9464cb836012bee1a8f9425b4725132f38444f9b2850b3ec52346f9d53d5a6c0b8d44787e5f4891be3ed28f45fe48c63e0c82d17aa9c828fdf7b32e6c2ed4ca4b099d288fe7abbe948fc5a1118a95841405a2a7b3d44bfb0153011962b9c0549e059b5441ddc58853e09e1928c0d72fbaa385898fd5c7849036fa9cdd2c3fcc62968716e009d0988efcd0c2d96858b12daf0d13ab50a4baf1a9a02a7a85a8c9ae728e93037173b49081282b9551451bf892ecd55a651b1faa9ef398fe12b6ecaac47243a88ec62322617ac07282a5589634bc2aa372173f6a39ec7e8d420b1dca2a650c7a4c43446550ce54fb3145374ae0e9ee9ae313ef165869e85c8876bfeb175ae0b49ab42709df0f38f095e4b0b73b9692780314054aa0691d6713b19de226a995b09747438b8d1e12fe5a6f676b30fe2187cee61a8fc905b94128b4679e22a689036b396ec50a9c038ab296b0cd3447cd2bb5a70e43c5803c87f8416a1c045ca966d1e8ba67a4046d095de9def5b0a884320477cc49e78cb71c37b73e0dd7af7b2f469b5ed68f042d0ee98bbf117b38800dedb21aa115cbba122bff0d51f2fef0222925343dc68b39678eaf6542b1b58f10eb726f2c758dc422a9d37c863cbe711aa06bf6d83c4a5190f9fd5689f02d1eba89d91002a4fe5fc8f558ed71451c275235e0f84cc21138d93ed8cb0b51062707f7b535ebec91542eaaef0fb4361898431a38c78eb414257ed9546475e409cd661e3720b9d37c1dee7e36bb8a36e535609a9ccb6a80c324db00a0fcb5fcc6f2305ff6f00241ea325b51f18eda55fc9e9b5122658ff0a2c766cb0594e30d433712ec4e2647faa912b772eea06fe78d49df03baa27776cde767da29cd0451bb0cd8e2203a0f46134bba1a01ab9ee504b306c8765ba730b73e538e22dbcfb5c8b5cfacd0a0986ef6e1172ffff3dfc3736abd4fdd6246ff19e005d00317d620e001ba826fea89b3ba7326bb5c34c9e4195479ffd038e76d055bafebf198e5916c4ced725b5b0053f37c84049320c527c5a857a04254896ad67e0fc3cc59291eea2cad6e7b707db3d047f9c0b60f22363ae0f55180246ab7a16703ff5e4fae2d35e764a0eb7b4c10b9555fdc123abe01d72bb8b1908e44410fa16503123b03237bfa3974b4c7fc6ddd973bc868606b139fd6d3e7b1055c284dd1445bd14c70603d4053e9ab02767192bdd539b4bc91a4d2c837290fd22baeb14b84871c94248de8da60f340cc9e7b87d1b69efc6cad88d88335206ce5ae53895b45a7631498cdbd9b4be4edfaad138afb4acb4306a0446894c343634a761bbadfadb3998a62866d9bc57f49c22f2dea724d1f3bac30eedfe33ef414b7c36b3eb15a447ca3e37439224041334c2911eff38c4f22eb7c60f2b9334c24c2e2ea72c9c9f49ae22e1758b15710a6be344cd63fbda4140cf9d03da946dedea72b4ee02549ef45fe03e8cd25497d19dc9aa981a65c12fae054aad7449d75b4fbc120ff4c0962578366136a257e9241662633680b0a74dade13f5829761ff4a08162306816ef41db875126fd31f3b57156eb51017972d25850da00e044dd913d0d4feaf0ffaee5d14e311e8ddf7e010cc4ee310dd28f30630ea35d918e88d5f1b9127b4dcdcc056a96155f0eb419bb0c7cf763bac51028e43db70a8cb4a535f0d82a2e31d9c145d5606fc158cde90c7c576224e45af7cfba40c022463b705629ddfad7192152f8b3828c4fa913a6d7f3c10c1157f18556b0e3972b6bc78fbdc65fc26323a189c2427de6cb5c43e5b8e536fb52095489f02c7e66446823986e17c886575bd650507778734259f0a3c9897edb27642fdb658df6e2d6d12852daff87ee2203c95f5e27267caa4fe973c058c543eec870964c68b7671e613ddd98d7030be53b6ed6721328949329be2964c3b7f4b1ea17454b671950753251243367f8d4164d06a2375c0d45978f768382e064ab0b789f61287486964728f0395a5088a5b828e034f61294fd804f4e8162f462a6a9fdb2618221cae3263f3f3d9f16b6de575ed4be468c6166cee8b8264a38b834b264a3224bce4feaeb932be058ced387db2f7128252edcff3ddc988f2bbe051cae7f29","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
