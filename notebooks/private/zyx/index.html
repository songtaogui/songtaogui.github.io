<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93d435bee8051ed906a63c09a7453cfc5a00f019d32aa448aee945ba88880c03f515f1d3e23e86617879ee4d7479f73c7ad701a68cf2367c8774eda22db5195556ae2563dbde01bdff805b3c98ad98738a3681c0ced4eb07fc6fee805c064fe19ad7c39fcffcbcdd9e392905ce86847306037533237da3bde8dce5e69fdd60cf99747dd1d772cc28a9192693eeb30052d46d59807d0221a0f193f3babfbad92637025da895288e4b46e36968c4fb8d1b2940a8ff80de046dbf02f5ba68c52e9957c999a87eb846e76492ec509d8984acb1a1a68d78541bd75dfb126047dfa66a0bfd7aba7812f89ddacbc92d2fb1a9d109784a15140ec73f46ade9e9ee1844ade5fc11cf2903600682bf8588adc3ac6538d1f96f66c5ba72ab5c5b583049509c074f08e97a72ec146806b3670035f4a06011868659f43db0d6f2f7e93c5c6508a5a07723dfa2189c30f853c4ec24f9f4cabbf4b14c53c73ba56d46fe6bcaae115046117658cec90491f94eac4c130cd04e97c5f5e62777b885ddc7b64d2835e577875701b43816fa2d5504f33203353c90967bb1b2c9a9a39bf58272c26733470df3a90413650fe90e8535f36a324600709c7eafe352459d16771380e6ccb83207f52de2a8eba79a4802a00b6666d988f94fb874cd01f762f23fa65805a422a8398b6afb56b065ceeb42a32eaf2aa248ee9d233cfd5474f5d260e8f3aba45eee2d1b46399c82aca2be8bb6b87d9885eac99162ee0fd9c75a22863bca61f8c5dc5c90e103266462ad886cb78c2e34714e283f159198996126c4a22175685db826f7f49f81f941ec766413a00fa703b63959dbe3925d4ec345af8cc08302c1a2a3dcb80245e740d81a541b0061aaf5fb2633ee258255d37b6d5620273de1cb76adb99ee296110cebd364a11f9be26699834dba5f2ec13ec8daf1f77b69e93e59b9880bdb6ec05ab991824c1dfdc4ce313c94da37a687ac2864af4d17cc979490380c7cebea3a555b6ed3eccfbfe5c5933955986ad9595479b687d81728bb0d3eb732ec8fa12a4b0542b7c23e11813ebb4a9c9ddd982aa460b0bace9a31882aa5dfd49e2557dea21a7ec63b9aae3b0f950211a372badd422c654f981ec676e2bb8eaaf2dcda1cff343fa9a565cd6ffccd96563aaf98d82931598f9057b2ceffd602b3a4048d9951f879eacdeee921d3036fbeefa9af8ec158bb59d698258d072f31f47aa36fb11abf553fe701c3f40e87c54236109c14c9d76c221d73235f1be3b97fc2687b9a12f03983e5e0e79a4e90789b0758d0317adf405a10aea64b20233bcbc53c74b426242b29bd3982704f37abdd0f90f13ecb6b66d8df40505888ba13c0f07c1225b478a4aede8dace7becef3ce69dfa426dc4bb342a20f1e7609ef5b300e6fbbda5c623bb202c164b9dd471a3e84fb7df4e34cd7309702d41fba3b14d850f12316d76e07b8be9812f34bf785d117db2cc5dfda8319d7a1fd886c2bb495ef3a8c28e849a4069e6363a0294d69c22cefc5b67e33cc34b18eea28cfc89aa8af869ddc79d7bac39d889e8aa4c4dbf02d013e1c1851d253f751e70bee5d149b51f084e482292ce05eb05b4649286e29e46f7fc5299aa69737e2f8d4e9db23cfb798821e036d63811bebfbb575390ef78044482a0c0d5bccbf186d4f56e5ea72444c73f081a5aff7b0ccac9223e59ec074447d50d37f102918ae31e4e52240dd23d2fa93f2ac04cea87ae68669400ca87e45cf8885b38173eadc50e4879effda3034c91c1a2a01a47599d8dec9e8bc2d3ff471f41cf11fb0968ec32fb1c2d5afd47d080e982e17ec77ea17ce27ae52a0c7c80cb1020968235aca49e2e250442a1a35a1839a65794d2e7c853967efbce947ea292a69ff58bca7f89bac72f4fe97502f821e3b16d6a1ef645e430be45e11a7e74289ed514dc7d50ee3a94d7e43299ad27512921b5a66cedb2c54b3c1aefc773ba6cb128ad24694cd2cc727a27a9fc1a0354f121d7ea233678abb5f8b13eb6312f31d3618d94a6400a9a0b17fbfdbc6d49bd20c30ffdaaf8368136928367dcba0396ff96243cf3137fc1c3b590c891485f646ec28714c9028264f7160e92d19f562e503399d4becb873a60551828e404955946919d8238f7b1d5bc293546e993bc733205924c9eb2662387328df0c5d5bd077c0826bea76e37b815b5a6220a05912739ae8d1deb31a9ebb2927ab9aef74bf3fcddacc790766cfcb9c26c903ad751dccce2b18f8b362619bca6d539d6703f34e3a70ac8b8602a83390093ecb040ec9cb9839624343288f88943f1d91de1135965312fe42477fd131ab7f2f18a6e361a4c7ee4078dcbf435822499ad4461f00a3b474dec9db176b4e60c2b6e14b69408168f7a4499f8753dea295c6a577a53dd8b983f72548429090ea99e399ca51afe1c595a7583f775c0a54ffa45c11e1a4a819efe20a48321b31af34724e780023b8aa7fe5ac84dc54a3edd03bc669d51213a30585282d0784ede9f529645d060839d347987bc20161b43b25bcbd199eb475e67a70d499378f6566ecdca93fc7be0a5a6ba0767da096c85083835776a55d157987717869e752127ee504c0cfd7b6d2dcffd9275cb3e6b60251cc677f700c544c44ba7cb61ca1ad7a10ed78c281885bc6e86ce44090e03c76d5d74ed4b5c84aff74bd1368ff274bcaad9d180132c1d509c8b5a14e5e93ed4c974a64cdb06aea708fbc0c13aef34d05067dd042bb8a8d545d5aa559c97e0fd775fb2f13d271843615098821682457e4a2456a9ccd47347bb3b9c85521cd9a848fdbe1aabb1dd131ef28ac0cf9be2e9c7172b4f05beed6ca799e9e7dfab79cbc61c55f8bbde6d7aeda752ea0f4f42340044728687f1af5dcdd7ba7d035d3220cb4cbc1def3a8d9183ead0cb62b691b263ab5c81a7ef7580ba631fa70b5a9deebaefe05bfde81f92e9326495de4824882b037acbb27931a646653a9e08dd5ccadd2b5889ef734f30cc142cbb3a6d99b19072f59857c8c2bfebdbe6e1180c84c069b578feb7cee3f2f4d7fb07619dca9e0a55c27c8d93cb4450bbaceb7732950a97cfd765e21e371fe3502180a0472592007989ff08b0d496bf2ecc862806b142449ac8023c0d3f492233c874c80956340b881ada1dba2fd95ca880c1dbee272030cbb92f952a9e67dca2339d6e4fddfd5dbac235003661f3b8e398f4b36955cd8249905ebc653fd6697622f70fc584f56149f1c7e8c669bb9fe6447bac7d194a55a23023c950ba9110d253fe2d51e20910056fca9896233dd4974f28bd4193e8df45a2b729d2fe8b99d0cabba1850afa92a4051dfb1a4020eeb51fa2e189eda2d8496fe1ef28aaf5451209418d06546f872ff66948f47ca546efdbe4c8ee8f9f7202a4d3a72386586edc96d69fffaee2af8089c63278ad498baaa0475bc1d9e3a5726b489bf697961f0cf362f8cdd29bcaeae3ce307635e4b2d7876fc9f9ec433ac93bc87afd610bda354dc849ec56ecb2df1979b0c502fbeae1257bfaeb40f854b8451c57638e4cfb1221dda0ea6aa2c8977310a1df67d77b359faac9b5b3fa8862b4926358f0b46fcb5e915f0ab9374d5d3c85ea9861ce94133894241be685fae8e0e781b3fb410214cdd36d85fed950aa986b40a28b1e4ae026b7d92550d5d6e88e8d064a0f1badadc26f9ef276c42f9844e2e452b833395af6e5d69026156f82ac6776a2d39f28d6286f3b1b7d3e46bede7f2b09bc639a9cf10ff4140deabf8cc49b24acdd92cd33cce15a1563cfe761e71be1634fc5f0e7c67e8260ede7e6239a64ffa0006395f5303a188c1adf96905e3b889d6c5c31d6e6d03cbd59f4bceb67755146464e49acaaf153e919aad339fb65c7b985760858077b8c5e22d6873d7c0d64d0a25672d6fad3c628f3c9ca171d729b20310b795675ce936384c8b031d0ff6efcc6ddb8ca70778a54be9d73bf06fe33eaa4c39977a366f1eb43b82b75d73a21cd0221c2dda08407c6fa04fedf0316dc4d4b065ae5545c0e143b27a9f6577bd5e18c4476bfc54d37c4448a3cfd7ee1691dd8d24a4241c4896bbfa8f518db6c09133ffb550c2cf6143474f4bf8b48b786cf133c48bc5a7bd71bb857836296a22b338b6af01a8de56f66dcb0a75ff98be623976003222081a559be12f376025fe6056e975c27f108b951ae5dcbd39e3bb64eec65c1d9de910a77de5286b5232075e06261edfabacb81d048aa56b1554984d2e8c517e92f423cba1a0ad485be2b814032ac8531a271683f72b9abcfa4598f67fe99e8d1a3fdc65e496546736277fb1037b0988da949084a0f25400bc5ef334cf83f08e5f0b1164876df0aa747b63b03d5b2a7940b27adb92491f7d0c23a1a46fd85516640f32b6234ccc852ed19382069054fae7674e872c1cfc8bf04c20d1b9005640264bfb4475ea5a1de400d9574f7dce2115c1db9fd06976407cfca986c26598a3b447eb0d19ef7e4b976549866ab7b4e63e47719cdec1e77ab7d1e3a8f69d02829d7272ebb5cfa220a87df5abfbac600b213bd1e11b75ee38b671f6dfc4b1e955d9d274a441a1dab0749068fbf29f030e4377767284f3f528d1f99c6329ef4fc4e9478ca1a6d7b6bfe7ebcd882792cbfac408af9cf3f432dbf064a8dc5497e5c0c97a149f312cf6889c305095b50ac26c17326dae7e4f81b5a4f2e6d2b27e8622cfbc45373dd7e940b1909eecc63210185a9c0d9ace258e676d927cfc223bb96c245d1a45b2b672d85448141de63884001cc19b5e0520114c63676e6354ece45e2efa4e5b8e51c57cd414de9cb106589d1200919129a731741c44602d996596c3d10ac44e56641d045dbd8dc61f8c30761a87cf233a0a92457cc530aeee1f97a62e646dc908f4e7c36dd84c7f20c1a56c47b9e4d320f010337dbbdc2ede158cd6a3a8d75853700af96df997c67a22c7f61dd45a83e46eac29515f30f277a9341be98a2a36907d82f6caa17518900f77d55e3c5efc31e4ef1b0f844147bfa5b55fb19a2179648ae1a925bcef4f33aa2be8b61b67d674114b23bffaf5f94639290e76b72b83b74a9ce5d6d105556263f6b5553adc8226ae1c068b85cc0f50a08b76e5ee6654cd338157d742e8cec602f53a43a0f80363eaa87d317b68c574510c1cca8883d05f7973a6419183fa6e8d3c89cdde834eab8242dd529f3a0dff00be081539d81895799effdb9b7fdb5ef23c2f28deb555a28b720a5b8c5ff7e2ed4bbe6e8dd355e45bb1790414c4faf18d526d44d766aefaa931e487309c012354cfacc4b656d634fdad78533cb4c782e2ed96a577fe8e9fa5c66ac41e6a26253de0b5dc8834f17b29f64f5dc4e32b745baf255bc0df86a7ac16b5898f3b25eae0c5f62ce07304bf995bd581191b15723dc18c4c4855bc762fcefe9d84f55aaf071986fa11b62660cff71b0e8f952cf451f3a88ce2b3f8a1813e2abaa5cb552d83e2f9a42bde2cc5f18caf4ba76a194124be466af4c5cd9a76a6fef246e955fbfe78c3863c489a90fd5bad5fdc8e1498b392c40af28ac89a7bb7541fd749711fb992a4567ca7483bb926cf39ff053f6cfa30569591c868c78bf92cb77668a61b0878d823352761210be4ab79b4522e3b79490d78cf2b963a37e97dc6d5d7cd735394d8728758fa09c76c49e560a1ef45a4f90ce7340943faab05a7f036f26bcc6d6d39ceeb83384f0c01138f1aa5554080d329a2aeed86e5f056fd178be4fb81fac75270f63d9572d14a53f7e3576341601e55af3f2e4a3518744fd881b88b9381f79c128265a772510bc4203e2700852191b23096bbddb69d5c629518282148af554ea416542bf2b221e0a26bfec6bdb0f0402b3f57220f49f6ae69e2aa2b486fae20c77c6a0f7b2b340bad61b42fa54e9b08d391e8939ed6b246385f748801ed700c1a910bfc0859a89138b2f7ef47653856ee004b216e078806b5084f353b5e71ca65baf53c8200f65c3467ebbe0be6ebbcf60dc58f09ac2d2989366e680dd749558f0b4cb1be8ca031f37ade143a2911cd2048b0984b85eb123ffd5e5d23d393380d3c3e1190747e4778d8f25283df8a2d86b69c29868d500809c8401cee8a1e04dc0c70f1e17cd1eaadb06f377cd2f38b40d6b86f0af7dd44b35650675fdc9fc663269c5d53fe5b49b323c94559efa00998004858ffa501d779f778f3872701a86f988377841c0888a1a23a9c7b279ac51052d4943cfba4e9584c00616bf5a21fc602a2168462fa6ec0c236270e299349465fa9c3185f06497e357a7a20117263d16c39e1e0d933a429665e8be9002f4a6237a7397aca6fe81443782a47ed796274587481e7ad7e21def6b17f72ee6642e8b295dd39975b1ddc8340d469a4862b6b7b9e7a3786767ed0282d75f6061bf22683dd16363538921926215dd30ffb8dd01d6c0da4e92326b4ea3e79690a81bf5966ad15a40aa326c052bf64b5afadbaa8d46662b96586814cb0297a59ba2ff7a99efc1003cbd199c575b2f37318498e121df245ac94e6c84fd13a90f14dc313bbf0163828187f8738130343843bc5a2572b97d934a8866c76f8c5ef4a19df299e7eefb1affb70eefa696beb523b6b15ed4d7d1cc693f9c2096b40375f5f661359cd15fc3dff522b99b36386c7736cfe468cc8e41cfc097c20c075ab4113f2388378f326f5f6985d956d5c3adfae16a82792244757ba419973b53c654520ffa654309c6531d0955b94ed81d1d5a2718b10b298d9f41db3c38a7b6a340ce16f3c74e4b3440f9b8b83a16727bc5ad2a0b9fb1501299b861aaad3b96541eff567771d1681b403c339c3013fa4cfc8dff1e4263ddb34d2da6714cb309dbc04e07e31543936a39eb457dd0c377b844f70bce85095fb7034eafb59d289f663cce7fc01f8e437937d94aaebc6d3817df44304772be145a3141e342bd466a5ee87bafa0eb5510d3b9e0835bdae0e453855411b70193dc20cb1a2c04bd90ef0781e0122334326f09d6fee4d91afe0d61802cc2a1d3f8979f86e5c54a9fb6bb8263466c6e5af29b2ddf88764c53960edec02b0b44f76138e89b7171a0c6857c9c36db687b0ebd736529291c2e541cc45adea7e65b606dc24c0812c0413b5124ca46c2f5ced4415f51c6e4ea39eaeedfd2fa2e852b8ffedfae1923afe689f0460428a48ca0ea5e0995d942f86f731fbd143e53b4ab3ddd8f4d8d9e1848591cd89d4bc6d2acfdd13bb8063e207bf3a53b888a0c277036f751e04fb8b8a4988fc8257b9b952938f79516f856cf9536e67553f7c673ef825ed520267aeed2b1768bb853333d6201d8bdfeaf76ccf46d48e5f49cf45c4c77484b1e3613a2a3bef606c37b1f3f5c398f9075c61cb4018570f24605823611a4829da51dcbcb29dbbd04508bd7a1a3a5411367a8aa173239c91bd8e95b9a65fe806a59d512712464745f90432e281d6428c69b01fd5cfe0a54fa900149f82559895a723b20b680336caf4da6b2471e7843d62de04bca6d5aad842cf4a09830f47d5858ad64b7d5d15bc0f0907b1665f84cf079219d2fb9f90c577f9e6ad384f326b940308f31873797e25b51fb2e87995ed71df94031a2e539bbe7718f42b736dc06c1481b15ce64146b71eceea6e219b49b71a539333cdc85050cbd3c61928536ef21807c182a3c0a1bd0d73f2cc5849d4649fa30a76e51a191adacc003a49eeaca6a3ad01b98c4e1957443c0f1fc0de89dedf02935903a87627dc53d56bef21a6582da0598942956a92babd3e4181189582ee601e88952b1ff0b304d2be70502be650c0bab7bac4252a3f84c0df83ad54e192896352cfd60ecd40f4fda4a100b4ecfc4db280f949cf575888aaac967b59428d0201291d0204c87e6df1c4e179b283aab364f9afc32ece963af8262152c4816c999d144c66cf817e8258a0d238c78590b9a2d4a044a17ac1739d91eeda416167349308d2a41d2510afc4126f81425a819b3b526532fc19460b72ce038d6a30dcdc971acec5b7059f30dc9be05b556d1ff47088a3a3fd04ec93621f0d4335a75294e07707932ba66d65089db8b00f8d6109515d8e258ab0f8562d724dfd6c6ccb5fee36bcc9984ea8debd460963a86e1d59c90171d7aeb35fa2fbabfb7b2779f4614abd49fe71f08711e05df746694da9c78775e7ac11c9032ac18703b42ab1a55b9ebc4ac9b0db585ecf573570652294c2075622d301f7c338e424f502131088369ea96fc74ee5efcac7032c2a22cb19f0f0d9f64cdd1acddf386d482f564451be9fd3f92c46d715b67c6791596841e8986dc0d5296b5ec1176d470f8d95b9b8cddb0552f28cbf6a6115b9d41f3695c030d5be2cf0c1c2912fadc9cd4d525e93bf1199920e38521453ec1bdf9cb63ca629a3914cb506c131f897479f0c360e11dfb7fabc3787f4f1aee48ab45f8bc873d428a1c75870d76411b1a2abe5483f28a149e8ac25f1bdbd58d1a2bb080dc278d9dfb10100f82c93a61db3a460109121b38dc71808784688d652a108f6bfde2d4df1e9e1ff8c05425b245fc9999b134bde2b6782d5396fccde30304c718e2f1f1df6345b816596eabe1f1a66ab9f12e19171eafb0b2483d3b956f695299d08f217e5695897d7a628f30e06e14d206f62ef2122c61720a317f5b94dcb907bc657408f3e1ac1023f641f83a404185cbef074210ed627cbe1dfcc24e0c9b87250ab3344b59e41a9854918873549f2ff039a624cb98d2977bc85134ce10236e2f39773d4270be2d234793adebe35a9b19c5cb197728cd337663aaee2919a1ee34d755f8ed1b07e0137a104f8897e21bee7ff3b40806f70d57933167351f06fe1b1d29a84690f39ca815af1a382c0077fb74b6c1dffbba3e306cf387d7ba805cd7455c23c05269045f758fcfed3fb7cde5fe25c744d603555ed41d01777a3c7a6282620b392d68e00f5dd7daf012ae951dd7d098148a367617431f5dc716aa5c7bfc8ba4452205cd45d7d503fbb983edc8045e0649d390dce60045e9d9f7ee6ffe466c453b629ef23a2cfbb71a1bfcd1a116c88b87038924ef15a3177a457d8ead2818ab9b20734005c14134819618a4f4e2c37da0a7c78fb1d77b54e12b36190c0ac1d16ff7715cf991662ee7331bf53531a1ae7ec491cf52075d6df29ab194c079f5f183bb2ccb6a0aaf0e608518a5737358061e9e85f37109d420d3212bcd511e0297fc1d5000b1e781198b6efe5e416a9439b3bf32936eb91cb1257c973f3f5bc306d2ba1030b810c99cb042db9e5aec2880935bc33749245c138b1cf9aad3a9332ec07442d41754d615bd2d193cf344fa3730c0c73821095aa7a353a8b1a9a57f4e8ea32fdbc3780e712786b580f42ed41b9edccef7414dd4465c5de572ebd8a8eae30d46332fa5332ba3f3a952a712173d83a982ffe74d13e02f57178db8480fdc66ef56dadff863689f7cd8c074f4135d88dd159a8e240907ba7af582c542a0db37fd2b79fba2880e93978f5bd9859dd3655c55ca3ed882c310f3ee06b02b04a086de30cf0ecebcb718094fa222e8ee7855d53a630297d4533b76e69439705c7bf9a4c37cb282a70800867265807c4f2a6d3f073de38ef83cce09cd3438af1ffd2ff4974ef4a660b5459ecf378056cad11bdc16d2e99deb42fdaf7606093b7e84175e49290b8f635ca1a9f05c4cc96d8e152ec06760a423d8e5a8af194613e63cb1f7ef3d65116706111f65aef11d2474375246a4031551a2c1b787d8d12a5df35648a24c7b2580f4ba8ca1fb70641e3afbfc76e615ab97ecf840db30a374873349c0c43f52968d5f1072015bba67ca51bc2e57074f05fb54b868251ebd09b54eeae457f8c18bbfa1f040f1f7179317d5b82d2531b31bb1a35b0d8081c91bdd32858522f3529ed5c985ba62e092f7e6553b86fdb82206adb3bfa9ae14ad85f550424672d5cf7582fde2d8745c9e31d6dea71e28490db23e32b0ae926503b421932563997aa657a2349e49210fa3c0d3af4884fe867332bd98c45838e61e25639ca24c8405e63dca09f6ec2e238e738270b8b231dfd21945f61527a5752bc187e7f53f696ec6a5136d4b5fbe9ed1a465b0d565343c4ff2040b43fd0ca74729662ec490c988ba4da0b05e8854524b0a9f6977f4cdeeec9184f4af2fc017029a8cc3cad961da060c4110ef26db8f02d68a3764c26968d6b1f41027b527d329eaf8682475ebebe1d4fdd0344495315cb3ab38e3e542642776246938571d9790bb533ddadcf96544fb8922762ea6af1b8f6e7ee6c0ea49cc441b1da9b9028b8612934252d9af83bad4c3423532e8ac7c2e1a0b0775253f0e7af497eda451377102b04bfa0dae1650a0a66454b91974d3d5e526b1fa859d1946aafe22544c33a26044702a827290a35c2234e1e749cbaddd111a5c5890a35ad0a32339e622e74db00b56d67d22826203fc93527d6d43a8092e60d36a3705a75dfb8506b6687f17e774b882aa72a07f00c81a5e685930fa9edb30d0913f62abfcf21ace881089e42884c147966d27699ab25973a0e580e78fdcc3adb36ea319daa969e651a294b151fbd1ac4da705d2f7e38f7e1223a2320f1071e0e87b2fab87580342c4c466f39b97926c06d30b46c3748dee9b8db624e73ad4cd7afbf9b5b9f2888a61d3d93b7645eb55f3cd1747083c206f8193b26b97c54f6c8f66b44a49bb6b54b132ebe2067bb8aed0080a489b5fc2e4f07edcb4cebf3aeae57d8c2a54e322d0a1c7868179a8c965800157524d4398749f73337676605552afc351ae14237e8b14ae8d69c9254775febcc3b6a1fd89dc9d55a80183afff02d6e5c7fa7ea23730da38b49021f8025c39b96ab5e31a81fa4af2279baefab4c6102b18936414996abab3f8ab3603e9647cc7a21206aa77f1aa339118930e37dc1ce54abc45e987e66b02f045be860495e083e7fc35c7df766cb2be135967a7b4aad7c351ff2fd49f86ad58a6bc905600518586c5be2755dd5348982c39bad0cf273a2cd4bf2537fe8b1db21f987054790a0e186b4d21ac20555ef4f1ae8a3f04af984d49f96f418d42bfda80ced04dba712e4a902985f3a959fd4e65cb23bafef609b4a83bc3e8108b3b8d4f694ae3e64f05a8ac8a0931431dc4aa9a93d63f726b72cd84f342769d748071c89ff8444aa394ae9e10d3c726495837f93f5a4eddd3b81c11c04d5216d7c516ec8957d2b6557861ea862cc5cb23ca504e1e2b1ec6e07ce6770446fd3e0163d7cbdf679712f928b287a951043a36b087e7fb1c3b4a7bddb0ed921af261ead85a4754a995fa75f70e970cb61716995cd41405ae461ce7432b91c29dd71cdc51459db1469e2d66fe258c2c4c6a1adb35207602375dca808da5bbe490080d040db731e9fcd3cc10a3011665935ecd9876381826e9b1c95ba6085654f59f56b855624b88242cf3078b0b375fcb9f2cd258d91a1373b24487437e3bb6bf07a2c9799fea570449948061ccca1bdc0916f249d9499d334a4de1f6641777c36fe2738f1b0e5c0511ca2dd042c429cde920f20266409865bce506c8727fb6746b8302a73660478879c4be707b44d0282df5730ad64e6805b8b60abcdf20bd6cba195d7a198ed0cc385a91c04bc18f633cd833e95486cc9463a29583e974dd6914da47531f3fd9ee03d4ac9c2a401570c3246d6a3351f454a983e188d245a55617170bc73d9cb53186642fffb1ba38a6848faa310fc90f3ed268ccd852978782ba3753c6ea13eb34dba3a404e62e6060eeef47152270024b25c9a7fcb88707863398d4845e46965656d6acc3609b59a9dd29ce7228145db26a28b9e4280078e88ff12425e4eca100fa3e9597a2870d474951c162c039d75e87ca62c1f409c834acf53c6368bdeafd855c41f19fe5ea1cc9264ee2b55a11063b452a075cba4319a6a76aea635f1edd2e17675b5a0e613de8993bf586ca95f59b6924697e2f711141d9516b436c0ab417b28d6e680867fd6385b928e6c21323a7eb848ca32e2bad68616ad505e3282cd7a88457cca88b501b2b2f9906d5a695975406a11716a55054a1b53c7cd36aac1d159c0488cb9fc13261ecd1c38e3bbbabc809212431c9ed77353272807b082e10b402e4fd7d7924e8e9c2e105a9db5d530d814a847e103757089e8f7d03d7289def71aebb086d92f04f56b22453d6a2a505a11a2e9e94f09d4fa9ee98abcf6da78207fc03b97e9f1bd11a9d22979bdf3af87ef10040ca339c96ada92e4c62e13780c1aa29a0d59a6ff8cd6e351677f11628498fc4d7ccd2c2ff15d6bb122caeda879511dd253dbe149e3a8f8a231d958ab470254266938584e7e6647df06a4b0507b624fa8a6f72250c145235efbc02099864ebf2ed28d9877e415f16881cdb40d67bfb94c0a16d8cd1c16b8708375f9632e9492fa7ca7bbc595873609bbfa0127caf52f045477762ea04b7e8c500169b09fb9e5b19f268c3c9befe780525725a75056d70a9575419c0733179b95e315e5f25a7a19561598b606476feb294fe75d03bd7f6be8bdb771425b58cd5559166b3fc91ec13322516f57edeb8d226382cc13c00417f111b40ad19bbe4c5d60bb3c70947dd19d18036af52603bbe0ff5da92c735b31a9589f27b6b03dbd431590f701b84899ab2c1138d013a1e3c6f6cf217231fdcf52ca6128d3708a1f9d4069341950ff3ccbd7e3a8168d034d07f183d289350b2a820d8dd4688db2b0e55121bdbba3fb5fb54fdace9ceedb27fd778c8a20bad23a3c86e098375f6acfd5af7727cc26f9a68e0acd9a4d84d896005d1181c555b9cc2fa4f50fc3d9415e04bc07e5911c3e4bcbfd428299d444938b429d4aec5d3d4f55e924a8bc5988f42924e64af43e2ad4cc20091786b8ad62f3d8cfa54a2ea339a664d886d79307de5134dda92d5fd76a78062da0edbd5358ec23b200178f323f3c06ec68ca67a7df564b771c48e01581d78fddc458bce0022489b42012e37098bd247598c95f7205963bbe827b2cc1d4238ba2fb118361e86a296d733813327e173c7b011c0cbf680119eb86f5f9e24b698e165a7ac601193dc2839c254b83fe85d78debd3138a1458f97dd6a017e39439251e40b8fd8fff4485bbdc301a5f2950d92e0963ac2b0ac1daf546a114cacb750c5fa34f99ad91c130d86291beaa1420c15715de2e44136ae70bff5bc21a022d5837951b1cf1fcebda949d4deb3271e24aa94a07f4a55e22eec3d49acb329bac36d5f3e05ae63d658c23fded3c73aaf33de4e0f0310fac51d16fb70b9913189375b8e0a54eeb2d0d528ae8454e59ec7727b95d0510e9f3c3b108fe32e91ed2bc9f99df0c1b33e5b71074bd0b3a67b9c4a52a132a98c4e96a38516af4ccaa30ad57e71f587ade15ade35cf83fcc051a5f20a15638230bbd5c434e1f3ad99ab0fdee356a36b91f271771b8ff821854887114e9616706d63518745f52b4c2d0107314256d734227b5945879e6d02cc98c2be0a870c787c22bd50ea8976bded9805a4841a5af51d3d96539484fa401524f1587c02a9f309c9011564e0c532df06867ed6affa0632ea34e49f72af1e8449eb606d09944f6fbe66b4b3c6afc5d2e9f347fe1fc4bf5398c58d2edd3f5d576db5c235f390720e57cc32b68db0c3119fea514e54005b31cffc8dd5c9311e2b3e70349c6e5c03cb0f85b09787082cbafd9b2ed4410ec9edf1b37b9e755bc3796f3156c95b321b32b41f0cc379fabaa2105e153936d9f9b8a994ddc60834d240aa71bb20bdffea0e696e952886678678a090da706dcf3ff0059caf5b358eef28e2af76f8b9825144d347388fd5b17d13469615316c04b0755ae0269d2d71c830a0a81624f23b32f692f68c76e4b964d4c913d26f16396b35337311f00ae37f86ef12cdd25220ce780304740d89c159dc0fe96ab323f5630982d7c4abf6441b797e60e6648960b2db9e039fb4a9de612c660b7bf22c3965c25c51612e52ae9f5bbefdd591ce5319d9afe59553cf96ec42ee8f6d15c59ddb74a59fdcdd198b52391502ed6b3319acfa2627cb6c29cb172e75bc65176f99a6593fdcf3ee889b5525a87e6aaf4492fa2cefcb8012881efa4c9285998a89778c5e20cd254ad1868243ae91edeefa1169d69c8be6c8a5d2e891c8046e0e99ab658935787c771a5b8bd733714fdd35a79282094044b1778302e62f6e5ed5b021264321c47e7da367c1aec55665ea4ec2084f3356516bda03e33683a3adcea1567c9a1800cd3233f7bddb11e864644ef26ee258dc27a25e4e5ff499f313575281de59949823c90f086daac572d655696e680e4a0cff6682c92559126abf5a863479b5b90ae78e879658cb0712b49b4c65d8dcd6656c6066e551330b71d27554b75d45a873a217ac6cb20f8005c2db47629a299da0e5de37e38530ccd8c1049058d9ad25a7cda903c421e2dd12efba9c12cc0f94c1e754c146280205b6e02098e2c2a062b0bb9f11cf8ffe72fbe9082781bfd1a3a2da854a4b1f04f83904c77c35304511f23278c1fe5ffa04593a6128d889628936b51f9ec97531e5aeec46e67fd4ce5e2b90f030b7ecc24e206d4c2f0c818a50091ba06b8a88b9ec9b321bc727b8f8ca06a6bb833580b509e6ab638b4e7d67406f8180e7abfd52fb1c5decc0d02ad06910a8dc6eb6d7c7d8623fc196660ceb280935457d5eef527e334dbe662336668aa76cb5cd9cf5e9ef587ffccbbddab1d651e04b55019fd264716e0c842aaa733636dd764c9fb57d9ecef5b910c22d6847693f7eb60c9904a434821405c955c27b5494680a6cd4c73d7b6683c1ea0ed4688dccf5a81685d99b85d11357ffd143cef3b5de87ea8e6436a818a4d72682f34d6cde6520a3ff52e169b68fa9197bb15ccb0bbea272c62610aaeaa791bf506062c66b633a2f30b401856432bd907a35bdbb7bcd8bc5bc1dfe32f3df84f6cc19c04f0dd84459451efb929ceb226cf83ae458748b9995dde0098bd20f78460662581c87e54eba5d503f8f6dc88f77c954b1602cd213b07a6d7104759c196a95a13af35c84b739d79cb90f29db9d57781daacb8962703fa292a856c513ca1a16e76e182f197dea8f01d26763b6f9b5d8f52a13afd83c8bf8006e8b30294b1749c70fa8525a3933ab38705112a99ccb695a5817d446866e585b9a23c35adf8c5af05f8061b4603ba2f7162ea692bf084100bc067b92efb8a8c6605382970eb5efb1b7728f7d8b9c1e03cc1c2624a87d421ac896e249bf41e7bf80de53c1ce2b5909d496281d90b601d537441c7f02779b90541022804dcb25113c502fd552a02fccc48429c0760cc30a6f65d04ff86864a9c911bd7fa231c19ebf1097ab700a798a28a0a4a1fd391412b8d965ab6d3453e43d81f71ea155d1b05e8d90fdcc0b7a6a023cac1c97d1dec89f320cd9ae0d778074b1401b8d67eb414685fa17978bd47a7d0b5f837c1b2cbec9f3ace5a7a49835664552623566f5033febda38fcdb942e960b8d57da8f2deed4981bf3ff89648665e005c5f4ce4ba53828c98e07d31c201eb8596f09f6adf51617bf17a518d4d8fbff76a02ff5aec6e0caabe39edb4b766e5830a24af8203f058921fa20a3a3ec9908a9633c42a97e8016b0ce209852ba070cf4c8a95fa1e5b697526cd6733b185d71efe472f874c0837e741c697c0f3114a6b2bb25ed9e7663ada399f8891e4c347360aa71457b65485d096088bfbfec579b028617c36cc0661892dba5b4295cccc3020b0bda15a6d519524748640ba9a6f22127ddc0761195389b346e27fe71dac6de2b0903c443c19e16ce420b2ed104385dfe15e6256d4cb3c895a8523ee924500d25587eeb918d464e68d4fe0222d67c89505d58e2f0b95f46588acbcaf29e59f83fa1390b082e707cb2fea94128364a23e7eed0a6ba1fb2bd977043030c534fb4d12b7a48d0eb91ac56eebf4a8c5309eaeff3d58a14c97430281978e22397e07c568fa0410d13a79d7d4788b7de55734333e3c84d7d98c7092a3152ab70496710b28d4c5f117ac3e01db8fe26d2640137eafc30b476316f6571dac09022a5f3caaedbbe514caa837c13360e519209a7395f34501e6ad1724c86ccf869e93717b5c5d1e695b088de984a04aed5c9c8fcc9452941cdae23bf6fe37c1964cc087b82469654b057d44707fe55e5d64ee401bb1d384b415ed43c2a9517af1d9d0905e5320925b2f1934aa1e355b5625cd9a896776f6a087f26e02451595fe19a085827732ff41fd58cae6783812272bd3a3552273e90ca5c7db5003f10b9507e5b412e80bcbfe9d3ed8eab09c4b0cf69d96eb0c11064ea6e10973d1aadbacbf08d567f52d3b9b86d4033d11667fbf112e02d9750caa8822835f89fe389bc2e519675acaa443aa72ef83661e7088b4d262fb2c0e03f7997f71d675170b276c0c0fd9dd706516bd50f2363d08f0e541d82aa956c0bd225c689af58873fb5e2fa7b16fcc63ed05ce1d80e944c9fe458e78f2dc83bd0c0a895f19cb5cb6b7bf90b7a35c3259ae77156383bb52d38a7561c2ab43f7844199a6ace310e0b08a07af9fc76d7425fd8e235fba02671ef20fdec61c057f1f2857d357aa6d9cab0be4aed092018fac0df3b07072bc153c20e2bae816083880e0915ea7e891607e21cc253a7f14a2c72bf40546c970d0b38823df491b9d02defcb0284994c3bde55dfdf96aecfeca09a0064aba31249f0e1201be8d107336f8477ee8b53f9b21819a6b8032dd022c1362dd3915c84a5c11f959c026a99c4f88108e0504656f0e8e3514f462a0219a2c40a0f84caa117970e21364f246d357c2f49ba1a13aebb46dfc941e2b9ecf6ecbddfdd23bee4401d673d5b9f50d639e7b2cb8a12a4bcb91ae072f88e23801840c3f135c3e28f19d51dd8b9289692e856f413107c5767f94cd5a6e96f4dae063b48da275310789301e5f7f401ae7a25f542759afc220a23a5b60ffa2901a953ffdb471080f5dfbbb015ff8f8347d587a6d360520e53ddca5fb054054714b45916f18e8d86a47468a17544c8b1ddbceef644d8f4af967394b0d6f11acc5fef1bebc1932d41ada4f1c859d5f9b6c3a3e6c218e39c0872b3c474d2ce235e9d6ce49f57cb8b8cbf2b4ca1dd2e911370d1c95ba6de2a54f7fcadd01360b48943e78b85abc5d6400e10b51a09ff6d874e3f66147473bd456256a983941cef4af7b85ac125d303aeeb00105bef7d06f1629ef777847746c0d2889d44b0a3d3efc78fd82374ba847fdfed8018eef6627aa4e6114661cf053de75d8025d838e91a4db235319ad8e627fd632791fb1d56cc27ea0e659378bc339a806f4a40dcdcec95a8028fba0ab8bd8ed121f974e9e306b3106bca31f0e8332428bbdf6abba249d65b38de6e2cfbe3dad357b1f24b8c226b96f170b6f10846e28e8be6bf42af2cf82719b3fb9e97410595eee778075eec330e4ae365e257fec5c625039aa30d3d2e3aa237be945e6f2891eae2b4d159de8d7275a44fd8d438673619c05e366e0b1f2621e8536e241f0ed624ca077e4f87162eaf2d9d09d4f9c44eb69ffb52e7b2f293544854462c7e221ff52e5626143014b6045dfb2df485dda9b9ef7c815906514fe31944430cf68ea380888cf7d8ce53866793e7d276cfb7caf49e8ef5ac6360c0b1ada488f84a5ed56effecf81ab84dbb51cb9a6d67befb220f436811e01ee566eebb9fc0aaf2f8903f01023c37ec4e27737d0c359bf1f4848550be5eeffa4a56e47e18b0e12b05d9377474b6d049c00180dbe1f213bba639dc239559de7051eba75d759b6c714fdc6a729307816c7a05d3a4dfb32c5d5b9426406a805297c1c5f925a17e1bd88c82f33cac178310569f3a0b4e3428c0ccb8bc5df583d3799a5ef3ff786bb01e10e3ec9e1dedf904ff8ee233f5418f60ba5eb557bcdd619b8577a0f6f8fb3af8671802ea6224c7a0a1e380e90e4fb3a5877600a27a9f3ae17cec172ace106b86cd396cd9b8428ccc543dc7e946a5cc4120326d425e83f708779963a03566c0933b722eccdf0ee97b8efe52e8c8c5fd99fbfffc961ca732e9c7004501c5dead6b57ca8e176e427d41ca286abebbfc805a58008995e948cc321d69d5f7ab60bc11dd2b422126e6aa14760d32aa7260ad27cdd46eb5a0b833b19f87ea48aa149d39fd770714a588085cb42e5ab5e1f82c975e40e1566ec25e7bb22e9138ab7b8ac0c636e263cd022174975e46b8e816677a7c82aec595ae40ed15e55e83bc6109197d247d8a1e1938bdf7afa976affd31ce4cbaffb87b89b10da7ddfacd87cb7cd19deb0ab0dc3f0d9d5a0907e5612e5e7b527d74f87d59ce683bb7544db2ec8d7901831ee35e1e5bea05843e0db78cc3b35b0a9dd6fb2d1ab56b1fd9316e3ef47a16da37e4bfa65f2f254b02b689c36808e188c36c5b5411f52f59a4aed83902673ee3dab14be444af98e6ddab99cef964c2443e798c5a8fd2d9ff0a63f4161808ed63342b4c4f356e6f655b51f5493630e86ef0374d061d2647278142a200da346340fef80bec6780b914d65cab76c5f9fce96eb3c4f3ce9cfd96ff004329201e8fb40868f3151c2d5e0e9b46e8ea8ceccf714ce7797038e987c3bb334c459f7e813db91c33e09fca91f034c7628617b7ba00a8c7a62b5c8d9bf4633b4f08cdd8336b3dfe0a57a1c9e19eb98a6fd4f3b2561101f6c7ef511487577a6fa6816d939b52066fed59666f8b44078779c22e5db38ba1d1f5109fd78ea2ae310fbd9e5bc043b7e2f312260f6352f3c9ed4f5915043beede65e8a2066f5a4da5d0945057e2896c2b928c230750f41ea4ea8127061c98b8129c3b438152051f324f2f2beacaad387d1928c79070129d9dc958ceade74af695dfde5d4c52696e589208ae3a2d3bdeb0deae8ac4b82d953f9557cfce212385d2d2a6f36628c500502c7789044e351c2b302c6c48a7ae09739e406b0720732f27a0d78b4ea4af092fe8be7c3ab70cf9eafdd57be540a32ccd0eafaaebbaf90fe2e2874183a24b2ac1cbdb736abf9cb58b62f42d9c4c1edd4e9b5e97282b2140c2af69cba1a2e97f6fa62b167f7746f9b35a9d864a92b9e1e6bc6b38e7cb1d05fe59c6d008766b1c1f08fcd859363312957803fd40d06a54e267f0c6eee752de0e6823e843eedead9017a6d6186378ade715eb25042c4c86b99340428828ae38afbc9b86f110d31b3e05203b58a7f9a33d9a15e3fd5633e5629bd68f6bedd02f8e45a0781d7d7ee4af54eb811d1d3c61d86c6ff6e9c36984890e56aae11eee9e597d277ba7db0958fe6944478ae440338b75d7ba59c221cc2f64e6d3e3232e16afdd2026fd1fac37746bf06f978a5c02495cfa746da4284418de1e53d39f376fc1f4cc7e65d0cd4bd0000d875822de85256b1a1f1b3d79529602b260a75add2d98c296e63a21511ec92daeae31f6633ea417df5b37d652d6cd2c2ee6965c8296c6a7a5836a545189c2b4d699ec63d54e48386e6630924abab90b7d8136b507b1a84ab935972144a0e80f8cd5a702c3e18c4f7f075484d5b317797d8ae8e01a17fa7d81c8e84e8331c5d0935f38dd4a3d8d6d96c7b2df56029689229aa2debc08c452667a4022e3d4d259f7768e0d1292f1c6f46d5da2e7d290edbc9663a4b00a279a37eb993eb6c2938a27cb2a69bdaaa60ce23a74f5cd6f9426041ed696701c37f72e407ff4b3972d8a94382b003e6388c2bfb1c0392ff6b8225e30a9e534e5908362602820ab79be5f9b48ec162367dccbd9b1cbfd1206b68d9d5903ad758deb14d0817ec43a69e3fcaaaf1c75b802f5b8e6fedef22bd120b92b3560ae127affed1ef186c3870cf484148b8e1167d1a3c78ff8ac39cc05a65160133ab591c1680620dd9921e3d8f9de351838a32a0e8f3e71a2a4f083058a32b75e3b09e46f0c207273b88cc732037dd7f627b870f293cfeaca3204cafd2cc42de686e289c2ad9d97b617f02fb61114fc7b3e719a3cbe21c7c9865fc29c202480b52a23ba35d67678e8328949d2cac181469c3a06448730737cb6708500c2aaa0f30dcc012e9e25b130a93da6a9d2df515cd3330fb0633132be5791a5986fb5f9cba8ad31bcbb9ac4690524212294122f4d6ea09a27d7b3d52b1e04480dd97802be85a1cb94e364cf735558dc6a929822e49c5030c43146763f03daf9f5896f7a0cc004cb9a854879eedf629f2b0467b389bff8141dc4abe631314198abf684aa6564fc054d9e6bf51d4fa5f459f01d670531124c3ce08639a78dd3bfc7a5b8ddb25e6a1f060257b02d1ba9607e594f6577d84a8e9da8ef70930e1cb0eac89210f2a2c1859544553a02b69940ddedc4cfbb3f2838982272611e838eaef3594cd7d40e1ee5b5dc046eac944ef4bbd60a77a4b077348917c593f3b692c44bb6f7f9afd68bbd6ac4f2c495819a9174905cc3ffaefa4fea654d5de4ae86c26d505c6fb0d028ddf7895933324bbd3422dde8e7a11946cb21522b5115514bd87cb0747ff77173273e0a0cc9f5c3c74bdb3a5e233b491d5ad5314a6c264f259b5077cc56216c97e500a034ba929c0962733d8eebe94fcbac248d8f1e8defce682b2303758a7fdc3b58aaa3a1ae986c92265fca2c988e98c4b88d2ac678757f3bc4742d102390ae68eeb4a18b66201c9a24e97918ddb8289b2ccfe4d47c05278e65b7a13e1d22adaca77716693b066092b205ae02925236a299b5dc1e283f87d1e2cade0469148512b22c30d6bf904667b2722ec09b60309746ad09a1238ddb0f39daf7058f5fd39184c9a807f41d5f6abf1e11b0db1f1b425bf610e0b97f228c4528cf249f2bbef5936041f5021d5907cb1e7a291e1d4ff52fa012236f149f23f1b37e0919ec79a3de3a9ddb8d9644d01652f6c8e6c6160665715c9e24f3b98d11903f04bf43f0faa0f4b39800545fc1087a923625d29bae420f7ae2ac982e5e7744ff64cbb00ac57efc43ed7811e7b0b854945045cb260468e8d47ef0a6d718930090c9a556771f3a9ad9373a9bd124f992e816237472317c542090c6dd80c9e32bd28158e5b0f2fde09cc50041a5992b18a7918aac3378567fa4d337cf65765f3fdaccae3372feb2154d8dba277e7fb6f8aebe533bc02de68dcdd3712d65e45dc5d57ee40e1c1cade7b8988ed6ffc22cdeeb37aa45106431db68051ba55ead055f4473bd7b98096d219cb5cce2e2423cb31d84ccf7cda38ee7eaec84b354524b38b47eb9274cc1608181bd61c09e1dfd50a0f8587916c19002c7c5c350dac6dfdaf6ed14cced076823d9bd057719d3e557c42cfc8e2683d164cf3ad9730c3fe973aa10eb729db4470086d5b4e2fbb2da83a11dcae6252d2ab6a8c0e3914cee64b105de3bf980d9c208589e2ff1137a2e8554765f84ace4119031210d103629e8cde7b7a4e107e1382841dcc0daa3965c1be55503865140de725fa661642080266c759e38441338dd312e9b5fa335fac9686c2e400e374eaa0d79d82ae901f87895217a119302e73d7a5905c072bd49654313beb905a518a33344168d0c5256b967f21eb3a12e0272655c693f09d56407e0f74b5dad11da1c36fe627439ade2b49feca98e034aaf4ede894f334323512fc75aa6870bcdabe24cc060024325d0b2175937884255fc8934bdd4f89e8292e142930b873bb10f04b508c316f34bd35be28e8b5a04f76be4a007a6ba623cce9025eebce13bfd068a5e95c1273483cde204e96893fbf68ecda05c91f31cf6e0bd93292a9d798e1c45c932c171cc28e1b5f6126195488e5a7b31adde34b055e102bbbbaef009d9863901f40acd227e7ec7e1c1f5ece2d0f39964f4f9ec904a37ad8c6af6207fa5d865376661d5a4c21283caeee1d3e3920db26a55d62a635e08b6fdfb9fd6b47e60a4f8aacc42e49e27a16cd6f28bfd553372324a9f187b7e8bba7d80006d21e976f7da378e7f9d64f402f421de60aba95644d931e00f91a7c137f38878258c9b764de6d3a5b281e8637d73fb88bd2b34ef407eb4035dde6b8b1c3452adad529361020ab64efff502e1d3ff016e122b66898f3385c21e16bcb41618111fe92c19972a6f7814e9841963e4ae06a7a8350e9f5de4b541eadc90a5d8f967fdc3a515536a3d1e1c106a74af9589f52e1028aa636eb26bc9fd4bb54925f3fc467de458b0cd616ba37b4b518d1fc694f3768f2f21fc72129bc9fa698d180692cf7f71a7c1ca85e70bbff6df3d31ed91fb3897d48c83197c5d544f7d1fe946531db8728d03757c85e376b14956a8f2e7fceba3ecfed800b18043da32aa63160aab3dcb3218e17b3512f5673fe384f3adce49d24dee081ce2175bf5f7a00e542989a1c46f2a99c8374f6f721e872a8077970c0dca34e7f8deea17de0446693a0ebbec75dc959dc9411aa7e6b9ed452e3ef8812caf3676cc13eebeaa1c051a2bf043fd496375270de3873be23b24a08ea270944d30259d1df3479eb9bccbc84a69d458d7dc50afa4a0d52d035f5e0c50aa1085a9f0d5f2ebc7d37853282f616e03cfeb705e5ae5f094ba6790bec0b8260a3fdfd9bc5d277b62c4a1dab50ee3beafbb47fd27bc40685d6cc64c937b2b99b147d75416d6ad64195091b6ad3c67d62ac4cfb7b633ed63cc8be23c43599c268ec5028890fb4d9821d4664ada309da1ca147dc092781540759cfabe5e9a4a4ea0b7bd2cc014c42e80e54ac03b25539fc6bc8f270c1462ee747104931fecb9a19b896d574aacfbde16a1bbce005b03c4475a7c40ec8dfa259e3e496505e39f10e27828e9020d46c2020a16843b76328ee89e76b2d93da3f361c5bc05edfd1f89a17be9e5f17","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
