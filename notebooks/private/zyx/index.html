<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0e589ce952b7d7189f21bf677ab3ee52da807a3452904b82c3a3b0c50be1061588ed4895af537b92991c0d4353451a40427226247fab25e3f1c8bec9c0424fd2c453054970bf845e1154444001da563b31676cf8ee1c276236c6ef38b0e75b29c24ddf44630e3995338c665e84bef52349948f75787cb11f0d909ae0247fea7f4400a121b438649505e73fd07a7da9204a82f7334de21e5cb78f1a5f989fb4347efa418126fec3630ab7ebcfa99ddf1bcee1db5d0b626b2f43b21e463502decb33847fbf962ca781db432d4e184585e3d0a1d26246d06cbcaad97218346646c7832037b1b8321326604c74fed6a198d78d5240c89adb05229faad235d2329ea3494cb82c7429c21786a3a6855ae135be2abcb863017b77afdf27c23ea65f5f4b3c8d603157f0f55f8f484f36c76d2606eb63e15493defea620f96f5e113cfed0e1ac60221d672ee94d4f04111061a23afa359bea2b349cc00e578536476487e58a823ea02bcba1403dc66e61f3cf8ce8ba041cb801fce54e85becb0df008f9f5b58278825aad4edb36f86f6cdde80fd5937086b9c3a9537e00900ffb4dc9fbdb6c50bea0e37478d684d06fd8626d94b0f248c16eb1464fa57f4d1780c92f4bd420fa4cefc53fa0a869a242cbad3b70bc4dab094ef12eb6024acc3148a66a15ecbde8645c4598864ec7cb220d91272cb999802a3a4511afa26a2cabaeb459c2ba167f520cfa99dbc8ef9b9d8aeac55e05710f2a5f5d8f725576a3bb805e76ff15f29621305182701c0c6c8e80d74b41636e4d671a32d1f334415202e3ca9dab975147512c8c32b8e39b700f585f60d7bc79bd4d3f13359785bc95aac361757b0b9dacd5dbdebaf9b28aaf9645c5ebf761b1458feb22f7b49a9e82344a1f7f0ada84c9815c74f37f50601659a1aa9ef76b4457dc67d101c46e4f02a86c4666e19744f979b2df073611db1a0bc9272421109834e87d9f07faf2f8ad48232de014959889d490b4ccd0adfa07602cecb52ce78fbb61721e8e713a1a387df7edba3be2e300d4283b1877b8a40077f498ad5026050ee6121c99a005a7e5a8b1645ca757c2d568ce81c3d08fdbe752f1bfe30ea6e6db46cb593aa392f3a2895ecb07b98d0624d91d4647f143e20cc43116523c31db5009aad0025eefbf3318ffeffcf67117bd5fcb90bf1ba08d5b90ddfdac57f8bfff8e841227e85d0eadffca4017c21d9203812f3c3bfde5334be8aefd5701e97ec67ed7ce0b3d40ed8508f65ad03a30556792fabec353cb6fea37f4eae3bb5a6ee23cece1d9be04c6baee972000d7959317393d88dc435667e6a08f274b0314c949f2ba3cad2a9985259246a370077de275e93de69c072917a9979f7311eac9ae016b305164f07bf219857bb49227d09c7e9b35c4a5877a0ce5a5df4dd4514fc72b13fc007d8225e52635bc57f5a5be61bc692f7e418489b69431350d50cc4d95baa2d2df23c435d51859fab2e101ecf7ba5bdad003693fd11dd112438aac05c07c7d61683f7a4ff2ed284426bd39e1bbbc8bd468a7e1335ca12cc5413979031fa5e3237199d68ff650be12a4e0983b019d0147d62697dfb6439436a4c8d02fa5932299e7c390ccc422ac66677151a355607ee61e299d1f245fae70aedfeca5b6c436a5900beff2fa7ccacf1d7fd894767fd44236c3aa9d0a35def7a1cbd65d45bdda86655efd927320ae28b9a3b966ce9ea960f4889c3d98fac8e237c3a06744a55e286c44295a700a00ee12ba2fb8b1483369ca3d20c738f36f05d32b517e10fc3f9200fe1f20b740b129d880ec98bbc51bc29a7a2a6afb59d46bec4e9b2a11e4f6901d3577f842837fb018deb90773b0e1aa5b64ce642562c7e13a4f7957a9358882e2ecd7dc16b0f0a2932d525bc8504c2c61fae9c1046377880a6efbc9d3774a1ed164f0db7f449c575265c5ac8293851a75d884c943d5559cb137aed599ca98a89ceaeae0fa831caa2d4a14d209d21ddcab88be47fe33adfecb84ce31eba1160cdb990ea407162d665ffe53e7dfe0c5de292816cba9d504fab6b767627a0ac27d2d60dcf7023f260cf0fab39bfaefc7d48f0e3248d5da9ee3cd6d948c6e573f3d4c25b6046204095b1aa01560a7f84bf73e7fef643e5ef2b2cd8fdb79f42ffab21d4abdec835eeaa2ce3e3645e44e56fa7b5b251bc4bd828d554ed0769487c40af73bb4387617cd4250ec40a8c6c9b9ebb614ab1168729dde5069c9e3404318f02c8fc67a33fa7f6713aecb4c191f00b9027b7b3ac97bb41946f0528ef290ab180ae3013824eaef4239b4d15e9937229a30a3cb7344773ed02a9eee9cd97720abc4cca943a837336f752168c086fc20e7b8d4ef768874f57a03e736d591371f204cd243f79b7d8110d5aac4e2e7f2a2499425355de54f2ef9b03109587f0f543c94bd7bd66a37cd95bcc4d22c3da65fc4ab54b3ba67ac85b2c1c78ba1b877f7e38bd04cf21258bf4aa489d6ab1e93fe832702fa7fbcc80a727f019bf79db63f049a9ec7c35f18c3e3c290b8da3078ad4aed85370846d2a92e9e6d674b1fd7bd88657a48ab0a45d86fffc658e399d993160ffa0a7735f75e2f72cbe57ca4c91741252589320ec14d310d327638c53a6ba43c91432a490ffe822c7adc6c5643bfb38d3d077469453ed7d908fabd81ec8c3f961c503871338e6c8ea4223fb28a91c48087aba7a3f89c012c8e3f6ecae2113ec489d07f7e1e06cd3d109171313f965668185ca4047aa238d90900b7ed95a8d7f7114a297fc220744b998c5cb0b93fc1f7edbd6ca7a699b3a3b6399a044ba29da500fa1e328414ef5595ab5875b500ae8cd3ddc600ec2b6dd6fbe89cb97b78a9610659045950dc4ea2666c2a155a4210ccc5dc402edb8ace0eba0739f6ea0e6ecb64a8d3de4aad3cda94e31d0f7d62469e21fcfe9245440711ee730ff7a9bb3a5af49ecfc0d0c53452626c191b268543d748a51342fc3cee60767c7363e1556a0bb086febe14ca369fe25f5c47a0ec525c27d6fe19cd616deb38982829497a0c1f14649ab533161fd1d7e8e53c088c28aa0457e44fe34c3f285f0527cd4b0a995d601c63ef4e3c24c85987f7dca4d7a0c99a65c0e4f618d3cfb9927cc563127c0b34f9fed9248da6f3aa8d17bb844249fbaba3e58a4255049952cfe1d89c1e410bda5b3f55e63b75672af64ff0c0a0a4a537c294763c7d856121c88e568e94f7f7b4cb152de3aaa82c3f10dc78a9eda519231afe7870f0b4a0869fc1e366d9e6cdd74339ccbba9a1b8f376afebfd425af0145d5691d9416b4443da6bfa46f88d4810f117bc8cbdedc2c29c0743498f1860ac9a2e8b2c8c5de1ccafe6f03a7e182cf0d32cad63fe4f3c0586a5fc3f459a49d98402b21fd6c9b8dcb370e18269310e13b59a7478bc57ae110a77ebdd32de2bf194085e8abe5c0c9a53b8da25e950fb23291d3cdfac5d21ecb98cf3c586625136d6aaf784276c0ace601b8931901c82f2f0b68910ef40f00183dcb948e103954c6528d21817c11c4656d835511fe7c02b5a971c6dda753d8fea3236ead8a8242db986dd1d3deebb630c6ad6a8ff31d9e9cd9aef03ab5ad132dff4b87f9781f1a9f641f8a90cf89fc42ffc70defaafef4ec0f12dacbf2db3bdc63ad6320df3f40128065f999931f4ec52f6bd1a856b246d4f16d9f40fcbe8398f4bb304870fce6628fc14577b439ad70b8c5c8944d50bca74e73af1c3a458d1dd9e68253bb2a59677764f63ed6e36941cc359091a442fdea97f48ec4a1fe6647225c83d20b63a2c8962c2618290569e063fe2b857d57e323e8d1da9773f8b82853f00fb03342ab005f01d9f1afcab296866e11420764ab103528ad9c43c2a293af8abaa54943195e964439df85799e2965bbf414c71d924c5382c6a3c62519c59258bab2e4672a15e1764181309aa502be3585bc61b61fc452a872128a25f1533cd15a5d6fb5d7f97137e9b873bf88712e7f23cdc033a81a11ee4feab0d112e6c87479d5a48b70e99dea03c1f5b4ef72265e76896c17ffa56bb74c22f88eeb028d8e1b63324a524793e3c7ffcedb9e5ec7098f33d64322341712f47eb1238c4dcfdadb71f988ff653ed43c6273fb75c94c26fcac7248e953b28716a3c3b07954511792142711ced36e7eded45c290926ea713b1b3490ee5eb6a229b42a2f7a59f3bc5940ac6debf23b9a07e6773363893eb7a2432eac947d2e1fb5d60f96c894ed4220a85d016fd0bc19ef62bb26d5e134f6ebc1a3011508f643050c9a58980b24ccc8120cb4c25da2caf3447d7159b719438a5757fcdfab7719c535300cbb1a5ca2dcb78e92d504fe5b3b8659b588878947702c5ed99da0b53d04ec925fcf22f9b5accc956ab015206b79ea1e2b09944db52415c74222bd09fb5c1d33693e9482f14e6ce6562b8988f3a8483095e69675010c2c02ca2106c64d8330c9240282f3310eccc437c1ebd9ef630f41eefca65785cb3cb1162f73e6d1f1e3358d8c66d3d351a604f6f6e3241f7139d92258bc3f57c9d0416970e4f4ba739dbd109d22971dc62aa7e4684bc242aeebdfb45f1130d9e262f31d61aa17311aebc0a45c73df27dbc9886ac091eeb634299bf2c64760d64c1702e0d2c28acb8774c50eb58196d22f16646bf88e847d029aab50434b56f974105995112e35c6d7b933346829895bfb484e184baedf3aaffdf8ec7117c58393bcc564c151c372ce447e558eddcd0173364eb3c3f0c62e8affeb9ec45e314d2db95e02704afd1ebb7f7395fc50c5100cafc6311cad6593ce8caf2a67a166bcece031357ac413ca9ee415d6b0389303efdb13129796dfb394b4feae688995eb53b5cb0ab1758121c741b734f057d16541bac766cc865a650717cc559371a783d81fac109568951615e64dd9f4f0c85eba1f8e56fd5f2bb5205f002f7820e37ef3ac2f1ac291bcc9789143ccbc8c778d98cc3a8b2ed34fd2e73d8525ed982c50a8c22ddb4b1b40960435db475258ee7184c15798d501c5eb88b02e457653aefd2bb818ecae9f486b74993c9c7266e880d6025333c7db95bf509b344132b44ea2a43e215ab5456dad509ce8253bd4607ebd1633bf6ea3d52e9071669fdf35433a02aeee76de9b21e59f7eb1c369529d8220af4f202319e327f9f51595b9490a3c765b3116bef423db34c39c9e1c13c78864fbd749dd5a01bee08da71031bf470473013640ac11aa63471ea69cf0d2588701ecb418de0298c49cff85242a3fff77f4ea9a3b74565c452ab8b44c9bee4a326a771d241182b572f5ef8fdc97508ef3c65819c3f024cd6df15fe3ddf5757753a5bb964cdd8d78e1d407ee932255796cad611391a8ee7579c200691d977c5717b128b74bbb46d6f47f36b1223f571497ca7904761718247d6166816a67116910e13251edec3672122ba188c2ef1e9e54c505d3c901db8c45a6fe3f23b798ec85145333e9da744e474db0dd90be0ee3a74c4bee0680c9ed75d625a2a25ce798a8c7b6f23869caa523e356340296a9cf8605aac63dfcb6f04980e03459180de0c31cc44e24875a1225a39775e90862592cc28f61edb3288150c344d347e0e3c0a8c96f3e5e316df1228fc4bf3d9ecc0ba727c186ab31d5320ab20411fabde0b715371565cf07e39f8806f601107410ecba15112432bf2159ae5584954b0472d3efd1a8853bbf05519f9aecc0f3e9f2d5e6e5fba48122b8740a6913c446c5e6ada03b8b8a9314ea8b624bbb71160cba22f14576d342d21a01616987e4a16b86ff32cf4bb8985b688b6a63c8aa81efd2dd59fcf875df42a0e94fea3b376858fad2347c55969a49763896cf60af189b0f14d2c0d10da98242cf285b2f8fcbdc2d4e0753dc22b1d116bebd8a84fd1cb4872438e110801ca8ebceaf694fbbf04e813ff1df466de5496199e756db4d0bcd5714370a33f869abc88e9798ad8d041717697be9a66f4cb74390d3a2abe2ee5306cca511ece5faf57398ded30c4385a09f4e9f40a9ccbac56b5aea3dafee3dfedf614942811a68f5f400b5d6de59991dd95c77b9d47abe697e4ccaefccde964abd0e7b1c0726ca372c75a82d98f49db0cc377d9f374af746bc571805b509ab66062abf7fd623c83c34e62ca0ac13a66589b00e71a23f05849bd1c18909988dd241d618198138598c535dedc11d02dc8ca813069eda8869e27a77fbbd2673960f5eed4f496c69e4713209cde155ef013a576e8ba70e21d2309e3b25b905a27346da149af538d312f156667833221db5b126acdb0777dfc9a0d61f7408f12806a1723b98477f23737f8f0deb7ee027cd095b32ea72f40c5519491df7e27fdae4caee066a7c44ab85ebddfbf32b64b4b56a3506ec93f78b383564b92f1c89bdcb07dd15e64626d3d2ac6dbf5f7a145736981343178d8ba3f6febf875c035b1adbc90ccb7c1c2550416e7c1f39716659d6effd5c420cb074ca5eaad0081a8e9a19e53ce046141a7fbd771d3456011cd812cb7aa43b32890c4243e7d4816959b3725b733af1602ddd529f58f4abc1cb7fcf961b373e3b099abaf418a671de4be56d217d63fdb27f32beec7438cc33608ad7bfb16d0778e9381a089261177b6de2c530f9a5d0bc69d34e3672cf20e5853eb8c2431443a091d32b799245a68140a35265b44d71b258d9a870f156cd6ae6e094132267b07f0ed0288e23e063bd467fb972b5d02fcc6e833da982e2855b59f29ff6bb2f64931d4bbb1829a8b1b606b2733963312085ec88f6b01ca52eda0a0c90f45dc16ea0c082936c822959fa80f39a29267320b68f5df7d59ad2e9200dd5d9ed2c4d1768c40360e31d8dad256cd2ac7dd68505d9d9c5e4c427c7b089df9d997b71aff27bb4ea67f5097140af5db600648aee1e3ab627fb7a14f4e2f7ea9abe2525e3a03a38d45a27c4cd52d5f22221bed1635b45175e32c8bca63d33e646d83d271d498bec336e2103b19a2060cea888a0123c96abc45e10b4e0c06f1119a223ed78f5398a890bedcf88e3c65a2178c9da17abcd2c0540a2af1d4a3f6f6c47dc51908a3cbf352bbd7d13b3f7688b2575207369b48b98430ba7e30451ca5e2310ed53e70176a79aa8dddc7b7d7d513a182503e77df14e37d1f23947d510e5a3cfaaf19d5966f0ffe60665b9b8b6c60af0e856f7332770b30326e56e8f4a956d266e15be34e23ed3b53e17da579fdbf9dc6fde8c9de3a165e35779e9f858f7aaa298aa86c6364cfe45ab112627f09118aa1c195ee26712da077a2fad7416bb508cbae48d9f5571fb3006a79e001293e4dd6c7ce54f874036200506f576d5f4a800be36719fa8f348c4ee531f7fbab9047be6ce697f298119f228fce3c89fdb9fd6da0c6839060781e7d0e7621dacfbb088010ca5f9b71d8989694469a9d87a3c2a89132647c61f88c258d70de23279c59135da21479c6f83b9cf5347f3ca055bd885494c001943462e6d4ecbb21281be8d4fb90a2f9956697e148f9a469e4a752e491515ae2a95d194add24617c7c7f6d973d5fb8c0e1fa259fb7ec43f744917119351afcb684124e94df126028b548c81665e4600d34b3084263ba2d261586e3f6c4648f734702ccc502bc1a72e6b20ce6d39471cf8bf453029b384860b9534ba3cd20c34bad5ea17be11275826fdc311d43b8fc8affcaa02ed55a041f46a07e17f18b77efa33fb6489684f3f931efafdfe8ecace30b51b44ba3ff9bf9e6adb5ce7ceb5972d38eeb607eb6ef806d39a70a17a7a4c7841a766796ed1ab3b10bc2495efcb1430c55426178d98bc945e50184230d5309fe7668d394eafdfc82001a7f1c64cc08b489ee59b439b7112d4fac3a5a8168bdfbd1e9357f214070a02ff65f7aa80c63a791d06656671f5c50263bfbe34fb6df4ca7921e30074795693f66bb812c87690b68deaf75789a1ec4ecaf88287d939073ec4ff78ef6c6781b77e83dd986fc85e7bc3b58b504e50b970fb7eb58449bf1775a5485711e6e25699937b354ee9fe98f37c3a70a48c34f19f3cd993f5d73b66614ed023b4247be5abb547d79ab8ff5528bbcf7e1c0441e3068894a6acc2331c8332883ade3a473a0d1784b07450c8477e6a759cd198c2bffc82153dcfc6c242ef98233d3c5bfb122aa9970363a8a80b240b9b8568fdde65f42b57c66abeb6e9e80045da8bdeec7cd2cb2afa4f652cf118786dd63c8d116467dd4d231328ffb7b8c61bfe8031448c70bf7bd59285b6ebba2a567c509593d63cf394e16ee37cc588ce24e39c2720174862f4e61d99971b92ad7e9a4e3aaa754faa16ef0702e3a2cb1fb8b50817cb0c3c9fae1a926735ee678176980394f1899279248e4cac76be3cd43aab9657bd48740fa8c0c5db72117fd23262a5d33c22a92d7c5252aa1453a90db6e947db5606f77568fbf7d314e105b0329b314236e67b1fc188db15a6d3b2c869e5ac0c835cc106b8502f2962f53de31a8e8e7e5a7f77a21e437947bc028ed3767542ba5725091894724d73ba90018e2a246f35fbebe183cb22b1fac4e9fb34999cb14881ea99928c7c8535c77baf0b9309decdeaa9b41467813e4e30a0799b73a03ead32e28b3300b7ea81c465f0d94ec4188e00e5581cd2269f4e64d210124cd508fcb4ff59e7886ebcfee1b33cbd59251840424c980beb94ae39c7506925f73c91dd4df500a1ef1eac6d7a18684d4aa82a390e3b1e3052fbb1f038d6180537db548630e7c8e95331d7483005029e98fc55cf957df4fb4238b7ad1bd982ab73b4f1320d727726fb9bb1a0d9525d30379074ac823761fad63c6590e7edee1dc388d482924149fababdbffd884f9708588dfe4d18048db4bbf7d236942430d2c006de2d6edbf74816dde7eb4292840a5eaba7c9fdc90a580a9f838c7d5e0ecd7a52b74e074ffc7352ee515011642a33e482dea996d28a662aa004455953bad428483f42a33d824bfba5ec8309c1e776001c3ae9ddf8086e6780da57e0112faded00148dc1b1076c747ad70b66e513a40c581b1365dc9f9c02c0a2d8c7c90e5aef1b2783c822d801a3f5b469613594fef1e4c763b439ecda4f8980abc1ff3ab35a8cb5c19b0ce1168c051b711e2768c88aae6cfe8c58cbef26698d705c1908f0d0226f8956c183860f6dea1998e4f2d72f9d15b699c394d687f808d29346cec8b21b29bb0876785d44ce819e9d3e8847dbd6d447ac6edab5ddc13f982f781aee149f03fdb4a4b4a012f6f3bb9f9b530ad629292a4c12a389b9657972421ae3dee5f0072b187fecc27b98566e48ac52236b431970ba8194a799afe90d7f7f45168af9db0ca77842de7a3e5530d89b041f45945034c97384ec1ef2a36d49c7dff0ecff4a807fbc913f06a9e55a106da3029d34ec500b79c39d4f1aaf8dfacb5652c94ef31e353bb2c0c513827d23234e2d7d24633a496d4f532aa83b65c66fc4a9f09e62505cf7ce5333d7a42c7453d21af82047bcf4d5ce1a4fb03604e557e093f5ef3c509f673d582ab5baeca6897695f4e11b8aac4f26aee9dcb27fcba48cfa4e5a61c491a2bcd95d472d319677b40038a5e3a2299328763233ca30361a987dc34ca777011a98f6d1be89cf14eb12a39d638fef5c4d9d1da93f6d909aa7a8c4b67bfefad189691dba29bab30c41897a4bbb6e289fc7c50ee74b9dab8f5f7848a4b4826628931053d62d21ec1196336e3a0c857a50df93e4fb3570fd05a4ac1af955d4ca8da855da390c6d1218b1627a3c2eacd27dabc4a1d9d0042a9710730a28a5fe5dc6891dbeb75151ec07625d156a9fb22bca845dc01191144b6e94638910458f92abbe0eeb21b5ce9faa511642222e9853cc5e78a30afc333aafea8e0b914adf890ecc3af226689c70c17f653b5a67cdb188e7732d495ef59ed8711b4d43b5ffffb4114946575ad3d109eca9102537aed43b1544a3f90059c5d757efbc29e6a0436d4a96d2979881af68dddaff6faae7f30080e3e25d0b7c7c606bb7e2eff86c287741226bbd59412e4351cd8551c9b1230bab5413c70961186719397a54f5f02f95a30936bd75676d9978eb10b139d8b15d5788bbd63c1e1665f176a322c128d669bf458798216b78cda8dbc646ff26b7fde591feab3c6070e685b5bec728cfe98ae7563803a2be1d42baddd646dbb77c97e78a6ec9cebe90dbc3aa5a54c9dfc69b423b9498e29f10d4b2cf2154a4f3a13e036e26e2ff34e917473176714e90fe3e8cc0d60506a701baec14b775bd15dd7b6b64af58a6328e46b957fea7cac7acde767bf79b2929d51775a35a066f05a3c21e6b1b034e78ec6a43d691bea56a3ebb65b2917f05ee8d7e21fd8bee3acc5f62d44803268921e9ca5bdc5cdd606f30bf0f6a9ec4b5369fd5544de05832b5e9451e626265e85b95fcf13e6405b315f74eafec4c8ff389e6e4068ebcfebee84f2207e52eb6cfebf57f187eacbee7dd7ba225177fb7a1d61fc631c59029baf5717fa02d7627bc6cf557895be07506a77b4f98761658ad237ec25decc94da22076708a93332bfb4ac1ea564490858858a06bf0da02a4ddbfc2e279625696ae93bbce0b8e9cb8a668bd1f4303c4a07757492f825acc2def39f00d918e17dba64e7239f1026681682cb43b55c87d05919a19d77bcb006d12b15463a232c64099281e91d735111af2c2a31642546102ad26b520a2973ac9e3ae3f246434793f0f74783a8af1248f6322882d13d861b9db3c312ccc6b6795aacb6e426df56a04b3c92c59645d52d59fc3607f914040ecadca0cebda50579fae8da04e04c2fb2c46b9ba52b33aad5873ce0076546798dfe4ab80710ce391299b659c191dc05969f763749f057b5a3d5926d9c819f54b1cfbfe1798b75feb132af1039a3887a086b074761b4b7aec65069194b3a25c93e1360bb98401e6c1d88f77882a83a868103ad3ee13d7d79826f45160b89ccb6fc3d296ce010279e7e606e70d680c70e19fdc42fc3696c622bbd06544319f8e6539b1dcf97789af83eec15227e027e60a6b59b4df10e6092e89381bbf0f6cf34e9c3cdd989edce49a5533f50dbfc704351f2ec8270b2f290cb935283a2fc6e47cda52398742900f82bab7d3b69584cc6f298f778eb76cd6d0f6fdc0b09a6232095155fc5640396cf89be7940ace26b2a1d1cddfd41942ead35f6f3025241adcd7eb0aa82679cafd807a9f70de14ba49107ffd878ea924482eef28013108f18f27a984764773853630ad3936f1859116da15b34709553cddf4e57b18bbde3ba52834d7d884684db587667a5950c86cfb9bcb12067000056c8b7e108c41243e5906858d0c8e9f232b5cdad1f11d6a83cc853a343d5a396cb3c63d042ad8a3600b8b204dae192eee53b91b8c2fc9298aea657b1caa571e2dbc5c2b15fe9a3ea7113ec35ec4bbaa8903654e890bd2ddbb702d6ed16b517e132b60bad9ba6af1f5cb369743a8d965f0ae2419aef26b1512a78176b8d9aa1ae14b9af67e54cddd4bf7df768913ce5081bec73137da51f732c4cb371f660a9dba78ee79dd11ed43f1b7bce8d265edfb6e0ad07c72af72cf914bec7c3163c474c447f7e218447eedf0b61081a0f88752ccc3578e5cf12ea66c1b758b6d4385944b4602f347f5ea5a91238e9251b37bf917c7cd6b47c98b7a72ee92810d88124e18c275cf4598c6a1627cebab21b044d8170676bd1b85d6ffc2ebca09be1d4005d91c540e890eaf1e7248d7661f7a9580e43d25919537523831e678c6c23fecdfa002df5527a748458f54e015febf34166fa3d1be5655e1080dc2ba93c42337e6d386bff6bab1864538471fc422c4b3c9bcea3e739ae50a74bd9c8204c2e6e29faa3427cbab6f28ea3491e0d7b77b3455b6ab02bfd3c97859e7857e535b0eea37d47d06260963345a5cbff2f9c4542583bc3e7a214ee01a72289f6fc767b3157b96ba1ffca20d3eaef24d4367c4942e734086a46be211e57c414ff00adc4508dc33edc3ce97b30614f23a727c07476dd3bf5c0de5a83e524f1ef56c125760ba746e390fb4e2462572772f7ab6647a578e2251673d3d7df566eafe9364606a1a9ee7e59b49bd522b8ab22edeff15bd637c745d4d8cf122872df0ab0cb128d635df563d7083126e9bd4d0ed26c4c0d2ed644195f9f90d9c818ef3b0c8ec3afb5ff645594ccbcb91f6c61cf2010541b2fb5e2a6fe1c34b0e1b86a33ca3d6c178bfa971929fcbdd195aa8092c387909a93764c45862c44e47f83ac0cec36a2e747c8d25e5d444f34fe377b01b8027b98cc418e4dc15d0775403eca6cdefe339eaabc11300b5b3e4cd0e86c906f5cf65f3b6e66788113ec49245f3e2316aeed7ecec5805a4cf8d3831ed7813da69adf79c1202a63f450a3c7c8e3e0952d3c37b1fa01107af54b326f4f5212d4c3fffbd8d04f764f9e41d429af7396fbd32cf81c58bcb2ee41e8c65c9e21b9718aecb943b4e06f2c66849118ce16ad5c781873cb3820cb7dcd9b84b5005f2cb5c9efb6bf553b9b3a9d4d46a555c66e668be5f92e47b6daf858dc9196c904c0770ed8704b90dbc1f9cdcd4fd0ab9c933550611d394e77ae1462be91605d71370e771929b70856a842ed95c1fa9f7da89e6b6b644a0262eec443c266d5879531d2949b5ab6050695fc5c4f5aea92ea7a5cfaa0716d3a63dac663604e4bd7d18f2906fa69ea76741731aeff2a02505cb7fc897138efa123364b8d5ebdf96462bbad389ae887a53c22afacab1506f83eb72f3db16db2d982c3cccd3bc2e1ba456988858758e0b6efb971805c6e3903df23b01cd4fe6c8bd16676f976c6e162cd1e2e82260cae79968fa8059241fb9ed3718cadf0795c09c111859d1f7505f3843174e2b725b0e908d78803297ed6d11fee85501d3e74430552a56f104385481b2b5acf0d245f89fd6613bfc6d94a60666a439effa63a17894ccf450a589e733d27046e485dc4deaa6e108a2138da829e24535ff190647329ee9a153dd5b38e12f0cf79232e9b59f3415dc5bf2ba140463bbf8ef5297fd763bff31c045b143cad04e48a37c32a73da0e89580620960b3be3f25c2d92c481b02333b45a4036640e111f61e9d4ea4d09060c7df35cc04efad1b69ded3f9e19ff542d3563506ff5a8f4703d3ad6ae9cd2212582ac6d790118ae7ef7f53a9754b9a4d20d4ac1241ec0583d819c4e9eac8496a492736ff875c6fe189fbd43627df6794a1902713922069c89922d82bc41d01fb9f3e575b339215099974c8bb469a12f01cd4321435960591962f1d64015050e8e0b135c91e00a3f8a806f6563a668d7fe5b8171d1b56354add6c72279992de1055483f7a0a7309cf90a0ae5141507326b56dd91bd7c19042c5278e31fbe3ff391699b637ce2f9a53e34ecb49fb55f70f07c16d371c467da6552c5fb740267ccd638b954331b76e81c4f7dcf0e009d4f57ac67859f3758967304892614c663dbe70fb03e132d47b14161e943e73fa880061b1903a4174405127635d399f2367e7b22e76b3bfb4d3d800dd52f9dc8c9db83cafcd34b57898fbbaba6bcbe1de67e6831bf7432950249194595ab54aaddf859bcfdb5ebc96755eab64e69bc3f6628846ee5be0ecec894ecb897fcdb615a9cf7a402ab7f0a38a23f3239b6a6243449f252e918d7fa5316a9a0ab38767091b0c6dde9f624b480d5b08e711bf584593af13fa4897fbd0ab3354560d7f1af1c34f663d98a86b9b3590c17c866c484c09e8fa3a3065779cec3a801016878c57edecb26729f5a461aacff3e72bdf70ad2c3c4964c385e68e164722ef4e87cb502d8cb0a38c678672a2a8e0b53cf6e707db53572d0e836eac0ee68374f5c4c5806611dc43acb01ca32bb6679d5362c5a59102f2737eacf75c87304c2b3410fb48cecaeab3c7b81ce1c0aadde52e4ec920857c78c6923524e395177f5459490cb0f7665dbc6ddfa8ff128b7063e467c971b3c115a832405d4ac78ca8dc54a9cb5a7b1dfcea1113d45e387ea4c5d66ef6b480fb69ea62f47a4497ca0edf8ca3cf49f85456c8d02d06441e8113003a21377cc364c69a7a73ab6c6e2c5e084b216507c4a8ec399503da6a08e6f9426ca0e840b692ee6bd57e9ea9a7cc5cff73d3f36c0b8f8b8f2aea9ab75fe422400f75698912af7eefa217da21a66c1d677a81c448a359608828bab2f4f7411f2173993efc09d4373313a43901a5d8f540e4ccc5040d29ba925a6348fa346c55f35c0de69ef622ca4dbe403edb040ee83c6e8d73616bcb93f598519f06378fa191c9839c3b76904e2c3d1fa2227d500716bbdbc0fd491d44a2a3a5c11022a5117be1d561d36dcfe938ae0c0d15cee6bf74960e9ed99d4013644f690f0c2614597970638f690284f3ec451e903a5f788f38fab818993d5b0b31f289c5cded6e5eac7618f70518d16f7d7d1768f653b3b62a43fea5ced6bd23479e8a123b22adada6f8c27a505af5b60e0ab0355ff4d1705d22c8c499b5968dca0bb7ec9368313e612aeb94531104b44638b02ad572d21d3e888e600727c79d04da2dc2f07efdb50fece4bc21992c649c3a877546c8fdd8c886d176a327595c97d59dd73b4d95ebc16281d3b048ce8c542dc29fbb51b55f192d0eba9d17398c4d62843651d92d67a0a9e8d6f45835915ca5460c86532ff3f44c9479a3a1a19f15ea0fea95906bcf0ccb0e1e638366d5a5363e0775ab4ab7cf7cb6d0037080ce568a64c37b7de4f5be74de963f43f87c30651453a1605d884df89a80b73b2b3fcd3f65f1781dda20d1801d8c97a4350d89fa4d8670f1db6a4593dc50196813e09bfc5837cb8a3712cc26bc3f210ea9fc0e6acc1f77b1a6d429cea06620ee8d567b4b418386d2f68fcf8d884c413069dca6f2185edd6f2289b7d4e51ec486a2215c8d1e513673b6fdd2b9c3dd9e7018aa19526d23120c47c3b57a07ddd6eac3302dbfc62ccd81836a4fa63c02b2f91d43f8de8dbb15513ceecd69188d3115aebb3f24e5c7e47c1bea467f817f16db27578030b7375a64f99a8ef8ed16f8b08ef0827eaed21d8a6ad80ff308c2eff44d2ac0e77e84cdd48adfc49977f1096d3f407058ce931ef1c894e99d345f4644f2e3c19dab5e251d4e8d89a6736beb3787af590c2967dcfd69ec535cc9a6385bfd264f911ac511c54c782a54e6c8d299df75cc44ff8a471f44bbde74fb890965d8a9ef465db364d42bd176d946dee824f7c89b6fbc278e6d33132f76db8ce9f6adb772fc08488da774e8df63d85fa13abc2427aef9872a2a9311e384c7cc86d8c3513fdda457ccd5d8babf4b488f52f900e7bfdaf54262e139022e4df974ef44a3d31e7f95404a929e33d951cdbc469e74984db5073f5fbe749ceb23ae5c1a6fb35be2d84d41cbe740a125ca3934df40abb359647b600ab5b05b6fc1182a35c59fc2ae5c65cb489058b3ebbb44c91af4b36957d4dc459b239f04551c8b1cd6393aa1b2a371c7757278a1ca72698dd4a587fcb29d1ed12734e5ab308bfd05b21b04a610feb38a535436a9f243a4dfd7080a1361170a0f07baf1d79a62b1fdb6fe49831a922b685fd0e81048512a76a127f3ca5dcaf5d936cccf97eb499e2e8f97d96cf69af72f188492845f69343feb7c8286ea8ace945cafa039bc18f8a1816bf9102f0d1099f721e2b3546bf73d2d17343edbf8cc1c27743ae527510f8e79c294fcedce8d320797640ddebc73b8987d41c3027ce754862f5923eb3a050c481ee4036ed1fd9ff5230c4097bbf1f48f3fdb433a933e24399a22d252be715233fe09fea99d7d07caee1118148000742836148bdea68b2a5db6d16b4354ef98d039a7a1e4c4296b78e159ae0bf64b609457f1b33e597d607cc64a66832610c5eb7f57f7e64d1844fbce7bf8026b810e4a5e291df6e1d2444e07683295c2d9b85c35f4630cabcd9065638cd2bddc55d95da7c198f9d9c89aaef4417d8e4f38e4441b80be29bf3a9c375b81100a43282da28a9c4ca4610793684bee2d982afc1358606e609d05bd28d8a03a4caaa3702fffc3b47ab2b0b54b8fbc3953ac5d627bda07b209b976996fb92e5627539ed8ebfcf31bfe158f6bfff11648fcc549de83eb4d0b163272ba9c17ec8b4efd918175ac44065c47ead74e40d3849eea56f745b48c419d8d0464e81410763dc8a5262bedfee5a049090e9ae2fbabbc7caff9e1f5fe9dd125f947750f58dcbdfd8a9e2393fa2d439d9811e1ae43e10515af03e2f1c0bb24907e03d18c820de19caa934146cd095a538bc113a743a8d71c2eb3f55c4287c8968acf696ad62a2256246a8cad21e0a6e09d89b7819deaaebb1fdf97280fd96b648e2ade82ad0cfafce6a59e35bb80a92bb80997fff9b1ad9f062fe17dd7de1b6f8a5b217ca4c40cf3b177e5b56a0dfb9badaca70b777ff7e74154f7475e21e7fc0254975df6deb2b9abc9dbb8176a1fee6f4b450686c70f21d47ea5c36fef8172e8e7d36933704ce976e3730d543ee2849e7ac0890fb9986af0c2a012a9cef734a5331ec6cd84f12329dfd32223cf98dad40926f2c3d1ba1dcfcf91adcf77de590133734986f82da02f8b5a6023b3e0e1ef1d89dda75fe32ae101ec6e518e0c09d03368002c59be90c16006a44b4984b49a63c1329f9da6b6eb12cc5752d78f4e3d7ab5ba3f7fed579a24ee253d2720ecfd155c95678dab774b616a25783f66d0912def45774fb496ca5f38555680c05b3408384525cdf1eb25dfba9ed6e1b045d2bb53c46efb41b52dd5213825157a714cc1a6cdd0dd8fa9fd5a9740d4e34adf6fbe4eb62c2598e26900bddd43945b7f68068da3014ce6466fb8afefc8e382b7f888cd1cacb9b5bf4c6c5a9ba0145283f6da796aa20926db69648de57d10bde4ee0bc95116b2eded26433592a67f17d9f8ecab258563aa25e2682c6527dab090e396f44f3f8a12e4416be7508f367de16a9bb67e4eb1dec65ae215f66daca7b92b53856e5023e90cde8c7ff4629e4972b1b109eb83001aa1363ddbaddb61d50115cae026b37965bf3c1eeacc2cc94e6f6b7c8370ec4021faf06bf03d9393ad3b3ca74c6f1a6d04d5b2f9cc73a8d032157be79df85a7ffbcbe6b263184072e4b952fcb9054cb4f892fd06589691c7bd61ea9a6b8a4c37ba7402fd3542ae9a1cd031de6f0bebfc7495b2a3ff1086b9e29b30364fe5b62d5ae0417e6112f615574c86331df027aec7d66b5e3fe29e78a462fa2f19de02170a17977c5a716a0ff87cdf236bad541c5d3fd400168b4344d031e754e2acc64024e2130c7e8a7f01c72aefd001a28c99233a2f1a90d828461ebd8e2246b3a1e19f110d9838b0a58cf2524ed5630e62d61e1ef4ab45568e0703891acfe56213aee23d1df2dc6e4c4446b778504a023c5643c5f5637e6540c01eee44f9d218dcd3cb2ac6b9a02ca29d6805ef4a7a038694fb7a4fa4010ddb09613abc715371f36a4c826a0c0a680ea180b9c2e2a29768f277a9f95f78aec1a919ed3aeb4a212a79a9b7234e188fe3cc2f25cb12c82c15ec26bba3acdc68624c91cc1141f7e55c01da138642f8f69226007a612f633e3eb4fe8b31dc10d22df35f32359f620cf4dc82178aa2cbb3d26afcf27f5353d5dc5f6a4b2061dba02b6c0ed5515fa18a628a8e0f53789de195e82e60a558a5ea2e5408388705877176649fbffd93b2e667032a71a7f0fcc8f176b81f0c62ddbf2834209052470b321a00a01689e7f0d38fe4cd154f94a5fb124b210f477cd977466b43149ad0559b529b552d523b3a89570796f6d21e78a6a680c0ea99ef719116963656c97befeab5bc841ebac17e1aadc36c336d9f5e9a0311e54762dbaeb07e1fdfd0646a525f3d1ce0354509a6b4ac073fda8451e7846f2965d1673f05037fa03320a5ac8915b042bd35870f3eb72f7ca59ab83ea420a8af643eb6506789d1f7ae3bf1122fb05f51d5d455e7c9d28a0efb4302acca11d4bafae4966fe2715db4f46f278c37dbf377cfa81be72303fa325f115069f2ec584f9e59a3363f209aac8d1b7d4ce2cd944277c725029e52f171e52d85099694c3a5f239d3a336af386e3039701593b28f6ace1c2b84d0bfc8e8206dc092bde428a12d79c9c5a4abd4e6e2a2a231a9353e113227cbd020685c4313b38001c326efedeb59a6ab539e3a878b96e5ad098edbc328c14575c930f8eb1530728f93ceae169f9070c4f98f24540d1584414f3c4d179e2e594304eda349cd133d8b294afab647a01423c51d6da9ed6176015ff00fffe41a6693094c6bd13e0801b0dd26c534b841158c5e8cde1cbc2a66c58779c21634f79a8de42c3f0ebeaf467282ddddba82f2f44b5773a802ca172fa94d6e7de81ed5692503d4600cedc904c9a94b1dcdf1832b95faf4e38c1fc78c3500ddaad9ae96dd7c9fd9f89ba318422ca333a189cb0d826556bcdbc178b01e7259e1ec3a7f374d594750855ed814c6d720a2fdc8ba47dbe1cbf3fd205dfad34a1c2e62454650753a4e1a4599854eef6fd589ce144f1142298881443adc892b46a7edaf5603a54d16f5154b4ee4fc9f78b7a7d3f3a43dd940f61e225efc364902974809a8b73ad6f109f0aac6f9bc7d381eb5c074568338f2ee5832ca4a61c65cff1b514aa3a4c582f2fc8950e441f36a5017ca4aa44154521e6966a93f12d1c8c772506377a62442108412f5dd928be0d5bbf5c31d8a5efa613c4bd34b895167c845c8922a96e4ac24540d672ecc2aacf042c09fc713ee207d80146bc61f71061574744aff1e9e4ae2fd04979178ef71eb4dceca3b07cb7ec318e4264f65a29a712634d1c492e28c94efe800b9b152c8dfb2d59ef2c26b17effa1d7b5651161b4e4485cce548d45040df0923287809f58f5abe1d9ccd3f44092f1219926b7f2e765573bb6dfb7a9b330517c373f853638ab00d7b768a74956733a5df81e8fe19f82926e8f80b2a60dcf379a26f18ddae5df09a628411dcf622861d960596b8e0e7b50d61b48ac3cc0614461a8965a4f287f715c6413245e5e1d92969895c040a606fa6c50256a33487231d1557f75a47ecccc0be6a7596b5bde312c0179ca69a3ced98285264c601a85e313b8dc49eb4d38d6a2b17a0f6fafeef00965c14210a38dba717798d290a463d667cdb0e9e6e8fd8f314bf969244751f954315cf5c71576b063f665765e7e522977d8affd05f4ede67bc49a52c1205ebff8dc237d7431296ec4a9e6c5663f8fddc1b93f44a927c7dcf7779ce5e3368440e0a4e09918ca3df988cf215adca78e12f1b46abb9b61c84a4cd4af1b32d9c72a555f6ca828b081740209043e795ff07f5ade368d4c87ced8b8767eb6ae811f5ff42fa1f2e7c959014a317747b1f3ac3e414778696b19d55384d29e47cf6f5fc3e6f79c53d23232e317d0a729ecdebec3a2339e4328886c6beaef6be8a7120cae2bb1de1c67346178ffc2b1f665a125ba3c847ec110da9332582733b6e6cac468d39f7c75d656c0a787f96158709c5125ca424312d5aa4fcfc961795c4eb44c9a0a1deb9799703676f73832b95722cd9aa511102057d8afbd72cc826a18183fab29cad5d2d9c41ea4da6b9eebe37341a5c97f819b5be86d42f25a704ba23b347eb1c40e657f4c568279ec9e8c7c3c3b0534864e32c0b8a99a1f23754e204a4de86cce4e2483b19cab3ce5f46f8090df7abb528a43a48973723ed8b848bf62725000ca7be3d10ded9b34c65a6b818276c57bdce059e883b4358eb88a2c82e73a01a0e7f73223e45de9d4bf0a769d201568a5c4608e439b36575dc9bea5862d5a6ad0d1e97ba6ae9368a625a00f7fd660b2373df882fa96a6c59bd67cbe337a1a9f829b7576502141da2eec3d8c52ed7cd7e6f226bf3ea038e50af80a2b855958119dc96312c303084070b3625259de515c75416109eb6c797fd4b3ca1c90ed014fc84f4d8de463ca25487e98b30685f4b4629ae2c027e17d2a70d0e57b0c1cd0306d9aa3c9ba64c252baf104f4b8a141a7748214faf3e53e299e3279a8bbce7d7fd2c6b5cef871371e23186f75a34f2f190b48e1bf7b1b4764ae8da83db52fa370d09cc64c27f1ed634e0b628f176d19e1cee4e7b1b9f7804786fd860ba5c3a552674f2e3e2e2bfe3bd55a7c06053671e14aef7edc0da6b5bf00f780ca0300a30f271ae6ff76d7a497fd25286ee6e76d0eb55fd2d00cdf3b6535724bd9882632d41ca8ca6393f4ad872c0e64ab369da689d209b51ea84da7d32dd5135e39bb171df2fc08f7648ab0e24b96f5966830c7703b41b2727b8c6301e32ecbdd18b001c3a2c923d5e7bee4220aa917633c60884d285ab2fa706fdb567788f51ccc96a252d390c2ebfbd6993bb5e6f384543d46f42191a3b6db2ea06868f35d94abe43064e0c06f50528b20934311b75fec78cd29a49e85c064dab86b3af86fe5b60ea1d1004e508cd393b60cde5cb8856f7af0b25957c208f64ea406d2e5b4541677b10076bfdf078aac289f13e8b640fee0ded86d463c7b76223c1a1a36730e0fce78b67ed8d92eb6534deb0fbf698e993278bed185a602105b3939f470b559bc9a4931c58f8e0f6b03c5fbba6fc1223fab77cfdfd3cdaac2f83f811027ac1075e85bd1a2e9cb40271e927cf06576d97a6e9bc40e1e9af8c5873ae89bac3497a602207cd3c83ab3a0f6e36d071badd7658f6a447604c57ff642e3d0e0ea2f0fab5f0b8ecccf7fac8ab9f1dc00c7a9a508068579562289ea65d448a3d096013c4f0d1f2602a564dfaa3a6d4919c55a755f3d484dd8fb21ed075a87873c458c5ec273926c275c6bc44f9c5a0601f93bdcc624e23522c530783356eeeca66d97ad8f5ffbf1e39b7f2230d21e88a85862f4a51fdf811a16182155056c4eaaabfb9d7bb75361ce3e6916ded02069ce30ac838dc0b0b5cb61d84b5746734b4351ac3101d10754ac6c929d144eac3b5c37bb71d3d4f3bb494b57c3e957b1e8d2a060665eb51c5946b01458ff6ae1d3869fa93a9ce31bc4b38fde23595d2449a135420ee90d1d890c6798c526c6e057c63dc3b380048e916c1fe0637d68dc45c132661ba72e49b853c04b0278fe69ade6d344d2add0333b84cf11a1dd9b69083e73600fd412c2e481930032f66f53a8be538d463f27951f997f0099f0b529a5d4cad2d6763232ac4d111125c2c906fae5026ad86ab2bc6a989529e19d65a55556118b87eee5313c7a00b2d59192c2b24bc426f7e700bfa0defef55fcf701d6fcde60a83c91bdb952e546829cc7cf0a501c54cbb34ede480aafe1436a15f12a6dff6ceb35b4881a098d5413b0faf3086fffc1902a60cf2315b82fda133a176c244be463db2911b8119ade7e9c3c91a1f6ac8f2bc3721279d3d21d0a0b5400614a6b7896e686fb8a3620b7dd1ab15842b132896f780ed918ec0f3fbc0eb7bef3cebdce45dde83250b823221b9e7d1f2cd8b0f89f00c3a429ea32c7a33519515383b9c94fd2e9d848f16438df62548e021702e2bf5e8553572c1a46b9cac4299dffa1c145e8cdb7daa7fb64cde7e1b1c357b2ca281413188729ff3fa94f09b071803f1416e95beba1131d3a6fc1df67089497d9cf82276c3d9ef7357d1924125f348d945cdc6d5db4d619dc358c99c86783f2740536aa7802afebd9d97c83cc035d0df1b666c5065e4245c31030161dad3d31ab394273a894254d58f5e2c4f1cb7e672d62b9e65863b85dbf55f6568a426d272023e3218d669c37ef0e6915e74878ee47ab9697102a32c8cf6c76411c41c78d34b2376f111ab5a01a94ca0f1034e909b1d1374fd3e74646099070a5a2f227c26be0f3cfe6002930708f43214586852e9d65a0fc7f01e75fb8355d5a0e57a180ae70b15df85885192716f20d21664899a21ab69fc4284cc1d2fbc041659135b8205c9cfc7c2e95d31f724d95aea25cf30a9fc462a40f351ffcf3db9d53cb5830431f3a3415a5e2ee3ea121b64f1961dadbdeab1726d4aa0736bdd53fb3623443a9fec691549cd2b1f411d43f84587b85a1843ea0769f56ba96b321a8129d0d60bcef5d31d1185776d80600fc27ad5def65da78c7f3fd9686e2212035785192815f42f0d99aefb7c5636da3a2f80ec4a8d814a73a0b9dff0229bd8cf388433f718772fa04e34d090dafd4ee44add246048112cd621e9a319e4cfc99da1abd7a25f0f20f93628e838c33d86c6c47717efc43c0c99ee60bcf78216a5e9915f302b06cd22752796c3354f0b8cf1b1f12c2fd84ceb895063f69f991c90e6bff58d4e075bb75b457118e3bdc915480797942e5f98252ed52acd8fd0c97b689721e4f6bcca31f17d5d00e8f08ad49c735a993819a8c10d8be8ec255a84fdb6a59674aa84d22c23b7c673596595855cf05d9d5a190c7bfd802dc210a9ba7e4c1512bc7dd4c106c5d8bddd768088345b6044bc4ef77cc2cf11e1aa392ebb9ec5fb6e1e64a2ec8c3044a4d18fb36630ecd2748b7c1246ea91ab3de68dd0e5f64861da5a29f856f3c11b3125b6b059ade1db6f436cb32fcbed1809b99a2bd6d851a4ba482b9c6a7532ec9e2abb2efc572c2cbca8fc93092a8130a31c4b555ab6c62c1e0536c9a042a27edb03af975d5e6a00b5b3e8c5b2715f483e9b7edaec83afb4145356f81f2856a9044f9463749830ec63b2deade3c02b00726ac50672b66856a1d6c647ff96ed6118467185b430f7317c0cb9c2e9c42ef454e8368fdb8d602e45b0af48d9408d5be1a3529247e9a0689fe7cc19e69f3bf4b7b2e8ad6d2fbdb90dbd9d2a8fa0f88ca3ca6b5810e07a2ab271926baefea743f149fa1784aea8cb56a79607f205fa923aebd8b9f3622a482f6796543409c52de","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
