<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c60f42a1cfc589fd87fd328ec059d59afe63357e2bc795215b3b8a4c38f4faa660afc93d813734193874d8c5eed48167a63b5e4dd5ada1669826840974e986086fa9e87ec307ee82430379980e37293157730bf123c0c0b8b5b4c7a9ace7553eceecdcd336efa113bc077274d2b3e7ae37775e953d2696b7ecaa7f5f544a2e33efc9a4d23419cd6866ce9bf4ec16225d07c4469bcd45349184471ad50582682f5ab40225ecda13ed8a0ada576f3f011a4627f8547822d752193c08c8b801cc563e71a2faf4357336eed7abc990fe2f48fd1e7d1f4982fc73976d360ee80f8272fb1655a9f3f83d113ea9e532dcdfbdcc4788ef1869ce5a8b78b91d55413228d104eafa9e0846e0719d0d57717a54f11a604754a7ae7748f8fe3a73c04850dee93f4c12d5065bf4dffe264bb85d982fe13ecae3723ac01f2d8cd01efe779f01ceeb0eae8b9a64831075e8aceca73bb5cd87b3dca1daeda9a660919c80384f8c3cd013747cd1371d1909eafe465f3b720c3de3b4f74f7b432ded19dc15484c5547beeb2d0286b8edd0d9736a972ff01015abfe45fe488c1764ec1bed1387314cb2e777c9f8d909caa476e8ae3f836982db5c60a17f68688d5b3cacd12cce5c64a62daf37a5be6ee607b02dafa741bdea44c7a031cdd30d2615b57a628bb9fda27158cf15193acc4ea67a1bec75b77db47378bcc567376921c78e3ac9d8f72df14c49202b4d274e3fcb26188d3f19b5b62099aa8c3328720dd708f8ca8ed5bfb1b3fb3ef342b2bbdbe1b228e12904a6e9965f43e32e0ab80148a58e86e008205fa4a87f6934fb9eec63adc797c20b3b26b1d28a3743c926656da1f13d0d588efe90a7ce859d2a4a43a6de9d4fc31d02781b046400bff349d5f28c9d72bd79232e0b8251cbffdc3747407e08f5059a19439c9e1f3536c882d28b674e43d9df9b7e2cf2f52b14afec39a5aa672035eb7c33c3e6a8170878afa2d8cace2cdfdedf20b8225d953e3691d4ec3f3166e5129bcf2e7bcd910528a69940094835ab62b62071eb185bd479db9d60b914ef75c97f56da646a6a5dd68f260127d40d20bd2abf1ca0d5907ecdab6c312012127744ef148deacb092e11539a5816f19b27563ca2f476e2fdb25ffeb55a95220c972e8afb751109d53af61e1f593431654c02074cc2c6bce8060ca6c6d8a0eb1223faa26e7a2f84d54667c181a611a27263f333039529f516732ef71eabad0fd66caec19081e80bde7220675d91bd3aef25c1da3406a901c016562c05fb914b5530bde7b38677e9b97f6777c29748ef1df32fd018c0f88c0914850ee3124179dc303b9906b0c4dffe9df060e117566aca26a73a780df3b6c4b018bc5a43a41c3e737b55f832caa299560cffa9883af012100e1e415070079b59cbd932146d6b90d5746107c1e561afd09f7532f199d5dac6cab74b5cb38abe8c82d42f47d4127a1859d61d70490e41d1d8137d2c18097681fa3ac2655ab7e7ab4d31217c7573d529e9f73564222ebeb60ca77e07c9ef9de105970b3163e39246c4145c65656c62c6893129e29b3f4ffcf3a287c07dd57bb8c6304e864c666251e633d2f4148ce60bd3eefb33f0d7af292cd1de4a1da0beb81f2309fdedfca0d0b1fd2eab15a1b16a758cddd2ed420d14d99dd697b66c952ae867f27cd93156b1d73ac523bd33cc15c06b2642138c3054557355b3c4d31d6ee707bc18ad564f760081f4509e634783612bcf6f80683f3d17ff5b4ab323f617897c290b631f68534d244c7ad4762678e71aab54f9f80578ab26dfc5f5eabe7821d673b67b13d726395c9ead8f8e5e1837ddbeb1618ef66c665e0eed3953bc9effbdc7d8e73f635a09ebd88563b450e288db3c481a16eadf1faf4c75709088cac5c29f622bb80c21f7a1219567fb84bac86c23f649d1425e0805e734cf5dcb97d8d8d96b079ad15d941e15d990bd016be051863a004eb04066237cac3c43ee0075c328946132e5164ceea0d225d641dd07bb12a26b528139151c8383e2081612e1344e8eb09b97a6c47fd82928f2be44abde8689531fb484e50192c7df7441fea8635ff9793f98785bc3f60e1f2788d8cd16ca7d0dc903cab7506381199879dabf8165974d26fbfb5c3ca2357f127307a5d55298f1f7ee93b11a75389d6f3b1cea1d0d76eedbca58f76c152dd6baaa800eadc425b5e77b666eb4dbbd156dbb67b6f80e1b12f007ecadc9e471668061a31dec06555014f2eda04a6efc8e1305688ae74a2924acd0e53c51368f7b121f39cd6f362228c1caee4fa819d14711bbe79b45c7861cc07cf852ab2e51d0339e31d6727898b5d10151c0ab58c4c247750ed2edce1fed15ebb28b8cf7c4acf8db2e8b41e7b19bfa69dda3edb4986c1b432b9429686d3792ecd98e0c4b036ac85d0089a8551cdea19ff587a57e034690725b7698f1466219e5d2b3d4732e485504799a850cbce27721e4b01e262f3798a12e4558087026ab4979312ec1e79a1c975a87e4065f2a354b365b6c9234609fc25a385a296b635eec3e180350ee8e1a6ec154fec566add54e653da8ea850ed7584cb5f7571956928471e409e045284724f4380985bc5064d14809b4459108dfd526f897e173c206bec1dd6ffca9998bd092916402e721d2fd759a4747ae494b9fcef9b48b67eae45cab796595d390ebc0074cd87845cfedd328cecd8f46ee281810f07d5d002d6fe9776c782829a8403766ba2dc04216a5f670abe646f1e4f0678711b4fb27b39cf210408782ebbde91d3cd3f98786d3ade35d405c3089ca1a8f06e387c5a735a868146bde09ba7ceda0dcf0682e0576238e5484cf70e6fe047c9d2ebceebcea88d3ad7e8b621e602c06784029219e64aa8f272d85c24ce6af273237c57dc9c84d400296a863dc128e9ed8e69db197707b4cd109424e420f32300b9c46cf90e55bcb133bd2f264c6ba709fb8733658605427078c9efa140ef2022c5150732e5e2d5108e9e91c53c88468f0ebac9d52644d4eb99c98cff75d77e3d09b81ba6d6c301149a35d8f792fb1d00c4f0376cb56af637b7cb8cf0978c2a9a838f06099c00eb54b4985a0b54d87306c7a8267276069ec1d2bd0d440e7f6a4bea9ea4066e0e7f7d5d1b9c59b0dac06f784f7b14f919382a7ad07798a1e2c6c38bb1e2d3dbeebbd54c63f5bc7fc3a7429729571a1096509e50453879c98e32e67e241e749f7d467ecdf26429770cac5fe5b20300cd211803766924284ec213c749b8b0779cc7010289c01bd24f11cac165568a18b8bbd6c3abf077f703043bd89e822c71bd2297442568241015f5877fb3ceccb871b879a28177669898e85af655c96dd66dc0f5b55ccf67af73f9c596e00bf923f07d0f0b3b1be95b28f8bedbbcc0df4206225373a83d8d5ef51d75ff6db598d3425e837b648bd96f3b25958b2aae0daf59fd6b0468ee3f23e73021c17271b7f1a6fef4b1c55d5cd15b1d950a9a6cb668a050127d3aea5cef31c0e4dd597313fb4fa73a1bd5c985912aab26a454f19ebe67b0f759bf9ac3a71673aad6ed44c4e3baa96e43fbffdb4b9c84c4d4b5df35aadb85417996f66fbff71240e2f86e07e8128a864bf0b124bb35b1e3e35c44f32e5ec6e2c9fc6f35c09575f60f297a6061b6d547781ce09b0fee88a9789f0787ee7e4ed6444caeff3a1ba8e57bf7bcab94ca6ba045276c3bffcbe3117203c10ab14771c6e835344dd621eb05517653d9415a76cf1180b19ebde961c61c4fc0e4352ae531106f2208cc42092aa98a357d68d98293ea0fdee10845cc39a6eb1bb52afbdc76bf2d234ae9aee837e39f609d5a6bd04adb88558f67f279528e3993c529529584853fff3704713909c9fa27c8ac2e9b11e05d11a931126e96461094492d8f917814d68273551b35d8769dcbeb186b72c3f8bd3ec44ed032062e26a3411b359b20f18e91c03f6d71c24ba6bd05088179e0b94f3a884f1ed61fc9d54e2aff473f07a1b2f3fb4297cd5119c70db2b13ef2583de27b4ae50b02388a27f340b8bcc75976e946ee9ea03a8351bc0e99ce0ebc41afd9daf3716cb558a2ee7470e0808aea8e1debf6d0c7114b5353f88bbda901336580133418c01368cb610f53342a0c0b9be7cb848aa80cd375d1629d63a1848b7001d1c3e215b04ddcd3196c5d5b6745edc8682dfd6314e93b61bea68062fa188b88271e6e1494237a657d25e2a6b943958f27a884c9b40746f365bfb86e541e104ca8cbf69f2ff35cd11bdee07c98913032801acf01f0caa2a086be6b8a3edba2815eeb599c7e09fde3733248814c9b7d898877b2858d0a989e1cb78c115ec042453fdda8d46b6e6adcca3a2b6a92d0bbed654df720ea1d3ebfde3b3fcb82846af86a8a7a2994d54de46b303ef6a7f47671d4f0d7044a86fc445e1778f42ad5017237793698d62f1378b2e5acc54ca31de10e81f43853e0abd1196a6918d23e5643f8e9a19a84ae93ed0861f9437383e9a456205d7a00c96de73940dd65ee6bca78f5abf38849e5e589b7cc2aba78f80be36a263fd16ff18db4837386ff3cfb27a32ba7c2c514242d092881a8ed8517a6ef72b889ef68bd786096b8ebd6bcdccecf7d4ca32e6f6044133f0f6ecf13eaf97fb8ab7b955287fe03eb62c7753c9bb12527873ed6fd4d44b16a94519487180e67a2738a538867f75dd9ede64e18479ea23b45662eeb0fce9a0bf19cd420e61286a42789402a3634f90ba8460c3f7d00bab885ccebc68acdf14948779a99d0f4782166a4b9004a5f2eb541e5358a2e4414869b590ed6dba9bac947bfc2db8f2eda72ff36b724b2709d50f1ba212b95ffeaac70342adb5ea4dcf9c5324f4e94a3dbcc92f114dc9f387d5fdc28b2927ec89939d406b0511b0d981d4667fcd796ddab6402d9b3a18b0ed119bb1435a9ef1893cbc1624b4c9e3da43b9514e263fa9c260ea54c16b712a6aa2b7f97a737a963270f6b076da67d844c89638af084965537dd3c1fe4971994a2ebe73b94eb7d2ee90f811684d3eeb107057bd8f3f404ee8fe223fa6c7db9fad04e11fef530a3d51fef5b4ed8c16db1e149287b302e5fd7c8aa10faa6d8e85a36d8fb00f1399d9d1e1d54b297e65ed31e09d50ec7d1ecd9261a96a11c966f2d061aafc3f5b8240f708cccaa2178767a01ae84f9d9b83378a5dc6efbbe1d38131df431e309915243605005a7d96bef88c54ef6e6886dc2d8e16af73afa64d1d59e7c57188e861e99e5d501ec17e065e5ed250bb2317a1ee3fca21c5cdb399dfaf9f54bf206f20908356bf7d2d1b1138d60510bf418f60dde8cd611cbe793fabb1717b3b698257d547049361557c70e80783486022e50e85a403889de5443410e0b0b0082daa5b625a3e76e870ab7995ceff73c54a0ed9292295134c4107fbad7b3b0c32c069b8abaa780642ea1e9dcf218b0e8b6de1972fe47cc602206da91531545c5b50e808343fffbe1f00ef94aa3cf1681df0447ddd8b9393eebf23aa70e4aaf6884a98c5b3e8af6759fb03b1cf36f563f4b726315f0130e1d5b666bcc914c4b670fd4b074cb2d414685ca0cea099a4e99c0daeaab9a94b0517b07534e2b4db69b3c548b88e48edd9a7002539fea4f624b51f50641244a55385985eb0ee7e3c01fc109adacaadf69770002902700ad58b0d83e580aa880d0b09c59b4a20b4c9d4e8475098d45ad8e0f999143e26344e162331164282d6bfd8519df1e1e357ab94ba6a7d3f0f6bf16e8629eea015dfea3e12fb4ea6fcc2bdb984abaeccde597c5e6110ba0c60c82e31a71824bdb808e2a4458708fc260d900c94d1d25c0c34de1c72d139e1cfbad1e095afb09592bc55327794421b94ea8279ab245c8b8a3b59b59e722564aef71270b88cb59eb1a59c043714a0774bb6d06a97fe6068c649092366efb26c461a897097b06f722c6b2b5ca6e9ae9af4a7c4f07ce3353bcbd220307b4e62408a2e9f43bc75eaa8bd2f5d0fe447aab53c5b9ff235188e97075dfd9c7e15514cfd17966c1d0388d496cb189fd47995cd24edd9b0460d6d8ea61fba57a7ae24d0fc729707ca7e4cefbca88c78859fb96db52c1ff8a244a63ddb99b6c79dc8a8c196713d4125d76cf03c01a1af19f0a47ccc936e49c4e0c2deafdfd1b310854893e1885a6e174526fccbfb015072c0e049d28ea8ab23f07702130adbe1a954480c7464c26566d9955a0b47b34aa2c0d5b399e2bd98d54ee5293fca54b81e1fe98619cab5f8dafc86ade2d4201a65906698884f921aee35ae9c63eb109b321a2bb5c944ef8329a7cd988d9b2ecafaf629fc3b06fedd5c934ccb5d755c40a8bc48afd8ce4674186c45693b5b159a9ff905e145ed742fddb842732d99a1582485b88fe4d4e14629f065fa6a8632c93fff2eb14f668c70ea3ba327e128e304014d3c78b13513c21b015814b7a7de53a47ad42b61298fc3520fbd12e1f3c982a0c0886cf39b9451312dd836c17d09d10a4dafc6e6afa2aa1760a3d3b0f753310b75e18a7060cef487813ccd3946b02f519d0d9d3e435ed03134b9eb23b90af8e111c2fe2552ee92dc567463388089578cfb825a00cc040f34e08ea90d64e899998a401c63f6a802569d913d03ce2ff4ffd99b09908440ca4e19df1f8b229ce2ebd29499ef149100204c4e3a589347edcd8c83d3199e5006ac806457797b1e3417be6336ae2771f827479995efa531042154486c9c82e7c8c5eda7a97bdaabcdd6b67439315799e941047aabc6d0f78554958fb044ca3c28d19e0e1180e0f9ea19b26310a5a83bac7e302d7582b1089c759dd48ed83d37fc4642ab99c320d74946e2f0c6cc0c4ab5a233ba3b322e9365a049ac9b9f62c569919a62cdd0b35bd11aa51f80fdd71e62e11c9a12f9f9646a9c93159b7e2ef68afe386cdc58ef1be27ec59a0516141b4eb63f633261396a4ff159a86e1562d9a727a95ee68cb829237aa146efbea25762108456a77ef982038178e80cd1e45304e7dc319fecf731a678002d737f99c72b8bd900aa55d7d6295c614fa49b57097362c69f72161efaf673cbc8596dfdc7800a782b7ed8106aafeea564e88bc3112cc1d04e195a8d869014f7c435067ec9f3f03719c0c4b30eb0f1da7b537e818fc0af6060198338c420801b9f29a41ea8c29f60fc51d745b5ca2e319d9d254db2ad68a0189090d3a8df371afc0cbe2493c8d8c4eba1aa2bd695bebed961357053ebee62ee722fd7ffd34cebb12818c52b450b04f1ae7d23e9c420ed4cfe6d29993fd13c24c5cd8968a9930723ec3c49345e934305b381541344041a4a6ef55e850a347b9b3805cc1a0e9e0905bcb5080b15ed75b35d0732bc0226889bf6ae421637c78c1e3ffc243d3f6b38f53132afc0db49e578cd92fdbc7abf6c6cdb46c9cf14ef2e274570700bcb90974799979ea65f4114b86c1849845f1e2b5601ca9b2fcaa85c15302399d82e628dd87ade854587579cb58dda7a7ae6ccf7fcecf8dc6426f205d131f5b603fffddab79ed07c0d26a3e49d20ef0dd2e847772b3090d92629dfb75cdc6bb0a051710a6090a560d7930fb623f2b3e1e5a17df441d765b2c10819ac59a627b9ee9c76aa91bf194ec9840ed259b54533cff761b7552df42008ea7e28cb94c9499a4d0a1684c387fd7e2701bfbaa7460be8a9fb1710aaa1911de05d484b1c9c1929c59bd516a712ddb6b96cf6e9d3c28ba4df574217383365f1e2ba3dfbc6d72e39f89e1ef1061bd1974d37a1445a521e6c06f834c96f418f64f2faed178c975707bb23390f3a6ee26ba9f0794346ba6096560742262d30e569ab5b8e97a8170ac1093c69f9619c6ca5e0674351b88b459982af400a733d36e0e73675c216290f1a6727ee91cb3f5d54d173ecada0ff73920d409bc53c3a107705624450906e038fb5eb58521ef7fef84be054a802717d1e7011ff939b272540809035b660f52c442c1d7cac8bec7fc4ceee4110d508202c47091df763cf8ba960099a9d2c6d2c496746541805cc8f90d56a135fb8f9a14fe01558728c92808c3a69692e0de2aa1bb18822b051631108ec254ce75326fbc9e0162024baa1fce5b4edf2c2185f30ff1de0a8318392739debd245ead87fe68c391bb7e0d80bea05b6a119b34e000d1a6891c1680762a2fe66055b30387b55a73b7d2fcef6e5552c87634f9b0f9f898e45302300d8e6fa15d4ecec5e28b86ad19f930892f37ad33b2b05e75dc05fbfb445d19b66ec9da1a0855327ea0e66f2e39e131241987219038dec1436e270d8009cdb02950d2b98fc6d73e018ad1fa992a6783ff43dbeb0a8c9a3198e7777acb9d837cd3706b3a14eff2da8971f8c067a7d33dd92d978168c831f4c604244703745e075a811edaacd185d7fc9c0bc6a539d500dbe4a72b7c47dd12e0a36318e96cd408a00bb90444e88633c7a1568a6b415b62bc44bf1f83361d86235e3e55059d586664d0736532eabedf9f2de5fa0a54e3964f2d8c4cac6fa5aefdad9313f757199a00c13ab50ba633c8387626e88b1a90d46c96cf5f8f1a18b95b36aeb426db7a3c1e9f6d7b7f66fe6f87fb1f8e1a793055ee60101ba11a1f713fe9e4a88097d877cf984c9e2f4ee9b02387a9f53e60d17a65ad8c1dca2790ba8a4bce36cca0d9f4e8ee38992efaa20e820f3065d2598c4d98b2ba75879401a2e0be5b38e21eeb75608fe5d8ce4d8047af56b1021cd164c10f06df01ecd9f853627e594a9df3d9a4a07a2777498beb2b0cb335907575ff6b47c27a5f0a8250ac8ca1d94203f6bd8a02982b4d81f7b4f323af1bbf8efcaf9f39d983d0e47d615377ab12c528039dbe8a9929e3d61d860983ae6378b81f24e8c4461fb05923d323216176314815c66eed51a3d46bb12b35a4498fec6f65240b8dca4b0b95a8300653fed8125637f11db61790cf1125bc7ccadda7711d54ae1fd69f500c0c11bc2a0dae71aec743f4b89329862a7cf8779e6f79e3b3eb999383ddc2149784e6f50e8f8edff8844d028bc68361542e8fc5b02d798f9d20ff7ef0a29270803c398253f37332cc34b41b02df63b366381b394fb5a7f59df17cc40e098fd4d13b9c27f8605f681dc37ca64afb67de7c0333107365fbf474c1655ba7b8753e11d74e838f68084ceaadadecd1a858c6d8983e49a7fdadf93825e1b119d6e729f109615c18b3f5b552329929b25744c9c75695e5986d9cc47765132cf0740133b499f60cd65614c977fa0c8b297b42c138392666a893c6482f75a1476cd49f8d6aac23b828bcd1a7793afc88812d9c9eaae69e4b94376d4531574574ef28bbb35cbeb30df10147a2906047cc16cdd3e1d803bfa761997ea12f3c7bc29723b8dfab3426d82abe3d716ed0f9450a220d2e5325f40d39e4755f182b42713331251e0fae580254d8ff125a4def4c103f85e88d9dafa75d5cbddb661ae3e87c3391f8cb767ad3f121636616221942d4c3c72e71a4043ec95c90d43869648c990065d7d51a839b2c1ae3ae06f43f0641ee210b352e492d28c16be99019961d656162c0671300030384ae9aa129778ec8f3d9a313c7275063d6102f21cc628651c5d86bcfdf34bcf4f9217c2bff1d5a3254a2eb1455315c3b08b9960bb9fe33af5b6ccaa109e5e5c180de0b8d1e3fab854a62d042328b3b3e5392469f18e7221f6749727eacc169939fb96556b155002265c17538b18dc77b1c72595b2d283510e364c1bda4262ea2cb724306c9be846195390f1699e393bd05a24f43315f8fbba683abb98b493facad6122b8e1f52986d1f918481693143f69933252253c05dba773b0ea9e246aba973e4fd61f447d11030d5e79f0d6d926c6eb1b36a59cce114aef45c44e80fe9c05db0140dca4429c46bd0e205c819dc45373dc899a5ce28c3d3d6f613b3fc3d6c993fe7c5fea29f196615195f780f3fa81a8ffd822982fc2e787e5ec140edaa9f896a405007ad3263dfbcd43dce79941449f3bc68c7bfd061a4253c939fa0f75069e3f77ae6d5e118a5f864affca1829246886242eca292f119730d34e5ebbd141143478cc5aa8fdd1369c3906f2d135087ead4f6b9d8b01d475f80f1296cfadb5225190d701ff0575b31fd733b8c87e1cc906a326e90c390f461e296910e5f8fa39b8a205ffccb5dbd523e883b3f7b8bc4d4a1fcbd952eb1b63f18bb9e30ab55916409667e1665f49c774453000792f846e3706acef87a2be4cfcb837fa882401117a1432d82e69395a33a85ccfede8f37bee68059e3dd5992e7d490421bad805ecd74cec557ac5fa6ba7fa4dd53d25190ee893bc90bb74f00e7ef32cad21a041bc6eab0c551fdf2bc06c91740668634d35d2cc66a5c8e6ec9786d3a16b39330a2843a729267d7a8c277f07e32d2ed1fa2cfc696f8e1549ec48a1c093153f033438aad5fe273df2776bffa2a2db846ab307717fd88d3875d9ef540cf537cc3de4372d48eed09dac6312a17a82cf13d097d1fc8458540dd0409f3565bc219c63b6eac1c8053d1db6558536b595ddf3b82b78ca6984c71bc3ee7405d3574152722e7c0a17a39231740667375c0716096aee640e123b9714b965b05ea4f4af830600e7584b3cf8786122a7b1528f914516a3fbc6fe08765eeae438ef4b227129f6022a45903f1ef8fbf3ff737fb7d2b360334ecfcaf1fd9b03f6897b905b59322e7c0b36fa49fa487105501504ccd7bebbb4831604b7542a8799868dd17bccfe65a5ace2d66042f1967ca374fcd99e455f38dafcd39f1aad3bbe36540e2cb08976736f7c42ac2b539cee4da5147adc3f413b1dc7b197933170e87a05541ee2ec739ae6002ff8f15c387cefe52276765e15fc24b498f22a7c22ca7907358446e4600dc0e30b207edad6dbdcf4990cad85ee066cb7c59a41002070d4767f2bfde864ed8c55182899dd8f7d2d536e1a59f03685a6fa03051feaaa82acb86524b4a3eea398066780e88ccf775ef288ce8291a20dc4b9dc6250ef79da49553b54a4311bcc23435b99a9e76d93092795167978e50aab3ef21d6332cfb896dc112bccdc89dea8dac653d6488d7d08c22b4d962968f0ac1faba1c85ebd7c8677d641cf3411d6828dc44026631eabca188cdf63d3691996879431a0f588b6f697bdd6a877ce3057f73e6a1818fb8c49837efacc4bbd317393c9be7ecdd4458bfeb1b9628d201f8a3c64d938c7ac60ad3fac498efdf3d379327eba5f4d9b98258fe7ce4d2ea7de6b286237ec158e0e0309b5ed29697e52fb76cd775dd2c525e9f0ab89450fc48594c502a26f5be4f1b1625a968180fd644cabeddf0ab58bcaa4298d457ef20480f0e98b1f6add220a25db9f5a229f12a321930e7ae7b34a680e835b6978be49ddfb0952ac2d8f3088b81ee8e434b687494b6ea8caba6a32fac660bd3508a784659d00e68e6e064d48f880fe1ae222cad0e42a6a1c9a7c0688bb566f9a9ba5f40e0c69ca723ecc8048ac62e787f1be5cd0ad0671aef28448a1968e954bd51731ca349babd2ff8ee4997c626254a3019f3aaba36209df009f79c7ab495cbc7020dd712cf772c2c8f3f473c2511fbe0cd20fe5c7b4848a3ac3e95ca333cebdd152fa2a67d2ba7bcbe1e8343367b53fb1e723eaf10cce919d58e06a49be39bf0fc188135bf6a039fb39f14a898d96242ba7346ec714baf6659a5823e22bfe55a55a41f4a0de1b314144e2f1f166bd8d3c5b9292df5fe42ee0392fe61966a5e20acc611f005d2684b9912c0ce3e70f5a136a5698d04d39cd98cc1d04d0a8c7ffc7ae94701a0e8f54cfbff0d787e5b293160185ee7313d75c116b2e28be482d264e2c3c0cf7ca0479e3ab908f9f1c64ecde23ba95ceb9f308a98b7642be66b9dae2ae77a0f32c25e51eb35e8783c2a052c3393746d5f7e3d2eb068c01f93a586107d6a8fda95fd7dc30532156683c9874660cec22452c1458f1a32a3fdb9ed35d2f4bb68df3bf7c54c413f3fe84454ae65652e1081b92ffe72a51e6db734b2544ce9e5fe39556a842e52ceef18a46895362b197593605ca5b1577639bea708227fb6dda56d9382ba159868085852d5ca342903efe19d4243215e2a222836a77bb0cf195a7eae0409b8d9731703ddd5e451dd5ccfec13cd3eb53db6bc4bbb4adb571d8d67dd34951a8d83076314a3aaed47575bac0ede2a267753b305341b0964b50503f295c4159ef3ee9ae93fe071f9416ee6983ee89ef15eea1390d483a194d28fbbf4b2fa413a20370123c9357d463021fbb51931aa89aaf85b14c835a81be7bd15fc3fed62b5b1eedfa48d33898f520a6ff59cb2a183ecc69b994dbb70d92eef10a09fcc1a4a3e3972502dfd63e703509c37ea4dc9e1d0555288803cdd56dac752b926e173625efd8b1c182b4059185c3af7828cc71dfe32a445ccb6d2cf89aecb25a67263badd112df1a0d9afbdea52aa07174f7eae80b602d775149c1d4b05feafcb395f1d7028a627a842d78c57b36d33e73b6e7a4967baf405a19d289c11637d04ef4ab8a01e40ffb8df169be5dd173df910c0b9aa133c905f93319c4a3c0959f7db438f768ebb07597b31e2e8c9992d42f8d0bfa1deabf4697138299df4468fb22100063cbf4df26099478e54829ada1aaba1627a63ee2735849d5c2afb8f81eba9c8cc15b556ae237b4b090e38c6d1ffc45f68809f412f354d60cc4978cd3015186ad2cb9ca04421d86e8028992bcbf00f92c6a7463b6846fd204e6b271a8dc22df915053715dd6bdc298d0beba922df8e99625e1bcefc160a0d8adb2851a198438f7094655426669c820422634fc86fe9b4da0bd312edc206c9acdc3270ee033ec793c5fddab66b8a0e713406f879281128506179c65a6ace7e29d4cb6b357b9bef91e6cb47be853b5cc4a2845ffa36f2e041176f7255449e25b034ab84bf13b960d9ce057fcb427c86b6e8335d7e5f4017032030bedf93316d1729307744b53e4ccc8f2406bce77d0b207b5ccf9a9332783d11a8e795e5d831aa41d5fe88f5f749451f1e13016c6f4cd628c40688708a5ffb80a65cbeec1cb487e9ae88e46d86e7b52cf524d31eaa80abd38f25be34160bfe996b58298b31f51b0773ec6e972c26f633b0cf377a80adc942f256a9edfe86eb583b83b0d0ffe17f248e45f1f20889b8579582a4f714d4cb2e5524551748488496daa0b014ba4f18f451e998322a6a5f0a48b413472cb9c5d41f1c526e73eaab6621a5e3c37056df6020674405c108df87fef1670ab32b07cc85488ec968a8c3709d73ae3b19d630dd2631cd7f81296c2bfa2fb953de5749da296f56779851ef919327fcf875d6696fec016b342bf54784007b56da53b04e46f2d5d1ab05e5c8187b55db34eaa3d39b0730c4d6425d64601a70e96baa6531718f9e36781deb8d749261327853cdbfa52fa30f38373cfafa1486329c2f1899ff5e7f61b28770ceda5d92dae637e448dbe029e474bbb3be8fa61b74a4526fd6cd215ce1ff18ce620a772a90b0a419e9f3d6a8178a663cdc6d5c1c47e30e9efc0e4b324736935efc83d0386f76730756e628ce8476b9a371a32aadeb2ab1734a481e2dbe3f9dbc9ea3f1fcb7ac5006b28833477dc0a87c4eadd25f017bf4ea06b6d1075bbda4a5800ef5a94cbf183801a4b79e9a29a229864bb3375d9044696a4f064699a00c0f8239f02a559b8a224a145e84c8c4736848f0895da765e41e6a8871114bffe32214651b5fbbc1f5eabab5d116cea439639adb051081844d5ca751e8287a895138a431e7bc214b66d6b0f12e012a6b9f251e83f5e2368f3f8ec2e0988e0afb3c578bc95705e06125e8110464306d74b1fa0b81d7e46b998cb976138097cf6880654bef483cf1f81d996c1fb7082a394039d6a6e775e30b233c60fb87fc76e0c1c9b3235078c0ba3005e32eb39f98936ee35a0a8de185a76bac667bea4205cd44d1bc69cd921890832eb1960292440dca87988a149ab957bd24529e64d7e123685fed5dba459af1943f79d29729f8e53e8e267acf0b593583fd6ff4c47a3f7c8621563047613ba6925eb0ef9d6d92f9330613c71a77f46dbd84c68d3cdd37806b68c39c959a0b18986cb44069ba9b2d8050eaec239e30242a781cac3e8d36bef1091f141ba2c381b066de76b4d64722accb48d1b5b584076f071bb68a48e44f307d73bee38862bc40f49824bc4dbecb179ef501cabb9c1035948d4cb8c08f5b7841dcb17dd942f4c52f6f9a5bb9d14a3be5853c07b6b07f7471ebf7b7f6082900deb9b93ceb49fca7b36a7ba19f9d18233e141d5d165df215edc70285a207866cd2815a483f247aecdc35dd20c5619dc2768f2f940eb0d4ee0042a55027664b13229324093c79cdaf197361820f24686a5fd1fa4528d720e59c4382d03e512f9f3fb871be86490b474e300af5292d5f88a0c0def28af9a8024ca2fc3d6c826b370982fadbc348e6707b145fc607c456194aaf2f59bcb44d9d255c1fb0eeb4d91ebde41191fc7eb9e84a50b16db6398ab5155f70a94593b72a83efd652ab97895574f0052ae7c853e044678eb642c3608c367c015617a222d95f817ea47621375b7a3fa2a5a57992d61b39a7a4594ebf4f69a7a3a7cdea2d7b1692161a9659b7bb0426c37a8170a5f4e39fda20eaee3d307e8846ecaf8d5d5696718b618e54b9a0b58f7add5b28966a3a8314daa1f69c8d224c5d8d7b575dc9a772c129f120027575dfdb5e4ebb5e52aa2df693c1c849f4d47812fa6da0e631ec41ecf77cce604e80ad7f11d017b3908d3e02dff67d3b40e95577f9d1240e627e263b76b4b947d561b007997befd75e7e5e7016736211761991a641f2a032036e2eaa38034de3882920d0735df3e5dee49e6835e64014368195998b8a2f8c899fa6fe8f78b70f1f47a38f1fb608d8a8f4f90d25fda05952c940e23f2a52f7298bc51c88546c976a0cda4c74e8e6bd0ef89792e37d479902b93fa3837c0e9c3f23c9e52678a41b41c906be36168f7b748eee910d552ea26f05b90a70aef5beccd47cf1d899bcfa82b2a1cc9d0011b662dcfdac0a4a612d0cbf5023f47b5b67eba0747102e2cfe9636d407e800164bd320c249df0a4bfe38a1df66e79b85ecbedad84fe4a027f9bffaee2038bcf3f9f2cc528b0e5a493e49c9a98db1e7c9db1b7e64a0301191da4ee1c02f5315299493b8910f467f79a99fd75c22bf76617f9a18e8c08fca0b69cf1744f146b879536c08c773b3bd8ffa0b1e717197e9a9b74431caff37ce161c28e5764fc83a7bb4e7d5bb4ad7111893cd4897c452b32735a710d43d1da823d46ebb5d5d00ce5f4fab6e81cb8ddf04fbb149225201cfa1bee4bc43e43b91fca8ae54fa76f42d1cbdb145c2f15f4b08c311a9116c2505889821a56acbec6674b1f06482e08be113ef03c1345545357e60a8dfcc7388fe946b974304a7eaaa3acf0ba893b6c4f1e1b412fb78c697805b886962fb600de25bd886432dba608d69f7bd3d00f57a714c6ac9aad9f39aa16682b723f951cec88cd4358653b84d1d9fa48a8478d2091de9bbc9e724b8496a338e1fcf28b7e028b6207c66e460289223affc6a3b20472f763041736dfe6a331c1b4ddd964d1dfe40fdcada6bb93055f6d46aedb6fb37eec5a48b1787ddd8531fe17fa079434ff571ba7b315344135c2c5c9513ebb790fa84f3f959fd663aca40e17f3682d4ea9b74d4da072512439b1d9866efc87458b459a92a2193ee09a1c3482a5fe804bbc9d41b9f41bf330c5c3d4fc64a7cfb4c2a7f68d238c9a07cc9da08afc425a6364666e7236bc07191f080194227f07c094119b039d60090e47ea4c4bdcd873e59a8cbe6b7f36f62a0f72de1d285aca74e6e149a0f434c9299437b4d37a53258c0b7ef7127d7a94ad09f2cb5cc1ab8cfd39e5a944f881143c28ad6276d142c2e95ac21e1ed317c3ce4264df17a3785f5259139feb5d182a55345d603494f5e785ca1a49ad5343fa8cddf644daedaf9ab4233bfaae7b129b9172385ba22ff63e820eb2c84d186d0277d0f46e146945ddf9adf7639abbf3e6d1891e33be3505d9b112398756d4ccb2189f255fd8dcd23da8fb3b0142ca8e45249ca0300e60ae605fce44dd0906fbb9f5ab7576f8c8f59f4293c2a69ce781a36c025fdc4e01c9d4d692c53f431655efc50d648c9f2a4aa8aed5946f1a93ba82b6efed7ed18ecc167d24ab92024e574fb78db45feac418c76a629b507478378cf76614054c730851742ae34bae04a8112a9a8085c5e15f7e1c94ddba3060a38d05937adf54fc9ddebf3355b2ee944d029e1b2226a621bf7d945599f9967ea9c331f00431b990469dfaed8896de3941a0c66a8fcc38115e76983cca3e5bd45cf939749ca5bdb9ec2b6632fe089bee3cf4211c73f0da2639a102b46a1fa9ac3f2d42a60c5523c43ba501aaee5db11e7ef11218d454224298eb458058f7db952aabf781fa4ded94ee1b71236dece395ac79dabd9c40dd8cf6a400f08e06cd5de174b69780e14171c88a3299c09a62fca78e1c9223d7ac3cd680437b3dc69151ab5994fc598a036ec6fdeac8508612e7bde38b63765213845d128550268f8cc23740a2ac1524e6833245a0944be3974416f635b4010d857a9884a79fd79672b3db6b47d87acf84bec0f9933474559e6286adc90f9d2e4c8c3b2c2cad37f960e333a87486d9b336dbcb085e4d2cbbf3bea1b2165d9673085759510d7c3cc43bf6c08d5ddc3a20a5a48971d62f2ce6d7bcf1d9182879650e5a95c26f3bb88965d4f7d31986791926957734bfc5878ea30a18ad04af101ad2483f91843f5a0ed3ae6dea04340264789fa8723fde1e36054bd0a248d6d8eeb02efd975ce8273f8057f6fdd166e260090aed4f385fe1a672a4d92da662f606d02c6dfc5fa3d9dadb0b4c54eb483ccb8d544662fe99431aad9bdb19edc79f9b244f716f7a59fd06d76ac4974a4f5690d8c9eeac474b11c2ab2268e96c6da6b67bf7dbc039684e61074243bcc5aca02e6c7e087c4979823f37791a22ac89495bb2fb7f6c9020e7c14b5c38831d5e9913c4fa7942277cfdf099cd5c4650f698bb64d0c8d2a9a1925a36ffe0936af3d2e0a0eab6e5c3c10420d2f90898a780108d5536f3252c8768ec7cdc23535de9d5a494d59bffa7218f792defa428f05697d4f2e2a22abe5f3000bfb64228c016bf4c13f7aa277637c7a27469698fe7e8ef647561a2bf81d2bfe93ad6076459d9cfe9f684bde95f779269d7b1534a786903356383fc91da79edea750ad421aed42448d0b82546d3971457573753c3f9f7d9be6613767086ca8ab97be3e6291127315d0808bfc17adcf203b5417688df485ec407c8dc956fd607b0cef4856c3dffd3be2a9f10595178058ff8c3cb3d7c0e559e98d9f20fee4051de2a13f44fc7c1a982aa9e3fa3445d65462161fe8dfef6788cb65a13ce362c3a5accf85625d57ac20925376c53f5dcd5c5a9bfaf38dad75544d586060277803a58c868525c4bb7bd7524a74328a8fc962f9d5d106c2d32c40e5effd48dfce35016ec3bd946ad5602190c91b3aa2c70127d86f243f0c50751a3ee61e338754c93559915596d6f740fc4c0547591dd18ad1119bbf978c52de9cda1285f205ed806ac7c8a014576c906da541874b942ab7d5ff09bdf85d082b4a24690ede09349e22ac79629062eda4ef67082a1f6923b7876c3afb1ec1a58033bf0ebc865db6ff485b97fcdb9369c4f22cab91a9f6ff1e40f9c05f68d920eb0da9276f163e97071e3921fa04bbefe500c97fb361ca2fc3cedba67dc4a31d0b9e2ecddb879fda1d9af09828999bcb0b9f5df3c52e8fcfe4ce7e86583e983b99fc4de1d27e6cbdd2212bb699c0d85477b87d4fcda0a843d9e3439db4721e2a235c053131e355504f6f62115315614dd0a6a97a65e5169b507657619c278eadc214ba1c6dbb2c758c208fe9a0fd57de69178ed44182a6484c9fb2aada621e56a5811ece08f798793e5023c8c7695b5dc2127782348ebe0c2eb928f32dad5d5868aef54e099b28ea1207f36d0435e75d0056ac9ba2a2c4dddc4654707ef3d4093abf0ed855e47951fed596d275a84f82e30499be35403bb295a863c9d5fdfed0fa6ab787ca3bd015806bbf962064d36c40c08972af6b02a3a1639b063f019b822b42b720459552d8010992b1cfd4747d64ac6e124c3de2e767206fe883e771538ea7041d9d98385824480a3bf6fe0c9ba9dc58c4688d49dbbf212c332531d5b17b381a0648ae426bffcbc5c425dbf37d76078846104d5de3dcb0e6ab8c5bb1ababf32517ac09bdffe981829bc88389da2c3d293154c410dd51e501878f9f56046e929de49c7b59fc134855c07395265c234245ad159e11e8d6eeaade9b55ea967515060029c307a16950edd968b74046f4aa3d067ff56862bda0f0036e47472159ac51d1f6c8424cc79761e00d54a4760dc2362a3f263117d0cfa62baae51294d831274da60b1c07d5240c618484710cf3fd42c1df822e9a0e383b7d0f161e6983d00a8f54ebd564bcff4219b142813f41afe752efa3208843acae8b63e7326e8b7cac7e7ce3414a1e5b1008d2fb15f437ffd77c8f4047d471f30f507e28eb5667ae3a93d8d00d927d7ec93175e8d80f77947adfea4c1a50150aab181a0b2170186f8c8a89856dd003d8c703510f8e3d871d1a337a661ee8b02b4d8b90e1699536aa2eb466a214b5e87897d315d056966ea06a133fedb4897406b773058d179c6e697c8acd35991852d1e5c85c5a044350af48c1202e3d8ab5b84cf4fc6db5f2060a9c992c0b94c1db067ed98af6f0d30acfeb2229cf98ec9bc189c5aec9b8d830c1afb0ad7a71a02cb91efb5e400b5d576d38327e34fb952281169e105ce73adbdd6e6f8143e9b30e97c568d4b1cb2a217567ea8c8fbaadefdb3af752011cfe3f60698283e1fe79ed64257afa38ac8feb8a3d47b27b396d612d7bbc3c4b980d5c577ed2ab174b8ed8c87ab2c837030d24ea74c4e281ddfdb40d636f659564c95610b83de188263a229f5b73ae29c769a0f08e66347329eef61f32c8151e67a26d0a689f5b04eb760863a313838f872f42c1eb0731164c8e61741518f9ee8d766a709b37d55a4a4e55dd1b01d54e9a10b039926dffbc194e430120285f5229417e96787914b675d88ed98470f14bd3740941e8d2234298f4beab4e638567e59fe4e642ea2abeb8d8bfbd030be72eedb64af2de7fb866e97566fc3c491b5152b437101bb9cf19091ed30e4e02e4d22449bf24d81bfa997087e7df46a13b7495665f6831db35f88a2016121a8d4b9eb4559112ed5ba2001a780ef4ebea11412c3244d9d13ca0c0968ecc295806f671829f6b5f0695a4469557114bcdba7555ab0347fe2c19079baea0aea7a402632492cfa5c36dfdd7b80583b9aaf544939fa01798cf9691637adc6fe4d042202649d4a442f199fe22556dc2f55128d93c2f57b8092b140507b9e3baaa680de88709722637a0b76b80b74e0b7c36146d011d678d343e27fb0ef61a328d79202228f3f741b97d33861951b34525a4c31c4adfa44076fabf26fb458727a2e1a2ce881711584470831e6ce1dc794a805f3ec2bc2f53934d629d2afc2660ce56648487cf967c4df50ce0872db9f62b365158d2e90b8d0f8b09ce2fdf28778e46c6718a8383b2752ede78cbc3f50aadd9b8d622060fcc1be4c83d10391d85f73e20407d89bff80bb932d428aa2f02199e749b1c50f068eff18acc344fc60c00f66a46b16924d71bca80b7845e0e0533c22d70c7bb9a7d0a34d123b40c6a42295f94f9019305960828f501a8d1a4cb7de69650f82d0d0f0ce5f5ab8a3cfd878e17fbf1bdbe33c8389045581473c2ccf7c3a68d6f8fc1da05f1ee5b5561e37f95b839f37608a547c03c71aa3400a49586266c5694acb34f75a223b83fd294ede4e215102e18fc1f40788a14e244c1ddb62e4f283ed397ef443f31bb90ca934984bc568627d56a8ab9c9f3043fec52be60cb40634a2a19e8ff3658634a2d8bc458329f62d0577365f3caebb9f837ed7e20f6309ca29957337a8ebce932c28182ea487549b31fa8abd17327dd0aad090f96c6425dfff51f6e88b8a3b9881f5f9a5c42eb4b9a4ce9719b7dfa1f610e976b7bbf58d90c92580ff7a52549aeb7072e4334e93bb74a3d108d5f57d7f482738b74080f17bd9420680e4e5063d1cadcfcec9b4d65b915de88691d824664d97c13959a3afe19c391a3bbc1281778a0573f67b7980bcdff085c5462f9cb31e70c86944513c5c7de92c187932ffb79443385320d7a3321ff6133c21aaafdbcd21274f6b411d24aeacb3beb547dbdda76b91242b3b577e08e7e38057f400036f8c7120d8de34cb5a1351549f13e4e9f2e4b2d3dfc92890ab86df76c1cfa85335ff278375bd8916a347249ed8f24f361d4a4dc2e52336f2787ef12c565d9ad7a15cde84eb6e3d6dde634c33a54f7c78570f3234543a12c608349e4fd039fb9b1b8b768fdcffb3d8692e216ac08a22c30b9bcfdbb276a8c23b406e7a4521f56782f9edafe37ce89158210e48c8a7dc6eb6b4a4b5e6428129face55e785127f421055a714f5b8ecc5a2617c6574482865f8ffd96e05d362e48dc316f98b2489b7c07bd39edb7ab672f4886657b1a9dfcc0c76cbaf449d7c64d0ef82b02de9f01fa0c5583ac04f7fe458596346205ed4bd5c84022605179e723702a52403618ab8effb3ad6df56d96c0b645a05a726997fb51710ee2e12f2ee4dd1e64bd8ec59a6df128db38377c01f96b407ebd700fd795fcf7111b35f6226b031e81e83ff20571f62a7b129f868c801574e5de5d39977d1bbda4f75380dd3f0339b3c9d61abf5caff8a811b759fce459fa264128deb459670db8c00ac2f9bbc8f362548a8c389d2b35b911cc8b421dc6fa768b76f24031767f567b1cfc5bd944e4023b42dbe27100aa39051cdc087b6248320172656d9e9c1ee208984f523f650e8be0ffb10da6c73226a8afa4d6d9bdcef6be1ca00815a908b833f3e6e2de36a4144f8151d03f5881149fb309f92c4ff00755bb07e24dfd95fad46f5f4cb1bb3e85bb2bc8e9e49b2d6f9b84ca1ad9d042f938aa78fac60b3241d7eceb25ff6003c5fbbe9e0acbbaa261541f07999f1f27bf071c01e2ca85292055cc72c0ef1c8074db23a8f4f989c7523f49dd3343f1c2f3d705c4c9cabb0a73323264defd741ba8646c0e1a25e8cd1e0ad90b4f012668945e86c3653f3329793309a3858112d6a359fe9c6b1e29344a603b356ab9ca85ed39b5eb379abe68fbea788aa691eaf6c32690d1411475c1fd6cbc50ad2c135893c7b3d9ce09e3911f11e05577d2ed66fc43518e7cd12dcf5e6b861efe4a29b594432a3d283a4588cea0c862f7b4194491ea7bb797f436ebc4be666c1de3382d166cb9e1f73223833498cc13a53bb82b6d2438511f1de2babfa062d6e1355435db76350a05f7023539b098e3c2dfa6c60780a299e2f8e81612818d3d0b7089fc1193d1b7b7c166a4aaf56e74c63886193f3000f40cebaec1b4ce8f75668a91724a851a37ef13eb85069ddaab383ce6d1bef5d99d47f1c26df36a2833a3ffbc058c53f212bcc2e6625117a04005f09d2b9e2cdb9e584e9c73ee3c0768d9bc1425978379fb95f583fc8ed3197f7f3b39340e377fceb0abc5c333372ab25ce97e2d7c4232b2e38441a349f10fc5fe936483b7fa560691a3244e6bfe77f8df95e5bdc0fff1a8a421cd2d7276f415f706621b3e22dec61c53fd2ef1774821724d10964b37f9da1842b443b8f448607017b945dc75c07dfcfd9b6329034d21181af48382faae910124d33ea51f0f207b4ce6bbb07de6999ae87e093dac11bac7e115b4cbb4089222bb34b1950120087dc0dbf4804ef217ab454f79c997914fdb9188365eb4f8aabb75b5aee246837643cddb53730f39a6dd849b76a1026a8d95113e8ee0cc690a0a626c8c31df4e5fb731805d2a41fb6e2c1df62cbc5f6894d852855bec6725086331f0514de94eeb065aed435e1c6fdc475cb28d2b39c5386cceb8a312541d74d72a31b690d66ac5df056f41de5e6dbc78d83fc9069af488f435a6b87a963580e439514d8860c804631b3621a30afc5ba39b15ce5565c8663c7d11e8d53feadd9f1b257803d07c97b34a7b2ba6426f84ce59ade8c181665509f1eba36e45cd86718287993f53fe4beeb0f539fccc398e90975655c8696d258ce3e2f800bb665144fd9e696ce353257530245c88640b8b465abbf86dea06454f4b4f7eba93be5f0340e744fdc7a279445facc9c2e19b94f33f8948a06606a93eb0a8c770b679f354bed13ecd044b417045aff966c5b1828d7f2e04a8125a904005660c0d977158a4d2a8953b823911725666b97ce03d56ac906b32213f03408236ac6317bb3845b6ac3a740ca0572fd808b718cb344a716611ff977d0415a6abf4195702098367e3512056e1270775a42dea577d7c0506509182a205e8697af4fafa6dc0bde1fe739c80285f88de615cedf7c344dee5cfe57ef04698c662eeda52072cfd896755c3141bd723a35b108b48ca214bdf3ffe1cbcc78dc4bf9b5aaee445cf6adb80a18e0d28438b327f72dbcc3d7b1b475cfc2c197ed52a9cd2f33345cddcd7d29102f6b4c598b2af35d07125635fbb2df1f8f1bd1fd235eb8e164ecc7a12ddfcaa7670040ddb84d0d7a918c3657a6f2a15a3e9b0e27ea041c22498db4a8d9fe99af5d04395f7df1659ea01480f3be780242afff98fb972a41919ffdd67ea67075700e766bfaa0389312304889ea0817e1c6fe26db35ce0cd","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
