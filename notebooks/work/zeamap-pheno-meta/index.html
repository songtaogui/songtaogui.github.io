<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d53fe035f26b643cab055f4d7bacb77cc1830bc51c02338e40aee7cfb416d5d090ba1db1c6ec6434745ded1f4e4dbf00f98d77397dd72dffc193590514ac5c244038f9c3e54570c48cc66d0dba23f7102d8b321575847fd0c6c4d8f84f36fca3de461f53f1e275c4afae7a6192769a83f70e0e74c2f19adf7a1e01081d99c0e14f42dd9ad46d9017bf5f9b3c9dcad4d4b085b8c2dd48b276bf6c7fc899e0346e24b448cb73c163257d0e985809ad90f94d48cb5b65917c66d13051667ce48043f6153844a82cf9271d8e3f2d7f72d6d9d37814ed3063ea7b2c0650fb8be980d176e0a4bbbf13eae84bfa1077c81a639b0d4470515d0c13a21faa40634d8f643012839c95a271223409dd5de2b46dc88cc78e96811fe4282c4ed2675eecb5d36a9aa04487c03e57eb25b86aec55156192cb9b792afb8131874e7dd2a0695ab25e168bc1f604ecdc4fc61a075c248ba0c2f7422c88e3beadf34fc2dd0cf4969e3d2c814b6f7fbd1888eba0cf8ce3626018a79d10c267e48efbb4808a4cdd287a2393351a2800286eed37460d55bc0bba5913d46004d4dd0c939e3a2951563655b6a6c19fadd056633bfb77b877d8493f9b23da7430cf868212e727ca82611121713ac4239085d6afcc2f5785ff4f2d209614e71665cad6b487d6afdda24327f43511ca950b7104e77c5ac05db2f85a3d565411b27bbcf84ad10d52fe815a0042a87b9576209ef44f67937e7e4e75b556780bf2abdd81d41f9828eb52175d9da5e1fed9fff81b9d63f9b3ee467df9defac25d43776f2e5e40486534390dfe892c97dd675424d004270e5dd5d3ac4243c0a6c2675ff328979c0a23993b3b27835799c4155bfd8bc8b428532a6679ab9f79fbb0a2d9896b9a96619eda3b2ffdb7d94d5f48f5b3f1927613eee94f770b9d410ecdacd60cedac7447fbc98cdc65c4d4fa3da2830787bfaf0cc4eca35629c7c50d0c594db60758f25b99ca2901112a21258cb1c164dae1288338fb8e8f66453e3ab36c4322d3ace2a0f04325ca7f11f55f7265050470fc2cdfb78cdc202a032026db82bd84267bb130f9ae099875db04c59c13c9defd46a4f76b0577603532b786856b549dd2278d7dde5fd24f3cab89234914389ed52258e85d216952bba297a79e593872121f292e23fb30501b4914cf4fa35a98de9a9bbe3519196adf82b7b8d9386924692dceceac9bb9cdb9d12200812ca344975580e816839f616b78fbd9dca6508a179913550f14e7d8c6752dfd1857dffa5ceabb056ae258a03fdc1a45c8ef6cf6f93d1bee7f5c4f960296338ff6074beebef5fee55c88483f7773905976e1557b514e22094115d1ef383596b1d0cec8748ffba69dc501708a95e2e9a807f12f3582a06799220568aa763253961d54688df991c697acac6d35a01ff3ffe0ba1cf382fbfa990b72855b350fd7d8ff428e3533907f33c06e076dec10c819805e51d54b0879ee7d6040df14c3287f97c32172f2143a8c73992b64bd04d22ed7175e07b1a335f41d1fbace240a959728bf43dba99905177d5be68a108d6085c7a9b55ab6b131e18d026992933127de2a045a6e2c82e4db32a466a3eed13fbeaddf1ae5e42a406a25e64d698bae95b0d7491dd952d55c9bf58cacae1691d21b2a82eddcbce09eedd73904be43df6165edb7f96e21056ff31f1ed9b9a54cdcd5b77a47c21fcd2dcf130fead928a1027e20332f893489688254ca3ce9135183fe6a166968c3cc9704004b2fd2d10186b13071cb4e41317b4875e9f876a7f56f8084a229ca2b6491609999e369ba0cbe7de86465de8e04eadd3f6b451b42bb28738e1eb9e464f7ae13540d39dc14c8bb33906af2b44de9600cf5aba8bfec94e1a55f135146ed8c2474cffb221b480cbab272152faf1aebed2f4af812e844c4b964496e07c695454ef8633983858d843fb236e1e9aef8a71a9dee8c7e04a5c54f3c239a57b27571166851f695c07ca2ce2fe0f6d580ae030c1b7b0648747eb5ccfef25634c2375ee3144ffad0af33af164857e016f92c0d3a2531cd962905e91fd87439d6935a6329edfea49d26baf742a28a6b680f3898a6a13c15cbe1ebe5174226f22d62863ebcfcb57804ebd6f04120d778acedf571798c2f8ca6a3f1c49e76497d7fb2c634dead66c64685522fda8e10103afd101b757bd0afabd30c7fd8d5c5ea47e07afe812575e4c28f9af5e6428cb6bb36b4dd09645e771a07f9a1732ed0af453c6c8bd6e8a2d5378e38131aa0223754bb673d211b6f81ab08232460e52b2b787de3412c6f42a864b9a8e05639ca2cf1139258163face833578c52d5f50eb7a0550ca0c54842b3af378cf337078f3dbd006de9adfdb6db4e0cd54fcb18853ca6c1af77d07e833c79ac68ae6eeed05c82c07dccbffa6c4f9779cc3c6f9cf07b96e5e61a5948e5cc8c23c212f6314aa0cdf9c9d5a62fcff27ef1661c877cc9a934c4bddd558633d84d754eb07b76709fa5b6dde164af93ac487efcf7c2c3b4bf4dc9d63b379d12d18ece58d52743f18145ac53eea8c730b8f117f623e04dfc827d4bdaae9e12b10056b0d1a770b8cf2cf2a7db911786461f4c3a5541f23318bffa2cee9b4b5d406d85adcf9d03ca092a8612ddcd019badb35e537fa058d32f3422589c5b27e6f31a13a90a143b8184c9b312dc4f4bdf90f6c61b15c1350a6a0d80c96bb7e0862ccadbccfe495757037dfa0c3931c0cd81f81fcec6d1ca1dfb0fb12c08ed1c0bb98a79d83290e30e445e35680527d97deb538a83fee62e4fd3e1212147b7789d43928599f501e08e853a92db5e4de8d812c1a40fbb621fe4409b93f12afe3fe448c262dbc5ec9521e4f629afa15522b392c49452491d1020f656d76c24cd4ad6069cfa4699dc9f4290d1e5e11dd7eab19743684b9a323da961e2527c756632ed41a4e9932adbeafdf8f70c0a3a3d8a7602e0bceb2902ec33998aa2ade5851d5fa6d0441a1cb774238682be535c6295bcb10ef879f206d16c03621cf4597afd25693783455f0b5d79bd885a0260d6782f351f9e9fb97935a467f5d773c46d7ad9cae29a8ecceb4fd101938f39472458a5b88eb29346c16d2a2b55620bcd5aceaee4a456020389e987f1cc45d2b7e44ebd96be2d1e786c8d71296574858bcced5ac5748b189e3b06e0c11cc88e4422e5fe3c3819dc5766e089ca96d1a3f501fe927623447c2a718ee90ff52663ed212339cd2868e8c75efd004f9a7418ceaf636aa87d6e2e1d12fc135d01b6515552e970c989a2b04b850d7966070009afe650dff23b6bfb18e7f5e64e7d45e0ae9499d352b90ae1c8b636c71aecd4fd2855f7e7c7f6d0fd26c29dbbeaa813f79c5fd8a25704e532aa42de6fefb4f69a809cca8019e3b45100867f0142d8209c5f48e9afc2325f5ba748890eb1011c814e3e9d01978a2b0878ea25c920b17244589b050fe98271c21aac2ab91721e743d42ac9c3aecc10a5e2f43e1a8c33f0b481b20a0b5f3b88682e7aefc2c0654aeb6595e6a54d834478f25253471f2c2eef8a75e8dd1f7a0d4fa67dc0b665c05abed3ffa7754059c718d1947fd68bfbe1866aeaf4b0cc3e06649124fa290bf7185e2a62ace9c17c61d92081979d1783c67bb3d78dbb2d3d54d5162b36aa6fb82fb5eda92b8be91d12d3fe02f464f63cbc2c20a2adc52b1060a38928dfa286f97dfebd447343a0fd957223d3fad74ad5a9dc2ceab10937b7e148dcefeed3bbdceb048ed287619d2e103cf5607f3aebd6931b91c1b8ad4f76a8a54bce691e97d720e7bf879facd3fcfc660202f674811139c61948020f735486490ada2ae8be4bdbad77ae7db85d587c177477e5707bda1aa73ff3a7bc93f08f887b80ce64f7582290732d7d77643c99047b62db9bf42a8ba56b32d05be12a3d083647aa2c351b46c3e01a6cb2b431e1fd3686a9d9814cf5de258d41fe21688fa4d98e69a1ba0accd4f257c5d129b7427d47368033915f9fe31aaaa6ca84621f1d931d083b74b0c7b21e2c248e33a872063dfc87eb384a88ef3efbe4bc4c9edccd41b08ce9243c2e759ca78768ec5c02326a6336b48db49ab2b5f76fc594a2b9aacc94648ce0d18595802a252f85c378332a50606b821d5bc04d6d43c6566dfbfc5afc21eba5563a7d195adc78ac71d13f38d98bbc553e28927f63c78ce8926ceee7455a9cfe817d69ac818b29de59c0a264cfe44d9bf2723c52ec3028ca63da87e7668d42fa6192e34ffdb290aa5b1a7dbbc3b0171ce65aa5fd18d268a6e2fabeb5cd4596959ac07e1f9cf724c3a698a72869e029757e6b9e6cb6266feaaf3baeeb0f7f4f1ad5e2e7329e54270b8e1ca999b6e9c52fbab4db94180aa7c767a23c07e27aca122f4f184cfcdbe255ee2917c39e3f9c65b64d4891bb6ce1b75b608d7e4cb2fb562fad83e415d3f4f6a0f5ba6d86a2612b18537177e765241cbe3dcb8b84e5fb514d6c1307582e67e4348e5ee305825d045160fc46cea70af0561c48a28938e571b21308c453fe9aa396b527390e670c6699eaa4b668ebdbb89ab47e58bcfd20415fe44f8e64ad7d06b09d9ae968baea6d8cd28e02a6647d4abf8a14e36c0d9e7cadf0e1f6dfb4f497d0c2059373b8c07d9a691848c2d2b6a7ed53482dbdee311f01aa8d80a86e67c71ddf4f83372abe9f97903406b5d3c93c7889b6dc23188f1d762005d4bc88dfabdf475b3e5cb4ced4defd05a7643adc29d4d12d24c56c2aefc2f0bf68e3269d1160d8689838cc10ecaded6f7e5878a7342e6bdc15db7ffbf2a3cf736f984f9e5737287ab3d0bfc64287d6531a8413e50a2763403f83208f7798889bbc70e7e83223c13e7bed6468a277dd2c3fd1b0c8f761826c01172f2713c915a8d7c099eedef5e187b81e7fa51609f2a36711a05cc331329cc3343e825f1b491902c5dc2d7385b484218de8b68f29648cc89ce2143f65f1ae30585e79c9bc818682dde9140f240571fc3a988ceb7bcb01d309609a46a8282072e01bb1f85df3f8dadf1d35382a8eabe01c333c71e6ce7d7144d62af25e207ff5d5af70ffe5bd763a9eb0bfb1c58a8e93b6158344e1221fa73c9cd607abc03ce641c01cc195dd68e71c8181dbc2726f5cf83fba4665569ead88b29b915d4346498251edacea9bef66550664d0b4ccd09c5fa5046d551de56570782585071f1beeb8d0664d6f3c4ae535877afe3201fcfe4e81751637abf0dd48acb4508dd2c946486af46ad15f14b6bbef3494e5f2a76a2d6da1f21fc87ece7b3a46e0a41a4c18c36c64731915db9561f7482026ff639b4b09676eab5dcd0e1b061da48c5d9b3818394143721493330e85c4024bd63db7cb4042dc385e147d69a0de3b33ae764a7000bba0e66cfc1c5a9579b6343473d7405a3fac49c58b935827efa722d544313f8d4c8e6e84a4d40d274bd0aef0243188a4b61e3f1d30c3d3a0599c8738268e4d38e69282f72bce7fcc2bdfa5221177488807a00b1f15b271f0a04bb9d3b12785998428ab09746153215a0a61b969a4adaf15122f85719023602afb6a753da00472792c8a5ac23b4e5a287fd4a599e9bbf5029dc236b5ffc26255e41ee695a539da759512adabfaf5e7301ebaa64be2719d8404494c525cc01308a83a85c5f808c0e5106bd2ab29b5bb6af84cf247b07261bb83e57b9f3961128fd20b8820e6a7d8622b55ebab472fc7bab0990953764c93ef628d0aaac2169380dd252146864eb0e9f470b741ee17b2c6a8736859b918cab054c4d03eda67465669fe6dda7fb9d640a483ba2e30518f0ff4fae94aa24bb201240d0385de08481225c69215fd235ce8fb434255ac541b82567db66d4e8b2837b41f56a10b4f67e02f75f270c5b2260a057986db607b901d7bb612660eebfd02b1cb244356ae67167ea6de7d449e57aeacd1af0e7322019e0bcfba228b12090ba6f4704578fb58abb02a994d187fbc6a1dc0e52175a56ec983e4caa0d23172ef0f8b3d7879a56a8524fb6782b229058347615bdb2b4bc1927dc5ecc4811c64d4a7198c0ef9ddc68f5f6326f082e0480788aebb2196cf3ad412c2c344aea67545ddd81910ef74192f9b55175fc2b36a65be228f21102c75693f7e1c80c260cdab8c80a523cf1c1de53a9cf57b3247f8a19edfdc00bc51668ac6f956996290e5799120923a7e21d7974c98a087ff6c90fc724cd5b0df4966ab6646c53a88680d500678e917ed9b2c8a82adcce4e93d4c75382bc7804e59a2059ac60ec8b4b739cd6051ccda07b91b5872fc1f6ab7d3d5abafc4f866001130a6fc67bc628b2ee9479e7dad1fdf0f34962be591d79c8fe7ae426f48a14efb883b3d0233cb5c72226869a100e9a5d72d653e957b574c3dcc3df2900275bd9fbef35897311169360ea7f35eb50b40e8219ad847c14a727f2a8c5dc55c53e776168c841eb2b49d1f0fcaef16d2a83e990f587ca9d7392925227f294b8342184dc130cb202e1d1c6d731cc706a71acfe8614aa92f71766121bc323cb89996093339cfe05d18aba8edff74758e7afe046e4d5e4d172c8d4adbfe161d447a9d6e726ffd6d8ad22db9ca5a0aad89363f10b362d597f51b16bbf482e2bd37539126a140c924efa2e9c9e124c744fb0c0220c8fd8b2d51cbcdcb2493ec783eb327ce445d48e71d5dbeec182c40fb8378f25dd0c9e21210d12ad8565e57a56da58bab7773b1ef69c1f8aa78a613dbeccbf288b3c597d60fdcf4fa88a3b0ec6ef5cd436b81d198856550975bd1e6cb5c47d633d9427c7db74ca2da34cb652f01ced2b01258d9540322e783cea130e4e149bf1a2140bfdeb07da6ad66225687f2473ca80c9d056461e398f8dde72067cb77262030bc37b61c39d73034ad291ad121141ce9d79bdf774e7cc4c8c275258fb176c92bc0bbc48b28ed0f9701532cfb14ebafdbb921a5ef09f166957aca80253a3daaf061f03fee67381d581c21fd21d02ead3fae4339b145fe84af6db234aff74c65dc8b667c5eb6b5ef49c518614a7569eff603e2dbc259219e3391ef390ce6c42bf6f18a7a5e8e08578f3804ea28dd6fd744541a33ece30e60fc30b2a927ea33fc91faefde41fd7f08ae1f5336404c91fb662bb6a7d8549120fe180f41af316bcd0a462800dae19cc17f8266b19d336dc66ac47e934bdb2f6c222dd817b036a95c21c54caa4a6d489071fa16b0b3e94fb305b42ced6fb80a60a631f3be83651a8dc7d12c38dfcd1e52236385e14ecd98269d6a3d8564a36cf6b217ad361a75963d5ac2b8acf19eb319808c86150ec6c342e7ae15f864b3af6fb5ed38d908eb96caaff3be265f97daa995fd3bf7494ddc7bfb9040099f4994b7934834458a994722f7efbb1e5443d3a74dbb39d262213bf407cac3670ce53d2f5bb73b37c9665893deb854f7c2b12962479c704c74c4f514eddea5965ec9daed39a38f8ad6fe8cafc67df0e681a5f7f6a6d186960159e04b2968cfa254c8c27ee9dd8dc3c9e55afc0a6800b0bb3240ba1c8d341c583ddf3fe9c2df864ae7e3469f489fa388b24fc1c463ff0fb811593365a087e8aef956404b62e8dd61b7c4a06a6cef8100012c1b64001ce7ed466b8b8ebcc86c3bd32aca627abc875c090b1ac0729cc218d8e862c8a937017351f6493babd7e9f6e75011d90e3fd1e48fa12e116f2d95c04f6bf3bcd3dcfbd16d2aa967f775a1312dbf0301d2ff789aa2f4c1f8dc8311a8c6253a36ec8271a05ca716618a4eca8f08ac72914e2c09619c534fd65178fb0172e04b1c4147df30452a951144f61a27c01f10a6d3ea635c17d36d8072f406c666c59bee1a3f79780e7eeee474a465c016fa0831770a52c714a5be4101d699b549ed4d0099ad0c983d65b1d6e215d60f7807a358acb99516333aec18e0f046ab8d5a2755ae2d943f5ad80db89a2c166f05fde1d4909e19d40903787db1d3f141c2577549a7f1f9c2e531151ffbde5f5ac5f4c08b08f9c201a3a7ecc0c0fc61241c3c4602076e3d62676e47663070a64bee840f20d866a05fb9e68b60063cdd8dc8779f19e700e7dc21db990585421d2bd899d3b0976685d9d10a73ce814a394b6efd95798ce557ed07df05e81e4b5e4146009f30fed6d71b896fc8b817285b1ebcd3e021486e6c2d8fd864c88ee69b17f25459d2f6f7fbfb90ffee0cefd81f78d4c513a32d2f83e5aa1a31cb8249b04e08b11e2f7ff7d98e2b99ef2a5be9021afd137953a936d2f1a10560db7ede84ded9dfdc91f7d7089bf4b624f3277a16a4220160ae71edfed967292971ed688aa1cb394c4a1450c3cfa31228c8f5bdfc876557a4afb97d7c8ee44b209a1104c899e528a15576078c88760957f5dcf5f25a97d667e0d3c2b17eac802b1e0e8fc5393a1068654ac7953d77a68ff9345d91e6ff575802c1f3278dfff24572799027518443715ba667a54fd876a7a2e7f002627c853ee93a18b0bc6c44db57dd1c1378536c0eab1add1f808b77ce60de7bc28196219749f03922fdc6502199edbda85aff0e203082c3217990a7e3d404b64105adaae2ce8ebe7d79ef978b1d50866347b38747844273f2845b7dc866d90e3a2ad2770ab923d4adbbf02ca73173199cd6b509e9a1810e9ddca083a5136bc5ea3089262fabf5bc86235116c6922154481a66ac75a4f485275ecb8bb37b60477a03ed5212b797f025eb82edf1d7f91afe02ced700d6848da8f4bc417feaf9f894d60243c38bb5359998650ad92ff7bc5cfe62b351f278f0b1966d592bf9f78259574830c1f3f851dc1a8a2f04667732515246d2fddc96e5727c9080cf1190854d160a8112cab4f09e08eec4b55a0920e109da01eae6e1bcacc77f4f28367cc689ff47b965663a384facfec035c9705996f02d2af01b2268947fe1e2a03592e9e3724f2daac305053c9e80bfff3aab6a92b4708d7fe5be932bd9e4a23ba86b8f9916211f05d8b04ae315cba08b3a0744cb9f0b4742a3f590c675c5fed0d114af517025481f87a9d515ae02a75a044c15975407c5b252f6b1973dd39a9bc94b8d4140513f85e3781412c5af6cbaccb623cf38520eb82cd415dce912ff7537f108ac784353e5743691f2b9812cd7530ee8d522db9c3f6102d566710ceb22dd0643f95ccda7e282784155362ffc9a07044f40377ea96303481edc3e6d3ae705741269c148ae2a6150153d7a0a7269d2e9154deaeee1837520bc9460f2d0f47f2a083c805811f9e1fdfc1f0b57c81a5842d17b94b1b53673c03d2e91b0a39f85c64c9b0996b980578dd3919e13556346cb321e6538cb8e5901ebf8def67f2f5313d03af6c7e486b5d3768d34f361d51bff595e09c38f52244c1b106126426122a5802f1a1efaaa6d1051a9ad411cf52318ac1758244c5bc748d8a5273d67cfabfb41f5f38ebdf594459f2869ac7e322916a6f057b545e10a84c3065b26e21cdec88102d3bcea02f881e1a882319ef612d2b394a129c3bd6099136e9e5f81f684588c4ce5593daa837a1e6bc3fd2bf3cdb768acbac5d8596676f2f6879a6c9e8422bc618f2ee426f37587b811724a6398f3cb989c0032e8c6572ad5d9d74eed0f560b2f64a93aff4a17af5f96dc0b877c3abf3ab0468257b22c81c9c4376457170a22ca8a85c080433a8aed2054eabf9a94c0cc9e2c2d86259ee6d760edb4b2daef1f56bca25ffefb12e00f1649125b3007482b6b8e98dfd38aeb228c8d28261983ac7ae8e770b5c54d14a8ffe6ef871d42ed3fc0f44b1e8bc9e1b9f50f6ff947301b812e78fc72c43ac8c82d9ec00c4833659f083f2e3cef1a0c0f59893e9753ac9ba458fdd5c011dfa550de2ee74b7d8917943f9d1443500258faa31397eaa44ce344becc7c78ab7fa387362c6509f96b6b00f04d86f20c0cc85bf0c3eea111461bd2fc37cf7ae75b4176102fa99c8f56e504b7fb4c2ae7a580d612d9a19a2d54c133cc9cb64535a241caa5898bd2ada7742a230aa56a1ec81f3dbf8c7e8581b59575ad9a6cd252d48ac638acf73e2ecdd519724268251ab828b5d6b446a2a99cae86b92d5167ca1a52bd334b1e7b14a243bb078d13a60168c89c585d8b15118bd4f437b20766c198679c10ac029b1d0745fd7e19364848b3d8fbfaa0221bee15de26ed4d1e9396258ff4c19f53935716f8be7a2f3af11027aa01d4fde71caacbcd096de97dcc0a3a798d70f8ba47c86b855951e51ff71afe885f830b93f2ed8db7fc2f8247911cb10744ca9fe03db5d0b976822375253f92b462facd72f294940be952d6f51bfe2b8a240d27ba2e53c8196de32b14519cf9d593ff738d433e1c7fdce43c21bb6a96e338dbe2da038c7a38bb12563876a04024352e44763772cff73e276cfeb4502f6c037e894094955a31590bb634f96415ccbbe309f44b3a6516cc6566170627e340c6434d7537333e07b9614bddddb0ae0566fc04eeeaa2bdfe234ec7eaa83364ef4d9071d626679e938273cb6e825a5dd94a77c02d4f162cbcc393eba2dd3bac5f3ab79d4246bc8cb9aa202aa49e0a8183f1efbae6e48aac1758c5bc7eec7bf03b315368ecba60a5eb03ef402a6a467eb321abb460a202c3b9a4da183a75029f482b8530c911fe7907718b4edf516aed7afdd7c7f3379621bdee2deb31f0b78e665782d7ba6fc051d6ed76fdd15cdcf9e1fb4a0949bbbfd78ab5d7569d4186e7f52da3f631b720dd20764ad3da6dc9e9a0b3b4e1679557e2ab9d369d63c8ad6635cc90786fd295edea253b9623c4a6533e327b20e9f08f6155b4a863e34104aa45f7ae27dec6d2f9d3f6a2c885b5076383c53d7e782ce4a9b9d3ddd106fa5833fd895ded7f627300a49be06c05b29a819d3f713b3cf03d21db5cddaed555d1236ea8dba3a1a44241adf3ee5ec193dd49613265d7a36373b0232fbe7ec51f4037af60c718a90987dd3bf6d4025f1b2ca4d32dcd1c94bf16ceadbe1316842b4436222b414d7a7b5adf18cbd47cbcddf1eb543501fad8c0a817e2b44215b73b6affe05e5d9b8d8b5a606c96022337dd89726ca8b7f7e32f23db62a7ca5f550440ba30f87ac3e797a474c7b5a025d48a129b97567716f29dcbdf1df68052327298d7a493088219facd6e1cccbad426e0c7df64ab27a0f13b61a4bdb2e57edf50f52def26c3d2e0cbaab14d718332eb1b75aa495fbda228a6314408c663810b69568b517e89ff6216bdabce4c819ee35dc374b0f7bb1da57e6f29ce1a228f10687be85489d338855568065f81abad777dbf67d1db68905e6beae112a3b4c3e68b2c47ecc7f1a71d4beaac28e0a0c04345ff4bf52f3fd4c9e4f0d12b05a54d0366d8f7c70d98820112540fe0b93b9acf726eeeb0f07dea0959c68259bf239bdc8242478e271bd36a471ae14e24eb41cc173c7f54441dc5ab06443bfab757b9fe1db4aef7c1e582c422e6aa28c24d92f47678d025e215bdb42a4f030caaae43a6b777198ef68ec98ea7a64d0a29b729d68a2f6d93a71a8d3dbc591a9e80ea47a3b25d1b18cde8eab4f1f2bec908e4876dd8ce70a781ad3663dbc496d391ff34a264a775993ecb024526ce0d1742104f4fbc42bd111cf8a9db0233a7e9f48dd401b921487eebefa2f4e6a17c88048dc09154a6526dfa0967cdaeebc4c2a167c8e905ca803c055573d03d6d3a46a956bfea937f1f00a6720bbf56047842e6e4397333f9587e753e8ec796df64d8a79180ce42af144c1999352cf7cd1df99fe207736d1207e7c05412e2459a14e16d6d0f7e65a953620dfaca987622912ae3d8cf106542b4fccc6cefba050d9916342746fa9c02428f4288d45515ec7780f417e14c77a7c62fad1fe47027b713d8630bc8af7a36ada347c5c0fe742572f0242dc63328e685287a6766f84ab12605cca412ebc4e2441de7b7b419506026fda79b58c4becaf4ba1cf5efc82aad9935f0183cb55b5a5c4cb8e6aab268c28877f3a904c923997520162e2b786e4f3bdb37e1e95f7279f31e491c7f9e65bb9bc575380422f10d03e07a7045da167b604d434d5c8b7fe7d881f7060396d0346370d2f204c627b50c7566b941aa1aa0618d9e719982b7c385ca81860265d36d6faf491dd5baf56f0484876c38ec1a188c5063c3a2d4bc3a6d57ae90f91653170702db2628367bd8dfa106bd9e69f783aa0f81f79d3ed4e79fb3b691055643c75dc07bc08a542042348073dc376a36153925d5a6e62313182a792e14d9f4afab33a5dd39abf5ca21a280b3f14971d6a6b6edd4cf4df26a1c2b1cb5f623dd9fe1663073e00c3458f112e20c1e1f8a24583295863c00e9a0d0ddb3dbd88ad3a75ec14f09ae2e4a0e447c64331b6991175a84637dd3769506888d78a31ca59f0f4386b684eee3b2ccbdfed1b5cb9f55096fdbfb8c505eb9165c4f60089ba92310e9baa9375ada5d1fef12e03c1dd24fb0a2f3d22239131a451912e62ce6258a62efe6de22367ab973b9462bd596ec5bc5e4bcdb976c6075a17987dfc55042f3f5623801d79cb7b944573e4dbd944dc794e2243608c4aef88d4f407eb9320f68ab78abbaf82f3e2c6aeceec49c1b17fd42d6c79cb04beaeea8fd47702d0c49466268f86be9156069a1c79ab46f8341901df2e212c8a9198b2db1c54dae557a8e486004550a9e46c95ef0005f34fb5958b38a5e14e57d33668aebc31b0b297c8a78c4b79b904248650a541b6c37612bfa00dde4e7d5c1eddf85966f80641fc19ea32928e08dcfb667c45eb71984ad8a49dacedf407d5e4d122bc4bb35589df1692b6db0ce17090b428998c8ddf388bceee505016a4e70fd2ecaee9e0c144f8b7fa010f1afcad27f740a53e82dc7e0df449c93c90751e55278f30f66a2333c86ffbdb9f3d8ead28364b608a2168eef1f7303d6379e7ca85ce02e20056eeaf1548931770bf3a98ba8f338e816d6a5d2951083ea886608f3e8dd6b4457742075ae7d8245f2ab60c7a1f0b9585ede97ce34d6dd4502bfc85feb0f1606f325878106496eb827cb34e887fd3b0bbe0a44658e58e4f3916d44d75beb85aad99d31f538ddcfa2dc9f9d85d7c5a02c934ced760569907e6369d31f568f211692237fdd66a5e6fa67492a1566c6c90e27221dd144e76f2616deca02f7f0522f6e1548b574d2f1d8c7f03e4fe6f2eb10bccff787dadb8c99eec89cc6fd4a972b3d8ab3f7514577d07af312fbced60574264d1a1130553d6c44935a7b148134709968300c8759eba53a0542ec0f40bdf30145a1ae3b139dba7b66d4015db65d0a6c0d1f3c080555b83397f7ff5cfedd8c3d48a1d3ef5126a054c98005606456e78da7984cf11eec127fe6abbeb2932b5febd4979db1862b14d46bcb65bb5151d5186ac3a6989b9a47eb8ae120c0ad3c5dfaedbfaccdeabd0da2d7b96ef1dda3b6e750a12b13a016b7b8a7bf04950a77a78200a5b49ea1229281a528359c1a9f8d8d2d0188f421b8ad150166c15134ea0337ada7249fb4feccf94c6db042c637c8fe99c017b00f98753fc1ce780ea87216708878faaa2d0021ffc8e96f8d630987a120eb3f750a014d91e98d86f88e1522c503d87f922c92c1d209ce90a68ddcf54928b2ea2c6c2c1b6ef35088f8ee7b41e73e8fc84f9bd041178c4a9e0688a538c64aac00ff66865e24ca8c7bf9d440dfa58234858314bcfcefc55894bdb67ec65bbbf118a7190674edb71ebd91707baa8205cebb0039443d2417e457f6693f7ee6a15c14b2118c76df9ae2e73499e2c030ad21b3d7c63287a204e03e6e29c1214fd95d938f1692f3455065c775a2a8090df5b5ed09e80322feecbee9b9887690f734584705cac7dab612e453173ef51635e7dc11fa73ab875481c551faa6b719078cf04253f906fd4692ed0615d529fc16b4f8badf016cfed7fbd40899cb1cb3f3bd0d2c45c3b6d83f3d8fe4a171d066517c4a84abc047252a3f0752a72328c13f1d7364ddf22204d49da2c31b77c537c04fe42a02806937baf55407838e3bfcfb53b439999a369bc9f8ac81af29fbfac91337d6a71990aa6b9b86b71106c81c3efd4f16c3faa545fc1b4fcd44b3b98476c93badb5da35e777f89c48b7bf87b5e44d0f927131a1072f605b8a4ed8d1c063f1eefec85d617d64501e68503dd864a8b4d8a52f1604f6384bf0f48e2a0d5aeac03697a94a56882c86c3a89497b8c7d1f3a0d2a346b1c094c064eddd497dce7d7bb226bf316417a4a06e8373123110fe681d29409de31fb3fa9f4f9bb710958491654d87c8191264c6a812dfd024bf65caa29ef341c43c2b80263b47a8555ba4f13511b91bf4f4311937f22111d026f9098c46ba5e17b1028bd53e08c3f9675a03686ff29ab18ed63d706cc54ac4754e0ed6d8744b7d2ed6e2fcb49283cb2481707fba99925890ca71b96270f5a47c58910d6973cc829a995338527ca93928c111559d751b77ef17974aeb0ca4cf38739cbcce930c746592e9ed8758ce8e37033f4324267fa8c447493eab81bf39c4fd2efeef401ef1e7ddd5d46f0bdc115679b1c872240000e8f55e0fe4fcd5214e297f3145ec4a2015c2ed9d848309861b3d7647c107edf2f0426e535e270b46bb649c37588cd674b8a5375d06ac7772ff7ca326e64512a473736acd08a07df93f03f80c46a8ab90b5037a4885e7db84ea36e6f2ea07c2905335f09cfedae827a204494c4bd5164313d58f15f5d9a31faa78efdd7f74079f8612c7ba2360cc933c0098631f8f8ee9f6cb5238f61da20abaf73e380999e7ba03a5f013d6d0592ae9d77f21c9598187c5c5dc6aa9964839d592481ac92996668e15e87ed4cc09cd9d929513ee6009cc1aef591c569f83b89ff404ced79523491720df8c99c345eb2272a8aa3cb318351316af1d1282fdd2a09c47a39fdb5288160987fecf37d413f3085652cd3461768a0b551838ba3c2f4a157a3008c4db8b84884d290a168c407548b1149724a912f3c8e020d2a6985b8c0b16df2346bee1b7af026c936ea3ba4b4eff01c7e67b1acad817e7efbb1a297086afacacebda2549276e14b55de8a9b5a2f089b6e95c2d089a1fcea7130d81eb61c0234a1a14b9d9738a27b34a3f2422e4e396330476ef9df08fc18353eaf9cf972efd724da2ae84dfc34d56684ffee4c8faba8ba7526444e4f77cd3668b9c5f273c90b3c57d1097face663e1e5d73062c13bfd065d547598380c68cd4e5d9835c2c06b24575082fc7c9cbc5f4300690e1b3866b088b26cd68fe8c954e0a26c12121a1b0f0a74cada72c7de49fc54783bef1981f533b0fefea94520dd575179575dab924d1e336fb944cc567c459d542f66a40370688229b852d7d3038b27cb1f7a98731ee3318e5a446ae917b49978d376fa99b66e296c584d8a9ce4bc9a6f110e1673c02cb70a829386f5d0724e9d9d3e8dfc14af5e5c3986776b1a79378d4520cae87d1345f159c943e440e142174ba0f843c5d32f4372163dca317a2bfa658ca30c0ea030bcbc38966e328f9271d1d45f5e7e08c119fa68d9907b12ffaf490b7a394ee9449c6a07d1aa31980530f25f6e5107cf7c38bb28b099bb04075088c5662b359541c0a29b8c767184b4d24fd1be1b0d6b7ca6a375e94822575ddcca42c0519fb073ebed9687f7f10f645eeb8f20920717c3cb405b11d0d9f347244a5fa80516e810dffadbf861fdef2ad33583177f6b4a024794a681f5fe43a142103674440230fff41af96356598d71d23b0826808db6856c47c5ce92b1e654035ebdeb2a503d7441111016abc57fdfcce6b7e644b2548631c32b5fd79c84a302ddd306e9ba9c1c27f69cfcf09438a11a00e6a295e9c2ec5e67e4e126c1025e22abb63517cffd2e020efb254bae0d2b5e33b7a8ad6220611f02868a3afc35c9aaefe218708e17ffc6ca29b57cb2da478ea75789b2dca176a729c64839b2303ebb3601a0780ee3dd7c7432dd010cf0d5e1d5b0e4d064a5c25b6946ad3cde1a6a55df5236a4e741da0bb4708fff842ca428b17d6270a6bac15c76150b4d6016b81dd1b989b283256c83469e2cf4332d1561feb45d22ad6ce0882d00e1d1879f0199d2689e2a879ac52750499e9ac236151d422cd92f271359ba566a00f82d234a2ae3d48f9010241877c47542c72dbe5a8153fb65d91a6c2300ccfae4dc341240fc3bf86d434dc60a26767312f45c454257c7facff8837a4e34a2b9093a0c9a40600da8f489f756c2abe7b736986374100972e0eae92d1c19b666955b735237adb876e84b5b6655c0c1753c7a69543344a6f87b8f9d57fd22bca78ce2e3a8821d21c3ef1e6a328810b4671c521cb89ed697240cf93e343271a6cf6ce9df1772d001fe19342ebbfcbb42ffaf6b4770260f3c560c0fb64d63793ce451b0fee644c2a2c87b60701bb847c337436200d1fba8d7d3def89caeb0f403e2fedd261236c079f1727bf0a04ea56d761149c489f5d84bd25d5f2b6e6cddd98276b890ebb5ee71faf7e53474d7c4628665d9de547f883c8657b2df0d011899914bbe7c304211d983d997da45f43bd2aed22e1e881816f22fdab9834f9264158fcf4f21adedd21c5c5d550121a41b78c908aef6ac9fee2dd2b314aadf87db301d4a4781a630602bfb2d578f9bb2e23396e85a536eeab47a6e8cf7f88f4d975a214e26908490b9e350b746658c181d2740db3fa1a8bc1b2b9f97b2b71dc7b2e96173aca33027c27d9e130c709f452052fdfd2c1fb1e5e5a8e499a6343f02a0d385d5bd413611aa7d08675e9e20a87fdb90c6400d96a06b079a400ad39ecef2e62113d92e507bc2207dc8b9490cd950b7ca1e6edaf4163fc178dade017a9012abf936c9c92cb42eba057a6a98ea6efe0f888f090a2d6b159fcb06db8090d587ec579b031ca876b5da11af4a0fa7b13b43e83b08bb8545c90a97e5403bd12d0f5d32c6fb4264e48e23628780cd374181017e68b591befb8d77171eb83e10c6c98c57604123bdaf01f278aa9ff26efdc3c433feeebba8f7d13c475c0144936e342c9c7983b9aa1fe709df1d78b65b0dd3cc37f94c533c5e7ac75940d83ae0f22ba22aad919abc498c98b9a0a65792d64a250efbf7cd0b419dac3dbba8db283dc58a680db52e1815d283ff6aae0937619a6e63c362dc06b92542602d25669959ccb0e8f4d643eed3472c907dc5b3348e065cc8902726b9f0edb08ec2feba0f650b749de2398f72bb0be3e407f9c336a9bacc7d0368fb1260d7eacf385dc5fefefedf352df722e4781a8d975c15d13ff659e9502aabc0cf6023064244578628a8f081756f709d3052290cf7d953d11fe67dd1323acddb066664c63a1547ea597849b71cee76750de4a9b03274882cfec20a867bff098ced18478e60a4afc67217623a9cfe65c04ec2fd536a49814455de9cfefc03d320b06ff90d662ce9e78b0e2604dc055ab000f5d9539160ab282c5b861ac16c886411e99570be0bda468d6c83e9916c40b94928d6d95b4b43cf62b79933f9383c8b7baa8d3e97f781134cf374d91525eefbb6dd2372194771c12e37d4af2b81106a8c51481da1a9b87727271a3ce5841d8032a64c7318c644e23fa3f150fed57bfdd4aae61fec8f9970e122eeff1cf3fbccc14077d128fb46016ed70939ba5141f8c296bea3c516b05a5badfdc370881faff48824acd41289bfe4781562562a43afcb61658ce7f685648d3c7c69b966cacd30cfc1f242d65f485ce7b45e2ca6753196632da65c320b5fb3396bd77ceea50b975b713b8d3c38ffed7749f2b63c5cc919d83fa5fbb13ba4974e79c319d3e15d7a77a352545e19b5a03df9c8e736c3272129fd9bfad5d8cc326f0cce4b56a2cecadd2c8b63595e6ac76a9310dccdf0906bb2febfe1e60846fa335a1cf9878130839997f2bb9f9f0e351e91826263626e7f16233e318e30a1e1c45763fca5402b82e4b8d7b7cc3e8580def81f0af01bf885f77ce32c6c8506298a9bbe99e29fa88ad7fe39f79a3298819ff14a8edde816389669c61fd2fd34e0e21731efd30c58bfd5018a652f22b979fa9a940779b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
