<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f38e3d3031ff4367a237767536be5e468a5b43cc939e89839dafe4c42495f2f338928d6b2e2d1d4fed692da9deba4ab5c7c52c38efdd5f61097f5c5d030908a43eb245a128510935addb76aac4a2289e0c827c51f5044cc56b5143c392d7d7748b7a3fc590986bbac2aff610e825824ae34d0bbce1d95209b5c1d51cf37250b71ecb49966d21cdee464879b3219c1058d44347126c29ae80cfda4f683e694e69a3a5702fb81ca2b685430014f9ec6aa322a2cf16a359f415dc22c2b62a9474ac4467cee6ca83d99f3d66aed74dd8d7c4e5c95c2b99c6886d964f57b27dd9cf3429607921eabb8a2a7f3cbf9a0704a01621d88f7abb54edea3b89b7ee6e1b6211dc4ea2e70a074a47b79fd2391bbc6f856eace365b8956f61d2355f4a06a9de862e61fbbc718877c224a63551cb9900d0c2c4a205e2f6b6443eb7d1593d6f27106be7b03ea6331f5d70cc5298d662ae48a91539f5daae54b4efef1da3b9d2aec49ae78c3695561d2c2d16a547b5ce35932bcd23c02762e3c1062412f631dc46142488399395aa4d5063ea760a535ec63db69075b409918f3a74d70fb28c1089fa2345aef20d0e545cd38aabe940a57c81d122fcbefb0351fde69d3c4a7333a9bb7b94b08b21b8370dde981a6bc207555de4141775e763eecec94051d3e883f6dd0c6d7225ee5e252a267e348e5c96513878afe08e732c60843a4bee2fe88b19cb619ec516a8eff1b44b456f1ecb01544eb6eff10e17856d01934e011ccf7cf08d1a67f49d150f3a6dda9f55897b66b3145c6006fa009bcfa36802826510f99c6e787c753093ffa2ba624166ac3f6d3158c5731bf940caba7e858d86ed3b65019416d584034ec331f537e83415c024c017dbf0d9477333f637678b77f8795e1fa92f897b835b3e6a7588692901248942650d15505b1621957f9bc6e75bd0dc2eb20a2b701f19d482a7a5a60ce7dd6f684e4e06f4e372bfa0312364e355ea4c2b1c904b434d22fe4513c7bfa04c65344568d83df72655282bc6f0b35c3da5f8c98e291759ae5ccfc6420168804b5ed935c66ce06f1062f352e1bb977eeb3d73fc7d04cf03a2036fe1054a610122131548e7f4131b5c9b2713aeebfb4ea2ed7b079686bbcd3088aa2a3e528b7f2a91fc2f0f465d5e1619dc05c5baa0a9fc5a698e901faa85f629be0fe48eb833d6ac858b132523dbbeb3bd771bf8e5c6c53730716d35f40f398df51a7d5e809b76df27e7fff836bff609eff00bfecf6a14511c620ed62c6bdc87ff4e60f5d19fae8f7355f9c87507ccd1acff8ae32c7aba6479b52e9d24bab8a2539689bf5a5928cddbef90d8636608668c23da75782ca117a27fc801ed29e0f5a43492b64d95825ee39b546326e161dfca8066d75bd1b44720b49f775237c1880515fadf22a8c8881c60b3b1c06e898b2f615d95d80b3128526ef5d0caa6face053cf66c9e835b262b12c46b3657ff8d8f33b9c48a946bdb9fe21047ef9cc23e71afabf64a413434ada04296abdd0ba109555215cb90402de9714cdc4eeee438a5564ea16e33155f2bd403e5a400fb8cd441213ba79b281e2973462c7cb4f4098e1109cdd8b8658d4a4113353aa11dcfba1a71b13d4225691773c0271bea4e60b2e18ce1356fb7d14165c713bd6d88fcdaf7e136839ef53339c19aa8417ffede111b0cc38c8349a86cc3adb6606e4e3034ea471f241976dbff324262e843e5fc803799e92953b69b9ea796ed389f894a6ac3d27c0c3efc61471de13e3fd2ba7a655f03c4a7341f223aaf568a53772cdc5007283a21f913ee09617669ebd0ff63c774221ddbcb9dcf418b4e7abcb01dbab842f05e7f7ab0850a19d28709b64e02eada318920437d745507a4ce4c349a52eb814d02375a1e3243768186cd42404fc9b61813f6ae63f5325c7cc1d9009769b7aef20515be71b4e22d6afb6c39c02498bb111e9dacdba0fb8661fd91259677e2ba56c740b93a3f568695f1690dbee857af5f05d6db14019f2a40b77d07ecefd704388ed8dc904797dc1732555e35b325b1525e11710ff66de5637f6e52aea1d21f728d79a2558e47de28c605b2835613e4c7bf43da103fe6e08df9bf2e65635abf8c79d64f87be7563b978e5bc36e5f9330721a67da371abbb5b1e94886b7b87667e623bc3eadda19566c113f98297040e24ea5e1e977bb1aa7588e5b960096cf3dc77f51e0dd7c351543f45a9c10fb91711397edb24ecde625770890e4c0c0321ce7e0af1749f1e2de389877807bc52c298e9cec5b8fc4ad5e8766ad55c727b401fe2bcc87bea8399c0de658c604e4d86faa92806924decf29d13216f0b54941c92781015924fcb5431c8cfc9752dbdf3983987e4198e92ed39e2914c05dbdc6e5eab478bb50548d7811475cbdc50bf3b4c4d20729a9a04a66618a3fa6f81a0387b60f3b1004cd3e48398e5fc01840b5e39def3de1cf63fc6bbefc73087a1561adbcc5b0efcadf844eaaac7033b92d58f67f1d2ffe330a83eaeda1db333207de3d3325d35cbbe4392b55592050d491889c6d0b0e862730036b7891d1d8cf2f265d9bbf137e070d74a7e4549ede4c5917c9f1807d2432c64e6df4addeda744ff7e5bcfe7b522d212507308cd8ce55480a7642202ee8b904d6f24314cd996fded63e80ef7b22876b54ba761f74acff542a84554f478b70ca7b10f14ee8451cff8617b5468e3fb28729bcbaef49ad0c3ce0dfbf9312102e9294c3eb727b1cd2674105af46f153856d71999e336a21dc397f172770c0737bb895661937c9cd76de3d21b1380b7d2bb951bf47407350a67129ba905838339216d2f4f419e478de3a65f69715bea2b368e988e4336d38cde308cce08000c87b219477772f9da7aa6bfcabec87fd685e405669543d927ad10825afd3ef369ef42df3211ba299087bf526f675ccd00b2564a6a487f9109aa555be12a1e4582f9785fa192d139651f7933bea6e2e2dc7064ee10caae38075a1e573b7b1a4ce7c1640cd992a77d715a7e6674908e5d5ca098a22b7693bb56c8a1036ccae6565f6445e0d163448f18c7f35cd8187b0efb7c145c11a159c0c96831592d58a04f3dab30a4cf37491f737e4c30084e6173399fdc6b0ed7cc8b12fdfc85d3cb4ea223dea6442be51577c944e693ad047b78109dad8c3e01f4915077fe08ef941f34f714a9c7aff2edec3a497d60dadc6409135f520368fa0c948f2dd4ca806a10b96a68e81c725854479767ef28e2d60870d09318c4ffefa34db4ba68422d0f05280e58dbd701e443d3fc23d37ada3696faff6230c499fbdf588a539452210915d7af1d525ae54dfb0784e8a9e98a8ad80de2651cd057e6ef8b220ac4db20b5a670ad883b1a0f1e0ff32f6a3cc996e56b7c94e3033acbdf06d14e2ce44d5361dc27aef7b5258593868cf75a39eac3dcdb6f2b311a45fb1599d045d122a79642156db18afee1fe47c4b9d87b8582bf1df928dffa2fd5b14f9e2d06b56c9a2a951032b6118bda825d15e76332c7ea2d27ab4f1ba4020b8f252eabe8a38efa108081856041344f95e810aa950da8388373529d9114f21432780b4e3f0d5bc2d53b1234e7123d28214c26d66d60ef6abf69b50f4a37106d0fc2a39da78023c3084cc6e7662e75921091b61492822309677a14cab0eb9d37aff98d95c619fca2f9467ff37d2c7fc5151192f07d29babb9e0ea424bb64da0b1b0815d5ead6dda0fdb5601da046b7a9bdeb2e347c7af6f4204030dff68af0ec0f6457fffa526994109bd32007677acbe34fdc48a19a35aea660f0e1482195ef8139ad9514b9bdd958812bf5a8f870d23de023a57931928d28b0610d1ca4ae79e537ce5972d3645987ceb6fca3d7684cd0ad950c841024b55a1e8411da086eb456552a2026065e60331e7f8af2186ac549326dbacc286eb62e904aa1d6de39fd2bc7d073352ee6c27aac66904c45fdf821d835d1f84659c6a75c1346e542ecc28a4dc0ea40633fcd135abd0bd79fb20d9fa6ea7b53056cffab71a1b073ccf63d4897615c15b5a766ec6f160f63722e75f13c090cd1f4dc85b0fd8a6d53ae50888ecb4e565cacdb472b2bc5d9b794762e4c1a81f9c857cf3a1b42c97636c1c222a357a4c835e23a723ef95e193b0f9c3654f910962a57380c697b2b906f5b0f50c823b18d963f71750917376e60aae9ecf5142f7909b85ac5d1bdc017f8e3b7bb818f038eb40ecd1601221883b33f21a6f88ec3d35ea620c757d5dae137d4f591f6ca3df84982c272b08a8736c67e763e43ef6014fa94e349c14d5a0782fcf26e84ec1d805298390cc309acb44c9b9f6ad24f056c09854032e7e0027196b8966a49ed3a98b285b1b5da4c6676ba453fe986be4b2d7e3de0a6d405df0319d3330a81fc92d6df8c0e24ce6f4fbd8690f6ea7b1fe9a9ed7dd75c99eabc9a5bab8a6fc4b343d6396a56f811ae038f5c9caf61d5fe2bdd247c62adb407c9f24ef75748cdd43d65cf05da80aa7ec09a1a8e9555de2cd02ff313038297bf6feb102f6942a5b838dcae0416329a849e88155f99ae9b58b580503328a4be5c9a2bcf141149a00109c2e9c8cc48fa416c59a278c74faf2417549f72bb83cffae7856c7bd3eec362032fa1c72dae1ddf90009d516fc967e3736ef4604da97c4f5fdb1be75c00a25215896985586f2c9054a18b3ab58007b15206ef911a1e248fd6d2790e1550f3550ca8479f8f7e99fc62dd0a9e70960eae3cd63b7c77c55108cc8b56a02eb0dfba2181819f5565679e7e9f4ab2f2f9a1506e2c3da5d7dc2465d17b6901f85ddebc1c486386e67a80c2abd5b5c81a375d7d5e8e3dfc7b7b983f994dba1f4dee05029e1073d1b6520cd4e70105c16d27ab422184334338bd8373afd9aed0b2e7f864e2b679e7532bc9db6196dd12e98d08fb44e23e854f66fee3fb68d9486c8a0e3bb129fd79fc17704fc39b30accd5bb0a897f1bc34c5a16ec07d047863510814e598d1248f42492a145dbf535a00eee3fa20e77a129fad96b28bda90483ecd0d366777cd032093bedb037d292ffe1b9ea497477835c195552b6346e101436ce5d834f5afba0dfabfec9a4f33d8b04b9a47fe3314ada690ea9901edce8f893bbcac2d03b559c5e42f66704fd699aca6ea8dfc405c54e57cdbe8fce81cd881f9578b7d7fddd3663c7f526d1ceded2c0258a7575d360ea128f99e857500833df0624671a13e2a286c429eb08cf3e14504be5d7692a060b3aea6945e8c3f8ba626c8f8a6afdad8ec52433e1bf9277ea2255c9bc3ef1eb718cb0bfe06e469019a614d3a81bf0fc29054da6fb1c044840f0e31832d38f634e5da54a8828cdf7211ff4129e97ded010bb5b6dbbc7d7f87cdc50a56b7ec7946bed52e631ad206d42fd1137d45b98876b6efa5ffd3b1bba1f901f55543f11ea35b6a40ab204c69048bd06101ff9f5d2b1b55230b40b0b49009c455beb0f5af14485aed39b400f995ba9958f002adfc37f5df7b2c8625fe93ac5e1bd00770d2ae38ecb60eba02697804b464583a0a3de0e807394ee6acc2c6d59ec3e0870e969d17c736f2ed60ab19710a9561a926b9568f6c7df0f4a0155a347fd01ec5e8b5ab59c08eb6d49bdcba15b6c8bcade2817b6b08951935f0074cf443e7bc6034ef5449cbe5ca24d5cbdf17dbd9f27f9f7e0aa3891b1a76ffa3ca3241d004c4cc6cf4d202afcfe1fe8e8aa239d8a68ace19ce771abdd8b0ca3c2b7377592031396f788e7f89c7763681e22b13f0ab21bbb00adff3657fa21cd1de3306d7956c4fd05dc68a2e8dcd793fb7e160a6b1bc3191dbeb243afcb574d57295092b9843ce91adc846a7acf7bbc39459bd8493ccb8e9d6b3b4494b0037dfc07a1b516274300a9d464e9b5f25bea46709af335bb8b0e23fa949200f943d4aa64d6da9b1eb08f5445ffd3539462c6db175dc00685478695dd79ffbcbf33ac7e4fa7524ba83c1d6df55d4ccfa25b35dedf9f7daed209b0d705ad60586ba7842cf6a92ca52018b71967dc10a4544f0c612b27c4bab1360b8f19bd3567e8fc5c97ca9a97cc2785977e04f73a77759b96fc670ccd5eb2ed3da1bc5b14003155207e1938ee15dc556e4cc237857d81a3065e4613057d92b567d5838a8b32dc6db046b182f99ab36ef3ec3426efe595c1a3f81bf7d5c20c60beabd8692161ca86470b9445cf40e3f957a217b08f1f03d0228bea4e4234cf1fb9a7026443ad16a595321b809383adbfd55491cca3cb1e70a7082921dcbebbb0ef567ddfe4fb8e1da2ce51080e2383bb9edd3b1777123ecbf5f7c0e433484d5a60edbe0809a25aea33825ccb9c9debc6a75fcdbce0b55171611881685fbcf6d06fd4d326361f9e4f61eb3efa2a11c776705b1b6649dc9e30140476ea95f0cc96cc8bef2f1334b6d3f47b3dd4ad17712d6796a6c9eb02b2edda54121e1b6471f26a8a7326c02a8e631bb4f67eb7ee17686585ef5b5fa794041f9716dfbd45712921b5f1251f99ff0d64fd36ac74815ffa080bde6aaa72667c1fb2441d537b30ba624e41f96430c4b80a41991348d7214920c0942fcfa7a660e35aab7852cec4b1420bb014b3e5a9b4274c0a3bc39343ae2f34f1ac1efd74d3368fae171c0c64a3fc76e6840d5574856b04a0cc4e94881b1f281b982990506fe1b7a99ab6bf466bc30627a077d35b2cb13011fee3f2d7d34828663ec17494fdcc1db9dc54fa878b22e3ed02f95226081aab8d478cdbdf16809851a548c3e5efad9655418e4035cd55b1038277843f9c67b954b755a8bfee79d6ae0655715bdbcb9181bd1f91d6087df5b4d4bcdda3b592d5977c0f34d4fb298f807fc37ada843aee3991fefbabc6c4499817a3fa78e9a24059ea579a938e594ce33258a8ae2d307422be5686a4d539a795fd265af72019aef186ebfc886c41eeb781675c7b223a30c7d26a07ff850956d336bef1a1ff91b8926fd6a15175eead6605cea75429826e35ebaff298a11451c3928af3a825b3f41f0630f8fe5216417b3b097b053e05fe0058fa4d3263622c7305c265f61e81ce42b00ee14d10b328ff00815bd53be487b01652436a6070140a3833cea0da09e6a0263d6a697cd55d975c98e768593bb0edf894ca2016f79c1f4df40ade8934fe21b3a4d9e3503083080e2ee159906f923d21e22cbb462361f900e5ecc99ca86580e0335a4904fb280f129e7368a1eb81f82d4e6b67142b9b02148224bbf0d274307d1b97e9e38857133e328752d24eb1fea3671344d4d67d1194b6652bebabe09b608a0eb953b55fed13487d2d6b5d10177fe952365e45f7cb3804e9086142f45d3ded1fb7b8717ada35be312efacbf3cac374c11c0023f60b6d1428fda258d72cafb74993663f2b143dcab121d6d8bce4ad277f4ed8609703c972b402c01abdfe8efa449cfffb634e350c47515b44b23220fce53cde8b82dddb9a9aa2d2e33542b25ac09ba4d23a9565f7a8f76c00e51c860fcad08062505d4042b8fbf3e6951fab1d5a369562a8ccee8c675fd1a13e61e92ba1e30eb1bd0f137e6edbbe9109837b1c3d4e31bd5eb9c8bb9c15f257dca4386ef3cf2c65e916cdc5b5d5305d367beba2239076f4a3cda76e8ad16947034ddd9ce737fb7d157c896e1bfacae80a5e195f4f94baeaa1936a543128f18de0b798f4886535a1b202141446e1aec725234f94e08ae1b21535d51fd5a950d35584664bd8e6276ecea888cb4329b3ac8f410c6ad857bcfbd206450d4a0a7ff56e1b119de814df72f1cf03a16c111cf1edc021fb59170e423aa62829f7d6cc780ecdc218c75cfcc9a604b332b55debe2f467653e6b0a37feff1f0495058ee48788eed60a3a75e4b1320378224a336c8e780e1df0eb74eaf8c2631bdc70395105a470f307d3680d73d3dc3704324cdc3791af157c3df542a51664d28ee8859180ec4cd46c9f52f6265aa21135fd7a02ccb97c6df91abda529959752cb5d44b136aac23cc73fc0573e5a67804df9a119e96f93a135b840c3045428eca8761472a65b0e4cf28642ca5aeaebf5d89b1a14aaf68181711000054cfb7b9289a867006c57a1d65fde7a39a3a56800aead927112b6ebf7af58297d0e4df88ae0b2cf2acfd0e125e00654f3f08774b13633b879e6712bb98bde9111b1173cf8d3da33bc7c8544712547f5ef556cb5427914b359a5c88cc566f87206cac1def7cdf66438873fdf51a1d30ca3b07342c07f788d95bd487499925f9a41dc62abe70eaf73c66ecc506c288e4f9e02b147684edafbc73e848556420431a2db4fa1247e1b1e7695c335e16a4c16b6a57f47133e22dc32538ed750ee33f57d89dc3b76f59a70cf5808188f2609a1d84e04da0539fefb4549508bc8f6bf443c245607efd1c686780a643fa359f3c45ec59cbfe16d14a1459233dda11746794f6c00363d953e6f854e4f4d600f02c6cbe8598bff20f4306c6f8ab9764d99c0366593b8348a297982189fe3550477d6b3e032984be00cd22d83634cdc5a90205413f912c97757c93a6248cca4c207ad79b8504238435108d8b77f7609f96a8d2a75212ff2bf096687e1be9739967e53bd36930c74eb83833958b338857429698be7cdb7d6a6f8529d8038d9bcca2a698d21d922a0e9434bc06dd721745e13f159b81e72a3957868e440f6e75c394464a030d8310fed9b544bcf6eb232b5b7fed141ec7dedc17417fcf8a0b4e324cdef625d9254e8e2f75917b20c08a01e75a36c90b08e15542ba91c05005b32e576ea9a098dfee616bb76f1a4c7503723921ae3fe0ddda46d7c43102e8aaf46537da3d398a95d526de3968a40cde53b1cc3b07779ef8d4e0bd4189e7cb84cc152b7c1f2d543cdd76c62682827c609e2aab9d1b311b08d40bace68d2bb5205ba3768474a4d50011eecf379848c9620e3246129c0127e05accee752ef2786969cd7ad474627e44f0da2ef60ff675e9ba8e92bd9c7b141d3a760dc3f4e841fef75b53e4655a69a76a60d57f18d74f6f5dc776a6d624d365b48261e7e50195dea0b972bc6171b174117fe1a0b07737b118aa34def9a308cb733610a97e28ee64319274ccc24423dd40c6db02c0e4170d9b1f05291480997ee0831e1521cf1779049aa7ed85c8fa29ecb1a466d653590e4cc75381c452271b12ad553ac147bb3bf71996cdb71740310654d1eb1089bbbbc09f67ce75d780c05b2e63582929f2bc28f5a521d734ed974ed408d02263c8647517f7beabcba6702c100bee29a7c2a21dbd353b678ef30d7449b4898fb31b2c073d603566c5eeab0dd27033708efa1a004fbbcb35a6960fa819570b11a9ac5dccead9479bc412ff900f6a7fca581f463e7e763ae6a4fb34f3feeaad3719e26a7c8c2c262f498bee7daaff0393095a76280dec364b22ba95fd667757f84933b6a7ce82b815beac490e2400aae82f50bf4306f6cac4a5a0938ab977f8e41e1f7fcd0047c3d6280c20a76847d9a76fb4a831fcb2ea1c75cf7d8e6c2b026097d89975637275f725e4236cdd6785158c6103c3681f36c766714f5875f29a60b258274f1d4cc011a2f646f1d172ba0f64b9f07c8e39323b7da53cbbd9998f80a1d7e9d72683c40c2d0263089e09fe0480e1828e1bdbf35db5d35285d9b51e1767de0ea454fb0667291c6c1e482370cac831bfacc544434921d77dd752a856ed5989d927234e6868d1fad47e9d9134b1066fbc814aaf853584f419bfabcb9cd71993df475311b747276e8f3331bffc40502281a0fd3dcc72f65885ba7f449b244f7e7fd23217a7f44a942688e808928fd0f6542bf68e3ce51a114a4a1766f8f0a0b94ec102a0e4cf06f4b5300657e25085bfa7a4d0f32c7347cb15c4cb98f3f4311f2025f4d0bc131985b1ac0120103747004a67f065de77f104a8cb9d39c9854148a944b6f1a05af3290d6a19ebb1978e9958ffbcf4d911bedd77bfc31177c77fc52f19e0b1c1def7a589a310b3b13793fb65ec543612d6fbcd661cffaafc39f45051e1634fa08a1dc6d8d25fc48256b78390e9bf97762121c47c4cc16ec80cfaae85485a0453dbd5975f0861c9c0b5c782dd7338ff4db9547a8e806c3e6074059df6727a62899847eab668220a96cfd8fe5120b3dff4943712c0512e2ca5da4927467ebfe23654145c9c35b2edcbdf4ffa090e7a919de2e19dbba06ba23f9654f8a711744a224636f3c1f2caffbc73d39f47cde991c42f6423ba0bf03415ca22de41a2591d78189584a1217c4b217a56b5517bfbe8058bccf8884dd685fde4c1172acfec9f786dcb063c48916ff237a806478c5f963d64013e09ea6b839dddccdeebe032b38628e34603fd2e52b0c9fb40f0fef9b25bf97c19ab05f49a42446ec5216f694b18f2b34d096828305c087f7ddd107d273afd2f259bac089f5246596b345700a11214713c79a3a79886c1a48b998e872be4d76eee5926adeeb51f9969200bedd3356f5f06787df07fc9dee63507e02745c3fe1cb14f7dcddbe54c7daef39cc2bc2035dc74410626bbd793bba8f827e720b09b1f805764a47d52cd536d637acec67dbe543a407bb72949a6ac4cd30887adb86261c752e7b57371cb3087d735f83473da5bd42d4ca9ab2cda09ffb5ecad9373f101a18224d14244c11b51199562ef5774363115d3e29d170345161f95ca65903e30e47c645d4fd828da8768a0ff6e6b759d5230918f82bf1e3d345294d174c5bcb6c6f4cbbfe11fbb14a91d820a3b4764bb64046afc5740a72217dc6f939a2ce93f273a9ce8e6ab683dbf10a0946e5a297577564232948050ce520514a98b59db20205a514c3dc61e4b6b5ebc26bcd6c830766ff1bc6b721625fb08b1d2924c9c8b33758bfbe69c5a91413559a58a49d066df719e7451c152289b3337e3bfe7683a8a7bfc067b90244bccbf8f792425654502908ed12953dc5af058cb173160028557212498220a549603d178022a94dc4092bc0e3229b8e94d83d9b727cb14a54bbf4488cb84137c337be441ddc2e445fbee63671a590a606fbafed80fed0beb9de56cd409dd2af246b0cd73abf7a7cd100c38bff3380e6702f1f5c18fc79ee62a3aa39011e4bfd0df2abf021d53521b7b893d1ae91f8cf980e0eca553c219eba5282861f59f89571cc894897a73d5705bf75c8f2e68fcde7b9cba5323d30ffbe9abe90d9e5a36e87ae785ca1b0b709f2c6b3ec8e20bd34b37f3394093e3b908254637c8e57a5fefb3a7bcb8810c03ed34acccda73c707c47a85e844f83d99a05037b0806e5c1fb9ae3f1500c404ad2ef2f0d1b36c7b6362fefb09dfece8025bc34919db273260affd4775eae71393044f1b1c7c1a653ac9c28b58d74ea0ead32040f7c4552525a53024fd6371298e6b2230de88c079b0de849dc6acc13d7108bbaaf72929577aa58198f894aa372383fd90798d014b290dc3e656409b5e8833e7d02a16169e59d4cb86de8235760cd7dc5b572c55907b145d54d3266832fb88de98dbcb6f12c5b4abdb2f9cf3ceb7454a40051e7ec2a56f36c2cdda8c3700e3f9b1b142bfd03c9e75d42c742654d46ae50b2c173654c64b262facb7e247374f72b5fd062ac9ed9d17fc9f82f5f2bbc1d78dfc3c2fbec47083db4892457feeae99903527957f14ca157f12368cdcaea82e29f8fbad6c8d62c17ff74d813873509a9826ba99666eacee45e2abea302bb381c433020e2252d9bce5747170140a64c39668a8a30c5cf742e3e10883d8b07ab41852a62862b3fcfa1425915c851edf53499b0699b83e0e319efad21a342924c98fc521dc8a1e551e5ee1a870b53b0529a6a0dc374c31161a6da16f95f3b2679476f329d1a93bb85875ebd86845c56a153602f7048f5e9907de7567e44586d6de40a0f16d224081d4d87a63dc1733d1a961cc96f7fa0a5096d5d27294befbbae2373361b93cc17de7d6a535141cc40e6e363590fceaddc186881520761d4b5b6d16898b8bdd68a4d6b29444f6f664195da37dc677758d558cb0e25b172ded0313a9a9031269f2762dee815070f71a3c4cb68ddbafd14319846e0af929a51a6877a66c04485f93608cea2a98f91ab467392f0de64ada6f9a6160f895804be56aa6a9b8835a1cf8bc3bcbee51113ddfd955419400911451ac2115244b54f56e0aaf23b0dfcc05a5cd991db941b7b2cdb542871e4ad56c82b271563b1805c84f65e4794ea0737749bd56cf8b1c0b29ae9e41d99899216b3827d9527eb53e9c994d81b4ad5727895d91fa966bfab8ba6d1f0f21bb2812e13e23cbede188ddaa3d6144802a285e8b06be9adabe0c2f0c66591020948b441d3dae051cc16f23cf2f4cb2c0f2a177029e283b6ad9aef54d609933b9521c43e1c99f5ac68cdce62df6b96df49c211afa5d27c481daf40f847ae8a62b04f0bb8b53c1608970e7e966b9bce7b6b7cbe097dde3ef5df6043b526ca6e3af6ced4d4a4115ff8c0d3f0bb7d5aac494635923221d5f833aa50a3a25e6ae5c5a53fac04448a8964716dc0f64ae46fcb2863792bf5a1a302aa81f42b74ead13948c337ca1da8070e9405ea207cf886ff4fe49350fac6dece70f7e8e0416dd9498d62613be5cb7a74c2994a5c2fd1ef852436b40fc8bc6c98bcfe5e42c417d6fbb169d02710f912262cdd4b8d1a40a5800749555c3457866f9457ef957d0cbb19e53353dfed03f5620660b9db4f36f9faa1113928f8f4eddc68d3219d20c398948287339eadb45c90f8ac47453cf79eb077f12b43ae8111b9bdec841627e1d5f45044dd380f8e8e840aee5654113f28aec8874a705dcb27a728d79a1efccd038681f1d98841d366de8962e5c328bd9e5bc183ff7c1d10941e9236e47514da197e41ff7506554b8853e2af250a728bc8b23dd0ad3cc806db8a9747c268dd3c29f5f3dd341c4d17c22d841e66ce66c1b566902f32aa17efcbb96c9f84c9bc166d185da2e8c221adefcc681399c48d748cb66251cd862db7a531c857f14fc52e2bc4d30dd2471c760f4b0750ec4a955ea945798545e65c0112eb898a6250a4651ae703d78a591fd11ce1196a8a10896810423e9e2891681603986efe5bdb96aa3345b17272977209aeb1c4fdefd8eff9fe92b922d8465bfc43dadcda253ff5c3bfa455027c205d08859fdfdcb8dd917286f1012b8ee56682e0e807f68018d9427b7ce75275de9023c57695083d08669a3ef7c10f5dc056e991675dc168187b5403ab821c87b06600d1e22639db7d2edc026402671a8d49699f0a96a36775c1c115b72b640f9ad9af3198d43a29f6a77aa19303c9c67329f930289fd5cc1375c9bcdc5b1405b1e9283d324155974a5daeec3a332615218cf3d8ce3a59d015063603f4b49388c69a140746df1f0428af032568615488271b549241a01b4f253ed6295fce712173fd3d863e376fde67f0c7b80e7b006f31a7be9c67e8389ee26fd047c2443a98c3db2922966af7a5dbcae7ee25409f32a4db261b7f4832301eeb8d35e17bb30d78769fec02f1f50bfe110cf7df87c30c8dfeedf0059c68b7ced85cd2e442ca8c4339fa00a418e457eeee30a09e869adc437887af764d9e3e4e5c0c0fc42483bd8e03103f2d6f56f50d7244526b9a6890c838e884135269ed24c3e703db87e46ddb91be20f2a4249f6a1763983f99de70e556fab18ffebd991d0b5345d4464bd354b173dec79f39de679d76bbf8f2b9b83ec407d3ce1324b59a36ad61e2d4078e6379351c95d29894559bc12d65ecb70348f3e5ff30823c93e0d2ce9ade9165bf4663b7adbc666ae36873e6e8378782504bd86622423c410da1c8e19b5bd788eafb0a80f0abd30fec7d41d8de7b1b9060d5f6c7d7117e5f4d144c7a8c8aeb9cebb1df5484e062155e81bc4bb3f9b4159741ec88a97f3aab12bab6a53ab05ab020fe15b50d2924562cec31e505a93f1c06c3eb5908b6d49efb75b230e040407e5ad6ef750364f3d01f2c216219ab6d170fc326afa7c151622c05e482c3629321eb27b775a21a4850c0ca1597937e22d6d7149d981dd11620774da2360b9f109367a2f7215c4d4e139d0747f78643539d016c467a48f2d811c5ed0f0bb1b911d56d53fa2c2094fd389bd5894bd1b2da86c1ab757766ff0c538807e884e13ece7327b6efc50504d9128503b6014d20abff2219ebae1cba8504b72a997ba34c5f20d5999fbd2193508dd402e44b67b47a891c603661ed6ba5675b93d43e94d79b19dab8aed3b67b78d19da0b4ed0514196e059a0ae92e759545f7aebd83020e928c4525045866dbb5880f6a91755e926e9de5600209fa6dec804299de4bffc15c920d42690c45488460e23bfa1d3479dc97dd7bbf176d9d7eeb0128f72d9d2e2d51aa8943ff573d1f9385567fc300ddbfaa6f2ab3193859e3c5ab494abaa1eecb2c974e75e037745674444dc4916f939a4538d2cda216cef57a288112a357b18b77d4c8b4094d955801b4e6c456b27efcb5ee9acd589d07f3c108a9357ba9d148b9409a3fd465fd7137a562e060b7e54ad924467e7ebc3bd6118642a2527d400b2ceeb8b59d3657f1452a8edbbd905b9d48165f7425823cd14309191def4b1a7cd61c6c9ac114d1d2413b657257189a6c47928104775ab8a74d8aef21ee3b796df9854dee8d680f243e72f271b4da3d179ffdae3e2caebd71efde94371dc26e10246444bcde713b39d9c2788f2a013a30097af44a755f988ed0791c40cea945225195f21d23f006219826e35642da77f03ac0fbae81312f23dea03e2ed14f6461aa01a5ff0a21f6a4e30fa9e6131b7b8a2a51ef7e0a67b38af93c48bce19e076b9eb38b61ee31c7da982e7f3e7fa4e2937b6f2477065ba9e8c39523425c32bcb69c56448307b36eaef5da232d9bf5f4cc9b4e547949d51086b8701e18e1f99507a9639961d321570d9e13788aec8609b185b346add1a15b293f50bfcfadef779e297f151e31ad65b060344f7ca6e3a0dc18b66b9d01f51b15adfedbb90737730195bc806e95b74fa7b2ba140e3647b267278b717d38a8edc29ac00b79abaf0da7ee56cf586bcf1e64c4d28415c5a13fb056258d2f0f41eaf7db7757e04a19d016532692453a24a135eb22f203677893299f431388b446a6ce1152dfe5fdef4c84b810b22ed8d75e85c0d6cfdbb6b26c4c6f56cd58a6dd69f258ce404b11df6f1d8ef4afd2f915f02f163b9a4ccfd235ac5efe16fefca12c95ef3ce3fc5a278bcc93e50ce7aa650cf798eb9ebdc86470853c9b72071e7904e1f4bfcdbc5cc7d0914cfe3f43f2685d006cf8e2108e976e853b677d06e7717afd9f55062fd0ce7528cfddf3e8f49f8bc4d88a19ce00e7107eb5a20db11e9b89d2deda0e67ec2e02e957c7befbe3e634040deba23d75b3421a68e2b871be9fa74bbde924f8daba13213f82be1d666350ab2513439d0bcd8e7adf4fb548ef3b14e06769cdd1dedaca7e3da1125a4b98e5eb07421585f92218f616e37a085660f5ff25bf22331a302f79fe8ce9c12d8d0a98f5383a2e39ef421bd54a5423514522027f8a4f16e2a75906208d7c797273b83ef5556ee8f1151ddcb50fef19267cfd34ddf271e5d0a42a4bd7f55713bc8018a6aab5d3cd9e994d46703e90528a90eb80e4c7b13e941db606478123d701e4eb536085a54474d8cd39fec7fe21f73a8ea0cc2ec672766b264ca6dc9fdb7592a15d94ac5956d91a90479918837e6393c424c845ebf5ea7500cf1de2745a741114101ea75748f7e17640a29dc7d6e0eff151b5a51ae8a473d9ac3b0ad40cf4d5a064cd39cdf80bfd67751e683e4c1582e6d504f106bbd1d27802a5bcdda2577c5f93ee88883bad901ac984a166456783698673d67c2a4b8969c9163f8e2720ade8c817f2f407a8d0e38a465acb6108d33d7685d3798e7700f80470832737b0d59cbadb046c35c874f510a57b3f3c554cb53bd6aa8b1c16b3fd959a068c7f3fc18d00a393da8c80ab70bcd041480fef433d712984e20bd241fc288c2d299231712da96d075c9c10af0d08f96a60ce8a7a4a7640adc1be6919666fe1a5b9c93d2b7ba6bf2dd2eb9e5b0d946d828550c2accd0d83f43dc763ff981839df6f045d98f6d48cc700d130529326de5cbd349e8d9d04fe28f8ecabf4b0222067e56568ed65a5559b2aea6e622e21f3ac702470dccaaf8e7b810039d15035d3721699c042f32003dc10296c6d749c179e322dc35900be289ec00a366a545529a1fa7d6ba0b2d4f89304093ef32e71ed8f573831dda0e66cd5c45c19ebc206fd81622fa9816799928f6821c4e9093e4561b4339db1dec84104816bc15beb6f326c81c96478b20be6b6f49bb4eeff366e2397c3449c2b85aab1c5f881374cd77e25c7837a91bbe72d074df9f9b0802f6d825a07378c475add695a363fc1d0f002a7bb7a0b96a9eda04d72cf5c020b136fe29b024dafa7bd2f1139c3e6fe1167313c709f50365c3c14a0afeae5646a1ec8f41d5b5acbc08b7e261b3a97171a7402c3fd64ed295772371797382c3c9a5b152cbae77b24f7a53a5fe309f505aace5b9809b543ffe5298ec3eb7ea5cdd7f1d908be68226735e11050293de6b3eb9ced1ee70a0133d89ce79893ef1fa829b9955d7ad77817ed9ad1df2565ff567e0675ef90df3633685087272cc93b510b6832a884ca58b857f76475712e2e1043c7253265d6eb43aa4642890932d7bb66770e34bba0df88c6a0f9ac31c5a2a52c0196883b770c49dcf9d819284597dc0f6f695f04d88aa5a9c5ad09c6311c8ad7631b8634eb778207545e73d13da83b2622d0f61fd72d951df9cd048e9ae7c7ebba81dd9d75a15ae8c46ea677cf451ea9e88addb36d34b217cb617b80e5639e9cda4ed2946e7d9e3971b2967beb23adcb8b70587da15687060906c2817805d149d1a05f525e5f0ee0c38f41d05bf4f0ef5ca8857ff750885553fc2e89f6a3b2b661ae37900cbc8e4da1ebb0341a3bb801d641d481d7217d586e34bbca7f2acc6a0ec12a7debbfe721d73dee6dfdd6cbbb052d82f4a8b081bd4cb960dd0f9a1533187ceed8396e12c85d2c9a2b07f1f8c8337674732cec3923f45173984c49d5a8f044b18c0fb7f4ae7c19b739b0a46a3012a65024e35fa7c4b3d75855c3493ed376b3c2c0688b7b2327d470e5cc4a7fca774b381b0414b611dbb942a3cfa68d84ba6c46865feb1f47aa8de3d07a09d37b193020f767995d38e2d65fcbaf23b03656e6560c7236ca24e58178dbaaf73177580cfea9d08fdc30e728f49d271518d3cc15094a2f62e808e9cf9f45c2299cbc5a44524674c3c818efb52d533ad2e1fda5070797cc46b5cee4a613652e4e75e5329144e9b5db55ca018d72a8be9ac4a1fdbee56ec2e9dd87a4f3f085f85a2858b922586f9a0fe908acace18ed47a522d0dbe301e5ad6a0dbd13477a0015753ba850d3a1198c5df9a665161bb4c540f564c0136413cecddd3dc8df3e3496fdcb41d72e508f0260c327ecd176b29158bf03f01ed2019d8ad2675773b2301531c4d3b87dc9d0fa3f0b951bf06b5061b81383c9333e87d560bd5f222030aa26dadaf9d1802fd3e257e24a28546691d85721f1cac21a83409d50443cae59a9310faf0c56c6fe4bf4833e54de777a2839539708ed94c1c2e3c959e0d55b9fa7c63c35ddaa662b440dcc423481b1df084ee18e94a3717e5e0d747262dd7d298011ae7cfab35360dcf0bb0968d3193708f80762d212fb66c103c4244b100ef7645ccfe021383766b65fefb9fe3a07b266388f44c033ea486780bff4d5639fe3e030e5421b2ab3a523e4b612c4838377eeadeaa8e8fefa82d38450d675eb18119abf9e811bd7c11b1ffcc9887a9a3ef41db421f70be10ca96ba1b71cd33f46fb5a226087bfcf92ab891371a2d3a3d9335e2c2012f582e5ba7e28382952fd4f0944960746cab06facde5e8863ccf622263d5e0a8488010e25b18e9ef79d3104590cee632bc6186babeab23071d9d2c0a4d6d7e98df95a403ba6b4be21beb80e318505f225b62f31bcf34b499369145793b62b61e8152280cddbc02854af9a00e09d0dbb592f30a756427e8a00cd3914ad61652a749b5761e64309693aa3e2923ac7104c88fcbe9cd6ea4f261db9c24ce7772ef7e4e9caa6aa9dbafef8f1a48ad82ddb6289c8e507a97556e0200a538a15b63deb31a15a08784e9a281656ccdc9413a1ddcd3987f1c5dacfdddb782d09ffb0c4931fb7815d2a87390c28bf148a41207c2d7711ef1ac104e18e68402f4c7200fafd73a08a123b2f07dced5443f0b09f04f90373305fbaf19db4e1b51af0cb0355f7ec69e1ef962514a59cdb8ae645431efb244b71eed56ee25beeb0404f7cb06703d92c9459680b99c8ac76e99507dc3200fbb862e58ce902027a94b183fb11e87255b370001b66c0bfec791c4d822c0c2ad23bebbf929f3547698cc502c214c0a86f66e42d07a5388c8c6efb1b1cb9a062cf5aa7dd885b1e39440824cd88e12246ff16da5742f42cb309ffa49655b96f4e3f01675895a6238a2844e4c9357f10607eeb21c4acb87f033f16146dbc79614862c12925301610fe7456258a72d26eca3366f6bf24baf555a189fc1d4cebd1eba74a2984d4f0eb09d5defefe2bb1460b36c3e4a10cd6ca35dd22d79390833313130cae6163881e4162b0940c1cf145887b3a921a5677310999c0adf127ccea","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
