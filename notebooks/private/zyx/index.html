<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b10d3cdf9bef0c1e3fd81d520c93c182cb6c31a9181eb0ae803171990ad19c837f08fc8f4067c27b06c79d337c82c9cfb2a722b45a741cd240181e67a1074ce3d6d8dbb98241f7970039f17e9eded1db258bab32d34bbfaa5b0e5e4a8165ac831172187e5aff4035954b595881c419ab47355574a81b72ee2d11292eeef762476018fe0c66732198716949dd85a1dbcb19f7cbe2dfe7ac0540c597f03dd3d29e99b6768e0f902e940e475ef4bcbd35f4279363564173d453f9509f0b8e8f36d917bf120dcbc4dff51e76314c4678b464b3efaa406214470e08ed690f1202118a2d28a4dfc914a405f21ea2b189168b58a6d80e8e1a1b78efbebb7c50ee32312d63c00e13d8859bc4484237390963186243a65839526a21f3e2e30f413b753851f6b92111b6814c508978b92f9aec37027099e8adc4a4701a3063f35f9f0c486d2876f6328cfdd4fdf50beff7ec2d5ddf0340c5d6d814edd3e3507d09ee115b284f70ab0a174f050c9fd6b56a1580bd9ba27dbf1ad87b522fedd0ba26d763476dfa17fa14da89e708853571303d2188160837dc6c6455a593c3fb0a4b9b6b2763b6570c8464e2bab1a0c1a2554634a934997b1f68fce4d84726ea0ad6c3002d1bea085768ac4289ad6a8cc7dfd74230d31892d633a9613507824450bff5de9b5ad04ffcd3b68567a25b47e79df232b04bc7bb85e73142232ea03f52dece21c7f2b69a5d1f014d82809c41028d4cbe8b541c8c4dd815abf24539dc795b703b80b17ca56fd65a55b865143835d0c769b20725d6dee02e3a19f15500f3d1ed92fe81a7c140aacabc99b9ec13f3b7ed053266b3d96cdf6f7dbd01d5274e7ecf086d5e3753b3c2f98e2b1d79974f3276d2335da207cba5e3f0b6831e38c7e69c8ead9f0dc4960be06ff26f52b697d2db60f35339a416c8347040654d64a9371d4f594bc25ca69a6009b9a91fa9fb1438b5cf9206edceb10e0f75d51131aa35a937e47e021702d37a62c1f26d511cf762bc28cc5123c5a8453ff926541069386f13f6dc2abb3ddb5982f64e0103e5de9a6576b71e293db9a7ec96af2ba0bdb0d46ac6a3671b9c8ef784f01413a9a14a0716eccb7446de3e9ad789298c29bebd83d28e589be53ab16d863c17db3b4f97b0503085d6fc98d42d3c9ec38554d42111f05cbe0cb9ee6a6865d70e2cd03229b0f8fe1e5f1d3b01d6c3a6fbb1140ca3e76f06c11f1332d70518f63445440ac1c068a81a39b151dd7099d9f9d67118a0e7121475f250653235ac480e2a6afaebfb65da21ae19deed14bc526fad31ffa4a04d344f58df412f40d6ad7a302b417c7f07a197359ca25557a295f7607d0471ecbb38ae0f02671fb80837022788d93f4848e27e88960610fbf475b4b91627d629dcbdce6d51da2cf2adaae37cb8f36b3231c07aadf61fdebf4a4c3af7bebbd5a965e6a7da25f6b782b20d26b95aedef371f23106607c8702de70eb004337fae8026ed272c118d3d3ca8d6caad1fd86ee4010498b4ebbb53f6ed8341bea0a0ab4acd5af032e16600552363935e679c4e6249c013be5de32c0c685a754136b48240b75c37c60db6d2cfc3b44c6f985e66956dc269822b379fdc83180fbd6feae574f1cee91ecfb32f340f3d7a3208c67887ffad6215962aba208cfe44f184f4f4372cf29a326a6bcca0e114bcc22153b64b143493955a8cbf8dba3acf8eb7add7c083a409d6567cf51076739b0dda6dd7b1e24ecc19d2e584eef5d9152e2ccebec4edf6c6bbe612680a87fb92c8c8ba0294863068584b818a6731b6356fcd9f805cbabc32cba183931f774ebcfafb9e223d4b5483bb4f961bb9d227dd751daa78012e943893ff1f367183f84ec0479400c4aa30c418852c5f1887489a53eb2869ae9027954b78adde754475978cd7ef9011473d71be8a9b351194305789d4c2f8b61f6da7a0cdd3213981a4cede81f083d96d519ad9e37505181f34e3f3e068c1a87f3431c09880ef9dbdc7904b66c6d682e837d9e3272528072d3ed91271b502103233b0db629a2d90eea89bb8f45d20213ed0ec179df1c1595e699f3f00c819f001dadf34a89b1afb3630ed6725826dbf311d805c7392dae7b7133710f96221819b623c1dd8916e7fa7233ef53fcdeb8f0ab944b94e7ad7d735f7a84a79259ec77bb414a7977950c85b54dc2aa6d5defe9e4e07544db4940ce1f9128d00f1e9134646054ea3e5602e981dc0a6efb045582180ac1d49be335cba59aac3c6e1788d08f6c3aa0f992303a02d020a49911da457936906b3e5f95d7363a7fc8f3a2b136ed686a15670e45a550fc20d700123b3e36101344d3544f7976defa11608d2e2d763ea39e5197e137a0c0d9c3635ab75d6d64730d81f35edad27eb109e78f1c43a2efdaec58a448999ee027d50ed58ef9cfe672d7e0921ef779bba8cc69a29b0e7761e00dac00da04afcbbe92b3c3ce838f5b275205a94b31e2cd9ef3a75fd52e5e0dafdb3e13bcf267655a9a39bd73c26daccfdade405de143384964ea093f5159e83fca4b81a8bde3d6c356783fd6325c666f8a82e9313d8302b4a9b137371604dcade856316eb4b0d2889aef5a57dd34784c8cafe02d51817286c50a4c96fe75bcf7594cb254ee85ca9e9994b789959c46dded81f444bcb14bee51f82fb9bfdfe5265e4a576275cbfdd902c3cf172b5fcb2dce519b918afff01bb1e01830871170c6ed06eefce70d10ff2fe36ad17bf371a9ee17e2830373315739429b88bd1f7774ef6f97e4d8251103f67cecf6b0604bb2538cbaa8cf33d65f81ee5f5d7b991d00a2136cee02c9aaa5a6dba954b81030a4959b4d7987b981bb067162f69c0792c4a9c0862466e0b562b1deb679cf4b08de6925ca3c2b53352383c6a5846f6a4f13ec84d9b6d16f90ce4307f30ea100afc8e92a3d4ceefb84c78a78d86015589513b437b8d4678259be3536f578a6569ef9890068d452509e935aabd29f7b57ebb8b6dbe133424b25cbfacdc96df5a0e515c27b751ff965f5defa0ef4740d66b4c290fcdf3a0120c18514d058e49f3502dba2d1fc3dc7de830b4866f1d1132c06bbd8257f3d4959bb47d6329e054d3d4b7859df56fb653d8e742ee8986c4538f1c94b2b6dc0579a752e8bfea5dfe2f0868e67b80de67ac706e040a66bb4fef0c73e68e2d3a642025872bb8472dfbd9edc6d2dd022cd44ace10f1e9d070e98363e74eca5b9b97d431456d118fa78e4eedf7942b697b5f8c6ae0bfeeb1771fc323ed5df7d402ebe6936322307e284594a6aa2a17b07ce4ce3c4081cb40285212072548dec8c0d16939be33202d8cd6916dd03dbb311dd86734e90d9d2653be32f7d93641940f97bb9d5428555aa5a2f6eb3eb82d6066e02cc1c4d62350f4b5c34e954d0274df85d3aebbeef69a677d6739dda2d5ea73e22490df4bb0bb6db178bc914e34171f4b6b47089d7c1f2cf2eb86497bba89a6dd62927adbcc1d84d5577751a70056638ace6aee2a2181bf49f2328d5f3a319d6b6a49b7567b12e73cda5780c08fa839de8ea4fa8239aa149fe267e9cf246baa254f0ab388bd1faba829e2371939edc8cc266800f37be3e6035a007a63bbf38100f20ce2598f05acc1a70c35584880093185702e289657ab5427f0f402b22afc851a0023b2109ae94729a000887bc38232f86166aa5ba563194fcb0bc320b2b98059706d97a8dc5bc0f02174692ea03e12703dfe27c79ca1b493c01b5871edb75b16c613f2ca77aa0370166f8d23e0d6deea495e01e249e6c8b1b259cea4dd44343e15042064469810cf39043301943a37d3b6ee8a9f796d17a69066a0ee421ff25237489f75e93b1c27c2b7e882322d2a482ec1873fc7455eccacbd8a6e17bcf376c281da928f7f94241f8f40f81025e234204dc8d32c4733a88b53ab72b669d76f7cef22430edc97f2ccb43aa20c3fabe5a4a8bb18bdf732f03810fe12345b72edfe2b662e8bab9b19658572098ccb34b25d12af4cc8c7cb2d44834d777ae2e786d3304619ada4b5670221976c9619e9d1af1fefe65367fa2733c408af9c18ef7fb84cc79c6439539101ac667777f1b9e20e69c411962de27e62bfbdafd46be562c2c23118cfaccd1d90229412a3d7a8a794d9f4e7f51b4cc26921c316b979ec91ffff388d6d35a656a0fc9315871af043c397cb8c4e342f154f27bc693c8040936d81d89ed718de269cdd055c650d17886bd520048d13c18049390dd01e7894b8a05b81064d641b6035f6dfd9112b897c786abcdb84caaed762c12468d0e361dbcc1f6f695493b5f9e42ae03f1f5d19879271a9b829db64bd0ff0761243efaf7311dc73e0360dfc6a26ab45e452ce023652d2627d3cce838a0c54dd92de5c05334faa7c26d576379c532e8dd9b3e4310d33e2fab9f13832e83cec50c90bc507d1d7ab1abdf7c36975fd600ed2e9b2173cf5a1d386f320ab48010b65ff2911ca9a80482029904775232d8ac59a1886a563dbb57b76687ac0698c76accbede29c151b6e6ac965df518a7516bd3ad6bc316793829c0181cbab20dea8d0f986b9d172099bfac28317663c89bf5e32d322cbfadf830cabc6376e5acaf810b20e013c458d16d999ec3f945d2a2b17a563fdfa1ef507992c36c60bd56e559a89b22b30dc6adcdce97e28a0f1cf4bcafa839c9dcb24e0afd5eaabe19c03dbd03cb7b715230f7a6024a83a47056bb3e73ae190b1bd7302cf53486e2912f9b7b14ccaa775feea240237148bb62d73f9af301eac05317810e1633bd36ff5bd662182b0ee6e464ea7a3e59ffd8e04a1e593083069dae92529023bcfaec0cbb1dec4bcab56d966e246852862e1aeb2320923ae07545ac0d903cf077b89f2d5922be37322b9174727363d91056c31eaf0a1c7ad090dbe95a9cc7bc53a26307c44302122958d23fa0a72e8cb37199055b6fee5edc0794a5b1bf8db376f19732b8ffec089c18e55b56178587ec0e7ba6c8f651e163efa88110a9a843b0ec49946bbc10e64ccb9b7057e6c5fd0ac7ae224e38a21bb269fb295a7076870534675926454f7592867d2dceab44082e1073663395937f249370172d141a7116b6528a778be313e508ce2c125cafd67387073ac83258c7c552d4a1fb3e4a600a8ad9b815213e0c5d6a7acaf2a07ffe7a887117a602f2de29f621c8297630940d9da0d7d816327273690e48109805e430d4b5557740accd5836554cca6cc4e11a4907bff25cb0e776ecf749c7537c726b38e6e9b4e5581eb521a9f5de87f2645e081d7211b4ce27ecd481b85bbfb7bb8ffb18c4f67ecc2f2ac636eafb5fe2acbb219797bfa4f6a8a2006efaf4ba812d4eb59fcd48d4a009ca10cf531417ab004a9438ac17da39a1a49a54b10d747e2816fbec9f3685230b95c9df04f2d5ddde785813ed795301bb9835874e0e5c0fea56d7db3279f2767f800601bf330ede7adba068aed0b0d9e344a4ade9e58ee615f252a87fcd131cca2bb2c37aaf07fffa0fb47ee5f9e619bfb87f5ec349eb3100132d595d837ee72c29d1782d9bfbc4b374250968a13cbcf7eb526f2bff8bcc8e64dcd48adf51919024f33890db8582e017f6f8a67cee3162dfe03b9b2ed968c49e457d6c10420fe8446842f8d696faa3776520cc0c9a5e26cc0117cc4937ab780fd2a424cc7f533d214dab1a79cadaa9dfa786d5d70febb96e305affd921bbd60728f52fd6497449d63239e9483a40572992befb634d3ce3635ccde2d12cf7f830087b3166ed62179d17b1eca6e34720dfc56a5c42a7f173d6ae3714e370c251ea97ee7cd710566424ddbfe09331e1b60db92032ee4a2eac69bdd75353b13b805e148f6f92fc9921955d66208878f9a3ef27b23b7074901ac0285f1d26558680ab3da5279d85b80fffac98df3e0b16bfb5d7faecebe2c0e221ad00eaedabf4721fb09fb840932f5504df6bf63fb4fe11c7e0f99b8eac48b720cf7fce6fb5175aa3413676c9bdcdbe4e2df7d5ef0baf19fbe560600a2e49b1b0f91de4cce91c332e5e565d389a92e382b83c587c4cd887b2c3fd1f75ef7b62553162b17c2047db049872a8196525753b3cd3c4d3a4f8fefad6cbc89abd1eb0a99e5ff248eafead9e9e664e02276e53578e7a0166201ae13f6bf859a880658252834fbe6840580a2fe51f3f2d91661b2322e30410994dd083638d4e12a0ea07fe73aa6acca3629cf5d1bba283743f7a23c9572807b3cbda0d97d01fc0baa2fdc71ac27a281abad2692b45578b3308018226b24ccaab894789f9970ae9359050094d1fe1500744f11e35197107cf4939e22ffe9e004708d247dc180ede4bd13ab172a85573f608c9c65a72a37111ff224fa2765b495c58506a9aa26b6e9ebd50d5c69697c70e2da222acf2fd851883362439d7864b4ebe515a21e11809bdb18f41cc0e5b136b563f10c7dec29251a335bd8eb762dccec0ec49e84ffab08b16b32b35d73d5965c7b806f079c9dee76af71644025cf2d015d06dace8b276bcce3749c8b67facb674fdc2a24dd7ec36ab77534dce4a7fbee4e7c3febcdcc99810c29fb0d014a3273976c1d0e1785a84a15af05d1758662d888649f9b7dde5ac26fa22ff7c073ff3a31ddf457a4895e971633aad7daa312948cfb021b8b22661cf6c3f4730ff69cec699990214aeef91b0edd26919ef14a31e8e6c4ac2f73ad53f5918d7dda63a70a644f0c2e2cb3ae3940c6716503e3cb67b9122c9a7fd37f015bd767a4bc6c937b33ee8cc7a3e3b6f40aaf56e00a406e44f02240a168d6df1349e3dc6dbb6362f391e2dda3b2e792fd0f296221449d827b7731a771e97593bf9bd0df627a6509f35ea441fcc32f224a7500a53e888847a9982140d1c81ecbaf24e583ad8afff80219b033a2171f05ae58df1635253dcbf07530eb31586609f7fe214de3e7c72ec7c279170f0d292e7c0a6c99e7f66f1d8c6a69a34a18512ce9bb809af079f19102d3bc00f1a1f094f217b5c55e7151c56244fae6e384b2787a381f0cfd29cd4b293e142144ecc618499b76418236495a4c6da4588c99338f538ae6d9ad01988fbffbff16c5d68ba11d9972fa09d7f5be3b12ed98d0b92e493f387dc7b7bb01450df75bc1d06a18301868f30a5df3bffa96a3cedee55c2a0c0a66287057ab55caecd54b806441a256f97ea8886496e5eaaee970ac1ac29c2aa1d39a3aefa508a4c57bf9c07dcc7fd46862a16d15dbdf48c7ef03e2fcc006b41325d401ad250709729c3788b874c434962d8427d22475630e3041301450d3070e6ad7e20f316224b678ac1c4304426b4cc67a8c0bccce3086c2fabcc06ace603de28661858e2e6ba617f60fae80855cc502286ad5884d64e0b8bd643edd78e599db04e77eef1b6029873e84b99fb3f3cae2765144b8d29653b465ff6f09d11d9ef2877d563109dd0852ab4ee5b697fb4b0050e0bd7c6a4a7705f47cd5e2199936b347a3a580aca56a1cbb4b44abee765917ec51f6020a4468e4b8f10a9a3e72c0db449989ee70e8f0a3f86874b6528fae98542baebe20b7a39e14d8805f525d9f17b6b17b3fcbea1f003315040f4ea334d6a6a1ec9c2814138142e5fd8ca23552807c30408b34462c7b7656b7d2227e37aa85821ff654701ed93172fe0ba77b9b139353351968738f64d5bf529b2aaf6b189c05b98badd601859fcdfcc5636b81a6cc7d926c10a08f0f023ddef28d0991fb7d0e22623b32132526e97318d5d5c10f0e74c1f471b954e69a35e9fdad450f3612172a37872910cfc519768073b2b8477942213ffa3fb11bfe23b245bf6c32fc102afe52c3932f088b231dd9be675c3287ed87433d5b80163baa5aca5e1a0ecd306b83a2e31d01dde3cb20c39f72d21c05853cae25b7cdb083d8c219ad761a9921a7cfb64e90e0a1a39f9a4e2a94b553a48eef4fdd02f589437d4a50e7a3caab0b3e6fecc944b7200bb37502a8b097fcdc78ea929eb200c511a4f5b7fbbd13c7c65baccaeacd48d378c69fabebcd0cc990f15e8d38debfc14d1bc4eb8d0a90ca163dc4fdc3a49d0dbeb22a88aa69676a9328e313502d0ac039915736de6399b950c8230b17611325af8f52d9c019432010582f696c0f77cf72cb084d6e4dabc2d938292ed56d72e989f9df715b84c2292059cce5de829d7a17e3871a5e7c06c9e9c36513db0dabc3cd3db3dee105df9ae2cff3f10786c4f4bd3d46536b5958aa8784802a1fa7ebfa33a2955b2a2405d861583cb48491b8f70d967d43f136c119aa793709b3eea2d7e40e6f5b7674b6b299c6b66f6187e5ef5d1a78098f22cb65710990fe7016d23f59d0089478f5fe48cb5d9489305d034948f1b7b44d6090e5492cab2cd0c69a31de336e3beb90a98f5b35b72c5870073889513cb7fcdf10ecba1513ff061c82c8a8f650beb485bc343840fde44d4a1b03240d89cb63e5fdfab9a1596bc24323b6094a518e0e7caba3fe74fd279bc5c9248c7e01b9626635f61bc7a26a534ac34887a318c65816e0abfca37eeb9b838770dc76ca64f5d55acc939d879afe2423088f75636a9c0f17d9d3f6acb5df6bfc925d7eeb05c32307510dd54fb6c4a5fd8cf896759c9ad6fe29a7974ec4769b7411656b028b5eb9ca3c8d6fc285d2ced343aac75cbffe0c951bff21a7a4b397a657f175cd9bea6d3a82986275d32ac257d0b02081a40899fc617b27433a8629938db9d7f81d6118cec3a3a0bef546c5d411c4db99b16d9ed246c3f07a7c843c219fc407381e57bf5f26c60a0d8b742282fafc590c9b5b4a2f1cf0b5bc8dd93ac7e5420352401232497a227152111366280b9ebbc5df4831d8427cececa62335a05e220518b2dd1dfb68491fe8b4a9471b41d85927db608744bc65b55deddee47d9c33983703fef0ba2735560c478ecba1daab892eaa7ccec2e16bc43c4b086f2ec1e77e5d5cd249065377f498933540430470acd70b04cd0acaeb085eae4d4631ad28acc06f0d5268fc41749b791251cda7c7cfc7726a4b9d264980bb8383c58d77c54b4dff4246d794ff6270423b438013a06579f98415861c6d0ec9461505bdcd135ae1bc3bd55b443e8b13a3d46bed9354d75c58bb0bff69ac8c08eca09c9f700db006b6dfff065b99bafa16d0cf39a6bea0dcea67911e58139302fc829e53ec94817188c3391084924fac949bdd0f33977cf49d9b1248eb4b52701723a55a1c595e867e9a9cc64d1562fdfec9fc28701ab974f58c924f3f0099b361179a5919ed0a364bdaa48ae95c2e0ab62faa9f5f8055c9c3c684c0fa0dbac3f9e9aebe2cf27c4d21d858a2d2eaad51b8ed855c10006b53c36ab7ad9620562b06ac0a438ad18f9b4f59064e0b6ce6a2a795b86815a26a0223130eb89f10a5ca411e1772579341ef0849fadb6621fbb5e6a42e95fa2f159110f43fd652620d41eebea9bf762e9092023a1ddbd2ceb5cd5793944272ec2b83f07c913369649329f0d85c460502281e2984b9af6c9e684136387089b7136f6ed1de3a4ba83c1b0f99075e20893789074cf74c86c4c264fb911716eb927822686a06b2e304756f02bcfda3f4a3ae3ee204980d61cb335bc062b588482098dfba0192831471f84d9a78b947dd6ca9254d4d94a6f31a549a2f3f91a8671aa002e5fc6ee0258553a55874193626efc71b403d6a1c150c312a36bc4cd8698c8635a99992890f9ebb1b5d774b9a5430b279db5b0362e99dd3a838cec31224935cf3d01ef3b099edadf67b4651e751d0fc84b790481a639c0728c11f921bc7e42e75b7b8f5be6fe87afe01497387ade13cfbe52f58a1de80560f24b607bd1bdd13026ddb74916dfddde7c1368d55a1c69b0b28e0978aae0b635a35cbd0fbae0b368e2291d57ec569bc83ea87099ee7b73512aaa1dcf5e4d3b6b295e84362248a7be47283699d30111ffdeec88508631326138e1099736318ee182a4542b22041da6b29895a3e5cdb1a8de21648819b12405ecc0fe48610a48513e50348cf19bc797f832e568a1e30fa3133ff88464e074988203ce4a3e10b9566fe38ad0c290aedac71e3940b264a343b0ae738f42711235a5972ed19c6fd4928bf4214080d730d11aa2326e1d690e65d0fb822a47294bd3ea6bae6a6acb3eaa0806a90b073150047f16c8cec012f9dc98344cf92d5ae95421e9f4166eb62b7452a1a70c533eed789b5f082240290016e1f9225b94ca7d0c1043e026b5641146ec1928121cd88b3c183face6f1fb3ac5db17267aae01e49e64dab9e9ff851e92b2006c9ef838ac0b897bc06db306e8f4200c230472672d8dc449ded835d0bbe5fe8e6327d004d9f2c38d8a0b29c8c867550e4d66e0b1946b833dfa283c9c511a3eb9bf1fe4eb2eb2d8dd0a13c974530ec851f5c9ec10be2ca16ca9018fc962d39b84f1aab92f7f5d3b4c1b752e6e3f26ffa9f07ec4d618f989dfcca8205108e9ecb2bd781f724aa994f2818a0027f097141249f8cf925276ed0c92f91704a1efcae83c8a296bc2380328240dbd805a3205df071f8befdd3fddba7221642ff960901ae7d4c8da003852aae62a9bfa94ee37b537d7dc4cc4a90ad7ea4e1e8a0f30a6c784fb668c95975e991f4fb3f79b2b55635d7b753c8b511b76617b05961907339a8d9b9d56850399333377076309655b46de542a4da97c67454f0258a6978215d426383e4e9ff30d279e612abe17764e9d8476225fef751c56efae759b018cfd08e4770d855f89b5bbe142e340b73d25375104988233c6edb30ae5dddefe5c2c390dcacaf38058fc00825612b46978c4f74b4107686ab98f0da2b0362afc29247d0fccd9cd80828d018acf75b13e12edd579726563882a7f7d0d0a8612cf5731b0c46af1b14ce419a25d6435a2c2fbba326c3fd27d892aa889c14a389683c5a281cb24cbd32f184f326a56002b8e315c08f633ab7d6aaf88219498144424db1f0e673a57ea56777bc9d02b626b8f4d4e76d9306dadc00e9db0ac7b2c8644149bed135b4b237b41f7243b0ebe4011274656865dcc59c2e6797522cf552f61c608fdbda0543e335130757afa21fe782589d7b10867994d2c136a0a6d07e5502a59645743d909da5d8804a540eb063284c1f5a71582fff4ca31a6e38a93ccc258e43d619101e9c348630e465642db799a2bd0fa4bece5e35cfa5b166134d18944f825d3e880fbc898520dde1f768acb499e619864b7d722c9305887daa03ff89e532e7ce0026c3ebc4bc2c6fcdd9433efd671d74a7fec0fb45b3cb70a5f7d6af014154daddf42ac68940ef8fc131905e81fc49b6ef2ede9428867d41984ea05099936787afd7f84dbce95847cbd5fcd0a69292ed25b8a5b9545a19acea6fd6d9095b6964dd1503f210fe700db50073aaa1588fe92768eb078460dd8c56bf37501e9b0b4cd482089dd369312250a7cdefc92ae34b34699e9042f966e0fcce204b9011e22866bd70cfec7309acc42a578e84063a23dfb17c8302edc9d7cc881ca7d66f0ff2397092f52a2740463b531c09f46d231a119e409db57282251984df478dcde3c179fd4291e4b863fec33c262153edb45d69f522622379550ef50bc076de1ea1d14778bf8397d68d35b9fa7200c4a9a94330cb86ae107d27ff7b37ae389f5a1e684876f88c187849fe49cd3edd40157acfb3eadeeceae670303fcec0c64bb091e975d2cb0518fe2a9c99b81d42627f76107b6a54a78cdf0c465660fb21195dd41c750883e214a9e35f64b01f56f07a39a4d6907e6b6445d18d06f38eb264c066436372ff4a0d874b258efbbabe558d8a5df084e663ccb1b74f08a3301e24b75ad06fe1bb8902fd81b2d764e788ba82f2c4cde883ece4e47a3497c43344d06601beb2fd04a0a0793802a571680d93c91fc0b05705d15bdf6435345d358867a70d972e82777026898ecf326296ff93319548a1cf3c4e8c6d8e10f4bf60413a7751988c7580ad8d95534108a308fd440a4dc68ad0dde61cced37106e207b5f9879ee4b3c41782447d9fd3abea761939be5efca46297ab8a1938d3c503bf4b322f31047071666df4202e76a76ce0a47f1af9d136bfc750c95377d76b87d2516dd4abc40ade7fdba658f6d20450c3e991a452c953bd79eae21cc6dec399231cc1e32e5bee67c842a4e857db3af69ad505975bebb3ade067b2d1b5fccde1eff544153423dda60cf8101b97107093ca073cc4b3a7f141ccb2cd1fae9bb35779729f06b7c77df087604148e84a3fb94e81bc970348cdc6f795dcfa0a7fe04e47c0c0e5b806854c527685073b22aa78104c43c34c5e048992e4299ddcfddc8c683d80d0a388bdd843261e63fdac53ee6b96a8dae86428c9e4514b882df26898a1e49a6961dc9cc5c4a61be9ed2190fa78362f20e3fa0e88a793a70073505c1fb14c4799f9a7bdf0e0d992a39837e58d4cc8e335dc445657de84e90475a7dd8a71463f889190bcde063fbc97e014c5e5a52bebba0cbc2fdbab7a20c1b0bb6108d95a05533c5d51e1df2848a4e61962870b14152d2ca852b4d7c550c2e5d274e1d44fd35d7519cad9c5f2e650a362892d9f77d3d116fe3af928e1927deaf5dfa790c0d4518f7552461ed8d3a6516966c4722f3cacfce4a51611b2664ee73eb348a700e9e79a8cf4e35cb9b63e53986a79c0bdaf7c43f73ae7508c4dd4137674b25941290edb553f14e0d7b00af92db0d329493dcbef9d4c6ef061532fd7c40ae9d46a82c9a08d487e3c03ed565a1586b16636d4d97b9f155d12002a7fb5afe88e0378233536dc01f8f29c9968e6b0895fc5ea7ae7f7584732807ff548ba41f048dee9e673cdc9cc438a451f7627b301eb219de149b2e642591be36b4d3f2f63d6ccb26e955cc98242d1da4f1edc165f041a3c52cc85348a530e4196586f7f7469611a71b718a383704120e261b7263f464a52e40c52e8023dbdf29ae385bf77380539a60f1325b4a16d68e903f9898a01af982210a6170b86fb925ee8f040c16446ea11a633c019b1b581b3759b3fced4004efa2616333ccd1a93c0eab35a9c180bf0878188c530cd54508bdba151d6a9fa6369cdc0af721e3d9fe3037b1d7c0fc5a8bd0ea368d6b0067e259414ec0bcf01fcbbcb19a176a5c12cf85f29f19ac67062ec1e3a3118f04d13db88428dce06cf26fc24aef274c426a504be528e00436ad85cd7487c5a0bc0b5dc3b66f08d5d4a4b17334c0178aa486aa8f6ab75882bba3a7daf5fbaf23012214d93d7bfbb7f5ee8f3779b219be8de576fa125ce879195f72db507df43e5e4de694314db9d7cee2d90231f0102219d97f61b91568b8ef5a2b7be565e79c7d7b4e5bd636c90dd8e921a34ffffc5a0d95b454c87c6c882df11a711060b7a505f4e8ed9bcc41b34e962706c1b87f6270816ff46e7d443ccf2a72d773eb2c04029c8a72ce2ee9dae69e403ecbaeb40d7ab090fe250c9df7b944519568fdfc395ef696cea8a490d4a12431d139643ece7e37942518466033eb72197e1aa9f06065b5cd6a8050dd412a0ea45206c11580bb073973efd4ac4962d8450d05442bc5abdc3999ac650fa4599c06f10eed8e41aa88f151734068968da7fee69e47ae831f5c5f82e03760a53946f60d7d51f5af6b677638cebf7e243671946cbe6e9337a1cb6222176eeb3215f649aaf648a975107ddab82a087630b5e0f11a8d68d436768350c4a53d1d07d03b61d312656f21e95e32d93ca45a2812fd0d1301b0319bfabf45707fa3d6404d7266bf2d30215f9bfdc461713f0ff6a0cf2e86ca7d1a3e12b8df914d1981ef01576b23c55ea3169bae766fbf942f00480cec32c8a9103cb8630f6ba3cc8db4faa0946d10159621473fa3e239369922e3ce0bd5616454960b0a0d2fe949471bf1d10339daad13a8861ebfa38a18276dbb8c1a3026d1ece58e9869bf0cd1aae3e2d6c45d83dd9b6318dbba71929c917033d95b2a6994541991f9447c1ce1db8082eb95007cecac10d7ac96b46c302cea9593594e2d0fade518f69272a6040ff988561d6d56f96fa5372fce857a6e800ce87f694663c02c7d65a7f3ce64a475ae229ed245f80de43c3de67ecbfd66ef4c98f5dc7100a43fe39c1c6db89e81646f9ff8a7a84f90a1c2e3b106ca19dfddcc335cf965e621932668c719bcc54b68f65b4850be2da19cbb598801bf34739c37cd58fedd998cee286e4525c10c071baa6d8a3c3ee054bd9addbc9aa69ebda2bc61f125c99a570b8c824829f43e0ff8224f7c2cfe7721976603feaeb963fd778e9219f24e782c3bb87e84f71efbd326837a300150f76839eda502226a3517032c5d83ef99fff671cf624c1815383848e40108e3253ff01344edf95b500ffde0daef7baa195d24a86c6c56756cbbffb9bb3949a84a6e20e34e94e3866e5648044bae2c104e2d31fb635a7f84deeba824c487d9e0bcf243892d428a4a1a9fe24c172703cfe7e941014b7fa1284b80162a0e2b5d7505e0006f6071df11f35e71bc73a48d6e0575819a47326203fb1d95f550482d3878cc54b967d28bb4a4c90284acee196d7837aff0f966d899ea7fe0492849f76eb79a459a9f9ded7273881cf72d442037de903a39e3fea4fc3d9041967381d28662eab6a80468e13461aa6003f1c8cecc639eb65516dfadacb9f8703d6bcf67752ddc92a59d384043dc361da15ae22536aa7907952c1155db572c99e4db6ed410ba2764ebd014382c79ae50fc5622c2b1d42f6091ea468476088c410fa807bc692cb84e2ca645bd47425b594345dd934465837ba5076b94e4baf797f8c7a976fa5f8d458e00375de910abad6f032dada9e7557afcca9a635273c99704968e312e172157005332f0e75536b7f0c25c93e52876448c4637c52c0111b9ad998646dc1bb619e079f27d05084206d8d2c390c6b325395094f3ffd6d0cd62b578d2f59a462a037a3cb68f1e3bddad0979bc3d5e59767e8d4b3db2126619ed3951809b9379019deec15504f67064a81faeae723c958dc10627083d21a2bc53d447f4089ce08c9d884948180fdb9d3911e43bb2867fa072baee798e32aefbf5ae20d7123ecc69e0bca0743fe8fad72978345f58a76ba45002c1adad824cae30aa8721a690cf7d5b6f2fac09181ceacb34e21654f59cbade18e16b1cb9b08d1e5f6e4c5bef0bf2fc8e2a78e8a4c6c8c8a779e62d219bbca0bdd2c2e1566df8159a536f748360f21b656f78e46740220734777408ef1a2eb6744134cd5e623206aec5a457718f5affd4a20af7c63a119b55d14efa7e48d48f4231127aa0625995783851ed364736153e8f887f71c7bcbdd283be00635f112d5337a1a4f44ee2c6cceeb74dda874ad22c55e301ce235def70cbc1c6693322a3fe1190baedbe829b7e5719a26678094ce5d2411722f7e0d546429282346878a8ef605100fd36c6a4a65fea8a94f9e05f3b38559c1980d98e6884319a25f77970b752b5ec974a5586e0d1218b9f6fabd99437d10f64ca5b7a0335c4b00e6a36f0d285aea80f102ea013b95897d478351097c7fd9e3359f4aab24901a938389e326018baa093f5cd3082cdb6a8726785104729aab758d0250ba866fc8a8bdf2849ea48c3606d88279f135c17e2d1322a208bc2299c280fc8b7c5fd12a484341bd398803117505463f9311c03ee47cc2cde336a0d572b3e4ba7eac5228358ad6c0d06849e4b0135bbd47abe199b825d79e872d959310d869b8e4434a214ed21b12be20e17590cc2657d4cfbeea2fd4ac39015cc87b0a3042ad3eb07e9a2d558baf92cb9fa24951d5496bd7caed2f6cccae34c9d41c93112dd48bbe70e9ab704c5dbbb0de4205d63c8ecc0f4e650ee8bb42c1e5bcd3df511cb37a08c766487b78c2bd714ed16f1031477ff87e5ea1028fbef8f1110c711d7597d9c9448e18b469c8c666964080008ecd7647839bd7383f08f56532b90fa1a20994910223c2796aba33aa22564e353b8c9261274c663924cdacb3e6fbf08978fb14a26eeda2b79a33506acd15f5acc80c271e076a3c78d6446342ab13801913940f07e46e43269c46de4fc1aea9883e537a70b3a631efcc11870e38b2fbb656f2385fee7e3819c97c0d5aba7d73bc4b3efd4db09ed76fc05c1be487d07843b71df3408dacb0d23a7de034474d8b1ce9081d1cafc77230b66e690740cdfccc7506a758246983366081ac47ed7cc1aabaa464e069c2f79c243433596e9907219af955ef5e4017b9647446ca30e418ab5b290d26491e63029de1e132990a6513a8a4d8cff23b0cdd5c2198429e0542d73c458ac6579c2cd5e8d89d7922b188c1d545380b1fda0da15c8731199839bb71ffed0a9036bee0d83d5dd1101c937f6ff87c9243aee7c8e4c0fd3bd64a5048e70fb9007c149f8b891a07ea29ee93c48d0f0254d2346c1b83c6ef459a681eed5dac2251609a4f59c56d3b78b37b837478b0ffb84367b3569de2bb2c25b01950cde2a802d6888eb8fc611807826b038b0807e0a7697832aca4553b42edff926ccada7870ad8ad8468d4952631cde3f54e9382403c9cd3dfb3f379700a3f779546f22e138636ac9b9f4ac527bed8eac515c6c8592afc9c987ba79e0a4ee4411c353fb8b0795ea436836a9304343fca4d443f35177bad245b20d4f4d11acfb29c94a3951dd20b8efa2a83f6bc568ecef211499722952a8861bf787c4d5d8cbb36f10de83e0a09857620591f6866af0eb32b81235a2392ee658a5de57b59c590d23d48063d90da4c623c570152b9c5aec028ca524b71ec701dbb75b08a5a5e834631e604933c809806025bdd418d1a9889f704c1b4dcf23a00f7e0bc3d79d5e25075df90a0100a5492b942b1eb8228cc43e1a956ec25c78940faf145fcdd6d063e5a72819b4b987e2bcb7414ccf87e828f4e70cc3c27d5fe42c814f3dc38fa814530b75c63829d2863b06ae3c38393f5365f6e09054d583ffaa841b58aba2582e16e3edfdfc076b19223f3da04f2cd9d6a9714ac896354da484731417a8c36e1ffe9bf8210f050afefc185e31bd708d2031c616d5425ebd6767c4d2222c4c746aaa0d8e7f153a954680d7172e9514d3cdc8e7d44a0f6577969107e876c0b8573dbabab62adceb7bc3822e9d95c67fe550c8b7f01e3bb3ec3e5a265f8290733167b2585292f9b80de7e3a68ee1f66a70ebd6d417c472edce1b50ac5572c9f4f94ef0b18b6bf0a0a643c33adef44a7a2eea1274393d995044a278a852e087aea6baeb52eab5df16e57acb01175ff305bc1ee692cdc7478ad49845f00b9e352360a441b17c2e9fdf64ab6cdb3b9e6f951ff84492b9ef2d116b04c51e398216a0f5df9014b096a0558d926c639d2ee2685f606576fcb1a69a2780a70e9226489fe0861c61b9fe01832f8674fd92f50ae93849b1defb311b5f3374c22c800a02ffa785b1801597d0e119714730be220608fa2486dea144f3b679a9a2f4af85a863b1460b06ba828e88b98698dc1ff25beaf1f74b2f614bc0636a29711d9b5bb2f06351a4bf447f24142a423fca672abf589612993dac0688ccdb7e2cf2e522b0a2712e912fd26a383cf8312d24ae0aa19b7b1da8834dc7cba6c9ee15786832e8ee607b28358fe6a713182e485d02978e1f9f5b2cce664442056a047b458e4886fbd5868df134062b83cec0d49af39e571c9ef666a0e63be911ec421a2487f9837c1d5a03e86c24c21ea9f0f8136ddcdf2a5db9fa59dc577719c7d0e050199d3dcf0c70da7576b168b1f2b30a1e7d82be611030711fa1a787336202b4748495d68756f4271717d141082a7594fe39418e308da3d76b48111c6c520a8f28e72f4b3eceab4b5397330d688da8df2ee233be3a557f46570073d2bc1e6bb440f1b2133b305aaafc91677ce7a3307e565a744e94fa01a6b334b736b3c47721420826a2fd8f3029a37319fc825f8dae0af7f21671bb0875776b3fd03ff8fad1437c2acd49f20cc52b1436d960da6966ccd96e41d8a4bc1aa7b4ec25afc4420ff9b71030b3c7eb6d05a5e343829ff415d112f754ecec85e7b043105f799cfaf17c391486e1157e3e7b79336c9988d5881c9dd386f9f75d5bfb2a8dfeb5671f155caf0c32a7ac578635b6930f4ed83926a86e076049e3dfd6e28f65513354e37191bf295a950615d80c7a9dafda480cbd09c130c91d72a7026606ff13b547e0bac96e46db57f5ef3e30ce47cfd201a2612053c1c7634a8910e66e8bb159f0cca6f3a58c55644ea64511d6dc28063d582b714ac4837451027a6c237627bf73f1ee441d92e4601a9678a277908d5f472adc1fc950c3ec5d7043ffd4e5c6550981304fad4a2a674b5c81c8bf99c1f2406ad5b21264b31d331b3445ee92f537de03243f35127f6e503824e9d603f63936feb04d0ee960125f545d5be567dcece6a53f2be7af85d3813b08788b881b8ee3a746d78f3bb0938bd9e4d94bd09644d22d778cec35ecba08a189f15ab5b23b2d1dfb1e2a9cee63f1a52d14508bb4e5802c4b9705ed3afb9c65fd8fb313c850764a5217eafedd6f3f95ff4ddaa97f3c02e4072b59ed30bcb0eb522ea0e2b0c68da6267e748477923001a35ec91c29e5c947070a66e83e730e245e0eb0861285574858b644a8c630c1c1ada4e1877b32956b6ba9b2c4a34654c113f3c98e7c899585c86208c6247be2a3d0818e5a1fa99cb9608d2001b8a1c91863860512dd214b19c1de7aa379c1e52188d12947c859dd893af8978a7b7b96d6017df166e887b96ab9a8c7a31e565e4293920354179c59851011251ef168fcfde6551e09f8430e09233602c4f88a8c7649269d49016b423b7037fc5313fb4cacdf8df41881b6c5abb1745d4c6ab35d7065680010b7011dfa7e35bf4ce843810cfa59d84ae3e0fa3c5b4afc92c6bb3684310e5c5dd639bf7a0e64b3280298cbcff76ac4f204de87284b1e071a7b74a9d8c3a3a44855a69f1b5132b6a5e0536ad8748391569e3f5be68bd29129742bf138aefae757f10a34836d5954677ee41a9ffeb87c4be34d49f3cee2c29724983983aa5daf145bb8d6e077957eda1bab5ffc7b3dcf48f479b61b1f90cb762d2591a05dc5b8469dddf3dc3da59e1682c88d2fb91b15f1b313b941883708c8ae5111f26935645e743ab1baab7d47ebf5758645b0fc9c7e35704155d56c639d86dfd7ffd1872c353d427e6c798ec244c6c6d124edf69207321e117179d9d8273bff2b4c2ab2865dd1e343f9747c79fe2b50c04f3684d77adc2512573f7d325270706b109385dd42b696a9ebd99e97a6804ab1030775ee5dd538130269c6f0e00704a0e69073d93735a50e43ee0ea22367e9fd0f33c3ac44caa43c8b45e97341979b3187e22152e362c22f879e4e06825e83aa1abf26a124433446161e7dc044eeb17b6aeedf23a20b5d7453354ce27b41b5aea95e41417794f9e9d2020b50c45ab0e607b401f4bdc65ddd461ca97bba023280e5c16e9728e049167696a51bbb795f2f8bdfdf09dd7d2b292b11ff001e3f14911b7ab9195c0d3706e1ecc744b6d8f71e348e2d081f04279dd7bc3bf2f596b9298275f0dc27b867900957e1ba9079e3e2fff3d975b215d9012cec12149bee48fb0a053ff8f66b2f748f7fb5c9d3a4085341883f2e3ae217651f766380e0f7da8e19df06499abaa055129d34ca8afd2db71539c3d80d99642ccfcc00e78d78e030095fc84d9020602d0e7f30fee549880e008cdcee146aafe1f701b8c2f3fb376ea6c5f3963f9d11892476e08e531732f51dac5e55000ed7d0d079f8f9c91ca2712cc91c96ff9065a4010c8b97306d0051610e88feab9d3587c454ded8f768c908453763afb675ffc725ea2901b4680f1fabddb5f127e44bda21b2e318654296880d99b7f1064cc234201a7b2b8fe5cbfbeb422ad1651b04d0ca2b43ba3ed15753fa0d44d190c4f5650e60e0bc9c5a873facfe70e28e10c43139667dcb0fecd17b35d8f41ed5899da1687771f8ebcc3397aa317ecee383d00ac455fe35bc623f7addba9aa16c582686b53bb7f7bb22fc0b1e7d96f0a7ccd6c20cdaaa9d659f3260adab9cae293ead6c779986a97497a54b33d1fe6e7970af02718a73a6c334af52539f134fe33286abc4c699362b909a7eb95ed48b7e66ba701e580f911b2d954a5531bf599d413254ad5e589488914ff9fee11e7858ae2c5cecbacdd240f03308978a9627a2b2b0d966cf85e48beac25bb617429f3abb11e2535c01b830cca79eda11c4aa779b4891a87bdf4461ea08b18a286e17a510cca947da776b906bb32d0760a5b3f368ee0e4ed25b8d8f225f18de89d808a93147c62fadfec95ab3860c7092233b57296a16dedfef478c1d391fb7cda656219b0e6ff940f4d87002db50a6ce0a53ad9e0a803930051aaffa6165d12c65ed8321189dde838be71425e909fa823220bd7aa46549207f3c4fff5460c4a3be99be080a85284fa2e3ffecea2a6ea924965f41d467c840d64c8f3772b2f7cb333846f59b69c92c4bc352c98decf31ea807fdaabd4e55f6af4a45e5ea2816a75fa6a75c419219247ce6f5bfc77d9f72f9014ae51fdab61628a45d37467dc7e2f00f7586687c6856d4c17141993866289dc9c44e6165007985e97ebc9eeb0c77298e8c7e4a548b77fb1d3b2a31761f559ebe70193b426d84b1d4c9215f65b9fc1655d0c9b7814dc79885564bb6787b0b574a9e84316bbabaf71e7db8ce1e989faac903320076f8c66ea58e9c2d89270bd56cf68bcbdd07e3226a690efa59c44ab217120304bf286e78c495338a7b5ab72d5ad8b5d6f73761e3adb7ebd9321bad18b29d0278a87842f5ec2c316ea3ea7411e29b1708a778078ffeb46ad07a49581486a49d604f4f5306223f9eed4340ced61c2cc668a6be60c57473d69a08fca78cf7c631c1ecaa2e7d0933f3d7037489106b2773d242bc1a03efff9bb69909e1b62d72e001e50ccb90d111bb0c443331f34488ed6bd02b0b4637ac27c16c41e547c783d0aed08a93351539c5fd666b9055ac7d3fd2aa80a3730eaf5e5307c799d5f63660d8910a23efdbd9027913d7cd0057ced812aa540469a576254dc3cafa95ffe8f8a2bfc9152cda989b6189418b356552230b35a3dd6af4441ddd27d5a82843fbc626c364039f81d3670472f6a311b8d8453483176f1c505fad130e5ffd439d7e2b8f30721b9a6bc69ec4690c73cb104ecc45a6483ef24763dbc34b3beea7f8ee95b1700fc1991a8f3f9b588f4ceac4086ee5d46de7e9ac216d01557e8e2c6460d1fbdb86ee1d1293fb5a322f949b30338a8f37c54d2ef419f4859336d13c0e569807fc67c7aa824b872eedd7862b7b89d1af445f1f669c23aa3136972dff41a329a0ff915e170ebb1a98127d62ddf615d909798ac7bde779855dfd9b0219a3e5c42bba94e7b644c90b92848c38e3369a78895d260776935ff9ae3b5d77761f4e14896110da997a31d08d7a415c9c82b8a92934afef8a260e4b80e1208e0e596eb07ba3edab41d79662bfd41742f4b60441d60297d8e41f2a9f246f09dd8a940086c68c8bbb0b9b7ef7cf076aa025611fdeece6eb7aeab760558f3dab3f5d35501efc0d384d81b0f52d126a3919d400d4974b64996b27429b0926e11ee84570c96372ebf4ee7e607a6f43ca0cb6ec6790a99887e32d70d5be235caf8be26a44f60a8c94e002804b2da2db97dadd1ac221c2f9b4d848e7ebac68c577f83f2444d0bf69c677040ccc9a907f77c05b783a8d168d199f4cd65338df4ad920057a68a1dd4646d8d154a4aaf20e7a595539415d864dea401e2dafb53aa104dc206d07782a967facf467ca236f7f0f27c01ff7639863e8c4826116ff8d74a51b02337cb8e12b1d4bf3c2cedc5efbaf6351087727ffce5976a96e01cabdf1a1a5049c837b06812c9184e990c0e329e5956f8851e4a42686ac9b188bbdaf81feb3fd94d5caccb36f3d49b85b63e3d0237bec408df2cb8f75ccf03d00e65df2dcdad03d006062dcc5a20b945411bee1a5d9fc0b595011eae602248af1b7978306dcdd655f565f02d80ecd530be8beba3e0d264461becca9793de4c833b4d14c7e877e79900a14ea8c5077cf00957d91f1a97e0e769f390082aa33da469d718cf7a4e008461a69ce70a5262955d3f391d782d93471a75418f55d36cdeff64a455b96d40de4f78b0229639b5b799bd64fdc67a1d7851dcf2ceb12d6e9e05d2dabea85a4cce6c6da239b843e7f69bcab3e8d1fa05fc109a3eb80ea85c19f4404b685ebb9030600e09f6173d4ace63cec6f751e5b895dc222220f048e4c590363daa499af2eba361e22cabce7955fef9e71e38f36eb3ca9b1c83be6a2fc12ff0b5206bde6b14cde472f5efd8a994e36141cc31964304a71579e2244906ca885db8c6abadc35a5265db995f48596e1537a2d9a739d8e67cf16591ac102031121d1fbea09fa44cc1dd315537b3b69b7d80638c4fe337add03da5e7ae166c03d22c91ac92782f5f53350592acb2ed0b7e8a8903304b2f8ee07087fcb0dc0916116e9becdeec88c192ed13459e368b0a3f2f274acbdade945031366441533fee6c8d4c4dbcf190c0d3629142ffaa3ddde795ec49e16df8d25c036f049381e959a4e4267f15a6e7d60117e455ae73477147b5c232e13e0697bf69a484716db91c96be591d838aba74f8f2b89ab46538b6ea3016b6775f830d40943bf976df28004e35d7d8cdb32c8c2c51cbe6f4ab478c86424bfb712a2b3db79b2e137f901bcc122a9b4f2b3947678cf7e6111100bbbb336d27a77ae02613bb574c68632e2ec837c1df8e340292b55b8f577ca6e079fb92a57163b320c266f0c8b96b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
