<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bfec620dc57c88cfa5d30acaa0884ebaf6fb81c192a08223e3c350f7b5614c00247b3ea46f79593e85e91b82ff6a3a19ff1f2a4bead9e6e60d64aa2d694f5c2fa54bd1685aeb893ad5d6598509b00ce6cf1f7d0c72cea551c815fcea34db6712b00adb6a1535464b3f3d5059660b5caed3a8e841eadb73307bc69bbb1563c79e691da0b87c5d18881f5614bebc7e13e72b586987ad5bf2ca6c40cefa8d5d13c0e3ab6302d5f22722bc070a917c874206df19c0a5d2d6919a8aa18ac097b525f61ae583b234f8851ca12d2502a9a7ef97d4cf7785cca52a5bbb6bbc1debb60644033a55f8a46d5ee512c10fede39d3cada6357d4196c279612f21a38968723d74ac54a0ec39855a622442317a47cc9d520bb556dd7bc551a7631b12df43471f84e969938893cfd3ac1a908cce84e3ecfe498344b5566fd9b7d982bb9dfe3fffa091363238cf9f429d19cf7c8272c058cdb315a8d7f74ae646466e560cd71d6819090dc56bcf9a294c9c301a095c843f6207b5621370c0c1a89f7570d729ee27546aae2d750381a42d567109e19b94523c73341bb7c2608c5ac8dbf8e828ad23caff8d12092a14826de95ef9b862656cde50a4941da037553b4677c410f152f5689d9166414828f957554a61f84991bffebca18fdf5ea2046f38d42b2515f656a631b62d81353172815caca0514ed0d906c7df1711ede40f57913666b19d7f1a32bcce387ce7450d2d63b7c25dddd38d96b32129e548abd5f4dc6130d46ed696a6727aa015557a5073eeb77fec9f46e53f4c16e75fae923b09ebbb0ce7073d0d9f697a844966325430c6fb298221678c6e862df78db051d2c755da22eb66649934035c762315232bef37206b03c978af2b7c7644a5058e55c4fbef8f1cd22a259195c9f22712314a13b8d6c694b71801ad49a4d9d7dc4ff3537be10411ffd8e0c084b668f2cd5155b14f465c16b2ba83d9ab89c26c953c4228d9c262f3c7ae720103d5abb26d378c39f5facca0cf9a649ad1e5575d98a87d351d176ad2f74e35db10fa1538e731d9eec66207062c9a70ee468d48061f59b24c7544084b40c34927b91120be84edc9233b2d3cd0b8d6eb951a9f40fc67cff96deaca35b41a487acecdcd6344f096529ad0b86bf44c45ef4145af798aaeaaa7c8fba36c4f272a5074c7352284171d5151b51a40b76cfb4c681583d353ce684d6fdd468e18b8a4134358174d9f3162154e13a9675719ef76052e46366724590da91d27eb19cb4272daf592e73ddb108bb4fba3e23d26c2afe3ac5b95c4bf12410071983164430fd79ef52f8de4bf20bc28ae961f9c1b407c60b4b96919f49c60919bd3c640434d0e9837e172dd89fa00487bc21701c735949527ba2a8a7f860c0273d5106a855ea7fc51aa2f53691b91c000af45736b695459bf9a80935cf2a1657cfc595a28bc38cde4e06e10c9836d03e8e46490230328a68cc0c43add58a02ba7b0bee5dcf1a89ceaeae060a1993c909f27b8fe8a08173f05b5ab435a5bb47d34a8c16005b90e93144b54a0fcc24436db1a96462c8fd19d699952599551a323c3567d2fa108d64751c25a7ae011ff18dd1e799d2bba6455e5cab9ae0aa03dc5664b5a79460e881927e82b21bd0a64d3e3db99368f3bd1eaa01cca87e60c605722e5f6588a4aaff82e888a31f46eac5b3a4fc4613e4bf207fbf061a0b42bcf027e8f1c065caf170c94ab8e4d9ed99070fd5afdf04b812d36a8e413432d1958c5a7554b7863310c1767d8a6a6b0cfaf4e16da4de53d5a47a63d21bdf5c70d3fee54d828246b3ce4e574bbffba1cbbe533a48bae9f0c8eb579fbd8ea5f5c4de227061eb2127301e8e7d73af41a2c66a65d8c105b0cad53615d17c8e4822e3d0e86c7b57a522dddb845c898d0935930cda43fccc5c3457a5acd243e0ca8027a3b8ab1e9f9cfd105f4e4a3768510e4598c2a0f96107b01270fe835e39b863dc290825582228d70a006b37bbb7586d6727f1f4f1f50c1d84e52211dab6d828bbad0503e804374bc5c881cfddc1e4e4ba6c3310bcab9f79698600dece5672814dbc67530215228412698dd919b6cd318f03c8e228e80d0588ec9efa1f0d91970ec2594e6f839d1fd64a479357c3decec4ca74f8a52b31b865d2e8044df0f0d49ae5260f5f748953082299190958e4fcd241a798a3a51e6b71e1dd3a041f350461ffcb145520b04bdfecf6547e420744f6bb59d3e08e18f88b3a3904f79af8d86f3b0f6f993dc597ab4052b35431cc42976b8b6f42891bfd7fd84ff23cbb4485646badacf0263ebea13f47e3d982afea95362975073bf688bdc740c0b4261bc74b3d5fafc699d17b01f468acf20f7aca4d1e68f620136503fdea358c31d0ca5e772d3821c211fd6bd2a16de38ee062c398656527c15d9745ada7ab7162a7525be535ff161ea76bc5d5b1f00e97ba44a3b39770e354fd40618dc7de608d60e09c49ab9e6050545f5944f3e1ead0ac036186d31d0f3bac81468ec027eee7a12844329867c5b109daacc7cceda52c9f2a2937f2b3bc27ee9630f6c0552bf6b56f133d1e1d77b970fc35373cc1837a97e5efa30a1ce306261cf1554be11d9976e459e48f030ec40ffa1eec06d6fca38983267dcb93446203a4940923a7940ba61e0ac9478ee65d8e94de7959bf2c1ffaa62f4627a7491d614a1a98075ac036394ac465228b07ff6d3057f34a7b2c2a4ebf3c67e748159069afc9c2e9a5a1982911696542635eed6a19b5463e38eb4d6e428cf95190d9bfaf83af875b2d8216dcf7d955f17fdeed180ea8ea91144df6d58a04bfb02b89b7c6ffc6a19d16243a453e1ba8f073b508d231d1ce25a8ce72bb2c050d635c417589a73d108bdbb0b2be6b6a134612a6f76b03da0d576bdc1b88854780917a16275eb53e6cf521994f0621954e03453fd5ff7149e4be26c34da70e142873b57dc72b10eb7c051c2fc6e9c2716cf7f168b02600c112d43d30e990692dca3a1dc978768c399b5e35335199f292690384ac7ff0f2f20cc2e24df1382e9be17c20575d7e3683ab36d642a2710ef61740691a32ea52d34733619eeb5224cbeb525e059bddd68f666f433ce7e0f76924edd1f9c4780426e5cd7f399ec776e15ce9850e83e16efe034f84a7bb0fdfbb0452b5f55bb9239cda8414393e14a493ba828225dc22610ecfd592bb5cb3975c7f3e19dd147a0a322f2d4aa8b60deb722700462674e4f72570d52cb48eb54992609cca2ca9d7bc2570d842404f8a68c92459cc7109390116580fcf35544e33c3d109e63b778a49b990d81dd59d476a253e72e79bb595f18956acf48551e8aaeeeee5c6518376e51de4cf38e5d943585c0a37ce4151c9b39ec460c1176f1e30606d89a599353bc0e3cecc4f4c09d46b9b47d797e9f7fa60a8800307febd388b329f9147851add942b245cac04a9efdfc99704c42dd8f0f8048644c02dac4e80cff6cfbb3b9b970a37cb3db6eb54b685cfa70bde3b4c269e434fe675d77200d41a32715019a17f16e959733f2437b594b4b7c6e2bbd6c69dbd0e02c81708e322b012732b3333b8dee9b850be6942fa2e8f6ef54e6b130bb214264824912d34f7a72b6ad6b1e71a83dfc0d3d3af14c580f053f3571f3849f7cffa1bdeb56b208a76746d017b942ed164cb8a4219ad5ef3789113ea8ad4b6a555ef88472db867e6cccbe9bb6002f62ddd0b6df6b9ccb1156d6475e5a5000ed2e5fd14249e3427c194438e6ca0b470a4e2d7266cc4ccaa91825b28f9d92fae4741e40d4d093c0607771ca63088bdd4dfc4fa214c5043ce0ce24df3b430df98c1b51fb8bf8702a969477c942a919f01c0779241adeae3b8722368db40fc0657da44043a889f69200e152fbff74e09df0682af2c8be8d0c32c759d1b6022be9c0bf6959060afd8f1f4871a21a19e3b925faebdb056c30748fa2d7a813d8ae1a081fef9f40e5c4d60440849bb86bd986266e92dbc14d769b89622f8d7e90216485537a8461e107526734d1f5b3e83433c9e88bed58bf4ed4103cc6f87b2bb3e24f0b03ed3492ca460d0b3295cd552bf5e7581d5c607bcffd24384aaa71b997ec7cbf62048144ead8d613d8d58434bc7db98d70a88f021e7852a3be518ecaec4e47bdf1fe8a68cce76e7af566c5873c1a1fe9949f017c1c47083e506821ab9a08affee7ceee94e35128e453be26820790c49b8e56e1d0066d493bdc87dca3b5ba28298485ce71d8a527328f04ea59f728a369a9794010c37cae2ed407fc1080a742b5766fd26da7fcbcfc44d5990f8634a8e5409da062d00452524eacd109c4264656a67a6a95ccc52fa54c7f8db2fc8af08115f4b781858554678528fa96a821b0a1255afce006434a4c75a78222083c17df7c81787d3da192863a45e1e08d43e07b9f1c1672dbcaefb481a530fc0d8018e505368c64f3d3cdc03cda32f21f4ac39778b0781acf46cda4bc8143c9a17de57ec9b9eb59f92f6b7dc1e522cba2de5386f173d7f3b1dff1f1f571967407ea59f580ca164e6b8f78d7ebb7ae0742725805dd0c539859c518855227df1aba6a36e4769f6eb6e73faad8e416dd6b56351b1c0fe6b4a8f1f72135f85890ee093080868e09b8596243915c4ae9fd0258f0e7f45fc62ffb06db1463570293faa2e718b32f4850475d41d2ed0305ac1ea393650004ef8b0e370b849d6ab50cc68ec62af47f57467a850f0ede75d0ec0e822b8f3e07235e2bf2f1e317e3e3380b9ce917cd3e1785f4f78d859e6349861892b9db1ef45d602676f5005807109868a81a6dc2997dfc62887897df786150c5b748054a726db6396c0af829c9cb14d7f303a6ff0e37361b21fd0704b2bb83439ad5f26d2523b3d145121e6d226119001c0867bac5e6dda58dcd84824d24b27e02e51126858902a28aec3a5dfaf5f7f290169e327a69c53394ce5e28ff4a7eb1f6fdf7be8d7563446904325c7532391eacc8bd59c18a14f3234848df496a68c2f5adc23f009d611cad2bd40f33da12f3250b8b930a371bf0568057db44f56153d954db5fcccf84978fdbe37aeae8efb2d069e5018881ba6b4e8497e088e85cccc5eb5f76e3d9d89814557601b8fcacb3e7aaed9e9af32e04573cb946394537094c9c85930e77d38f6efcd26b6cec7be1c93636e2d8459616562a62076179414c8a7b83cc1ee44034360fbf0ee72aa7730ce2a677339fc8790cd8160c92ed8867552c7099853e96519ea13a833e224fea5d899644c2640f58a0f0f17edb8023e2b417e1f174a1ad40138ebd3ca94645bf046fc14a25dc16c17a1654b781747122b8f1740c495f030e09b3244ee1b842edead491786364064c5a848c0868d0e6f2c7b6294d8afd201c26aaa8ca91558fa47edde68319ff71fac10e3666c75ec945a937065b89b4559b392da48cc8f2474ed72a921bf0dc63bb54d7756837b254974630101729b755c4f3e1140bd7eb501c0cf5b8d3affe09aebed41f61ec95b79a9d612b3f82a44e2e73a3b02a8ed2a6ef0d9df4de65a0aac4f27c212114104f59ccd5f645cfb476bc16f040b25ea80f4d4f090663944eee02169669c30cb0ae74ae82a769075fe6df959fe08751bc96c4e1955bfa9c01d71334c351b44d5d2783408953c615bdc7e071d9d68b27cc0a2f0329a968235ae8ce231a0bf8a0da64fa558e6955b9a23e4fea1186ab990ae872e75b4ba8c6aa176a875b1098dd476f0fd4f8aab90e04abf7b5f397b30f9d11c025d8030e230aa9720bd9cae5c94f35763f06539576fea8452e3481f22be1216b704a0bde7210632628c9272c6719f8e02014303af9884bdd5285f03bb1faaedd420d47f9ed0519ceba6d96a83923f7e2ac7565bd012274abd63f4e1fa8b9efb74249a28cb0c38f882431fb9e5695b76ae9441826eccdee9492edacbae38af8b0660c3d8a94a137531576b07b813f0c9c938d4ff237ed3423eede5bfddeeddba911ec5b78a0be7f144754bc91eb01dcbe7ab769908e994cac764dde792b3ed9040b9219b298f0488c043df77bb9851b9cd017628c73bafd8a4f243d72d8dd83df05f758dac727b7f40d99311edd501db17b4445b52bb4cb54632cd4ea6fc73aaf887faaa01cb78c0b6839dd913a87deaeb7eea3d9ba84109c59737d50a46d6951ff95070c531d91b248d652e57e30c572e149eb1a6a941c3232376612be4825e87745f0885da6e9c531f75d3e992a97716fb7d8947b84074219ac61dd705fb170f38ef8ba0ac4499decc3fe0396f276fecd0dfd2992a605d86ed2c57f1e2f59cb1a6d894578f67bbd1e14b127df19aaa91f519758d2831212af20c7467364b5fccc5a424be245565f9c9f62e558dde524efafa6108d26e4204dabada544bf41cf13e453e1c79c209139602cb8b7dfcfa3e0a3391388050b062ca1aa2c3471e57362d8ffcac7c4c5b44c66bc819dab22199302a0015479ea03df63f630e64cea41cea1a368cdda8b47cd19974ac0653798e211fa73b34b0736972b436cf409c2be715e7fe46e01fa84c6a7c0cdc36562b63b961037bceefd7e6d01910cdbc7397b7b107362963722ada86094294997114619862c2d852eb979bb56d1f6f28a4908c224e5b223dc2f70c243f4044b0b12f995b2c156738e889843b33625624ea025f0910cd938a7037ace7c82b3c3e2bd4ce2d3a1ea04ff7f53b697235dafbfdb002edac69fbfd2743814c2deb83e1a3382805bf371bf0c5ea8c40d254297631f7a1f44640509a59a6b23d26ff69e8d87561367fa9d9f03ca7d7814648b68e0fe1dd747bc4d2e53925be3cb39e208e8b47208435b6dcfea234db8bfe27cce6b103c5fe18c4f05e4044ce9ef32eec110975e28813bbcaad184f9bc8dcbfb89261964bf7ade4047c1f1bcf72cac321499c13ada8ae929a4014dcd98735e4cccef7279287e7bf937b443e3300513644b925be3ceceb0bda5c9da9e5f7879afd9702e2d637985a9f89bac5c8fd563712f99c06c3ebdc034e725ec459721a07b636d23e8697976720224a54d0912a0db7fb45614f8575065f26b75014dc530ad010b80212815adb1647c3f47bb1efcda180e24fe5c67edad15904ea22fb785125b4c779b4d453abe6bc56ac6119acf5df7c4170d606fbe475952ce165616cebefe7013713349f377310e8e23ed634473d30d357404c77cf66ef80e4938fb133fa835058f77ef6d7c1466f7edf3d5ecfb59b8d6bc0eade75f118603dd1b227ac85e1c3d1c28b419d5de649895e200b965b3f0125bf969a684ab4695f0217f90dbf203b33ed83d4354667d58af85d2a2876b6891bc4e9fc738559896a4b79e806803c25c2712f1d269a72ac2f6c060c6592b6dd00d820fa774084a2c7819a4c5746571127f3b155d37b7a0139e79beced5ca777880477701751f59984e68fde525448bfeb356c5164bf8b8bba4c1c59c6c5587ae687d51ec1da272ccb126c7dd624dabab1299e36c62533cf1ac582a2249c2c7229ed62d38641fd32042c12c33c46475492061ad570dd060f7ba8801c4ae7468447e78ec13a2938c212c92ce4d235646c0ea632760bbaa84c6228f17dff39fa386fc622e2f60148a5efdc952bce6c10fc3675b7ae30d43f6e60f2adc1c737d904c52896be09457d4fdd75bd84b909cda1c96eec6e5af75d9ca204e7877e36ca7822e00e631caa1ca40bb31f3651d34a0296cad3d9d4b781235b0a126dd69822f72649364d34d43fef833e3a48f4c884deb2b15a36630b0e457528ed8aea1cbd5f0f9dd976cf26a28abd22e511ee65b59ee4db8d038b526bb7daecfa7129c70b9b58ed6e24c72f21bf005866b0b16fc82f3922eb7280cf0447a185e0b3c1f592a48616f3a8049643f80ca195b86af49b9e06d6d11d64f7da306fb97722657b53994b948689a51943eae1f34f06f76e8aa5c72ce0691c0aa51f0130dc1d64be2bb3415ee59b05921a41203215f83d783382d01737121c179489cfe27a3e28eea929d9a2a9686ce59358276dc4aa2765ab6c5859ecd18e5d09b861f711fe889e8be323f5640da204d1857c83836c5b25be81e2608c0299d888f14b375cfaa3d9e6a9a6c2918ba1e05b0002fed2ba2e02166277e91079a28c08a3dedf7a1b97319f45c46e9b53d10ae9950852b5ea3e3f5b5881347a3816d36c4e0d76183f62c01505c9697844d23d2bb65e79bcda34b056e4e7b1b3774c80a5c360a5d198de3d16563b876e2bb9ac43947de88737b419733cdd30c782b562f417f674bb507fe0e05ab1dfdfa455a2581a56339ca8ad759375689d1706ce6fb481cd3f63164b4c0f2faed9d5324d622e216b148f779c3fbdf3ff82e0cb4e7b879ede1402cc9b5715c0e561d67990f7599cc54cc127380b51acb3dd8b1192aec3c31fb4fce105f067e740b9e605ccf91e65d2f90f5c0162d8c15c2170bc72b243e77a8fcddd19d1ec0ecc3159ab02f09837d84478799d1a0fd208b83748c9ce03cf9d1009423b42128cb3de9774e5be3dd705f04bfc46858a0c433838b479eb8313f95dbca27f503e84a5915eaec4ea9e6a174f2a2483351184f5daa748cb99dea4815e79c88cc6cd5d8fe2a97c537ea0e9dce3f31b5f8c677bc476000f64d5803678800c41439e267cd71161d4b473e45c2ee734d3dab8f8c7910536cf97aea45d9d882bfdd1513bd0bb36280d80aaf4503d15aebc4c587482b646692de96bb02a2accb8f8dc1b445d72f7520fec0885d0a464499005872704aeb8bbeed262c86b689cf6c61e8165e1d62f44740abf7ecb52f95ee8b3a111a7ac0af0b9d85fc8b1b6cd1cd3f9c24febd62780a1647da985db50260a220c1b116a0fb4e3c20758c08dff5bfa0f0c0ad05f0a0e7dc3ba51673cc3ea2aa5f83a05987586a6f839f62632d46cc33cb1b627e77af58d728bae61d53d018c0dca058531481e382a9286023cbe868d4e55b7e74a0261e4d7dadbf0951fdee455886a45e5491ba5d15ae5ec985ec7b969ce17d99725f71caebaa127477eb3a36e2db7fc94939a94cc25cd5ae837e25ffd314a156dd06086260da708c718ab06e0c8dc2418309fdde067f8791b2f56e8b5e840c7c3d60b3b587ec4c41c63936196224329e45bb10e508a2b39a1a8e2310edfededd586cf4dacce8c234dd376efd3d756375c5b8fed4b174f9ff6bf0f22f659f57e4bdd88f12d1f89a5550c309a56f68800ac7be321d84fa671afc84449aa611d995fe0351ea76ee27f40c2e18323d1ef5a5acd36f41a0743ba1f68902a85fe72fab14eca11d87ceb50e52f465f4404c116d5ebe0ed17413805cbb040b32958dfd6108faee64d4638f1fe2806aa0b67ce94e828f2dffcf87b8a521b5c301593f354d25da1440b9f830365ee92866e0d209a79575bd6cb4ccab03d841005f814f386f752a1fe083e18f8bbab906712a3d2b28aa1122a0188e60d7963ffbebe6afd8881cf74bfb39c00e42b181a2badd3fa6b4f40fffc110b9878f4558370c7f1bfe24371879604558ac2e029ebeba84c5d15bf3853323c4400e0ba49cc80cf57e9526d69a3b4fd94469df6b2dd6e762956c9dec46feb186511049b7b4c8de619cdeee804b8135c34f1196d2783ef52494c5de35337235f385ba7489e3a86fe9f5d14e21a370a4ad59d374ac06c330e078b0680d227c790521998a609f3363fdbfd6bd6a988f7c6025a81d3a8798de4ad74ad3369a5bacc5540e7ac325b296fd423a6822a0e373d5de24d1fac8765474fdf3c0a08a2a57a4421fabc851dee0d965cc716098ba416a327d20e14527e74274d6093ebc422f7d6a8b67d8b8947bdba513ff6f9f827f756a7dc4e6d01cb4555a0dfdd8ad4a6450a694e53f9b42f77adae83e777f0b29c88235c55a3b7f869591a448b1d2e7aa355c8a3d2f74462434947e3d753647b9a32fa1911540ca8a7cd05897903fc968eecf6e7b0ac151816fd662c114f1e88f0973b6529be69111f64a85b501d7bd5338893ea26251b36b92d3ab117cc466fcc469213902c440517977808d014dfa842afd2ca7c0a2f6256f94abd6788f3b8b218bd5aa4c2929f2ab26f8c87f4bbd810536bd7005f2efc7a16f694499b2bb722c7731b920ad1f69ff004c4f4bd599efc25a6ac195fd6c8677b6e3b9483ff6aa78faa2e24972b4fceb91d64eb16b11198545a39478f4dc12ac62c9489b9d9c10f327caaffbaa3c888586cdd1abae2715f5e021c02f5e0f693398ac47b516ce3d9a4a5066d457c41c3d0b7ffea0ce98afb2796a8177be69164cbe69a320c63aa27e2b2b67aac0efaa4b5081ea91876d83cd3cf94b2dc6ac9e8baab9284c4a8190a6a5d48e0ab39cab600bb1bf8148ac7f03bac83b927331ada7b0667aa7f970c83af64e6184df1e14f3a4ec13b89a4c2a048814b565833c2fc4253d024f53976e13d8d7640a43e643db5d048beae29b2dc81f45229253fb14daff5cd41bb7118a0b8f4605d96a61c4279087495d028010e93e0cb439c57b2449553cc56a8d6cced7c1ea36d69de1c0a026e8c830109a06caf4f6289c09be26237402fa7238404c94e2b328678d98fdd74affc06d5b5ed6dc4a77797d9fa6b1c20c3b13f1e2b7785173ae32a593fb3f33d8f3c35346da02bcdea429310847292320f37df6b46711908ba3abc66266b765b9a3cee00fb23ffa5859c140b1f84c45ffa8b6df234131ebbc3f4403d8ca5f42c175fb2701d4e83799e74a1445ed2192d0d1cd0e17c1e02a9c43cf9e13d9316badf273f710a1fdd87fad689b3ab5c77d7477a47a4cdf4c465150504f824077abea0965b734d543ff56ce26a111e5d528b3c6e7d6232e95bfd53a76d55ac1beb7f0b7aa2c4d930b5365dccfadc79de5fde2b9a21e4892bd03a21f6e87f67b04146e19144abf56e65c7df9b82b5018a1e0a092b0d90612a187fd1d8528e2f001b77561e8cc92b760533dcc28156f59f6e03f5226ed3981c8007a68e4dd880c4f5ae172da6ae76cbf267181d6a9d83dc28d377a9c83020f9fa45b3bf9110ab5a79509e651c639b41b601d39112696c77dfd7155b1bdfcb29e5a10a35796ac619fad44d266e2b033cd2580a13b2cd6be0f336e89fc223db98b87ac2896fb734310695b1b90f0561d344c21bebbaa16e2bc35a289e3bd3eb6646b9cb1dd54612835bc98d04685e62d8b109836bb0d609dd03dd5b3f398392b0818f0a6d5aa69b5ce8064e7d5310cb6dfc4fb875b4d22bd357701108fed144e9f6d6b3fdd1c7f238bc064b3582ea2f888c2b8933556b0e6ff6ae8c840d1f7eae25cd82463362a38a246349ea2617d22986108f5ac7102892f6dba4ac8a2920e6996b364bea77474eb2545426ec89b53d0bfb67a240db604f2722ef2815cd8756d06cc43d8b4764ba2c0ac7b683a182fc68b48b2a70ecb3d58a10f12866797a4e6ecf28f723acc3a1b713d47dffdf9dfcdc199e5e0cf7dafdfd72b4f334d0966fbf46db042c519b9d4c3cb2d2fb129e8f5831b34e2a4dc977a8292dcfb629170d9bae92a0e4eb56754379612f7e872a70117b3e3da8d3d236dbeddc0cddb853a71d6fbf181c17a57a1bc0d0831772db828a033976120a711b7998a614349e86022b6f124c36d737cbe32c3c96e1a44956c6a48d5528cc3131ac1665b8c1bdc087bd0a82565d7cbc6efd4d1e2619c742aff12353040cf84d1473c4d77ddb46d6fb2106107396b8eabed69e487738abf3a136328bc87ca3726fc16fceff04fab0bba2745d78cf6b050e49bc3f00e67a52dec86fce6b2f4ec56d6942bcc1fd66fe0f53e81b1c8050e2659c280b46f34913b113c7e329c52627a4afd82da7f88877119d91af0f2c5fff580fc2d9ae8d219c2fc5b6c331e50a012d44c468329be937f5ec99a4a5018cfc289bab18ff068ecde254c18e645dc8a40876c9307dabaf91a60fc724888a8ebbf4cc31cc0836425e17b21f639a6af5606e6c4c78028a433fe5390a74beac354350cd004760062d0f126e90a23a6caefa4b63813d258f111817abebd9dc37b08a4b9f05c4c5a4e1b7ab31170499b492be4829c763ecfb49e29c64e2d515e2277a8bf00bc7913cbede5277fb8d71a8d968dcaa2037738620acb0f29882a1eaa75b291331bc332b29b70c1c0c6e53cab4fc8bcb7063be948a937e9b585b0b29572d9857c252e22c5fb7c1dd478dab1bfed3de5c8f97befd891bc65f497d4032dcf5fd31b71240aa81be90031af1990702500b6a8ea099b32db42f0797e03e7c5222e6859a84579ef9ce802806ed30f804c3b78c3a3b4f49e97449cdf37dc1ac365738dfb0816b1487c7bbdc50d79fafadb24dbc0739c0a1f94e4d8b4390f02efd628e105be054b0bf54732b7e3b529340bedbc246d27f64e7beb4b58c27dd15780c70dc7393e157bf445f23acb0c1f8eac323e0bc57450fc336d2c82673dde72b3ffb2d45bd74b6d2423b55f9b42cc86100c5854f15955a277397dad86d3a936d47c8115ed6dd60d808c111b4447e5132a339704322ef141cd3d6d1fa8115dec28f2a8becf2e5d12e8259148ef00f78213bae59368487be4628fcd5c79d4cbc434820bb3069ae34abd88b3d4714c79b2b777064a50232560283647f2b01b1aae2055e8756334b88383f2e21a078564735f6a5dfb028fbf3729ee273d56c14b38510cf16fedeebb31a2307f602fe53c7f0c507fbba3d133621d7e2fbfb6b3e998438ccb39578869ed735a76e2f00923ff63a9c6949e8d6b964efc24b997d403af5cbc279f080ddc48945daa51bdba8ea933f06db530f652d58b03315fdfc5bdc352cb069d11d07bb7d653b602c76d279335d0240fd54b2dfd4ca744b02555c15abe298e4ead3f39fa0ec05226039f2d8f20a94efae59fa865fc8c26fdfd2d27ed6bc3f6edc5f4eff57166cc029cce3f12034d25af6fe4e67bb934608b5d56b972d721f751e4f595af0d445546a1baf5cc94f26c40f0de5e3d223263c198165ff9878d37ebdda711f1c34545bc22a8b5324cba0e8b1e89a21982684e1f130dc92882eaccc6bdf8b48cc7855b031d41cbb80af367b094d284c33a8b1e388f0312b088292da19c6d5c39780d5c535d5cb78192aac32dccfaed1216fa7aa71d195b8608b87df0c25c2fb9280c4c650940943de888bb4ee67329247140168214c8ca32e4313b080fd97bda79cad4381e79a274dd2d117645f6582a0f2216fe8fcec3ccf78be9ba90afc15cb5b7c8a3b5a15d668ef9301be3323ac7c4e9613389b268acf43be29bfb3108789c800ee9357af1778436904ad242743bf5d2c1c4853bd7d0bf5b115b98a88b722692e31519a2e73eb80d9aaad20bc9269079e104a99b41bccfe4aa9137047ded4e0adf300fa1fb23fdab876867eab987e3206e392ae4699c640e519fa48b53418ec53358d02a819e103f729b79ef08b75bb169e6a6428ccf229dbb599799c1787dd94fd9472305a71110d09973f944d658658eeacdc6ee5236794955be38e62528ce62f2d06190ce1fbd6c4e32239f7e43603a401f41d48a7ce4f99e9aa2ccc0ba164a5409de0fc68a53dd8701fc263fd4779e3c3bf9986e6b79a601bdecf2740f0666a5210956171be3d85d44e3030c2dfeda9db82ca0959a69d2368f9671ae4481cd609615dce6a678ff131f07e9e1a8a332a09d7fd851422c79562b211cf85f76d184d0383e694b947a223b58ff753d09375b34c28eb385dade5455d37499fe9310bc584ffd189862e32defec03b456b05ad7fbd3b15efadfba7e886ef93dc9a0636c0116a721f7ad511ad710fe091a94f90c6e50cd1134e8f778d76f1684b282fc7a11663c2d8719fe0cd0a6af2ae6981c47ec09e937c7c7918d73af2223033594cee0d362bfb79b1768b41217f66e5a9a25294f4cf59770bfa897f8c26cd3e27396c7dda02d1ed0646e3a71c6a8d12c89feb623eab6f1cce3a8a8433eded7521d319d313b392b58f6f1ef881b79c492660a7d9ecceff70d4c80beee1bdf2aa55112272bee4ce506865962ef44229d84818db8234294b387417d356fb5788cba34f18a9880f17e47212202f728dd476bfa0c07bcf220eafe93e580a4853309ba8e512dcd53f4e43920adc8e48574409df02535ebadb4d115de5d789ea7ea85365f9a71d3152e0d9b259624ac085178a3f45cc893b4d6b4bec0b18192f1993b65ff1c1e331e8da3d924c6d2cb323687e5fe8cdc0767e15574651830bb109f99cab7d6e79d2092dd291ddf8168c092cae2e13fc8bac5fa4e1f1a077aa4785258c7ac65ac03e592772d4539b875adf04e44ba7484af6ee5c2c16ca3d6104c49d2cf34d2ea06500ae2da836577be0439d48dfcea432749cdfd796acfb3190cdce1deb9e51744e740ca9e0e86d87d74d9046da07a1a62358c8d5d84f48d81143518e1c59b2873c6dd9e4293d8589bcbf3a6b20b9fbfcdfe989b81a54e653e17002177518ca8d482d97a93de5a1103b62cdda37b636794a8a26b57974d4fb5e21d013c903b6b0d4521cf68cccac37b78129d2efa03e852cbd781e51f93fdb42871cf653d29f632dd9f0e1a847336824be231f20c8f357cb7e7d3a5e59d6db2b45cf039bea638fad9383012cd04369e858020a355a18f53bd52046b380308248a361e7700470bd1abfef81d68bf5ef27b7901f78c4a6474eafd6b270182bdb2022da064395b614cf945f17f4388552d28e026da45461c4aa35118dae95b5d99ec00d7027cbdef469ca45b94da273067355b2ca0d0f205693411ca9397c4a7c8a64e58470931be7cff556671658f1182028d6f5ff793100fcc1c6dbe8609a79ebc3a8502d3df4f567c428b2ea981ba7a527d18719418bea0b5556eb0a184ca9d91a01d9c7cbe5c63ab4bac5a34612d88b79ba1ce12c42d987a6c9b55c9485c771f4d870c2913537b3dc401e06f538a66f5b107e7a4914dc21923591ea1a8a666eaabc61df9761bddd1b54fb8137c842821cf0dc27e714c9be3c544ab98bc7324698e8cb66a78657f47b47e1681b013a5cfa966da31b971610d427e6cf2ab8300f09104d92702002a42fd554ba5dd60753a1edcfff5a85d5463b376a74a4d8df0dbd93ff8cdd25258e280c02dd019c16e969d9779711edbe122b7a4ce0c39614b9faef2a91b52f669dbf739543fd4275d1cba922da8fa01b108d6d37cdb7b2a8787e38731cea7f45eeab90a7eae954ef9f05e0192767b80d09f95965d96b1dedcf82763bd41071d9299e67628916f8eda331aed0e0ce63712e5738041c83e93e7de8003e4bf447ed257b095adb44e80b97d194941a0e44d0741c5872adb3048d23e02e46b44b55b0af87cc82276fd7718843b5364df4c97773ad0b623d9d79d8092deb1560996d9586895407266251aed81a08fad61ead9cc533bf1e5d37a1aecd31f2868ac4d51a7b918862f2bc9cb12d75a1aaa25378352d720afc662c52f461cb6c6ce41ad0b9ab0a608cee7f7e342515f8cd427d6fafaea93746957b3879346c6746bb59f320b0393cbecbc7247de423d5b44b83c09ef2bced6649cd737899d327da31461d0530e2c64004cc5ecbd95a6417d1bb9438e58e6fe677844c4eb7669c20490052b9e7d81d1a5afe34314afd5da9e7b086b84cbf5ca84d891038f0cda468f4fddd2376277e4e01f3eb03c5e9109e662a28b489c5f73033c07abaca37cda624483c7b3854dd8ba257aecaf025eedadf1d72b8193e96e6540d3e7f08927f93443872a8bbc0aa4f4db06c1927f95d29d8abb14b6aa7fa048d18c7ad0e8a9a5303d89503e0ad6ea07ee0acc5fcbff1e6e6e56d7e3d8dbfdd9a99f442c67319a658fbc79304dd175e782ec14e96bf76961a0263104be375dacbe739192772c2cb7d247be7f5bed7632130aed88d4fb5cac895ec896fc7b96bb8c478ccce3efec70c92f51db1c2e7ab3b543c7103ebf4a87ab0338662bbc788ef193dda276bd0d69a5579e85e1b5938765999419caaa751a5fdd546223065b202c3fdd00ed5048ad7183145d80125487de31ff177e7a22f7e4c85f4bc005de2078d619dd9164bcbd253e24a673d5d904703dd73c787a74751849afcd3a916afcdfaf2b072064fc231018fb86faab708bff350b8ac52b99a37e374fb703731b1617952740ba68ee3f1cad0c75a35d57773faae870200aaaf59a217747ad8164310d93d299e2d40b50304c02104bc2f4a8ffdb70c33ad8d3000978467d3cb4c1ca0dfb10224e67c4fba2d8c8605c1441be5652d63585baff1aad1e4c4766fe3a7decb416cc06ad3d407368881994367987e55a2715944de9590cfdfa1fd79552ad9a7e7834ca85aad07330575331b2ff2a3973155dd4d70c3df59653c5a3a6ed571dd3aaf8500f59993f9187e15a51d8f9460e45dae8045f8b38250ebe8ac4e6ef8bc93331d36163fc0d5354532ca05189e55260e81f7e9da93afd43671b9e29b1aa6af1932f7ef13ef39a3b82cf4f4bc3ae565b645d8d8d04de96af23ea7c244abae8ee228057e1c97dd03ebd7867cacbbf4106a57ce501659915e138b5f1d06c10a8576569ebaf6ae13fe3d06a2d615da5e749e65e5103d2f50f5c8a1f0b36ecba5e32176be6fb37a0bbb44fa4915e3561958cfe604220ee9e17c281498045fd40289ab77ac8ef53ac354bf4164a38133a21625f2a923b8ce5a3fc036c02b22bf7805609f32e03b6cbde08e98b5b87005a074cd2474cf076912e034f03844477c656770739026627eee279d91260e109ae5669bc8c279fc99e5ee615df7d7751213648138bb1de66db38c4ea6222bc08acccd2599086c6f7df6e97fc3848d3235c09aabbc09a4161252dc9c122888bf35788fe4276115ff9b1be9e713345c0020fc9cf80be42af0d194cbec77b1cc19c03e097319e25d8eb6a95c78f44cc493fe00882678f07e575e22095f77f80e7cfa2ea0c5c9d4fa5b66c4347373d71588275ad47481fc003d13125bedc176f21c975b0a5ab8098df0b0260f5fd0ec965205f35c46640f4799c50111fd91fd2eabe1ba528a6d9bb536b817539fdfc48ce7ee5c2b2d6b0bb229fbd15fc71a3a8843880ece5d5b879c47057851297f1ea360795619b05f3adee40c7b093c89c619fef9745548fb7b5e1d257623b50116e1c469eddc1f435aba826a37093044d912db63982c354c150bf5ae205412318c13af591698850d0b0c81b87ca561d85f5627270352ab0212529dba24abee8c9888fd97cf99ee9860fc3bc1aa2358ff1aa67f9978154b93a134c19481de6599eeabea326f654f4dd5ed102beaf5655b8748583f13a26907ed5ed3ef721e22d288e992efcf88b60f7a7bd5a434c110ab6d8733d84f084c6a50751f26767ae2371bfe07ba622da31a4df5c8d9b4a3e003ae33ca80a566fa6a6eedc1004c7f872f08e06ab9038a672db8ec934528c607c7d9a7a97a16d939bb15a8ced701c406795cdfe8950374fb2e3b6d4d52a45c08593aea95fc890c18b6d010fc7b1817a580bdd0530cd3e67bd085b3e88912e8fb7a0561cc7395d44a74ffacce7543fe07637c63d3889071fd84232b50e3d468aab740279f2a7205b05964cec4b95e28c58f2bb082751400b8ca02dbc69d0420aad79afbca9b02075adc9e3d9d6e116db31e2d60c22fb99ed065def3c352a6392b4771ed9aa847529dc5acfd2fa20217e1adf3f67e36ba350e7c34f20c81b1da7f61505a5b7d2a6311c67e61b7064fb492f08aedea84d3b924c4b7228969423783ee624c7b6822fe06f3f731f935088cfafef8b3a314aaea8fb06e6192dd81aca848b849e5317553d8ed6d455f3261d3f1ca324eba5669f131ac06c67e8705fa5d36f370181236817e5a1382c767aca003f23d624021346016df47bc7c2baaf2113a95cd347e69f5c77d339e9eb6609fb6f6c6652bd5807e0da40f7e48d99f220cb29b9f8374d0b5b45b2cc801b2cc121ad6d24dca455bcdb10af05e335a2dda6b873e43aa82ae7c706a1e628b4f4fb71770e89c06c3dbecdce14b8710763e2a8e2ce945b71d8c07fe4dfb098077f783b926febfcb31f0239abe2db1cba57b925e86455f3641a662ae2df64169566e63784be508e4c286c23dd6ebb853b2c05611c4cb0a41a3ee5136eadba1874d2d86a76f6f842d38dac8e4562618b211db631e042119e6b894fb2dab2e2549f9334a549282aca5326f11fcc95e3603a8912283b6627f82d186ed2fc209988b3b6d52485125114681932cb559a3499015b94cda15b405f25a1451372708bfb233df32bdcd1172c75e695838af74868052f7fac40bddbce9961383eab9fe32533926dd07cee4def82d0f213a28ffcc57a8cf9119d11a1104b7fc066611146ac8aa90e3380e9737c0e121cc86b7598c4a980aa85ae2060ff62ca2e630b22259a5e1685fd81abbd9116a1961a606e8b1312f5ecf28bdd535f95274fa9a3dcf68f0d4b69a584f3e725fccd0bdb6e96428409ba61f4a38c317d1cb307ea35b0729c91923c76dff797bed671e152db656b3e4d3bc775e1ddeeb4b40ff8f3b55cc287dc59a3d9c00d7988398305ab439adc0868661e5e1766dd6d4e14c494b0d73a3480f1b17dbf1403d8e21aa7ca5bbf2e5221b02840991a44c9a2ded20456d2534fe027c2163c4b1a031c26497aefa54665f39faf26350822bd30fd21ca560b042d23a109a4a22589cb15bf349468f6b22fdb09bc161ed344b2ea7a7de982dee3464b2b2476da72cfeafd6c97c2c1943c2290d3b7d7f9d07252770e817bd7ef7d63037fa0374b20fca3c057ab6fcef71d0c274d732402aaa1eb89f6c2dab25ffc8a0754291d8599c03699ca4631560b6a915f3b31b89dc8334b17302605c23680d0319aea5fa00da614f685d12ff76d5460a99a63f42b72a69c504f1345ec46c4f0940e7752a6854a8ab50d85b2996abce0a8fe9651be7d136c7f1c5a2eb67059af7f8a52541bb2f0c03a0b75cd6cdbdac2b1fe1776f04f369a65f52f5af9c965e36189decb1e267d438a89071e30ebd99cf8d15fc78ded1a675e7b56c2dc6a53db659e9dd5ec45957c66eb8002e1fb37d93ee0645181c22cb31d43b867e06ec4fe17d1ae7edde075bef0035ca062e19c0f88053284cc987cfe9acf81d593da921485ec7b06c3a5b28a916736557bb5ac62be1f00ac1efa7d445431847022c4f06b2b5ad74497ed0a9fed7d65060bd1207287f215f6710cb27387565c4f0914552c83a31f3b0d7f798d68be6fb89d448fd36ffffccf53f706ed7fdad9369fb3722ba48e817017d9cd02a3b9e4cf3c0d39b69ea9c063446f69485973a391e59054abe823a195003604afa3e8a4d446489ffac5bbd0dee91f1dc6455f163db9039e5f249b44b1c58a02af579d6f0d824e2303872b9b15e4747928607749ca6252c7b13a6309de4c674346f63e0437168f201f1799485a81fccfd3bd2d73a5a4e8e01263d51573b04613644cfc849556508153e1b4efa9be95348d5ebc9dbc17d397e06a9c9deb0f9b869bea759299f2440014b2212332a4bfaf2137d9a34d568c49fe5ed92af4e1c32460e7e23d37a12549c55d0ab4d1978cdbbeb2c6309c26c9670564069ef9389f8f7e693cff0c5a6612ac1556dabcd7fc067cd8a4ee9bc48a07e76790dc22791d4e606970dad274705281197c0a26eb474b902a2cc6d735e4aef3dfb15d50e39936b4743d29da273f28ae81110d46eb3560d929c2d5e1ea1506c6e6e6a22461abb6983148263443e82285c41e3c383e1290ac3f432ed3895285e7bddf29dc793ad6315c56eb6d647e6dd18c38b318120a1f0aa2f9a50f71e6957c9de5613052cf3402c1cbed917eb616c418f784bdc7606c5b1b7a08e6e08b94ce3e1848f324da6e879ac41a7879f2327e70b80317a4ce43b6b3535d472b52aacc023c148e1207d41ac03683bb89887ae914a5047fae18c3957bca93fd68ee1393af3d8e92683602fe3e5818ac1eea73a03f84fbdff84141d924b346bac55f93deb8395209bb0863195bc8268b31916971d9a4b219b7510be2a0f93d176dfe441e9b84d1a2503e3ed48cccbec3f2d6132b451cec4ae359314f91199f11567c42bf6a9fac279fb84356474d798ba6220e4d1c1be0211ef54b6613c9c6bfa1c78e882bac219f4c53f0ef3e5013310d580a6cb217627c9c5ee679bf5aeb3059e14bc78368136ae9da271b3413fec13da40f45cb4099304e1a3a9c8525f7e66490af09f02a75352cafc5c32d1a80a0b2f99aada31e72caea54d115e73d1b1b63828a577a05841f7dbf81ba02fc13b7bfe9140f7e615170a6458cdf31a0140524e2ace2c06a879c4e69593a3651041d6d9cfff72ade42adbe64ce44a579649a1f5b9b929d1e394e398547bb4783fe1422483cd66b29e9593828aba3612928ca9f60d23f70c4ef6fdf1bc1c4ae28f125281441ecda19a044f270fd1cac404fcca13a3b49d1e6c7de60f902bd6ca27bb20841930091bcab78a73a44d2243f30917de691f1f9fb27857e85e2a2d824dc897560eaafc57cd45634bca0d272667911e6c1b151fed4598159cfee7a4fbd42ffe5e84efe84ae5158c5b8417e2e35cc14b58585c7865aa2f76c270db51a7fb3fdbffe3a7795ebf0bfe168facf2b1f5b33f83b921116e09d6bde342ddb80079f5b7e22d2e08f2ff01b59a00bfbfafded92c9e4e0c97098a855689aa33a91ea1f3293b140635436df177e5092852c5a787359e06d23fcc161ee81cda5a85b485551b8e780db9e75378fa38584734a73c158739f5b0d4ac71cecc2111e33908be490c08550540927ba217419ff085c773b5d81cea42bb9b22d3626c59f2c2a943f6f109dc341bf300d4c280760178de8e4eb8e158b2546fbe03494f8223617253cf9537d75cedf031daa5554748080982ee5870167b06b8062ec3180845cfad5127349a6d0ba2357cff6b0e76335aa6453a5ae92ad00fa4f0fe300ec7c264a2151fff13be70ae8744b4bed642221a4e67c92291bf5002572c636cc496ce065efe18ba44e8bec373bf259e1c060a8e47388310ca9768b2099df2196db16cf4d2b02bc85478563239e5426fe28e96d9ef7367c2eff0cd2360446743c47713e22631a07725b387eefe383ff9a7dc422f92dd869ae8e4f8daef46b9369026be5ed85c457c685de42cb32ba6171a1229127ff15220ee4792a8e7436af8b8ab08a6d2706ce2c69de8af0d0023d2bdd1bcff75d7aa6ba0ededd8dc6c10395fa6dd8410ecb42183a58e594a3f27fdc0d77b183932748dd38c3e9ced6198f685d4331c7d27eab138a8942246abc5c26bae0b5c3681d0e93b1063bb65f82bcaff43af8e26b08cfaac1cd4b087bd7de3f2afa87eb04e7389f667499b93255f5e2e5a0ac8dc3887b17cc85496cca0d2dc1a7500529cae3adf93cb14e1fef88bc6627b37e562c27f5978f66af4bdbe57843f9926d89ea0f6fc55409fff1d6f4ad728f6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
