<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e61cdfc5cc22a58daa3c1d5b210547dd5c65dab73e24d8636d30005a6a6e6dcfc5a4bb80b817495dbb9d846cb988a3fd8276b9b82fd40405ab922e223f5d348a7aa350ddf40ecc261e5be45ef4b91b0193483bc78fd2355af0be5394e3c1bbe22f08597655c266dc06c721404e76ea11d0efd19d97fba37af91b0e4a1f40f4d307a8b7b97893e9ec221f30705b6ba48f6218f45f936793cc3b01a2e0ae4b24a214c505b88129e68747a7434ca9f1a7ef6bfd73cc85bb5c725e3dc3961dbf61fc358d0e6663f6e798b53937a1f158ed844548a5aaf89fb1a3843cd20a535e07f1b77d5b6f2063356297d1fbf45d4e80862be9bf67571f238e0f1eb88df7ba35c594e5cf2192890508887e0144d7d54cb3f61bf4df5054760e4e7ad837239f1e4bb8990fccd89dcbc2639a783b5df1871ba57e9b082263e0044821ca9747ab046957bd22013f4b20ffbefca43cda51c7c4dfc1445926f60a36bfcd2ade6d3934ea2a55ad65986281c8b24936f6daa4e97ac6858306aa635ae1e98c50fdac613537b7673731aa16e879f006236d0620291ad8dc71afe0911546d19a8f8f10ebcc8693bcbb61266a81439b9884ba497f2e09b1b9c78167a9432dc28dafa7e3b2619104f0c184cd0344d01bfbce108c4024192f9f4f07c770c1bcc753ce328c1e4e11102b94b4c2920fabf5843c35ef1b368c9c5c2fdcec77e6bbe39c5c937b672df6090c0a8a465243e896437ce852ae06f618e1bee205512b12870c505631b3e0e35d0630fab5e2115e01da23fa261a311d4031860a82cbb7426b4f3fffa5839e0a1e8bbff5328e4a23b496f9ceeeeac47c549e95828d95c18132c3bfb058db859af9d8973ce5dfedae76f519c161256f60e78fd3d13c7fb07ad5800bfab0ac65e137b1f82bc819c6f88a592d8176e70dd12e80e4e72bd15f534804ba21787c9f374a6a939950187f56702571e7988f12943a4964f1caddd71cebd8df993d0f141d51224d8ff8bed0b74e1f41c38538d8fb06972457a954371578bdd0fc94ca9697e3eaade7cbe9b9cdb826eb4c974fafc9c6a21fbaebe1317461125634991b9838386fa8e2c8f3259e4c3c197cc4538b266eac4b60b9b544a07af01a90b10bd32d560119d0db058a992e0396ab5c6c0968d01f6f37b82b41cb1b141476a5ebd104f8adf070c6003a6122cc49873a2fa20d18afcc080d57f909dd5e11a5de96d80b99df930cd89c9453c0070a8a4b8fcbe0d91f6ccf199698d61d40382a41439f5fbaa44455f8d4169aea1209b9f7e34a8b6b738d5ac87f2cf92ceb190832fafb806b9d1899d316538e2c7a95bbd3e30b7fbeef2f54e5aaa55713a86d138be0e99aedb31bb15bd4e06a0873a275e1d0964984af0d0f7acb565fb96e8dbc4c03d48963558bf3e21de8e644188da377aee00c0860c2f93f91a6f383adb4687b35d4d92c45c60ae2da065ea7194868d3c48a7250ceeb64e612813c385579a5e765f70a554899f6c84e93e3723bd835d5ba1155d0dd53c34b74b6654cbf3f9ddc092e439ab47831835980dac5ed60539aece9c42a2539046c975db18e9ecf5b193a91d74162ce36ff8246cd1d1988c58b9f6bc5033e9fe2cd5783eb1f733d9f3f7846833649a75abc73be59a01df8c4fcec9f819aedc526748d11bc477773503c1aad96165cc5fd4efe77f4e187b067e3fcb59b9836ec369df65ac5945f5c39c4b8403a8084d77663728da3c92ac52b2a558297a8468e7ba42f5141bee1d00b577858a2013cfa7979d558b98b399cd2d9522d5686d8736da13a39a37baeef32e98d6284fc8d583bd354f78369153ad0d1d60be8b768c1d3354b3833902662a43c4b13d80f3866c5ab6ea8f0fce97fa27f90adf9d6be94451b86beed6cf7671f4c3e32a94544cdb07e170368017669da633d4bf61c4bdee7fdfcf06c3cbe2f22b75b68640b33327a9e7c54096b04d292f5954e89604c5ac95ff67f86ac0862d7288bd4c01f534f07907957a053eef0a8062bbf0f1f5b3f7a246c65d2dd708725c224d789917c0d390149f5a5e11e342144fb66183a759939df04e87e904908d1850129af9420d2091151a0d8828fe1f15121401ac30b13f5e95aae3d9cb9833fe0c1dfb98660bf73b12fd622bd51e9269386103ccaf44a9834c9c96dd3bd238df93d7f71ba2e72b955d5cd9a0131a9c383308277bbe18c4def4f2108c6ce53a8ef2a93562406ef53400e1c76ec4d0821432f1d8e9b4967ba4781f3241309edaf8a92e7855910223de1f0444deaac7372edbd6e3598312ec4bac12fb2002109370350ecbcd013e0c8c3be6fb5fc44a52cd85d8c622130a01071f0749cafb64c1111d962862d8d22679a92170d7a03d6fe424b22a8861a38278809524e6c179cc2fe6b506a341f644194e381308dd185babed1a5c43e02278a77dbac58b20c96b77b05493e6acbc86d8c46934fc8bf19ea988ff9f9de0c0de0f6c7e64be9ac4e84a5cbda067da60f753918c579868b827f8d1fd84d988b9f9515e38ffe78531f085ac55c35601e633f613b07d5626fe09878ef61f7f9fefad76922c7f9a53f92bc92aee4b2dd430b018604a102f7be4cd85a57419fd6058bf2f74bb5d091fb48b1f9654d984ff4e3fcb14ad461bcc7cdd4aecc134ddee229bfefc03565c00fad03435ffcf0a996c13f007490e0709301481f896d4591664e71d739c04fbdcaac48935341a9a21b4b2020258d187b341e3758761d6d356a735e24ebb41b8d8d185690c66219de5ce2ccb40859e0421ba061fe6c255c26ac64c1bc17838df4366f49737c612f668d1135c2d42eba366c77e8d3304baca10464146ba341712743f9474b995f0aad2583ddcbb44a1cf31e72a891f8c32d0c76119195a032a53966481585a42f224d8e31ff29469bf7896da70bb923dd455a494bae40197daf71d66fafad9d11ff473dc555e23dd982ac3ab9fb2e842be4f5e956c01aaf6d9116a109c66bedc9622aeeae6755fd51c0192abdd6f15482b2ce3dc05e4bba2d542f227cbf99f127dd86dcc7634504042ecb2b00883d295b252be3e37e6921870e16975b663176ac4a5e343e60aab75d7ce60d350a1ee3d052ac68b6b7c3905588ad0b746ae36ef7575ff8e9c53c7bb5a96c5e41e12f3ddaf3eb1056346bf8a79d781e9b54a58e1d2a22a69f4313d5f74cd3441cf6b89e075596e2f19f6d0732cdb20d982f463927647445f9aa1ec2831654b2e9be25be71ef3b02542e959b6b9e83116a144a69d3db4ec2ef67fc7ec30ff37572546c3e8c80b8f2b73b7369b177fd9eb6857481603aa5c7977a5620296f01187d6616fd03c34640026367804df00c24aaf65798d89dcbf256d5d40e7119e817b68cea69ea4054fad93051445abc541ee0eb17633bb9d2baa57868382c121c4d52055bad8b989c9e995605964e26fdc792c319a00fb0e43c2056fd81b47e4812e2140f1012f74aaa5f6ed38748b757b8f271679ae23a9f8fc4beb824a2408b6bca48bac9bf7c4bb3f585f733a6f081431a86bb13680f85aab620d0b0e60bc3e679cfe1fcb78a3db007e7bdc5cf44daec89202674f97a9509012da37da2a93f114f6ab9bc19d6405fd0310675c8e461cb05dcb0879c6686e9c914d9edc4db4536a0aadbc13029cfabeda8e096578b253868535b00f2d5a480d1c480d19faf4c390f63a4a33414269adbcbddc79abf3daa92593457c40d32a1b2bf21754230b6d0b66fc175878ab5e2689e3494022ba066292a20c394eb0f72e98154bee9b729ba2defe13700f07c72227cc64e8efb32a0bf490bf7e93d326565bdcfee5ce968fcb0d703914018a854e4a5b731b5145aaf449a037e28b258802fe44275569f04e420c20e447e379471bb4a532aabb5812e95c8c21a1346a719d97c7fc866e6b4fc29f8c203bc25d6838bb6340c7962b15c58a8a51e306ddbbdcc1f5652aa4402578d1c1b47ecbecca571268979ca3cf96826fa878ae65218bba35729a9aa1261a880532f68f1217bc2c8f19594379efab28900427b159954628f01deee6dc5c67c0908b28a99ef83bed0040ccad8f75c1b532063cd862591185905f7c1682e9fe9d38232675a10057b253228465e7d400d8cb50d11aa121420cc7650ad63b78b82ecfb6cbba4d283f0a288c0b505a7a22805720fe65996fa0d1d5d9c35b945df269c4476f3956b5e8c2f600851e9b136f4acfdb76e7633e0c635921c6128a755c6b178d870988fd26a7c9dc41df4241b2d64106deb3fa3c69d133f6b2c16131bd8d3092a9e7bdd0a1481883e6b5e219fd3d466d7b87bd2e66dcd7a0618f319893715eb0f3ead513df70f0b146da00daaed215061c8e499abdeb07097f7e8fb9fa13d8ba639347109497c91e88e6b699199cbc43094ff5befe4ee9b57dd17191055e63341833460cd90cc5588d7eeb92032c6d486c0d325bd991a7134bbb6eefb452185ea096104a7ee2c81f88d1844f3cee657d4fb041b22f068e3e2c843acefef33d15ec1bd6d1fad2f0203514d26c4d7dc6ad425602960138ba91111e77f9e21644de68eb1639dc12526c5159db40807d584518b50c34a7721ab3c7c214a26cbc8fd7b60b24dec2f59ff2f5cb0273c17ae07520341244218913d22a2afe03bfe646db904170b883f18324b7422f0411e8f28c6d87be8b8c3b41a3cb1338073535436a10ed6ccb09340d1988b6fc3b2f519e144cfdec962a32e6195ee23d2d7d0f7883704f98765e31ee6d96bdfc009c228af52c9fed47a1df44d3e87074d2ae952ac0011716613f2eec42543cb0572b958b48f3de21720fccf221f22181aa8f80e512cee2553990de705254ce7c12bbaeafe95668c635a7f89df686464a60d1d7e35f14d0344036a054097b868f49e521c6b1950e0b82a849ff4da743944f31a786205039fb36a9332c93066835956f8fea92db0999b710ad35aaedf2a97b46ecd8ee487821553b7c3c4364df9d299cf3dca5bb8fa7909e82f919d5bcff1399ec4efc0c64a4f9e40f37d8984b590fe26071ea1e8f8580c1578001a2031cce72f5ef702f08211233655fce1ed4f23f075be160e17ad20ae3d1eb29e9ba2ff4215df806e9fa91c62f336be7e0bc35b387a7af86100cba44bd4a2ad5d6c424cf7094cb64cc90178e6631df47150e0888910728f13c6ea811cd57164d0931aaaf8c5baa2dd1bbdf64392457e3b80d51ce0698c94bb1678ec54e86752146820a600cea4f3833a8717e31891998b267f28c237839e0246c2f9d8f715f94b889963de2ba3ae87376843c3a5e01f4ec92ea70f3891b2a848fe7934e3d3183b5ce498ac39cbb2258e46d4c4ee1cf4e4b88b2d46d47666bcba5fce36960245d5577f951df485cb47b6d1d5969e8524b14b6738be5f0ea80bfb494c04c7f818568eceb7d4ed23657aeb9007fcda06d2234930b361abf0f3d252bec79942d86dcaea541e2dcb23c68ebd5b2a4c677a0995ab60995196c41227896d04bce73cf827c8f1eaea2569e5fc67573a6146b52515113442beb6ee1a087b404f6ed7cc38703255daf12d835a93d4538ea15afe972ca7e8dc41709a1cc29b6dca965d8b014c710f1004abfc4a724187b29ba7bfeb5054fb2164aa7485fd1d9268a6eb3653af1fb4965c034794f2c13f49ecb3c0d33018f8f73f12c633799eab0a0afbd5aa7eeaac2fa9cc502b715a462510bb9f6e7b48e99b20e65ab3455444756f3737fea78fb5128c33c04060586c586c3602a05d69a2e6be9f0a6ca1d0da09a64e90c1daa36b16d9d87122bcce732e0d879c3af8bd2296cf8f4b9bce5bb2ea7061e8dc855a7432f15436c57363a791c97406e4f8e4b6999d901a328d09fb56f3178d81b5cb35443f3820e0a0b2922044b3064e9ccfcebf2f7096b555017aef40d80f2544a185a20b50cc5a42a7afbcd004cec186c7eea30ccc2e8840bab96ef0ea50bd555be0b995ace70a8420db330c9136f5be970a8476ef71518b987747acf724c55489099c4ad45102feb17fa31e1e48afe10cf30bb882faf5a63f872db7dd81b79abd2a2f452b53af561ecb75882dd41e0ed47035034bc92f05496d353aef7cb0dab252e8433d390c729bdbf35e93e4cd68d74d2ff99cce235c01c219dd8b6888215cb9f5d5c4740a9926310f061984334c8c87cf170cf9faf6c810450c46b2f66c7b530dfa7e8f82f5e68ef164ac0cf36a6c455c1673e31bcef00ff94893e85a87558a61d89a8f5e22a536c01cda01d348d747856fd070bdd7388347b1b7ec55964985501c6cad103c1e08bdf5a40d91b3b09a50720d6e4ca45fb7cd7d259dcf94975340d19884f66f7dd2d55add6edbde9f14b3fb9a740ef448668382a117ef85240e09c8d2cb5990c65f073aa5d7e0507e50dbcb5d0a241af88ac8047526e6f318ad47e027c53c27c6e3d9e5ccbc7f677f7d0e7302db4c43aafd356a504e3963a0d892393542a4b69a2a1ae3bb0f726d456de97fe0cd23397e0a505cc30d68c518aefe100a69dbdac28986ec55af5c7a04a7cbdbef46de272e4e4069ecaf0251d70c86ca3227a4f38ad36fb4234e30a2c149c07275d57cea65af1e8e530734dbe0723c873dff40bcf995df27891be2d39c5ff167e28d81a55bab0c20f529b1110fd098781c4568e683712a836367096737cbfa29acca06b3a8993c3519281f41074245694bc6fb319eac4c22dcfb77e43031eddff36e7a4396b72454f21301bd595a5a67c3863ef7fe08e6ce00c7d87d71af13bb5a1bdd89c947fa47821956975fc47320bbabcf7554b734ecfe3f984f2674b59998b6e308c3795a5daf33e26fc24b96fa8de81298a83ca188add9162520b73f3aab55b1f5a97b421f157e0bcd6273dab00a376138e3b1a6f193159c5133c47837fdd6837b079ebe9c784ac5571f7c0363594fab23cfb22bd44ba0eab953c848ab4c18fd77ac806479c6661bc50f2297b45f5a29f7737e129c7c56727b4eb5d1ef290d186e1f159e3d7ee737e2b8ff3b537d337054f8ed2151df3b59f9d143f88f94ca4683baac296bfc640a0fece527ed992908d467744d6df8f536e0407f72427df5349d6cc1fd5f194000c5995daaf283f72d544476f94f3cb069291c03857b5ae7d319874190e7491958e7cda0badc519a7437f17be45d099079959ad30e561b1b396264fe116be5de235fc98d08d2dae84d6cf0d2d214ff7a71481ceac20df22bec366cfc02855294052512d67c8a6c4cb200d1e0004f481c94af162258082cec842b5577c1c139cb30d7a580042b48f8fc5483abb560c288f2633813156ccd4c8e0b684409785df953a064936cac0266f7c14989cf730b52bebd50729f4ab91bfa4a423d194b9e5cbf387eb57408996da107d3b26c86af6f143d79d90908c6595269dcd079e3305f68074d54b51f417357d628ee6d8be12bb1ca2702c54d9cba34db4e6e2aa3c7802d25ce421e701f5935b8b12cdf6bd1038e1fb8c468f6882a976b78b6cfb1902e06d86c39cbbf5063eec7ca19fcb4dd985caebabca8337dc95e5092ff20b9eb4702e0f5ecd7785e0d7eca94855c14fbd08953a01f592540269c8f3802550141ae6e281ac99fe68b73a72598261330bebca95b972049d4e10137fdd1644c676aef5197f0f8e1d44cbf8e0b8e3be7aaf9c42bb61d60cc89c3cb794003c661a407e109f4be435deadfa6961c000b2f44837dc35e6529c06e157216ad2532b88b82246eb436ea5deef09818c1675cee20c4a1718c7c56330ccd702aac3402d6e0d02f7bcda4da87e970ab87ae118881e4afaf513115747dd59a4156445a3b0db1e25d41ad388626c8d215c891c555630f2e6d051ebe0be9dc0e5db7e5c7e51e83aca7e19a0c3874b37a2603e93c8eada03be67d749db35df082d1c3192f27ebab90ba6f59e518ed395bfd2a6bd367787afc50e13c8f9f2f34dd265160f07c6efcc0518737a1d544fac277999d4c3d14441a580ac9cdfc3fffc6abd1ba294faf04774339c1bd50a688d7645e8bd0c2061ce37022c20e0cc0d835deb19c3c5061f09f79d0ea1d936666a8eec89df5234bbfa181819fbf32557faf0cba768e89d5bc5f16ad4c18f0bd5564f0a7a685a98c2a9ddbd2b2fd58974465b59a040c6fb6dde5a41fa0cf62d8148b28c84143eabaabe8e5cedbd0a10bc3913d96acb8df331bdde3f0c4d329c17d83ded5c3cb021fd3fa5ad0aa8d31780a4ec84372c3fb099603c7e8950a875833b9524db677594b706d28d017c38c97fec09763dda87fd8eb5ff986ffa200b92319618fbe2a57b39a9c8901d4d63905e65a9bcdcea6758653039b9fb5e60abfc13543daf0ef3d617eac24e2a983926ed394fa16dda0863934867a5b97889421f2ab2418d21ada8c6a7dc24abee01918799c581db061c8ab878d7b6e4d33160fb073c5b11612765d00ee705b413bb556164be7b049d96c210b10ac05c7b575d15388c87513f376c969c1233d98a2feb20da7381cef9e4a595ec7b9b2b2ce7fea52975c5ab0f4e0896004866d729cdd968ef6226a943a28a8a887565446b5330685305972f3110d335142bf79495185f891904e93037490ab90a1038f14214050ecbbaf7d1060c4861596d18f22bd690fc4736b28c6c1cfa23cdcd90ae41a3cff20c136ab1b336cc81efaa40de89465181ffcdc0a7d78c0340ca7dfe2a84e2a64f41cd911466b487564d84161a1f69aaa78e7a693630a12edb03e3fe3ed481e3de2bfa9323632127405aa8026a970180767218b32ce4ef7105ea3253a78546daca8bb8e7af23f1c3a1105faa83fb2519fe724854a187e2604b6eab24f0d0875850a0897dd3210f3aef71aab20adf6c30ff1a044b773b1c81616a10ad7726c628c40c6b13dba52cd706a809575d1fa82404d66e1c79834102fb8a17d03fa441ee4cd85042af388ed38e30b865277ebed4f20a6d2fa15383e847406a8e812713fac4268504783833d7fb70a0550e11ff8493da70c593a56bf6b48875dc36f97e0b8b9cc1333939b06622f65cb7716b427092bb4eee7197a3415a729414214bb8730f3b4b1bece9cec1780f2e93ad0e6876e7d2cfd864d66585c00c2d57be3f85d9530ac8ed312d752f41e143c127d19e5a0c011ce73acbad4ffb308e424f630cabd9af03cc13f3c9960f079651903423bb431cfccbb246e9c1b8f26a47adc48f5895af7c3bc762813290a5011c8bc4ea5b8f8b82db3a61eafda4396061419236c2a8790fe49f25a0242d9092947abfbbd271dfe27697e5c402eaf2297cbbe93033a88ae5f948d1780bfd757e176f2866866e71f0ab5380df3badb82eea69a709c5987c52ff1eb1d13b29ae113cab3122261d21a0755c28a7a84e9aefe38c3aa17fbf799a06c7839655b126ef2fe1c3a0d7963aa9dd9dbbe1fd8bd3776608cc29d112b598b759a87062eebd0dd19660e811794d1cfa79454c5f6bfe8b83f25498c7c00590469420b3728c86c62d042be93fd4cd94b2709658be8d8c7cdc2db4f69f86e8289bf77bfe4e93e03558e32368d17704b88cbb59ca38cf156b018bd9ec460e6367fded26661cfea7ef40021f3fd59e7dd8e902cbe01e7d8230407759f2bd9065e9865fc2a757d0e484a6be4d22873a211221794a19535763c02d5d0012e3a621096f48937c3cbf976cab5d1b6217c99f7f58307632e00f97924ed41626199f6fdea7aa2cd7a6176350cff01dce7b334f2e71b88be41dd41ad1e2c5f88f40b09ef8031f450eef72a724e23e4d18caedc1aea893552eb1e146555076d2f56bc022487184a8f6f9f9de6e09ca410f685e13d1f58fe9b6ea78fb788ad26b3a4b8baaa085bd84da7c1cd35c317ae295f4dc6075bea17df1c5d005d097214f0fc95d6fb7594900bd3e362a8f4ec4db857a02aa5157519960abbbf60bf42f4c650d3755734e67b27b915ee35105be47b5c4989697e753312dca746bd13f52c7db48a136c57cc03a63a60e07a08f171b016f36b188841d6771ba9fde03f8f842b2477981e9f4d4d36c099b33f31900cafec84a9d379a956b256e73abb05943746e5e88bd7fe1eeefab2c854f25fd0ee426ec6a16c6e9d4d85dfd36c0a422738aaa91b0033fb2194c7a3f600ee1f23e10c32da11238326a32f13060f74872a7dcc74fe08d8277a577836398a4ea29e7027b1dc549eb6f396d668a9d5b5a2f4743b367fdf906b9ab0e804c36ae233eb3fb9f9d3bf8680f1455bb8fdd6cdf1b130ec81c32772ccd48a13eec27c6e735523dfd087363b590ce1ee533cfc0c58e42b5be27ddeae1af2445fb8056b4ea6741311b25791961c3858405b511023a267f61d45befa1b8150f1e339c3470717424cce255975e887f297048acd6f67e51352ae281ff4da7d121d28ad62c0c63345e49f9d6e352dfbf50edad9d3f02c166ead61ee6a2d5adbc10790477e32f0332bb1f39ecb6d8ff432ceccde233ca0f0a7ac81bda4029be8a24c877565b00b6165beebd53c9582152c4ee2cabcd6dc88578e49eda93ae0ab3b2b9e17e855da2e1c65b62a55def6736f666898088816b5850d06e6799803b201cf5c9569d83335f74490c996a52db1a5db4105260dbb9311e51f25f015afc055a3e6b6f476b2f4fc0fd733875b378c8af0fd5c419afe8398cbcf641457cf39867973ebe491e44626016ddcb54ce0e590067ded2a0ff985dd5aace948b98ca2feda406cfc91b04eb984f8536d9c734a884a3a63dc7a3468068593fe0a02342fc9747a89bc55d65914443e78e0a5279a6ba267a04d8404fbc9a88e24cb5e666c91345eb6e6412ddcc3e39eae04859ad70e992de7fb1a39034df36573b38317e4fec91fa01a1c73f7cc1d42963bf655b33c3caf85e486a2f5bb5db11f7f77b9557382d7e5a3d96fd0318baa7775291dcfa0e4af248cadece664f6b665e2d1266452cc9e81838e0d814bac574e92975c087895932b2a12b07d48bc2cdc0b57ec3e0997f58cc58c70f0be3723ea3c3cb77eeda2ae922d0db70f92830e8378cdb958e0d5d9735eb2761dc8036f0df07d738841418d1638add04fa27df10eb050c9248122941333c99befdce430d3775231efca4613e618f7083b091ad443b65c4fc971d75deb288b37af3933f7bb45be6fa2b7c53fb2c6cc9868b951b3d5f0fc7d02aed0efd16ac898c4e151079b45398feee7de7562c97e411e0e8430d5f8b7fc06126fd2438faa58b6ba3f967857d1104b0137cf5d9f20315bd41ece954afa265cff4ce9c7db0f04f413ebbf29b060f1063a47607534185623d6950f7c5029bc1be16cc920f949707807eeda19c594ce8cfb42e56f661b3adba33694b7fd15d6bbe778a201150c149bbdbefeba1fb843c1979d95b19cd285e88f898fbdf5a57781e72d2540da4af5f80971c26c5c4f0bf81c2987c810b889fc1a525e47baf152ca9a6238e54c6f497e4c1f9fd26c455f06571c97c357b99259efe593b6c031bcb3f069f69eaa2b82e6572542a2baebe499a9dc6361e80cbed74acf6136593040b15134c8a5acd4b6f26e849d35b7c5c78c79d8d6aee4059a27a658844c66ec4df2357d832103bbe9a78b810710052f0fec0df19291d85b665cd1d7e341e846547058152ed4d620074bdbe9867bd7e13b35ca95be656334a71748367084c5504c2dc521c321cc65ce1f3a8699b2e80f68f775f86852e78cdfc863284b5c123470aa5f4ce764fb22a4b5567b6c663e6c8e992fc5c894cef2837aecf3de068fe5db4e5712be6efa2f486529e926358707a0aa148656da89d7b0051aa9c7d748701c4433de6f364a091a1fc49a3afb3eaf83bc939744790e87972cf31ebd92de963ea04a574c4453b2a0209033f36fb6646d3e844e265846d8db42f2fe0b776c26ce0b264d2290a8519b3680daada058242c211bb14edc5bc4c1bc8602a58eb5db0f7967bc9d291f5259319dde618635377c876ae3eaa3c6cfeb4381508d7792e7e66170931e59d76ffd3ab01777eba47ca9864006f6bd7664edfd2ca666ca819407d6aae0dd212283c6cdd235cd58f57de1f5198d2f49003134897d7ba6278a53a380b2c7263272c7ec29f6652daa60cd6f7df1c115f25fb52e398bb93fddf52420de8709d0477634194b4fd3e173ddffc25228c4d76dc3827e5229658754fc06d438f763f1a0d0cae6471e3d9f3bbbfc5c36638afd4fcc4e91b40b8c499c51bc639207a68311b3662eecc456840c27ec38c0e1e5e7735843f66b274d9d83f270a625030f60a8af27cbd58ea94c245f546b76aef275ebf939243e47fd0eb83be77e000db573e2bd8cff1f930bc90d28259dcc5206f6ec8bc5457f1cc7288393acdd0231fb7e14500ada74a32fb45687cc5c7eea447306fbad45c9e2b0fc59abf1c0b359e6102bfa5d8e05f2da33a664ffbf8627364e951de2e81f069944a004759730d0b3704b3afcf56bc3c4f72da85d99ed871de25eb9f08e7a65ceed3948f80ef3a1372eea9a86392fa34ff4f782b2b45e2a229fbec4cb5bac071a95017c9993747b50d825ad238f17288e4d11270dacddc780c3bac0e54619e8ddcc8727f94f6dd66f94870d598f1f54e5719bc345fdf855022e7ca48a101569c47d14eaef3c85c4e3a6c1d05a56aa7b81461c4cb2e52d2d0ed8da836f650ce7ef99fc56dfbcd8a2890d14192055e6d6fdb91147e0adfe7dddf87d45c7cd304edacb2a29092e0a1d56a9dc205fa363f6d2ffa53c8422c99168837b380077eeddc1f27cd3570c4dabc462c1748cc1db544fe9d4cbb77fc34d0a000869a339edc174e498e191459b2d86107d5ab0d655aea0ff83ec658d1be7a08f01fc30b3061f0d7a007ecbed4788ff906aabc3f647b17131f4924931f521ce5d88b1d97a85fac455ad379bb918941ecf676e2b400bb1c61b0d1f42e9a566a887034e32b80c44647f57a48556b178dce0b69669d368dfa8cf7952a9b764bdf9ffbc9fa4eec2847ee7df44cd17557ec22397f20d752b8909edf6e68e932381cda4b8a1f3f486e9559734ba8401a54cf809c86d92995c6d16e78ae86acf44a8e1202a7f9b23e215a0bbaa0721bd1813b5717098c7404f103012695f6103e93303e18199e3213dca6f254192ce0d9f195e1729470b46f8d588c6b89af2cd3cff9ebad26e4a3faac7a87c14afffd83202d182967d12783ef0c382c9bc959d01590f5d57636461cdbf15b317ea04ef1a556e198db90139dc70ddfa63fd57e49357edec26ee0780ea3cb7a51f3cbd43180807f0995802725dc27c6e6a80e711b45c5092cb9a328f01c1323f2a1b2f8128c932171c4130d2bba069994f6b9f58cd509e13e0f3ac327b145936c677ad73cb9b66eebe6897aaf808d984fca59cf756e5b42b95da642d240835208b17697e2022c70052e18b171d8e97e9bcbb3f1705c0bf0d5607b6d9d6a0527779e412b5cdbb788079f74215dd787bbf64fc28438831d7e59b3a08158845fc9e1c729cfd24da8b12c20bab417c48c83ed9364ce5eb0b7c705a0ae4e135bd903d8109832b47c4528d8d67f3ff20a0e5c7b1aa2c4b34ad3b11e072d272e522ef00150ba97457acebf7a80d3f79e09a977afc304095ed80116b81ddb9777a6083de482b5eb1a692bda5219cb1c39acd63a7e2e5def2071caa74c77517468ec1ee09c873eb8ba08d83c29772b3bdf9eab6a1c22702fdae4107246a976d843e634fc3f8b76771e28a2128bf3b3af43f7d1e4ec3722b697766cdac37c839dae1a3c2c54e35025a4c12ecd213bfe986a49ca4dc95b7511c0b5b80b9bb3804949616549a13d577e11b3e80217a4851f36b62f12f454e90fbeb1a540b42ad6982c5fa9bb66b6a9e89730d91415ed0edad2a8da18f45686311770165dc72e3ca8446cf77e9212f40cf8331287022f887c9fba865742bfefa5b68376a075a4b21629fe8930ec623a55c0e3e866e31625c6086657192479d1531d90df9ba307aed4042c0a960cf835ec4677658b900f1c50387785311d67efabd735873bea673b265e0c3498116493278a80491919c9acc7ac6e17abffeee557f42c9a2a2e8ebe2a2c8c7c40993fc6ffd369f6a8aa4db43c49bab0ef88d6c50509926fcd7d83fe2d98191d1bab2f143943787b7f2112bf19caf095353dc99925fcba8ce62882b285ae7ad21891964e0eb13fa845891daaa48e9c44accd64c1dbb50ccf6bd8a602934f8541aed1c65b66525a6f4a9b1b3b157706d5622c73b010fb40e1bbe57cd6fa41a65ec085691861a919c3b888f9d30cc233aa0f462e50f28df4c856208bf82377c0925f370c30ca9491bf3b380b87ad164887ee60aea70824a316443d6037dd48968d8e953d2781038c8d856154de0e958be7d6feebded7b49fcc3f61e81cc3721a86f0fd2a9badfd10f78e0ce07204c5c371498f286023474a2801bca9d8089e2dafde9816357839bd55c0e1cf8b2b4c15439c56fa4f35bff5a64f2143cc664b68d43d59502b150d3d8dd02d2193620526450169426c7636e095d4d279d8eefcf79d751aa8b805f55edf14931c39e7b0599eb14eb4e5bb6947b7159e4a106a4bbccf98d87b95fef4f6c1491763d5db79d2d6d7a0b8143eb1d29f75b9e0433a1652b925979cb9a7f13fe1b4a91e48402ecd22ad7e8f9b1c27e5bb42777e7edef8f7bff65f48c59b34a1a2950c4a9483fdee1ac43f3f8a49cbbf8e6460fd1793ede17756ee14b3536ebb001ce1a6d51ebf5dd0f52793452ca4283a9473c778ff8f1bc8c340199d33ad27209dcb44769296eadb805d596dc39a02bae5ffd31300403d84ebcad237b83a32905fb89c05d2085111140ecf28c990c60f65350a6ae75c886f2526090590ba1143a32b690a3048e4caff05fe7b2db16ba79f4e1f8b0be10b02a31182ff2a5ae90b43aca8fb99ebdbc94014b83b701de814a33588b6d72ac519e4c3b54e9d19adf4ba906c17d537320021fc33c12140f9346b7624a78553683d92514a0382563d2f0dc3012172755f010efba1eb805590aac1515a8f2e8bd83d6536f7a2905143d4d58b0ccff44e967086ad1f70edc55d40d7c6e2e642cc5d725342a952dfc2ca53e7bca6d7a8d484eed2c23d8c02f27ddd5dd2d2d7d07e32964eb9973390a0828663f63e452839f143eee27404c615fc85a05c825de94e9aeb73a75af9e5410e0e9b161f78a9398a54bd5e3b969b44140b1bdb80f6de998c665edcaa9b972183ddade9b17d8dfcad353e40a5a781f88ecef3e7371b03089170014bdaf0fdc39cc6fd09fa2ef1ad16f34771cb62d1d5c12a6f5d299b0fbbaeafdb8c5e4a6bf1449dd5cfd27132089313662b08733b299e16d8056009d532fc29b343c596033b1caf70f50563a918e43a7ed03cce703c63f3064c1d3ca867b368e6c85d75772fa1a24b6ce6d6279981ebc86931a648c6cc3c5fcb5553f124962b47f0ac1390450db6f8a4230a5b61b8656a1a84ae5109d71c1eec2fe5118d7cf98661b610f36f5f5ee777d9966c6825555278a94efd91f60806b8f788ae7cb246af6c8efd0dc85bd89a42a1385f9ea61c6f98d5538010181682193d988928952a9ca52ce280f3dbbf8920e0f092dc79acbb2a4939fb8e9bfd79c8b740d56dfb3bc09e81e5b6dcb195ba4dfb43870d17d5a76f0cf2cef06b429189714180f08b9912793ef16af6a68437c06c1fb2eb168add35e3c9f713f99166d706eeaca7364f4224c12d243eaa035a0d02ac07c798954ddb9e6785475b4242a8dc1af7b6c9b99517cc9126ec6bcda3b14ffec8b1b7f703ea58da6ef45d9715104decfbad879bc88cb495f967deedb9f3073da665958dd79ffaecc5676a72bcf96751b06ae5dd9fb42144dee1c563e79c8b1d431f5fca2cf558735722c83cefdbcd13625050212f18ef05ebc89a50703bb4bf102fb64a0bb3265a1aebbbc719390f31fe7cbe790a03f8a0eef849c2d1fb32042bdf80aca160a7c5016b5e675374cc9b198e604d513b5702b81ef0e0276d6342a0f283ba9c5ee9312ffd7abba43e452013b4af07c341ab2b5b03e099f312f2d42c7f7ad8ec09ff77658b417b779e3aaeb55288c7d3cc1c3285142f3889e5d381f6c173132fda22cded42cb9e601edbcc246038516102f32fe54da5eebf794715fd82d824ac3f316ea73e9aa02b9742e3fae98f6b97682239409a177c9fa9ef19a9edf2e6953a3359776319de43e605e920f4c651b164e07a29b90baccd8826afb0c75c68748daff19745bbd71c06e1c822238b988ff72a0c16075c2a45c097a4491240d53d222d47bc35cb5f053ba10c7509dbf025686a94bb2152778ad7b88edcf777d686859a168e26e311b3f3f175eb730999756af6d1c6ff4543bd6b65658ea9a9f461c66a0f44f9bbad106d3431dc283bdfc379f34de84dc75cae001dd23d3e3265b5cb248bf625d0b38eddad8e499058b2ea52d29e920825b30cfc52b074c1089cd73d79d2235bfa4be214d2bd932acf24b74f4ba6a4026ef4719e35313d54bcfe636ff8ebfcd2e4f1b379efce9b5f957cbef52f1d9a302209510c31d5f81b15318385e4d6d92d996d0c46297d055b16767bac6c171288cabf57685f986ee65bd7ade5b9771761ef5de2db697d529e623b803d0ada4514e58424826c9783c72a0de51f519fdf9251e5de370e0b5ab595b671894e5ccc7a99eecde9a660b0df7b22cd535d5ecf5b768a8b6104ba18ca9132a00b6b9152bfd177c5dede5f5858315c1dfb2a3037155d8a94944bb03395dd5192486408d0a80e364dc1b05db28c2f9b2a762c856bbb374b693ab108de464562e8602dce23ab07c7d79051428fe61779b7304ebf192f2573a3b9cf4393ae7de8c61cb39de6ae7692d76cf97236d5acbaef853eef648a30855cac4f548b75a54db020df51307a25ad1a2c52ea15e7bbda32f6ddf550f706c3a1aff96086ac99b7f53fb547cbb7d0e92d34b009630828bbbf7786c05030b488f83326ce363e2fa66faf0b2d2c9938936634d9d926528820770643f2c47241426b24fdcf2db309b6d2913fa1958ec32c8477ffc9a1b7726d8ce437fe5b21aadcf8955ba17d752496d5f6b5ae2b987e1c00a6a91eb302a802eecd7fc17c7ad20b7f504af625b089a4564cc0da9a95b5f2dbc7c9b30606474108d905ed79c60180d4cacdf8d58272876d631741badbd0c5d3f50d2c1f099e02ea5e3791aaa7b41fd8c64dd582399715f3e464dd0815095f2d7a3fa58f6ffbb1448e68d20ee13f5d22ceac62e9eadec30c7e99c7485b0244dcc300d82c63d157998fe8f6fc5fcc3149071805baaf886bb7a8075ba91ae3d228fff2e6af5b860e4040fb21082dd5b320f3158e62c5988443d7d964986e8e8b31eed479a03bfb88461b19f6222a6fe851443095117b9b527ad63979092e740061842d10b9f14a9c991461611527b860a70f725c5208e5479876ac23a9e4828194923aad42c7042f78020611cca5323b3cf5f3d75daba13b91d4bec77ecab1e626a4fcdd0908bb4e2db690f566074e2d268dffb3a0c6a62beac6d122f6f2384948ed50e62534374f52797ad31a517e1a367f5eb110fdad03430173efcf15b86abb9f10765dae199ecc5c9b1687c1c494a52c222ecca33920962cfa049ad843216ddaeb8cb9c52a0e3c74ca00e84111ece34ad71ea526176c575d2f7a3bf53de50ae454464a5616dcee242b0c5c081a7f13e011c4f3a028c705164242556c493b24dd13568f7d7d36ce5905af5ef8a67bc3d9267bfc130862f8282296b8f225cd38bc0cea890ee946364fa5aa13158af712a170b2ca40b6bfad9a3710ee76f9ac39c2a58c5c12844ff5bf683a4b1b1e450779c6783c4d505d40e650bc59d90bedbd2aaac363b45c0ff0ef577785fe54ee5be09ca6b72c6616123e2b45a5be911f113741967ad2e76ea621932cf4c0983299b88ae4a5ef9f1d02106297acfe5861f10f6d78c3a1778c815f0e5cd4c76f991b71a4ffa02a05f9f334158e4e193bac59a57b6e810b5874c51f7969f8ad58a9f5b073bb5f7ae73eef119b1b4454db5bf9cd1851bea05dada0bfcd3159860dda965aad5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
