<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aed71e05e812ed2d17608eefd074bb58710913b335ee70279bd2c87fbaa39d9415852e97535eb95a68f00e5ce4d55bca0889ff2150dc20a2b358912d1d60630dc98ead0ef2ef0a3222217b8de10e6f441b98e87ac14ef0e940492bfb58f4b8cb3f0a54a9c9e3feea0f9df9227ac753620ae92963d5a6fb9928f967ff1666ef4e9a62cf1fe3053c5348fa3f6d7fb3471c664351108d409f5bf180245bd45c61969393092d9c6e80428748658ab36d24fc9396f8cda95e9d732bce866bf85025e43b68be7bfcb3ad9c75f6983c2c9d7e584ea8973065d86261b2b1d4b121ae2ddcc22398efd0d948783a95a99bc015e07b11353bc7b1f516f72f23584cf2343429c6865fb6d395f45f30e0eac4c5c3d1a33136944008f9371a81b8f9cccf485b4b7fd8855cc3ab7dcdf09c1ae6ec298de4e28fcc776a3d200ee01ca9c4d126ad645e017212c071d05c0d25c48a683d734ed4ce7c506d285fdf216ef164592ee0677f436044a5262312e09a283428a51d2676e5f007e19eb4317e2ae629f4c2af3e5343af6724b787698a0f37097d7625f25e1781b480e0430c22f08af6f647a2a51d6d9c030e6e3d5593c76d70cb6c0a61f7868fd34d0d2b4e00a5acb3a35234de3f9b0080bca8a1ebf0e4771423bca02d77823bc154336f149c83b62ac5190d70d8e0d3108d7ee86deb7df9f3bed974717a5227499896b985ac9595407ed46e0f0dce24303b0b1f3c7e49161b8eac1e0183432bcf133b2cf7deaa4879b9f137db97601645ee02e454cb8d01c107d2707ed8833dceb9cc04e8d3de0c795697510680276779d5b0f447d2811f5fbdd829eac49dbebde3aad07d6f0e34df62929c2827057c2951458731fa242f96e243bf4d53d8ed44d226be1cd6ce760a1366d6e44e008357af2fbc0eb21c5bf4f087cbc93a977dbb103b1da79df07c8d07ded6d7d1731d87853e747ba9c3adad2fe3c36fd10d894f53fa4dde5b604260b9338711f30a0068b6e01b4610f1289d74c0d019a9e7a0e3b80a9970290f80af4a154a22dfa78795851d2ec6dafa553804e2359fc34b0c66140a9088ecf700565fd97101aff1167512018ec8fc7e46c6d8cb978393ca60e23e1d0d9fe591f7c64df328be02f90e24fa8ff9d03a542583968f46096fee02268e8d6e0ce4028072d75bc1f02a21c90eb9cba010114a48a2bd3f967d699d62cd8712d974f87aab3570c662e01bc82982ada7a07844ca5bf7b70237bf2c2f1c461a243a715443339839fc1d0e5d8d9a1f234cda604ccee93dac92ba8f79bcb34b8964d5a3ebbdef0e90e3e17f468550158071e939dcdfa8fa6bb25248f66b64590a8984af95a8f7988c23051c336fae76544e04d4a6d487691580e17159e9b36480188b338beeb7edf32b5332d5fd215ddd5dd6b6bee6f17f0acb497ed1714e0b8b4d62dee73845af683971d868b514e840d72f96bfd95fb441696dee02e95ef552f9553ee090530d875e4f9e80026d9b66f713e9ff8e6f14a74b39831f0d842dcf984d825ce8df6ef6d65ad22b7821cf10b6bb887c1e07b12287f5672d4e571c051789edb9a51a52bf00be647916e7db9b3dec05cc9b9e7f6dc9a559344516cc8335f236f6da9f9387e3c9c900598a503a235141b7c1cffb2401516c334d66040923d1dce8e392965c6f83f53fbd5de10af41482ed578e4ee9a3f6ff5866d2bc9a4ce515a8dfc8cfb1aa60e6581659c59af4a1f57bd3e439c8bace6a038c5fb03ddf40642be6fbf68229b90ca573136a283f0a03d17a604913ffd7f6cf39f7c682bc38fb1caa055e699378f3573b3460ca8d3fd56b963a32ff0fe5bab15eb2235c33c3a624dc1d0f50dc471e60e10b2d6ea0470d4b04c186dddbaa47ddd0e34f87bf5e4c970da797b19cc93940f5d57bff2d1ca68867e27c563bad8ddc1310184c4de7fabf769e42968113e8004154a45f5a0b97444ef89c4775f5aa3ca1bf169630930e41f78beeeea0186640678d8e273b739f412d62e6d0f3e82006a8f27024af9cd96a812ae17f0a7ef3e94b3cdbf7d323a26f299051b0d0d6dab520d524334349de1a76cb4446da06ea5a70d8df00a2081f1fb9b2a68bb52d618166583b3f5279cfb2cb69abe916f45fd02c27ffa6327125069d4bc5509f262ad61a9dff1158db931a3de275ca04b67aa110cdbd55f0a586cc6e30dcfd00c73b26c19e295205b6da3832297ffc76d08c75364cab6496858b7074bfe01295b5ade9e2acebb6e312bcfc644059cc38a6fb557d7ad58d2fe663ef411200f38ebfc4a136be8632140ede69f63c4f7a3561e8c57c2e2e2521416a5c18c1dbf8d00074ec1ef33c638c38a1a096fa55cb7ce409b4884df6ba119d53d5c12a5ed1e7181a1a1a7dbd4471aa879aed8656ab71ca3375cbbe8fd37c06c47eae83aa30a572764030b0bf69f7be9756a2ce991525c503431154289f572ed22c41af3e380e8f5c61f5a1cd89eda581f03bb56fc92e9d86b221055dc2b29080b8df9eb503107cedbbafa08c45f35c99070144d9a3784486ed156d2e459b0c2d8a4375f586923a44c113ecb5059482b1f11c2c9f5b1e2b805cad78c7da231fa76e1faf03d62f9880059af72e822252a51aac14e094da4eae46317c4ebf166ee3fbbc1118920e3916b24a9b73520a51873b53e2aaba3561d0fe556f55fc40132882ee8e0e4be6edc96cfb774ed954789f204e9ed182825e299e715e679f3f19d66466cbc821a0717bf6528f9d5113102442b010f0a584e116fc31ce56be258948860e64268eec938a4e85c0317393fb53ec90e26ebd98dce4c9f2c7d75e2bc97ba814a746d9ecd5ac06734c79200b753fd162d15c38a5283f31596ecf6f10d5e07984fd552cdf5dd68061abb64b1b0d9d57171841ea9b1fc9c38951547201f5f42fe90483094e813b29498be3409dc5b26daec521816df781a4542223b219274c3e68eb733e481025b26ce9f9ebaab792b646877af2d0e40828dfd59112c2758ddc9d64e33110c419545603a3f5117a3933ad2274e88eb6de0498b083b03674cf6a00a630f5e31f3c048b1c045e53c1eb54c849588969767e506158cfec98df3c0dcc06ab390b7b9c2b00d6513cbc11d34bc3a2cae12d47ee2bd545b6aa7f4df0c4e05bacfe8a637acc464655d2a06ba3957cbd64a90d38d8cb8664e7c86cfc123b2510c9d72ed50d80306a044a983a632835c0f984ec00d47aaf6789a377a533e55b0b638749852f54a572dbdfc4e1ea98a07406b2ee6031402a05c2c611eb08175f9b6c76f1414884477218899190098f0362325fe3cc6d8f8346ac5eee5c89f30728586bbcef81b5814c6f6548ba35274ebb074fb4b22da6fd0548f046d16d866499f3c7024db55b3ef130a78db6e21462c15b9eef67db62da674ef6316ea9562c8db82831fe246de77a9711c4061718b7094cd1b3612036e4a17f5364c0c4b43749a4da332f567c2817636bc5d6a2530ebb40341c133ad37289dfdb82bfc06ab505cbbd523898bb27094fe6cd66dfd717ea52a1d8b484d7b154752800f0a58f225c0e06601dd93adc80bd531f4e40ce7c811010daa3730db14dc7c319135e12229efea90869d287e31a48d3a74d69355cb609d1b26bffc76f58ee76dd86579c091b73389174c09b6a0c321cb962ec14146dafbf430486087e944a39c0c63212193f42d2f4d7b804b6fcd1f28d090af8eab4c7b44dc9c9dde0cf7218fc8e6fcb3d288c896ec955f8a46f2171c03056230cc5f7479626892ee206f5193d1cc91c82204f97b8e923151ef5c0fa196bd3d27a5675d59c5dbd831d8c637d05b674f1f4bee9af530efbca8dcf78656fc9846297e1dee87b32c1620fb6d8ec51b8b2eb4a167ef72e7ffd11ca3e3a87a969ad9518ffa7f883332d0255dc6f67bba2006a6a85d621a6fb5b95f62c995b33f1e8827d4c879d7505c4973bd577831f0d8d36d7677d16f25c23f252659e29257137be441168d75a56f457d23069f7be7ed0b011c878f4a13600cd95480fe894ec84e33bc970d0544c4153d0a1d6f63bf881ea0a8ad979a859785c332f58c8ff551f2b8ec1b81a65cb0e0e6c7b57851bd4643a93dd64f83c5cb68f7fa4f8e7c34f5f2258b52127102349c5d31beb281578416e0039b4faa85802100230db891983336b153c01051fd421a6ba39e77c65c1723b991098dbf15a1cabe5b3e83bfddd977e877f4d5fcb358930cb4fc396cc2dd0ae14df474e3e7ef698f82b4d50293df0f71c0906fc05350de1a304e266541575bf3d36309b200efc28a1b3d1fd3dd138ba8ead3355cc6ababadca2cb0c9c1a8021d31680da9cdd673b4924601494557da9a1e62273e3d4afaa5a6579c41e9780ecf741a099b079b4fed4ef5cba76980904513c210904d45af3605c24f968742b40d04c72d7c1d0e6656130037ce0c4ef4bdda261c1731674c796518ff6f9fb84650a720d898d7f7c5848a99127d3915cfbccc16d19da851dd911e4abdf6362baa2bdc5158d845518927c34f6906042b3426df4d420e653446055b5efb663e9a69748753b64920a7c69c3a3e7100a8a5a8aa980f5ff9d385671baa9b062085ba8f635a3efd8c3c630db6bf97fdd7752d526fc336a9f36ccbd6cb4b6acf41ab066a151fcae0e2cce11d99fef0e8ad6c303fdce033c5746092690f994470cdd891b263348cd7486022a2bf0e4b89fb90d142cd04c88dfbc7023cae333d7d4142ed11c7e017d54b047b5dbfbb271be144945db029778a8f1877ff6baede2b89a60278664ecff17c92c93bfbb96746b0f1439b3b09ef0ff91bd0efd1901f16dca6faf49eb1243c863909a63df551d6869df85a75861bee982c1c644daefa7c69b4b72ac68e77698b32a472c88c0015ee1bc9a51e6b1f9984cca053b317be5a8e123dea99a39623927bd979957af5440b9a67709e066cbda7cf325adec88f730c5e05ca5b00c7d291c5e40e8f271d4f91a23e4055e7033ef713f6124962083fb7733a910420123c3b5a0673316e3876af56423739db8ace53ba659ff0dca2ba63aa51d3563a24d23102a812ee385edcdde74b8a044c09ab153de045c88f093c09f343c706c18d9b363df4487c58c7d97d076d8e51012ecd14e16e440230264787b85dcdaec5b428d69f4af2a3fb804feb327c17d4c39637af9bff84790e6de518df8c640ce275e5946e0a363e2c7b6cc4bb68588b1764ad4a729e9012c1b62bcf58b145a51361ff88f8bd331560eb3ad96d73da16115bd2b2ba2751ff781be0a6837afb29bbd6b03b8ac708e3535a677e8f5a1db070d72a5d9136906846a1462a85dadb62e841cd50c527f4e19f4e75c1dd0b70a26c8f3a5946eadf5b5a6ed89946a84b4c81aaf15c12195335a1c8ce073132cfc4dc325752f0889931407b2c0180626d96cbb644521a897b101751f9cf496f64b1d5c1ca40172b15c74724ecfed5ed4f1e56c565694dbdf0780dadef7d0162a1f7772945b39c0bdf3b06077a1e3f61bddd1d3d1670b5d01975221e173ec98b2167de31d1ebd5681ddaaa36bf25acac108dcdca7a5f2aeb0046669d195e85abcc2107a7d1ed0095c05da6f9f9765248ed4116a567d8010fc78893de5454962777c43e647e5d15308694279b1ac286220c75e0bcee30a14e4c8debbbf3b6e0d2bd51c56a1558369f5c3ce95e311d8303ce275f4131dc4aa1eeb98f4cf0c6d61ffd502588f936b50be26ce4a91c7a0ba4912bf077b33c9873bb9b8a7cfa276b0c553fda65d23350c10cb945796c78cebff1560490bd0e3ec37ddf90a17dbf2907264715f36a229f7b2dd60e34c8c9e94a390a11c24e73c313cb56c1b47b6d3db227bda9d31aaca3bd17417345096014141ab973f4a9f0291779d98fa4ad6340ab506c38a50aab978c88a386dea81c7866f4507a48cc806e331c4b6dc678a48734e47ce05a488159c00da8cdd8e19fc566182ac3b0d00cb4ce3050b4730fb538a19b4e8f66a2e6517ecc4576eaabfed81a25e88a4b6f0468616794e71196dafb4953bfa0d2e1e927a16c897fadb4da63af93c436ba10d9f58ee93a6c7f8e790f45e74476c1e65af66ad6861fa4cf12f5ab1aa78341df04bf348b15988fa56aa68f92e79d9c2c08576d2950cdecf2d2e2d07d0c5be813aa42770613f72ab9b3b8108e603a86b61c141ab1fe7afc8ad7f447cff177544791e03805b7ccfcb223d063fec19fa4e831ac5a4dc10eb9b2dfc680f6a052093bf0522805847050917f3e2a53e49d4b3168cee5455865b0ac0c3a410f2fbb524181c2843ec467bfa237c01739543b77e23a9074f3ede2bb177c8124ebb43c36b4e592accca0606afe55ae987387c074677abf43b49fef9425cb1ae67f52d0f134c78729dfcec7296a72e5eb5463a42377ad3d98e017712c5a150a39ab96538c75201245f658f036c31a0a815cec17734a85b8affb425477cfbc5ed32cd43dfd15865cab7cbf1e1705747dba378c1239e3f6893f655a0532926f6f13e9f6c9d5063cbd11710a78ad1bbcea2e4eef2bc8c6ebf6219676f8b0c25061e0268c086570e48cc106237056d31d031ef2c405e38fae5c82f9a0c165387f5f01a08b1052e050c688d2fbc1e9ee117f6270f9c36ac135d4909bfd6ababebb4ef5ae97ef250a905bcffb24e657938dd843400edde89bfd266bfe0c676017e7a24fb6d9816bd5da3558675942788d4f0bb3adf74fe55ed16e5a169357a9c23700a4e5228a507801076067002920b74cba7d65639ca0538144cc5f4d6d3aefcbd6d24d16376019ce5777b304f7b43d5228bab2a9a4af58042559abf8877ae87e8557c3fb11d278f4a666e2d854f5c2f16d7c4af75a361b7f9c2d89229123ed5199e05cd1f499188dd4e68998fca948ba08e55aca75b4045f2224fd767ee69824429eea5c47f8a59e6c71e201c8fab3e7f6ae7f2eaddf46a278f74a4212eb13c904d958b7b5f2cda0aa1ecb82d42a83d93603b753bb7a04008cac3678cd6beb8428537908e917ceae28808372e66aee6cda7a52fd1401d8e9a5951858bdb06957940db2942661eeba7ef2e0784e9a477189c2edeb54e13fd93b21a5385402d58729aaf9e23c929e8bd9a591b31e4234d783d88eadc68a5f6755964bcfb7d88988e8c41b29b0961c1d20f702fac198c16e505b036e5ae7cd18e7a92ac8632446a24c3fc6d4a584a2a869bd9626f8355cdaea6a97f7e16de740f060707470bf7b128fcca78e93c1c3b9b9a0829ba5e59102631839f2f2b15f16097f725448b2377ef39dcfb39cc0394657bda1654515e34e7f23e7ca7a4d433d2934860e36ea2032d394b2fbb6c33b67d3e3b3494f464758549bf09c2fd98c4e20c9af18e264a613aa9d6ff9a2b1fb3de04b9f40789c46b6202532d8f3718ed46cd30dbd19931822eabc27945910cd3c581e35c0f0df649b4c996902a4a264cb257b1971abd909044acae42e482c0b8cf0032b547bfd961b87c35b453bebfe1c528a20502070861d3508d690bdfe58eb3b34d2862d5f41c8194d0ab97fd6368db7f6fa27642e47731127bed583da3e349ea7b618a25bf11ab8588c9076505d543838369dc034e022289771b4366eddfaed95619f3725c535ccb5d86510b4c13e0c4e16ada9cc54803ae4f688280bf2a7ff9649d41ffaa1de82491eb5e5bf7b55d5cc4a621353831351ab9b8a702273c802e834ae6c645d6abef6ed6a985a57642b5be77b06abe5a41719e245d539450082dd7538c409ce6c3c2c2fd341f2ae3572f934163a7f4966250e7aa4be2832a72d96958a700a82e8f8b484cdc4672676a2cd1a93968b8fe10c73ec1e1fc9667e77e37b3499772c3a0c088c27919c8b8016002eeda1ae74f2ebee2be1cedf75362dfcce0bc8e62f0bad36eed56cc48d3964b2382332fa791d920707cda70bf85003abb9e115cfc0b741396c8643f6b753988a4199683c2890b19b4950929fd2a4342ce60afa41dfe628b48ffefc38ea3b9035a5d0db9d011c203d5ca65c3537d59d3c79414e76012dc8f3f5ffc2a58ce49f63a81a94f177c490db6bf692ec78afbb7d4656cb1885b0db518a17c4df39c67ea3d281dc8ab3c4291464a1451e5824b0cef0c139d4c58fcda53cba05b60abce233581cea2c655e6ef901693f77440aefd7848846e6d2c1a957d1827673d7c1072bc5ab4810e1a7250c75c32e7b990e19cc9b62d9fbfd68cfb21d961616a6b018f5f2c6df98655706765e7f99f5e2d5bc80904cebc3dc966967ea8bb5e90434925bb25bb45fb6825ebe3788030b2e40b4379cc24f68f8548b934c423a436663a246c93b1dab422a89943fcde12550ea8e8fe9e2bcf66e7c75a25363710e63de8e6564053693a7effb95b51cb298307140aeab56d9ffd50bdf65e864b76cda8d3eecf63b42587947915ddbb8b50336d8689a17246ca4323914c619032a2d86a4b26b732a84b3f138f164329878a2f1c5753cfc96a9c2aaf8164f8fed088907d8fd4e1a8ea91b65a3ff330105031d65ed0def2407304295e10820e0d6fdb9e37028facd3d127a346957e852093819fc64e169aa702961ddcbffe230b5e85481da66736b2dda97b525b2e36147b218f3711669cf2d308219e7ffaea5dce76741b04998375ffe4af99478c7940d72469fe52929d8bc8e2023fa980c365fbed6c9e378c0fc3ee3b20bd9797d9d5141384efee4db23a4fa834faa8bbe2c13e322cac893fed5dfc5acf1ce1c2ecfd4048556cf18a70de01e215474f1163d0d2c2a4459f3eb3b414069064e47ec4515e156543299ec4a99c914262b37fd3c95331afaa3ba72c933edb3d72e713734e4f5772a48fdae7aed99e1912139ae496ac10be5c051a74236feaca389cd4775ecb8a7badd0891c80f6b8ba573bb7e7e917c391d11124ae71e50a125a951bc282922e791f7be6013e6492cb09fe91f7ef7adca08a162268fbece009ac87c5887d1c0a03ccf5b7cefd9ac724507a7152334b980048e1adb47c0693a8d51f5aeac63d34acf7480e3cb0244e69e10107713821b84bb7d6defcbcad15167d17b8cc5234828974abb73255582b689efa2e9f5e861c4054cb5290d8f2127ca7724b79ef5eeb8de74d176d64761cf1312a0900c64df3e9531da10566995b151cea9496ee8fb9167212ec0204d7d60a63cb1508e6e814e93248f7b16b01996270f4282d93b402b36b530b4cee2859de10f2e9a175af59ccd34c7ff28c24b88a05319e3db2985a0b5488b32835040109b51d2b92274ff0a911115e439016a6903c2122a567c4727c79d6361303d4642226f5295d3cceae2d0432a4d0d05c736c98163524bd74180ead0756833168f5b490f71f133cfc2a8bb20acade570ff00e7bc40be01c78d202e0cefbd2cd0596a08bdeb0ba30f789eb90f05c7bec6948bd4e16f14c24f5cd562275dabd6fd8a69500abab3306598e21cf5232effcae2fe59c83c4f425cfb519644c936ffd3423e1373786b1a59b64fbfa680e15d55caebca72409e0779db6ef36ea2c7b7774f2e95d0ffa8bb992deae77dc9d0e75b1bab0b29cfa7acd98c9a621537905b9838b0ab80c2f1519ab445dd8e687dcdb0f89003a50ab3d773021379b194013be1ea0452ae7c1c37901ccca55cf35859ee48009fa2bf9753f7d56927dfe4e26a13e0af8273cc792cd42eccb9a8b60e8dc64926034ff44ba1954c78d453e8c12394d448478625ba72b80a60983fb2d366fc58f1452478539d333c4fe8fabc244bc8037023d98a33a68761ac3314efb9a9e4f63b8977f84f1facb6454ca89831124c58da9b6915b63f5a71d70f9d1780dca30b17996d99b6e255a082c47cf1b4d9488630bd591b1fe91d80128d3348d70925f029ab8afee3c0b43c25be21df262bf38375d9b0c159f734965ed30ce2614783cc5a062166953f35bdf9452734af3326d5b25da1d3ab37db5428affc1cd3e284466f2b36c3f0e45e70e5ce0a1298b107618541a494e9f2b239768a12d9205c5c355413fe4b1b4dc4c55d847b436a35f449677ee88b9bda4dd533e791bc4ca9193ad537a773c2e9bf5649c3ba360162d64cc19e29d314b13866ccd3dbb14bd8450ed517ccaab4b6dc22045f2df846c7fd2890876f4480eb90d26e3729e498e53d5e98414f9ac5e3c019ad495f59c2cbe08079accdd104d4af864a9c61f375ab0b2fc27fb13cd210de6f2681f5cdd1e3a116d3bbd515415f844e049ffd41319c671e77feca1d0c8d29f9c3745e758a156eb4e23403c4210df59a8f0e5641a1b8ea8560dcf84dfbd7c670d21523beebd53c78017c9a050115c79969a8169e0331256a4dd169ad150b9bb6eca77c9778045df8a31b4169ee640d5b829623f11b4e61b394190864613c1fa0c5999e9103b12bb572e5d302f0b884815b8dd74a3c7c237a2e38a9f5179790cb7a2451f707d5039c324253888c48ec3673df0fa8729887c6f199f3459aa737bda79d984029dde61f844a7b56aa7f15b079d6fca2343d55b5faac10e932e41a66e71629d180e889fedadb1895100e3c97ed7adaedff50b209cb5da5acb8479fdca7621b3963be50f268902bd060fa8dba525245ceae76ebaafe7040bd6469d3868826f59840b8a99677002b67893f13ca95f53cc84e1f03c668b7e4eacdb0408e6297db218346071381818ff3ee5e489993919b4d6b8c0bd23e0a9ac5d3a9f44a2fd9900d80f7b6636fa4802471666f9189287d8bb3d4ad6ca34af0e51026e1d35b18c91a37f07257afb371ee1c880fd1c228b84de748b79938b2b4bda1c618753cf5ab92d672de4b0c7174f0b198eba2a1f8eb023c1ab140a69416b7cc3f53eb2a212fc61e4f6753be533c6a1d7f7ffe6202b518c9caf1dfe8370356477ff16ee38bdfa6e6ebef7dcf76fe79bdbff7fed6e73a408d7744e9b1a46fa4d94592abbd8568b5a8e7c52e8c95f33cfd57c1650247e899cde9b7ca34194d1c121f8bb0e5bb6b333893244a7c1f25a0f3ca627f50c36619ccefddb979ac7d2a3f031e319a1e5ee2a76449f3be3088619acbfefebfcbc11b16a264fe446b1135fec7aebd6c73bc51e7b0fd0575cb1d14314c246f59e9de64e1cccdf9fffd5a3f88d649a3ed16079efbfb8e8cf4c94158f9d0ad29c1f11d9ed6884c3c75f3e09c6eb9c29f7d6eb18f210bcc8203b99717f955ad480dae28a4df18bdd856389bfb0373257e4270db81988055dc6e5ce76032c2ec7208282f3844fef8ed0ea163485b9df52d4de0b3bcd7740642d55f696d4e29b5d13b32add251927c959383c4c589eacda60593ef006369a0c04b4733549bf731a4c24fefe33c0e29e53b2c302cb8d59143f8e5843667caf6a0f214f468df9076b468772842b8f776a0e6728a31441e90dc8a558e42b93f6167b1526650b1247974379ff7e8ceb0a0972663e9e58b7e60986cc0afb7b0f499a377f0f891b660e4db51c091d8864326d3fe0b77d064a76efde7746da4abfd611761f79fc62093ff43be003f430125781a331f0a9bdec3382575afa6fc52d7d072aaf16eaf41cd436ab6c2c5bf5f758210bf3452073710b454934add9cf1d53ef2099e89390ab9773c0cba3a7fd1c8d4530293daabcc1447bed14d01a3ee6207d9298449e9f5ec8428618a343f6392a40f60d8667be90b797ca352249cbe8b126d456e36a27b8ede99f109d92ac4d479179b1b67ace9485f715cd478bba3bd5b0131bd3342e51c5aa4750a4e72f307af5971a3c1548d195932d14ee796b605175f47f32b6455c9e8692f7af9ac730f9a97e4ddef4f8d8abe4cdc4442dd40bfa3dad16c2014ce20b64dd694fda330d51339db3325f87ae005557a5945f2637c30bf4888ca6b599e6e14d444bb047090d5d88305b89d891db588a746a827e51f28f94e897489a7be9e93dee294fc08671803d0afff859a15b2fadcb6e678925659f157f6cbc1ec71112385f653fec96074b0389b1b2ab1cc1efd2ef5a54f07de30ee446a467c5e1a72e26bc64a28af2b6dcfd662955d581b834fa05242283443dfc10ff36f58aed9c21750b9727e4e9fdc559bf80969dfa2471267c3388619a0b5a84cd837c3479da15275cb7b15eb22c7adbe9fd7c4a2c8902f35811a57c8dee85cea66066dbd955cf50f83b97ca15288dfcaaa1363bd28a5316e1a8bbd8b2af158431cdd5d12f133b9f2f9f59dd8ec27323361afc69ee7d1519397df5a0dd297ae66d9f8694c68282dc919642f161420bb7d2ef407b5305207df9a0307b5afcbf57d8e5c7968ad16fe85e32ee6300d80a316af4027111662b24bb4d0f8117bf843af322ef980f439a5705f8ef5841c0d9c4a71a1f07558d79f830651cbd86eccf7b2dd1f496d8aa53705cf95c49fb27cc6591a64073ba9bbded424a192635b904a35e75b170890f307d4bf207ecb0e3509b0c6175078c066c986d6059eecb9f6f50d842867f21d2c3df6df92183bf32d2d7aeecb548d72935945aabb12c79a2203b9d8ea5e94b98e0ecbc6d9c660bb7688973c2feaea49b338817785462f67567db39ab2c978d45a1d83b87a32e1a3ebfa2d1c64a4b18104bd54b5db71de946106d274c7939b6e55530fc51086291f4f36a8dfc7f90d9e42267f11ea2e599eb998ea8dc970148f1f63faef21ac37a641668cd15a8890859f1a25ef0279bbccab450c9aacfc97419667a3e751eae6037ea8c6c5a9dbdd67899639af29170db52a226b7be2c9a719ce5ed7607cc92c50765c72f1e5034cde626cd41a89bd7fff2a0ff0d1f6b1649a09d195758de584862f459136dac4663a3ff1f3b94d1b30cf6154e1f9266699bd722ea379a64af2f9040743110cbef9a2bb899a0ad5e6e8b76de9049946821cb34658a185132b114947ba52e79d81f970f6423bf4c0d819df31d759713d286dca43f06641560676d6abd444412da8eff9e39b9a150e54103f5948801fc4c6cb35fd06864e2cf24c70088008ebfe8e5e72368be065c69e5ec40c28c417b84a67b51dca9976e1f64e53767814f60f6d9bf5433d99154459a02b442ac58fdf7e7c91b8e1d761eda842e31ae228997e8010540df7d1e90882865ce5e2d14af08a9a3b3c8faad22d3418783d8dd8307e3403dc7e85bbf761d7d4023e9d5f0844d339bcd95e9d69fcae6160a79e0037d42922733beea7e553ce5eeb7b85008d0b99466c8ec8df89b5eb8b45170494ffb454aca0e36a1e12a22ba6f89d7c7b0857350d1d1643ef89bd69166e53de2f102299b31543f4c23f2291e794a84d88a61018b46939290feb793d22ca31048554697d57781a8b1f930f5596bb60f8aa36cab989010d5793f7dc56351c3824c158a36a248400df467f45b18ae7f8d792759f7a18d8585404d5a7c2011b1614d8ac3fe2b2a1d11026f6d40fba9a9723d7fd81ef1da49c14b6af4f591d8b26d24c449dc2675452146dd4ef0a798690b29d1d027830cb1261568e3a6efb762a65f36418d432b86579c407c343cab8faa3080001021249a81cee082a91ee1be381a55fb1682cae90764060839fd4ad9fe38c3bb93f5f07b706170083fedbfdd2d47f9d08b468a951d40d483925ca1635e9959f97948f7fa5be49bb0c8fd8282ae20bd95d05905f3526fe03e1dba8b9f188762881e60401380f06211cf38b923f035f24f0b79b2bd443b14e06f3f4ab023ef6a280e2ce4f124d57dc8e2334beb3318a7a7b945b32946aa73573030cc7cc3a72179b170099a73e6c2b1f07b3358bdd0427a49a099b279fe321571bba5aee6eec8b9bed9e0d7238730b99742c0d1554a377bc5a24050a740dc0ce952fa80932241502941e3d97e6a43728d63efc659985c123e3694c1671ecc077da645c3c8cafd2cc38785b1ff6fd485d428bd05231f4467847eedd0513c15ca6d617cd667c61230e6aeec80eaa6f3c39daf26b4b97ea8bd60a22422256d2bca984f5511d932f08de0ea5142ecda9a5cabb4c895e12a058979c772910134d2673501585787f4503c9aa2af630a955e65b91273a7a89c897180111de8645e5662f6f8d1a17a400df64d50b25a07925c0e534a3bbc200f58c4dfdb7419c8248ba464fe8b89eac7bd28171393977443e8c81ea6ee156762be3387790dbd4257edc94a03a0968feb36cabf229a9bd5caa93276e3304391b8441b6aa50a6cac5b6ec9a6013bd2760e18cd46a26a12543ffd380ef4051158e6c71bf9f8c06844bcac832082eace1552a50615c11e608a972841ad64357f8c1d00693675e50b2d564ed90a56e37276c5364bda073fa4dc465ea4008da43cb0a251f4da93c61a2353c9456c63d494768fdefa53fb622839c774dd1fc43051ccc481158d52f2f7c4c69a1431872c5a2b77ac10a22d1de83d99166ed1d479f14f26798f9cb2abe7e32d9a28917fc821c185c126fab9892423e437b5f1945feadbdacffa9c3a62aa8a9f88b397a3295313d7bd24e0f92f571e51e507c1b996bb302b35f9c2b2c4dd45a5ff13118eb1622a59965880a5139cb1af02e41ff2bd736e712e8b1440c6ef544b672e3c67b6efbb65d74ad56b81d39c53a41b424e1e3b9249d72e0e685c48bafc69271eba75b36964e001a7e4361ddbc8a52593bde3e1acf14834c9bc41a5813fd10c3011ad24bdc570a93dfa0b361a2feb8082b86b0f0a9d64ac231c700eafa2bd316f2aa3576fe1ea24b3dbc645aec757a87cce91954d3558a220201fad113b155f7380e6804191906fd69229d1b7317c7b56a167bf0c82dc8fc7cc58848f05331da387022052d15cccc837f9f97bf7b8bec08a7803b0cbce17021a8d08a31ed9b5c869b932f7c47a61cb5ac0bda0073a2e793d4f43551cc5da73aed4726bc7388b69aba6b4dc6868eb0dcf95ebf6c9b81c473a50f04b48f9c9faec226fffec65c2bcbb60424ddbc813f60681ac7e5dfb33619a61ec4f4ddfcc5967d730a47ebc0534ef9b56a0eb384eea8d388db3db924d33a1ebca48f030f0782122d618472f1cfeca2d8a55936466d034c3a27b32fdf2c0643919fb9e7cb98dba06c4c472c1e83350dccc69b948323ddf88a55137bbace84998afa456976db60c3c84aadecbf73ecd110ce8fa33e0a72be51220a0aba45338ad9808397352c87f1c6257a04c842e0a81d6ba1a606b91b55d5d430b79389dae4fe8fd2ba243721fc77ac0b8e385d7e48fa010588174af5f3fc9b2f85c61cc6262ea51e9349a019e9e2981dff96a97b806f2dea727ceb7c2b9325b3b9c00cb1bee5f5da6099e298f0191d31fa209912de83add98e016b774b7730b03b242d897017434bf3e2281b8716d8467652b9c2f3f9e87978555296599aafd1b878b39e3e2dbae368b84ebf9243d92bf8c9d47b42294e761508b05558ec1266b56b89f32cdb895672969ce8f168f68b60fd69905933ae23e321ccad2bf839d8e5eec6e994a26c8e9c80b3b2c0680b87fb6a63936e57f450deded06f12a8c10df944440d4c647309dc9914198b74a50445305a4914deff22f4c5bfc00cdc46e1ff7b04bbb7a5c9d0db9d12c7a6620b62eda95a0f46ba9201c7f66e82ac51c00921a8165e6db449c6a886c9f541e476114b469ca947a775bcc741d4f9d9516dba20042fa38c1323618abcc17b1fa1d7722f1a99f59ebc614132f6b80d9cd884ccd7a120f01ef686d555bb132e3d9e32ba295ce361353b47fec039c6e380e1c8539f52cb54e55dee79db2e3d4546153fd1c6c2f8a1d4d56f1487bd2a7cf1474cc59a630ae11b347ce0f464494e0345d98d6f72cf04cb8ddd062f45b51ea9b79280f5bfc78809075fc51c8b9b9e290e5bbb8ae440cb601ea2e51d92ee771971f3e5edd1249fc50cd7c279e99b3157320437191a53c79e39d33e42683bdad134eb5c103c325976b26c2cfcc49f995e7d59c466b0307a0eb0c145771b3466e743377f9ec34452f112cc8ca40256cc02178e1790159737184e421279ed902cc11fb5adfdc87f0fe86dc72b8ca4d4df70ac62aa526817fb339301123bf61114a6ee482f5512aa87bd06c17d0ec92a549f758fa5725d4b8ba87779ec516c22900c36b463a474e56b60614edfdde551378868891df0364cb7a50fd0e4c9c229b5b5083dbd14992a73790fce22a33c1aae759b496b309df1bea9f67353b8db1bed50e053877b03b176f8b8efeb11a3e24c934dbaa98d42f258e059473e99425ed619b5af92f74437f2002f11543514e76e403135baae37623a652de4d3b08eff8a9500be12f92b3fe015897b1704fd77da1c8782667f3c0136c6cb65e095b477c6354e1c607a19035720f696932548b0d151922e440fc20f64cb178e887673386d1df15f49442d8a76a6d06afa88defe797c594f5934e8abf8db7f9486da288c4b44a61d3882108bcfea6b0f534347783406bbf0d608288da665f9a7f1b4a7c753e17db21a3b79bbf45476e634af047beb5669381c4b4f9ec8455ee68b3cd9f7632486fd9114ec64738cd35357bbec48e1cf90692f2b94d623f73bc2872e1fe73f734a187016dad048475714234607e95ba5c0fe212617060e914eed3ad1931fb3cba2d17549381dc6b1d0f1289ffc0af3c9731352340382884bfcd9b3ff05d4bdc0a2cf82aae833db52b66dfc45836ad534ee9f6d8230d06bb97e5c84850fc286f08b44de2f4f5d0fc4d3b07ab20c82a8b45ce308a1ae93557d3cc5decb2d7e579dab3439cac4411c64515c4abbc3ef96761d7bd555041b8ad1a42875d0aa704044f259d3eec190b75b2abcc25056e6f120cced4ed7a818babe3d4b61d183fa4492eb983432227e0204ae4d33151f548b708cbc6907f317c359029a6f3ebd52fca4621e6cad09cbf72771c80ee08ae76a45201f945825d8e5ce89871d0436f3b2cdab70daf548e50b6b08500709937bec736222490a7bb3db1b1e5635cbdfca2bea60e41a8f738896232983f30f3dd9367aed2ea2877db05c7df667ced08551e7f86236e8dd0060afb44dccf1708b1cb96b8e67f5b3d4b4b52696f0d1ee20a416ec4343a63731b4f545a0fe4d97331798a90be75a12f84f3a6cd9dde42ee234e2201c23b35b00a3fb7acdbc268e568fafe41aca7068d9f4b1c7b006f150782f14d3ed5489495a9042b1f55569c306159734c6f98589f4bdff1c7090ab79eed2a38ad1b242530ab175b1a312cd0b9a3f458760545bd185b568dc3f02d1b0e01c885e63ffd9dc29e061b4f112b2f00d2d5e4acdc9d40601282e7e8ace4efcc6b951d72291cce35149533b16f61f8749b5b4099816f9ae89ab3084836fc4c80f0de5396f85aa94573165a5f7a080b47d5f81fb5d1ea31234e6af616d6a73ff2ffdd7ba308d50de3444f3c2673757a94ec4840a9a9eddeb15d7bcdb68f82285d6148d9f8b8a50b02cef31f25c8ced4d3c71234fe16b63a1086f2a4788020526a01c553ede01ba42aac094eae0f57410d921aa8ffc32bcf1154d5bfa5ad85e9c0ef8c0c49c359c2fc496eba53a1cc4401ac8fef94626e1cd152e89b954b87a8d36ab852da389768bdd937a385c5a1453d620485026037975b97143b254ba241178da43dbb7dcc8d7d91ea0ddadb2f1f466302bf6d3b4b7b7f38eb7ac89bb44b2212ef39253472e41713c8bfddbb4f3e0a389f7f7a1b8dee636e974e62388b4a1b217a0463ad47e2857b2521a542db58f95551d6b102b26746f9472ced4cb636a3455c97d95237d251ca206d9c4e502a393d9c8a27c261f88ee1cd871fb0629b042135428dab2c2a703c9dc15eb07d72693a023acae3a6e8b5275023af239327a1050ca29f767f2db490938ba5cc4d519a007eb9f408f6840781d12ba6920c873ce570c68e8275e6f61ddc69dedfe63f90c01aca821d958c71dccfd21398a4340060f25c42345357d2af560fde3536b94c13d8fb5a7c713f38f4fe229617f1ebf11fc25e9354aac9e7c61d6c11e742d578d5f0f4c7baefdfedc14330ff01911cfb89d0e2c3ed10231a0272510e5ae9778f37a60622e08a2b9a458ad3438fe1145bce9e404ff6d54bcfca8797ecb6a2b526eba3ab92daeed7c584379949691c945ce3247b5bd1a63ecb9f60c5eb177054b3b176a5346b5a529db3a2de78cb70382b5080567cba25a517dc5ea448dbfcbbcdb596415dd14c6a145f138ae0669fd60d50710d78a02436b00e6631ccd5b6867db532a46bc045e28cfa3d6b68cb92e0e65c76043d198798a9c173f7a7d02850fbc99845034a9618c825656367bb5ddd31f12e266b02ab70bcade8515e1cbd5d4f8b07a2f0a99123eac29382586ee02e7445df5d7db7de1516de47cb14","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
