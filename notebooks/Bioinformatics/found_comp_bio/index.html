<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75f6904bdd45067053b81ab4cedf475ec1b77a2dfacb2bcd6cfd2a8f9af858312285a36927058cea19fc4f677550cba998ab3a11b0c460abff7c98f860133fcde9309a879ece6102cbe2b1d12c876f388d9d412071948d4af9cafff0a89ce4f1c52ecdd0578ee31caaec4c4283841a60ae3c05e918364bdf514153f054401f5d23b0f94d1160b5a9b828ea556b8ed28f13757aa197ec825b8b48bc793945262717d10993c2cba3724a75e79296b58502ee846871e7c03d98a814e7d65c0beca8147e2ee102477858f5bb031403ae8dc845bd11733fce119d15272b2cd577d60d7570f35a0d87bb22d50c8770014dd233e4b5067188b8e1f3c54311188171862670ec76ebb39b735c3613c3efcd160475b58fc248356ebc2122873234ffdb9919a984f04cc5cf584abab84855e15ca3746a0ecd0698796c1e5a2bdadbf90c0c978cbdf3ecef185709ba45e4281bb8026c454b4c13fe4bf03b6188c61b33f9a73faed99c6579b91851401039068a4898210b5c01d4d9b5378fcbc8b886825feb6f269acf2652fbefd0255d6a987cdfd8bb30a38941bbc83e964aef618f0f218360d4a66dd23cbe32391cc8003ec18f31d8764327e011a522f41c0e619d9a7a44c62edadc640c3c379009395e68c00b771418585a73cd6b5bd450457be2fc9beba129a73839242024ad1bcd9f5e0a94cfd4f4e9f61de0a4fae5175760009709e57a2715f230569761f0707ad9e9838388412273cd39d76215dc80e16946ec68939a3f3e7a69c2c72aa20dba8af2efcd6678f4c6fb75c7d3f27003549643d2c33f09985176966f7cbb948b52fb9fba1f75b40e4d885998f44e9fcaaaab5f62d6812a09825c1ee03caac3b9ab9b20746419dc18984d027ab17ea1044a86562e901a71fd0033aeb3ab1f973583e624de4ef2c16e4a3131c7d363dd48294971ad669a3249899913bb4d454dc97846afcd0331a286456ea97bf6d4b508e9423f107ed5288692b6b87bed128ae3d6379495052bee7f218c925ea4f2f71e9d32048c11f49a4b35a9e843d67b98881afc2a43df5556244d53a21ccb8d8c0bfd47f1a18c4edeeea163c4124bcd9b1923bc17f946afa5f79d924945114790846ca2dc4799fac121affa61f26388027394d7d80c1f7ff1e46cb757d88e05a887a3ce3b907711d66cac97013ac51811287461ea416bbf8657116a5505bc9b30df4f7f28de4295b36c2e90e1c0a3ebc76d98dd3427938ff76c5f55529898a448f8d315b94c0ef4cec17893d2b3ed218937ee183197660782e40c288effa026a6ed05d83f00caaeee10f6298b8ddfe367f934ef96ea178cfb86bac139f793f2c3228646e182f665623c31a05cbe51ae61332f638a45cd003a84a4f4828570435ae2b405313ac4662975d1d10fc6649a255b887a8dcc1e8fb5558bed8043ab6acb74d5e070d50adee88f492f3573fcfed14ed17d1d83db58aae35d3d9bdd97a73e9264f9fa4524012338449728e2e3de97d4763ddac4cd7ba0354af9af6b4dacda4f1c4c3ba048d00c112f7b7fdc95b3a378c26d76f16fdb499628eef7e4cefb5ca45f41cb873f98311f6dafebbb99c717e8851512db11db87d6e265f18a4cf1f5cab92f4a8e226aee2f4f613b6258e903bc419e8bd441af9500f28e745abf24540f4065456abfbe18ec8a0152a71265500a44531e3462014961b18a733c7334822e3840b5d1a8cad0803d9e12eb0dc024f85b680b943b647453b13c946f9faa8fb9c2a0368ad7babe90418f587f90cdb8cecf3941c37661d35c71455b7a9001f11257d107fd31757a061df084ca248ab6bdffd584c74cb4cefbc469360456c09e289de4a3fc08a9f869178d84eb5c6997b825dbf41561bf5cb73193c89cc5f681da3ca16b75492a52cae590850e4d53c437660ad9ae7ac5637f2ed9fce8a2c1b4178116de8d254dd7c3a50bd35cebd8dfd68e88573093834f1ff2be061c9038d0da7ee3c6cf8867cc1e3f1596ed8e6ca315a8e97e0fdcdd9493a9480860d8bb0f2eced569d7309cf8607b4c8f945b2616fa0dc746937966b3a119d3a78eda613027c90267f20d67287029d815ed9e2342e09ed883a33c5f26c0ec57ea98bc1364e4a85d87987bd78f471e1b89a042cace193014300e04909816b64eb1d4ed425c2273485232fbfc20cf28c7b714da163ffe2262d8e4f11a79df929eca661755460911066114f39f28c55a9b330931105bb64c05aaf4c6d6a9bade79ce4045a0d238924e49b9e1b75dc4badb789d8d62b1a27e8350cd7d0551edeed9c077072f3c06810c0c0310e9fee167484872e743872feb69639225f77ad903904b90c21c3489ef6df36462aba917cb09a4adced3775811eaca16feeccac7c8ca74e5c8c1d31898eef4aa916b276eabdb85c411d48333990112f7bcc33afe6f3c31d039630626140c0fb912d88d602ff4ce6b3ca9a7b418a0670fa42a52cb8f9244bf2d3f5f3f783109091c854b03982f4ef27f139f7ea1db38cc4f236c360969548965ed2a542e8d5c6269cef08653a2f499ac4c15dace4af1bbe186cfae2d5d752c33d6cda8b3afd2823aaa12573c0dd8a857d716f4d9088b7a34a332fd8bbc53212f78dae8cf5e0bf7b6687426d811474beea726f8a88e1d1fbc9c1a558e35bdad9706349a7bcf4a5e8c507d40540d384677318a045413e583c3a8c10700369c795c01335094b6bffff55ff7f6f7a5b9b2b3b2a284907692d2d46feb7d6a2801886a3ee5ac5f3875cb3d9e3cdc1aa2cef3449ab107bfa42aef323271be916cc03566307a82861b40686c55912b4d0a889896ee7cdc336e4aca873a8a6e1bd42fe2774a74bcf17e3779defd8f322e39a72538c833409f2834182640ea7ac01434863dfb25b593eb9b94ed47d5839baaf810c91fb108f89534ed125d703037bcfdee014b423e7f74c2676d35df0be1cc385517a8b1f7871f97d362258fea65e02f7fcd772fe65c61a8354b9aa9295b494ea14316b04dcde7cc0e4f5534dd6b21d1784bf7ddcb12c4abb3b597cce0b40ba6e80ccf947831ebca05e254a14cc9297e3308ca8901cdf52571654ab1fbd4a12b2ee4c7a4daa856458d00d33a235002727492ec7b1ba01c232d5e1a34ec6c15c1434d08f8a2f9a483e6fe6efefdadc55bd094050bbcdb9b982b7bbd897b56053ef545388f1201bad04ce4af8124391719ec807d9ae415050d21bd024b0957a304a2ca388602f660f36bb3620bb279761f2556940a69d450b9c2b42d06d001cf50fd8960784916c49a56286fe4165a2b1f80460424ac526a47551a2407dfcab79378efd37ce60cf9aefddae79c71c0b81ed02665d9adc47a1e5070665ea1fb058b05620b45824a60715f2caae92166dfd6b3a5c32fe1f058d85d0aa5cac3bc65f68149f20548f9365a61b6de922653a52d487114cf59d9b3a00dbe5c20701c94f51ec86bdf750e544b23f4db7d62ce46591e38f1ef5d6bbf00249ffce1abc1bceba02b97e3fe1286c1c0da077bc3732b4c5bdd78e3a03b0eccc829e1cdb0e2efdd526b4a0834f4cb56512d20c87ed16704daf454c79beb945b16c18cfec61a5e0a0f2a601dd5fcc57713a3e6277141e0e816d6549736daa5c1ae1cb7aecd0314532855c153cca30258693ec1768a9020f52bf29d189342a7647ab605033f83ff8ddd009f3b14c04ecc553b36a3f09bdf117f406447c17fd10c2e8ef5c192a7dafaf9ba8cd10f4c6771097a8cebaefd0a52c703aef171bb2f9fe79e4dcb8b0f34ec4b78d888f125defa613c3e9c8416140b407d15af4b8a2e95e9cbb6c3f2f304847311cd745dac1aab0f79e94782c0a18907c5bc272187640d825ffb1371933edaa25b9dd51383b773801c77f8c21c658bd59c6fd127879edf8a34bbef05fa1a0325d91318d4b09372b3edd9f44f59942e9d66ebf6260303c01fa99dccf5e825f25208145559420fd8ae8b1188ba005cf2729069b7f4eba118e4bb0619ecf022334acd822684ef8243696171f9464a71abe5b561f68af77472840fd51f2e3da07f44f571c2cd0e31ab757c03476092dc498096f09006306a2c691f9692dd3f3b2e681d62c71fabe7cddc346760f1d9b623470202f073b0190d992744c19599b97c06457a8491d657ee81cae54134e9f863ceda43c27d2cdb3791d1f31de4864f144e2766c86eb653b2ab98682bb5e8529ca149f510c7b7cfa604ad2100348fc34c5042fa627757a6e5803ec800d9b308c00a9817f9412fb73adcd2b314dfe7d6d2147d3a98f3e83a083c5fc757ca967ffe63e2ce394f26968b49537b1bc50b6c38b4dcf531a6fe4304ee946eb804b8ef4c6344a30a272a9c7c3e885767c377398fef5a59490be67418711964878614d85b860afc564db72cb94697dba6ec98d2ed71dc8aacfe26f3d21612f4bc1c65bd7d63b3d68c78de276c69dfedf6f56adfe16e1b0a7a9e11994b56ac9fdb1c5d9065fe092cae155c2be088b6d92f6cddc05c67225a4daca8e0bc082ce0cc6b03a80419757c3bd95d53efa59d32b812a9798a8d8fa25e28969ca42bb1e7ed5f5d80b0a7b5bf4e4da320165ac711b7929ebf239b85db2a7b2dfd1d98048a59a9d4b1e5e9b4dbec2ad1919d332b61d9306097244ec984e1bb621c8989527e368082cb8a559ac45e24233c17a5c8444131da9c437a564ad67ee03412b6ccb1c7838f9bef8b359ddbba33c77a615c8f761713415fca29b36658967241894995855f7c680d1aee637caac4656feaeb227516c5342e9702dd82e1a4dd575500d7969c371509d19952ae5371ad2bf96e06eb4cb347c8f0e6eacaa30872c60919286fa5e0bb8cc1875014f3f163638b01b7ee1bc0318bf9f8cd8e8184c5d3e3d6db60b9c7e719ae58cb01ac6dfaa93a3d3821f39c8f1ae1fba27ca15292005e60acdfd8763aefa7a87c3b1a11ee5f1346cc490e7389e514def6d67260d7b37e3c94e74200c2a592240ae53188cb8e2627bd1fe3a68d26e9ce43dc6e7757fafc94044f86fbe4be253646408ac948619b8f5275e1e482eedc791fcd4cf1a635cbc0512faa98e44d166158f695e6789f0008aec6eb3d92536ab4b99d4408a64fc494d17a7d00435116da23739ef10464758e2816b2fbe61b6298cb048e1790dcf91d61adfe13125d1c44082f3a67dd13da8943365a6b0a5ccc5fd304debaae29cf9340427e4efb169488c091391efd2055cce07a83e67ad0866fa65e61d4bd7056852486d4c4c645d48bdac18558c914ff9749287abfc93efe0d53e58e49b5114f6029f5a648136a2c5ad40dd3d95b8c1f0cbd6da2770c0b0fb1ff031de6e39cafc6dfb025f67641887467f61f1b91f096b37238da0664d08f2c8b3f2401292409d933ed7d9a948feffa5e22b385ee683d56f5d3814cc2d1d862d460459ac8fc0062b44a3dd59002df08a7056ebd6041efcfd66cfe3e3579da33065adb5e42bf62a10510a812b7d0eae755b504d112e1bba1674fd2a3e43c561fa9af4ae0d322103c32e9e87c53592a4d9feec815ba556c6be16fcdf9a18aa81d0d832d7830fd52f63f838f1afa9f5b9dfe6f837b5aff539a9db3df1b5819b8f35f75f5925a5d5c99f7d5d36ef1e9e0793134236be1a9ad1a459c73a494e81f333465a1e363f5648731d31a18a05b7195c9deb7f9704ca7ae7a2042b64cb46ec3f719215a56f943c1a2d809ce3b66464cef9ed693147395b04a69e37dc6b896e233dfd3552f0bb220a967e86dd51bc92a1b5bf720c1cfbc16b0aaa3ac6b04aabbcd3f52fef3af13a1ad6d08a27fd22ef9e5a83b8eac273f009ab50614f686c14ffc694c9bfc857bf08911b53996d1a0a77bde0a624a6dfb214ba85253bb6c89885f633c2e908258e42034c797fc5ff6b8f2280f89db427302f0df6526c739396cc31396e295871efba99c169646d573b8af438ddc40b4c7b41c7b54233597e87aa12bb7773150b6c2692ce90ac2e4381fde7f2583640436315ab6ad0a9d57b83c1f5e2f06ac6470f73bac4b975dc8b3484df7df06a5c3b7ff417e5a3a83c4f6306f39098fac1cffb501890343b03895751149335c7984b6784298ac2e63b1a32477e05977c2cf300473492823f52c1019cbcc5db995f89c17124fe2e16f2552a0674df6b8b94f900eec27e46353b0c65b4b795d95fc28d8e7097e76159eda7c52afc18ded9942636a5098f920d52a32d2eded21849dab15a0f492fc7167167dfce00e434ade0da5b32e50f160ec43a81578937c605e277f54870f1f678da2f78ffcc9e92e8166743cee304296eccce78795742094d0521ec069b121ad4203b33ae73b9f4706853c04a044ede73b7e2afbe1998ebd29ccca833f21f19916920a7f62d11757669386cf6dcffee77e5792668da4204544b536c93b6911caf8d917885d926373e358da5aca3be30e881c5c73907c96fc725b334d1a163e0bd4a06490a869187b73f3a0f13cbee0aa0959defce8bc1cca6b77ce407d4cdd1ef42e1b2542f9e9e026f8e5d2935e27d6b59ca5ea4261d08cbd854de982ec15f6f953a5727fce9fad1a4dd72320785fd47bc506ae918b641b5d6de8a4e1aa11d18bae6fcf72bdbefb7833645c7b0820faa8df7f58e5d970d9a8d8a3e28aeb148711e95c523d1482063dcc532ef96db5c830349a3e45614056de74fa263eed9d39cc10bdc79f515a6d6a643686d91c86fb5e7043c3f12356910d4fde7633246efffb45c38565831dfa22c9b905a1036ac3c8a633beea7e0b5118047b2f3e43d393ae5ccc5b0cf92e8a986f87b4c3173032cfb54b5af50524f2cdd5e147c283dc56761a35d1c863d90a68d15b3368a12a70303131f6344e75b53722333f05c9c8e30f2487c2b91461f32e30f66f88f9fb33439b330ce10db64060ffa771eecf9d2e6f0d333f3b4a504bfebfd71087003df941fac7419d7f2ef8adf60a5d1ec1be1a7f44410531a0240731ce4932f9ca3659cde5ce9ead1376ddb7e49a6e7f8c28e26615d4c367dd85c1ca85d6a28db8be2dc06dff1b865d0b3ae53600e8253c2c11f9c438448c41a70649cfe8617f3a37b49ce87e129fa2b79d83bc192e2e9a13e05733efe19fc4c07eca3820518089998d43700c6d0d7992afea2cc8b8a4708a52a8bbe59f4f1b36825ecd292aa7aca0b9f703444497c339e1b2ffce97fc24de43228811cfd6f03e51e6bb779b8ec2738b422b270031664731f5c4fc0d4bb6bc094b66b9ca9ca7ced8600e828ac191336a6b948d7aff4c379278b589a09dba4b41db92a897ff563b4560548b08de9ab0eca5460fe946e5ec7de2d9dff84c718ead36c6bc645ea7faa546c806a2ba7f1e5df041689c5d4ee1920947d67f2e7c2e34dc10fc52085c507c3adea3ef5809444066808e7141e9d641c5c4d725fa9c1cae70f033ab8838e9f9d976113e39671c0c74b4e92817ffd5d9296b13e5fa4444ed9cef3e5d909fba3ea43a64915f05838a0334a40a224d482d874c057d4501be4e7f0d218928ce233e5c5e472dd77da3552a371b9f479940bf6c5bb37096d9fc7ff760f0862c6b6dd9a1c4c43761f64ac573e1cd54db2a8e24c9e49f36d7f4718a6645abf7230ee60b46c80dd8f82395c84249632d859f8db9dab3038e8940d20f4a197570ee89011aeb131311a1ab30aa118c2f9893afc92d190de71449ace9dd3e1b4b6bd25d6bca8e12a73546bf2a44e35c3cf81327cb8e7c4e6cf4bf189f4fbbbe82dee5b58bfa3e8502a2bac4489d023827ca8ed024aae156a7ecece30bce1b881c25185f8c8535fa43d506defd8b0c5ee80ea5e39cbe7ae94acd4f3c31913c5ba5ab77314a5c88c11a950d46250fe13eb826d3a026b6920ba81471e476848ab8ea0010b1f123ff40fef1198734a529fee9751dc2808aa600cba7cc1e76ea70e304bb45c554e0d0fbbee18037658ee53ecf3d5d88a0c39feb29238d15a2abbebc98e4f1ef5338ee4f1c924fd9266593ce44e0edcc8d6f87d367390718f9b01b794d29932dd550ed29d74a568852d368a335373771f1942a276ed6020e5f9462d3301f4c9e0532a008e45165137980bd7e002cbea7bfbe17d97861c1510502a8441a4b39a9d784d36ecce91bf7da89f340f70b9d519c69eeecd1b7bf598503b63c45a9ca017b8b1e1d97e2618c0ea6f7798c6af752219bb49ce7e2cd210aca3118dcc0a898d0a54bf5e66a3167cda2c6ada7843c5ef94cbb850eaf38be736cb529b382e2a587c48c5e60c9b113fc093bdab4cef9cbe7e0a030076809f80bfb36e60c06ac52233cb7d3dedeeaff9a33dc22f9578d5a7910006de4a31952dee9aa061f6319f21e28f93043b4090d22e21b97a2a5cdc9742b6d1ad25578870574921471b8bbb8c4eff813cd74378ea55db39825dc0f21ec9c5d581a2a7c92813a9abf4dfff40d208b4f34d0aa7862a5bcb975bf164c34c22ac4a2940361bfed9af113f9d568eade4524b3e2f7f4c4ca307d0e832eb2cabf2be23f574722aa881d9a0b47c2635eb89c5cee3ccbb22a547d0175e8b3a692953b18e34de13ba7a3cd2ddb6efc82cc7382ad33819659644f9139577cb4cc758dd0e3a5259b98f96192c462277c468a3d7b032532f659a3bf2c97bb13937a1f757bff9992de69700696c282b67db548e4677ca8d72ede3806305b4c32dfc351d2bcca199f3925c2ba3903e13161005e57013359b04207498943211b86ab6dc1894a7f08c8cc66dd77a6082149541c518ff230f81f2abe848beb79a03fb3ea5281776a56cb8c9b843831828d9a90118abcd8fc5acbc04af0539d6d9b7f84079a4037ce4a0abf83bc9e26bae4924d4afa27c5dcaf3ba747a0e96eb567c4d825ff5be91392e0f7ebf802f999a33a813a8defe898279858855642aa2a5b7f44c15c189c5a4954b0e8e9e293aa622c452bb0c08b4dd294a8ef4ebbf3e7b01888dd837ba9522b6b79965421204d5cad23a6e80199aa0598238a15a3c1091dc663891716eee89ebeac926db8678f20114d6acad751fbfbf3303f3e03e7caf4746933690d5cc6dd2ee106891e470c50b0cc8ad92807289c2c54ca46802eee57023feca0268bc638534a20406c5e0e0d54f5317db5ed29ab61d0bc056cc84002f13d4ab7c6b13a6bb5a17387b26dab6d47601f1c0dda2bfa43df9fd1b82d5e2467623eaa9ca87bb6b3821279c5f9b6bdbd4b470743d5fc9e1d0c6bfced1a71392842110df228040704ccf7649368c3fed963f641b58e18df76a1172c892ac49a5055e3b8446e4ec4729fe779833e1f3deaf135b005f2ce78d1b28ab4c4df6e7472d172eeb20d1595abab89e9fba1f73d3a9432071c09163afd5010488e10e93d236f78d4a15eb066611ee373382bba722c40d9a41e0f23c176487a887c756095897bc3cfda19853b29420f571858501a89127731836303a3063041961ab9e4a3fd20e6177d45fe57aac21c6355041a010ca28c6d0072b44d847609180f658a938b2b149e4afd2a814cc25106c3c951e548399cc03592ab88c7b7bf3dc9875232a32236abcdc65da448ff281f53764df0f4c741b20fb55f12e7a2e1ad9d262625e205154946daf58d4b2f35210a5290c99191a52586e689ca14776d097a71b8868629f1079597c81ae734b9299d93192f2e38a818a8712969be8db955c6c2926ae1bfd9d6fbaed2f54d11c2a8702e853b13fa41245ba01c18d55f11860cf67aa40faf78e05211f4bcbf62dee8fc0aadd9574d3241fd615c0c5a988c407db099b49166e6a511b2b73cba8bea6013ec95d8c45dd494a38fac502f6a630e927d68140e721240e2050bb8a1be951b2cba71b87670f287f0047a3b6cd861fbc92000a7952fdb5a42b95b7c9424c2637c94c0f45d3791f7e4945a3f8e604ad5aecb331484d1215167c0a36cb98f410f466870d9168ab9bf6f25baf39c2ca7755e5271134e81d444e2c9f43cfec13fa7d0cf72f1445ada9ab1cfe3e67a47d71e8200cf807823c24f790aa8ff24f68e5050259c5cac2d8fe25b15d313981ad524379052d593f5f667be4da40466d9bf797a7ee59418fa50ad0ceebf98a199d760490d454a08275ade6dd26dd5a152f3e7aa165bbd727886294735585147e76dcc4b8f22a3eb9b9cb099fc72bee2f517f3ae140cd108951e37d8499bc6a04f7e17363eb942974e274c9ec7049feb598cf3a52fa36dd0d6b9d8e6acd969172610147d335c1de1c0ded3af83a7c54fef3247e667a1cb05172a47d5f74ed11e0a589d9276427a9f630f657aa3b049e9143123a1de17998d2b35bd6de430198fa853f292ab96f6669bbf31c8bb9d962c09ffcb6ad988d36300485759cd0301dd3d7abc3d77145cf358e5cfa9c71d63b9ce7303fdb32d56ecd5c9716fdf2a2d73346c5cac34ffc3047483e9bcde62039d58e87e43f68cd7dff99990942927365aac8397822a3de86f2c5e5e3f649fdeae43672e0a60565af35685005f4a8b1958f06efce77099d7618cbdce0f43314273f3e70a4778bddc6328265f07926054f4dd434d23dfe6a5a30fc4bb650b812c87c9689e4316c9657cd261f9837744bb93c8a21029ba4f8192a29341f2e8e150306503163ca03efc6796f8f13b8d8c3c32ef34e6dc391aac2fb93b7002a74661cb52a1e7bf6fe3c58f2b16c42bf26f193ad669ef66e3e83afb37c767b210aa7dd3907b163d24bf042179abc3483b90af9950c939fd4da13793d5dcfa97bd29c1d390d7d693fbd88365dec720283bbe255d20c3f9d5435b734f78503a17fc4b6de044448c58fb7acc25ef6bbf9c4584a6be20765b8db2f06dd783b3f24dc80a0a916878601e6f17e27e6ca02f22637cf5952a38f0ffa72a1b338ef480c388ada21d0676067508b10f5d5795b531a948362aadf7e1b4ae541dcffd2329a6f640fd14fe6ac4bdf04413f0a3633bdaa7370f9119fbe8217e79ee23f5c0305373e92e8aded8bd821cfca0b7d4a845a1210f4bd6728bb703ccaaef1422586c5c7b5852603aff817c2ef94749c0acfbef056e05cbba4b2199fecb5b6dab0b8fc9b19927e44104ce4e253b65d5917eca8a202f6cd80724523c9b9ecfc4408f3f4fdbf061e8cb1b058fc278512b073efa4d10a79e60166c052b5603150e8dfe9ee09732204d94bf5622ee7fd638b99f82f5d86c265ae35b76c694ba7d14cc08b4e11fa69f31240140757b85d56767c8b72b338e82aa9f6e003674a8f9c281d4b14885f39cb4c99b24001100a9766832e22193152d2b8d72816cf7e112c4d54354f8424593c1360536cf1f7a63ac735066fba001bba07480766fa76166323eeda0e37f7cefeeaf5f26487168f797889cdc6a01cee90592c3699db109680747267d48ad44bbd77eb5d6c4112cca4b20b2e0b24fd2bdbc4bee70dae4a20cd197a8938c33c99e07a651fb5ea6ed91cf67d5a2846f3a2015973857ff073a4e24404d08f3e1d6dbaf6b1c40e3d9416e0fffa12a6813c1f00923f951d8b7c196dce43d8718b16b44231a48548606a7ed78a644d93c7b5ab71115bbe8caaacda37240b261b024b035247a7a774bfa56ee071e378baf25ca4a47680740ad669ce6449ee06ef4aba2151cdc99cd3fb5eb3758cb97f631d5ccbf44a85f19342839b536b13322ff79a00289808f70f0d5590fe175d0d602b3dd4d61afc26dc49a8ac76ba23a5a4986494b3b7c18f863e91e5acf03fa163d57e107dead5d4fd9b9343a37ba8ccc09b285297f8b808f50e1a123a8b01f44b326c3118c629b6d260b498006fa1384122e4a8a039e6043aee3009f2ca6e017b6a3d862173543823e84cec38f2f209ffbd881d948461e0d169613a176ff610a8b02177c46c24f401b2c51124f1dbe97b4a12404e842b8be00f6701175086bf891037c10695553ed4df18e135db1e62c84856e764e19c0a5a53e44f6fd35e9d165dc71ddcdbfdc3e8f9fef7e2d966ee2bc84b8547eaa453e93f68051204a5783429223f5b2bb3cfc7e0e8d141054c03fe08c6b0e41e630d0180beaee014319804b09e271758629f31fa47b501b21bc3570a5900411a8d90a6d8410dc23f45cb6f833ee11172f577c2ccd26a515629f94e5b6d08702e2ea612ea36229d3d5a89e088696f5c0355d516c41cce38344b642fd542bc5509acb20fc9a78ddac27be5e2dc00b9ffa27afede6b58bae6b9141c77212d9610ce87b69d83d741e461f60ce6f99bae3dc11092c92bf0139864316934eb5ac5bfe83f2c5c912ef43c2750f4df9a7b52433d1ca1ed9cd94e2d2b23747eef5127094824a7fecdf77936500b9adc67cf17a0e9b017309e36f81e8e871fe58abe1bffdd049a5eb6554cd1e8e82f3207345fe9890b823f6ff268b99d17722df7fd1762bf0dff7f1f159ecb58ae6122a8a5a8637c472b7fe02a3421b49fdcc436eb03c0455b0e8bfa7b420f4bb078913e89f50b0a56a34cca2a84ec4a63cc04a04d0e9eec574bcc53e098075f7e35783a3d4b761ae37734c27acc23947d0ee527e12bbd837ab22b6dcb7dbcb6c512b54346c0c3655526c65c34e12a9a68d18d0747bb91b8a9dbdd05466d48a451eb4dfd7b9fcf88af6cae74ca1a8629b4b8021a6209fa1ab6745c4f99b0be0d26df9d9dab3f31100ca109537bbaf72eefb252ae03404095b28f3ee75892073c4a414a06fa841e3f32b69277119947f951ca5a5fc53d5073863c71be075dd1264cb77fd86b56514c61cb4e937d67fa38989e01fe8d8e11115f7db971ece56b96990459f4c695cb14c5a9368b06587e9dcdca9100a6a44fdf3be5f493dd31249cacd48652ed383207002d5c0c2bff37cdfaae943f0499704221fb37c3ce0bc091e45d00ec46a34c2071df8de5b169a24e9f79583da360ea963a2447d1fd0c0b5bd886c8823e2167576d55a56b4bf3587b317f1000456c442bd2a65ee283c44d2039aa66bc6e4f4cb9a299513eb02f3efd90271479ef0c76aa4f3c022585ae174210b0d0f5651ae2f00a4454e2f33d4cb3ce01f386f344a5f053056b116f6b79435debc38ba6ec957f3b1352a7602272dcc0115b82636e5b6bb4d50b50b02fb57532fc827ea1b461b3201a1579f6033b7d070505e5ed6bf2b903e00f3f9094727d350fcb1da0905cd79f3aa57ce89fdcb8f0b02604572fa396487d75daa6d5b4834fb9dd3603d9ba76cfdf38099c93b0436418abb2f2394f21ac480802a88caa20591440a40998bbcb52a516ff26217f36cb497862bf37f6734218327211a370891fcebb89c9d7575e8a5c53b059c603701d1d874d52b0cdac70227f0cef34c79f880a1c56ff33fd6815bd648a7a05ee3fae9b98959fe5295b9887edadd88e33d1315a361f66e58ecfd187ebd94a53e28f0129f0a7178b6fa0bce6a51bb85ec1ff61cb08158b1c7f9e44882b4bd0ee50280f6345c9fe9a6d0a4d9fbbfe034d524684928d9769536d4c55ad578ff5a17128816f6bf41e726847ad441366ab3fa94234fc640169c356c054d736d3fe70d13d097c2a0fbf56e48b4c690856c2979c7f9f2d1814b73f7e747fb3a4e424f68a401a335d9bc32d0d6a389ba11d6cf0cd308befc64b92c0fd4c595ba815cd50ef1349b48478f336fcde81aa8ba00265dac908a2931b5ab60d67404d04c34a2ac767674e8f1f526b00f08d5f984a9bca690dfe650104d38875c8c568a699a182c02213d478801faa51b0f05817a19bbc99ef550e403022688bd967d1f6d820790024555f51ca52cd2d2081e69c4a8d4f6521ebce489d24dfe7159c6128d20956648bb623b0a6aff9c298e517af840fed9a3e696cbdac837472019df5cbc2a8ccd3e1e047ea16a4291c8ae0392dac975452e2c9cd4a6c913913ab69d11235836ff2692855150d7826463c30c36513e515758236badc7c08656a08edd3a1e0aa4288af807306f15afbd292dc30dde908651076c3b403218e82e118a18192fd5bbb81e1cf9c980356626b3d922846ad484d3db5d81c51e85e2c0d2898955ab0931188f51f78815c94a49fd40a23238feffa83f09b95a7659937c9f8f4eba4aae70b71700556ef3fa248fa1830896871f8325c261ed2d14c7f931d8bbf5816b9c7516e63d5d280e0a4934867e529eec73f34946e8a8a637ed59d73f810683ccdc1a42b1376f222b45c3c9d6f339e84489b39856bea4c500d610abe675797da37a3b23360ceb5bb0e5e251b5deb08fd9f880f4b87da3d4a926159c9d596e3fbf25e425a375127e829ec151286b61d366d0a8396e952679e6a825ede4926e1ea95fb93137cc8957a26926a03df62daa9bf0dfa1c45d97b6f05bb4d579075857e3e3094cd4d975708f6edce80286416974f7b9cff12f5ee08424a8c38fef8959c12b6ec6b5b90f575d833133fe0b60ae84f4eb66d7c832ba45cfd213c8f3c13ccfa85ee18ecf08f4bc92e4ec0b627fbc6ef2b4e3bd71e62b0c8d8710cce46138c9a4d85c69683c1a2d8eb053eb8ceae425131e75a251424de765ef9077734cd5224245fe9f99e97ba3cf17082141433a9ef17f482758c9b4ddcad145990b471e1563d4287193d6e184f7da6446ce107f5df6a6893b73ae0488ea8f418ef2a294061e98aff17f4bcf77abaa7282ae0e64fb81d4c173344eede064c190aeda5c7bc4cb3002266f3b27d29c67b11390f49ee214d66d0c20fbd6ba968b63081b9b650d2f86db1934b3f311587ef11b4603d9229dc7fe8469c092074813e90957c8295632b9b1205837ad56698c8e4f62b2af132b2cb775c927b169da9e5dd056674d98ec35d10e27ef043f10e3ecabd3ef1007c6e7da63d4307823e87a76dfbb21b81f41dd1ea817a9a299d91343a67a47111505749c355948b367b6c7fa3947f9752e92267fc16c0bc3fde9fc0da9d05d03a437b519e76713d02822a8cecc126d52ca95cb07a4b29cdf60961e22312e6e6bc46a7dc524a5f67f7fdc100feea826e8944d29c4204f08e49b7011e292b3ad1e5dfeb436003667b90228625d3e42fe6aecc6d29b41e57834f3a47a9dd40e8c95f047d950eddde73e582be0845b2aa666e1e4aeb94bdd519fbb62dafabc97b69ee15fce9cc0e142751acc213958937a688c9ff75413f684271eddde302f21fd2b1d5339b3f7ee3daae6eb37a4c024eaf1872b408c951173248573b67f6ef7590d5534f5b05b9d0be7b7679bbad5c7acfc5fbd33be315d39cbac371885ad77c6128a7c5b5c7a36dca210db5bf55041e13815e9043d01a5280d9562b6fa4255636cd872e6f662b1d31832fc845634a348eeed43d986cc51bcaa203a43e604b862b14541b2b72d645a5a674ae5f419be67959ebdb7d1ee23f5bc62c5d98db1c8722c1afb16d4e793196c8173838fd8f1a1f3c0ce28ffdf90ef8d30494168dcf894e1774362f3c88022950309613c4dddfd43a899d12640859e84abf32f3165ab87f47059f3d582dd02d27fa76033b667254132ce5c042d6511fc325b4ec733c4c8eedb9eb12c244a44342ed9b0d845af0821bf7d1b835040e5667a35e9600998d6122ea3ca1008d3d9600a0f47c23553a8b8f2a6b1bc66da712c3269981007bc1ebf46ee2fe181e0cb9e9457a34e4d32cf9637826dae1394986bf56d6f38b452c1d71fbd0b3fc7e5b1473f89064740ccbfda788e0c37f4f3a8821bfe797f70bc1a2411cbddab468374bc375da4856d4bda41f8ec6c5dbeea803ef104ca09e73c2aecac12fdedae3126d2dbcbc1fdb4f70eed42915703ae64be957685d39d1ac3f1b8b4239552930ed260c11699b09efe6746c90bb27314a78eec17003014cb241c83ce14d6d7dd9fade7e317b21d4809d2d0fdc2b045cf3c25013abee416540bd1c73ed8854aa83898b5e8cf6829579e2867c0b6c3dbf061bef12702e141e0f36594082476b21d062bf9225d4e7e8cf9b4491fa46d683d9656791f5988fa1c1289286a966f1c716d6e34de5bfe9f48d7ee622452a4384b50ffceb117be3096d957a19950ea351b489585573fed8ce5d8a2bbffe0255dd8c5bae537a79afc70428666d34d82d804b46ed129f82c9d765ad0fbb0dceb7d997d01c5c2868317cb99e65df2599595280d2f9effc630e62a8af72d9ceffa8ad08f132fbcc7173edf5b3c468213f15910f2717d1885f2ce88d0526107681f2ae6a35b416f29d0548731dd72bb16c972bb0dcd72066a880a92747fa93bad5a75d01cd2d1d67ad544209d915dfcdc451711c3ecc9423f1f11c69c7d89eb29593cdd44361889b623da8b610892cb033fda56a330b3e27eb3dd4a5ff14fc95af7cf13c9bba7e96f8fb644b0c129cf0cf1b7a522106ce3472d1b55144653bd122a3e527925ae86c9199889880dc7ad8dabc2e8ae85705d6b2d3d4cba274c07d83fb3cff6b39141ba98ff1e3dabd95a59c926b3fb5002a3e3f08c2bb0d09e2de838c14dcb69519e9a6f76d9efe788cb987420421a97f6661b5be60a3ba54c071e2774492c575f51414d7b38e1026c9592e118cd14130a445df42841968cc55e124165fab934c6aaf087f384cb75fc77bde1e136428e49c08e21e41a9f12830ac880dae13d4073b028d7be276f6d8020c3b4ffdc4de569d2de84ead1a4b8daf27911844ed3e229cda37c094181bd52640f763d3d2fb09972dbb8813a42c9626e05a107b0f12a02a26b9f66fbd984db9fbc6811e845c0276668ea6f1ccca0fa4e1fb33154895d68949a9950296dc9a06c2b6f168bade9373c8f227e94aa11ccf67042a77c6296e346b6a0d613fc201531361562b84d759426d0bdc5f128a348572788b94fda33923cd6417f31dbd90cad97b1320a134567a048884923bed11ffa4096dc1374880af8f87389f94c6459b03c50618ed99a402d2f79f473a1a5f57e36bd149807b7c95e8069501e45bbe1eb333561f57cbb07fdeaa009c4c78315c0a6cab666030138b80c46ec0ab1086843325ab5ff797385065f579341c815548695815fca7710b4bf425eeec0f597245dd1e34f86aeeb8c2262a7ab690015e0cb777e1696385bf796f4983d991c17886e7daedd4d8a419bfc4dfeb9af3c6590f9e6f63f8547ed929b4d5c735ae9c81fe7f40c7e0d99f905d8ee9198549fc216ae539dface81c58249671f6fc322205ce408e48377028eaf9e790cf3273d001167cd37acf63f5a7658b9caa969a7898ad8fb7c443da777be687a3789d766fbabceefaab56deb684864e6eabc23407d65d4a079aac4962e528c62347d5dd2919a87a1d4073fff0815af842222c76b19604e5cda7f4f97de030f69ff03aafb40d6001c7bc095513285444cb5ef2cc9d3af8e8142e14a075110b3c7e27e1f2a5b07f91c70ddaf6fc222ffd7a9e4e4a81ecb09d292951db670f4e6a88dfe828d4e80bbe05d4b9f7b888ef90de2c8dbd6489d744d8d8568f191246f5463882f86353e6a2d7675b81cfa7b1db70a65ef0aa6c2068bc7459fb96aadf960c6b8c0fcab5cc6f0f7962f02fa5dc5d097ee5cf057e5b5d28f9519fc24953093e887201059d92018b837e39991504f5e171d4701791465e95bdf0985d703299e1c3c187d80d79d33f6224d4a5484935afde6e4342ff888715765fff188c36945f8f3ad5c398455150ee39fb611f8e37e79e34b7304465582f85faee9ff8fc012efb445fbca276cbc94a5869c16ff89f7b7fba51222e5c123c70a36d3483faf585f55f2c53e4c5364ea9b0c46ad5bcf96adb18049a76a0b63e4c52db41ecb6631863575bda7894edc66c6c72274b5ea143b12e7c11546785b212c00ee4eef1a5b553201e6267a57fb6fd212d6b9010b2ca0deccf47e43954ed3cb4ca50eb988a0b4324bd1835dd5a834d6f28528077b5367ed83954a9eb43a9dd0af5df09b94f2b05162cb429b3ba57268e0563716e7fc52af7e6be83e02e830e6e130c0a27051b3c58420da533d0df9febff40e3d6e7edb1609dd6f2b76c7117360fc19e93c734c9185fa39a0555d6940dc67f1eec6601712c2d202685f1ff2b9cc5bf17fa3725eddea54f294b7e85cdddd43ccbc9f6de222bf49993e85f2c48950c4f49a7fe6eda3af306d48b18890850ca7bf5c4ef430cdb77303855bfd9b4da98325d09e080f9fb8aee586065d3eb3939b34ce1996b34473e5f1dc623ce55f9fcb7a1406f9f65f95b742461d1185dd1b452063f0e43de0017dbf08f51ba05ffe49c88953f5f287540694c2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
