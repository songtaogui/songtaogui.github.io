<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"269ce806140abbdc1d0228f2a0e67254b5885c3b99290c5a9e6de2763e009e5049890963d3c53c210b8d3dd63d051fdc944d57bcfb49a116a178725c8387c166c2c42156fe334d279a5ec84e1e7a068ccf485b08d2e7b020d3080c25cfe9f09c35acc1798539e96fce5b98fce717997b39473a922b7ee313cb8b4630d6946a70ff1065d63602cbc02c0901bf2f7fdf2b37c1ed476a7440c83bc36cf41018ca072bb1a6aae72f9013fe38b97c2c5b5fb771bf74ec7e4dc8a8b2bf6ec1a70db078addf08192bce02e32f58db74a035d3d87aa426e217c661df6f4a78765590c2f8483c186e61d23ab194eb14ff2ba853407932555a4821331673b0eac9a5adf064928b8043887b7d7c61e2a697458a4bb3f184d83c5f1717a4ba301e9673ff776a65075363e8f8e702a7f755ce291a18a6cd688e689a0d536560deedf9afa8a60781a743b87d26c2ece53488fa38f0bf88cbf073cb84d1659550400673e480c0d2ad827a78edf4af56d7f0ea44f4436d0017bc970101b56976070f8f768f6f80257460bc43d3be05e138bd941d06a98e3666bfcce388ed2645f997f2c99604bda4d935dadbe8976df6b2b661b11bb4185148c59a0de29a62633b2727f31795fbeb165f7cdc8893f097976fef277df60410926324d18b3dd681c1873dc99372b73a6d181401bf76f9624c689c16012035d2c6cb6e9d78396ca9274198488376ab3c2f325fc62ffad7d7e2704bbe307629f10f34eee3962994514d538ab60700cebc54f37fd4a2a9c6a215a9b156642ed21fa9f01397a9fbc24bf05fc2f438e2d01aeabb55a2905f4ffe0e73c6dce6bd45fe477912b7ccbc6575de51e284856c29280cfad80e5741b1c4ba2bc2ee17d2789c8fb17f8646265e540734d31c353577696650870dedbe9726ba726a15984fb1622f52789a3d98aedb304e56a97c84c54b542f3b68485c733df98a12b9d0f4f67ba41a003ee31457a90c072ed28d89d6f8676ad77221039eb89ccc7ccfdbcc6d35165d90f77fd8d396c272ac5f4cf978fb9873ac353d95eca3160e05eb269bf0456b255b9f10de9dd01900c3220dcbe34b090ce86987b36b6d42d82bb211dbfcc91cc63fdf4364ca252d9cc3c0dafeabe9dc268aac7ff93694bfaaaceab711758f2418a6cad4a166b67d9dc2a720166dfbaff6832ffff976a2ec1aaa9ea777c09f3ef30f4081b074758317b6032d71951a191659752530f6da7e7deda0d11ee0b8fc84a490225119afb692fbe47ab10511eb4abedaf32e62799134673347ddd25ccd3835eb46d21be94ebed5193e620cea9ddbe1e61bb92388cf8782d431e7c01a4fcfe9bb4720ad55f83ac4bcef5fadc26de4a203937962a0dff953b85956a681669dfcf04fd24d5377b67823a8acb0171c67e92f999aaff8e6f536c035dabc41ff7e14b5decc32c45fef1c9882cd801ba79dcc4e13d55b140814815ad851155b7aa6ac4b74e5afcef67a6bef1ce70b873975a2314a3852fa15b3d2d54f2366a8b4d2ae7311b45742af89cc1068c971709ca9716f049d3b5e7106a6e308c126dc009cb3035d2f3efe518110c32143be5e67998906d14f8c3e255148212658e8cdd2ae9d71b5d2d94a5f0eb5554d6f57fa9ecd51cbe204b446e6ed1b6510c9f7f6e1faa0ec4c5a0b84b8b4fd13db4adf933d8443f870cae8939aac84f1f9c2dd96f3b41d46d16e4af31ce9579402cbe67513eda0081a42a7b928df7625f46fd8ed9655b450a0a4b4268681cc84209a6de0cd87789fbec3442e06f223b8f1cb0e35db6402243ce071f30028fa245bfe3a960b108e8adbd33c458e59b553e2eb331e98ca2425aa27644bfa31d75049e28762e4b7b7c7c26035235544ccbefb64de5be9a52fe2d2c778c66a15b82287d2ad8f8164d9200e12699e10406d06a2cf7b9ec8719de21ab225e4609121244aec9865adbfcb2aeb684a393a434bb34f8d994b878774d4baf2862baf4c9c99bb4d206fe2b2c421ab16c229e3382fb2792dc96fa827b40cc4cacc66048ddc5c2ed28aacfa610f7720f2a9e194763beaaf01c2c10c21e0da8838646796b13de604b1776ab532936b2b267b820a6b0ed43280e50adcb12ccd650389d05b756e84b4fd93362210b974de2a789c5a198a0f35abb961dc7993cd10303607625027cc1783def99aae21642caec80e711fbe1747042edc8a6b27d0959176b5a91635fdbc02ca815028dc729ba2f46124db3f2f3d01ad765be028554f2846fa8c3ec6333db2d12b91e419893b449254f359b9ef3c5dad7932b0cbdbade6a1b2fb71b92dc4bd5c887443a32771c1cd1636a8d07872aff926003bf1edf27440b37bf0e8c3e84f1e8f8f0ab6a3b48888c1736247d02db7a52ec5920e7760ea3a5f34b066101bb9a870ee73e986078bb324cf5fc032d5a7cf7a2da14710254be93ffdfe4cc4bbc2851db75e0f6c2687081c29325d13cfae591def0a2c5c46a6d936496c44a34e9284a48a4edef2cb4a8399672038b26f61f986fc59cd25fe7755025834b8a20e4b2236e66138ab73de4bd2e384b069aa26c2550fbe9cc235073af394b59dc6c77b1a558c8584e668c174a0c2eee5bf2019638c0e6f8a0dd303c8f619a93bd865273d0732475757c35c795292073a500ed9e48fa5341c49d642d50b50bea36a1497e0e27237c53f877107bfb75ded1ad08ed5612801acf03bb2fc41540c73672b9c88139adf16ffc87994b1adc038b32bfa267bb7fb12bc7b9377fc14a5d38d7b82aa25a3d69c31370940533f894ece850d41451875e0989c022f794fe78bbe112a79a2a8e63ee458ee64336b0d47c0bf7b3493fc9c61a0f6b692ea0e441b892a0f9f5992da83e1ad7552233c87f2f2a00c7c2e1601722e7e0c2a12a407a51a62517f83f3573c4ddb33f0a1f649297d1cc817e1583bd10ac3e2c1f325dc383e045f5015932fb25b8e4e8e2aaaefe677dc126ee38e9857abbec3aa9d32545658fdaca51a52331ce4197e37d9652e54621dfc1e47fdd1e7c1faf586904a61fc548eb03136117b71fd03930c268ac2838c75631d3817bd5aff5e766b203621fa35b68eb6af0bf3d9dd7f27edbea86fd3f674564b83891026430540c20a9d344900d4664cb4d3ed9e8dc560839611419c95d7d7cf565eeee27ec3339bbe6e5a5361a4dc1a6b87011b78b2c6bfebf56c0f0cbd70a2ad44a29f4b7bc5b31d5898dc37cdc0b8fdaec7ee1efebbad1954b02b27daa80ffe5a50872989e8ddadac023cdc77dc1ce9a1ff5c912eca0d97f0f06384fcddd31b4fee3cb5063b77b47ec3ae79eaf744525fd925f8c7c6c600d67bbaf195d0371d31c92dc15003db3d852b850c62106169dd3c00cad759ef06a11b4375fdb3635485d38cd78b48413c0b11e562aacbc9072c583435bd3c1ab3fe65d9d8406a478c553b4dcb853feedde5b50d8ba2d8bc5a3f9ed21a822d145eed6e38a1d5fb89f78d4147b492e3f899bb9859443eced23bd03cfdcb7cad6e96f326f06c150522058bde126ee13aca9d921344444fe834516fd5c47afa49259e905642f528a0207c3cf3c1ab939bb768c51128ba4ff7747c0c1d4ef20d3464783337ca88e90c8ebf198dc60a169655175b0db1af70a0086bb0ce22bcd8db590f6f307ce0e55f01e15d14180b57650353137cd9e7919601faf3ec7a2e61ae6de63d12412c60398bb4e793ca766b615c88e883ed3cab86789d783630691f3d710c9557ef0968f3ca3f5e6473ee3dbc39b49793bbcd6636259b7c975a15dab85f9a6f8f5eeaf85889878677081db18484ecc589e602a8cdce3060b200d09fd3a1fa542d27e1546d38db5f9b26cd287685edd838739749286a7d2333d795a45cc1deca10320d015d659dd3ea5efeb4af8531f97b3616b492007eb2d08e366e08df4b4a31d09986f7821ee28a15cdbee1fa5b571d4819c62429f52c6c52f213bd87cc93f2e8bf075982a6166ea5e52e1f807f195f85be22fec9df15efae015933dc57dd0d0990dc517232ae093c3f4194f025559be4317d786f2b599100ae241a7803bd96b6d3d542a6cd05fb0142cb2187d3ddc7126fb6fd7027f435b1aabf392f11e70bdb03ddb947e58118eb887fc5472f611b3d8100b46fbbd6da2095915c42d02f3ca5fae8ca4677ef51091d2ad3d7775d5258b2b9bad1ed8a58f91d014edb643890195154c3f5f53baf59accbf2e90fe3172b5482d854428d26e6d6b09e3f5912b8acc45c9af7f8370b06df873741a3e8b9875e71278bc0419f30f0be7ea1fad71fe224fc1631879a26c352f5a3818d9157a5ae8c35b328876c22f78c4b5f31d5a5f0f7f48cd1dcbcb6128ed493066d6aa37c9c4f60300f7721c209121463125fa140a7b664c7b51499baffbe6d5e42b39d6f5e526438e89ee0e6eddf3f672980454691647cb1965e5fb4ddaed5c64e7878ad11e18c5e9a556c42fd1ae907601bbb262f7ba641eab0b97841f96efeea6eb198dc8bdefa525e3f62e7b4367aa8de0866d0d492f7498096734a6b50d4357cd6a1be75dac60a47546df00708698a3618e7a2858033016adfb7ae5308362e95b97fff40bcecf2e65a5c44dde8559ad11762e08b8c3a1a240ada43fabc343b43adcbe10c97beb07a6f0c68da3924fe3a95bfea246c839cded6930e7b9019ab0be4b82f08854ff64f759d95cc4470edfab9c05400cab20ba0ab33c6db6c7dcaf75416887dc0c787e38cb3fcc58bf98d295201565a4ab287864a613356a13b91f03f91579b1a8e3944b8fe8105316fbbad5024aab749da80634892460c9b7649854452aaf12f5fde63aaa9110f6be312adfdf4689672612e7311f06e06d6623f6fa3f1e3f732e147f0032617aa44a05c0dcfa4dd3d128ea7276e38a4a1090d08b8bbc616b75f6304464b722ac293c71821ffb8e23e78e1492c62daa8debca9a3993f722421aa82a40afed6cd71d7680f6e42d20af7802731a685dd5b27e204ea1948b38f40262a9d6c276ed8b82e765c6b3565b78b966e160b95e91d9849f7bb6ff3fcc482f04b8c7a184dddb6b645cec783c11c543acd1cc68e38da856a826af3b1e2444bf8d84d1cb9ffb33ea054f864e92fa9cec94f196e39788cff8755280228f486bdacbe1e87990c1c66e77758e3557955e9cc693ae4d95c4653a61461d2c5c3bbdbda43d21ade4abd4998fe43fba7564b9c3e106eb6660ad8c179b32716f8bb4c2e2ac5787bc11b14674c59073bf6dad128c3a4643ecb99662a5fefad2e12a5afd60daf0675b36e08ced765cdf9e48dfd6a417f37c18b20f75686aff1d257deeec4142bc443f46f9cd367a8af97a5ac4ebc47090b8e34b41981a2886f33713bfe52d2ceecad2c58e330b475066b603a0a5d0b42372a5dfa41321c89c84cfb25b19b816cd92d9c744a6f9357e8369e8c322f34c9900b7fe57f5e4a170882c0ec2c1a55ff8f784129703827b495b8ce1739b16279278665b1eeaab9744761f41b3b5e3c27d0f492cb80ebeaa06f311684af9ab67c161dcb1954c6db7d08bb1b05fc65a49cc53c3c0edf67fbbbf475d8a52a28d8058240385b542fb7c38b97a56cdcaa586d2c74abc56ca4dc4aa51ccf0c4878e2f15960b9a6cbb2c23daea5fbb78da26bd2ceb6b541d25c287115cb5293165f3a5ef5ec53643e4ac9f364a60707433ce4af7b106c5db32afc4c8f2c68870ff9ce4fca3231c5a69584086bd417c91922de48b7788d886fc2a809419449e5b5eea987d22154de6d761c0ce7b3caceddfd10fc44202d20f65dca1f7435385da1eabf607e8251f40cc9b673d3c0a3cb8409d96c772bbaf30bf19fd8f9583f4b31851831cdb46979db08f5eb371c86d0de44d55b79c0976b85811620a7d4a62d55a4ce242534117194554af5cae7653fe18f7b79db9e142ad70672619002c0956e601cd1ccb58ab1399fe5fa7d0f5d4947eee38566144cfe7e746112dfafbb6d760abce7f10307eefab4824341a71878d71d758bf57a5d168bf2a7285d2d38e4691b84e8570b9e791b0688021fcc5eb69a65f6be715c3f1810556fc987dd64b149a4ebc2aa348df44ac0b921c4f264e93df2e8f6df9029f001b565123c567f8e64857e64331808653f740ecef3c84428ece28cc4d377a144e19b016152a561dac578f3c7dc9f26193d2789a2e63f6694c5666949d213ec79160470191c9130d18385d8afed20196757bc29dd38ce1bde2cd99bcd574cefb1f28b4f559f377981769bf749a70af4b2e7fd5c370ec340c5290b5c1ae21c39c6f38e552d9a6858e7aaadcaa90a927037aa47b7b8438993f4e46310d875ed7574f904afed5b5cd5f355103005641ff951a80709b851ac1b11106f9515e5771b9e336de870299f17525c45b997bfd9f4c605308b6560d8262528736a1c0a60dc9fe0ada30c122d837534d64228025c054b82ef53c3f7c41e77deb327fd751dd7c13f42dfc1efd27f5deee955719c33dfce42a45eef5929c2390d6d2a1f09b778beded5273fc9d326c886b9cb542035ffda9fb2214ad77f7b553ca5f538312cb4657a7f43d843a5d46306f112105571e073cd2c9ab045d71b05b73c86755ad57b8d7a60c2474efea72e020a85231cde0ace5c3bd2bf9361954c3dd0a4d6f55dddcbbef479bdfd4035431044045499f950e613c4c2727ff0d8929d26e499ea8f779979937bf49faf19cded318561ecba4e94de8b0e9a1f0117cac0de398f913a72ea8bfc440a22f604d37d0cc605891c718d3d07ffaf7ec796b2a8b4bca8d76da96d04dd10a6d45e946f5d3d1ac7955e3a089a8e87929993c0432c482aa49237cdb458eda15ba23c143462ba5f990f615ea2d35de60ce1ca9e6cdeb10bf5904a37f435ef8acb3303c4d47dc421048c371619aa6ded8912e84e2bf5791b453ed1812cba170b8407d4f5d0adc1c8e24426c2870f692d171da1adc6e3a3ef57b10155600bc734047c0f471c19d57861bdce1d439dd9620c68cc1ce076ddd7945908c98212c0acc4c693d0f893f22b0bfc81f3e7bf0a0e2b11ef438d511eb91e842d65b90f8f62b88da9353f141d1da9e37bc320e8f484d982a71d19c42308899010fa2c4500b269d6be168b0e22c5341486d74bec3389315b8d630cce3887d920b923c935cb9ed7527e4145f5916400befea8225da4af5382d91be4965fc4154822735275c190107d266cc28216ff2906a757ec4da53a8e7b2faaf1a3f06e723a7125cf4c609a3e604c4a1dfce45b409db4a446ec0d98daaf14dca37b48ec653674423c5b0b533e700f3fe4d09a83f538f12de0835a50d53bf15ab75beda7802e31c68c6e7e9b5ca995a0d1e8e7dbafee1f6195c2088ffffa0f85a6c20c3fa271243b24d575871caa90274d4476a51ea0488c0b5158433cadfaff9fbe246b502585908c9559e9a34fcd9f681c3e672f1cc150f57d8a127949a0fc67aa4f61760e87865585b7b4908be204b6422b892f288f15a04268afb75157edfcd78460ed391b2c2b5c6436044b014e89958884561fd5ea4b7d7ffd198eb9dd90d26717299ad12909fb01f4fb670b1df40844d8f4b33361609438d53a69a598e55f4e5062d9ccb9f23ecc73768953a5e09563e621d7b0168aceb4096a2652ea64cbabf4647adc9d215e203ddeea4a8e6d43c9d98b34c159eb47e4c0ce5e5fef2684d4e7f24e6b0f1bafcd781df528c7bc1ccdb0dcb2652ac301fbf09f3bd83d9ebddeebae8f5dc72dc2427140f1df7089fd76772f9326b52c34db7ea2b773658917643c73fdee4611d4e1667e74b46b5dc70fd5cdf5231243598c17559bacb288debdc353a6d75e7439dae1434ddfac1f82e05d8d9c1c4e2f0b76cf1d0771655460b2c61c16f0b52e66ff78525ad318b95fa942ae7925495e46690c082b7daa754693735dd9161ba866c565be9cd94e542b01a02abbc6d78e5db3675e0076977101f54716f736e61715a34fd7671f2d3fd0a28b0b911127c90d29a864e5d3eede6e6e852cc48db4b5df06085c461cfdcd5b88ed15f41efa9c3d0a91bac277fa4701340699695c5f07582d17e96c38a1ac19cffff91e04683c97ad355abb095041eeb2c28dd28b9630b7da8e4f1ffa9f6d0ac298ac74f4fa9739931f7323183ed356f73668029797f495e90b18f54074bed6477813386bacabaa159cb0079f23c32c8891061f770ac5c9260b33564b7271db757a1af6da579e4acf881dd29a5442d31f326b06c56a474dfd0383afeef63438e3e8f8f8c38ac97495d9eb3024900f890db6324a66d58efbe61ac5c40e13ae4faab06b520f23e2a541a8d166901a107af39cdb6f3b7c4625dc580b890b8caee97670b69461e07d39998cb74143755e3cec004a8b3990e873d8a60bf13f2707a59f650f6142ca0bbf172c2ec08df80925bb8865b840c53e50c8b31a5bf3070b571e13029b5b64d1965e32c466303b823d0f3aeae573c05795dd2343b8a1de0073e575afff6a7f57cfcb47249213699ab6ff8fb811c6ce3b26b7ac54d5e6240fbca85ebf88d067e01b658551b2acd21c8e3444d5241f97c9641178ed14f80e92c1cb0b43051e6504713bc8b3de9cfdb8a70087ea204d1ca9dd5296a74b1c1d0f3deb6069034699160d29d067cfa96da337965e0962ebfac50834d8e5f0c093fb52cd16e1c77e34daa37bdb37fa180bd3119ac5b6e8d1272bfe528e7eef75e5e2a3d300fd47efbd3bbb7034a43bb8fb2421f27e3c353e81f2e61f5b974d64df374faf08a5593cd298723d816831a2e8b774db687c341f6b7db578894e833df22c58c8e5fd7419e25e803599e7dc3c3e9a8cb188a1e96f656c64bfcbce069f05ac1171f1714d200ec2a3372076595b5ce0dbb4759186ac038184d3fb901729d17dff4e9b3e128e61d564ffd8611d6321fdd046bf598af5068fc0d22fcaa2e40eac6d7ce1ee02e156f9946aa8d4bef7a250032f0e28f19894bf4f8c69a519ae12666800af2d3dc5684359cbc895969f74cea9de0ace2b23b1184ea85e19c99288f463b6bf41f290116910c7bb2c98f719d7bb97ead53909ea47bfa35eb841b130780aafb24390fe8f8b644201df25b5d302f82483940925e9d0df6bc384010e02257fb0511738ed6240f23cfd723e98b556ff34787f36221eab4f5125d98f1067de385a3128fe382b2eef5dfca78c2de060864c960a870549ee65e8942be41eeab26b36213ff59fb18aa814b0cb674168f2c3d4651571d66735bee405041e6c304c91c1395e4f55b1954c1dd3538fd6913439cef34c25bf864c40077fd749da554ddf4ea0511a93df330f788b92ed0c41665dff1a0c4da1b6f69eacec7397439945e9ecf56856a76f6e9cf52ced4e90c103888aa7f5b4ebd09b1972161a2fd9b47f77e2327026c01b6816cd37ebee5486d7a87f4943bc025f18bd08cafe99ecd6e70eb351da363a1371847d735a57af0b0aafc17e846f57468540cdf8fe76a8e5b7011cab9758e7b81d4a9f94d5cda89f185bd1800cb21caa0feda378ca2b7784a8b94641f8ceb4b2d07fed0b94b754ea2140bf82dfd1fa9ff3c168c7801b75447db97816d80af989dfc20b440a537e72f83d6a4705a588e3aae938326f37a7454f77310c718f00af51d54f7ddbd1c106298464b3a438c889b3f0c7dabfc7d7d85a0fc08ced4233931ac156ba5495c43ca82d12baffd283e9333a16c70e04f842cce59db1226f88e80398012b3faaea777fa066b61b2ae3e6ac35fd58ad494c3a3272a0925b1cd7a23dc569fb85c38f8b1e5ff7af3e3031198b346d35eec865074906e9bc0accde56fffef063b01a8db844a38976b3e7f6a21641581be6764a362988f3f52be1f22e9b667974b08b7625b69aea8ed0395294b021dd1e8719c399ce60556bc6b1884658edbb01eff6ff7a6c834d20d0c31b6ec81a500eb3c36706f5270cdf9776070627e5f00a4632f836d36e26eadfe95398108bf9d088c96c3655f04b22c139217a2a9462450934b23fd0d2a0581cf3b7359117e524f856f06983f703d556551b42a94cdea3d47dfcb3e33b0854dc0981ee32db889a1491312e744a717e057dcba51eeec6780885092651c70070149aadb39c247b8961eee9f055fd222a8cb0020e5c62cbc60d95ecf12e0dc6e967f28f6dd8679a52e23cf0714aa0baad33954844a77209fccda52f85002c401e727fa49e6c371346ab5def7027a8f109ca3d0e062f3cd0963d771ce53abcd0c715508471a0f426b839790ec1a36aee9d5e06cab88c7854d642a897057f1f55f7100fb0fb5da1e2945a531e3d63350b694e8665384f432dd16d6810b04dbc94e9ff6f80edfa1bee56a12711751b9f41caa9091a7fa33a05c23ec2b12b9418fbe4bccf613636bcf788ab0d7bd86c5ea0a1dad5eb77a0601b6371d595902f8dbb97cb2b445f0e67662193bae92350cd0306c95e777b1bb763cde8fb5e51dc133d8b2f4f36357f9f04b7ac767c8e3d628f00bd7a4a5cba5219c58250f839efa01cf4be77d8e9a973f515a91723bc9a35beae19784cb2fa8b09c48b0b1ffc0f3fcb815444b382d26a641e4267954ab50ff5c718125caf2784a7603fd8ec73dc5cd295ca6dfb838d7ce94d07a18a8ca07d3101dfa650c5bd95e87f16cd8cdf6af2335a9d6816656e2b9c346db89b42fbf5dc062d8d660bf958b3e195c964f29df97609a3dc2ed2c72f7cb20f1567bbf7efa6bfbcd339b9a9cb8cc1e2d75651b0ea226b5dca8f1b520501f6a609ab8a4f9a937d95095b81740ccbf18c839c7315b508d665f53c155ef904435a9f28897cfc9136410855d8a41311cd8c7fed49bc1964f2ac2f6b2b11d4eb10d340315352351d6377e720509cb049615b283da9ea38d72278c7e208bfe964897bba7f2af8b99c45091e319c223356b65df53b4c69097cea7ca0b46de2883a5d0d567dda15a5165302e829a1a3675d75a40a3a40afae7c526e965a16d231a5cfd0c8ee2ab950974e81b4b05e779e09e63c9398e44917d715e9c71ac73b0cea2e294a42b6cf19eca17bab840944bfd7c3222046e96dd2f44c03fe6f169ea51d8def2496e1113a91606a5f62af14fe318cecfa933224635f319e57830d3ac016bf69912c04ab86fc1fd283f852ccdae25fcd5d986ef2f6dbdb3d6383f439a3c1a0e4a2d97b4890248cb082033a76ed253964c8862e3b1ee90c629134b8b06b308c1366b6b398ed8ca907d0a88b01c2524d255555ca2bbdec7c5e31fb6d10a55076156117cb60f76849ea324c2a64bcd8095c71dfae2d91e28f2221d4affbde3345d8fed68f8f853d54663090ee8311fd12aef40f8663a8207658c6ed4a682f5b0b212a22c0531937f91495bbd49703948914ba37ab515b6e420a0a14a90e9e687a56e08f4138c113079de2fff641104400d878960441efe3862e95ff00aaebf1dba791cb8d6a773c8bfa00f4f68a537124f23be31de71bf4b76cd77691053fc1f460b9e46d6be03f125e1da933f12b82fadfa29ff476154f586a10035d2526f0cc553c93affd1a2c32583ecffa5082332870b64f053cbe77c885d1644f35e15d25a509f9a1b05f411c9628d750372ae615896f73d408ade955cbc73d675d418b33d12f9c05f7acc38227a0591f5a1b451d2cba03ccbc3bf9671041c0d0962040c3ad152caf5ae50c68ea897fb2fec882dbd717763aeaa25360a5be202d659e0f5a65c23f836ccbdcb7012422d37e4158c6ba80f3ea6161b807e22dec278682eef93234d27e1b9ddb07b02fb355cd61ecab44ac0fa26cd3281a742fca27dbec7ece29134fd588e19463b661285408c923c708aa974bfbaaa89d61dc20fde351bcbd96117c358e7761e87281502c81f4b4db7726189eb76a51a0af65e59cd7f9fd24ac12170c58bcc8a43459c77d9accbb746ad8664b976228b9f52b58feb08109cd2d5fb4bc3aa99872a64cc140c30aae1a87e705d64f7d4ccc1d9fe083f1026be65982a4724aeaa656681b37037f0219c16c6aecd735972ac83f817e73a5ba19ba793419653653a6cb16d5d931dabc1a0d7a4a3097a4e092991ed14333e9a9361b3083a24efbf0aeb62b4c37046d8e847716df8829f012068a5febcfb651996f366d28cde937a3be35b8d365112960699fa34a04b41ce15d3835e74a1126445d0850d83eb921375cb8f1358fdb98b765f870552fb6c8d02b017da73d0d42c40f2b3b01b5a6468e963d052b69105e08761ef96e584a10c53c90991c02f82503bb152f79ed56b37fb306f23a17896fb26733165071dfa1d6e3b973d4ce489bf458ce71524d17259a93d7adc9a90f734cb65187980218d1e3661422a0ce4747ca43c328c60ccfbcf65235f6ee6ef433fc5442127503f56a7d19492ae61651bec632bd546b72edbc55cc6944008b7e68376633c4a24e50653a3522771f2ec722b017438981b7c0fd4e47df4af12fab72bb89209e062f4433f0178f57d731ee5e13ed4ddab6eb1e92d407b7abf2b8002f18a1351298983d779dc0d3b497b1c269c14e2191266ad670da676f24be68d7558dd6ea293e51f6f2e7357c37e999af9a42f20a1187691674d6c30b6564b6bc9b3d5dd1d4f0edfc5886100320d5499be441156f51b291dac63408286e7cb122c30722c219d902b96ccb1e61689ef1b49963d0770869b99933948ef1de7c274aa0c27d81f2558782f9697e3afa6371a1f6a5d2a12ca7a464907d1ec0d56bf4c6879d311880e6468d05cf83b043fb5df8b73a111bb955aed89293a65829ff1777c8bd99549b0d31ac23ea09473f3a81e412ca7a12405f09f30523fa73193b6c543c461838b3f1c373274badc5ff30181eb6b31cd2801d5cab5808b0d7ba7654a28cea20908f531ef9ab3004bbf3f7afc4a10305b47d4858fda45d96f591dd29f6a47edb33bd7772480f840f9f537c357eb169a37539193af372540b7bc0b0a9633adabcc9e4281199b6644ca77d5eafdd4d3e9916c310fcfbd669741d48772e20eeef4489935a1f08f4b0bc1b152164aeea0078fe13a789e11ac95e32c3a6cd68091f9887e1edd1311226c177483df1a7772384016a00833d4e82d499df986d78986dc90e82c499accf6ad84e4a57bd89793454e1c9b23614ca9ffcb99dca5f9af3155ad887c04a6d157e6ddc982fcab983c483edc5155e27ebd6874390c08dab058ef80fd03c956fbcd4981f93e8df2628ab38c72d3fecbb4bf4804cf9358e1e31aa6e91f9250406391da1e7bac40af05c20cafdaa5613c5567a97de623a558483d83fe18baf9c038951bc44074107f6c82750da4953427bebf90656ddf6cb86be191173c5fb381c97b3eb038eeccff6a47a10d1e81e5acac17fc2da4811b21060423682f67fe741b432a2fb9d9253530c01d8392049b043ace139aa1896d15543baeec212479a10128c996f6142d86ed0f18000ca38f292588c7ee0d1cf472761fb54b29c4797fcd8e3ea1412546580a0412ca4f5d60175133f54556323d3df4bdc4c4b3b25d131ece5cfbb3acf65c19f87ebfd4920f332b76cbb35e78e7d27fe0706dfecb97184687ebdc00bbc6e304bd3f9da68cb830dc971b666cc3e2c094e8b45dfffe663987bad2153149a76819c12ad1af3ead68f8c1b8fd24694caa8ddd3706d86c91adf643495e0b82e6f39b6ca6ecf4004fa518c1ad487712a1131b9ddd6d10740001ec23120da8fa719b2f0af2a1a0240866f19f7e23204438d690cb992c78688ab5c262b35fe5a87b947fc78037ed3f82f62ce71cff2fa1907832057e0fdec449f4f0c4af53c88d5bea1665c216f3b5f052a9427c7183ea5af16604df15f2704d29476ef0d2fb51a8e074e84c7ae78a739939788bfe456a7e388f53cd8f34eb924801c2db372281b69c66651720c9f8ef08bb1813db92b570910d5abdd9b6899a980c691a4d58629b6043aed228df1bbaf197d7820e095bdec43e484a850e018b6797385df0d5b6a02c5e2cda3bf40eb0f3c863496f608a7a0d3b65fc20ead4dec76dd75879c5b98d5dafe6ec8a2bb8de039ec515471e61886587df537aa5b757142207503e5f33e592bc7078ea206ceecb001149e2e83dd136bb1e8f5e5c39a0c1a1497a8726f425239f8654b86654d309bd5bd07f9dc90f689467a0b08fb4b20b227cc9a94fb6dc3a770884b47f06169c0b2654810c9e8db0310c6e2ed79352af0decc6befcde76d3128ce8392a77d321ab4f7f1013d7dcf6c35e32a4d472dfae189c607691511a071e0d0293347f2ceea89446491d2978e8df418b2c91e0697700ec7a6ab8624512afb0cb293a70277f2f1758bfd099865ff2f1037f77759376956ccdd50e9a9645aa8f09f2c585c31a19e0d92c344343b3b5c4adbb622e1b06e1bf3bf780e07a38788bad7320cce98afcd77a4aba4dacb8777fcbd91833a6efab2b215dff8bbd874df8b70b187f7da30441567341124e9524fb15f260c92bdee0241ab41068efaf4384d50c1901658a2f3713f8b333d1e95b130977457b742c0e0b0ea0e63aad68c76b6b47cac66650aad1541c57dbac69427e550e5e91fb36065f650c8a77cd1ad78fedd581e7b78558a75b4039fcc2d17110b595582a6446dcea6f4e4c45f6c566b9a185a6b695210ff2334b6bdd605bb51368a08c2013ff283d46468942882aa8fc3598f3a729104d6df415ddd84611f6ac5349e82948755a6008dd9b50ca68e2febcffad9741d073b699fcc0cab73cd77f3091f2326a97b4e6b3f4aa988c4c0de036ab58066ae685b8ef6bfc971626ed7e6ee5d1b73f7e87582d4bd3fe393311b2f3e5ee799e0fa22e65f906f06c5df412ac408437133c8b8254e1b6c107f2d5cbcc81f0e31bf8b91439ec5a0d95aa9101a99ede7bb90ac0af0c02f565c79a11ea753877cd56b0e9409151b29501d56fcaeb1717690f2e9d1997e54acbcc66c2bed33982da81607d144a7457f46e7c30b1a2fd9dc9cfe3b4a7c7ffcb682cfcf645cc00c5a0937adc6ae30ad3de9c55ac2ddb7750a9e1b68b3b9b9b42efcc2a41a1a257e82beb2614fd4bbc890702a9b9e6c071a8713c73ed41d44571752dfce23a95ae4cd2afd893cbb8eb9adc2413963a3d464f6ea94c6d8c4c00a0ed6584ab24f0c41912fcce0f2b03bc65fa52fa7c8a9e6525a84703ddb83764cffd291832d0bb3f8fd13dc36b3be5168ba90b32f35facef47c284234094263ade95fbcf379be95d9b37986cfc66b1b2a92c97f2bdeb2c5cad8a9d1403986e11cfce7400a87f78990746ddc397677d5c8c8d12eee4d3294bb2dfb7b0e016bbc45bc87d3fdb84194036ee5176fa7563f98c9b3937c3fe470c7030acba29bb0663b5ca49a2829cbc76bc46d409c6d0b9c33f4461cb57a4abda37fa5af046a6b677c5825015cb5581a2b314d14a601304c9af919322b40fcebb85ed7586055811dd1644e6c866c1808b6e4549cb9531444b7077a787d46a896a96c2b43cef9c1f880536074f8180700cf3756d554b593b95bbf7fb389ce52140d3b6f3dc1087f1c557de7911eca19a87bfc52cdb1d211c6f4eb466170717b816595658c6456c5582dcdc723b646a0cb5e230804e83fc6d6663bd264d49e4461efef833f5d73c26e2ea0294086a8bbe749708100a261cc1701579e6686bba5c7f0315bbd6994204c355f97e8073b9985e9cdb4e00c1017b9a7e1ec16b2993142ffbc1b5c922c3b93765fd47429dbef3c0deae5671d1f076340f10e4a3be05d9b48599e5b83fc5aa488c468b70c54f69050c14283e7b8f33486f93d3ae450901b574332a8695c70fda11a0d98a88a0aea315223780e550492aa926e260cbcd187132ec7d844bc1d8673626a118551dba5aec0e0bcd9a2ff8d91a73895d80649ceb2adc79af45a3bdd58dfa80540bb880c5b007ec86b9005471c343cc6267093ab4d3ab06e253e8142776329cd1d7de90ba6771b4c98ae95bc34bba6869904dc1d65c75ae62084b1b5e29fce77e3d87a62765717b0cdf7c5dc780250150c66c66eb272ce0ae4902f91b71ef40feb48376a7d1fdf17d2988ca7fa96f6028745612b1ac94641fe08c45c7345e7be360362c29df4f5d903ff7309aedde8925a9a19dff6b9f876a631050a8bfed5ea7b56eca098bcbd27263b672a2b66615c870d504f66bed0c36faa2fe00b6052ab53025cbae60c25d373b4f60ad4d0219f1e92b6e33498dff86af27af916d0b42c2ffc3b61913d0b557378817c73b4ce8c6fc77e787634051dfac517a262618982a3405b9f1ecc501130491cf2b86528e46ad0e2169997c97337f61345804529dc9171cf0cc7bcee7e0e5c0eaa213bbd640f3f965bcab765871a7924021afe3b0eba55425a78653d9a481f3bc685a743cc2d5de1ce0715534c2fa9cca87f21722ff6a08037b857e13b462ec336b8b261fb72d8639ca6f4c59f1354c5a82b6e359860b65c9ae74775f8a1baf8e93cf3c4776a42d1232e9e88bfa7ae33dc4e57553b2a84688b623e93048d65deb623f524762963762244f8830a83927c15367e4d8022013eb65e10baad24899acca5368aa2cd163c8cda48f5a480e3d548bd1179686b338b6a1dd5df5b0f34a04245eeeb5a03034deaf180dabd04fc3e73357e0c6fb82f65934d7eedf2c59f436b97df44c3c8381468afd52b61f01fca1a2730f71a718cb80a19c8d4ca40cb703756dffb373f6643cae2ceee2df2c1b10fe10ba9a88cc494485880fce3765a0cef4a3a3ddee89d9797be2b1e5086ad0be3e96179b4b24c2c311d244ace5521bdf8a67650471190b2fb22b5a8fc2bc920992a2ebacb8394556102bb30918377e0647d66190dc5cb13e9799575d8a4b0fe347dd58b158facb8e3f3c862d9689aa5d8cd01fccbbfe5658a28a4ce8e57cdc53099eed028fb0ceaf1eebfc312274dc7c08923223abd54922b3791ea4df2121ea318abfe0fa32196631d5dee023b0fc36467a014f635ce328a5b5703234658c5546d8a9b14eb99a6d5274cb5ccc50616362f4022ca3c5a046000af1bbb70ba4265ff0caf897558012d18ff4ece91b41bd68e97b1fa5564a269aea042cd4f30c1ae842500743fb86c30edd5354ca490d3768efd21fffee5aa81031986bddf1141b585625af630363a2efa6ce0126a6784615bf40cc494a495a6c30dfefab449210c1c24ed3b14f8413b1da9d4fcdabb9555e97860caa9b6a63b5c17679d0873a78d4eaf084b169fbb8168c80a843c21c513e05f2617cdf2c8957188af4d7bd8da0e4c86272078b88a4591bc67015dc978e36a9a944eedbe5a0ae31b7c363855d84a07128c23057f99be425f49fe32a16468c226411256dc235917c3e3e5e8b24ed3c4c64b3fb38e0a05d3f8b3501e76105208229f0aa713e0c5daed56665d00a67553829091e2b4c81fbf927ded9b33b1a656a1c857169b67eb5d31c468b75870d7907b2354be5da691cd5a885883060da1e6494a45da1e36ed472f1d1a7ddb5606d205fc3b604f26a6a80d0b232ac34841cd1cd1b2a4ae1fef70e453f043e4f6283e86ead01b72861985d07f676940bcbc10c6a52073de548847747ac23f8308a01ffe340958ba41d05ec1b14d95547466348a3b26daa8498700cac5f84504e03cb7e84c25946caad2b24b672abd6f063ec4ae9aaed4604c24804dc8dee4ca7f26d9168a8af8e9fd1c47d0e7a91ebbba1a43908e17eb9128eea08a89fa8e5327c53d76d64bb209918cee6fd0c01fea18ec8e0f69f6119f3908617e2247549ed4cb16166792539e57617178916939429af41d2fb77f2f401d92f7a83652f39ee68a8b6025dd7d928e794c096c98ec2f5886ae32e7c75bd5725ff17aee4e8728a08547c00e4ef6d1c1a9b633d78ac829c28a44c62e25b99a81911fd4b73a42302ee761050329174b4d50fa36986c2c05385b0b632b750ba355a50f1f7688f13eafe341eb0960a3e5bda82ec2fd15a87b16c2da1846fa60b5398d8254d8a1ff54e522dd3db12fc4d6b1a19048c3db5023ea8dfcbbae9e3a70d16c8e6f236d4652070611bd5bfd47fcd937f925c355e0d1f9f50d47ebfe65b69cb416b2f11ec27f63ae15385d210b44f33a192d22db7517e5dcf669ade2b87cb958bd1e8f5622318e503cdd927bc20cdf6f0518a713892bfab95d0b62070d337367d3ff748c7bd0911a7e67a92162ffeba8b56d86c5d928ec9b436184","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
