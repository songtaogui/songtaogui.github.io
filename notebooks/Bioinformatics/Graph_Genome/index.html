<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6e42f413930a33a2e911a04c2441c5f231089563a71ee6bca51764f33b17ff8c81bc2c6ede2f1fb0ea3ea8733b434e41de2f30bfe08dc3f85d2544e923fef9461ef1b8f39c8157003a07f0f3bc98b894f763a23204f6fe43447857736c8beb49806b2b0fb1d81edcb142de93e644ee2067a15c6084571cdaafb45aea8fe874f383f6a07fb99f9f1fc39d2ad7a7b0fe787c449b4fd9ad22461261026648f5c1e44d497440d2da670a8c5b3ca19634c4fa83d9c394804a3f92e9bdfebaaa867a3fcdb63062e2ce0a7c82a8503b76790a1caf4474fee43d210ddc1531b45f03a4fdbcee8d8adfcac38b41e693a083c836e35a2ef36db3f6468a7161a314396a269f8b0174100fb6c72862156955eeb17e7405dc435f6884bb2ae848a7766bd1be695c968c800ddbf44f8022fb583a5086724341fe9bc135ce2268e36e0e8b8b069db91664cf874fad9cc342e69fb843409eb76554d9e31bfd2dc6a7c9ee9a48787db80276c01cba0ebc94d51f11691b1d1cebb9bf3cc1968699b70b438a3c10a8d353224cbfede40f3c121f4f7241d0e1e10b0e25084e5080d3ccaefd0247f4f62f7ef3a6753d5a3b0f4a1fdb20c2b3eac75a643a415c9128cdc23941d4f346fd3641abb0e4f153c24f8e07fad946152def6f5953aef5900f74333e4ed1f1723ed7cef67b69f9beb34b337ae81b5a2cae8fb701f2ba730b5379abcff4ea8801eb27658e03049114806dc29a001fee5334f2183829d0e3c1941a5fa60e7da4da6cbe99beaee048332c8ddc8420d14761411360d5f3383fef478cf79c8082197a48d98cd6d193effee7ea7b4592619fda07251c3d076291d8a1303c566d4f8d993fe5f849b72e22b2d4d4d4c41f8d1784e8593cc352b795dbb909876bfc7e966b333bab025a50ff357a1b1bf3357ccd91937c18b35ea13ffa081a3f531e33a06cc8c39ae2ddee0121a7000582917b122eff88a33b363fe269c579e47537972c040c399003064e0cfc31ad97f77227830efa6af05769077ab4f5a46e91aa11bdaaf76740b30056e9541e0a78d793c2bf281ca139c70b891bd37fce6978da8f0ad105b11ccd8ffa14131aaccd001ddf52040b6086bf1cd1421999a5ce9ad43d41bf8e2557fc52ef6ec6d122daaab2a6825bffa00fdfde98eb100c676e0bbb4847335569583cf9d22686ad7a2d555f962d1955b5a7025ad768efbc5ff9f0d7dfc3870d84ee2496b960daa7874161a631ee3d2c099139b6e1992ec9678d8c17cd088e6c854b1121e61c94f4d7ff4b4115f114d2c387f6d4d10394a565dbc96118ffb81ed9d127b0c242e5af861f884580ec2c69bb97e972b96f7a4b10b70d8a7455bb1b41b5b47e1975bd61e13992cde22eb733e78b0e077a945fc954ae7bdd9eac08f31bc19d54be3647adf06ca2b9621328e7fee1e31a22686c4bed339dd3401d0af5410bb8c1afff6d23f7054c900f250781b9faa3e7ec3be98c9c4efb6630c3ece1d1963edbde1911f934e1bd2cfc8c0f136cf396674b3c0fc157712ea487f91a7c4999afe9ad90b0b241849a33beb87391ee5d114f1dab498850a93f820468558c9eff6c0927ffb1e819d68da60becd833486d4f55a89e5799ef3fb89636fc22f27f688a913cad3aa771243d4f03ded8374c620096dc41cd832c8d850a5959ade50c1967c8494e5d3959dfb8ca71c517ed270427652e8be7f0a3cbe45676011e4ecb4727048048f1bc96f1a3cb2f47a9c314994677bd03e8e9ad889fdc8780f4fb05dbbd704d9a78cfb93cc745804a87066fe073c9673f972e7762cb8eeb62d6d786cd17687587464f5b482599100a52e16749140e97d743f0291522b1ba8a87a30a2ac332e4b59778ed1a4dd004d494872ad05720880795fd58da2551f19aee7f2bb65840672d159fb8b514e518c9fab8314f02e4329d07e51d02b17dd1599bf8d27eb4afacc23f4f89a4c08cde42e67d5fa7df746c8b0499191e7792deefb55e2303003c3d55a6aa02705f5a55c8258b5a61c6b2bc131b98682fe30bd09a107120d9c6d57471ab100fec20d9bde2d028ab89f5b63185f5b87a1addf5f718f49d1f736353468fc0218f97dfe87dc1adf784264cd7e600e4b91e88aeb020f465ece012afb979f75d0a749af1198c91dd5082bdfb1e201a3184ec2c7fa7caa95e4d24ea526c06f889ba27a28da7cae516fabdbb002b78d6b926208265ceb0a36b960b4812ea860017fc7d13a582b997ecab0726ad96703c7c52d2680d0cbab0ea72ea0459d609c668b0c831e89250a6801c4a76f91477cab99c29a54f468bdd0e62f9439e45346d46392c35fcc8e77d867c8fa37f688c149c92eecbf35202b6815d2c32511ff50aece8acc190873c618e1dd74f6b64d2269c059bae504f408c4e85d568faabdd399b04ed3635a7b15147aa3e52b6cb3190c5ef5bbe25e9c9b3fc4578bb1fe75b31a8b7ec93f9b2363ee27ba061634e0cdae6a2d8a232163ede0234e23ffb55e56ee58d572eabd9c73881bee8db610b17928a1cba10ff1d67b410b9e292bb1a64b19de31160fcd8208ad220026e37d89a2e22a7f73bc262d6fb0c11cb6a575283c75e6b1105e078f63900460a136f1278138b5af5201c376d63200a4bb25d9d580001b5636493377f2c8733bdf0770205b722e3026995172905c3b77d19fd5725e10a17cfc81f5ec7080bfa95b7b63e03e222504c0ad6e1a92bf2451e4a5e0ce1bbcbcc6bbe2e1394a1bb24fe092c619a552c14e8114d89dc8d5e5a4e30c1f3de211eebee1f3a609ee94cf8905bd03e26a14ef5adc7a16400ff1add632a1721609cb7a5a51e62bd6961ba6015cca7194ae994e37980eb6ae255f67dbb80fe9bc028016ccc26cb518c17d6ac61f602e25428c2b9b3095400164d217012a3166a0da01a6e2cc7791e156680e2beede1bc93be8a007ec09aac088e9e008409fddf41b5fb14cfde605de909b6756bf8a96bebc4410e52d5e56ff26955ae2b389b66e29cfe0efc3b238227c6464617f0d2bec7952a949d32794e350c31f1c9d39ecb129a66cc3c28cfbf3321683b2572e4755d576d056fdfce1bb574bf522e15dafd772cc871580b9f8a49fa77ca8b0120ffc88c6881724cb424cbf5bbaf4af5d93d088e2501792420c75455da3875976fa7f3f7c3d17cc52987cbac7cd640db5311ab1b40cf8f04b5ca85099710b858d99474f7a030cad397b1342698bfe1dedb9a434017f21c4bbca518ebb580f532cba0b272710896712712a00d4d6b9aef70d25f64ecac2075018e96ec1cefb4a76a448824a7997812e719ae38b746791a6af750b561b8ab5a4094f052eff415151f5ac8c96d06916f2af9bdee3b342ad41a8e9534f4fa0eabb7bc19b568e4dc7347c9752cd817205a8be61568ed1030dc67d5bcbb1ed5a8446dbe52f79864ff19ea980f1cd43dc903ed022525e94204386a69d907ac850c224d5f843cb8b78df048416bd5e529763df1433423d63a40d75ad9f620f2ade03cf1b83f235c8aaefeeb1a8231293439448da5d7d7a0fe81d9f3aea8540ed0c0ea4460aa718c7f6d1dc36fc1989662d224dac19edb724439025721f5924b7510ed4acd8af8bb24d6b2ef4198d70d62b4819b763f68a249f78bc0f6cba4b7ee67253cd11116d783e2c47d5dae84ff0a3a63b1394de16fd105dde2e1934285a9ad7efdabce367381c932aa0861bd1e6387f41090765387c86f7f299814836738e50b6f0efe940344877fee1038261c86a4cf866a95381fa1878b5e07306ee0fa8889b008276854b03b13066bd1349fecef201775af76b9b10439aea40227b48d7e2b07c609bb2038e116555d06df30e1f80ad70999e8112e66e723fd95920020c507baef629b6795139ac641369b5c650e56f5f1c6ab7e5bf2df76b99e57b473a3b122b3c071afe3eba72f872d3f21f1341efe184e0ec14aa9e1e4f89c152efcbee5c8509a1400721c486cc5dae24bdf2cf1dcd0ae941ae703307abce14836a77a531212d51de7c0322fac97faaced7672f6d3410180f43f90795b7dfb4ad94a51d9f7ac51c137557577e2cb8788c0ff3f518469c2ce3713f2d9b74cdf6fb7266efeec6deb50ed1ded60c622a1eb489dbe265251ba8ef6f95a68054be683b1d693a557388826628bb2b63807ac42db46c5693ffba7f4ab1bb87398e871a6975d3e5fe8e95b00eb2954adf5ff16ae6447387da0a8e1547286516fe831f19d357cbd9275d0c9d7dedf5f561d1e7fda7df6c56c249849bab22e0bd0ebbc3037ca979a8545d4c0a712f2560a4214bf5d67736203c23323dface6e143ab9716dbcfa54bc0b72a6d04bb8aa7e952d8fedf40c07bb1dfca6853e31682d87cd29219d954c0fbc2fd833de1a9535b9c5b29d8591d25c8e032d7eb2c401a1abfd1842b3c626650fc33e208f91a109c98c287ecdd2174b03a646cc840ae746a8a375f4af4cbedb181a79961fd2df14d8a4cd220203513dc728d1b13686ffe52d9b8e4af4a6f278122763268bde8196191952635177487daad648aff594ac7f8e7ac36f726e21fd03f4c28bbef089aa8a5316eaabe6e4f5bab3783695bf01642726fb51f61ee0b84aa1fbf3cb2f1d387c5790a344050c088b1f1cca98b54e49f598236f30d9a3f2c73bd25f93f0d8321309f4e4f4cafc21317c5120f8c15a71134821d887a19f2fffe435a283ce0aa1bd1b2cd49ed5b8c029fab49f2395ff52c3828be948d2ea0cce731a6f147884e774dfbe9a994856729ad121a1a6eddef8109d670335023d73be88dfd74044fc70b149fc4004803af2dd2f23aba16343517f7bb62dadaf7453ca0c6eb22b9e73b3b01f75401bf0d8dd580e85982b9543b751aa0eb680cad05442499e3feffb3ab128c69589f3811fbcc126e7ba51b23c086e5c7f2f4a29077c2dd61d36af0e82a5fc58c0aa0bccd339f81a5a007dcb7b5d3f2b3f21c280da9cd288c4f2d22f99232e1ef3e9d9686e0e0a54af92a6b8645b253bc1ec9af299f8e04d295edd55208fff861749720c93c1bb301700b3039b48a4afb5436b643d3fbb9736fb672b9afacfaddc95d5dd8a8a005260ceeadcaccb42715fa820e72bd9a391218974b40b6658ca9b2ddcc0fb2be9944ed7941536f9907a20d384c13d9a6b89f05a98a4d886c9af6b811a18815c5aa372f74b61b0ff68f0bfd51b3e4ea60ea41615598db486455e1d2e277c22535e33408a38e951b7e327f529b47499a0961d228b1fba6d8b2aeb8bc8a4defa2fc7e1badae127d770f583e5258086fc4092f7cf997f98c374fcbf2ac94d35fb203be5bba5d9205114f13a2bce0083a99378a6bdf514e250e20e8e975d3e0b11c3bc2830b5e11420891a065dbcd21e5764b8c7d42618f9b63f5a702a6f9406acdbf0ef491af26747cf8dc9c8df0d88f4467e2abadfbed249a2fcf471e13ae8e77e704d3c2051b9a69b95c27fdb9921b1c4782f5eef06afad5e5a9b7f8de390666d7bb79c128d7e6b3279791bc4397385860d19af03bc603d61280eb5bfb03b765be07ce03c8c0f085c5794fddd35e0ca618b4e7a9e12e4895ffa09828d4ae2979749baab4b36daabe8037d3fb7a1b6698307c6f3e35232095e2058f25116933ca6b07f936a8875bd0ec10e4f42fbf87f972f4dd246bb6e514eea32a5f272e1906494215f9bb56585f9846ff74c81d1cf2612db6ea4008441663a8d3e7bbc861cfb49a18304cb24902cdc92fb57563d1ff75e12a94b71765f9aca71088543bf67e250760a4d33d9914c6cb2d72fcfeaadd93753846241ed4dcb6cafd626eb8d552ade548b1045bef50fd0be6b4a10fbad7adc25e72064812eebe058d735545693360006e70cbfc8f589cff46e646d5c16abef309f03ac6f4d3af7893919ba17fd13ec5125dd65e7d665740b9505e1817f3681e7424ad2ff69e3f56a549585004761809a4d00a6454c07c780f96d4b97733fc5f5560f2f76a1111ad0b0ca10e750e9f401cacf420c797ece5bdb04ab4bedb6590d6d6ebdd306e8249efa15b185e399a795bbfb66f40909d4e5c41c735b7140be54c91252fcf1f1ae3b93e5ca534de561e05bd737b89abe64db958f548ec6867e0d547dc23a0309d0b44bf9f4dc81c04a6c73bd421798164d47b0c4c90073d62a76faeccc9c7153d14148f92a0710ad80195abd63994bbf2607f9b79a46646e056777b756e74c0847a295a512bf885a0a963d50c484800910f3b040b375dfbf0a1e1be49c3fc471e0f0544a11d4a4118b883fb9a06fe43ab07fba0b313eb1f5b70b16089d5c150be396ea1fb1b0747fa48bc31813401a32b2425ca37700ce580e7ded9a4cc7c0cd1803b1eaa05ef1aaf7c2d294dca8bd5daf5557f215839769905ee15735d71ab004ee020364700220b7fab48c225a036d36a4b48aa912fea3f8b766db6fdacd612b36d564d2e460aa83179a039ca6bf11aed122d391048c5237fe2f114128044e4eeae73d7b693b83a38df20c5c6cc917e4ed1a71c1033aae1cc51efde22a92315206be3a6299554d08e6a7fd0706aa8fa751887e282c2b30dcc55a3dcb4fdd40b11d300fc47668fbb0add382cbb7e209cd9bde3263de3030cc876e806b90180248f40dbc339920d284cd932e2898fae68c8b06f9a6980d39276332a71f6ae3011984244eb7521615093724a2ff4a2f12abcfd71dad505842df75486482d5fac7ea1acfb003faac64cd13919f05fb7de04eb815d53ab0d806ccfc9288236145fcc62a8f76d5917c472658b96692f0d72b4764ea74e07fca217de7afc03b9cf785d1658c42512f0ae863b4fee486a61fecc64dfb326940455bb4d44be924f48ff0e2f77f2f00177ceca58a549e12e507bfbe85c696d04ca01e4e798ab8d07dda8234f308f21f487dc651adb65693e5dcdc19cd57750a4abba0ffb4a294bd035a45bc5bf61644f8ddeab1c64c0b2cc5d750f5b3029be20d7c3dbe5a54f4afec1248d75ec818f459872d1c264f04c6f18ecbe810bb507d8a71b4cb908d564cc25fcf283d07c7fb4227cb62f5ba93331b76421c3c673fe5c041c08006ed86503a42483eeb9273e24f999755b833595e02d220f99b4f99ca2e6c2518a877229cd0d513c00fa8619b1123450fda28844c1d4bab694e2affeda5c89ed15efcdffd770d1a1ba0a40fd739272e4fdc7241061e2041c7c42eca874c59313c6ac632d3a9af22929a9a55b8ad98415e8f0c321a0cc1c86e0020cc1bc11f52f497b1f0106df00640e90e2cf71cbd6d792334550bf0e4ac6757306a6f58706b92263087a1b367937b3b065fe0a44a25c3811a5142b86c7ba7ebc8570f87fe969cac6417b94d8c89c2b0b5579c230d3062d946b1508e8f1ce6037d3f246f5570c420fd7ae848fb55dc874d8ed2a1c458bcd91cdf0732b91b6687ccb4939628d43901d638168639121819d673d0387a690794cfc8943ff1216ab846be0964fa0b3ca433bd2e57a64e79b65a6fc452aa7e0ecb17452f15b72f481292f9de449e8ebeb2b86750b7c7e320423b771330270c8e13e72fa110e3a522d0f6712c98ea79e7a50cdfd0680a0f6b488b7ff324cdb4ad468b7b6d553d3d29091e20d974687e2143383afa224a5479b58279fd3b9ae60ba4f16f0d3b94a4c8efe67ae8b406225111bc03651d0a521207114f708f2ae1f874106b87243b5f637d4ab8973f27d0cc9188340f72806a5a70827036fda05b7b5d26cf9619df9edf7479ee24c30bf897a4f4a489f00a5faf2ccaa45f3c2d2c17d9bbda1696d70fe719ac08cfd78b2e4b83afcce3be92e910b84c66800ce54d0081463f1a49c7fa13d347741a12a9b3cf8d597038eca53edfafad573da812ceb99f2814726300d20f7a07fc239cc4aa4649173d95b860a1806a4e2b96db851009fd13fc2d0ee97bdfc7e80b2efe6f61e259bec5bda04765287448240ffd3f6271a3f75e46afe1ab624c7ac81390bc5d610dcc2308c08e1fa36eb2ad0e127af430e6eb65fade6ba325edbe60314864f592465ebb33c9a1772563cd0473471c103c6f3765ce66f2e8bb62ffa78afaae279c98de464e7f763949bd4edd2b2e11cd4704c8db38ca85e5c009de62339d7fda7cfe66c7fce4b481a2c9b464aca6cf1383c2d15c5dc60714e2e6c8600f8bdbc5dfbd6aa9053a59c0c85119ea692cfeb93cff2c85a27c0a69d59cf2fb4ebc13c17bad8aff90968e19e7656f6b31bcd8f2d7cf8e3587b71bb985073faa22978389374b89e40798cf084b0c13138175eabf4a777e0a4baabbc7c3166b0202cc0c8c6d6b0f1c1985c8bc678cba66b96889c8362290477d1993d4323a13c965989d2c0166d194015323a7455130e5e80aa70720944fba9107987a14a71706ad63416e80d123faaa02520cdf961a115b6a2b046cec71f1bee59b5124a64ce59de415cb97867950499919252b2ea00ab71bdbbc1960e118bad4fa9f0cc484021d86bf0449817b1636de42ea30895024c1f5d83c0eeb1283149bde8aaba6bef8432984de773b571804446f01f764e3b82b26f535c9b05f547e266da54ee616007b885b1c8f0edafce35c3af91e060e01d98dd59961410752c836f7db8e9732944817a1efebe2edb3e7647eaa3899b1582354c4222a1db333bf35101104d827617f5efb9528a6eb1174f1baa1e06edd4a45af989c867da33efced0d6a7a92337b5c77a8f536c3ac1d0134fff8f585095482f3a9ebfdb7b2f1a3cea3474dd10d5130461a7877356c76003002704d992cfc928f2eec9903d8c29dd85c7e6283495e608e2925b7f4e2d5ddfec243860bcdab93dbbf25824b0c0fc6e545c8bfd563debc5de9ff0a5514530b43b5af20c260f9de4ee578fbdee46f216f080248571c7d3671091c15fd134461aba8df82e494fb411c0c2e8193d550a5ca0a7d5cc03a68b7672fb86a5fa4656919e420e637a6ab48bf7c65f45af960d328d94255f34616c47e598138989385d65e8bfad60e2e0f4502847968cdfeb7db8ac4067ee7304c68d92ab192899afbd1de11eefe7da1751c32d23cd5086eef13aab65ee166b5403d50924211aa090a661e932bfaa66c4e63582a429fc778ffba9ce2ee8bc172b2aa06bf8c336c141eedb28c81763ee3f34f0dd2893a95578843dea3425a51d78e53ccbdb2574e640a063a4d1e5f9339dc7dc10e6f386e09cf8e513a0101bf01355706407ccbad2c9adc8169c22d99dec167d6a06ef6699b58ffdac71e9e9ee14ac48a976d9c00929fedfef3586ab1bb07126a40eacfca264baa8386cf090e5f864677c996d823e172889e44bdef2b128603ed6bc7aac738d1332e0c20585b5626ccf1c9f0050223dcb0f0ae8a961903bcf75028d5c0532ffa0c0f2f8902af1fa4f05d3f4995d04d4b9d8d20a3a20693af56783a6130fd65b36d6759432c9b7e43cecada455c7e828b6216661d390fe54cce06f47ae5622772f823d288547bee64a2a7500bb43ef3144a75d2fc4dd3057e686c34f07b452dcfbf80b980c324bb2741ff55cd3ed23238a903803ee636873e93ba88def1009074a9ce3e6eaef07a6f5167f4e0ea6623ad01e3037e5745a6864b1ae5c5f1a28e91295e09528d33ed050ad98c385bcf582ee911fac0a643a65fb1cf2c896fbfae210100c6cb3b8ef95e5235ebaf7076e08966a4f0e91b159022040a9f8a5f3664a304d233278f4b94c19997f580cd1130dd9c1ea5fc4d365b65b945725159642a4b3ef37a8a50970a52c63bf2d1f227ab30c562442cec4c4f80bd34f8f50e2176c975fc8268ff2a3396a78e609b05638454c83c24211244b956883cb9dc0b7972b2efcc4674ac163e670a680571c5a96fbab24a6aeffe55526716afd0839aabc98f023f05eca585d8da56f1f19abe27fa1b30890d562ab21588e10223d2eb12f24b2beb0e31afa1a6abd8ae610380bc2906a31760bdfea9d152713a894d7d22bcf479538a1f005ddd28b95c89434818ba6bd1e3af8b10106f886ebd2328b8237ae872c32845c4886ca9ed8d98d7597bfb89ee0eeb4a650fb4ce5b2c4457ad5c7db5dfc3215aff6f624b967372587e742821cbd3bdc9e5df03cf75489d859f2228c3d4a7fb9e71bda096947658f44dd5de23ce25ec7006ff2a3cbe722fa70583f9a441b310b846dcaf3bd7844361a6dd369305f4fcc1ef75da117f2967cfd762fd4c24a5119a8286cbb9d3efac6383c26415b21345b7f8e8629b336c90a00f7c9cc19490f8255cdc5a29d96692eae45d765985c673764a542120c51351214247b00be8490579ceed90a3adc9a2101cf956f0ce40e022c96e5bdbeaf798762865fbe605a19428ae63b87ac0a5b2d7c490e3c159b18feaf2af9de09a9b9dc0a1479b3f13d43cb1422ea8b205295fe6cbaa2fbdfabf8fb12938433de487a402b02b63a22009fbc11a8846bca7c4d7150a7aeef4a4e4d1fde303cfdeefbac38f9186e4a18fefc0f188eddef2f1376e183959b75922528dc0418815609373135c889c943cb8555213e53d8d33884c0f8277eb0aa850b37d9a0cf70d9f55dbddb13b7b0c8f80a0abf3dcc305c33cbf061f3bde966aa4bc15af11e8c4cccea8d391875db38c9d1ed04c370eeee269bc6122acda161f7c7a9f23976500a1757df990801a2463b4c17c5da48814cc7cb17e62e1a5c7ec8c98fd046933289dc5c833597cf87d1ec3564cb4e2598bf8a2829f85a2d8efbdc231400d4d45a885caefb150555fc36fae36f925c9ec762280bb5e22c8286f7c5c54fa335f6d414e0f202937f0c4e331acb137fd1cd81ea9d2e02717faf66d9dec50fadf7d34f944bc09b0c7ae44fe788869840686d180d731db4bd82bf868e7ac158c564a3a230ed881bb1d9facbe632c1d7fa525e8f6765bf21dfa54284ed5fd61e608f859095c19b1f0bbddb0e7d308d1aab5230f2214a5fa1c73a8a197efe861a84006ae274ea41c2382088a12b26be8fb6395ddae693b499a6e3632d3aa38c33cdcf0278fbbb8b623b919466084ffc010e101a5b36e7cac9fd827133ca4cdef27ed7a4a4bce71be723efa0850ba35b5d3c717b294fc55f38b4dd50cca332da2985294b46f8fa4c302f563586a32101c02095ea6a70f2fa4880e45268a9ebdbf719f48f3ee24b9f807cc690ac61bacbbd59f77dc63d3b4a9ff39bd94810644a2dc3fedac7f487240f9d7fac5d51cef758e83fbe7f7ecc8165e7cffe8d64e3dc83a764022e1a7cf3b9c6d30f3ba84e8fd81a7bcf537f82573f4371d8db9a45beb3ba0732214dba8a45bd1cffc67047a61a7d3d771b1ed36eff44886091cf241474944297b67db9c9a277c9d186b29f0bf7e6bee1cd70b5cd0aa4b22dddbad8ca4ac9125609b37740e7ab97728b629760d939e617cd53632c178267b9a4025a54e1853b956ed8ccd00cb31c6f4c5c5fe260344575c023af34e022b6c16a42212606ba65faad86861658e16d3c70a89edf5bb75d2cdd182472a120e04afda921b3cbed941d51e0b5b264b71c0134c81b895f248131170f04f7c414fdb780b1faf960bb22c48d0b92a6872019cccf78369aaa8920d5daefe2fb5f7577ac346c776e48a005041b39e8152bb7e2013c9f1b1545026296ebeea346845ddd6ceccdeb48fb83243e4e29e5295891931dbc74a41348c46e75f337919534b4a1fbaf62c221adb921e248c2f3da8658c4e0f81b7c0edf41aeb8e91f23c9a4c56e43c0eb853367a916a63e131d0e14ffbfc7be7cb25cea23f9425d3e37cc802c9b64822f90999659977d56952cf484551da64994aebfa0f4530426d7a880e31ab99633ac7477bd3affe7fe5e759052fe8202f513e740e841deafdeb9e54aa41ddb0a944eb3478dff28445d81a4905e4fd3b767bb2f439aefcf1977471ded0fea419ae6dbff9f01c3bda9cae029c19a2a12fd5b3edc66f3f33c28318f01f73e8dd663b19831eebb514cdd4b6e24f4d0116657f51a660d3170f0d8898107ccb687f3c188d3366740eeaf8c4d98fca03fb8f82c80539f3c76becc6c2d96936059f61718137e94aee7068918c7102621edab6351bf186956b0eb4d178fb55623071409a4d0c77e71ecdb163a04440d6a4ad44d2c795b5403358de7b90315dc94797a783452f65b117440a17b9d3b3b4537500df817fe30209de2949c9463736b9172ad1252e3d36aa2af614d8605e95b1fc1108a44d4d0ea3aa4e6f06a35002e334b3b62c17fbb08836d9f6c6b168247bba090d009622404998160e562533b0c050a55e145d6217256d053e8aeb002b62f03e501b6c6375c256581b00fee229ec81618de3d375b4bfe7cb7eb2750568dad80ddc903e2d6b1e6cfb7b58ac1e4c60ea09940fb867b71cbd7ca4dd426e09eaa44a05a3f7ca2ba60e9d5479ba6a7cef776eedfacc9766f3a92241df0cd2506c7d4cd180730aece8ecd19c2c4953f679ac5fd28b1a8b9ac70df99f70ae85ed5f0cfc663b295bedca696e887ecd29dc8501d35dfd6018f11f9b201831d65c5778e2efe7fb54769e16f58953fb80f20fc0a11d8aac0ad237baf6b4646126f2404589e984cf76b4d2f615a2150560f909d593b5e6b087930dce54cc0769383d90af38c8bc22f815e41fee60b66e40dac29750f4dc0125e2480dd25f5fb7af181e321983491ee39109bd2f6973921efefd03e54b626421938c1f1b01d922f835ae6f2ffbfc6c13350bf96f2e3a9656163eecb648f429cb07f9b8ce7048a2dc41a59858953fc8470b5d021b42ea837800872bf73cb23408f4d91828d1bfcdd13d8b867fe4465ba7a463c07839650f88856a12d858dbafe334c10a6e6f290abe8a2d122328c3d9850889031963226b2a14967f19a012eec2606200c8973436690b307353a8eeaa8b4b80c8592a72c89a31fbdecc4c20c8a8b3f41b6d153c927a7b678d9770342e0677a001a69f6cc47eb54c7d4f0752a22185638554c1af03a76857ce99e270d0d86c8721690fcf98b47c1ce4d82b23df000a5d790df0691a710704071232b207b892671b5c064e51bb6b280770606540abe79d6b338f0d4968d1fe082f556e892a832ef89ee22065ea523bc00e2d826b6c3f554ad006a31cec45a5280fea44848f36e77af4fb2fa936576b4ecf5ad8a2a04ac8d405ef18fc3dc8f3e52912e8509205f583cbbe982efb959f84253d6ddd68729d28460fd39d766edd0c1a5c84f8d0274557c6f76cec2d362fa031ae4830faf483af1242f10b1f5fbb24b42f166a03492aaef97cfdd34ebd91bef8b3c9b483b226755c8b3910ae7008adf2fb3017d7997d6c3ec96943cbcc83fa26475a527271ae763bb0248c2a84aa5f0c9e61542b2c1b508f29457f57ab8b1b88e80fd1e975d1f50b415f01eef12b7ace9c677a87c627ecc0472fc3b1de720a6c90cb456b2d4fb6b5ab290cbe6af31f4a6bf9ee298bc0862f910b75bba58842a3fbf820c0e7565fe3e480c5ce2bc73644c4a25848872bea6d6cf31b2c5ef8acfb3236271a46cf06ca219edf45d85fb970003009bfcac36dc67524ada992947d0f813dc0b61678c6a6ab1f8df87348770ea528568883752e4682103eddf208230092cb05eecdd2a716644dad0ed361bbe28f44731805f079cc7d30ee6e2a5d2d053ff970c903492985afcedaa046da41c78fe25bb55cf21657bd01e320b0dba1e286f3123c0c4e86577b616d559ae45d43d34f1239859377bebebd33494134042473708c836181461e59efd0b4ef56b1d58319428618e0f97b0bb2b9bb2fd1398bfac183969d2fc9776b037425ced95be182f4691ff82969318120444533d4d7d97febd69f350daaa560962b7253862db98663ed4c5e2c001d3d9329c356d34d90bf3f4a3c23580d0ed4db72614f6325cd2100817babb629d90e38e042704410e65fd26005b8d48855eb6ac10913ae38caa9760f3f5a70f2676262ce1cc35f09ae70e6b5d3f99c9889b296272423c6a1278d23f08eb08a2f013854cf56044c567e9bcf0d363e894e231846199fef9f1efa84134a666c017411291304bd6896dbe6eb0c4c5f70d981cefa14472669ca884514ddaaee6ecbe49046fdd460a6356fafd782f79433fe0179e449998398dea4b5105fe5609871a819d49c6a1897558c906bf2ce1b6afdf2504c63c1202da2852dbfde6ef055130c637b4201c12b53790a3f56e8074df77b7414689e2abefaccb38e4de837758a7818cae59cc0a6becef42edc73c234104224fd6b2974d67ab7221aed6ff97752b4a206f422026f5a20d994bb5119a91b0ff7ef9d5397cd7bc6dd714236bfdbef4dbda045f184e4c7e92b4d972e31df2a02df1c9dde28bd13caba7dd45932098bf2e9eb93515cc4f181a969f0220a635c0b4aeac02994c1c5dea07ec2f83aa8b7323066024ca76786fe5afe451a7e4d00042f565fdcb6b1638a74823fe1a6fac96eef01917ce8afb1b44482784f49221278fca887ed6cfac4c3cb507f2c0d47a3645ef0959f92acf013421f6a8ab28a16abe72490def4b812e5f3d083ed7d2a388c3a712ded52c12f7a3d0920021783d30ce01dad1ffb67ce6d5e1937f5bb5e55a33a1f83612ec1485e865833e8ad71083eab1a2f8d03b7044477d16e8d828d3ce2d716a6b7d42d904150f5ed1f78b91b41d29d692fac81660687bd1f26e880e423c9961389ea59a2a46d07d83b555d892bc9c4d7069da4df1066f76dff84a8f6b06545276428c83646b2703c9ae3c63d15f22d82a681714607c6ed93d5ae7adfcd6c75a449fd4602c64608748a269e71d8e59050c5d55d8ba8227dbb070c8beb968a51cabdb550188356012e37d4e295890b79fca9d8dc33323a82ae54a9bcbcb6246389892bf523176ea2c34de40941b0ff1299c08bef3aaabcae56c66c478a838ee605a8b601fa290498385904c159e6a8ff9fe3074b224b715553817ffb0e147d8d7550a7a49f932f26c08fe9907a14196773be38598aa0ab99669ba506c64205f25dbacdd296f7a23b3784d2831d6c2fe9d160ac265d7c0e44ffd28a82c26be9c0f0d16dea96b83fe47c6eae5e40378b51b148b9eef06e919cae79ef304cba62cc2d5adc2d123a3f1835ddb65c7fc34caad7afa443766de44c096ab3c9ea955c4df2f35daa8e0fc3855ea6649a8489d047777e9458d6c68c77ea9b315759b7cf5d00ccce4a67181220f1267eeba602bfeff45ba747d5cc3feca5c6fc7c2cbb55b57b698a5274216ba2dfd71bff62ead940bd2624f6fb0e98eb535343618feaac1ef741d2cb6c3083a5731a360fc18dacbb3473a8f21bc34b0c08e935dbbeb75ccb05441be426bedc2200bc8e8afed39d3912c223bc79175dbb4630f1771805b8631c8b8ad4c774dab5fc129ef3cd4689a7a2e7c30a52726782b8c9bc1093aa20bf81d19eb625ddf5657e0832d028fa57f8df8280d6357bbfbad82ed9a99fca99d6a46cbdc17297bda0092afc76ec488a885ad389e8eb146edc5a0d5dd1e5abd588d44411e8c73728120f6a798c2cc817e09bc4477659dad450b98a6d5960aa2eb59118ca31881b9364cc6f18a0106d57d8e336a6c96a9515bb611150b749d12bd1f70a0b9d9f5c2be88f8f90f8e9cd9ebfb2df1c3efdc4471ea8738551aa159643b8c28365d3d957f4a20a3c5ab916a95b86d64bf2ce7a42fb24cf4c9260f51163b0bd02695ec1d6e31c11881d496cbc3872eaca27cabdfa68a79455f55e224375b227b675340c1e5223d2a2a0286eccccb4edab9f7a9108cf9ce908ffb9f99ed412a04b4706e5a92e1e5327bed849ce4eb776efc382bdfef751a6fd72bc60d8399bcf16d9aa33e27c7b60e137f8cb607b2be518bb0168d81edd30c6bf72c50aa1e895fe67b66cc1cc8fd0368d5ae84937ed512546f3c9927b19c308e3bf61a1c788231cfeca7ef93c944c5863135a3c13c8c5ac121f81b5495e1d0e8bfae1be5c0ccc974a780d98d234458ed1c446114aa0aa0cde29f2e60fffc3062247c1178d4ee0d1d65ccaacca01f8702a5f9fb33e8b7cc258701686c0b7f7256da822d6b631281166c7d585b1338f2e2c571695e490193b69e8b96a2f6e485bd62678962251e2bd57a8ca3e925476c9850175804bec17efafaafd4b2a16df0b40a9311ed43e3b08579f9d81b76414d4faad2ffea291d02f115be0484e6598fb26737079f816a2341a0d9313004119549826adec3b0b31c9ab4eff27acacaef2ca4cdb1e3025b49f4ab0d7ad0300b60a6ac45445d43cf6c3c401556743829cfa75a5827b1b93f77ff08963751292d47a3c373d63337d65aaf84a02fb55be13ae7999fe0aeb85448eaaf75213539670d8effc833eedefe6a4a182e7964b44f99a2666b88da28f03d5b57c66c7f379b4d1e6c20fc8c979b6d1a58d82e14e70192c822d321734ac10428fc2a4db0d8aac7404dd5dd18103405bda76ced762748492e5cdcd13e9fe1aca032e15a237d5bdb9b73e016e5ba2a5b7ffdca1fbe671bcbd1069484bec470ea88515631674d5621a86a31423cedd12d3779aac7fc26c2fc258aea38a374882fd2f38b7090171284b008042849dba11963409802587a815806cec5e5f1bf2c5afdeec4fa136482579705d584e7b1e1b1dfb12fb90dc034035e9b1af3d5195f8fbf9854ffb02442cabdd1cb7ce215076a62c76d1e03d8299081500b024e52a31a9585ed941864070f901b92520011e2c0a6ebf847203a985cec92cb06e3f561ad36e0f7a8485dbf4cd4cf78701fd23d7c86fcacc7a51c53872691156051fb002ba041b9daedda99a1e61381aa8b9aa11e1711ada525df7d65daea5a05c47bb8ecdfb06b9e971075309a47bea08e7424823c74fc7aa57e74bc6cfbf6c8318fb25fb8bab923b989998af6a0a70676ee000a6b733d5e6a3dec5c92d7ea41082dff48815476c0a412526c804fdd87c7694152df1706cca2f97a50c1c6492be4fe386ed117d4b40bee25105f66487f7486ddfb7651364a14db0f83bb3f9ccc20c6c7597dfd81e84e394df2f6bf17ff91a9f332edf52c6ef9eb5ba31dfd6fea3fb2a584160fcb0439c9e9057af74ad2cb5d47744234a00bf02a1c144172813fb61d8ba947808bcfab5e66c9ccada18bda0e51ce7c774e14e2e6beb6ecb772381f94c149b054250e701e65ae1b89c1028cd31fe2a6c73385e5017c94e5cde3809c18772f6bb32edb9d3a742800417232ec14d58c10d3987ff1a1b73a57b1d07e446107dc52969fa69d4d8b9789b8261746c86049f10e7d67941cfd634ecab5376cf4842ecd6c1b545212af590dc34b47f2702bee211d792b15da3b14cb2b6a98280d4f1c07eb5d601d8a6921917496fe94fd9ad8a6f3fd35f033f791485f8a7d46ad64347f38f8c6a37ef5395441accc1ed602d1990db0e718f68cccb99921de3085834e3ee0e1528ae34be9c90981a8c5ec3c4ddcfb1a30523d69d51b64265bac07950482f6cfdb7f3a526be0b124ac30a1b60d1ebfeea83d3e02545776675812ff8612872360b9b30f9d2fb84db579a628363225f90d154e6db485ff25a9ad80af7bbe5a677fab72cdb170f0a83854882f1a40836a74e2fd3081c73d3a463491a882395ca976e7644be17cb359b88a582affcdebcc8315077bc4d9a7f12522c2d27235957b2148268394386ac8975558f99e8d83c4aac376181510ea671835451704cf5ffee934f6e31825efa91c4809e011d27fa6c8abc81d2d887af7bcac21fbe6111da3120811afe4bc2792952004991014490ee57c45fd39bf625fd978f3f838e90775b1f3959196d11c87775d5178cd4409ed45bf5d15a4a5846cafbe4788c6f931921caa10c6303a3b3bfbfa381533c6528ea18114c727c08e2a170f29f39a57369f80f44042bc2e958a711393cc4190b44b61c77cfc32def2ba2a63a7c247a7b37b8ad4bd42e3a6bd1bab68aff8687745fa8120d7e75779d3d918a98d6c1926f233444ab5f37ed6e0ee92dbfdb595092ef380e27fb05a5095937ea44c2d2736df7e6d8626aa4efa07e736cb6d22c0295a127ae914a15f9e1237d4e393a02f5ab1459deeec824a3cfe62882afb8c0b07fe4e47f3b3539c8701cdaf39c6c8ea5f57cce686f6e9be1be904e53d236b37f43be7e6799cbc6c72eb464b8f631432f8ace489f1d515c2551f8d520a227f6471ebbe7df4ec7af62bfa5061ca91adeec20a0e180ad5e967b82d60100c31681f0aa9d14b4ae43e68836637a604ac23338b5ddc31448a981830530d8cbb5f089174d115e75b7e8f5616b7ad5e842659a00af27a1847e1895a9bb402c5384456f044c484557ab8e9e5f18071ac593f26a566f8790ae6297a5f5530b142af96cf7de54aeefb68a072a5408e61e721cec571aa77b6f773d2424853832bbbd1c7b75f87301ed24e9b7ef4aced93987851b0cd4f713ec1e75f4be72eaa0e077a59f5259e10b7cfde69f5ae005d2a6173bcd5d87c7ee89d096d698c33f5a83a8dee24778db83a9271e2cb4c854d1fa484065325b1a0f19a10620d7a8c9d8e7bf217ec411fdc16939133252972de6c7e21da18efb20fb870e2ce8b30a923b960e2ee92f58575ea67f73070edb7e847ffdbb5f7ee3fb38706ee426e6d85e2b89e9773f647ef3a1e09b5456c8d889d116cf4ce292fdf4517a26a59ab862bcc0bae9410dd0a7f191f02cb7180eda55efc1f5811bd585e29072e2de18ca58a6349494b57d2bf32d0f723cfcbdeb35410dd5fe9370acc78ffda0f2b98a8f4c3802f47d17","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
