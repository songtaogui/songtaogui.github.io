<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab7da22e9e63c2dfe8a9a470aea0af634f60ea3fadc8bdd9b126cf45aca2410623ed7ffe5c8deb115196ccd098560c5288b5b6c38e3f901f40dd54a866fa00d9b1facc2cac45099b2b975522dfe92b18ed9c43e8dd4462cee21ebfca57a5a90343866fb560f9c0c8f429b42b509edcff5213b41ec8a859e6b48a196b79b80248f72372197d21778f0d68db3b5bc918990f82cc09a5810155c6177474887eda1bc483ae3ce19aa5b79a1ba409a93de770c5e86274e4ed1268c7e598e29aa237b0f40ef8ecc8d417811e54c3df70d8ea50d48611d7032573bd97d9fd02a60f3c8ef07a8533d8c3f7427469adfa1a7eb7dc3628e04831044eae2cb18fd1271326b5ec2e0338552101d04c3a7f7f9c5df2e8047dfeac32fe39bf71092e6c7260a1f32b2efe1d6ff832aba455fac3548b37e698a90b43c7e182e8d24c24d2dc07b672866f0d5127bffdb9bd406c507b2566cc09dca1209d3f9a86d751d6626a6255a2fe1940747537a6c92f8558fb21bb4dab9fcaa3ded11c214aeac417ff0b8da0083a929bdd9bbfbe7b9e7c6042be1e5260f21bfb8485fe929cc71f8788fdf97625797e09bea069d41d254324b171e3c540fa8493c3106e32ee184ebb2ed8153b7c2d8c2b8e449b584b315e49f2ca6c965606fddd99bb09aae3394a229066d7d7d8b398660e999bb34d131d196b77a17b038cf9144671e33747bc5833ff6e8362434915a157fbfb6b1229f0d1daaa6cd51288e7051c534c9f7809be94e663f3502f8e0f534e9137178795f8d189c42c4af42ca559ed47046da61e17a78f001ced2c783e1c048ce62008fedba844343b3e3de0f4909d345911901823f82fbe170a181745b5682192bbdc1b2e3dad0284c5f0482abd5d004a0d536f8ddefeb7cae4bfd9f706adf8795ae8f08bedcdd25bf866e3a5efdc21946144efe31f379d2d3be68e085827099a604151a4dd7544c49f227473210bcc27a2b953c4c67aaa13d132bbb7dffbf9ebe4d81fa54ad38d2741e23013ea145e835f18fa28bdc2a6830be7fd8fd1f2937ba1984bc172c9b0d4e2ce4004736852d3458fbae2701700f111349427d6a6af055b400c2bbd270801f3bda5874b850d340dc20664484459cbecf112be04af674977a0a83b8803a5f621ac7a17a9caffb51cf67d9f0a06cdebdb82de027f04e526face33feb69c1bfe60fb5a67b0de032c99c47c7b2c5b2e65aab4b3b347669b31303d9ddd3e6f3571d64ebc476b794306d1f8f2486a53b62813887c2fa03eea4eae8b54a5dcf17425b87fd633a8ce1f208cec91f933a4c4205a9f7804a733d8d846954050fea572c924a75d461ffb2afc65bbc1be50e99e568fc7f6fb55c35f421a82ae6ecf30d75cf1aacafa54236e935a60be6ac0046f1cd711b3b859cc588e5cc046ddfb234b3d00eb33f4bff124afba52426fe20fb4b41bab2b425d181ae0dd1d5fe18bca137a21030da8bb3df09ac707133b5c0ca0988a9f84b377548d32ed2ea1e8953a5b059cd9072b35c0f500f7ded5decaceff6fc0e4de49e253a57d6d26992f80f6f785291395a91c728e18656e6a642c1e40a48ecf8cb9ae9945e55190e88561cf966031c73d7836f782ff438f69ce27885d731fa4ae4494324759c7e8c37cb4aa5c476c1520c9e28912792db3b0398541c62a65aa7826fc3be886a70261639ce64ea73f2fdd8033b4f95d15953a8db353419c8ee56a7911611167df2641934bd0681175fbe2dccc6fe49aa18875e95bb60ddf99b9209508ba537ac2fee1162935f0582c0df39fe6fc7b3a364957960598471aab2d25f77e0aff3106c7ceecfbba76bfeb79c90d35d6e31c4a47c39db1fc110b05099e400d859ad435b9b28b136fc53dce33351e98c6011d8421e235e160a62c6e9d4f8d4000bcd6eb408d47468bd7c065b884e6dc654cfd5e864dc473042676689e14643325ae88744ee2507de34db039d39de426da07fc3801e82aa191c80939a51586d89abf1108009030ae3ae50b3e1f664783f9e4bce0ce6761b814bb23dce1273e8729ed58703aaa1e646067eb436154c413e44db626195bc166f99bc2c30ebf26bef296de3b80767242ae0b218e2d503e1c7f27ddda2dabaa50b791d581c4cde81d655710bf9adaa25072528652968faa6b141f9ea096602ff7d138ea21c6f27ea75e5c0ff1504aecddd21a1840e6c582b6b84ab9d20fa129ca0bb8badff5968f34e9af25d91ac01fddf76307a2e385ff8222a64d28b826285b5bfef5d526bc6b6f4d5a9cefdc51b5e187c6e069a7e5ca6ee5264d93fd49cf6315a2c53159aba1ffbbb05e0c1f6bdcb75d5943497a677745ed524110006e877a025fff3078f6e189dd3e6e70904e27038f67c38b4c0ed82a5754cac1e4c78e46ba520aa4163eb25218f432b7cd5d0d3de5e68bbba45db6802e3e0823c980f975bd6bdc954a8a49592f77eb6810fd45d7d5117b6f8f40dcb8a8bd3b8bdd8eafcf44c36e0ecee274bfa4c7f3ba8bcff92859d13ed1328e0d593eaeda017f6ad2a2c019bbe23064ad9f0c115e4934af5bb2db0128dc30cfa7297e1704f0ad212322db975f736a16ec403642c36edf6af931feb482f3ab3d2a4647869e9d59f473d6df82828cbc088e3b6d1487e508cafa070f3b92a289d5c09e23b75765a886ffe62c75c8aea216aa29a4dfc7a7a22f50ab624abc544e6c132007a1bfedb29c6bd9a5d5ebeaf0ca7f49380533ca326df05bee566dd312e684ab986725bcc604998535cf3a166e9cbd2837d165ca6cf4eb4915c48795c4aa665450b98feec21c8024b212740f2c0fba8eb581a62dc6a9402427e9302d5d83e44795a0e8bb59946fc7721302f0b17fd2fd8acad489f1c30d0b1bd99a2d7e3be299b0ce673a62857549273f4cd3f5ffdce8ac84f34fd6f47ce7a8c1bbe247ccb9dccbd4e297091d28c1633674ec5b5079d08e67c801c6260892f06e8bb9884c444af018d05e8d9978443a9674181c3c352d8a5f8ec5ce87c2a5be10db14bae5f81b63cf2409780722f3d56d0961e7e48f22f0a0c5847b519350a29e4644e666845409bc1ce34af2043e0f9d83b5fbef58d0e6a625c28612fd82355bf7dcf133aa80c36126d83edf95774ad02c11bab23999ce31511b6189d29f8dd495e1fe06647425031f002cb86c49f36e375425ed26705d9e80c67be13bf31b75a538c1dd3427b39981487e7f4d22406e09b2852f61de4bd03cd9709386f7bb8b0a349b7adcf9d6cb1fbb8f18d5b0c54c7c3098d13ae87f08d8810a4324e7b289913192199bd4cf1a734b08f284c8225b53edfba57a86d45e42d40236778e5d193ab29daec7ea728d098b1e3b3c593db2b4cfa801fa7eccd4a84661963c1c9373d5e40cc7d4bb30f2222926b4511328414fd175b0b235af5617f88865f916d2048047eb28f084f2de75f423c753a83b8d7215931579faf9bed199b93886d378a5b8e283b8638517f70dc18109069e342e82fdfacde8d2fe1a00fdf7dbec4eedffa5d726d8781c939631d3227d5d2a3625b83e66657b954279c9e80a936e65c8f1f8b8b3eae5af612a9f6432cf02d1b00028f112d8055fdfebcc67446e4597998aa58f48a207aee4333a3bf401e6b4009e679d0aa5d2347e38cc580a4256f35afcc011dd2c3ddebe0b3b9d2bc9c0b394228d36960368db0a347d02a78a7c8822cb95d800e78b2b802af39ed58ec81998f597a4a4c711d6df39d8ecc2332b7d0c439ab75d0eaacc96a189d7129235b540b5b694b4051cea36506b763bdf76be2e69ac492b974123e884ede0f37e036e52772100ec331380b22162267a1b50e4b7be495a39b2fcc0563a01a6fe8439b27089072991c30f5ca0cc872a7abc16550b000954c55fd5aebf1d70db9139daaf1647df2317ef00ae14b8aee224370302f799e6f2a985e30a5ac531bd1b9a946f98e2d4218a112231db375b2512e49fbf5b23af1fd0e8bd28b37aac1cc88fbf82e966978e471113519f4ca15ab9033ed7b20332264c7353def36d36fca587e800e562646cadb8d74de664d12ec13696e9a60c646c58a75596d761c3aee75ce0378508341b2f380819e0c14a92a2c7fd953aadf378644c2f4feb2d5bcd1c1026908ef116e6c9e8a8b828976aa722605023879bd4ac4bcf79f37021c514d3b4c4ef89e0255c2e38b86eaeb657b6fa601d2ce5f7a6ebdcfd883a17825eb8db17d072f6e4f177029ffb2d5289aa6cf28fc23c3a4ca02cc6a9b77e79fd0d80c08c3b6685b9ecdc40f08a6a5b9bc86ed4c0407cd9ce4c5df173098b9f4d65f4f6ffe836cba69c0f51aba0631d61f539dd85a63c5c9abec993d195e2518f289480ada1b272eea0abc59a712aaebac4e252c7302aaabd505618e003ceffe4d67c6aadeaa34a50f85b0c58c99383a43f2024e4d29a52d410f123dcaf5bbb8de29eec267ae88e637a51a12e47898c3fb1371f89f4d317d0a977ce4bfc50a94d0d11c11c228958a32578e4d75db69a60e5582cce9a6e5d76cd202ff75c3013717a0b5e4e887981af4a0876107129ff6924509fe67d0c286499b764cca2b0b8e80b9609189b0d37400689f54734affd2d051d48dfa8c0700def6ece921e28febce1f73298960263bd3e4b01190ec323e74b8e6c30ebc5662535f33a352a50a48a5731f7901ee70c7653e1d21bfc531a68019443e416f506bfa9797b9a21f25490fe71ae56722944193dc75eac6a58edb57e7f550acce532a46164f25c5c428d6f653c9a5809e7b5c36a7fb2161db77759149bd7ef2fc02298ff889172533a650abad3ae085d30f49832695751ec6cc4540a23ef8cf1e26ed441beb281e25f69fc43ff3a0a4358354bcc1f1c8f7c2d73984193fa575826dd9c5f8eac3c75f8a83c392662d6a4a8665f79a9bfcf3c2f14f3379e60dbd87c9908acb8ec12ae4ed74d445e38db9e1d89d47ec0931778666c8347a5c5b752842693e071f1136057e0f2e0b87d0436c942a7adecec097e3d087d0fb51a0447c96a620f16caef1cb8301bb4191c2435cfd0be0834b5fc5d5b705363914c02bf2b1dfdaeccdcd546039b054d6bbb237ff2f9713122672ea8dbea58a80715a5a89f826ac654839faf60d7fac1231f902db2a5bd32c21595b6fbbc755b52216425bd7390bc32609b1eb116e901c2e0d5774156942f5f70e93e9a601bde3edbf0a59575c925890aff3941e588509335c8e063526a283b634c011a183995d0c3317e98fe2a0b1af8ed0f06fe936c3bec04460ddf498ef1516133fb8bed0c3afdd83f6f3b6f9f32278e94e1b1350ef0c050671e05abe44d596d4cdcb0427573aa5dfae54573c4a0e42effab06f54517ed2fda8cf6b60b180b50ad9bd16848d655627080562f46c2da89a1ee8613d6a7d5705a65b4365addcd2e6230b9eb20e0ccc401b0854a758ccdfe3671ccaef2d5cc5ed609bccbb5e5b881946776e512734d597bebda917b7a918b9ec8a8484475afeb8358632d9e6ddd4a328c7c6679d19971097a0336cb099c7b0a36990340108f27dbf3ea2c4e990b794dbf1c9553202dc3477afbdb04ac0764b40a66ad536e6f60c14a4ed76026bcd28524d66338a16c01f7e91ddcafe7e344d4b29f93d45518d543ec6d3419ad1d9c68ec4af14631cebf3ee266f3fb8192479e64db5e02c40ed3192829243a8a10e48c494e2a1e538c2701b624f8518666dd33029d97e1e4955b6940cbfe4159f3b6b4d6f1479c2a27debb56003058de6c2c68051ac2cdb62f4eae31f6eb4e303f4cbeeb511e8e1eda5cd9eae85419eddf9f26bec442aa9ce8709d4634a0cae719efc9755b3f2b1de968f03255ad3cc324740928267ba46c90c49fd1af02e507ea3ecd0911ae73532fda3def8777ed5a25ec771badcec28b7d2b9aebbcad9047d2c3693d153ebf16383b3293a9ae51940fa41ac02b961b9fd9e0495f02c281ad20fb57fbb14052da10e7c05d35f1f369dc6f0e12adb3c92492096c84583af4b622deedd7085800ca35f2ce9b94f3c492d94b88dd585b126f24bb1cae3e343cd9449c15757ffa11439f472e877be4ad9310420aacdf7c273281ef5446b44e76f58b3ccfb8785d00ddd243789932b9b69382d7b334246f4ae9bc9815715c1f9583b66138e6e7a59cabd2f82fc013527a8889d59c2527483c2c521a690d469e049cf4edd2dabc75a41ec65db522548015e2db26315705b7229e0819a51dea136b83a540b69e5fb0c4ee8a17038bc4d3a93269837ad388c39709d666eb63b0cc46ab6420672c5a7f955b328d6fe10993bfaad8691091476053b9f6caf4525bc2fa8df5a97a10d0cd2e646e006505ef0bb0b58c8bf01d54bdbe9c43791d3371f777e660388082d7af9852d15c1e2d30810179a3d94b3bc03fb52bbc66e3cfa5cbe384764a2b4810d652ffaafceff050f3ef1e73d183829c85613044f1c542370d5f8ff46973648da02335c4386dfa822fb6e8a3601e784904c08fcdb427983096a56378786e2f2855c3f88e1c36ff141ab11db72e91896e378edfa5a3b7d16bd928af17043a73f2a63ed6803b2e6d2535a898175d2c531fe3cd2a50f149414e830be57801ae511fd8e01649b29bed318bac445ef283f268411a53e8f4b2b7fa0708afde2aa4a8ad81297a68f92bef4174b9365e56ef4e5dfb3489af5f8e9caeede190eb893851c2dc66fa81342594fe1c8eaa602c74e5c7209c5883db70649c0811668b3b7d00116d9a70b26238b607ebe54cbde0b5ad025e2fdce80f1b490e812897916acac278f3137636a7cff1d56a9c7ebf95fee62c32202863c587e32053bfa580c98fb442fb6934ddb9539bcd164c885db535ac10493152228db52766d3c2f211cb72baf48eda1aa6aff0faec9fec7ce1aa3d313a33819ef2f35ffd521f4f30b4692ace91f9bb88e27948e971898fc4a9b135766972b5cb4e0eb779b36705911ce56862fb5b09666892d7a49e27cd2fa1bafee46117f32e4df226145992b81ca441c811ca9e5b760bc05b6fe3828af97c5bb3817c881023576c59b18058f62248a63314e0b0e3365b92de905e17d4274d7bcb260ef7d6723962c7de3c6a2d6a35e729c15c1e70bf7a978a02f4a6624379bd6c0663cded8945d279ebb5b067860698bcf1ee7a289eb9bd4dd56fbe0fd6418764e6663d07edc53622e111a83659885edb03a3ba67378e9b7c004d2220cfc86350fa2cd7dfae91d626431cc43382f4191cc2013d551c71412a84057a4bf2c4e68516eb6b651845ff306a83c0208a8f55d63c4bab7aa79f5736465d0ee36d2eb27070f0f081ddbe6d8d6e51bbfb1b0613c64eaf69d1edf2b16c92d0d6303c5fcd6141431ade19031ece05c78b5362c03cd875804c256dda6c706a3cbf1b5e4f57e5198bfa5d2a5df4624ec7f5b49b9eb72fcd429b2c27bc8c476f62602c7ed782e2a332d952fc594a5bcf90874b7f736eaabbdac38bbe2b557ee9d66b9d51cffd3b1cb9164f993fffd2a935680f50eaed6f4fa6a38452d6eb4604e78aa066d38e7e6ed174e71e23ededd63067f8ff36ca3c1acd3e8108c29deb70701aca1eae66c32015742a931f3522ba9d5414d5a70b361b3fda81c3103e94b1edc877be5d2ed955f1e9085c4e7456d8fd614aaef0a4db6786b9f64ae676b096d339b75b460716144d33a1720d7a810cda0015bd23b2ec9dd092c8b0fc7dd06847e3f7c119795fd25d72ed2615e058073357cfd49161990357ed9b76f56470cf6f3d9dd9e2cdb5e4a845f0639e078f51514d12c9e768c77fe56c9e2be598348f6ff5d847c33b3eec5c065186c6495dfcc5c56bf982e708a7621a970b5547a2369f03cebb9c86d51ef1e15c1e2daa5c581442377749a1ef46e9c9d3b411b7d77c8df91afe9f0aabe922728ebdf59a0ea804cbbf46b034def6561e032113a13e98f3fb90353319063503db205b3183024ecead7d1d78914222c284c3f768e8816938e077f80eeaafc605ca4df606d1d38131c4299a16a285f5b2559454ae13e186642fd8c7b69d6c4883d016c2018ca6f37cba99d40b028d09ac8a44392a2a7208b11fadfe243cc61a92dd5f5c7ece68937e5a596e87e6be9f093a09844d6082377d8c4b47e1d96be82e577433b78c03d719bb704802af4cb65541e5534d2b6fa3ac201de1cb5f274a03c7e30f1391d1d5adfa35a912383f47284ca26fa281d838de10e92394e879c0e5448b67a5156159d3d5ad4e2870cbd92007097d03afe04eb049c1d3074a2df1727c51f4960c277af01c7047623c8fedb7d9229a13e36da23f9bebe4e17c4a57b7e469d0066e3044fc5ca0e11ef3be38f48c4de9360c7428a90ea5b63c24fdddd0302763761cc93344bb80d2fcfd095ce6c2d5eef35852496b27f04b25b1f455e86af09afbb964a57d948a10a8a334c0557300f6808a0fc9b645406eb24da3bfb6f837763b1ed2686dbaf008c391df7f3afa15a99333c2edc60445e21ccf4ebb19b65c98e3d989c2672080c5eddaf0d578c59ca4641a2dacf0b837a3385fbaad2d7ed66737d25583f6ca3b1311d4d7ec377a2274e9179b2d05e03194e4ee2068d8d810adf367072615cd351ae75292b57c66436c8f243f1d85cb5b8cb9c0df626800464de954ce63b70675c894b9aef7c95b6238723502376be20778fbc9e155dacc1208ea84ae5c8a9c4f86785e29d7db73fed1f95bc06069abdad636125f19e83b240d73bac479f450538d8139ca1a152618597de127209360a41d24afc179abe6222249622c2a88b5a9dd6c33b2d18c1998d54e96082a172d235ca730056912737ecd8565aa2341894ee63e0f05d11916b37dd66363bc5b74ed4634f236660adbe740e60b3b4369fc1661eda8bd13633f18109ffaad93a1bf25af318508cc82a2a8f05f81bead9f0738c6474a24204ced96a874f66b590d1f25bf65d01de3a484a311d9310740f3ae585b663e93dfda7dd11caddb236de78648fc36ac2931aaab071219e41eda4d556cd6e4bcc4f258eddc408050e76b59fcce2684ba52ebe320bfc04d502d694263bdc591d2770378f74a6830842d4a421b5deda5dc39a99656cedfca5b81882c0d7a9f675c0f1bc5ed347f697a30ff8809c5f219b57201ee53198ec869d5b9205fa5985f4256e10500a4c40b2615ba9cd45fe753b6b02ea8b136c6fbcd68f18eb20a9705075077447462c22314297e66b83194584fa9c9208c4bd3d571558c6f29886eeff987caf4727d7adb9c8c3055a82f6cbbc418fdbcc9dd15faa94fe446c058efbc6cc4e23def4a7bc9aa4ac515a3807ee5e1e5d65b0754115be91c0b2808059ddbb7f2ffdbb5b88f32f9e6158fec71ec37b442184b6ef677191f432d2133089cea6e7cc3fb14ccdcad80df0faf16f988e58d684a37799b13270908c18f28e406086b77c1cba509c5a8f02cd4caf91ce428bb7694388df3e2522a1a54683fe0ec8e975cbb625cc448f476008f743a431a8982c1fcc48207b310395196188aaa6ac3136045f152bdec2dae5abe529c35f571ce662085738a4aa1a10f0c17f047f1a6b67883956e2d243bc5f09a0bc032f81632f157ee9081d77821df6cf9bfc03c11b2cddd12a303f057ee197a1c20a79979c18a6fdd0f120b41caeb594bfeed88237675415dedba7ae3b45c2694aa0ef562e14e1b1c734982d0642c653933d59652996424a53d019165fc08a6978570711f48b2ecd240de8e5220ebdef0b6825bcc7d826c3e6a163d113854b62023719f3356587651f10431c53344c0989569ee31dfe2889bb9ddcae1267c8f8a4091eb8011c9c16b5fe1fc2aab6aa0cbd3d8bd5f8a699ff34283535872dd2d86ca6917b09de8d81475c125cc45774602a3aedc822f563428628ddb70fa8457477b76ea05e92987581d0bd55498e6d5d83db8d12a5d23a2b97c9dd9fc8dd6c92eb1b273a25ad124fbaac920d8f6dd973f0dafd3790275211557f0c676acaa443665328e4f9c28474758078eadc3a7770ec694c5767678ce371c96143d339fdb9d8ae51ba16924c42a9f499f213ac9386cc11ab36c9f7733efedefde68c9caa17f6feb108d223e43f7ec561963fe16b7b61761862fe896c28612d11dbceecc7019b8cb34628711730214b15530408f8deb4b2d0215c09e0e3fdbefeee3dda2402026565f39c3da041de0b09e88008fa92eb2eff8f384579c5cb9e9a0e64b82ffd8d35d182b35d5fe745a54e65ae70660a64e9d0c6900293ff4ad16a9fbeea688724c24fbd4ab8e6676c386a9c703f543b28955cb1f4a27c8654b7a2ce78dd0f34f4fa0c6e938d8551b51beca756a36cec23557f2e87ad65922d4a6b23fa3b90feb1bcbf74aeee9f5296e64843e56526766ce6a9a6fdb8129bf131128331a3909fda6df33952bde2c163de68d810180c9a8bf242df66741566ab0b39d54c83140bb93b86276357ba8ffb17cbdc3a71d4d974dbbdc6f174676770c27542db7944a7b1958a34308d9368be276790b68451adf97154283938ee7d4fe7374c5076ad8f1bd8107aed0775abef7d61d6a4448e27a353122313333fce3a29d17c86b55b5180e99e6b35e53c4c37504c494d6ad6913ad4176ec9cf758f03ebdf7c146425b73a6c57d6f190a67df5729971bd696954473e89fb9e2376f61e9c5a47ccce2df3fa11eafdd76d0a24b0bf2800d6e167983d7f029d788d381914e385bca94679d6f2eb5b00913f46fff3d4e687873968780b4b0ae784b969adc1b810c2ae0e4c30a9ae9653af3bd2bfe6ea50125a7778f5188ac335b8c8429ad595084f2087d1aa6680a9681241313a63d7bcd5466d9fb3205aa2a685561e5ab7fc4354440e2e304c9b46216158c57622883c52fda8586eb4409082939203dab514b60d1fc1d254b15513d71daa1449ad43a71c3a24bfb33256ed5e86a27f20b960605359103b1b36ab7a58d9b9d878f7311a71f242ddf0c00d389fbde6a58a87e8fcf96e6efb4fd25c4b07911a7ed0cb3280f544796f6a21a20c849e9d3fa68f1638d4b3246ef3ccd98d941faf112f06cd7d3c547a89348a67c37fdf0e7ff0ef49deec29186cc920eefbc808ed2aa19b2bd1e96d9b9c8ad64ef89bc22b5d222a77a7c55fe99c5404f6d21ac745e8eb79e7c219163ad23fd1ac31d13bc58554ddd5cc13053bec12d6137dccb588fd2de2358a28513db2d0af5cef519f384a76ae5d39579449353a849bbafb4fe1c6b7b499755ae7d2ea2ef17879b5d67829d4f030667e5010eca1a79d8ac37d29232724704c645b61203e57c482de14075a1f228f9f32e45ad7f5c3c3d53924bf95cfc1961698c3ec3ddf0913d8df62bb9d12ee27a5e67cfb8ad3633ce5c555bb1cf31e4dc1171ad33c92aeab07f032a355b96910ced742e8fb3c882d4cac899707a28a107eb2a3d078e8d895c9249cafc134d62d09c2555e37e039fdd27a777d2036cf2dbda16de4e0b63251307691dce44ea2893cb9285951c2881a8f1eadc27b6305dbb5868a64cc6d01d1c11488c67e582a5a2724f9e157d5b524bf9421609af32cf0288ea8f8f5db73a492a329d912dcea6c0bfcbf83ea47e72900b5473dab09c4c1ec2f18d33293d1b4e87732a416b46559dc2ae308ae628339a4bbd7cba0c8410aba294461d0cc7df49f8995abe32b93144b220673fc1058ae04a3c77afd996c822d447b33300d72275077f8b7c93fd444dbf6d13e22f864781cd41e658bba8f145e4386ed1576dc0a79fd29ded8987a19cca251a39d567943f60b631ab2da3fe2225af24cd43426e85ea39f8bf335766e1ab5714998099ea1e41790474ac089cb5b71bb236c8b16e53f2d22fe3e430a8fcee86045d7a2ec7796e6fea6dab196283a95464631f2dadb5a610ac5a090f548d5e484416e1bf6f93bbb6388a097eaa790510e8e533035578ca16930e3b9b40dab1ce960cbb118559fd3dead0a1c52e5c6c077a7952042580160985cd325d92b8bfa8a38ccf3a796df640b62c5bc8637ca1bdcea22a98665718453be5e5f345af8af845e9b412ae9a6467c1e128df5cdedba00b3c5d24b94694215dab0e95b4d81c9dd9c7712cda61f10adcbaafd6fb0f47dcd13fb3aa3b7fa744c49dc78df04c22ce1b1e1c7046583f008a6dda6e879cead492306e2e8dee5194a1f2b16756a07a972fdd6b0222b2ee98b91919f69e1904398d0f139dfca9ead3755e23f1c0b39ec5de6c02f2b46a72770fc8fbfce99dc516b43c911776742bbf6ecb083329f525ed74130cb9bd6bbbe206e9a2f392177cae5fd50cb78e7d65ccaf20abd365db4c3f38a0437e72220b66f24f1a153b24c8a30e8965646fc1ace85d8dbc9971ae777d4e49695c040ee32fa0bcb3b1ac8030ba850d0d0f445847ce105612dbfbc34bb16257b598fc21f69075648238a51c96de4e28e87488c0061861fdaba7aa57c3492136459a9831a564557281a92616fecf89c0ceb0c74db81c8f961db3c3dfad5354d32f49d8ddedede86f1977310e219f3b9be5700621eed2c36e30267dfa89541bf83b45dd10299c5deb420e987255e41077c117d0af3e68fdef2feb6a246357e8cedf7ca6d6a1ee50f2c66d37cab675317871f844cc3a374dc831b6b1a9981a4ff1cb99b2ce11f185f2bb57632b8e11ad42a32f798c51ec3c6bd9c8e4bde7b8ffa10c32240bc7f730e672fb3b5e85c54466088941019b5510c37e2fe1e9690bda90d3bcf60e8dc93543e55a29d15f0fe1169631a2903cd0c01ec2f1ee560bdd6d2ea63ee72a9642cdf87b1c4ea23d18e12ea82a41777f87d961dddffe77e5eb56e34da5d92f100a170dfc8f26fc7415460067af524aed878270b27bc29b37a7a935728c63d9cc7a520248d1b246d68a1e516c45203b5e601042683ac00b70142f224ca3ccbdd3bc38f3297888b97f126085ae0e8335d6bfe8350c502468ce090d11ae3f02d1d0dd00fb088ef0ffd29fca83e9f886fcdba457a1129e9013a8928eda396908db025493c64925a0bea6dc498d508b87d4821d9e49e5a0ef94ff370ce2daecbb234deb7228910fde2fe6f06e3c64927056da1a9e19630a9a6ea4c784927880426d5872ba8a9ca12edae9f9c9507ea41fccb8e552cca982cde8e14cf560a9d4e4f92b20931b00bdc58528881e1d9443acf4ee24322a8d9eb0fbace12412dd1e5fcab842629a14385e39c65a8f85a8e307e8e57e841fa54a56843d61ce660307c80ab9c245f26fed56f93732c564c118577a88887bab536fa8109b77d6f11bb4ca5133745551ada2d5a13a0cf817f72971bfe4dfb37b7fa9470e10a153160f5940bb739117114586da7fad4a07831d38f41d231f9ff001373d78c8a7902de09c238c4972d24260f4d586b009b94393a38d448371d7837a289d1491045f936c70f15376605fc085eab14fe8e04e544739bae7222d452d14b5f83289f1ad56c25b9b4219d7635a6c17a74bc02dffc3ced8c0483249b8d9f3d78db05fca7356e4d881c753fe25e3cda8ed07b28862bc8a6c80a5f9eeb65a3b5b04d12f14e6fd84bfad6eb8fc7bf46d7bfcc243ff459fc15634ceea32e0f56ca7b8eeb68324584a44ff6577c0d480af7d590c97b8a4656fa2564f41e61911413ef49dfea3ff1bf228f7b75e07620d383437b08e912cf6c481586e258d75ab1278105c0bdbec65b879b01e445c04aea212c86140d0866c2c199a7081c9144ec60330822d99d9235ee6afb6d1ac5a1be79be9f91e7b90c352c39b13cb890e9918e817386f77ac5a33741e10f68254f29789de30fd511357bb62139cdef68f3c0b27de219ca3387442b8a74d4e6a76bde858f689b52b677c1749a073ce85d93058d87e5ff74feba29b2aef4bf73d457d330661c9e6b1459e004eb9972cd1360f2fd9140fe88f91ecd916118064fff13a1386a56356886c90c1fdc0da591a5f1303eb35c01178cc6f819d3e04765f07153b2bde1ec037e6930f2150b2b384fb5bc62563e2556c7268d4d08b459c1bbc065035d38fe468ecc4b465ba4ef7608b40975a48975c378a65ce8c79ee240f247158fa1efc7986508c86f0ebcdbc095a88f00d6dc19f22bed70c6d5948710f3d5735f3e9264462896861be603aafc96933ab180adaf74bd88d460c975b11f342a1913be64969ee2a8f19ff40eeb4f02d690086923cff68b58848ed756a6c3a9d07e7a2cca68ae63868c3c7a423f1c6fbdc61fa6d0a297ecef0c5c269bb68becdfc67cae2e5c863595fd969ddd609d8c437c85ecf3d3171227fbee80ad41de5d5200f2a96830aab534cd4e93848a423259fdb726435bcd2705168191323809269280971739449ceab5784c6b99bf93238926d99b916e11192c4e703c74a1b0909c61ce7ecab9cce651533c62d22e0f088c3193c0a53ec7eff2836fb4c0219060083371bcc307e4e7cf1cecf52cea2a96636389592cde72b54a06627a12737fda50576fd6406fbbc7cc2ad972eabc5d727ad1a345ecaa1b649cec5a9ebe05af7fb7ce8dff50f08b3bda233dfba4e5ef195c383d7d8840cbd2abe0c8696d57764bd44127c891eb41278bf3ec78c0723866f88c8673b22fb1ca1584cb5ace14dcda7f08ffbdf59ce6b4d60a054baf9cf69c425fe9b6a6125c055fbb09352e782326480b5c6a2f2896c590a00eb4a886380525afbaa01c13b02c09d7202c46e34a360ec2e3ebad47dc3ec585e9aa3a3299f865b12189867136693a1dc83fae8ef0f8b1e12b943119eb66223a688e66b7ca50637c71f176adff7dc58a22775770cacda828d8626a6c1217b026c2a23705e36737df573c5ab2d61ed7d5cbb6ca5d8e70b238585216695fe3cd18f2f5a6cdb87331696bf578d0bb93d864da85a71418f9865867ab64bbfe58ac2d8a13114ebd0dce8194a1107c5d27188760aeaef0f96e5ba2f6f7118ff4a53bb1d38199f840621cf29748d8cd98296862fdba1adb2105628d9a494ee6b94f871d8fc0b0cf281075ba08dd82e8d8ad2594bc6f51fd66bb6a55c45eef6c61ec4466fa98faf6501dbb7a33a94c0966eb156f44076cd13bde37630f790ade6764e28e28f7f9c1016024e92856fc08c2f5040a40c434380acd387f75206aeade1d59ebcb7938dbe12345f12f71fccab8f86aa7c63390ec09cf9614cdc7d4a294896699200a5971088bd29e4a07ae132dfbdb9556bc77e74171c6f473dede10f289ccae638c25ad44fd3c06f7f1626f47433b392bf385706d8c82fab77828ef7e0914e1b9b54753b344d0a52153734406460d52527277a7385acf12f7c9d5765d84ee84c2d382ac2f46925b7adb4b765c14f3df1780bdcc66ec29293d1eb537bfcaae232107f6f4659739217a8cac1f2fb0ee4ac7f9b2efd88705a48a4ec3042de9b38c04397b0dd2a9ecb7ae799bf26c19f2a70185556cd7f3eabf4563e22a6e9c60a10c391a52682b34666551c160c1741619b1afdbad779916417038846141e2314ffaec6d3bbd9e2a93bbda956bb490f5d871857a943608cafd44657350c962ebfa5193486f7c7dd193a587b42d0aab7e035f1f777614f0d718b12131ecaa3fdabe0eeabb0bf72714842398c67538435ad571c99b0db70eec08dcadf97a98f49f7e2d05f7e67c1f4981a2fe0a403b732ce39c1e56e565ff9d88c862e4a9e0418d922260bfa7e2a09685ab3cf22f9352102db3714530f7d78d7eafb427dab626f8d756d6481cb19ecd806fa3604366c90dbaed86e7dd37ec7478b0a90fdb44c2fce059509fca6784f7ed7ed938ce49f6648dcfcebdf779085eb393d0862306a66e7d653d9a5fc5817251abd3d31fda7203860db76eb775a60af78a2c51f955d049c1a927109279cf93275acfb755e569838a77642183d4f41f63cc3139f97129e1952931b6d3c9f1be5bb92d3bcbdc5efbbcd768cc7b60dc73f66ae99c9447b9e73a72163a0f15d814eeac0f6fad123701b65338119c96833582f543acf1c134dee1beea437c96161b8293e7bf64e9413c05450b61043393bcab4a873b19335c9504cc5ed2c1df5f1dbd6f46a1843ea22a66b4a11d95beaa97875a346e252a0df98c95cd4a29e5f90e69a8f17565489b023fb51a777a12d84ba33f051a45f9c5c342672f75791dcc45abc7f0e6774f1b3dfa3c7f41c73b82eb0de4b3a4acdbc8a1986ac3bea6dfbf3d6f7322d481c6ef231ad28e625f3f0f759170167ab4a4d56f747d26b5a26dd2db188dfb3f1306426e048160e048409b19917ddf5e101a6950f5405eac31855a693a0e3b9866c4f8f972deaf4bf3d0b767a1fbec24baacfea7d4dea496b7ee1432d30543919fac9dc09a460691539c8b99f9cc733c6561adce8f0c9ad56f5094bc3dd2f1ccdaaf93858c509eadf31fff313cc374f7fa70e094bdc1d15b96c4334cb138c7d8d4c3e766118e2bde91d061913677f4ceb710446213ed61e5bc137df93da52a642ae09ffb5eef8c39fe2f1f3fd95124ea3cb610a0a98de781370554ff9f9261790fb27b8fde27525025b2df851a451c7172cdb5424e8fdb6153f166259038d6a0b5244d80bbd76a8a8994ddf8d41d21f1596b0cd2727e5475f480f14ef2c616c9d612194c057f367b9d54a72533225aa448450de3500c7a6c50e87a495a796fffdd39d26181291300c035573c6a3a57a8f54b465c199993559c7a034ddf746d7d2889976a688293b0d73618b5226abe3650732446e7f7ea37d1992b15d0cea7ca6833efbfbbbcdbaf00281b3938f648879ed9478a3f6735030d38d24f7c43b4eff00a27243b8c5e33c8caef79a4d36e13db8b985c6c59bf2b6f7c02caaa678cd9deb5350d763e63abece4f337e1be3b9f36b0fc89289892c61398f136d1ebae85d494e1a5bd81ebe43160ce77061db2e7d6dfc1dfc32293c8c4aa3689da1f5a377a6a4449699be3c543587156f59b3979cbdaf4901cf89c9faccb8878850a4560330fb7241df92b029e8459598134c0f37f316819fbff2d826a142e01796302b21ea07fd2c289bdb9edb1fe5195709c8944ada82d4ba701014a5a1a925d84f36df4797f681ff4e65c173f9ec9f0d682be4a503b90b2d92809407f3e28e06750e7a92a7a46cfc1fcd385499ada5a06cb43c2be6a1dd77bf21d41f9ebc65cf0177092331b7136d772f97617cd0ebfb4424315300a1970ac22865e0cb06fe76536d6c8f9fe305af7b2d4a5bfe453ce886720e6f5c03c3cf96e6cb76936b5031c3c24acfbcff593ec806af98d1f7cc61b3b96d2060a5a6ecc67049c451e39d1c072747fdacd8dd34f51135553bc3d4bdbfc65912cacd32fe4917e20478f94f4b7c01479f5a410f6a3bcbae52feaed43d078ef35ad82f77f176a2bcdb86c1da66e1e4df47e81d489eb356f9ea805ec680c343995f241812b41a359e4247c1db9270d1fd39ab6a1a43a4c7a6ae16377a9e7129fe116f24d51d78b974fe93aa8bf489080140a3390740312fc79a60b8287df489141917065c9fa333a9adf92afb9887ed5f9099c9332579ef2620bd7801688b62bf2882bfb3f1c657424dc2783323187726fc37672042e9a4bbc0be57d902fc45fcc29080fedc9d5b8f59453841b533221db6c191f94b90fa042882f9d15eb9f12565eaa5583086aab66d3f331e38ce3ffe7382146e8619880c8502f341cc26cd0fd4272d020987f35707710e9f0c541e57e177d72fd4656aeb5073ab8778e7a22a6b0e0f0e473006d4778ab94a2c2d0c22f571a23f2530008f2776411d231665bba08bc1e7a96c64ae12bf1a7500bb3b65d70149249b7418f79196aa6a39f59282cdf2ffd0fee9d49fe5659b3cd6e5e59e0d3ceb20b2b6195eb55b30cae7374f682c48a85c3352871b93dcd1c226369ae47eb1237d8e131b95afae0ff38596757e079dd74bc30c6592a8d2fdabd36b8f7ca9bef580ae4853e8b7c6ac4080159dca5d2a9df4d151ba1015c91fea90c2ef665d9c5964a4c1f7879351a80f866ade71c01a1de4a74f01930f4b27d578551970753a4887aae87625034731e6e47e494aa26a47e43d21bc7fff912f10fca5d1faac6a4dec21fa72aaf7f92a3962263f92d90fc595b12afefc385a7007b2d587da18d0a5bb81bd3484d0cd61fb251a714359a773772b4803bf003dde5a1ab817aa03098da948f5836e686e6e5897264910d3758c175be07cc8ebbdf44c47f8b8c2ef8959c0261dbc8643c424aebe30d4006eff1bb003ca2785e35071a0bdd60961e6dc10623224a80eeaa95b455298d443e971352974c742ac9c5f14e3b109e11dce135df8d934bd5191a32ba9d30c6c7d3c8b9a9222daf078b7a4cd7ea4adb66f99e7329b3a88e89ada764f449c9273a03e372b3190b2c2c3e30327a2ebeb88ac79d949e7e9ed0564e28b4188b2f4d00768ae4e8f7c9c140da25966b8c0fa2f1b373eec486556d38c0c76","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
