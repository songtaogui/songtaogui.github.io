<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41ca90a8ecf80e738358c31f73ae084bab93b50bacba8b6b85b125d1c971bb39b6208953f101cf5fd2690a256af15b5c950ce15f3882ee63aad9731ac6857a65e574aa2471477ad1d2a71ebed242e95e8bed2c14ddf3f4c53b3da10ff391988b4f180af703e1d0983d820952e1a68ca511ab79a014e9ebbd2e8ab03ecdb3350bfcc22a98bb55022496245700a2dd28f501dd6635945c0871b21ac20fb6519870dd9d4f2f09b06d160b7f537631c3778fee66b71371d2530704471ba7e985bf88ed9cad79c23d55de08a0ec900c497b9a8effa5a87e27da3225c50f61efd1d2f5888b3fbec4b559086113231b329c4c1aef8fe84079c4f0e991a2078e242db98d808b95b5da31638fcea6834290c7051b32a53283190b01c126ada45e0e06a725e881eb1599b9c5846ed89813754419ce5b3ece8540bd1d361febed10be3afa0f82254ad1bc82e40a9da52146004d24ecb3f2403b2ff4fc9a3b1241e8d9aa3d38e924d64ed4f04e85f7087d7b95b5bbff6d584796254b3c44442c744133fb49cb2c03580a2a788f96bbfd971327ebe359893cdcfad513ad007045bae088b36103022b92757f0cbd17833493014330517da9fcffaec72c19a70f111977cd1dcb107e6088f774397d3b1f50ac0954bc7b55a77fb7a48bcda61a90effde8031038a32b34926f2438ab184c32e0d633a1a22e78adf7b52055423abfb3f9026ed32de87dc62c6150ac64c0f1c99b45b137489e5a4906c702ac956eabc24bd8ae79fd543873edf66a490de256d5f225d33b3b0f9bcd610502c9f33e5d65e8a34409a8bf52a8ebe45d6bd609b9c4562617fe5b71179162819f1a625d9a2031bf46dc38ed99e05a527e33e3c8eeb41ac9e4e196e4ca36d000e7d8ec2a1910de64a5a2b24d61a6c1b84bbb4f9d250f31df465ed6b577808d608fe7d3b25c25d9292c40b61e60d4f52c99fef944eb863e6cdef1e9b4edd72511a01df8f28b1c77ad51b02feb0b10692baef824266fa510b7ea6f08df32d9dbe45ca253ce3178759756225a5a782bc9089b2e9e834516113ad101531ecdf462c156c2001ccf005b1779121b2c5367df0d919a6c060bade4988cbb3f5c79d2293d5c5c4b3a74bd540a4e22e655bf381fa636be7580da85ca30cc0ef28519a21184afb31f616a6d667720239a4607e591830d67fa5b6385251ebcdf48c09a203faf05de251b08b0cedc108e583bcc912025bbc8423efd3c8361e1605ef86586297dfd597ee1b34ac6c8756c79d5d568349b895cc71d275960a5944e1c209e30a285884e2cc1361344c4f20a139bfe660f08c52362c0d943d8fbde061c843c1f253a9db96cdb4239f055f4e894e9a78546234413553f06d38ef7475f813935b87cbae24f976cb9e0a5e137a55fae57b9a8217318d84bd729bba1691ed852b9d0f600b808c1303a89a3bbb083d60c2c3671c9cbb6043dcd6d99479b2954596e2e38bd51afb875ce734042271ce7d8e5cb627201c9e93afa4fdc6fe386458895ffce932f80dc25ed19c64f26bcb5961d384ea80442163c7e3833e88321d786f211bbc6ac19f83517999b3401b80c488a983d262a8318d84fdeb56aaab69b436de237d26853b712d222a0a593b249112a743c04be66e035bc6d506134dea29e649c43dbf6be58a1c81b7534eb502f4cb3ae0f910bc97def8e6d5761c9aba68ca664be99549fbfc21c6e937fe6a30092cfd21755379e366cd7a6637f92c86a37554922f0c61a95e155da1333476235eb3e1fad2ffa3c34a652dd4e777c6b30c35dfff726865485b0c8a5da8669ca6519041c75f4d814c2616da18ea1c59a79ea475100d61e41108e642c86ee32fae09eed6e2561bb4016ceda4130f213f5c78556f027ed9987ba23a341989330e1c62ddf0214186695650ef21ababc6a0c7faf430572fb4759db20b768d06e578b3850b53bdaa4b64fe9e7708dd74616b5c52db3e103f3b7911ad448d6cf9506a423c5404019f02c4f9ca7f543ccec79e9ebc6c4e07a42b7260d6e96abda08cd672eaedead953741438dd14e36104f150fc2c31eda9dc48e2493b51ff162b2fae0d7e1b272d25aa568dff2c38081086147db6082f983a4f00b77ff65f3590480d87085115076eb0470670b0b956df34ac7aef02c10faabe6cac88514e04e8cda3f67ee172e4a8f95fff6bbf239381088b710c87aeae2bc84e22955e83a2d5aba2ad32ef6a675947ee547ecf061e1f7c713911443d065c115fe9038d444e6c85e02a8cf23ee9dc929d9a67a7f8a9829da55e55e6d764243f6028559143323a3aea8e3ca7151c80afc7360020dc60c6d94d033648682b42ba6134748e20c02066351defa0925112e6d7055c223613bf05260d8c7906bbcf84cd756449e248ea3524f6537f91844b1680b0a79fda6517ae3ded2737095b4d3432be85818a125b2480d5704fc1c10b71cd319ff4ed1cc164752f7a89413302c55a4ddad2731af30cf90e992d7bbf9537e56010c9efb020c75de350c990b94747d4f3b0ce919bb3f913aabfda2c7a2875877e42fc1f64663bdc2314cc20b179de0a8ee162aca6c95cc446b0882c890a0284de8f3c737bc0522f6a03404acfc9a60f8733f35cc21ef3c9db375a5609a83ae926b8222c17f1f16cca5a8e90b62e3e3f7bfd830c586376bf76457e44d106f4a62c239c53889a35627c8814c7a7c87e4150d9c4fd0ef9162df4d6bb44def27c6f02f4fa7b5f889e9ebfee34683c1e2c7c52bf4604ae9e15e6d84759ab5bda1e477837abb9e5b6cab844fecd223bdd732af1587e93048899cb2e102ebdbdfd2fe7b07ac86c0e30b8a90c6a7a8ca75011bf90c40a7bd195c80e32b181fc5644d19c1284815f75254af093041d1c574e1169bfcedbe8131c0bab81102911a38c78c4d13532e5f95ca76436b4641ef8ae5b2d43f623b4447d0f11425214e6806c8586cd068e3872089cc71d86095221b2aad47cb64f4b83c535df4351aadad18d7d968b71ee6d2c876e5478cf14ca86d1ca5ad927c38388ae330adbae5c157fd9de0eac0617384d49a12096c925d75b72184f71e5c84189786c39ce7eec7c34174ab84e4c2b8fd1ace59801598371b6e07d73599b63e583e040c68716d58eb125d250546ecd8887b18e7a1b75cb3823c8d9833d37ce6c8176d1b542bb0c632c1eb04c89e035d2dd86a8d085aa88273e7ff904eec322b0085367d0dd78f741048149e55553733e7e252891c7d15526e3bd16a35f5c9e83f8b85a93a756a3b1b1a9a7dd352fb8eace45be5e564f379d4a2e4beb80a6083a598ba832049e26dfcb6f3c784d55ad704a9e906936003e825bda6430758e5ac2a7038242ca159777dd67979c31d184b2ca3cb462b5e0f8e8b91343f96dccfb3ad4780b9eb61c21c54e04c41a71e79fcbf7e14163eb247179d30f30e412513fcb4bce9025fb8577eb0ef1ff2e293e2cffa29061a0b4280c0b4fa60f98572e3c4e88344a373cf14f0c870ed8d656a888231e48b3f668105e0d9d3618efd0a6f0b979f94e64456250b46bbed1df730bd5c43712bb82c67d45ca36b32b3fd52d2d90760db57fadca1937751aab4f13f67862cd92130cdf327413bea37d4ece90b768010e1abf03a21c25e6a0f14edef6a67c07aa77a6c4acf0be3ff2479367307a336c8ced04e4d87589965eb8daa180ac2a5e729b922a0f161780fef4a79612f819b369707e804ee57b0d53710ce9386a707a9a34cee412436465fbda9c90145ec370b6d20271af3c8dc86bd60d9c20ce4ee4c3b677afb86d4b2e503ef45bc43b2611e99c42d61dae812ef03c0b42b9a7afc630333208c3b635f10b47b15877cbd225dc44d8c4176a272dbbebfee5a9a169399c98a8eec3d1f36fcb6bbaa9093155a3e63f08e139723fdddaa4710b3782868d82671be24d30c7ee63cb8ded8331b397a59c7eea18c41e724b7650daa395f9b7ad4246a21f0fc37d0c96aec8c4bd19c45a0421fc70ed956c1e0ea5a2d60331dc4501328563228bf42f26340707de4624970e72d368e01df6fca3a96748f27900d1833cf718963e728f4c68a07d1857b7de93597912f14cbbefb255e5856fd594db8d82c5985c09d541b3856b28e40af6113404a0942ae77940629e5f9d33b4cbf618bf4383982ffa3d242502c616ae21920dc69d8f399fd3c53774b46f8bf3204338dd6914d6b881f8c490a97da59623b1a3ee97360d1f716d39d381dddd621465ada442a56522e35d269af74a6dc8eade969d75790fa8c55f9712ecec60eb4499367d7a83ed379b17363b04f9e023d3f13a84e9dfaf53c4a72771b3c4a0e60bc36f2f50eeba8f1cc50d281989b72e468fd3956289c3237d122bfd719a203680539ebd7fa7895943386166e6795c893b1a33af8d1601b7cf46863583a0905191d5ef4f54f671c0de4ac31565839deb11b2de633da42406945185a7a102339aebe0f8ae4ddde51708ee7d85f5ca8a7d6640cca514e0aba58d39cb25ca297dbdb0712128751613213218d3a87b42c11f333f22d67b62a428390eda28f2853d68deb1e05192733615aeadbd6456533ddc3bca304a64f432bb6cca0bcc158047f4649226ad26a9705a8f2be7ff76b995caf8d0d7c9bb86d600584f867c38251fee63138e40b017e4e38e0ad97b9d86639fdefa0549b8865d57aeecdc2953e0b58d430bf8efc465fbb59518f326fae9409e41f55574b6982431e8a5e77aedcce7a71cd8ae9c484cca73cab31f1e415d27d9fd1bad1b5c5dbb5890e11bf210e56b03770f066aae4cff2dd5cd02f6fe21d717c48c1e7bbb404525de929742fbdad3197dcab94553500d10c33cbf5152a02e439ae92c46810f336644f7089d5eaca7cd383e1465b68bb57bdb21bd4a06d9277c088f748356901dc4a2fdf8a859f7fb315bb4a5537c479450f4b82cc08fed1850d8e356c24e8c21344b56dd679da43b0e2412b1550c92580a3141ea69eca81d212e819137d7e0bf5657acb9e566e7b8edcd8d404d13568e3ed629aec9195d37140c69c811aba02c119dbdfd340c9b0dc9f067bd779dfb97e967bb434ebcc1d1e6c533cf9edad9808238d2d43dbd388bdb20d7f65155185ef0c56f084f437d8797d7e3957d3a0ca5d58213ddf9cde0d95b7c571c45ab1154e7cabf702754bb1b310ad3181d756687cb71911f4f55bdf0c3aa0ed68caff441495d6592308360956ec1959247da2008e86dac50535cdd0328cc6cdfb596cb0d493b8809ba5a4664b3f955f725ad9f6292506348a108fd8e8aa1da6c5ce2865dfe07ff34562cf442ac79148fc149bc7c201d3910b02d81b5b9e2138f0f016249c5ccef2897fc1483a3783e1b15d95deea5f0e99602ab7ce8bbdd8bf58b26b2cc3da04bd9cfd6ed22540a8ec9b8ea166e1dbdcf966d4473515b5e91a919933edccfb845f1cb3d7cf8f7446972ea01e921f6ad5ce77c6160018e6b7c1c6ef5a8f0df1b2a4e4a68c3c7df3f8764172cec27a3c26c786277b6d0c68f267c07ea3c82b9d9ac1f8b3d22b034170af7f3134381ebc1a07eb13ea86f9009a6378594bf8bb1ac975e137b0aef9a93e7fb52cdcd3767d64dd14d2bb752f20fd1d2abefb8cb8766ef36083000d249cacd4a9205e3ad71842efdf628e3103c775ad607e658eed602b793177ff6c91926a5b3110a78cc729cbc11eeb467f0a551948eed2683064fc9f3be4b5cc004e0270b74a4b5b2fd4285575ec169bcae9b99e4df7f41f562d39d9209aa90ab493a309441ae42628016c3b4e9a8350b6163d24cebd719c2aee7b7d866d171544b65d64bd0576635ab4cda801e9391d20f2e40eb4ddcca5058beebb9ecef2ab26b06051935e1fcd35114979aac6541ad1e502a66f08c091f5b6ffc7b50e6f0716fda0e228c99985b13f6f78416a884d0e52a389bd3acc8635fd6467624e8fc616393e41f4edcd6e9cc03f6526bad879b551f66547989f655240ef215f7fc79a1dab2ec9936033107e42d48203c4dc1fa91284e915e2936871b928cd9b1dcccf123dab6841fc8ab90a926a497f60813001ddfd83ad3786c281a365761f7ee4f9c65f15350e7f73ae1ab19eecd3f4f5ea98ad3448f84b1bd2af1e954d1767b1bd76ff16fd347684bc305f737cdfe5a5b426f11c4ee304aac4e94d9105ba1688fad41f625e0f419979a82f041d770dea38eaa04c0957a963108eaeff53e2ab1ff49fa167e69f259c39bdcfcbcbdcf511816aca5decab8627095435ae702ceb53904108bed7ed1fb355e053bffa4fbf5dac246451595e085804eb24bed409d59dcc84b1dd716aa6560b1895db6f5c9330a24efd5ab059ffc2a9056814ed15a28ffef1c8e154e9dfdb196f86b261d6eb7dee1ce0287b3d886897f3583cc4935946d595aab6f20ee163bb21943b25b5398614e8e6cc6dc04f7d719dd2beb97435fe354a2abb2818c1ad66784459c30810d83dfaff4d3f6f3de379519bca7a3fa00b644e8de14ff7ccd4ea7bb1e36541d4d9a914c59c8292f5bc01ba9938a6464d4bfdffa7e5b6aa4b9528a1610aa4a3ca98d13fa10e8aab64f9227a159763b25caa8c8442ec33d519543839bfe9a3b038510bfcd42f0d898d3eaba2286f64c55a7990e3f06574bd51396b7628084554539c783de2d277dc566cee2be5c6fceed6e702fbc614da723e869fb4014908013e596156b3da5b3701d20a436cfb30f08017db0a11b7b7212e9aad03721b6d45caa08cba8d9a9d9f420d7fd8572d625b80d15146ed0c7892f92c486a858c2bf7058d53456126314a35a083f1574ad293fa8a26de769ed8ed77e3f94587195ecc490bbf143269cd17b8b343532bf7bbcb429dc39150dda2f335947291c7dc475d78aeb8449e4b65d10f10d097638eecaad7b501dffc50b83772427b5ac9aeebee3a980ad52eb49c9e2402ee0a799261316cb843cc31d535999126dab5ae821cd019e9bf27bae2db618bf95acb8d76c6221811988e6d698fd798b0683d4f2a45c72babfb49f83286f114430680fce1cee9cbe24d94ab0182a3ff0e11504f8fb3403be389db4bd680e4ba031786b555b6c00952452c51e241904b2b7dc75f1102364412c4bccc0d975ec544056cb8430fa10b45a69469a38bf98e12715fa7342cc6a26de8d13f585fbc542d8500d7ad3778a60b2d5e7787eaccd3b081ce1d7550abdab9879f7a02c0ce47154e7e0c69a9a7fe67c82f98464f72af874072590a31574f8b56ef43d2d73f4b592aeef1c5c61f2340767c86fbd6161c27020762ff3eb0ec1e4a6c5159c48436e29da68b1a13267dda190df23c1633a26bc0861761d12c1cbc4cea72153eb643dde7c3e025976e3868c765ce4e95f6aa58d3ca5518ccf1518d7d435b4fe443eaac7d76bb413a7525eb12eeff47bbf30d42a927037822bf558733075fb6297e9a57440d3289fae4320f5c949469c295bd1d484364bc8b5e78de5212a629e01cd14c39520973c29f3ce6fa70f41656d8d700567910a4356fde6bf7d2e9b220d0ef0704a651f8bd508717ba8348484b93b010268e5a7936003001c08883df09e4f01b28d50b0d9b2ae7562c1c69ac726122fcf4b7d149f58c4849629e7df8b671af1f1c575add1195a28a898369ff76a05fdb0ec9a73e24c4db1842d2acd52f7c6382de25490936d60f4c66c33421425854d13409cc1185bc6ee3956687cf97f96de779f3648c6d0c29cc8f0c3b7a89ec4aad9601d3fe737d56ef8b11fd0a9b526f44d913fba077b8e8684af47cf661a4aeee4ee37fb11d7cd7868bf6463eb9844239a5e4b4ccf0fbdbdffddcfd024f181922407a292cb64262be90cc0caf86f1b31790cc12255e6c5232fc9c7e2b4b06336cedf235b77ca848e22b41169e73b8ffd940021f16cd0060e82efa0e593927e5b6ec9889dfc067022c0bdb5ea9a7e1b18e52784a93bb22de3e99587aaaed7266d33b12c8b6ba2b1911196ae804b98c60150be3984c458b47e2bef65e0e313c006f1facaab3967b67418cedb34dee6afd98b44764548726bf6b611f1f61cb8884c904c6a686dc182c24913aadd3c2c2bc16908ff0e18b59374fc04f9eff66eeaa7ea430645a764790b7ac900568dffecef57d4107fafa69fe28992d018ddbe8c831e4f1e16c7573cf423add9d10d2a39db57c6cc5a8f9ffb7b91462ea607455e157c31aa45969f605c707dcb9c02680f9b2082e3866cf155203c267f5af842fedde281c84452b92b535cde71099e210e4ee9a68aca2054ca5574cdb70d457b3a824f9cbc04d21b4ce392115ed4635063d08cbc7aba21b5a75263a9cd66b5a730d916ef8e5a9326eee8f5b3f93e1fc50dd2b2604b8950fbe2cd9b3b4324aacbb4e27b63d6b739da15ab1274638870911b63446a52a7d25ca0ef445d7b4356d3b2f73b2627a2794f24925cf39addd44cb2ba9b1e139f2d3a6306de90eb6e3ba53aaa377d45fb31fbda6a84d04b3d54ab1e97d35ae3e570be7389e8a07b51204604fc13ab7a79f5a774f33017139a0b7c266efb1b113cd7f5fe4a7d50c03cfcae5fd40b9d14706830a85a48a71d38cca3f0cd9fb71fa14615bcd39c60ba9956bbd3ed8c3453813b6d49bfd324ebb8a30bea9a290ca00c12128843109acedeaca4edac18d683eb40f333f0f7327685f156fca56eca4d242eacf92f2143e03595d93c4ee94b04e0332201a1cdd2ab53d26db567e75b7fba716bad3de1eeadbcc6ba93e2c02b8f82d622b59f6c84315a62f13180b7c3af02d7d2652d083c8ad69eaa558065694fb2230276044ec65cfff5bd53202cfd9ec470a868c38450636fc8ff8c7a59cc574477d7b0b0db27adc5d43bb13966200207af183071ede263f9d44aefc3501a58a3bb05dd9717439625f005ca7c6811972496e0e28317846c4b12c1fa8ae88c1af165b12a192bf0c275ebdf99850d7602a002a0fc9ffaf092db1f656a778088a1d2ec8ae57b290f97a90069afcf8f5542a878a402fa1d0573ec25be550f2eee3db31e05089b9cb8af111bb83616286012c234b69f942250d933a7d65dd2aa1cad93d1dd0d95e17da8d5d15f2e818c1f1427ab91943d56731fcc64ccb1b2facce48f26073273e207e0f3239d4e43475bad4e7ee3a64148b0fc485cb40bb06d871420d535bb98416aa105b1ece2ff477490691f312afe242956ababf1d31a8d2fb8136114dcd1c509eeab874ea5e94582cd0075c5705f4af406657c079d83c3a3b564aa287694fa6240f871b33278bf5b009ff8a4a694287ccc598c58a1012b18f498096c3a109f250d3f64f2ae33d3ae1879e9c8798a7c4dad9e2472ccb1c1d261ad08163a7edaa7a0a8bed31ba2f7880063de7ecc6b3521d23bb4061e5f304a578a38b1fa422316589e6d76036acb85a54cdaf8d6e38c9bb5ecb5e3706f4a32924a536dda07851c3e317a47689e009e28f73d04aa3738e7ec6c6eb87aea164f41fbf32fe5a5fafc51648a79d238dffad9157e285a54860a0209ab815096511c1303bcf9a4a71cacf3e71331bd7dfb5a1092b8e826273d9bcbeb4993ac2df3291c86fd21a3f69e19b46756e95b8f1d6ab1f75f92c2512a24c0cb2cf9f8422f6576bd5a54de568648cb4a2362c2a46339f523ca54c02b9211993762346b8ea5902ed0b060b7b450581d6d8e4a7dd91ef8846e32e4c3a39a2132256cb753207b9b8f97c18efdf0bad613bfc8a1c695c7bbb521f688285ddaa14a738c4c196e84cd60720350bae01617fa5f202c988b90de3368aab0b5533b8783c3927aa33c45ba84f8c88d9735114d42eec85f227ce82b807356b062eb2fcd9fb9c0041c762bda2d4b386193a96a94a14550dae2033c6ccd4550cc3c32089e49accbf9c392fdecdb7c8619579b9acad8eaaf99f7fd9d2f5c47f1e9e7f036a90ead451d4834226eecf6f3241bf4e175ef312f521d58471dd281fafb2120da4d60f9549746c97307eda794446b89db9664812ed8a0c3148158528ccc529915730edda048ce8b04ba01eff8e874ebc77a3c6a3c843f3c43abaa394e2eb1bd785b3670a357cdb734905178db287766aebc1f725c092470830c9c385992348654cdf0b60e3601380bf03ad98f53ea152934b011854c2ddc9834d545210e6e7e3193ebd62606d59c8f7b50b82a602e199c675f56feaa16862832e23932da2f4c618bd020b1bf37d32192307abe363b600d430891061df6167ef125c4c0aa7a66180b97e3fea96703d946fe1f2251a483ebf61a0cefc2a752608dc9e1e670e07d3ddd565040298c931c3fff7a792fc8558b9526e8c85c6fb9127f0227ad9fafb5d9e3265ed14e86b4c60af8bb79227c89963180032e00936f019ed42c352d796f58b44df11b8641a837d85622f95121ec3fa6b2988b3113222c15a1569716891b943f9b2f89c8e6cfa8830cd2bc8a08b801554352daa6f535ac29eb561347e355496ee5a2f3497b28fb343ef626ac7b12b39ab881b17e3c7f6038e76dcbfc3da29b99d2d295251c1c273237ee402143b77b5d3db59d49ea9d6311acd70b294b0f1dfdf9c9784eb18cf882a8a73e290f8718fb1390ee2c82a8597ef4f675dde69a7f05d5d7bdd7a0666d6374c4065e6beb748286eae1176d6c4b5af5a9ac2a49de096edc6fe33300d47742bf6f04b14c7406be2245aaaf2792a62818079931d41e613722aecef079fafed464f73302abc90c538617fbfac0d66ba5704c62644566c4eb755f2f9e76a7bd6e26eead306193edec2ddd7a646e368d3e0375a0947dfdf4abab335815c3df1f7cc6c45f1b18cbaf24d7165e5b67a9e6effaae0f8436607f13272f670b44cc50a28c93e9594a9db7593300b0fca24ff9089c63c284eec802bd118b372856f054c20a94e508b91573fba8df13a22180d8ff6ad41e49c48ccfe25313d5bdb16f4ad872219c418db24580d7909172b04f44b241bd21e65b4b45b8e04163ed54fedaf97f5923b109f6fa8ce3d1531edd5c199fb787a4e0d0c991b91e24a028ff4dc62009c70fafe3bde3c5a0dffaab75b64217e68f7b11ae18dc5a4159e770830eae18baec3ea445d1e8597d50af1b3caf02f083a2d7de865c62f32da64b1c28da4f96474a1ab2825a3b385f998e80b00d03fb2b7bd151977cd4f1a61d2cfbba1b70687fdffdca940b87bb773d081c667d428127eb7b9cef88fca7c01efc95abd2508773903ce938c80efebfb663d0087652810740dc92f185a3db80ff368ebe41ef6ae0fe52cf3f42def133507b52d011aaeeaaa3236d1776349b7c3c6a00f510eb653668d805633f919b645ab3419f9a54ae527f4470c1544c7f827fa4a4973bb6c4bd45a15aefb3642e36517ea4cbe6de8fe0b355812107b2a311b26fd26081ece3d3f414dc8f69e65d84a34008cdff42cf272271f3efcfde2a7c54139f301b60f4b6e298de66824715f5c182e1b36bda608359efb2f2adaba9c0c7d6280fbe0a0fd3681977acd74a57182bbc7e284123bdff77ea8f25fdf4fff11b8a0dd27942c592522a8f135afbd2d63bf3dd7abc198a36979d6f38075ce8b942c0455c123ba6d8f3b389da11bcc009f5ffaf759fe0c770592aaf3e00696ba32cbd45faef22285212c433f99ba9530f0dc6270fba94002c9a9b9fbebecf24faa81d9cd64faf898fa0047f8f086ba806f42bbbf5e312b0c745cffeb67fb74e6b492277f64ec2709d9a7a9d298c57c114071a02778018f3376c4f6b3b947b1ec9e12f61226dae34ab0bedc5879039a709c8be013566fcce094e8adf02a6d83a8bfb9a82e3c64f6dbb66fe39eba0d8c08cfbcab08362ef71791504c088c9bdb3363d548a932edbd1be382c26d8d6b09737ccba992ff13f7e2ec8e706c3f993d13cce5e4eb57682749baa4da6a905fa42c6478b1154d29a9386863aad06021db219042a9401a437dd420bc6b18e46cab92656bd63a56e5a91aaeb52a53b70e15e50d716daac97fb45909b6e32e53e9b5001a302e4735dd274161bcee2fcdd38ad3f515b24595e497514fc843f99e531e6b31fc36e5b9bfb61ee6f776ac2cdfdf945bea66da4a65886e7fcf719dae35186375dd92c2a14903682500b9477dfd9cd016917cdbd86a7835e14ff9aba62a7a3591708f3f34f7cd775cde964a0e2290b29f6bb677cfdec15ae676ac35b73f68b5d7f2d6c6643b7906365a0733027448232abe247e36acfd973a96b596d1372ecdec1cc7df5d276f15667bbdcce7ce2baa7fbdd677b216e56c69b1a4d02df51acdd76bcf1c35e87895376a8dfe508b8be08f0115e8570a24de6b1af0ef84ae5da6a205757c9a74827815f1106a0e59211c42097397ebc0a4682108dbd44929fb32e0010e21cf6ecc0910892d0dc1bd813c7a867b954fb3dde6bb625af4b1d303d5142a97031396fdd2172db3ffbd3e78236099684b46e863c8001ea96713cf9b20592b715f78a7e66c41c2261cc7867afe2b19c20fe5415db8210972d3588a3dc257c42574854cf02c0f46ed9bc0f5c6d003c6b1254a10146227aee3b39280a64892888b901abc7f652a8567fed2b864ae00a691e03684a9813d1f60d32d33817bec82a76bdcc204946da669c16e83177697795e37bcf32e87b15f97e89f8e3755b7975e4d285d8b5581b15d7c7db80cf0f58868e16532c1b57eed1466788d0a559b14d726c11d248fb5200f5ef8871001989ff69c1a91897adadab15e04c3e19ea8070e7c0332dd4031dd2a363c2cf018255bd99135a18e5c9efe1d6198b125afee566ef8efb9ffc1dbef4465c3be23bda66356140dbb0fdf937d404a5ddf5a68ea0e0431a4aa483ff1f1afe8b6b31e0a5c638ae5f9469ddfbc342c2ed89464dd7f5e8dd0618186107e4df7f4b3cd15aa8769d8555016e555dd932b587c22f8f10fd7c90669dbe84813bf066734f7c101845e78f7b333f1ce7c599600fdf7046b0e67df9e267df954f8582ad7caac821298b0087ab8f1b99d722dcdd58d23932fc5fa3149391d7d50f8c328a67a03e11b41c2743249aaa60338d8b58df4d2cc088c5dd56340f1cb7a5dec4d3b6b5bc200c1e08e5c9c4306a8b651d34d76da602d34cf3ae0f86c269ac82d9ec2721b67d078e40755da49af1a7711aa7004e76ec878df8e382db2ced457addc0c85ce8aceddd1f2b00d190381ec4be293bf64f41cbf44cd916ee334c419d0a54ec68e4c846f6e92c8fbaf4d38eb7a4d26b9fa9382e3bbb07c58e9aaaa13d72e4dceac10ac2851355fa45ac7df94bfab41d34d0f1a2bf392fe9a6eca5df5a61585dcc5f6082ae5b62602a3a839290f4b4dd41a6d04e184e870853f7feeb85c5770ffab0449147b904e31e3727b308c5ac621f4e723c0d45034f4875be5d7f0aef86d8f1ff05fb42c8338261d8aac08764e2c523616bb3c5df3ef2d4fb31117de4413f64e5820ea2444e97132dea6d4a36bef8d42f1911b72688f704f8cf8726ed8fe7a471167dad199282169466d25bfc300dd8d2158a438e09c8c16fabf51ef642a9966a25c8db413e632bcb178544bc4e5d97966658ae9fde64b6524138bad42e949b44b7742faee919b1aed3dcb2b78086692e7360109781c7116b57e6658a7f06e8f83a1af9fa96bfa8cc7017a02ccc031dfbf49d9425637ed41448ca40ac195da400f9267caa9c43d999edc553a79bc65297f79b713f97160c64306fb21bd84264a743e76ee2b4e8d5801dcac07cb8ea4866804d624b6b70a071232bab6aa1adcb66de0336216653d45f745aeaf018e94b98d2f96d2dde169bd013d576e69f9d914d49f9b9c7eed1e6268c400a0fef7f328d6ae3a913a08feaf9fe57cb2d6bfc4ffad8dc63a49d49be7538fcf82868ab18971b10ab3827c61acfe21120b94afecd607ddc6c8b8209b17a272dac19a9b2455b59f26716dc89725eca6a79522639af610596e9748575018d48c201439a29c0466ccd0e7ddbcc649257f981c8d6d22bcfbe1c24407af3e0f0ec866aabdc68a2dc808291b06122cb0d7c59cb1ca3c2a7f36fc5b5bbc763d6a5c7cb8f6fbc8377654c2b01e3c96c461b471f4cbe6598a198df4c93e3521572bbb1029d62a3184a60f1c5e3db9c92f8f75fdaa31c01128dd5f19e421a22e5a11242182b5a02fca891aca30624c34abac3ace6a33db147ba12eebbcf696a4b2fffbadb70594b3abf765443be0f25022462ec1bee01230b80282294671231adf5744bf9b9f149cb044badeb56454807114305323c14e1488ba53f0e3699eaf4dc48cba9a10f96c0da84f338226ecef37e4f3990d45da59be7302e12533c0b983d55e3df0a9aae57de7a7f8f8e6c533697167925270a9e34219f554961502a69cd3a244ab2e541f4f923a599d0624b5a88b00d9b35d15c164894ef24f598e038d684b853139e28bcff7f49a291a38c9628cac521b87f44f3609264df8c1a5c728098569334955f77443c5283b9834f9a8cd76ba30f079a53cc238dff225d31c86c63a7c4843040d8fcb600db89fdf72a760a70064fc2b1ba79d2cb87394ab7c7db02e62564f49c52fb93af5870b1c11e6a8d556db47ba3226e774afe6d8868859035fdff2f82deeaf87039ade9397ca5de30630100ece3be184cc580072525d8f7e1c291de4dfdf4dbfc9d3ae07b14410948775e74da044e1159d9969dff073878b3a6b54b63f1315b8d38030a0b00b5051508a0d7c8e0a0877ab32a40b5a98c37963ee6874410940d9742a2ecc661d6b1f3e6ea10801e8c50d0826eb8552249aa591de0aff6e6d05321788a7a9b18ed929e26d8eba209493abbaba52f04eae33178fb04c33fa4d16859994c5544dee2e0da6644066b0c76111a7c59e13526a282c5b7f542d37655e3cdb670c7c8490ee937fd686a2f4761c7c95afeeec8e4ecd816234f9d9f08f5b2aafb1e216542703da9c1789d4d66593134915d8d6f371c0833eca2108df7ab4cc42f85b4520ac9485d864781e33b99bbb179e61ac159db131b9b961863ce0f56000c028b11a87ae476325fb02674afc05eb46c30efb7d96b55240c6906a9fbcea8d8cc5130c7b781643d9a7b6375b43cb56f083310e75ce33deae352f9663fc536a4140c6033b4df63fbdf7022b8837556f5daf4ad31652245886567efb68c722280360c8e89a7b0e19135a6599f0032fb82491c7f28520b4be844d633e82b68101e01fd23fba5e83174fc9626ef378128b43b7e608da93de674c28beadc8c177c17a531c84cad09ca48f6bc4ad10bbc5328d1be06c71ab47c3308445ea0b2609763399174b98afdd55b38900b0a88d244c1b6cee98f69c15b5add2970fc8a2c40f307f13ce3c83e47197458247ebca0da49a065ad6fbb0ff67c290bbd417af5fb66c35972ef35c1946cd0c44e45ba5a3cf36e1c3204994066e8132234afe75a5598b96f246eb601e6a747a861d8faff70030954aa1c412465ed966f027e0033aa3a9e8b44df23fffdc602285c5e4334a8019c14094f04e696d13b97777256372a36bfa0dc80d57bd1f722eda4bb1ca9e36a491a9a4dd8dd950f7e071a6a04c23453a806c3a826a8c290c6ba7dc60415a92980094b0e9ea33158e29b74746985b65381d39ac874223a0aca3ba9fbc3e07ab76288683da45c89dd21a97c8e0c896c79fc0f3b242c73a04799b4e6e7f4dba55e1a6d7e47595cd7074ad24aed01f5283940b0d7083737a03aa31d017eb3f0d1ff0040a59a6726e3913fc79f58c4213b8dacd78f9ab6bed948b978233ac0a4692e138f5da3eff1f42c2ae2f618e704c8a52dec2f839022f94a03719b663987435c821af98881d874c9d4a6d0a7a5ad15cc31a6eb99b0759f51f91b3c5737a6a5e9b42f9903ea571eb2ebc97f8c6daef65f7d3ccbd3e19eff20a49f3e05c2bb9bc91e55a5108e2dc4c1be2803d77515e4d70b8087bdaf4c300c8ead7c8208598fd0fe27de467a1a256e5aec783dbb1da07ff8de506a71f8177564570d31e8b3b7fdb22a5961e71c49d35503a6087640f5ebf0f4a7d92a4ee411e5001fd623cac19ea30d576c3302998c9be7b2c077df7f8326ab28e911818868accc290d95b501307852ab6bfc3629927af14a9792b33509b47ac4af08683507903069f4fbd00768d4f069fbcd5d03a5e6cee5c97213092c51893c6a5bbd0e7b512e64bde6560542fc6108c23fb93a6c62ba80312ea171185e3650320085d1e4a01a2503824a885e9fee4bdabb1fbd477b9c86a987ec285c6e801308ad621a73fd5cf51d6f2bb768724231e95f95898ab3beda7b525f4aba3654e1742efd3e770ca699c4688de9fb769243edead147b150bef633822904274851b6ae5af5eeb584f0ebbd3358a7bdfc750a6d4ca745d5fb87485c63d9b408030a69b384f5f275558cff0c1947ede6ff982be805bb1b11774346dc97f63191fba6152763ab8b5a26ef258c318f4ee17eee7f8339eacff6e3dcc83d9fcade0530f1aefbdc6b69934c36f39a4303d2f54f8c6d84239e61df18be7b68dcbe36d1b4995f5cafc1662aed2025736e718889f46c8ccd1a6c6c30a46536dd75c735372eecbbf2b73d0a64403352f14703aa95f2241deae2571dd74a85ac188aab9e7f681a4dc9c55dedefd8e8b8846377c7ab6f356ee2302aaf50d5baa58b09037d62dc2a785ae923a9dec464198e42c717087a21e510fd10c8b23366f85c4bf5c5a78895492b40117fcf7e988cea61560c16fed0219ccc6e7295158b7276dba04159a377ff701b80f325bda89c0890e6871b2adb41d1bf25f42e6b286386d8565af8d58f4ab55771cb26132f54561cf5ab37bb4edb661987182fdb96ef77c147a7c58ab1bd4a8e12dffc23b36df60c51096e3dce95bc6c211a278e3f7dd3e96e0747c8ab988bb716c764b7518fbdccc631feef2e0ff7637cb5c038ceec3b79de0ef20c095ca6362c8f91e5ca0a65d6360e9d3c5f307f26c037a8a760fd269f63cc996fd27c85340c87a3897702f9eb21725a73a0af31eb4a7c1e2ad79dbb40b3c69c07274a98cfea29ee40c6d3e68717ed8b0a43d377d91253697ce1d8a9c4bf42e104a14f2875039a735b5c825ee9202d192431c1517a89bcb483088e33aeb9264884f8aa09c639d589f09d7b373c2f0cc4bf1fe28f0462faa9fb4b80515b7a701569459cc7fb5be07133cd89ea2a5cd5d8db703a51b51bc07634ec08d4d856690d3edb93de62a6f1c847822b53083c0ea26caca70c2fcf008d34843410b852fd19e4bf9e462803f33a676e9ab008b2d7015c22e5ab6d0e4a7cfb3075f7a7c074136207211230bfea27f7785be1b1ab8774648b071bdc4619414730bc03bf8884af5afc64e52e10e74d2896271972ba56ca29776aec36e2ea24421762646ab33ea267de368fc93e1ee3ee3e8186c7ad260ac3f170f758bfe110c3bf9f41dda6d5d5e0fd048d79e82b6fecc710a0b20d5de84e355534f079ccfc1d4acbc2c53fb3afba028183a362c25bb050d7da2638f58361e0fd1e44816147374a174a5dbd8b67e010fa3146bc9aa3b2c78b68030840af91503315a31b5da25bb7c658eeb9cc0374dbb268fe9dbbf67967c3da745e846de79e2b7dcea51956b0a2ebb77329fe6fb008bb2ca755c5711045b8f0521e0be348a6b8f76388b5ff0ae12a73ba35d2a36509347729a21f179600eedbae7360138aa3e0391bc6d66c0c17979e96ed697ef53e09f256a72b3db7cbb84303a994073054b53d2a0a365a66001ddd7b130f017d5c42d3a2a1a578364005fe11a465ee7a0703a6ebe40529437e43da87f685fc8bcfb17bcc9c4c7d88eca22522ef863362b45215e64df039fbeb02ff223ec44edf77c793686e684081aeef2c1df69441fe76fc0e8dd8240be5542563e7684affad95e81ff0eb2e53a96aea7e53392666be11771d46f77301d86a486de8c852fc01eba2365a6ddb9e7466f1a76f94f7708eb2c35e86e1ded211b0e6d3a6198e0027eb1c8aa01cda15f1b1f31449ec85a0aecd5fd98451857d12cc5aebe12d7dc43a8e70512a37a422c79cd742354dbafe21babd6e2fee23d91943cac23f364bc2d9e03030c0b0e56c78db3b65d783c4d5d84cfeedb11d734b861c50952701c42c1fe74a3ea81138d7881080626edfde63b2ec37dd567a916b9985c7cfb94ac0a74dfce0c92aad37a134c67c7a98bef009939543f541fceeb369f382f5d3a714b3ab7a0274d77f2b15a3c0596bbe558b203b99cd4627a9ac45234e7bb129beb46fbc36a002fb092a48846554a5046409a6d340136657b532f2a44b4756ed5bec6fe81125f34f840bed808825bfbb0f66b92a54ce76662894d51d35704227e01a5ad1e7709771c66f409227b601b9d794e0addfbc477724dbfd8bee68b81a5a054432208c623c04973433ce3f75b83a81928807eaa3e6769822735cc0d68513687e95f31ad5e374643f46ecd320511dd941dd4d9e3a7be3b0a44e51b36949751d894ba9a75f7bffb835b364da9c48c843d5f2b3d915be22e3f50e80825a0b36cbccda931762b9fa1c89007546247cd95a6225a1bb5c14e71316907eba1318d4d5e23c686952d6e875fbb0ff990c64664c23c8baa39def25842690b54b6ecc538ebf4684fbe303c37add5a58f0f3dde692238cc9f1f278992743e405106ec4e00933cdd799a1a1666671bce14e2e0a0e16e47c1fdef59dddf545ac89efa686cf3065e8ce32d47e3599f50a21a351f07085116a77f2343848e97e646485ec9ddfb1ff79a6269b8ed9bda","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
