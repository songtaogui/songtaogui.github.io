<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e525d4700c4e86cd2139389c61ea5a52596c09e63ba3e8aa1b07c5c21b9cc1062689f08b612ce173734f4127006c6b0d783f9e592cd0ab0a52e11677cc77536fa256f513da10d5b1586746490a84fe68b9976e622b797ba81cd3057afc0e78c65743881c1a6959aa3297c257786581edd0b255229a5dcfa4e84c8745a0c1774dff33a91103ba6757e9b5bb3fbb7816a042fad0f2bf701ec85517befd94b710347473ea740bb3e1372326b2d9cf9d18a82c452d12f3e7e0abdb88f9ce2878d2379b6be86669b247390b66b77e00277239a13c0692dfa1581d8b1cb441cbbbd53bdd3fffe803a27b26ea6e5710309c9c24c701189f7bf3cbc231efff9533e493deaae38de6954a42e0231bb01ccbb22b1a603bdf48b61ede5b2d7aa249a1c3cdad283695bd5c31b25c7dad68abaaf7dedf97b2da1f23cc97cfb68b5eda162896ddbe0cf75efd20540cefc9652684989f8eba14f224b7702552f361a44ad8bc56e6d96506b0ed4601017e6129f267369d2afc0a17c4674c25204f4677c198bfdc5a4cdd52554d9838f231425cc87fbab08c63a4a7172ea5723f13289cbececddc7e960a1519ada53e40ba1943c049d675a926f6f52487dfe43a92b9262a76042329c1b8e6d61c7adc4301074fb6b32164ae0d58026a823e79f6d37b22cf7c4595a4eb0b4c68ba4d92d8914cbfdbaf5de2a2861c0ceeb6cfeef315a1106b084b0fb947bb861cab91b374f5e5c928a3cdf8dc2d2ec240000060dad419959171e0da59b23855fa0a610e650f3c9d8e5df5da5d3e73f8201d0ecf3c045f2f561b11b6a755b789fbb33ff0cf8b7b828b9ab1acf0789dfe0848d0f9960b98bb755bad1812920e33afb69f9c151365e18751c25a1cceff4620f8f6ffca53cdc8d4bd1defd2fb3ed006f7b101b2df3c58ca0826d7b69d9dc8d636b5073b4e5873c8e7f1d5ccc44bfc8bc3a20aedbfd17431307d84a3c856587e68f9a9191b7b590e5b587356d2b7c99b63f2d3ae8f4b70042c3d26712c210ce1fdd2dd0f5aaa8b3bcfe81eb2824ee2157cfecb019eac5ba63c99baba614191068cb5e8fd7216d795ec960cf6fa119f5dc7519d071b6bb9f2e0522ff4915a381b37a31f66e27532cb4c89764687318dc0ccc59dec2f27d26ef7634e1723f8a4f2cd8b1d5dc28ea7a6c38b7cdd71c3191797a5426b5f5c24adda4a8775419b39ddbc4cda9ec02a9d747b066fb6294fc75c61967145b084df90a0b02e5d8153abaa9b4d823f31a8001a4a7d872d1b606bd76a26ca336380d7cbc156054b9f4d3a15aafd2aa541289060e72a26d5545ade2da7952f9f112faad8a672bb349d52301632b4650da7f8ba08c264b5aa1f923d3c715ec09fa7ef43f7d01e0a63b2141d2861010ac2c97eeb0b7844c27740f75a978366dd6c9300a3e08132e27b64eac635e863074e991b91b1853d5b51c36c7bc364e8c800fcb1e4b71f3a0c43dcbe37aee6719f213cef3f4b693e6b769685f0c20d50aeb87a565529dba0012cd5a58f32658af7a687977d4ff528029f0ac33b0102f979d815779fe00506ff03026f2a572f276b12252cd2d4cf358eeb9ca6e25567159b415e185c099aaaa0b8bd2b44b5fe516279b8247ea9500cd54afb0213d8759310cab8bb72704a127f66c5f17b6afe128ed191215869a871131f14eecd1c9f6c6976f8b9ef2c21c6d8444cf927bc2f28736634b3fe945771054c8ee672c320fcbb6d8906da929989d9c2d08e14fb9befc1907c139176a30c1d07d7ddf6ef503287e5a14ce3751ddc6374b7d6c1d70394b6b5efdd18b8250efed97e6d2a6e9f8aaf00eba0863dc645487abab7d1329c10d1730a113060b27fae9b645a05c33006d5fb9c3d640deff2451140fc32b0fd630bb2824e07cd28758f56e1eb9f8b52ae0ceaf502a5de2a2bf160c23bec62e15b7be1aef09afe454f59d9e50d4faaaf977f2d34a9145532e605495ca1544eaad0250dd57de3d4a51624a8b41491fde2e7cc31648dea8eba3a916009fbdab80ed2121b8c5b7cab2921a66fda747f1500347f67f856d009d928c48eadf5a224d52fca4482e04c907293c923b8e191642040be91ce91aa30886bd335a0117f1bd57c3e1706a93afdfff5e6b69fd00406a0849e169bd5c2e23b9434f953c67473eb1bc401516e70534ec91446e9c6177d97f17247e3741413d766652efbf0c55e88c2445a4478fcf6d63054754a9882a04ff65e07fe118a6840924ae301e90551d05bf5f048502775a02c8c8b8d8a035ad9780af182aef1d56eab49f1e95af86232b9a8295e19ad243dbb7e828e1912a54f1a93b858027f0bcec0396a88f05818c233b807d16556211a3cfbf445da7c1127bd9d06461c0a1e727aefb3913cf2a88605e4cc37026025d66b7c6aa62d3d8eba9a940c785e888983d812b20d6ac58d4de884682d029e18b35193342405e5466445e7646ba3fd63c8452829e0d32b25db316287021ef2579ee82470eb561f5421268674042dd82a5e8e449a30fb3546f854fe63be8ca4a17ec236dc02baee0cd94816aa520f578e70c21f35e12ca0b5da64541eb42506eb40543caefa4bdca6b69e45aa076dccd4e259dee65cab912e6c6c6c8a3647721cdb29f65fe8154dd5903f940fa7aafe33deafa183770aac01363369be1af65f0d3cb67969c11eab89508f119b5366654b23017a66aa3c12d9b7e2bad329eed917301281e71539380695a840cfc55e5f4726f8fe44c6ffbfdc12f9652be05d5b67aae9325fa2965ca6fed8d55f50324c786aade4d024e89ce129b9cffe0aa6333fa0995f6e6cbe3718154fc10ad380c84f76ae1c5e0ba8420b562064ecf5c652db9fcc65bcb96417698d5e20835f68c88c3712bd9ae4ca573d9b762b9e1d180ac59dd90fee79e533880bc59ae4bc92de405ac282d1ae428e0f3c8bc49b77f76a65b7386456d76f0a3671404251625e39a7d93d81d65bc53f853f028279e43af70810ce3bd02f535b7cd2ae6e036fd95d7b11efed295dbce55dc63a2c542b66aea6555b61a27e3a42fba4cf587f252a085f9eb563d794fe71cde2b091987e72bd561bbdf6f3254d9943f44aa7757ca5e4e3ea949001dd48e893a7e443b6ee9c7506f58f1614ab78ff7922d02a5d0c0539186ffb166b2aa3d9af9c2dd35e31a80dbabd33097b83572d3ba645d72be87e7fc542d8d510f50968b8d10ef2dab6e04baae195742e64991e60057a85bb32bcdea3724403ba290268b920808c96b8166849b05b60f274a5c6f08a64564cdc9d5ec9be6bb96cdd705722a0274e8951cb0f8a513880a7b37b7d5a1856c43ed8bd1eb60dfa08d3152f71d68b1a771a9ef5f07f81f1ac2e1cb5e66a6cc0332885e43d47bbc397d1937c21f303c29fd5746fa99b5d24a7f8348cb8069018d5a7d14c4656779533f6340fde87667ca4f57e4a46056f67796f2bcf7e47887b4fa9691f4e699e48c1040483cae925c49f2f13aef6fc00b3c11934098077902766ff75a3598bc5a770dec6ec62c8027ef46e68b0b138956e546fc1f7b3dd2e56faecef47b07e93f764a97e8c76d2c5f408e93dd71bbf3098a7cf4ede30e0d3568bb66767ed85223ced63cea7b52fc072968c311539d2c34d0859e2b758a51bb6ed6df7563229cda9e97b8de455ba5ad4f46c90001e407cbec9d76d622f6bd75984451d6deed1f4b3d6816acc09ca882921143a23a9cad576645f66a640dd51ba314a6de64590bc5f5e466a3fc16715710dd66cc388bae0449f4a5b499f5dd74ca3b9710b131c3b51852c6d4529663477a08d42e178dd0425814608b77cc5af412a8d91bf17b738263b7f4d0e66c0d4b17b098dfe78c89aa7cb91c4407e1784783c93c7181996496d4b62e9e7c8f88e9e26d29c0d4a06fec28f40566b196bdafa5cad8c9035f9af108d8c90ebf76dcdb4c69c20838d9c377fe168f32c3d19a05c3b3532e9a4c0037d225b0e4a1ecd301e9772de106c0ccb330862a57e6dd913ace65c9dbcb2acd068ee19d71620441c3a406e12c2d80a492b2075f721bb1fe531898e162e7e33b63c0cc707e591f379057972a878d0a8df7e47e773f3286695f703c132537f5be5ac0057276d001fa4192e086a3277d2f52b70f72adbf8822864fedef84d8f273d774fa873f33a440440fa777a6fe135f816702692d2a479afc1ee192a0f177aa883a121630b6237bddbee6939b6826c1a96f432b4a289d9982715446b1027255d586c09964447b09d5f11cd3caa5d29b5da89135a945a2eef6bc5718bebb1439e2d7a6a4ec031296a5a166fd298ab98b2afd2b875121cf4b658d3b0faab43b6f2c7d019e95894d956a8e854187fa48ad6a03a84bb30303a5162c6acb45d606360c1d1a12b0c2eee0e300769ed813a5c1fc1bfd74d80078daabe77e00476b6090c382291ffc6a260e03cc65a14e5b4f9eeb9f432bbd36018a20a17472a466cfffcd3cbe6a7ee3ccf915932f32508f392cdda8d9615e8f7f0df1dc858ed001b3505ca9e5696a275d4e334f6b8a8f102b5181327902be52af069bef74e5704e5a756ad08f99cc41fbba316295e9c5ffd87a0f0893b84e8c8b76c37c89ad3e807685bc9a4f1456e486943e555b270ee04a20cb314b2b83232052eabf9e30d2f37b7ce0a258bac2f7008133dee367071a71bee1eeb0b1f638ec02beb854b693b7af8004b59497c28287726ef119a3dad388505efe24699661979ecb12b7118f49fd12fdfc45cd53fff7300553a64a906304b2d477c6905abdfc73eaee7e2ef53d01dc57d0412813ded5442007df60375cf8fcfa4f6e6e52057f7013d0c4dba4e603b79d0756cc96defd8a8210065df1e3635b007b7a2be082ae1d4e20e16384d4a607c1e5030c522809484546561f041b9072e88917076f90d726038372d05368b27dc916f5caf7d6c1178c129ed104f6fc4ccc186bfc6e6ed07a1b41b8a791eb822e16eacfa6064b23761169937256a708872ed48c384b8fe6440041f5d2ace86403b4e0df1a01b13a575cce62b92745fd6f2f6405f407591f154f14ba5c057b4fa8a31f8d5d597f29fd7d0c03f6819fa39402c8c4ce183505d34c7e756514e6c5988586ab10af40c97637323dbdcf36fb125d5f4f4664b8387329a67c102885e0e4e2fe4a9850143fe6ba10c6b9fc81b9f3243fe1988c14de7d1f16c497c4f238c05a4a8743df8c4b697cb2f5ecea4fd04d7d7be97a265d3c2e5046ef97ede93568f3917c690a5a55459c8a59b30d9f0131aeef21f996d38af83d2aa9942e323a01e9aedb4ec7a41f62638c6477570b35b98c930f8fb9c019a82eda770101655d5979e3bf8cc17f6c3fe550f3ba122d4ea78b6e289986eee20d689d178fbcf945562e51234b7372571db86185b33c1af2f562f921dab78ba4ccf58091736b2d28e6afef0b716f8a944ecddb27a0b89f5f2f57141e6eb06c70154c7408e7c741eafd796204bb4b658df6e167ca7939bf25a4cf611820107a259f397d819d061d36153f9d5e04adb6212f588cd6711f1f3c42d50fc347c9c7d6238d9b267e3bcb0befd7153c2c4ac8812e723326a989914b58b28c4ccdbf6934bac7a3801e0abeef7a00d84a70983b409573a4763308f9c8ee859d67c4bc2dc378c1d0b81800823544109e87492a58d70c98e1f5b11f5421a34ecc4cf42e4bf104d02308ed028b1ac3f20ea45c22fce42f17ae6277c50f9d34f2d5a707823f6d03e91383f63ba7982a558f9cbe3dfa2a07af9c479ee7c0c8cdc705d080e3a96f5aaee1b69320e4937d23f2de62bc6356a677165f23de9261ef3591abf04b1652d4cb8ab0f14bed77d072401c6c2996f09e43220f2d64e2a0e5c443f7480c2825e8f73b24eddb5af4d1543833d69d153cf06948a1fe8129b8c705657eeb9565a81408c4b3362ddffc6265fdceffdd5cd5c5071380b5bcf5e88b55d4ff2e38421d486f93a7c4079c82a2e82a43afd7f94a6f21812b223be55c6863ec3835917ba8940f0fcd79a959cd5cf8987e653683bdacce29356fe664f3ab071d44a5c9d266e34da124a8a5591da73cd6dc1c234ef9a69d211b6c8c90bb720cbb29ea639d87d8d3ff6c80468a99ab6d79959cd73369ddf5d5fe6c805129b11dff2f4f35cdcd2931cf4ceb4e54db8dda860148c6033b137a95b6146b4c97391cb7d21f05e5afa85213fcb4c05560ee330664cf654b1b8060c1ed012204fbadcc1aa10c82f1a363428527c7163acfbae1ebcc08018ca77c18ccc3ea6526f528da76c309bebfcc43035677d37b1f08bda9a556b977945d783f6fc1e39e700948d623fb2620e1b706132c90ce986d99f3a3096f0ab3d1799b4d96957f5df9300e8943aa9e1c169f5a884d6b6a397f99954afe62ca1ab699c6d5f85191a26f7ae4052685e816fe2cf9897079ab884a8d00a03a11da9a8c91ae3a321bf906e83ba017b95ccca9b762aa09b570303fc883b50c367b0e558c7791dfeb50e8020f8aa8c583530ab1244c047e206652a08a9280e77ec643088d3df302beed1aa6a96f5800a8b065252f1c522217e2801219adec57253de1508cc9ec0d58fbcc783d68476c723dc6d8c7e30e38362acd6deeda341afc73853c0d5465b51e70d4b14b765d00a82d242ca835f6f0c525a01e9ba3257de73b93b103d6cc15cbf1250ce0028978e8e3f9ea7be904b78bad8419faa770b5f4b1e787fb63480fbc52295ba5226424f9d0e9a5a438ccb76fe4978e6fcfc36e80be6796726e992c6f5f04abb90a42661a419371af53dc28a8af177991b42fb12e3829dddf2e46932fd1abe533f5bb58bf31eb9d77569a3c15d1006dc8c473bbcd4a45a1566e87284a84e76f7524b1cc2ac2c91e27406aee861250ff5c7352cdb4461561a33895819673e239fd08b7efaf42fdde7bdf234f0d9b73e627658a2c7287ee08333910e348908e3a96b2f2d95365417bd7c33ccf81ae8032abad75be01e409a4c8b6943cc8d58fbe93bc6fd51dd3e8769efed87003e558809c5fc404ee5966d7f10dcf1a9211d78dd8c99f8c5373d867c4f45d87c7972ca40e69ea03326410fc185aa4c2246ca7c4d26cf4bef230ad8035c0ab824e224bdcc64a7eb17b7a7279e87a591406d46c0705d2148a80ab1a271c2fe3f8c62d81b815250582ddf9419b8bcfad9f4540d25b18dcd660bbc745ab28bb019e81269f8d7bb6b933bfe8d52528461505bb52a0c82b2b3baad606debeadb92216fba8bf795c9deed0cc4792ecfb01d8e329fe2f688c951f8be8e6ffda7703af059364a93c9f5243f9df9be4b27c65deb503fe885013374ed64eebe38bf021176ce813311fbed59bc7a818700a30d6afc2a47351e1d4a9cfd3517148d47e8e89320d55f3aa1ce2cdf66efa69c8f5f713e10100657a4c682ee5a6bf5af429056f6a396059373a6b6e3f0f211fc887ec0c3c1838dffa8501110525b6e3ef029f43cdf8fe61f0f7a14e8a20548fe144d76da57294fa6bb127fe3f7ed7a1028af12d8cdf07eb89423c2c67035b4ffea4cc30a77b957ebd99d89acdce8cf1fad1a0578de4f9287d15deff0abc3a3435eadc7e635e894d864c017f65530e40c2fa86c03e774e8c8c3d6dc4b4d992d38a52f5ba9885b284bab008f45eaf62afb5cd6025bc5a56a7b9bf83db73ef633b19ff18b29ff382f854e7976cd7eac0c69d4413e88010a973bb7c08afca934c0c93f7930fb5a7ac2984b9d4dd2586bb1d297850cd0849b983675b6e014aa48befa99319dfadceda15802644d17f48657af5503a2519d4f1f16113b3ef4522e73df623d7d4b7deaa8c7e6d5ff5122ad2a117396ee39d42ad9177533de7b73c10e68dac139b0c986068e7fca930b19cb38bef8e8f4d9d764f09c2c4161609ea7976e570804146c05336e8c4317b63408f0609910e81eb4e2e7c3d80b91b3d850c5d47c8ff48887c691d572920a183c45a92f5282435ebe1570f25e8bc992402567be87b61f06c100cb2911cdac85265c5d05f9f7d57e210cc425cabc48fd21ea117b69c1d107d01320e73e90f6d06ec724fb3f49f57637f0a2b4e6c6114f62845e30de91c6ba71a788dbcadf736b5cce0db379d1cf98bb17c297eabef243908493fa1788c5a794e713bc17a83f10fe34a26d9dd9fd5ae89354eb57e5b9d6c941d0b72054255da4159a60e33a899c57c8d6ca4ed786c8d779135d7273aaa96d5aa5d1bc3f1c0cd01ecf1b34a2436a8fb2b74aa2e740bb25b79dcd6fa1f8995193d995b527493f3ec5c10028ffd883f74dc1997817fc5e5cf29544ebf51af9d210b44706fecf84fbffd4ee866a00c0292b599a93a49acff0c24bcf79622efef3d557823b546d99862d2f8de951e8a17e720d08851ff903fc89595c1473bd30d289cf051163ec3b1d5a66c53b6a8dcf905a9c0e58710a19274403bcbd7dff989f7f50d82988a52321a4621392f90bf91cfa24378a1b0a2361799919dd40f4178190585ddb900d2cff1a32095f4f41c18f2261a175d2b6fbf6e848a37cbf37f5c90892aa5b75b660e536557e0c1a980c2ec50c0db12c859311f9074216a6a53851e777cf61338557649e373d7e46259e617bbdc240432b7c4a598a00420ac4c4276344f9a5c4e2764ec63af734b89c89d4dc3c9fe1fe2ba5d5294f6ad8cad607da55bf0b2847b6f5cd16e01215e8754bfa1cbe470654d5e6cb9a314fa3fa92b339721a719b8384fa2ff6010d9298a91e0ad1b24f51aa4618c418819d37e087a8c36d1067a5dcc451c4b18df65228d458e8cd7a31b5f5eadf75844bafd724f9136b1d339411026f9885c07a2c1a68caeac9d6073532d9e0eaa0d63df2076b801c75115ac6b56dec825dde3a6eb89756cfb01d057cabe73a6fd1b9d8d825a5be4e203cc426a1a903df2685333c6a20918b2fede2cd9b291d9738dd23b9f21ba37827a89e171a1f80f60c1acd4040f00d65916062915a713098cb227df29a8e75e64079ef07aa99afec74750df939639d65dc09222bf2fd84c605ab841db4bf0ae66de6a4a0cc5055a4c18d2d98d98d13279b3fb51fa9115cca7a7d8e5e5bcdccdc771327c93e63e431ef389c242d621aaa67586a49f1cd9697df28a861fb3ad4d7681aff87fd42510293be3a5996d0c14b357f57373cc49305ffa87314e6be52e4e79405188fb985a17ea9d5d36a885f022123569e4865f6aef529467ba303cb0ff9d3178a34491dd3bb857ca70f6bb143f4937763aba4fcc120c4f8b0cb15a802944b85274d157c01901a652f2a605ca300adaffb709064dff5d3b81c130d462c11b86886c56d3b489501a12a459f67b81695dc2b1aed65cdb60026f9500762b209454a55032ed5e646d441bac36d4170912d0aa3526cb1990f07d5df6c1beb83444b9a0d256fc2aba79c5fd5b32259303ce59eed40f56aa7784664926ed005e67dd8d5a31207402abc140c6b30d84ea9cbe30171ab5061cc43ffbe321b1563327afbc628eeab03d04e52f42c4acd80343c1a9cd379beb8fa4c74e683a091f6b7388befb9c26224b70b8239024714288ac5132a99bf65570a34d9156ee429a2240ae04205c4cadef5830468c754dbcae9f8d915cb138b49f0425977ae4780f8ec73c6fe7fbebde52dd222d68639b3684fa973f52db3de185f1c55ebd6300a0887df37921ec8201f8f27112576e1a85eab8d40ec539b7d7ee9db05a71e40e6aab63855f4940a6b9b839593c888c0076797841c2e73a749269ad6fb2926faa3385a0d3b4dcff21bbd966ac041bf433611de6858bc6eeaa6935db8138808689454684c72be1a8cfb1f84a03e051f4cc10390373dec28a6640f36dea055339d1da90ae28c55be8a07b0cafbc46250c9837f0ee4abe4b9c127760985dffaa0efcbf6dfaa19189f9feebcad9e11266b5b9e609f7f378700d100414bb16bf8db59f10e7685a76a7e6e6cbb834fe5b6f5cba178058a3b97863ff76e061cc63fe58192712a9b47b1113f66d3063070a82684d7e68211c01ff9ba8d27119defb3b83a46806861d1fa57f42cb9c56e91c13ab811ae408f4c64ba24eed48af5462c251cd65cae028ad625b096e9e14ecf34ed463a5ba898fbd3fffd0c11f35b7581b2ff3d555585f8cbe5f87b660e28e99ed6279b64f0df8b8653c8c2b67cb6e73526332aa61e54c4671d1c2468462049cb24bc260318841578167e006f6c59a5d64e893e68fd0281ed067a06ccbfd6c78b64fee521a47afe793d5fea24787983e0365c027df265be71259f4bd9866f03b6851b4d4f8a40f01499be7905dfe3e23ccf0d74548635693b7bf0bef9164a8e2439dc1f07deabefde3d00ac8118eb802a9ad36bc37612713686fccebd46995f63f3f8292b21b82d917425358e9ac4e02efbed0e994d4f9ebfe6aa0d3a1e15cb3fdbcd2b1726baf342d06710be47b31a66c9d1feee7713e7c56b941873085517d3b564e7ffd49b9f4d016e5fbf8965b63b4633300d77747e571e81f50554756fd9f021dae451df8f11de9adb233bcebfd3b70066e56885b5e99b070fb0b453577faf1c8209b7a4e87f1fc7be3edd14f65980eeeead3e6bdeefad7e1aaa5e3cbfe5f9e1d9dcee7d01e7ce6799575873f6b454abc5a386cfd78da159a74e1b3723af8ee212aa46337a9f92d99ff8e23c75d30586aec405c0176e7b458824b47ac65ac661e7684ddb360fe8015f28be30db8409cbe84a9bfec30630d889f7490fa1a424489518b0a8dcadb269801cb70ecfcdd62741459df5a170d5890547f77327e6c2cf6948dacb7f7999d535689880f373a4667122a11fb8e4c64da7eccfc0cd949faa898c48c6a2256b62e131fd73f0bb887bed92918b4c1cecd1f2ee9b5afc6c6fc15256601ac57a907887698002dc8a0717e411236891025ae1124d209955b511ea2a36b00150c865f52dad3138171768ab76bca823e9337d6958a6e935cc41fc88c16b207b7059572b4875c10fa5e9f6bee26efc9b167e62b55c69dca93785a6791b48463bcb133412bc559d1512336fbe93b025fc0e92a1e04678095e00397d9eec7ff77c1d7529d436f65f1bb41c9e1e7b83ad556c8a8ca560059eb40060e7d303e22c4ec264a46284be8a1353701b53bf83b2d0a9175f6b006fba15e573fab555a4d72b5b9c6456cef60c3b6b6ab91ff94638c876bfb4a042c6556d0f14442e97719d11a3c347ad6339cacd5c357bb82fa51d3584f55696b309ec90ad38e7568c2b6cb44bc5f02b6795d3f0a034b7cc465ed51bc965aeb6c36d75ffc1a97b5675c023992008aad179724c609001e09058c83c2bb2d98be716065170b8ca5f4786202996f88a924b7fb44b0264fcd7aef9074a339d305cf3aaee6d75e67d21b455ad5101a5c7b2682bfb6f9271a241892c7d2fc775543869e1d6af166f88fe986a898884113c55ad0865033e6667b56a903ec3eb4e684a2b8ba4f1c82de0bc1809887f93acda0ef2d117a3f94453343ffba0278f35c27dc787528890f5c77e3ca3f0cee449e36dc88fdcdd6fb41ff5f226f00095239da6e1fe7fa946b9e4be6b6d3ae0156980d9104bc667bdb5f8d8316456d23759b42abfce13a83fd1a19ed1d5eb57be73e5dcce44f4e4952f25b89213ac856b7925fbb50840a3dcd9f6ab06231e0569e0d316c3ef16f972b57e1d9d13d882ec3f51bc99964e95a8d37b7f8795974733269e9bb36569ba1c21759694e11f47d1a46b003442dec0ba193df7dcb123ba6ee94e4b8e6b15e3c15037b4c6f7593b88ba94ad0c63193e26fdb57a7683b83203f9a544df1e61e95d13a1fd04c3bbfe31678e6bc92bf48d828d1f1c2007b01a25f20b0db33c5b7a9f67abbea4ec8378ab8f06b8bafdfe268718d7b50111c16d282f411580f7ef57352fd9e1bf2027372dd26e80d99ae060a35543a3b13c48ba21dae4ba90ea77c070a253365e1b1c260ee649635546a50e73df76a0a0fdab6c867a65f8e10348db698c72c9b08c5cb68cc852e9051d17a9a078e13df8cfd930fa547e097348560b8aacfb9ea30102990e73fd1587c52a96b6cede9259cef9d3935067fa55d217fa41d75ad046550f3169a12b9767680f62ce8a8fa1c75558fd4e1f0371a39658cec9af9b7de58743ecc5909036ae65c3cfb2e90b1f7b2fe8f9aa9826acdcf8626ce36ff7131bdbfac498e222c423641b9f070a2ad1cd9a198f493d29419c81fbdf006fbe085b0b06f1c9149b1d714833ef0e7ef3cecaf5326a7f458a2a11bb21c714c1f73e6cf37eaaf282748442cb6e93a502fc269f25a7d638535b63e2c1a26500ed87f35bdafe413f12b5f0983f910b9bc6e874aa3566359a42fa84505ab1fb667ee584eb9ac32f8593328d1f554ca0e57be54c53965eef8b9990fa0b8e007e3e9d94b0ad992288f5bfdec5cfc8d945afdb380c42660e13cab0ad13ecc595c8b0fed0b3ee34cd654c9ee61784920fb4393a9adae76819f391ec391cb6525e7fedf6a40d64649d5d5ab86c19dda16e2d8c48e32b7908f59a9228309e66de32004cb1991d7a87fae1299eded5e7aa004d269e8edfadb7abf7180c2bb0f4cbe558c6466957dd0c56e3b61c9dcdb3d3432bcc451e30d9173309511a4499329013e2c6b11e1ed8b5988f3962b643e7361740871f45d8f0bd73050feee60ba78bd78711b4474d0976f3308cda5f8d65e46a9f1e3d98cfa7f0db9751ececb4a4fb1a46400af5ad400a6918652c82a8a05f1712183f3f8cd0596001d3e8e7902f4dca0035f10d8fef2f75c78966a72c83d1ce4a301752b62e52ef46c99c203c075def20f5a2817096feeb3801ee00624b5ac5f68e729b429a4894bc030b8bd8f61799ab3abc26f643b68756d656abe62d19456c540da23cac8c1181f82a472b7f6cc0ff05a4534063cbd9b0072b8c21c9c2727b197e550791176ea656d38db55357d27ced770d035aadeee5bacda130349431339f1244a1c918e7425d7f6dca48dc3aaab3dc9cec5fa997e5abfbf7bf94f3b43e01bdbabe5dc6e2d1b89ea59c463b294f0b8735696cbc22921503f6b864e6ebcabacea61a350e10d02fc8b0c54ce5cb81b64d5ce8a25ece9983176ef19e0d41f538cf798c7b5b6abea2d38e14dd1d2077e2613925c3f13d59a12e055422a19b6d255cdbeb0683db2e1326bc709de0acdaf44f9a28924d890e859fd438c6a3a2ba263733dd1f758d2ba499ef61f2bfa8c38bc966269f72a17141a2ad07f5eca6ce75b830a25613204a0a1ff6643a87e847d412327bc46527022aacececde7adf8cb8455e6ba70065de3b78b632e1b52b926ca34c1bd8bad3c0ca9760e50cc1019991df8caa4fdbcef7144bb30eef51ebe0f3806e8c11198e6a51cf136ac06426feee66ab60ec33eee13a76076303fea72ae2f91048a49e1f40a76af901bfab1dd3b31b16b58e4eb2a423d498a3ddc1a1e3bab278067a3edc5052232a5fd33bf2efcdf0e055cbf79725b3d69371270d98820a84d39d814e22d103b01f2877bf2ab2e594f3efd46ef512473c1578f5810c57e5315a50c9d211c8b65c47e5faf802021a04cb0453191d5b18b5cfae52dbf505e08fcc249712189646cae46c2f6a59241e47108f766af1965221920da6e98a593987e5fbae4d073fd0ea9b4a2c36b8f802925eaa8e535d4f6881bafd079af84f2e7bbde75d33d1b4af4ff628e85651b1215d3d35321c28abe5f778b89188a940e59090111bfcebe2f8fa51ee8bed0ca8b48c751de7c3914d1e017385566a42d059035eded7105d5e19f9d290fc145990ea0fcbf6c0beb14107641f947d57c186faf259a5c4a90c87bfe1ab5f31214c9426fd83f00a2690db162de1ae94599105a14658f77a9531031dea8a9a0a9448b41c83a3572a695698f6b9b5f6714b5453e40bc78dc0531fd54e7e9162a8668a33287101e714d96b8814d652409c3fe683620ac31ab33592c1a75f318d161ee214a82e16aebe66b7171f8a83b24b841a23c1549d597bdd799e4e2b730293d566c3e0e76ac6bc8f1487b831f91e133abfef938c08b39aa66a391bf161f2f1c7e348618ff52a5ea8b21148818d9c7a454647162dea81fe8104bc28f01219602487b4ad4a363bf163dcabe38cc2c3adb3b6bc233950718025523dc40122c41c6c9bb90f087908b5cddcbf9e7e32caccefba30e47ba43899e362db5aea5d547219eaa54ef48ea2e9c03411644ad33992a56fc6b5eee5c8d8c78fe4de30861507fea24e52acbffb9ce14dedda18b0b4052207d8387105c588de631e53b1e3fa4f7eb97947c0f9ac9272f2e786a272548a4b30c517b9717be0612a6a9a858f080b7ec818d5df7c2ead20aa0234b3ceaa6e42524d3d02f574024b0c3973c96acd661dd30a46a0ce1b72299e8d08b1e4fd87dba665a3ca686dc780ca7638cfc8f612e2626d49350287d323efb96941f7a024415f4570976a644c9e3cc903a685bd9f659cbd9b1784cca6efe5646df9deb36891d025d13487770e111e6f0303c629ddc8209dbacedb2fbf4234e59cf32d801d347bd5019cf7441a78732e3b377862a8c0fbfb0e053e2acc5104d3cfa2993c331f4bf8e7a0c2ba8e64b69a7d03b429ace445b35582aabd05c8d9b14b31616e99b03a2ba7ed258a61ffc36035ddb3940249e419c2f6b476379491b763890aa79ed6cfda37c13839f851c1a04e5006edb3c960a6f8785d7ec75698839d5dc683f00e76cc855784298b6344e3f39255f1668b73171025a8fe5cc9d449abd4502d024e9e273f1ad0f7fce62fa6cdbf16780eca92adc8dae7879315ca11e69908afcd2d1b33e18dfa9b31a092c54c877d21d9cd290a1318759998819c393fe16ad5ce23d7435f0682abfa572e3e66d4d636cb2cff63699c80fe15aa58f3f590d5c335b94a61d3174b8d00825e9351dee0665bda5ef5d11ad81b8efcfb5ea7fff56e19274b9d40eddc8186473cafd36612b4c875c34a3d93b20074e09c0993ef3c50a09cbaed82770c7a026016a83a31d162c67feb1e1cf284502605c71e48b0e9754d6867091e2213a06a631f44632bdec17e399a50a0bb7fa83efa9d64c8e170caace0272d2f45bc56e9350ba0429591d3cf509759fa710b966c36121e7bfe3f4d276c9b3ca8343e0448d2b4f0f9741236eaf09b35e40bce7058737a6a7250d758d619bb8c42798faef707c496ef0ab559cf1fdb03f886c074abef639fe3e5206b421a25cc32f71e5b233e55d803e38c0b8a24182c80a295cf16412c7033037163c8c5e9bf7aafdc8def41b3ead554132b68baeb07c069affca69f720a2d43f61552c3f63dde935160b7b68def34722b1c5b3b5d4eefef6efe4dd0b5f7f7122b3cac2e4b377c1e8580e8a39c822d154197d00138037b545e523ce377fd0d31bc1ea11c8e6fac57acead4ba40ead7bd2fe46cbd12f790c45b125d8a912b8023e6f5daedabb60c7a022d55a710a6c33ce6ca6c51e60a8c0eb395a77c19a5da525f4f56a1a242aa1d5f1cc4748fb2ebe030ef49638864fc29b92958303ce8ef3aed26f90148252ac6a46c1ae3ebc4f8045ee1c09c39e9581fddca8432ec09522dc61746102032791cb6460e117aa1687a1adf971c7dae2e24abc025827671fed39991d1906217b2fa711dd9b90b7b1e57e66468906cfcdf14b4dc160e09f979f63fb6cd15e41b0c87cfdcd45c755883b5a846c8b6548841d19b6fe72d3069e2b5d8af04b753b789151375913944e2948cb7a360f5b71bf7553c3857e132999f1b4cc26fb25691c1d7661b835007f3a6c9108d371c53ed732e917697d01a8546ee9d9917bd05ab81c42c1005dc4d13b14cdd3cabf721157fe1de728ad93879c04e7ee08eef247dad92ba2d439c080554b2843efcd9d317f050f349a16ec84d8437a24f6139c228e044da1337d63e05d13e0766d22f7bfba8d9f030d8814f31a4e83b9826d2850f40205811a42bdac5b52c46ef0a4801a0e1a92151d754bb3bfeedf83afb942fb9d41181863d0b819bcbfd79a96642c03a3896a4fcd525bc07a529ac5084fc0957f7f7e57ed529e53b5fdb465a11985dcac4e4680a9c5f050e5fa8a492afa5e9c0a82d3960c62108be8e5e0bcdf73d3d2fddd0a3c42595e8ab5d11a9716ff0fb3f98772b81c510d62845904bb4e6c41e549ffd9c4bfc79105d39ba682722c73826b5ae5818606abb7ecc5c549120beb344a2dd7a0b08e8ffa31f803eb2e9a9500e0f7e4f97ca22969285a0422f107076ed47240a5e438c4525d1d0847f32cfc3bfe8a01fd714703b56ae128238d426db01eda5017129949d0c7e610391b4b1e11b68e795a53fc44b2db3ab250f1e0b8fe4d2c077c611274a12f3f66078fa5f7af59271a1969fadc75a6754e1f3eefa84ce3367d2ef6fefb06c49be3b1d707e8314c9b2aadccb44fb9efa2e48dd010f762182760253ae572cc64f7d5f31dbd4b5551c1742c8209656eca9d35d92751f79a59ea50f61103d6c534eb4c0eac0e65dbcc9de0a4238664d8ab57e0aa962c99ef713754546e997f53c550c437cf2e8a5f0260d02cfbfe0a77e79d23d4405c645cb428eede80fc0017ba3338dcad587fad0cc9cc79bf8bb08bfa676a0373ff04abb06ff4b82b8f84769e14be8c289628faef415c37d0e1a06a9838866cd964d11c708cd3eed173cdbce01ff641ffb266b728c36637bd6f29047fa6594b4aeee38070d21e69d589e1558cdbb32c18b658246e54ff881301bd0ea4efeceb7c243c6ba686a963053ce545aa0a41e42eff689febba0ffdc60d583c60e2dac836c1473cb4bd6c05a145343460664091564438a46ef6c76ecce69e9bc55a68fab0ce7dd796dfc1c3f49be5369f90e77f7e89d2de8ba7e8cca8ed8c2e9a095bf5346a87bc611af580e8daa8cbe1a1f2fe68886b6f701c0c180e40065ab24309d78f4247be162eefcf7bcf8979a0ece7578b914a2be03c8680c741aceb2c9dd1f62e9853ff0a391d43ff384d238695b4a6362b5e68e549fb3ca876ddf5ee7c4ca96d61c68221ec28ce3a1a0ba7a7656cc896d75d87d6e3119dc1ec1d67adcf602b49791c23db00cf10a443092bc17524ec3b5b6c5bd843b4e89a661f0b2c6fbc2910b62bf46035f02c82681aa21c44cd22f9468c71a815a3207742989f9e4065d0df6761898be6fc56118cfb1c59bfc08716cb39305ff7a84c617852cee0a6ef135357284e7506a676cc906d5dbfa0ac4530b185e88a00b5196550711f576252a1cb92f2fa92359a58ea703ef18bc72ec13a64fa532527afc194e7834420bf4068d38484c062bd2bbfc2f2cc8f4b64954b540a5a3349a5fe059307067333dd1a01ca70643b03f0d33bbdc6274363f7ee8e9fc500c09096ebf7c0366ed1a261195f3dd8193086d53d2cfb3f87767252925c69840316a9a58717f4f64fd60c16c9901b271222c84e7c2cd1bd698cc76f6e7c33048ba0fee8caf0762d13ff2c321f1ca78dba04829caca1eeec06aa1c01ad7df478b4bbcdeb54a5287b77ff96011546fb08b7a521a1411878394f20bc773a83f621d71136bb5f4c492b0a53cfd6fd56864c6b04c3a9c92df1137ab4bd113797f74368543f7a5d0ce58af9796d5727e381f737bbb1201664dbafcce32714a51f902d49e01e1fb4f518539aef0c5789f9ba141fac5085312e09f50d363ef2f48f4b385857093930fbf6e75dcc7ebef3397823ce30a0b0b51452c24223e0ae370651f25acfa8a0f7e0604ba06ef2ced4b610c3d7dd22092035f7f6bfa5116e16ee722893fad1e47a458ed187d18dc7f45585cfe2271370e13acadef406a1a53f27f2c55c2f9a1628607cb27b95db32cff5d48a7212aacee25e330afa3a55ce3b7bf6723df2797992edf7e72996d8c40ccdfa3b4e799fb464982f8bcc2c4d22098856391037ea404b9a50e8a8f544f0a2b6263eceb9ad3905b5a62ddbab33f3bb95f26bd2309f412992b47d9f11b024d594d6b584c5a59f25e692389d11ee1417f5ce416691f2c578ec91525e9ce58f7b2be8f0a02e6ff79dcd47a5c1e655f85b4262ff0e4306f93230ba3e5b3082670355095f36edc075f4afe5123e1af07f716432987f4db7a351c0c1f5ad4a0ad13e7d5612ac17f280911abc79d5a619c2c0064fc0674291d699514c3cd52cfcf3ed2320f241ef1f7c03c5075654544887b917b731567496b313898c799ade3432dd10e6a58bdfecf79aa7115cb9c4dd9a514f70f17057dcf0eead5d1ad7e14cac42fc7909a9f4f409e20c00ce895901657ff29ca2f8bd0e1b71deecaa499bf19cfc242d2a91b80fef302a5a97773d82f81567fc862b87a12e61a37ff95c1be8c72dbd615dc33ea1857c0abb07a2ec770c36f1fcf2d313c7fc116218b9c9c4eaaf951ba7e0f8171ef306cbac619f1ababf0fec4f566de38276ea1a4f89151e12efd6a4800c6d94b8838b7335a2b70b34eeea82b6eb2a6b4625fbf43a272cffca7f63a58d09c28353d027e5f31616ad489d4b225143e6075b69247e82074d3846137e9dca176326120991c01fc49b68827c29b445b75115d0e191c074b2e22bf77ceea074cc61c3be7d25e4f49bb34637dd8447da98b85a52d1be9d1bc10d99d6ae612531d7a8d48b548862ded1106b7d8e07c06b9c69549227206d7cb46acc550f03995aec14b99184136cea1a79862b5531aea267fb2289b3de1316c934b2f0f2aad428b81fcfdd2af4176bb68a813b350dbfc0fe4e713fe10d08b944486e2ac32be","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
