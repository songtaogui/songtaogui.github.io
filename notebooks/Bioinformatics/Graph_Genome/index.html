<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bfebfeac9c1cfa5acb157a09f93912f152d4842e761fd31d7358d85bae96caf8b4cfef0ffef66dfd13bad07465ae00ce5ead10977d8ac8b324d60fb8d48c949f1e35be6b4661cd097807d0c0c3df3030054c3e306a10662e6ef434844032203275082554e1c567997801db356f46f6fca7e1f875afcbb3cd88932ef2b650d61c74b04e65f467689d02b2c7e4b4b57c122efa0ab3b6a3b669a874f3033ddb1d40572a36bc59189ee7346bc4f3f5d15575892b240ba41373bb253ed2a481cbfd12995032a7f8d4f481581e6deab2b8c6428ad703e2e3175ba8fd0513a7635949f9c0e87887dcda59c951a5cb7c2657e849d5da3f0547e594249fae2918a522223e3ccc94220bbfa1615caf8a414183ff99555ec9aee3225b038c0bea62e880f4e95b6c2757b6cf368d0b945e23052905b156b40e530dfecc0af13afb66dd9aed8d8375ba4b0e51354d74bd47c7d65323d22a9a006a83ff43c419913048b26f8eda2599aa07227790e0fc1462f2934b5bf75f018a0557d00dd71d8215eeeab8a6b4f8ab96818e2954b363d99114e623b36a0c6aa651eb2d5fb768ba58f09272f2eae1fe18f6fa4f969cb74ece75944a91ddf9783d91d4e9b97d020638792c5e920b8e2e03feed0600369d2e3c58f4eef704ec323d4e7103ff473a0ecb7f9753304306b8772682b01ec07f25bc44716cbdcb08c4d7ab29874f9ac51076b48a4596d225463567e24b1fcb616094c2d37b8e27cb362d567b40f87d39d1db213b720df135255469e71c81e61df7467b4a756bf38838044641af2287cd8cbe3138f679de6361585dcb0d8582dad8c267af6b277a19d9be4a93b977ade8a2ef0696d6def44f65a87b9f875fc4cc6a4a1c5127c6f045e99592a9967fbb0c89317436e276af6db12fe54b87f0c5eeaeada42f4671d41413816c6e6e456f8031d93e76061d840939bac96897eb405b6281ff74835c33b6b9fb27fa63dde1a278ac1136d06c0b2ac2f653b209d7674818af179448a2f9e63019c2594a8108bee9323dc2195f0b0327ee0d36d2316303b45500930a8898a37ee31816d522404005c072032db94174484ec8d3b3ea13bae88eff39609a2bb09dbb1a9f60a3a7317759c2b661356a833fd406ade58de5aa88c122aa32f25152182f8541ec573961ab5c01a824cde6dadae293f003de9603718bcd57e78f582ea04205a2d68b7d7222c8dc8d64d6fa7adf504e467f3981ac08267b92946e8be0adacd78b7c7564ed9ed223833972d154c40efda8ab81db76e9073a2dbe751819ac29d9d2568b4823700386643cab8885345d05661c2cb3c8efcc248bd072cab7a4ee4bd0e2292ad1de67aafb288296d94434a7085703bbce9bcb6d85e34176945b3b2e82d5bf8387b65f6813fa2924cd7fbe50ed7659b74bcd27927342142d8a15e4a165b4b189b4db92764c76133a2303ecfa179e8477b9810d252f4fd92ab6827a3dd2aaba5a0854846c73481442a9f113dab451cabba21e9f6794ec7128078f9fa73587a0523be96ff09e4e9a79a4a4899f1b5d262126496514b25601222223ce86d66bda0d06e0572e4edc4415b9d4bbedc996226c09ed582fa17b2d5aab9a77a487e4f1b5c85783d7af262eb9a32fb64b2283a3b23d163580b8f1280ce9785189fbb347bb863d9e9b1e14d91cdbb8d0e05e944e27cccb05bc4214fdb60f8ca83b0241a33b10a298c784841f42a7a56ff14bffb40c9c440cbbc5a74cfc3d86f37b9e9cb7c8bdec53f40020ae6e91ed23e4776109087668d9e5c4c8ed7684c3a5e7b0827d06c082f6fa82fb3892111a09ad0a8858592a3f3a696be3d99c89bc950ccaa23015eeaafb89c7edc1f350ed52a83cac677cee7c23372584e08d6446cc6d979c2e55dc81cd1b2f3784f6430deb42b4dace0132897bd0d891ca15365a8dd4fa379d78f436d81da451a8e7d3ad2748924434a86123a407581176670bca23d98a6f9204764942ac9cbf26b41bdf0f0113e4de1c5ac7899ce6d4abb22b7dbf11db1f7b6661266ef7199c7f07bd11f115b31462765044455782e19131aead1c3d686c1d9876950e2ba81b6a969d8a13ed3e0e5e3213546481409146df47d4016f211500d149e4f4fb411392bf7725a956a3e44cecbe4364332e86da90055b23728866163139ee2abdb88c135c78cfe94de862ae2480f677f40db182c3de769f13cd114bbd7806ba1bba04f3da995094f16b50937bdc3262e4df28f412625a4072de206eeee3264369f011b434123ac69f2f237d46b39d023f812d94d99a122deaea01ad4ba8a6380485790e480f4eb2dd8188cbf50ae2eae80dd71073609f26da2b67d471bde319cb74c7927dd0f86f360f9ba8807edec8ec29370cbc3751affbbfcca6c66baa6554d6d5da9b839886db1c3bd40179241352758d9847089e92f38bf688d3e19ca6dcc5a49406cf6249f969082bacaf0f466072d3a96f870e30baa4b6594722837788e53ce690d1235e284a11c00cf6732444bed09e71c8b0ded3192028a8884294430c8c69c5402cf8b88cffed4c211740bf350b7a1d7c8328a6ea78106250a3a31a6eed8a8a14026d49b64f9866a38e5b0d658da8693ca1ac8fd472e745570819dddfb34497b7b647b2d357fdbade8b65b4a9dadf72492317e700d5a0e6ed8d1d8b934c9d8efc3ecf2db91bce091a672b84335d5365a74c6980ce11e512099efb465d3075cbc241bd88ff72fac62528a6e1dffc963ff198b4c072c207d8fd722bb81d762af108889d5f62565913fe871361d765af9e0807bcd63ea854f7bc797f57aea0502c62efd986643bd54b9a572739d64dabab0c3f007ee5cabd2013354adf78e1ea775a23e284ddda136efe6209c2262bd07e61d0fb6c0bfacde41a68aa5e4daa8ae8b03e4db9c6f42d35263e3a87910beb369fdbe459e5fbbeeb6f98c43bbe2daca8feeb5dde5a9dc34afd99bb9893677e37332ff00bf320c6335012942931e664d5f7125a846c32e0f472fdf8113f0fe4b26ee36b000fbac456d8d034fa96a9eaea80f9f44f6304433a71affc842d08621d8c7b563905712c6a916ad4c2d8e75d208287b013d37d493eaaeed4cc1460c81c35b2efac4e24cc88513098bb734c91ef1706a7737c1a4605f1151e84296a071dd56926e32e66f6bef62987e76d0315f431cdbbf4a0978236d4be4b8d0fa3af0d8272319f1e2b4ead93b1e3e3150e273805dd9225c454fa990dda1fd59544e33e9eb2aead4d51a94de118d31bdd409338e8f50b90bc3abba15a4013a5909638b251ae404970380d3761892e49034c72f5d04d8ae4f75feb2fc3a497add7ac8bb3ab791011c0385bb381ad93e5c66b2f246d5b0b7f73efd5ed6f9301f71c1b12d19e41e6c90b8ae7ea6571d64a42592d99c389034da973e85b9034eaa876b9af9a4bfc0c0184ff17867620110ec716ffd1a0554a2f805ff474b40b5e8a3d368afd2a22eea0b6e6f8f17ea9b3a1f3bbb23fd97468fabff97345d9a2f5bfb497bb98e39226fd6668d1eb87b14ca4bbed9767c343837567ccc81ca7896faaae6a6ee656aecea00f2a9d383cc9ae0b9508859f82ecf68030ad84e42347f6af4e98ba7cfc3b045d36d032ca5ebd239cb9e2b6701dca2ad81954f7cb44f42d2bb6b6c0329fa7a1f4e87359c6e4cd15697a99010cfa72276a68e06a1dbf3672cc4944351b7a6fe3aaea9543cf89801fef796c6f682ac445b904b8798fe5b2f1c62ec12e04e71969f97b3468d590d07cc480fbe3adab089fc96aaa232e97077b08cd3fa2eccd5642a46e8d44137a83d3e8409bedf4b66f8430d18bfe7aba814552d321207ad03bd1a759573947a87d3634295c94d01c04e6a411c51860964f903f99c508b02aa150d6774edd1c5914d3437fc12fde27551e1247a5cf07384de43035ead115c4a04809b29be1e5811fab29194ed46be320ab884621d12aec7b07d265ab08439f14b3335247c269abb8170e3770b8c967501bfb970f9e730424a7a92f8f2a6e127a7ff071232fbc654c344c6d7724ebaddfe442d234f872ce9338c1ba13b7b112d4a616125c7dde9dc54996a9f42a4a2676752042bb051c663d6516a480559402141d87ea96efebe568aad57ce88ba2059c0edd54920079f346313c5ec7f16fc708fa3d231c0559db862ddb8e55588ba544aa8a0d210048e722693a736446290a73251afbdf185bca5ad63d8f0205e91984d69a2f5b071623d6db048bca3b483708e120b27f1e9ed6bbba41488bc11d962686badbfa98f2d5b8cc1b993554897796e6aacf060d0c80c63a229ce5ec80a65ffdab5de9124ed19391d61d20e5cf4ab4b0bc0a32562d8bfe817f523d2654015a7a8d65676068b27aede087cc801b2a45c01d47aae72827c7c8de20fa8b2d9e595512407394b52b4c213cfe60ae32c38397f4e2989b3e6f580207a989861f7f82e2052509d029aa9872e6ab299279c63c10d79e9c477999efc61aef3325c3fd0e8074a9dd73632cc532bf688813eafdc7f8923259c2b588cf6dbac18252f008779a53a0664ebd87d512eddde38a63ad70c7ee804a1dd108152ea913437c791a8b48af93d4510e769f8f13611a250729ff18889b5163ad8d8af1d762d5eaa0434fc4323d812f9a518204b2465bd24fae88c8bf3df741d49d94923c7955b57af3f970172bcfe5be1e0597f52fe636fe52433edd67304a64067c398dfdf7f89606596f30e4cc97b215418b19a8cdaa52c4516423e58b5ff9cb71f6f7fff02b5375e3bdef9f539b8c731a399c2879237e2969b272d17a0dc2471e80467ecff1ace8b916ec239ca4fdca9502a05b3e3b3d1090b9c35526d4bcc773612b183b939d7be936b767130f7b7137b1ffdfee1d09390b851c36e927917aa62ef185efcd73894f27b1faa22ce5f1da0c2d562db311dd5a6d0444a72c00e68f74917c5d21b24d0796ec2d7b9d1c3444dd56504600d558f8e28541cdb1d1ed1c65a4cf6f2f68cfbb9d90e770e6720e89b9edd86fc7b143d931d19b1857265428486339278457ae879d3f4bfcf843031a1ff3848d981120ef5a21f45680c7e8c506286c8e47a538b61b0fbbee9546ec956be1bdc8341f08f996c8e8d5cee37d1af1c4a253c25af68b7315336bf0b91a08f797eb855e85d05812a8b1c13345a56a1d1b8813eb46f6f905ab2e0e8371d0a67a660179286c77c81bf9eb53cc0e28160a398c0707118743f7c280ad98100fefd334a6c207856f297b8e872e37fb320b84f89579fd7c444db96c61e41ca216159d0d14ef8aaff4ce6c4d3a64ee1270a57eec1baa29140a7390bf22fcf04a2b9883664229dbeb5f1f8fbdb1cfbea6f05708015368012e1621380d2206f23af935e2009d274b6051f291942cfc8d748a76ce340c1e7c35d17cce000871ab1a8ad05fa0e3619526c9b606fe9e1b735e6bed44a8fcfc1b133f8bd886116fa404839a956c95053636eeb81e6c8ef4b2e3642f3fa283dbb054129a4ec4739986d4ece964bd5f986db54be252aaa7a0cf4e2eff8da855673b56b0e63db247fa5dca2946f60d589cd5c7f59c293cd7ebfbea4333a2676ade51c0c94d17c03de57aa99f958fb7a5de2652b34e481e9fb99a8328162b2b2a2040237ad75fa55b0682c17ecc6b7fd77e99033050519f32f0e66177baa4e88852a742796eef0b2751d087ee730836adbd972f6ebb21f818cfebd4d822a7d8d4069f102e8403e7150a6346eac3d5337aa5f9ed4a306348b8a2a0606cbcaa5d90f6100c128e50281579c50fefe3750445dec8b1b465663ecd02b0049eb6f5565f3ab34dd67c001111d6391ff62e00fb06d2574976daa356afc40f3e684070650bffc4faf438f87a3cda1d6f7a3a1e8990243965a272f6ef4ba516d59972e9a87f0159321835602032c9400561dd5ed2e59e45b0d691787e969e9f9bb06f7a101794b469eb8def641d798244ee406e277877ec5a34f429afe6cf6a60e7d138978ce7796b3dc43087fb8c3e2518b468a1921dd1078263fc0a8bcf2359bf6736347a1e4161209860605c9b8750d0ff1286a9402ac0e482a5b57b050db09f98c43dea4e45a6d107ff6cf8ecd5917e572594466110a53db82a551d4745b4a4b32b58b7b21afd42ce9bdc90177fdb07a158b20f2db3439552f9593116c9bd1c1452e791ab35f8db4d2b2b37b745b70c5e81c4ba9a690478f30d51a160e231929de375f33a8ee47056896eb803aa2bc5b2c546c79dc9dcd9eafe79f20166788362d3b3179a527f2caaf373e7dc2c6eaaf1a3797d3856cd1328c4bac6e5a84bde4aa3fcbca869e5b7305bc45ae64b35c7db8ee30991c3fb25c754620d3645a6e18fd523cdfd565bf385fa34fda2f44fc393a63ef6f27ed27072759d029b69f3ada1e535b7bd805c52c32fc8fdb6e8950e0a93eebeb15a2366f8ec0653df171796df95a87e8c8ecfdd8c210e98cd32ed9224b1a5fd082469a73c3f3264f9fe9be41e788ac164b650d884eee0e96fd35b0c67cbcafd279b7786436541cd31b33a970c374690624c164f5be3e1a9337771309a1c7868246620d0901459dd01e7b4c1800344b42eae448eb0375a08d7e093aae29fc846ffb4a95b680a1b166963fb56db2b1ab748c56bbfe84ebddf15bb3f543e4117c8fa5f24a13cb9b53aee58c6434392959f14aeb3a1210e0e218bed46d25352ceab9d2cb678643d36d656bcc359bad5fc9031046af6c7eada43ca5730c5e090d4b9e2542d9a6f2a1fec71a84ae5be3a3a17ed4ff17e56d607003f28b4318c76e6639758f9b58427e78478a15ba50157cf453122e496d28b81ecb82714a607d2fdd2f47389c1586d45f502cb3e656f08316526b3ef94ec2348cc5061252e6094b0890d17f858865661df9c45b074c3d258cac52c04ce855ae8a0c15ba18c34b411cd02e8183179edaeed68aae44826786c01402c38813102fae96ce197ed1b493931b1d27399eb653766593b85dfbef3636b008c319ed7b4f8f340218a1236c366266edcddd3125f28b72e2f3da32781e432a44b7487334642ff667d6a30652ef06b08542b8680655fb7dc1fb1a4df1f47757b27e81192fc7aa45ca00076d33b2a9a06ba973ae9a5cb067ea07f01a6bcadb280aaac656494b2ddbfedc316e068c7f37016bc597201a562ae21cc4624b5a26e74f9946be63b233b09c9078948c2e493e7dd02f6e65d956f8dfa5746a765e79bc71ccda983f9c869418cf5a951165787f8eadaae42cc56c044a76822d7447defc94ab8e116bb06d6adf2628417425d38b929c51d11069f9b043c5f763dfa26875c1aa1a89f57e09faea44918a0949516f09e4384cf4ac75ef0b7e14f2f40be53b604edcc3739074419277cba29563bb28d82de71ea47d90cb735e73bf65004dcff9edfe5260c944be52f5ea4759e2e0a944e1c73dc853c648f43dff1180341b94bb61e046ae8a8ba878fde51c1b789dbe5463b51875a6e5298d061810dc696e604158bb2d7ef7c079422cbfa6c10383d3ecf6dcd174234672c8a2a90bbb63077572873d0e53f6fc27e4b3773ad7907fd7fe5d3a7a251825f421305feecfd6ff00ec419bcb10a03962aabfd34a893e287648a386423ba9ae023e186b40335aa55e5d95f4ddf2af612f6beb47cc74bf41d8563c2aa512c1c70289ed318512aaa2f38411bcea61ca5d8da2832988aa8c3fe5752e10aaafb88eb93024eb068bcd8b24c36af13b3f427290cb9131f4f41f5ad0e7ee66f365b0643c27344b7fb7e268a6c22ea763086f260846bb0321a54a3597e5f17f5950b5342f6305e6a31e5bc615b3fb95fbb2f97c43eef3afc18fe5d7395541d271958ef5060917f8f3b8102a25adf603f68724cbd8ee3e5cecdf34ac79a768d01f137c33c796a18491a8636dec63318e0f903c0962a988e3570324a98963522102ad64226c8f544c2cfec2f063d87f286e57edde25a0d82c9bd726f3002286d11200079942805f413b83a2429a98de8bfeccb17be9603595204436c660ed22a48a9ec6cbe2d09d2c3d7cde24fe8de90c4ef991848535b36672e6495526f802a78bc6b07b0f76ee291eba08fa1ab2a61ccec4a42884f625e8c31e0496ae6d6cc5ac5aceb3a279100366fb3da22a07f5b03466ce57bb9ee5e9bcdb6ad1c56443ae59b95f31b454f542f148b7bdef4c76de816a1b24bd9c18e3741afd5213126bbf0d377e2ae9882ae2c89c5c22c47150e1f450c930fdf5057d57a90d5df07d56bf6a14b47ad2b338fa7462e554cc78519a0e4262d8b1441efee30930d26df4372d895ff004e8e4e808fede7a1f4148cf430ee7ed86c97e29c509cccc2c59fcd12ab16ee9eba361fd2171dcb7731402bd8d5f19a34fc44c409fa6dc356118ed3d74f77a17739fd41e3a27fc7b2704e3d31b85ca9349119ecc43989c544b903f2324af8b248ebe912fb27fa50fed3ef59935da483eb3670397d3fea9fb2efebbbdcd3976eefdf0ad6b237338fbbd92a07d888e3bf25aead9bfb6415a580676ca4f674d4205e1dd2a3a12291664d249b5aad550d81a2cf186f8051f4eeb4cd3dea35ba16ef74edd51fa342834927bf9bdbf67d5d8be8a0a5aca4c79ce0eb97752712b75aae1d5efa5e16dd048784919e7a7ce62bc623d4b781c27848f31436a4dfcc1570a39f2d4952959b46b25af27e74e28344f72d7cc8e5f58761634b00bd5a15bd3a37899a3fb52b61d9c17fde4042c155bc1e058ced3fa9f3e9056ed5ca00bdae7844e908a1c0ab48d1b025b0ab279aa900dcbba1f25f16f08592dae7dffd6049faaad01235dd1b180a9e9d6571797ddb3a7522235602fdc1123bde580bfa44890b052bc28ab90aef5aecb8d3d02206013fcfefe4c0e155e79514c55f0d49bd8ae10297d447c320f6e854d55bc9cee93938c84c35f1b9c09ca798bbe64d343299c24147fc67bdd3ded9dd2637857c554872f267574b508426b747a36f7a520c4d6460ef79df6a6ef8427f7f5b17ae5457e8f0824cdd134b4c8f4a9b6a577eebae14681dfb2e112139a9e849c33e35b4f2b4dd5cbd5d662e77e6ec164a1551647e0adf7afd886e6f96be08c9c5aae980fa4cf1b11cc917ac1c7b3bf2316f3a32900f4151d847404c2af0b2863bcf9e9168e47b0078c6c211cc154e66715330ee75616a72f07deca839823a5678316e12c3114e20a98b38ec9f2a935c166eb8b9ecdf00c33000ac84e115f65687869dcd818bd6ee024487c24c3a50221476a922170b534c3b0539d45cdccb18d36426ce5a84f3bc092a8b0bf675c52b530f8ddae1474160b8861b388268f0046a8a7bf2083a3653d465e8da1037f3d0918fcc1f967fe231613fb84352a427006f0190b47a89e2e2e95ba6e9990318342b9f167a43b3916a0bb25ae6dad4ffddc1b980a1da50fd359f891463ecd60d6611f3df332cc4757bf0124cedf1c614678a02da708b460a8c21ed6547e2ab77c61dcc8f113edd8f9934f346c211c1a9aa4d6affa2b601cb17fbbcc75444be6c5fb84c254692e6d32e58fc90f17ecf7c2332664e60108dd5035d97fbfed42bf8435243abdd9671ee6fb7a219c32255aff4b707a9a4dd5044a040fd7767a70bf1edbf084958d88d61f26c6b5666b034ba7e628d04b6e48f45dd812976e9bfda3399fa69db09fe011f0ed975202fc0087b768e5a25a6a83aa0986effe4d802e1f3dd31afa2c206f400d248ae85a5c2b6a641a3645ab41278bfc70348f68549c059e4e81a3c63b87658e0841ab693b89a4019106d91ac7a08380bd8ec8f9151b4080f15a01a39d905b775c39f5939eee1acec3044f66f59512bed87161f73591e85615e8417b421c108211f27aa00a1b2fdaa4dc6c1c7acc9672fab003fcaca6b425d63d37155b6ecb7c995a78d19c5bdb5d796b425003409ffaebdd950f631c5df6943d1bef36bbbe3746ec99d9f02a3fb69f79e0ba0881623b2af9593592f34d489e3e865f411eff0076d370cc826694ba7082d32ecc153566313ca78b3a66ba67988f0e932af38b9fd1194c4dce92b475f42b7592a22bbd62cf5fd6e145d0b71ef73727d53e86bb54f0290ea4f6dc4638642c4f8511a61fac5642c48dc1113909f8d782fd97d9177dfff3dcf5428a62b2e3cd91bb4067fba9d7c6823734a813b8fd3c01d6191e80320227f122320b7452ec9d303b8b5e75a4dc470e82d990c318695147b8ddc8ee5acc94a4520c2036c621d3158eae9b380999187e05499066d0f93d4d556894d1e5141ab071a25af7dbb18eb990bfa31e27e0a40cfb104cace79bad5b112e3379dfee21191c76c5070af6dfb840a33400dbce661576548142121763b380a012337f73f05072a22f7f1a40c7e2a93531792c4843003900df94bf4ad642435a914c44f22ab44c8960eba4b7a2546b0500482a3868d607143070362fb0b6c1ffce3d1f74a85e3c187a5ed3260ec8caa4d1454fdce3ef77dc9b922b6ececf2db97b2c772f901ae3edcf7c3c1a39c50be3dee3cf8f25e4f3984b2e1b3ee8be5fba6099b8b2abaf78e72ac68b8b42f01153799b65e13b1b6f3430e8100e099e13f6ef76bd2c58ab28c827794ac20029021f260c60cf7808acb9bcf49d331dedb5c1706c46295fcf446c370126743a768b59a323c15d76e5743956da7211fefb9dd73c7f961f970c6a7d20c36968c8bc9b958683466dacb5062bb39c361a07efc489db192417b5f5c277f447bf7c7005ab37e9aa80108f5763ff8e602f2feaf269753132d588270c1a2db06b640612bfe4c74019b75ab327d9df51c2b62e572b6bfc707a3581acff23ec61d07269acac8f437a827b7bbe6a982c1f2278ae046b02875871f1a848643f2f8d828c4ca5ba9e2f0e51786456443c1d5d7a9089217404a1351082ea91347dd4e375801b97753a9e0f0ff26775180ad3847e2e78f6183efeb8c17dd3b88f8c8b43abf8d28ee4c893b7f5472327a231b5e03db08444c6dc845843805d9f942edad2534c4fd4fc73263d93d0cd8c2bafaa591ca122b8ccdd374149ba411107a3bb9809241be5bfa4681bd540a692e66e972288f2371c38d5c51ab79d24efb6cc1c3b2a860abf60b07db978c0357e422f230b706175ef301f0a31a84db732f2a6fe8cd9e130356b620e99de6ce9c51ef73e3b3aaf9a69efd3bf73e8fc3dd4ff53dfedb71a456d597a9d82d34daa6a8e2042b46aa8e72dddc9393825771fa805f1a35bd1994f6c1303e11490fbf788aea6ad6596558afc4f495e536e669e33533f1c830c0e0896d4bcb6811e3bb3bcde1170c41a2947d367aa8428795d7b2207fd4b4b8df62264f7befb916a23a53723f50aec1c802b6cfd29989eb5a45bba751501e31f827cd0811e5ae67467084cde6b9fabe51279b1f987a1c43b96c76b989e4cde5971f1345a76cee54f3c4b0b2ef527ecb5877d0b8e33c91799d6079ac223c544ad6b6cea6b5a75221d068aeb82fed838569235dff24ebe1424e2de7ec4fa22e33ba00d17286d1136e159043c8d6aa5eab05c10edccd2c01bdafae0c41ba2356bca6a7b6662c08ab8fe4eee105d8a5a70e9f19a2876a904884bbfa6b67d627943c4bf24ea6640ae20c55246fd83a46012f39068fd5f5d47575786c6e7faf1bb71523b03a4433c273ac1ae9faabfd8912acbc9aeb3d82161f7d83951f77f77d9b7807d21f5920fa6c24aad5de3435ffb33bbfff53594c3fc4c0686be47b7f0f32eb3de8c6e9d4d3aa1ed7ec744d48fc779998aec81effcdfed50137b1aa50f091cd469a5e8d0566b7d7838fefce8d14feaf30f1fb03c4020cb40e19974d96a7239008265cfaee9f20194532e048e41a7f80825836cc29f96671eca8b63e0f046c91e63844f37f18ac6e7c6ea6298b5f59139bd7589fc91800560799124a858dce0061fe5b54d8eb4da2bc9ce8411f14204a1b475069ba81eb874c412876dda599d98379b35e860f73803c0d29a783ec4e49cae95e25c893562903625c00f4f8924fa96aa7d4365f4158ab5d45ea06f7a9d7e7ca9889f6b7d8167576d22b24cbffe5092e33298006eaf4b34e52663d2d5f24dcff883d4c698d895e526bb998fc1aad8331aa39177177fa5b2e567f701fa3348e74f94f91fb9e7ae9035480dcb11374fac07fd96719979059786a3eca7dee045d3863ec11abefe5fd7c0e1739085609416c603058edd507654fac56c23a77af89910bf0ef5f51cd12be873076afd58b1aa3c8c284bce56814b5fdd78834659b9394d0e84eaee4f985d5015c3e8bacb7ce38edf8ecd8c69294da7c334abe05ad96f6d0fbad16744f32c2f84c3443c642c7e9804b4d1c81befa6531f36d4fbf6ecea989863601aa46e17ea2acb1c1bd4f1928e9959abf0f3d27966e36442db7af6e39b8577e0be5720b46fd478c70d5e9a35f8d5f492654d97b11291b3f6c1f4fa4d346db9a11efa839edba9a1bce7697732eabadc929ef5482146bf3562f86f75cc9a127fa1f10957c3826ed439fef8176966a439b4b5c68ac6dbe1ec45b11badba05fa7047d118e237c7a1bed79a19f650c1d467b034bf3fe7f65df0d3fcdeb959bc2c06bbfb0198cf9f2934e6d64699c0c2e4889633f9a5a600b78b6a517924eca361215ecd5a59cde998a4fc0971614d390496bc49968311c284a16abeb65b559c38acee3b92371d3ed17e6c4206127b5345289cabf77f75d2ed05b79dd87ed9d326872ee1894f5b379821b19904b805e8544f6ca52faa69dbc3655da63a0fb04d5304dbb2c835840134be1453c5ed694248d2c8356721d157352222a3cc592e02da692ddebe02be8b038f20aa2ca942e2099081e4fb0b772d28a9f4e4063479792218ec69443d48ad1fbc40cf784e2d7e56cbde81d1253491fd4748d629b907ba8b164821ec8fa1491e920238822358e6d4cbbb6de8806ed649e341520ac51e22f5efc7bca4c4a830cf869b00ad76f802666139aa4c08167806ef4ba548cd408f3d449c6c510a3c6831a2aed8e28e7f43309e9e857068e24ede8a2b4529b944541cb92e3a75a718162a101dbc69128c4861c1588449006b83748adc744f920fe743dcd55865d5d6ac495a7a371e60c0027607c224a226a75f36dd2da11aed10e85e3242def1b7a506a7a372341864136ebab6d8bb9c1d2d7984a05421b29cc0b36c7a24e0bb577559b0c8a8d87e243d7c792765750ac6139d7f0099e54027bde787bddb4b27c44e6b2bcd67d88b5c53315afb1c583fd19e0d982a906218397e6451b8d11ff6a0ae70b64a3db3441838b1ad5d17cb34924d4b1a6730bd13497c1e05df8f2d149f7d78a9a78b46b1cda3c8aeab7ca9f1e768a76a301b2526c49aa044d15963f5601bea182b2d4e27b52772b2d0409a4c1b9792880e4a860b99e06e0b0a339e4e69b9de0fa14e9dd882c20e90270603bcb6ad766b3adffeedc250e56a376d9d03a67897ed858f6fb00852efb7a17bc8be3fb7435d34be15c741a2c7cae845744dff3905e0b00b21df73bb125726fa79ced855d2fd611333cb23a30f35263a832a5044d2d1ec47704b69e9ae4c79b9053265c1d669993ad3080b93a6047c08d892d0081f841bcbcbb46479fe60cda8cb1c17b07e04a7c004b4caf677fd79bf0b129d1e8c96f88958d05725875f4ae21ff912eedc8f451ab5e71701f400872a379179d9f4d61fa73218d0d2b39630436d308852b570e5dedc4e54ad84f6c3cab98130476e34f3fff4eee46b0297ea6355d4b15a2f2af2b2371ca1437c24dcecadc0b8271b11e09e3c63cab0f810e9fd4bfe720851ea46c396aabc242e3827b0bb126232d84b6d1cae60e4be397f448c20f1ac08f5e1bc90774af913a8f47b4911a0fc6223dd1fb01f07565e60e1d0fd414fd6521852821ea988f73a25f2f852f8aac8d6dc8be856f8fee3d63c1d3ba150ee726ffc429d1323b3eb86d0479cf6c5617e2e3c225e1aeaf9a0bb97f42420099fafc9179b439f89e8e29c48b43db74b52a2146d0794cfa765083c446da973ebac912ded277bbe605f9bdda75f701a4bc3e468853f7de01e558a81cd21d80fb2848547d7cd4fab911cfe1bb228d1dacba2880ffff9e86034001ca6e539454bb39d1d7a39960aff6c6ce5c77c32140f54c081eb257565bf84709a106dd7f1f8477865c5cc0a71522e76977b60b991fcd1a0f8029f779d321b7cb1d0453e7e82a059db5b18bd0d8bd696c6bdfb19345ecf31dce2f828655494ed2320fc32bd0aa262d8a36ed60cdf1059323da3cbfbddd453f788fdb24fa20e79b1d31492904d56ac926edd7090543e019eb075032250031a3dfcbf3f9a621453771ee513e504ce437df0b3a89460deb74ea40b1e390453921aebd5851b3a68515d1ce540b2133f60f8622cdf7c09af87b10d2cffea37e91d14f0d7eae4082400784bfd1eb88b4a6a8afa615008bc13cece91e6a1d3f5f80c615d946a6060eaae7bac8b4022346718fe6e06597feecdab44752714201b84709f3aa0c25356896d5ded088cd3e1994e5be951b28f6b10698b3b7d19c7043a68fa710d02585045aba76d97b91308d5cd271efa94fefd8518b36e105d729dcc80caea45342970787cb063bb95a62a905910eb36b9871ade27da93e23a281951f73b4736e38f317bb7e1ff75f7838e65f4efb3995c5ab532bea17c8a03210bc4803b7c535aecd57c09f11593b9732234ad52d90138ed028b0188dba35aafdffefa568e9195e15b321808f7f29c33b616bd7f5dd6bb32e1141c9dc6382e618672f57dba7c1df0205b9660657b1e462fe139a3cc4c9759c3bd5ff10e19ee2632e4ca341c3a27b88ebda80aacffe86d621e4c95535f4f985f5785ef1db3c7b3b8adb6948938ef4f1c9446016df5ff38767dd261da77add42bb4e79465b7e49b39ac1a23a2000af9b471ca4d39fa260139e506e80671a81e02ba094e91e341ad9ebd9b0c8ba666484ac64782f121ba86df7a97f995af2c6a5fe653617f9202db5b71243ee2ed2ee26fa8a6df354329bf9404a95b45e0ae0af28e781fcd30d17f77112a956930faecede16b4706bfbb9d87ec0d5f334b8d6d6e8a0e5fe8c5e7c0cc80941c3d789f3f6be473013a3997940ec646c25e338feb59ec24939f0913439d893566edb18f5960d134ca409bd51074eb02cb2732f9a41badfe9ee98bf8ded6a444ea8ff95c2b40c8b65b0a4756a49b9adbf44f4abfd2826c51154c2ee887b1031a426c7b67cfe91b560c62001f9aaf2b48df98efc88c897d985cd9f2488fb262f6690d2950be5420a75ca3be0f3aab67e48278bf7a85686278375840668f090896023a538618239beb2f0eec3a797af14ea2e091257d5b52bde0530a8c93dc548c78b6adc3c2c3730e1f972fb12e0dd458fc3b4b9636daedeab4d852a42cc15d9e7492cdb2453a1c547d8319f8e44b7b14bd990eaa6ccc88153000b126d6ea28f02fd95f257dc334925065e973d27b47ccc5293e926572caf97775cb07dc13598b59f9bc64152d03e655cbc742801c19d5fae25fdb936081442a6bc267fe2526317c57a62d1d53f46712d0688fea3fe674512ad40d056479a307de65acb51018eeba558ad666126d9fc046004c5cdc46c227094a81b5aab3f0d123a8e33850dbe54d3b6c708b346277cda6dc99a02d9c0b259e5007bbc2f31d7242c7418a18fff541672ed5c9fc0f6e9038bfbd1c1dd87c12d9c2172233803de21b024be9eb8808476aff434bb3ef98b42958fc82f4572dc09865719c9cebe149641e5d6549150fc2b130c62d9f6927225984d06e448f0b0848ab3d53895170c521388b8c487b079838206d113a7d67e12f84c4c1b0b36c13115b64b091beb841cc2a634f551215ec3edbbf7430ac943907482da769333cc71f51f4409f645f08c5126357a42760cb2421505112aeb819ec7c21315f349aabbee9d7accc5e95d3e4e9c81b34abbf7b3ec0d7ef775bf49473475359769fc2337751f8fdf1f843f02c3c6f0c530c845e9dab088990393350de8ceea9e93e0a8d8557e7456b41ee420f649f1f4d3356101a9105fe9666cf144a1c32e481addcae65a3abb3391bfa34bbf89b72f01612a3f70c6ed1ae846ca0f2006b0c8289fb78e511b1aa0216bc0474816ab00b4aab5c6b0b94beca7b62592b7f45494945e3040546e00dffa627adae7795766c7ab4d9bc4df03996727b86f9364db641f5a50480e89442247d97cd2ea616c50840efc440946aa8e91c0acb537b8738a451689ae680a40ae355fd69d49ec975d12175841b249d7cab7f7966af1ccac3fe7334b7638b94b270955fcc8e739dd7a35e29ca3f9fcbf2143fbc2e460866872c78ac1d0b8893d299d981370f52bc45f7a471cb97278c0132462eda31c7bdc2bb6bef80ee522c2776f555b9f81bfe588b3172bad14a7d9ffd390fb402567a859981f7b59404851ff8d211fcd7151dbc501945a2aa2ffea2d704819347a29410ed10f7292ca060f37108fe7f627f54fc78a1b0ef5dd17f529e1e82b0895a2e9fb3a546eaed6b02ec16daae3c6e3cd7895a359657626eb333ee76f36bfbbb6076625785985a91dbb6ee2b77ea9e567a2b4da3e553bb8523fa007b0819439a23b0f236b9e226dc9ca819a2c53f0d646ba212c6eb0fe2e87596cce9ea095ea9803304c8f9efdec17f9c03a73f95718f336c4c48f64ca3131b718dff14697e31d262b2af2e8c0535c3f057d329b9e0b68053eacded2781fbe0b4da03de5c4ecdd0b13b704a62d0fcf1c5a43bf069f419d1a1699f75c37d8c88fabaaa25542fa0fd0bccfc6194004e7f857044d2be588c6cb3904208a36e81876ff45151f3950e931e5c7794e4b6145c88079e964e6ec3c5171f615b3b99c3cfdbfb9805df5b6efec0f27fae281b43abe0cdaa3f7e91121a1dc130d6a3608af2c3d7834290c90927341079b23c6643c5fa75ce62b6fc95f622c34742d6f0baaa81aeea8c27566272c33934fee1b6e6b556dd72cdca7d4e2c48eebc7523ab56893fbee9d09f879d43d7ba04d4fc860fd71cfe6504ffaa5f03130fc19c8c20f0ab435830350f27b6552a8db80a363336736c850a067668a3c0af992be9ff0bd2907f735149fa09f874addfcd9670f18f9266dbbea2aa49e4905cd2a4adc327908e983822a2bd979dccfa186e934645c7371bccceb8ca868d087521fea86f569b2804b346b61bb407e7e31f7856a53159b11528fe905f66e46b7bcbea58a1d8993eae92bb029a133aadd6c766be959d0b253144ca3c153411007fc4133081f12f45cf9001a6b3be0b0d6a2abf9b44ddf9d999a557905d2898ca7e2cbe3b53edb9329bc8b7cd8d4b8187cb766833a81654f10c7098457e39c2ca9096deff1b544cdffed8b711219fd0802ba6a0df44fb145f18055d9d5a6ddaf0e8a760950774a1c40fc3068b3140d034f34d7e6e1e21f5a8b715c066961e3d3e3b1f3ecaf8e18a28e2a4930c349ecc734f22e3b6ca8739f517463c32b12d41fb592fa3f4b8d4bc47453de418a0823f5925963e416bd66ffca1fdf11e4e8c1fd48541000b222ec9097932164a47dac1757a17d2e514a3499319425de0d2939ca2de73695221818d84d00be5da71d9df4b1015a7461788285604e5efdf9c5ceca301bf58c6cfae66c59d6fd80d0577cae86c0c64659bbb68901ffe3b837365f48cd6640d87ca477e300790d40361333afd247d227e5497416a9d2978e12bb2004b15e0df5501ab4b10f7234a9520572d894e09c8257c7b8dbd3e35345f6b1361d15437aaef00400bdae73424199726266058bb5577dbda06c5c5f32e73ac7e9147f17e68510b18a9e0f80c52dd20813b55da9142e927887ec2eb44c9df73b3cfd440087a22beefba3f53bb3b1cd851b94d62c9e0ac4d5732f8e376152e88ff784b78a38d1bd6c2c95c83c78774bf19a95f71f17d98cc59a89f3c2d9173bd6ed3cf5887374470845f006b0068a16f4e809dd0f055bc5ee44ba31c6791e45acc5f09d6761a239c48bf12acff76813a1695fb2b5ac0d904ea903a93ccfb124c8fd1363f9f50bf67f501dc1d9c242deb30c1be26e4faf68fa06fc4f258ea6930e67164fdd6b8a330d482755b9836d39484ed5636641f62dfa0b2827c6bec3488ccc6ce0d34fbb5923c10aac62207bb6dc8721ccaeaaf6770c96c918688130ff36aaba235b594aa9dfc8efc8e4ae7a234869584881593bc4acfebeed8fe992ce882c650fd35a578c9d8cc8ed2d1aeff24f5c2f4dae7e934587012b9743adc351371af87a6d9b898e231e516d345dac6ab51c2fb6319263964d2df8eab34461aa34339ad0a165f148ee0f99ceccd208a753cce2ab12e2279dc99d458fe89d7278dd6f663d76a4a482c5704028abd8528b0deefe79d76af20838c32af25cade4805213f9e5f8d99d2a9993be5cc9db82145dcad8a31a00ac1470b42c8d312fb310b3ec48cef6fcf5486f556a8d3086820a0e016628b70313938f282d4914798a1924d4a3282b52387664969911b5bafa08264fcd224458e28eade3380ef214e76b2f451448d34482250311bde9de4e49e25dd8fe456f8f344c4d4a23d0cdb6a2e8cc55377bd39ab7e5a90411f3218232ace928f305c70227f141fafb7828e00a496f5c1e7241ffebaa47bb33b349680550fe2a5a40dbed7f7afc99c54c756834c7af6243500a440ae40bf1adb0251a7de4379f2b537c124cc9e7be4ebed3830e31217395e4858d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
