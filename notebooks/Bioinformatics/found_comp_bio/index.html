<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ea69ba1a416e207429b912801048d3cfc14a48349640c8d4f5ff0e7b3e209bb6e2ff6d45191f3e7398b17406d34f8cba50e6b666f23fc7aa6ab279cf6b8389fe290e46655bec6e91a68e194d5f7853c84081684e60f45036bb5b404e8987aaa764b58d700d9c03adff08047f6fc50c06e8a7aac50abe56ae2a5249366345b53294594be8142c044dc0722102c651c7ec83f23aa8c72da26b38a94897ef23403fd986a3b163d689e502ae20fbafdd107c5d6bcbc2cc534aa3656fceff0dd592fc3edc3c1f7b652fee62fe0177c05c1cc45ce7579850a1e7de0e69a7a5f5e2a7d609af54a1be9bc936996fbaa9057e00437a3449e1202a031dad76f48be7bbaff94ffdb6599112aecbd134560efb4f6bfc8da35afebceb29565098080c494735cd6fb7f729b5d097c18237618a482eef588671e86e6af2fdcf9c5cf84e6cd1cb2b3e195e386e07a95dfa0d76cd44f81397a9b5f0188ac095fad23344904558f703c4e07bb1eee40b9ede44ca5d1365178c6672e601f275ef1bd3b398cb6b67a3388aa3efae20ca60cf7b7dee52e671db3e7813e32ccba34987a083f441c2e90c09060bc4c483b8429950ce7f5b61147f129beca76bf2e423293d4c5aa9f5a4ae6a765e45926072f55bd8aa2099dc38da5cb0355c9ca8ada9edbccbf86f5bb7e7801fcd238b7d11e15a567d7a83e6c12d13b2baaf3cf7bcbf68d4add6698a2039af6a5e402f5ac00517464793547a1c6dfe0e6b93019bf9e9b5fd1ffed6701fc63eec70fea4f73b07db33029f8a310d2a17e1b97663a94faede1e7636e4fd78c21b874fe8231c00c9715f20a3f49d7b6d65ad81ed3ce5c053027615ac0a9e19e36f8a709007c7c26c3bb62c54c8cef274c06c1798701665e06b96ebf99bc91c4a76de83edf72f9afc9e7e2ce537adf012ed62f75d5585c139b476c9ef2f506889b28f76bd77dc04a42c39ba50487f06a4384f063b005e5465ede300cddfd7ae7421709f996424607eb3ffe748749ffaa7998bf163a447983617e62c0db31f84475814cc5674d5a99f9ae36ccdbb093611e67a45309c8f6d30523fae622ed7e58be08b7e56719a8516b0a56af8624bd0cf1cb55233f38d17771122abb4bb88b55f18a6c255a280e4a9f670d650c86376c3f66625c9a391be1056b12cfa3bf3377ab3f1c10142e2d7c174c0ec2531ad61287ad8433d8024b81db91c2eb3d2a994a378acf1bacd892b6c6dca43d9faa0cfef8a1e3ebd2a749c2e8c773e0dbf4ea463bf8008a9b7ed7ca07aeef2c6ec3f2b76dce0f10b3f7cc828153d22196a340bcc418827c6a775a13f413efd218b901cbc185ecab16a0144ea389e96ef6bfb8df25e3c960df43d3f477f4dc030cf95ef8b81812c4c491200cec28446610a072ccdb554905fa750891b53096f4f0558435232b49c1f8f609ad3ad185f0df5e59525617963f5f6e3dcb6feabe6f58d8cec99371616896618eb6facbfc64dcded20d4fc5d909dd7cab2cc0bfc9d74caf514f2d1623818823361d3396aef6a0c8e19b1ec24897b17e07b99ee6ebe84c5616767221c6371af109ff6bf156675c438c644702082616fe892aa18c095691e5002e4090b9ed3a5a3be60c9b8fa5c6e9ba487873d61b748f73d88014e4dd7da2bec817987fd2b64fab758d7b1d5e3a4c86608944b5659c4472ebf89c9b02db47893ea5642083f0842a798e63e7cd1b11402d3bc1b9adc448bb8d9ccfd1e1d742b2e664967bb992f37870e3b1efb80d05922aa0f6806e677bfb37c8a488349e59ece5c85258dbef8f66feb0b6e9c5a04b0aea1af6456e9d8ecb8a1704f1730adbad3221a0b656d03c5805048e2442ee49ffcc0f7ec4cce3086c8461479c971768ffcf4c44f5e05d2c6edcaaddd76c1942bda829a7205d168fabbea0c307b687afe479a6a4d534e70dfd52a212c071b89c1e01105b5019af646ba5669f6363df94b2c8538a1a151ca8f3a25f05776aa080dab35816d853e80b7d6b0f76e8ac0edb56227336ad5229298cb66ca188d17394f609fcdb7820cd6cc52c4c05e8762e5da6cd6f4f11d8a7281cfc116aff20dab7b729e90e47a854ded40d370abea20db198bd2469d1c3ed349ddb3ef75376b278a83dcf330d96a8e3895e0f058eede242252b4c214846fdc3de9ff4ffaf3ce7b62587da9bea04b027d85b60a267edf4d4e45eada71b3fb15a2590ba813e3d0229ec2ff67b32846a81a02b284bf2474cbaf2717ced573c8ec2e22e90468b04931f9e4438ecd01d98c139fdf3992e1778d2dad041bcaf1c6b96ab4b997f91de82e340035466d04c0f579f396fc62f7577ffd5d159281ea2cd3adfdc57f9d0e615179aa40148894a57f63a629ddf2e97fa8116babb41714b26f3110db386fe2801a1ada27580824c721a470d6ef30ae63406929da83673178ecf6994528c564adfcbd0b5662c5e687ca6ed7c6264a88acb16161e93a6fd68144d668653bc7ff86edea80ae5e06b3ea3373dfe57b2b02cb5302ab64660b4675819dfd8fb8bf339546a993ca8d461f999bfee9e9f0bbebc6cb67c13c62e57b9516b1170d5f6b4d9f61b1ce9705001a58015c09e6ea89f3f8eb505e0efb5980d152f8862516d5ce83eed71a69712d4578d0189cb4062227105fa0131bd9188ded51aa5f085cea5f3de4dbf455f233d51ee50696c71f3bf566d22833dfff9fb0e6464f910a3a77f99bc9424352b14d8e435e4f235ac1e6453f8204fd93c8837cb5bbb96f113d1403251302c765af7cdd9c4f0282425ed7d4f56f413ea67489f145a0cb7c25094b6e585299d60a92bd88b6c316f878df3fa77828acbdef1bd51098aa8efc1625a1c62e25532c8747ced8fcbc71ae948b6c6d08ce3a5235eba665ea36553ec091e254dc4c613f90f230d1242a58de4c68edb8835f8c20583cadd006c063c031729e14a70c161efce8cac5d5fe36b58732f8b54385b9282f6c70c7e326ece1c2eff93a88cc36de9c61ed0344118b69b14b4f7b6ac9a95710c00a3576e2684e5830f43e401ebf7d4c65b425e9d6d3a393147d03fcec8ac428ef48374b026109ee9b322102d72462f945d9d13d1adaaa3a469e2adbb85ab854d1372c7902c67f55af2ebce43689e136b9058323f375b739d11c33c2469584f1cbb86d10d36323848d5596cee1dd18880ddd3a4d854725edcfd2e81ffade199f681b3074498de78288f5695d25a14609fd529208a8049c3fe7c18e4cabceb1c51ca3ec4f3035a6d390f5b9078202d4771426b39cabd7ca17abf8b11d44e796df86273ba1a8c1a3c0306d4d12404c08714ac22d6deb9d1ddf3d9ea8798e9b0f21cbba72b3891b9a7f2bf18518f957422b9ca3f40c5edacf10b3804519e922d5c4a5147e6c5e8d8a85691ad9db48aa198a3f1f16c6622c3e095ffd4344ece1a88592cc46b79a4516b7868608d42afa7b1c3d1c6145d1b3cd4fae3a3bdbd8afe6698c993df1a9ab30752363ec6cceaca8150a52f3f557cca044250e423e27b6fce78075d32a8f1164ff904b5ad8f6eca6ac3f4d726477bf54bd892a6a4b517cb5357a8c1360c5c31fe458e61ef01a2e14fa3578bd77dcd159a0f1f1c67f85b31c8af2eadf99d0ed53843d6b20214a2244b900180cba16ccb2f4c95a5e19506c5bd3ab2bf999bb9bab05b8baebcf91cf62bcb774ae16334537966eaaeb56b6724f50560b0485413b78ee80d511f826d9308c10225c93372675f4cc9b2c729bb8f4e18e050fff6adf054029aa9b726fc8bb092aeeaa60d624953e2fade901948b18b81bfcb0706e6f36f693eef77c32819bb98405b589888101f7c60aa1432816422e7a16120a41feb9b4141121a8c8103cbac02242983754c48f05d57bd3fb682d47ed378245bb27bd066efea5aff78fbce9ef95ebb48cd15ac8def3aebbdfc700a1416d0f7ca3be0975c24d2e78893ab31a4e90f128f196b2579cb8e819d7a29663f0cee2ec948926be6225d7e4b83d2da73a4322526d7e7a73fc305be5973c0672fafa4d7c6590090219bf9f51b691d2ba2c408ab1d1404d32e14427343437d49cad7492584cc629a5179720d472b6f049f572d789162ee09bfc183d460a3559a29224d580356989572fbc765e5774146b241abe048fc51d3cc3bb52cdaba762d5e6f3a25fa5c9ab336834d7d2a99415762b91d442db927f8cda8d366a3e8e5dbd35e10c3d23ef3f99c53d673d699e9af87ad4f8ed43b7f7dccf0c4e6a9312dbba4a7214bb405dddfb965ff1dc6c83c4a9ee0ef69f53f3a8947e6d074d665fdac4bd60c5566cadab177742b1297f1328928bfe929607903154dc2e1bf4c34063c903b3c20b522a92db7e610a5cc1ff6966bc5b854beacf04ba0db3acded8baec0675708bf41416ec005f07b761f4d9dbe46822484b2b592839ddb9c320389e3d8c6a5a2f47bd9f50730eb2de8183677d529ccce0fd04ece61fdd629bc5f5284729888e02f4679f55dd7335a8ab50f780dec78473e46a5ce050082711c52c0d621193364b93ee0149e40e421f29e50a9d71ff2fc7e2feeed25d3a0de999d9881ecaa74cb845c797609289c01cb1532f891d4f024811a841f31fb6a68059329f17d80068ce7713c0159f7226235f8a8a273ccb2de07b338b23ff00dcde61b86320cbfbfc41416b779f93884e3c3a6fc803ba9d3f7d819bae3acd9be28e269e74781f19c01930e0f26356fc31772e5c5a916cf9b2d620958d9c8b10ed31ec71726c16a101c9d20ce27bbc07e15d0a2259d66589bbbeceef91965b50a03bc5609f5c170ba5690a46537970402db78e231e858f2c6492025040b2cc1863742606d1faf82d0a3afe514f689754dbe9e8803b0819ee8dffce6f10398b919a3ac9a5d9d2c86b643893d49857cc577c54b00a0b84464bd0a733459ac607ba93440aeef24991a0c40c50536b4c1b1dc7a7798d2bf6e959a87799b2818ca70dbb4fcb5a5480a5e2fe7c2b9f2bee94768417e73a79881a2ca8e5521d176875f642ef4862dae73ed09083b1c158452c499c7e8c1689f39619c5d3320f1ccaace8e8747bc3c1f1408f1dd2495e907ba2ded5751d24f650ffe351cbb869bc5f7cf57cb2fe75ab5809e1e599947a3874ca0eaa2cf04f3593f10b6d1a63431137698eb6d1f7a838a71e1096022e241f378aa20ce956a7c8a949bb6368bd8b7dc8608da1d14bdcd4e0eb2bbc079f7245aa6ba5f1952e7aa19a4c64c5d4cfebd8cc9f30e28b3a9b326560f5541f0a53f7d270afe41c56238cda4fc863ddd1850f99eb9d64e4f63421d98528d40ebe17750e90fc2435c36916f58e61ce86f6a64272b1f7eaa67416423f99cb4994ff6b87974d7776aff70cbe4826f49da073ff0fc9d6ec310124cb3d3bcbf0363b9a529f9d0a1641003dbe13f009c5ca9813e7c0e4588b22177cabe135456968f89f01b32caf5967f31d37ecba635b25f12aea308143ff2044277517a523fdc50c58d2d2bc972a84a2714ffc67b0b365e3f26acd11220cc29b7c39d6062172e0ba56e1e7f23f16ee94fd8b18b6d54bf9f795f8ee6f56598b45b85e4501df1441f036dc5a5c591577decbab754debf5595f048330dc87f29d0772ff489314ebb65bb13a3a0bc379aab902be86d1403eb452cc074372f53d5bae4f07e024841294b8fbdc51555f1f6a8d36aeccf547ab66817d10b8d9a2d43c3d352163d8562e1ee5fbe0303921c16aa25b3476225eefba594a6e2dd540ab14be6f076dd4c5cb145e02e2978ffa4b6e2216e338f5a5d35d919b3574864e9e56d5f501267f60990e6db41fdab64777f82b1822c13bfa7deb6d2273d3cbec14a3c1bf9315061a3a2a0c2cc06ac9b6153678da1c1cad00512fbb8a1df917d9d9133e0cfbdfc9f7f06b7666136317cfff16144f5008124d8f94a7eb3c7da9db4f3c8cae3c87ffd8fe70b59fdb9949a270273b928162213dc7ff943847b1eba4cd03e243ce0b87099b80fbde59df0bf995e4e73d9ae08761c3c4101e13d28ee512391056f2b338e299f132712cb594dd31ed87662f907ef2000bd500e790b611eb0f850dea86bcc6cdcb580985159acb067dbb4f2545d0bed07f5c4a9c06bc96da628e37259a3681c822a18de83af2e1609534075dc60553a1c8cb948f4c1a91eb69eeff923f595302d7be8c781fad9faf1b79a3ef74ccf23ed6e7896a224aad5ad3435893ec332b96a529104feed136fe719bd81681af8e61445b949f2e7cb9149a613d20c0d1cb406f7e9672107a02e3ddf8150725ba9fec36b410369316f41a59bc0f969f4a8515f6e6be0b6f5c9a2f6582a7d782a3e2e7a65cf5cd280f42f90cce89ac9c7999491efc8097db918f72bff5fa8ac48e69d3b3b8d770f5f627c26dc74b5d35c54a3098ae6b636247633f2b95eb1da8f76f696387c0ae0999432c8f939f28ea0a029f37928019d5aee7d06634541aa14fe0fb5c37e10a4b5139e14800d6fa69e7a26e6d6635babef14f54eed786b566fc8d4bce9d2aaa13055838a1261d016d7f4c403868c61b4db83a0968b4ba639bb7e7b2f589e2a8abee2e00a90300d5582dc9e645df2d90fd007523c6f3abbec06196d6edd6060db27de7525200fd349548f18e0aeb417a94d7548c930958e925f86c0f18a1b798f0726aed1567dd2386b482ec9e8217548a704ec1d5b0fb414268e611c689e481383ea76cff92653fec6992b532806ec525e0eaf535f20d4647b1a41ab5847755b07c69f9a15a213dcbe8abbbf7e9f7f03037adc7e1e5a21344bb03f697ff55ef1fee1ff808a553d7804b92f595510bf4492569fae8debe48cff46c450bfe4c91492a1b94a22d5e445e37a699b7580d2161f33b88a4801fde93ecae922a65274a98b8e7f592a8c3fb972b5c9c0e087ca5cf54acd7dc2b9bf998c438c8a534aeef5402ea42e8b7022dc75c55e2207a0d04b5cc31f91b689b6059f29e4e4f75c8b03a3e2113eff2e9a5a84e630b6cf7e5c526f089277002932c50f5ba4bdac3d0eab4158ba72797220fd104f77af0aab0d1dc7f238c63e221289336705dce9e0352d31597c920ba241131f7a911335d8a82f4f19a278efb9d114804e01ba6ec0f8158ff9b9347cfe9634e1adc6226f5afab5d16be119ed49c9988df06e733c191a811c778fb3f48a9a7f629d23ac59f0a4f096180b86d94c97562bebb69b2681a630ee87f8024c144c0cd0ff604434d976709b0eb8086beaf9994a2f30448260a65288277cab67947fa2a857a8ca85ffeeb8f81a1d898969bd27de87f1fd37a17649f32d3df979429fe5500667ddd4351e4913562f075a3092eeef38823b9be6d980e782ae1dc5c2930816786eeb9c20c70194acb6cf8496d8ea2ec740267c69da17a80650ed5d8317304e97968b8fe9d3833b6a2aca458564adecfe8f6a071184adc09d6ce5ab9d9b43ccdac32bcd43ad187170eed169ad440a235628479bcb24c1f2ae0b1529bf0bbe851329a89cfaef16b37b0c06e8326c8f5a19f9a1ebcd294929a33694349db904503c841f9d5baeb9a9fea347feedb9bf1d315bc3ed1bf0241e4406dd09e957a0837e4ab65c2c6d4a30037b0983496f5d37a2caa944d4ec4e372296162090f05573811b61ef8c274a0efca449c3f4349574f49fd7bd956862a394cca45f1548988c285cbcb6e8133b916e5341fb97b0c581c1060caea3201443d11f0c397ae124aa5f48d7e420238a639edefe345311bd483e34de83e2bdf89246e94bfc677b3b3a8d7887c978abaa33c0cba7d7cfcd256cbf7fc346062228656801d670f671dd1ffa86a5258fb9cbf07ae8728ba7e03315c4f6212c82082613b576eac54a8d656758a8005dc14e40a2fa4d67edff00ccb008ae690072ea4cf0576b3876088ee67d353835743a4c7e680e4ba8068c9d10653d18848b2a5cd4f62ad956381101ab7627bb58101d1025a84375ebf009493fbd2a3b6ea7ed86feef26e14af2788e2403ea80bca1bd26ae3070cef47978aa74f50de73af6babbeeef8f268eee8bbd4c736daa7a9c8f7b474c5734349ece50f1525beb9b1d005c3f11fbf26df6636a7794ed76aa5819565cecb335a0bf6f6d1cdbc785b7b7e8c8e5de6cf11e3db02867ab9048fcc487d4cf83ba6c34744d499bbbae250ef5bd9e8ccb938075fdf84dc51d1682d3d710172e9043dd42c103217185807d64778cb19db47db3332d307b7642a37321a428f03191a1fb435d1fa0bc137537abcacf5d4fca99596983d91dac49810fed961636186c052c2f02a3d97fd32f175637207c78b285796a20f8976c79a40ba281add0c4d558aa0fb59233dab859afb859280079ebcd70eac893b2e655b33079f3589dcfd7ff145be832a4e154947bd6fccef75f3da91036f8172d09685f497a46fd9b043b079738c5f1c9f9c5ca0e4452fb527608114c874aa2f2b7a5ffbcb70b5fb5da744d664926b5838d28c8d96bc61c011f73cc142c0a691b3bd80dfb7c44631e59c5d594e6ed94f06c43602add3615f3d6f20d41c38e13530ee42b09b641c81fe89c02ebca7fb92458e7e7a56bbda79ae13cbcbe3c4d6ab52bbb178bebab25bc0b5a9edbff07582d0ef0c5b3c9cc4e2c394a7b516317e52f2164b3ad64898af1f96e18918de0d9fec098486571ae66b546bd12c5be49ec76a5ff10de7bf33d65a8382d85008008f46226201ac927a23091bbd0d839c4288f72b1df3ca959dd48483a4afbc9fa1ded4f135f971deb1a5e0b29331b9145a6379ba9a3d9bb5c451197f569d029fc39e5af14bbf47b178d4fafca3c8e0a6835cf0b1e578fb1d319dcf19bb05110b18a16a881b2d503873b4f56352165ddc8cd08bf8e03abf5aceed3af928ff9ddc04ab14d838c9e1c7ec78813e21c6a72bafa1f596159d9c4107961cf833210e84a76c0c1b96ca13561a3f288b33b79b6cfc787b1341f25e957dd8a0acb5c7420835e2179168e9235713971f5d59c491bf09d179204e93c17247e3011fa46ddce1d8050ad663267f0f9ff3c84becbf7972a079d57a7d6a9d48a9c3e58de74a34175a041f395ca390af7cee93b841cffe2a06e3d632b480d8ac6a9a4ea49036c59794c4f5d03b4bf1fc044cbbc77484a92ad9d3ebe120e7e5961c68dc1ae558515ecdef07f5cf25be1e69f25a1950993e25bf6f06dee0152773910cf63a199190eca13bac07ee3e965590b91938de9190b9c8c8f28ce79165fb1c3fefb057ff15b5a764605bf51ca05ceedf3c7cc56e60220d642426cca9649f504c7b03d1f5a54f1c0cf2d6f2fd34962fc360e7f16dde06153e6e95355756ee12baebf5ab38a55730a136980d5e6014e09b7534cbaa2b4d18426fcb1dd5ce407d4d251b1ef6ccf8434604ccbc5de713ae9f859ce196050513f258981a3c043c1198af0113ca4b38c560179b2e0d67575983d68c8aa5ff69a5a8df76fccfa385cc03ad9324cb5961720f8d35679abf3a330d4e0a55146478741bbc07b6faf1d872bdd18be45758e2810d9079320d258999cd8ebccbbf85d7a30acafa79686a2279019ed1c62dad427aed402db57201830f91604bd057de8172f32f569ff73ea6b0cda0701e352c8d38c730c8b932c3fd9a533b5a370e368124338712d264bbaa80ff6c3d596b6084c57f1d2a10b5400adda8edb3da1d629d47237c280a808cc8b477b87952abb9203296129f59c346d5305bfc58d7b7ae82d85abdbefb6df2af87b4bf09cd88d9266cb2371b53538a593673b4f8c2378604c56b3a7f4de5fbae7df5f3a1877362f6d2d0a3ecaf9ca4d072c3051cc94845c3e17b8cb4153a89cb44ba888b1b2e15fb39ef4ad9d8d939f094acdbbfe235992bf9fc6a18b647bd21bd6478ab22e10a864b9bfc88f46f1c4d81156b3c7984d0b783d133b9d220b8bd8d0f3739ce521f21a4bff4dba80c5f24655dac42ba058ea5cecbf2d8d9ce2da6ecc6ac5104b86e1b4523ec2487abf289f9f1404e9fe9c06f56114ca821c378207ae782ac86d770250da9f905e2927341d87969467688034c5f177bbc2fcee45bd104d0da8e3d73a91ce4f9fe62c51d41cc844ee26ae83a1d5dfffe28f0b957deadac86d9af3fd743f8da9dc893c208de56e9edcf38a662923da15903e28afab478959ea4bda0d7584ff19f924701e35a9769a412c93cef55fd760ab7834842c283f00af537cf7838c87be42d37e91fd0098950d3ab5c3c20bd96c48e67f2487aee4b773da6bf728570887b535b8632983f07e4ab85841bc3c6ec030e4915181d72cc905ae45a1615197a134c2f38703c0e869a1148e7b19f775570c7aa5f7913039674bb47c4fa37fe034a17bbff9d746feef30fd33c5b7606b13c3684535ece225f01127dfc63a3290ee3461e52b4fb0b314964e950c464ba857a9c9e78eafcef54e087818b63f1e3e5dcd55095a19a19ee7bb2a96df2440c261aedf142df2b951a2a548f0905444acff65299913051b321f1bc6a70644d384babeb63ba9401316791bd6e7ab68e1aa362c941b04c250ee4b80e0d2a3e4196b3236ade12881323377aa6c1ceb58f27ea3315b98098888790f585c74a0a8d22de13547b5d7958eb3d34e3adaa8f5b1aeb562b3731afe3d23231a4b068f22a86ad54828d17068dac5cbb359570362738f2787bfba0d406af47b2c62615bd105e3ac64215f02fe643e62829a16ef0525e300a8be85ac9ffbabdf0bd15c7f7ae674eb484ad223ea4d433d83259dddaeabaf1795b39b71c1feb3dd4ed78a138a4e86e320c6a01adec2ecbbac99b5f7d9d06d1e35ac1764d361a016be62a3a7b88ee8140b081f73c01f0e991deb10ffd7dc63be3dc1a435a9d71deb17f4f0a835612a4c94f3aa1ee3228b69a9ee60da0674402c46cdf3c8086375529f13748c4f5ae9c7c5e144ba1fc1eeaec66b734dc940dea6c4f52e573a9f2d00f818e110f39e616f4bf9b2d28775b83f127e31fb6e52ba4f5ba5fc44999c7c77f94029d523dd3d4402e8bb7b42ed27c57099f23487040757fee6d91bfbe18a7565e3126e0b58fadf527c7d741aeb330de7664d2660ed783ac3c3cafd2668d9a2182e6f907730a479b9ddc95de3bbeb78ba4671b0fff937587be2561981dd83d6ee0e7f3aacac7accd68c71f1133802ba9c70a2c4c6926f3a7d8500d3398d0328848a86dd18db1b99249bcf7d2282e5934a53e879b27f96ecc9c936bfd8a096c8c33ac0d8e0f489af1a9296aba4fc5fab893643d314db0bf81aa4f8ff93c856d83bf53631fc7603e3f128bc30cef8f452f057c7dbf80eda9af822c28ce2fdd4d489afb9267cebc96025fab320634e52c70a4a7e4e646bbe67b3b8571c58a5025e309f40a86aef2328aaa0cd81914eb78798545b24fafd9013f1bf245c3fed81b322c9bde3420eb8179e5265f889440325399eb42baeb4e1eb2030d846b41396eb02f223da366af86e62f9a6fff0390f456bc5ee2f8141bc1a37865ca68865c08b89155a89d58f9a13a7dddb7587691f8c9ca283bbd13a2af3f2edd52ead25e330670788f22db8bfbc3e1ce96a01b1d88704a4bcc69d5b53723ddc12bdcc1ab1c0727230283b5d873a97ab65cdde8795e65cdfc675554ad669469059e6996418aff2a08902bfe36f7766ed5c03d3c06cb1f7a5ed489b11b1dd82eac6c12db3c4cb041a40587112845fdf3ac423094a44c326b6eefb4844b37f3b68f3570e3566d925fefadfc8c27c72032a1e87db11703e3da15f9eac20489ee9e0a2e83c3270e1bfae63c62320400e86aa8e937d5f5f2fba81223e5d1b4d45684828b598f440c5f23fb68e7fdc5ac4792ae2f0821a9d15be89fb19e098dfbcd172721c0899d3e908915b7e5ecffc2fb3241aea7afdca95b4d7c4c6a455c2e9ea67bf9d7c5330fc5ee54ff13d4345389380caef9236255a8b7114a49c39ed391902fbda0f8ea11424d1cdf79e99055a7a349c2571c3c96cf52e6c83b5e71bc7dbe9e346b88106a792409f205dab58b90b1b265e4f129335aea8d2d1140e059166417e3fc1292e288ba97e75e9ad59d2f90838579cce971ed93dab34711169a5f50d2b4d1d20345ce37b647596a2d6090fbe784e3806e6270c81b7e32fbcc06cfdf3e601d6f01844b8dbb6775acd64f7f1125f83e78e3685b74327077c6a8b4534283a201905d6637fbe32b11649b9c015d2b73ccc8d93aa4b8b93bb361658c84ed48797f5b93bdcfb34d90d0b8a96496c620166494d94f319aa202ff7d1c7a11cf3dbf14cc618d81f9f8a99dc165b8d03725f6e01c7138be6694942486078336c47cd1d91ade3233f4df79192a9d6062abf928be79e4333ffd02f2409b64fac48afdeb353991769093574faa2f4831d5e75530acd21f07b3b416e2d26a57398156062b43303806e0ea8ef1bf9260dd238c70dfa65bf52cb63c484c60cd6798c11a02b6e6f6e7ea8f23d6b9e45ff501d09c89a18453b25afcaabbce7274e6a81eb562256d3837b5c3ada407b2b5f7825b981b75fdc2c0ee1726293b4a38dd82a80cbae92ae9f7f58648a8f560836639b1b2fd3ea1382210e2b89d7072f7b0a67da1b05e2896a1676cd4cde4b845a43e738cc81104f149546a3b2d8e3aa86f2e134e9f937ab83583f68741d0d6f3988faebe9953fe2ecac161ee7d89ef9ceb829d451e89d71b610e4ee83d9edc524b3d73cccc4517dec8efc31c8b67be9147e3934aca35a09548a2179277ab11a0027a14810d573318fbc72e561648b73b661fe32a817c3ab6c673609b39ceb27f9523222c18e1611501f6a6d89793d3df056753612de4cfa718ffe4062846d59d791efbfe634236d58176f4275bee4aaa87d9b5cc8aa4556455ca8894f15a857543f37f81e54680c7e2f2e29cad5cc558e5918e4b8fc940fe88777d505d7c5bfd53d084cb9b2237ad088eef7b39f646950d70aaf177bd0e6ae6cc0f66459e66816998d73c3dc0be79a544f8db7fc7fe0d9cb52c4cccf4526efda79b9b503f240cdbedc9d53df3621d7d0e193b6946ac44c323fc12e792b7b009dc12e46be7e571b0df5048abf7299678c8a51f21c92d94d1796281210a348d863eed8f9b9027e5ab6fbcf27b5d412cbcef01284f677f5e9e974eb3b1d44f4a7f8519c02ef04eb978bbf419f4cc0816d48abb4d268943a93ed74c00a595c9a810b717d8422708d8cc6b7d3103d575dd539a603e89aa051f118c513cb04acb9568df2c6e3c111865b46b69c80443b26a9244a13848a9dc45f08bfb005ffe820f89bd15447abb60dc7c9da821279ec52a91e314f7329a11745bd2ee41375d62aa1e197447ef3ad1f93e1e6d07e5cf272f4824897c866aea1e51f7fcf09c6289e8b25fb11905abfaa9efa57686a8bbaf5a767eb2bb43cef218edad83973ff0daec00f5d394018f0a311c8acd8acaf09e6e262cb5a8d0c32ec79cbd8ea4dbcdf267ec218617548af107a327462977aeefcc7e7fa2676148fc3c3e62ad438eaa6f1d41d3c947deefeb855dcea39f85b6417337d715048b51dd9d5589ca43ca488dc4b4e441fef797459b2573baf05521b9a7fb78d2e7b4aba991101f39d004f9897cf8c714d87a073007887dc3fe34a3b6d48a7ab169111bdbc512b3dae50f16cc99dfa807409c602250a71a5f30bb864f71a585146fcf0f414b716cd3c10023134963e18296fb56417c7b827b0159e5863205ae0f42fc5a2bf9967839f631aca21328c5f513a4898c1031257ed22f269624fbeae9f2342c5cea9f4db7f22c8b90f134df0c1f47974505ca5d201f69eca958fa1173af1b236b208cf2b32c1cdbd5883cc65eba8aa5235a129dc552822441025beb53409e3086d22ee4743f664ee06b0c180972a0da6fb981ae625787ae32731415288381d8ed7d1041d7e9f4ada17b822a6013bfcb1a67f3070daf14966b1dba7e1fe45211106cce919d53063776a17c9a05224d67172dd812258a0fc6d958d27e6471fdc71b04f06d6e7cc523fbb0f49825bfbe398b5f685226a191d93023fa42070e55f32c540d5434701f1231187e457a98fbfa194119618d3485ab855a6bea1f6a3e4edb31355a170b4df46647647db874d7f0ed4648b86e96f7858131ddfce9523612cd5d6a7c230529c72f1f56a06fc49ccbbfdc8e0ace3073cf2896804cc94c5e09f1143547baea76aef0d13f14697cc620f1aad3e141ada03e5e6cdaa98bcfbe08166d3233ee1edcc00308077d72244d240a4f788aa23d95996ad29931473eacf9f5f1f0a679644a2c9638423c2f101387602c398f29510298116a8f0655a63bfbe30335d47ca178007175e025e4dcf58890452b4b5d37dfec2263fd9883c087fa760a973f33897853591aa3e4ebbe16d684812efd4a2ee43f5ca9d66f849b1ce5839d5815be9c5310326796838ed22e1d0fcc145ffd3c81bd3c81c1cea08da8a80512df55d3e10296937863d0f7288969de5c48aa719f05365bd399489689b59e6c639b698deb16d8dc710b79a9634096dfacf9454606f1598e2f3b2024c48fc01fda9071c0799697acf0cbac54b8a74f8c52845f35f53eca54e67bdf76a2b73f8efdb401ee9e0d86955fc19f94b7ba92d1d3e334e8727b6e26b64b6a9240587ae59daa448dd5fe2179e52b3905a0a8c7170f6c37e3bd429f8ee21cadec4dbfa7220d54f723d2d03219eec740f6c8604cc2ea235e47f6f565d1003c84ea77b09d532baac9ec111e302edd0b7b0947b1c49285c1acbf7f53b6e06ca3d5b4baf7efdd6a7f769495f81bf4f14b4ea8cb9881da7f89a78508a34e2486edfd04b867cf111fc722e133c9f09df2aa9193d982c0e51ba7a322332ee120b0dec97e129a87b1cb9a6f4c3d17d722e1ed3bd1ec1cf9815f178cb67118b1790edf5c5d5e2b983edf947e24e6234dfa6cfa94c6149a07badedd57b4d31e0d76373a35e51e288ad3dc16abf29b3811e0b33f3dee69b31d2d5edb374c2835d7a5df9e9d310e55548b1606509b75049cb2312e28724fa9b26ce187c3ec482dd4b145bbbb1345d0f788a7de18003cecd264098153acbf7ac9c6507c05d3b58e98f07111a73552bfdd79bfea938df16bb4b12f52b14a3b6000167c8cbb2bb49bb14abe725ab298fe5ff8915e6d17bf7c108098a893729ee737801ae1a1c453220c1822ca89e4881b1782bcd8b3d5a7a1fa256362f3a8ee859c2dced4474763955a2b034fbcd8e3c9a8340db2bc156764eb1056f6556db1898e332331c98e451ce86ad378923caf136f0f642b1524688a7602e503195b6dfcd24b731b21954a3584628d719cb55a2a16024441e59170cd4790a0aa29574446b16f4a485629a64b6b08be4778ecd9f218021451c314f5894ec3eaf7ab185824199b411182e51701ca3bf2fb871d40f726dff0f9d48999a76a00f00f8a9f7e7c2a4de238338f4d12ccb579db04f17b44059158db10b2168d1f761211c0983a47d8c90564c6150708a14fd30339d19eb45d30ec71051a58001b04dd88d2cd3dcd2c9b15f8b05c2d16c8987ecf9a264b821ca164c2d2c8f87fb507897dcef632d18308098d4978080fde20cc3128ca409ff58a30a79800c510f93eddf63345808f4d2227c90eb65b1e2bd4e8cd3a25bf020e3c5662f904b504596a3331880afc59223872927e373f780fc95c4066bc6787f651f101b91ea3140a45cae50b58b582211ac40fa003ab736b82ca00fb856a7a677ed07e54fb3432a173ef7eb0261f188da09bf9ada9eb2dc8eb0d4e4d7a3447d20c34fc3cc189572d6d9bd9c661c4ab8712654433ddd0f25992422440fcb668fa9870373a599d7a538a50e89f7cf8b50753ad5669c1c908d0498bee924f1d0910701aef40d90b99ac0d92c7be446f745ae980c2526912666a60cb4cf26f0cd2328e4d53cc4f213ef73d5811d2a4ca6c9162931812aef7f3ee35547f4542d6adadc9e19b66b0e4a44083d3e9a4159d833b5818ab1c278e051b555763690307bfe04b5d4db8b2b9b382f738853bfa8562f05c8d527b7273ee14d85879f00c47dfe8004b25853cb001fee415397b6d72d4182b4057e6c1a7b27dfd825bc25b2db5df1a5cc7b313f781a0a5fc27648f25b4bdd4f80c68dd2725d61c9538be44b2569e91ba01c3f1d3d320fb7283b928b8f750d7823919275c19369fba4c51f11cb9043ce5561599386da5f418634b70e840259d430d1cdf6f30cecc626ff349353c21a17c31bb6ceed3ab8327e1444d183a31f62816d74d9e678ac400e5dc4a95f4448e7bcc136f4cdbeff670edca95f10cf491a5eb3fbd50f695599c5b6d9b94ce84e1f151f4bfd4954ceee710a5a5f811afa2bd66d82536885b8686227f46e00681244c2ec48dd048f76961e80a4409d5d11d21a4d0aff99f5a33d6cfe2689197d22b55a1d349e5d0553616e67b816010ad2bf22fa2c9b1233503aab17a4f78e8f9331afa945b591a7b6599af7c4d1db1a126ddc379d47c92baa0ec014b9d19574169ecf4c37aaa73a50a84f4914640fbdfe94501ddf249fc6404cca95563d7f1c507f6e7aea570a9fffbc9e308cf19e1c723b8e56ff6ad727d8f67ad87d25b52a7cc979a5aa943679f1eab979e5812386fcebf7630487d29f64cf8febf1c4d0ab4251520f416200033511df114b99a521bcb62622a97ac27c4952355532269c8a97050a2f4aefa378a0b1c16da4d6de11e4ade57f2f8ba906e36ac9d3c59ab896aff86662a53e910347bcd6bb548b036b038881c5f984b10a75b755bea83a101d21681b9bf8e993d7d8aa6e8df98d8d15aa4c9c4a9eb1bc941fb446eb1b307402cfacb2dea61c45659f972abb81425fdcb707d794111ab08ecc6b17969bb33eb3ed47d8924997f9d1131fdaf0a91b7632022543d3c43bcd398b903f0c4400d6c78250d031a20e99520cc21aad9edb3d0da76797aa596fb703b732823b19d11fa8fb4d61ed950e7fef8828b754556949f90bcae5046db598b438d1e109a60e8a3792118ea8372b3afd0a2a83d43557b64bf3e8aef88c4b105c6bf84ff98a3ebdfacf36cc58d1b239e0f2c29a0ebe27e0ea4aab5cbd0e3537ad668b12f3559cd3665fe941575cb13278841eeef9227d1c8da929abe77d632b16290f37818aa9863f1baa8b6b5fb816b60420dc9481f1b3a9c6d4062d2db7819700dcc7808748f194da28cc39e1a3d65747f92194e5d4abadb44197ed310bc2bc8cacb83cdbf00c18b89da52572a6a2996d32de00b1b071ec94af422a93725bd7b5249e9a52efc64d3143c30f1e8e8ea139356582e7c45f1f64b4f206ca715abcfbf1ee4c9458e01d68edcda55ca02881c4e4f8aebf6feaa5953c56596c26e920d6746faafee52b1c32ef68ee54db9e670388664422fe2324d62be89dfb0f6916af1fc5452b00695da42834f9b991683b8a995d0887565b603601ebc303e3793658011bede6999ab81ea25aaed218cd47f3c5fec55aeebbe44c43ae1e3c85458d4566222b1da3724460337fe0fa0cb73ec38b62e4096e9e0fe2219f593d7f91c9aabce6a8eb0e9b5ca386f4f1c822a61ae475e6f240e30f54d1d1b6b4e20b161967e88a160f8959190599a3de8974b3c031f4b0384476d83596d9ec1333178379609d314558c2839ba4162083f3f506b4a0168f17d680ad186b51bc391fde2ca9c97f709a670849aaa0d5d8c580b6b29cffe6175ca8b112afabb513460d5ad4de955b6778ece305b97f4618ee84f8dc22c5c570920e6793dba9ba1cfc169da91b0c967b627fbee9db324fcbd4c5875d432b28af38b4d92a51af394d7a7657b70f529dbc47a6c74e4a197a5ff905c0e333d4bac7440d1c848f111f01bff311600dd28ab6f8ee12f62928271fa885f4d2f5da10467e1a1042a01647bce8da70eebfeffcc719257289db5c9cdfccd779b98d4c8788951551519ae24982e00c33d20f0571c88dfab72e946b449f261653e763dbd6bf7a083a9f1bc86c1fead6b962c76d7b7be280f4ee656c687753e564ad16d16ddedc1d46b20f449ef9ddfe374e910e5279b38a84c42cb9d70f3a8c8c7d80e1457d792229d009630d7a069a33dd99b0219cab0084ec1f1f4a8e9993b8d7a0b896f9d02ab60ef550d5ffa4d2cd4df55c5d34d6a36f7ae20eb9d7ca3b100a97863e6fd60d3277a46c1ce60510374cf043badcd54ceb052c86e8c25f6a247ebc32d6d979ec050874930dc856a302f76eaa","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
