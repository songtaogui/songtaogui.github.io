<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"487fed6dad716bdd517c752486959a6a3067d43eee68b1867e99f44e072d57907618f87a29f825927079f362f4e282037026e24ea38b228c80656da14cceaf7a7bbf1fbbbd9274e98ce4aafe34c28ec4a0272146d9b61c98efb74962086a5314941306ba2e1136d48223e59a53558b8534bf0da065778b935df3a82d68fb7c4653851970bd7cd7edb21e54584274c8dac06dea91c186567dc847732d8d62d4fd3ae1bd34ace8a4ad7f13950968b59d701bca3863fde146c47a337944afd676485b8db9d3d186c1cdbbe240ecbc6045986a8766d90b4b07181dde5e69f601eece8d2830ff6f0e60d909cb9e3ed866335cc16b2b960cf2aa806652c0b01f567a5d6861176c8f9cf2124d1f3978048a872d74ed547f85c5cd4bfc16fee3aa7ac5e7fb6f88a73487fb6cf5d55070123ea48c520b73dea4796952a74ea9a3472e64326e6f1e7e9548d7a7c672a0753e544ab1cb296fcf514ed0694dd59798da86eec64cdf5c7975ae8f1d1730531e93e0de2ba3fa3e6c310c83a50b6d55086e1cde41b65a742e14f0f27de666841ba5b3e37f041ae781ba3e4aaa0ccfafbbd2f392b959b929b100e250d97257dbb3ba9b5431c9c959c23ced79feee93a772232e83fbf59e3192b5ff7c9d1f4ad2b299379faab41aebb59ca958768dbff13a651ac05853c0d2355d05457a31d5d7d0c9bd30ca30b04482fa44c470de6ad52c5cf7f7fef82c1d0a9d5c0b29e41165839a8e0bc6eac04c67aab8898ab7ab1b556b91821edf4a199cb7b7540d4c91c85af1c0808ec15bb54359524a85be9147c77efe5be09e1da161afd24cb87814447d077d7067f7edbd5172db8577055c88c0e58b9dedf7c9009806717eeeccef8b504059eea1b88c7eb4c9020ad0170819f347154de2e44a07416abf56d32b13abf80ea0de6fa213ce201f685c7053c9fd39d474d3a8451801ce56c3e3550124cc715c64c2c96cece89f7dd41e82ea156dc7aa047882bb748e1ce5f2fdfb2e77fca0d5b5fb54170adc87e687ba9671b0037406f29d232399d494cda392a936210b1cf8167c4a0aff5292435125bfe5655d2030696da1733ee5837cf814e8ac4b8c2e37be1c60d208f7825a5acdf1eef5dd1ee2240ca787d1e36cab71dc9a4519cfa7154047c71fc3e7be6a31f2e548581c447c02a8ea0a398dc5995ca76d79d0aab28b46e6069130e88aa174b966e1db02108c62cbe24a87baa61e1bc4a6da8499bcea2e892e35ddae14641d17c854434da6d5e673c8cebcbeab61d5a1649871a3a9419daaf2939d9b84abdea1463f4d8019886cb04a3a4d0d5e6a1911a64618ed92568f6b13e2edc78eac6ef84a60d97ae57094d2792ced1b5c0dcc91f36e00323c65d240eb78d8163a28d4208ddb3094d7af5a313c00c2df046eb1549bcee0c4a356c299bdba1b79bb83d488f10ad85a14fca6e8a0ca49e36929a73c1b330f4bd822aa82e854c5dd4a872527f3a8c7e9045fa1704b963870aaf485972ae289166eff1a0126cc2b17adc531128590474f8dd46f2536f6ae1e449ac586a8d3053495579e5f5283c3be852a4afbc48cfc97ac73deeae0fd41a0d340e8d9fbc31828c63cd5bae57449fbc76c2e940df9066cfae7670e45d1fb11b4be1bf6155556b599d9aaac2a179cd83b3df4ae5ea43a8629a684480aa01989a11ea2831aae54d119b0b0d3f4cffda06557541fe3d8da3946fa63a32693ac7240fb134c47af97e9076168dd76876a317d1b4ac6063723d693020d537e852ee26193a04f2e691f5cce507a2b31bda09454d7ed4e63afd8b0cde21c17285fc0de52643fa0ffbf65b604a1854e9c856b4cd6ed5882bc2541dbd549cd976c9670610f9323ac34b3299c56eeffb61b02a524bc79490ab17f0c126c48d543d7cfa0e0878b7b730a48aaa68bd95a1136da5097295e57220131557b86fb3d8bde505eee1c8ad86a8600ce8c1533e8b8b2216f0380b00fab9fe822b12f655a6bb898f2f5e35e8d5248dde47b0882a07b812c1f29b39f0fc3e4e8e4f22a5222bf4ffe1fd8f430d75fed4836477bcfec9ebc52b58f882e72de966cf6799220bdc2f40635c2476c21770254245da6a10ba3988c8152b198ac30886ea3bf12ec3ed4ea91bca77ad540d883f8f193c317cadeb100a2415ae1deb39dda570ac391014449dca0545e89b0901b48bfe1f2b318967dc78f1b1de96b71866c500528d159163ca2e454946c426eaf4f12a57b3aa46abd5815ed7222f1785d237788b1c2dfbb43a07cd19a351d51e1106e10909db5b7017185a13c948cc38f42d7b53ac574165a5f6faf955a6253c2949ce193aecdb7c0cd41bbdf37e143f9627209fc3177ba6b7fd1e87c62aa9c128066e3c57142147d20332c96babe3c1d2516ddd2e99a96aeae7ccf3ecf754cfe2043492df373e9a3c341ff17427f89314e45390abb723b0a6803cc0dfdb9c6f0ec14fd9b166980ed19789f890a690ed075a8dbe7590c52e5848bc81f8c36818505a1848ec3a98bb83688b9daa24a59bb17b1e29b9be02a0988f46ac5a68c2ed2e9aef7d400045bd2110302e73790e77b3713372cbc8cb5ce3a100015f7f1fbeedbf5596984d439a32287b7567afd96052a8be7dbfe97984cdab0db850e380f51daddd0f904c85f8d497bbaecb41796951bd8068e3ed78489901681b6a0510404aae3db0293d6ec639116090cffa9c1084490f5ebff09f5b0afa4be2a74d788f2d68aca96eb2583ef8c296f74970aa91ec8b1949d541d4cf17ce91bb9b05634838049189d65d6945f58ba365dca50015c2eb770685bacc1223d6cc99cb56f0d48f9cb7adcf9b6b70a8e4c2a56da3abca8d9898f40ec0cd13f289120d0f3f81d0faf62ca9141f83cf0dc1906837d194d3951c912c7fbb44ac63b375b999a9a0855dda4c5acb22dad0636fd66c883f22bcbcc50296f9117751f8105473c73f8df1416226d4d8197cfeedee4e68f0d301a5e790575342cffcbc8d4ea26db176054bc2863775fbcaa276302a8a8bde3322d178d3b867815e424d01b4e7f7417e5ab059fb37a735c303645d2c4f96f606a2d3acdbac465daeffaf6afd67111aa9d66ea651fd190b8c96ba53819f13ae7a802e02a350993cef5fffd5a2070c9f30f1c1eb297f4977b648abf997034523eb396112683880041f9cac9d1e1a06810813f11267f1a44a9c78a55e9349284335b44b2d7c27e4848be75ea5aaddbdc9a7532158cd9dae40cdd8a4800ca76e4d50ae5ff331b26cb277888663f22627d41fd99b6598653187efdb584e7c26a6dca97ed696c262e3eec35717c5e427b67c42150a5bc730c92a3494ca50604d0352caf2401599b1c556cd90ec522511996e2c542cfe804a89825e68b52e8ff90b48265962cc5f20e0c68357d3d2c91979d14a266382bd0b4183853d46b73dca640672c5bd72f7b3986ceedf43cfcf8b466c82b23cdc6a58e52c07f1618fab1bf1a746741cfecd670a3217b20de8f390bebade1b637d92b0d5208790eaaa1412a918f79241de51730af5127036e1534f75716f42006ea5bc9b8dfd5c7dfcf5ccea88013e53434a8fae13530c285565b8c95c57f125951d5542c356491ecb619c2ff77475a46eee4fd5677a2878187bbbeed2900d678c7b7ff9a72b0ef3085b0373ee548ac39269d144a4536d4fde03107426756e6641cd6b34adeb589fc837c7fd3fbad8b3daa6d7245cb5b5dfda75ab988d601dce4295f6c72f3e3056c0ef2871686e1935848b7046c36e56df8df6ef4cd4ff6b2d3aa51a66b6982cacb3b369823996f380ca1a9d353e1ac6046bd7f322cb505bf9f5f049dcde3785c11740fe9182dddde92bf2cf5b7c46be75689b6bd878ffb32691f2ddd98b2bc49c314d9b13d1d2276e273d4fbb18e25294b40f4e9fdd4ce29f4012ab1a00798601bea8c75de9c8f5203bfe7afc2ccd7f5915572228dce3aad1475b4e5b9fd88f6b63b3d5b2c3b9c0e0b063af01200f1ab1c51c7ffff7b4be7420d15910015b5d4f46acc1a08a04ad125e94b9a5c245cb24c03cdcb47d991166c1428b9522799408e06014eb7ff6f96cd9d9168391f5e884f10761d441fb50ebb4e947df44eb03b0700992b0927d07500767b2dcaa1e621586b05a14e366df6a26297bc479a06d48b7d1bf4bad6fac485bd3aaaf3add362d93145b628ee6d335c8c77ec9e38800197b6c87b1a064e1727d276284d8762501734e910650a53adc238117435be42ea874a07f8069d162ed46892c7820013c78954a986cecce7aa8d5e8aeaa6430774a7a814a19fd29e50788be57a8c9981f8541e8fef9353d115e50e4ca17fe0b5e420ff823aea5841a44b7ecaaad2881ead92149565e8cd4f4b0f3e0a2ecf67c9ddccd544e46d518c99c84a761581df97ce123e6ce50164ab4c9040bfc93560c19232cb0521f876eed0ae000def63ba358a23b1fc3b6328c11eed354dcf4c38ca1cf8d26bbde184851f81e0dc5f25f4643c8a9e389ecd729e883ad0067e51dc730d21f97c565a585e03013ce49fd0b62669f133880c69895caa977b5ab49cc03e21a5c803b68a0c6f7b9ee1f0c58efbca256abf9a35e9dca343e9a54a5658609a20a7ad364d4c14e56ae9fcb47c0405a8a6f28e597511a96630baebfc1cc73c5a4139f79d637cd78d392f6df8cda6a86a80e15ed6c2412ec9313ae47e1d6c0d071b766a536079dfa11e728d94a07515830ca1a3e465b2946a52a7109385b2d075d59d077e8a9e76631400c70ed8a1391600a9befc15b8f9121490d4a9eeae6139d3105a5608a6d30ac913e56e9c9575e6c6da80375eb8d6e2a6bdc47536e5c06b26e03562f0987dee9b646c58bec4492a169856471b5168253d8ec27a01bd503426f30d1a6bf5cc6dc0bada1f8c05470a1617916fc5910f54e5314b3df96888f4efca8dbf4128d189e69c6405d8dfbc02b46de803a5d72b7a53b797fcb6f2367993c3ed3dbc99f5c8109e092c2e04d1d20b54e5f332f6bfcca209652a558795ba7fb5d9ff6bdafa74d225f97abace4971748090631c9909da1cb10024a774c7eea187001a77c06e0c256d10ae90aaa9622f553440594dfcf653dcd556e5f8c83ed34d57dd627be9bf9b8198362085749caff51df4505f666216cde8427b72fa580a63f4081537dce456ab8f8d441b6efc046364aa59e3ed8aee63af46b8275d1f49ff036dfffcc94634e2dea0ef6084b499a3545da5d2483e7fe97b94bc3e73b539b8c6b71a899f901cfb83f852c1e5dc6d050b443ca4d78e8f189e3d7e33d9492e4e762ac95b682903dbb40b761b29b3c812042e33a959a960e77e0fc65c77ac661110e6bfd81d974e4ddc7ea3224ba0b9c86c383efa69238cb577d49736081effd569046d8ecfaefb37549df0222404716b1fefd26390f1a0bb58b3fbecb2590fd35cd5bc3488c938e5fe9b12e200905d50782283e1971b5593b8a4ce41568ef135d660b349a9e2a19715c2a7c22167f9fec3adc5cca60322532815be0b2cd3e2d16b588375ac476a53c25c5a16b5e699ef7b7c438bba7dc2b2bec7b7b3cbddac103c27e95d0bc09c49896b2c6ad511bba9f7c72ed514ce4cd46ebd3440868c5a428da78098a1d444ee40ac97f7c5b050ce2229bcc150e908e8d370f5659b8fdec210dbccb4ed0e34bb4bdbff6fcb283edbb1046ac514bc2e312048cbcc981039d823f980c54997c0572a232b65407c995bc6869228690dfc2a5596b33901d5e83fb7d2bddc30fc287a30c6cdb00335733e448dbb48ca20d1a47317474869f39e8120a6bfb0b1e9ca737fef9020c5867e1363fbe4116c1e37b08138fbc0f458dd19fc62767ebd41dbf3f82bb314eb430eaeade673d1d11c84fc68c7c6742a589047813873e9b153a5b7013feb8cfd32879bb4a6ddaac412c560742dc3e160e45e3789881eda91b0bdff9dfeb22d443da1b71f20286a97d3c164af90f7b88876cded19a203891d0973dc0fde19a421ff91cfba01ae6383fb143f52475775ce66ed2b73d9b8d6a1c4c7efd7a53cd7a39005bdc23cc34e68810e034bcc41423c1bfbed6130fbe4bd70a85ccaf98977181f141d706d0ed89f81dd53b8bc5a90a1851ea3debbe09cda2e5595978b9a5cae72b1e173ecc762080a1ac5e967a85299435bf4662fc846256565ff1a7d8e08f5cd920a1d2c21312947463c4e5468e2ef39e9ffb3354a2a1ec8ed33d8a1c7072f2f89a51cb5ff5b43c115ebffb882c72e3ce32566686220fefd1104eea47e6f72e486712499a6038766766c9321f2ab250133cff166736dc40f675a44c11831526d67a28f7ddeb5a9533cfeb0c52aa6a1e97cf3b954571d89cb1848be07ae4ef3f39211630e3b30e2035d7bab0571421ec953863e25286c3b2596d34f90a6737dad457cf43bf0555a658337198abf9514e6aef253417cf9235ad5ec2de7ecdead450925eb9d726819c227beb81e44f88639850cec011307edfddf0a49c04cb50c6e8a3f2f9672dc70d5396eb4931e1d1430a23b87bf7e0671c5bb9f6e86b29bd08c2c963126be51b236883b70e7cea753196afc9fa5da96594cc03f1e48288e03aaa8a30ec911aee3daed3c50770d8902f1569ea508d4b30f400400a16241449e9eff03dc4a87ff7fdc6219a7ce361fce83ca57e1dab8120a79eb2a312957aeece57a5c267a99f4fb7867139995ca82f0df76355f58fd8c54f52fa9823214d8115ff859c2593ff558e6696afee57a48bd755c31d0228b849f257bf3c6bfafcb4402c8e2e444bcfb0352a1ccc0fbf48e8cc4fd5309654f53732639a18b592a63216081c5c06bfd3726a7746ee71a421b92333d15619d644d4bc5f7d952ef1975d42d6baad8be2243a1f45938debc7afb255f7cc93317f9ea67d76c29a55f3f96d9e00ca2e1ad230564820f5271e749dd5b0719dc71ac88b83778d8c039f8171fa0f651e725b62cd09c0a01f40f11d745f022f10fb520d43eb9621cfef478ff9fc86d7527f41554bab10568f95db075552d049240bd62fec8c0a401e167c8c0e0a53ebe1ae6ea16012bfa3e4165d678ce439870ce1449678eeb292099dc1800aec8cbda6684e2c7b90204ed9f87a8a3dd03029a3b5e96679cde793fd7adaf349b7b2b3467327f0556b155ddac0ff0d618e960c93dbbd289abfebe3032b850b6e02bfcb54bc40285522c291d847a083dc961fce1b6e826cb20c29e376718895cbc3d9266d71907c971a484c4a8bca7109bfcfe01c9ea49bc9c0d1ebb2f84064bb1ae94e79d01b9ce9688632d6235c428aa14e01b441e39aacf01b82693fd85708f106eed7d7b81766a2fb82a4df9dbbb36c7bdf877648ce7567a9b1659c51886e505d27ba874a992dc69223c57f636a135946247c826d7cb6945970ffd1e6d4051ab48e7d4fc29bb4f3e831ada51844715ca278a98c3f0357e5cfe80a2c9577b5d5ddf0cbca038891d0e3eaa94ae809208122adce399de6dbc01d7e3ac74750722c5f61130c6e76c138e074caf9c0e0206a133ac379617cf59bf1c086cffc30073f28bd624758577f98a63eea836cb476516376ffecba01145e83992127babd40922a10c7db43e65c8d95ef3ca8e9aebe169e7873c86db8c59cfa6e0629dcd27afb596316738d66528fbce3b275efe7026090b3af2b7c1f62f157099e404b787be585aa015892e3f13d0b4077ba26139a990c6600b9712c709b436c9361b320c2e5c71bb897c8a67833d53d66c6cbb0fd61922dba79384f891f38afc83cb81a9ba0bb1c8c0a27e409ce54a4f8668c8a875f27ecdbec2d31d93ab438672cacce3b7b9731604b15edb90f84eca38950c98ce5b14003b75701727fe2941d8f09985e8ac659abc940c824e3a650b6a7b77657eee0926637b73547c12f208723a77203faa058e325838c8767ddce9b25b9da7e045cf46280512c325bb9532ffc1504c3eee8edfb2fb964a7672171bba1c228a7e3f23da597693f3e097f38006a52ebaab2e5cdf84806ee55e4e17e1d32fe5d63a1023daf37ec37880ef78d9ae7cb9d5907d866b378717def68c9974cbbcbfb71d30548c2e56ec50828bec1a6109f43125e2491806fbed817762880f7896c26f46c5af10064c1fa8672bcc3730d1171b82649de6c3de837b7b1fc5c7181ed61191d286334d6f370f8ad0f95a74a7e81235b4317642537325c366e1149a7985d7053766376e8c6604920e5f2d8ec3bdeee06e26de8c139c735647b8ab35dc100b10927b8ed006bc5e2980e8043e856e18c736334b5d9ffe3a1a1189486c168b3ec572137125d18b1e0d41e103d906dc80392285f1e66926088e19380755d1a7f0f8451eea2916f45dbe5ba1bc53376a28e8ce3c09a814f50a616f8359b62ab6469f912fabdb7ea715f8b8b74ae6a4be9e1312dc0a8f430587c04a057ce9f43987b8c451b890f4c1c581ab25735954c0e631c3a6f27b8fda8d162fd3d61d4fcc32592c18a9c7548f826b6bfd738d41774e2eae67a876b68406af01172e3bcfb8db54a6c9a3c33aae6f56aa66eefa9b64a136c2233ddfc2e007427c22a38fcb9184a88347c56f8df153a5188e605858f6b1727ab7334020cfa025defe0fd0822bc21d0ce79cb3c40011f185c10d1f4ba24482f3db50564fcd2fdcb8e5323680c2f24d7d80787ea03a54111ba24cebe1ff8a7e6b75198db24bd0a3944a46433cbcd25f5acf4513049d8f44ac2f05812050f9c556e2c2c394fcdaae3ed3f0080be3a193d6b43687e57d40b9013f420b1cb4b7988ec9044733586365cb79330a1424c4df1faf675bbb6837a56de5df5e8e90b512ec17d8154bf76c5b3f8be1d80f2835605c188854c663e14da1c3432e733d1447c07e02da6cb4add80bae8511b40d25fbcb1c9756aeaf60633db374d9732e47b09a642ac7e75742127ab6870807428bc96818c82e5506980ae4bf8005b9ffeaee4ff991a69df631cca6e25b4238ec580db51eafe9988d55e84588ea80e2d129df403aed12fb76e2c73dd28fd323a820a7c5174f83223a076d6f557454debcda3104deb16d749a8d161ced3766dbc59c2395a3621a7983500fd0c0f476451faf042d1bb10bcbbf48b0730250c1888e7e817f2067afb1e8febbeb0db053bad1ae8e81b9c5d1d49c2ba588ac855480a6d81b30b4777b31faf78fc326f61965d59bedfe3aff17caadfbd288121f509a4ee34429b987cdd6955ad949d10aaff72cd60f406afdfe31cf6ec777e4f5852f9b6bb8b012abf8034b753fe1a7676febd7def175c4fc50f7aebced1c5f066888fc32a1398f293d2659f735acacf8ea1b6604c128c99243e926f168a7ecb2c372032b8964d3c47db1b27909c6913a1e9699385e1f8cfabd9f0f34c693b8c97293aeef053db2f3dda9537c704a89d60ad87d9a20754c3270c6b158378b2b89561ea50adf03a5aea92fe5e16e7b01fe4b569eca0806778fd9e24ba3e2cb135e56b171a25ef0a69b85be3af4f1a9e8c8fa9db69fb8fcb7c3eba51b69e4d329fa59d2973ea20de27afc396295257601e45d0da83442cfe560fe41bd8cf8de8af07b01a19876d0828867bef93606037b39a50a125690d8c1b974245284a9a52408e70e933a8072e07b7048bf2ed64f58fd834cd7467895a6036f3bcf85c8bb855e003609c314cdbff8ebc1f529f6751ee5ae71b9d601c36948565d4b38c77006ab696d6ffe1a5ff34b2e1e9262e36e2158b7722629c44fe6d141fbba661c2b47feefc3867444617927634de3ac8ba8d28f44b4fab3014cf5f4805311eff892d2712a6b805850274b8a76e55f8fc0347c5acd4c40e4bc27a9ce166894221d58f7522e9c765f064e506ee6a9d7c36c458fc3c6ce5f88d9770fe64fef3ab39801145b71198fe45b8274ac970be5b8762bea3d0339f981a145f7b89c99d5a5dd80efbc0b63c20f2ca69f968beba5baa9d1ac9d5f15585ebf0d2219632b8df2fa9772e7ff9fbf738afbfa9d953b78c0b18a307cf6a222d755260a6dea3ba82ce1b3875cfbf9b0cddfe4d2477bd9d3803fea2bc8f06ed0221ed04aefd2976a7297e189749e49824968df21ae5fe7c9bb1f246ed922387170b5fc4f1bd519b3a1e0247819402c63510df068ccc2b1e024ef42a147a5b851fa690d51607436d0a01250a8f3fa6ad292aaf4a78f919f71b9cd6f507145226b372dc543cc6cb4176f1ba2f786ff8fb2044f9725f3a207734d29861c0d8cc13032e2b0a4735db6022a16da453200871d0d4d0e151f2a9eccb75cb79f15e86f3e0ca9e3290fd5071af8e5060aacf817f768c41c13fa26c59cc57ec3a1f0b7789b283513ae2d748616ea7b3b15648a16c30cb645e7de07872ead3fdb8a349f2b0d592a45aa0fb7814440221c93699415a36f77ed8edb7e624c9ab8cb2ebb3b7d58c9e9e8134230026b5c03ee7ec3d1fadd66ac5d6dd6ab9d8c68a52203d39917f5bba0622a978ec1aee9c599330c56dd2b2a1d6b8b0efca8b1097a127aa207d88eec2a18fb919afc50ca3bd6a5715e10e7c941e6d6f8ae17eb545832bf4fb329c2434fab55e14571b72a3412bba2eb370451a42f3a3f123e327be672ec178fcf7558b3dd7d7bbb2d42dd4baf36e68302a587f3ff0e435a1752310fbe95a49c7a4de0fc47cb585c6e911e1fbbd905eda10083988fa6ba43d3143088f932981c212427f1945ee18c7b4eab87f6127727e0114c1c9ce42a76b127097117753843ecf2b3236ff826998ed9ccd3c39de57aaa194bd935553f7438caa7b83fc5240d6ef142204a428ab7874fb002c36bd7402eb3ccd318c85a318699bcdb048d12028a52d0aa27b040189a3d2b12a543502b923aa8b8de0f405654da9b8697e0361347168d1855550f645fb03803608b16a962a3b839992355fe7e6801fedf53fabebaf06b5b6277e6fd57a5420e6dacc158a80ba56ebf7f8390c056472fee039bf270102e7d3b65dc9ef335caef9b9dd753730008dcb93c86b6530fce4946d5f63d2209bbeedfe63bf81ed283cfe680c27ed25c3fab4e50d092a9de3dab58bc84546c4f9fc07afc318888d98df410042438a1efb5db5ff16f7e3f0d208e63ca407880a8cc8bca72f9b6cfa64b32d3170b297412c7dac93ee868d3753096538b339d6eaee5add921a929b0bae6bfc0349884a52ffbc0a6f36ac4c29432649a4be89bc657a273977f8ea857c1e20c16f76ab56e55d140c5a428a803ed5731d18ed3832edcc2202d2b0aceca3207b4d0427e158d76a2dc821d9d6cf880c0ee53a494f128d9fcb80957a9e52c8601d8e17296f59dd34bc6ae45612f61ce8bd7b318c7d09e736a7ba3b6c5438fef7df1c4675fc476da94fcbc83bc8a7f09fa95f1afd6d68c52946bf3f9894b6347cad12393da33a2fe0c2906bb1b05bb3074e8c9050297f517a0a646ad919afbd2a1f0b2c532b8032e9702ae7e46c6cb395477e1aa4cb0cd8334d30cf87904a9b9b17f29b7c28849f2b9956701e9d042b4e527dabd4c3136c494f222948ba9077b80f6353708df7192198671318e7676621a495cb1b539c9486f12c228b4cf9a325cdb4ed8f72230638f3e03d51b3c493b367257809ec1c78b1db0d842e8f9c50c3fe193fb56efc9854ab4d2caab6ca254fea8c8fc5e1c0e9eefbc6e17c5651b27799b3b24ac28e8c2590d9cdbcac692a37bb922a6115e9ed0693e24066c58016e68d572302bfb716c149850c5bc88ececf6b93d4dd19bada688bf58d95cb5a6894cf7881b22ae05695d63e7750aa7717bb62c338d9c42c494bf04b22caffae24c7c529ecd953a7f4ef87fc5abd9999f91e98b86e7e5f6f4c30b38acfb86cb74ed32ab1d280a4189f5079df4826434925a0471b73a8e3237e9727d1c18a2a7da9c5d806c701a96db9362548621d8241d890ded1145ce523b9724c1816812c14e8e5a8a6b1801e5333f2dbdb568d42e011f6436c1a94bc0bc315f838ddf5d96e6c0f63c6cba5e408a9fb0018ba4cafe0106de6da9ed5da0df59365762580c6816c2ca8162d91d433a346cf7ddd85c8d0c0ec9a0a9e0258c73de854942c3bbc69363552fbab2d4622350714122276850d838b5e6370af5194816660785cb1076bb908c2624c41feed325d2fdbc56cce3a433cf00976df2b7ec9309a231ddd4cb36f6ab2f44365d66ae012bd77544c796e0d9f51d6391033e5a45fcfa6ab408f6cf210e7fee40273c13c39cfb335094e6afbcbb960f58a2a4096008ebc95fb919e24c10f582876c03427ab4ef485077d6e85385d7824fe86db72340a7577c1d44175c0d178197031b281d00363d4bf9be2a0a626690467c1847d7733c7851c7997b75724b3c42caa3aa6494b2c6fe49e506dbff6c7cd8fbd71ae74f1897f55bf31a33b8d7d3e7d651b0fe6bd34684218eb732ae4a3a3955c4632c9f858a7bc447ba14ac006dd1f10129afa8ff6ec0496ef633a1a96a829dd7d53f336f7954a507d3ae4eea9331fb08a3a5a1f4e11da45624df2039f9f8545bb2e4a47059b03df48222ae4cb327a15d74c7ac5a70d0fdeaa7f07cf50bf7565685826c1ffdb7bb79044020da5467b8d23e3dd6dd29542a5a67dfb25254128d18039c877fff2fedf4bf41b1267c12b1fdf3b3f601f849e5bdca410504fc128eef59f2ead9ab563eb92651db1d4b5b7f4c7133a5f10487d5391d0a9a397803bfe06ec727ffb88c8326ff354a3273ae09f3269504df852a957ea2c44fa2fed4440d076746a9e8ac9436ba03439b5a861364b71e6f75070e7c985868f696fb3c27df218bbde1067ae179e854c9baf60f8ca77e787741a0192f07fe6ce02e949f1f2c24f960f10162a296b6b192f1e37dcb5c12b15fdc98bd269f3b5d0feca681d2079c64f1dc21a6090b01fe4a46f8d8b5bd7413b0af0a2bc2002e152142b351a51852283edaa88f6e995970bb4eac71834c1e491c45c366ff400ec0c20451516933d772bc422ad2871313ac65d2643ca9350867f7b597a495b7867dbeb241a75d2a76cf6b835344f0a6cf10be49ad28e5a3a162c73c2aedd55a8a0fd20b40ae7a60fd2594d74a1d660968b4bda78d2bc21a06e1db4595264508dc1d998e378d5817bb53ee31429ca12bca3592c998a3b30db492984d969c13ac57ef1486f4238c9583e848d3eaa326f3efa7138a2695bdc17d2464b4f23ae8f7c113313153afb7fd8b8f2fddefc6335a9fdc56821bca0f1dbbbd3c561f4e2f41c47e0101baf72eb3085ab6a66d43a3fa5e36ecf533918b1b2b197c4365197c6b2bc359a97931f85f7137d73bbeecdd911cba6b5cf0801a9e81a615ee0bbc640391c4083f8071ee1805dd21a0e9d263359728d85ccdfdf89e77f014b705dc0b2ec7ae4b972632c08c63501a58b42673f957dc82ef768155e81575ffcba2312d801a9fb9e98a3a1745ad1fad11edc522f8c31d8c3a6b4b8602e48976f5843f66383d858d8af223acefd9e93b17167181e22ca3cadc79465a0bf09d7b1af585d8a9813e8bd0c1fed03b90271e3232faf2ab1617f702ebbff75941b467720237e4573b89b4fb26e5c5acd8fb29469479a4921a8670e079c585f425ea5109a0e4150a6d1c4a5be5b464771b8269f921c0f8f2457c272da44743ed77da87287544ad85f21727bb7fb51cd522f396d8c186231fdc1c9c5e34ce43d5f4d8c2fcd75cbfa12b2e571c20f99b153da24297199c8fc4cdd5ee4ee1b933d53207bb7701234d3951f17f56479e187f29739fee329e6158208e32fda2a5583e8e5c0d9040bc88da0cb791b8c180ffe428a780b02494a84d70be5c26305352e31c0c50b432c04735ad8376b6834fd676da5b99072bf52ed07f9d92940df080f69951d959d52f0303ac5caabcf20fd6062e4f369c5a98f9b5a3bbe76b6a4369d98858db76bb5293f70920b09e5086ab36ecbd3d20ff9dfa88b13995d04feb49eecdf76db805e307cc35a8f33c84e4124200fb791597e967f7ab86ebf8a24bf044be007853a04a2c9e5b7a1ad04c10b93cb14a441945e92ee448cc893fa7e0cc21deb7c661154f3c6d15efa9d041ddeddac22cde4c8fc9c7f6070a986e6818200f1895987f14b7cd3609a9c0d3dfe67811d2bb6f81f517eec4eafddd530584a15d4666e17148fe154c235920ef41ce5273e3e62a29e1856cdbfbc963417edc4266021d9b8d41b1845341c86740a2956121a1d194bc67caabeb3a6f9d355bfdf11807ec22bbfeca04a99c71600d802ee38ee216ca800ae259d01656cd4dee1ded7891870b8d41eb175be4f751f942b052b8abf90a1761545fa7d55f5be9b532fd0b0a7001118e255c33b927d5038f05940dc23ca8a080496911033076ad1a2ce7c49f515efbb27807b8ff33e8fc33c17da16bdf79c0e85e8e8dd66f31825ea26e41a9f8497a3f2994f937e74ac4d9ba21bb242cfeb03a0dbfe40a6ec3df5ae8f7f71b60b9c3e2b215fa0e51f9a5e1f79dceef77a6f10dc34cd8dd472caa5cbb80382b97093bed5584ab65d6c2d739e201a45e148e2ca9826daf5e6b2c9d68bdc45a157aa003f1c6af77e05cc39a63a1e4f00307d97f5e84bc626ad93292f42fba6e9a4ea4fb7249f8f280c1ef786f232a3cbc5450d38686df3ffe20f91f3f27e0d3cbc15b7d10b2cfe46d16043b0945a5f57b350421a718a3383dd1810b7c873d316f4eb02c37776e178eb20a7080cc35bab2c463952fc25de7d0f3988c411d47b9fb9065b514256e2307ae0cf7e46c6c9a4352e195b8fe10900ef83b0e7259f7c51a4cdc25f6818501303afa60595c43d123317c2be681e76dae6466c26a7e6f570690f2c60ce077f4c0736203f298efa22d193aca917eebb313f01fe165b1d081c7b572119cb13d8e33c1ef5b80bf00beeae817c7b2c704ea3a679e7f7aa9fc4118a13a248d2f5cde54ae39ca13955033bd5d1388acf6dc661763bc50880bc59a25c98047c487d094ddbe6d95f83f5015844abd37ebb9f0f9d33f7a1e48519d08e9e0a5122407763fce6f8748771da205271c93147f4219d6e4c0e4e6e91bb69764ab6d7b6d2ed3231eaeecc248f1f9a8c5399a33d5f6111c25f0fdab6a6ec1de2d0e36a2656e75445fbbd2052a81a4c1e85f784d2a95fea781cb5f6c17b7b61d192012b832609856f31a0f9d6eea69d3b263a32dcf9b043deb31084f0e48fe1eee440fccfcfa837d47240470e016ecac23827fb5e8e229892b0ce20479bee0947754a24d3c5efbff5b0eca3338c821842ecd9e4df5928f459010908014c08e08907f51964b374cae85e0da17481ffc2f7db0f4efe021485e5d1cd154f6fecb8ba85f9091f4937b4a420ffaba8bb31b19bafa6253ae15220d52f6b9a0ed04c9a1ce5761b56de9badf207c88da9744bc0c20088a20f5c2e0423d399e731b8b784e58ceff3c7705c00a8872e945e41fac8cb4e1412bd114d79be21144b83ea3a9a6bae36cf22058fa30b09083ee0d94454fbb148c23afcee1064dea51da2c40e4796eee35087063d6336204e537b265aa06e587e49d584fd618454c72268cf0fd643a80d5d08c1be871377bd6ae1af3fe54d69e36e6ac05fce71a12df1368b584966482c681a25cba07be8cdca380ed4b3779e24491f180dbe9e7f98a549813cd9c92f3ed49bbe102bf9451d394bfb9ff290813fb7fdbe626d03973379d671b80cdcade7e065062734d6d5a18bc4f227adf74516e88045765273b54814c5d2dc5c99441056819a2d372311d04599d2d04d4e4626a385c7d71f34fa6330117a3591e7f98248f835253e13fe449e37a35644cb1a03eafc2c2bce26a3bc286e9f0576ea3697eaa2425d3191e17569c41fd245f491f7e89b2901514b49a12f74a6dc7653a4b3eae32b192bf4cc830a62a612cf22a8c3db621708cab104bedc8357655cf22c72d1fe0be8e4ec8fa613d9890e782c2b2a65e7e64f40a02e471920192a09296bdfbb07fee2a2b5d565390d03e6593a74d1e7706f85d6aa5a37f7dc3ef7aa2f7935f8cf375c3744c375a917e8a474f4141e6c3863ca346ed5e0c373aff9a198f4b0a101922bf41bdf77d768a01f7ea858f915c8bed280eca61cab291633a2cf63035b5c90074239735feee510c491c62bf509413fbea1794b260fd63bdc62734b72f9bd20c7f1e28a42997f02bd983fc7516388fae641de8c1d229af4cd7969d602fd4cf43569e8a1ef87188ab8ef2fdec1ec4634f42cc090c00323fc07d8d29812b4fa2c2b3ad540c9a06031294d6d2987a7e9b67db250bb62547e79e25e70742a4bc543083e5e8aaac0c71fdc7951dde9d4cd12a9ea1758d326515ed3e2da8217530aaf3b6739b336b804ee982093df8383ae264f6145bc81c19ca956796c63c1395846136a79f257c01847b0a730a80be0403d47f880ac5e32967ac2e4e118f542755d7017756a36085d57c045566b82f32adaad8402beb54cef498344946884bdc9e93b7a54df0faf439bce9dd63bbedde84fab7dacbbbe2afb3832400e94dc685efabd5d133519d719f2320ae4b7e62c0a80bf07b47bac817fe00f149a3baa51c6ef7168f174ba2c272f5e145e55285dc077dfb1789f9f00be7cf798e83705a85db134ffbe0d29ec2de9ca62b9cbd0daf75b87237c2cff017f7e292fd25c30f25cf36de5696bf37b8e872552db037ff50cb8f30bed4504afd42897796dc02ab99073bc4995a2f3cd4735f1b0ffaed6424562006e77c3bf47450ba09cc11a1cf045265891093c18f752f894552b504a9927822aea9aeee6b557289e1a34f3cff22219b22fa5b3fca9336eba6315cbb88023df3e66f047c24aa9d21a89212c9a8842ceb7afbe86d84a952f8722b4a9addc090ddf3abbb57f0871fc1b7e235ec392f42e7a51b4b4147dd049c452e8af5682b520efeba187b83ee6b0d99d60d64c45b95861abef7fdc25d319d9bdd8ccc96a636aacb786ce49487a50c7c155ca59108243e0cc10e9083b5c8aa03bc8d6997489de1dff06911e6d6b256db10a290e7e5a0c9092a53f311a6157fc6d45f26620f676c5eea34c879cec6bf05e9d480b59e1455b79c4c114bf015b7d2e4415ddfb4370ee3db81cc90754cdb181fa1e8c5834a03d53fe7909e727587ff36298da00effae163718bdf28eb6bccab7c70d92c02ffae5927e43b6b7e937f9e64e1e7bc40adecfb56c5960e1dd69efa080a5a72ccd14030f4d4e441c5c2e6365c5bfaa21af71cf82f75cabdf6bf88dafe58a7196805b20892b4cb2ccf154c3839cc5ca9aa3a69ca5166583bb82b5312ea46d2622a21647c5758d6416ccf7f04180a667cbbda7bb4144abd07a78912ccc851d1034858a5b34c3c243e9eada90bbab55dc9afdb6c5b51f576997136031d5ee1b2d15b7099482c806a71f9dbe5fb39d35b8b539a21eba61feb210e3a06fc0686f3a863a1d7f9e0423d3bfb2031879ccc954a3726a0d51e5df24a8f36bfd7d5132c4156dca19dc2e1bf2fb1f13cf408cc42bb230e00efe0437d599209107145ab7e2958f950f5ab86747c564d78f211d62d9def4d8f4a693462676561a59be96672f44e78cf3c10d293da558c68cfb35e4de62b7a96bc40b580f335437ee5485938ff771eb2a4d993813df870e18de9160af1771ec04b684eac883eaf3301a295e95dbf24d69bd953302bbd4f8bccc561dec5aa0e4762f4c233c477d6984c72f886928efc4e922d7b03fc732c7b6319f2bb39afa0317e59a26e2ceb9ddb4ab4aff341dedc58242ab7a1da7e1eff72bcc99872a0aca509f1f5c4f518c872b4af7d5276c359ff80d62483184a1aa76e055f8aa9a970942908128b715ce100b6eb416bfe56e5c85d3fab380be226f8426ae176861c542e79e746fcca73d0ead1034ae57aaaa5d186b91d11a9a375130767697d7617c060e5d159e34e69802f75a24908a2e95c5ad5052a16d519dc18bf8e80099a19aa895cb5a5330a847b7ba07e4bcf0be52e875643abe7f3bf191743f4b323cc0cbbc27ed572b4ccbeaafa3cbed1b97cdceb1e83010fb572f9319d853055e7842d73dd5b07cf2b27f665aedaf00f5046f01c42d50220e8702eb40c5946fa5a6c22acdfb3bc039adbb738f0aa12d4732ce246af8172a3900b828b8fa3cb931eec67634ab2220ba361c2b23d3f8b21376a4b87322c4655888c11340027cc7005bee7602354505f839a6dbd560813313698565a6075349621e8cdfb1c4d82e893b5299c6600b3e176f542fe8201d828e1716705b24a8e74f6b0e31dd7dfe88cccf52046bae9890073b688dfe5f7f22e64d7cd0eeb74f1779068a344c97ace7cdacdb50ebd716b1c521feda46fc8a091948aebdb5bc43ae15f6aadb52064e386bf50d88b4c93004a9cda9c81cd1ccd7853bb3070a139724dd62f944bf86a17ac17941bf8869dc15f87b6506e559409fdb1ae630daa5836b6b661853be044c3c7ed63d38c82062225a868cfd368d38184aa8cc584ff70c75713e1ca222af9a22514329df3250217b553fe68b11e242a72666fe761f3ce53edcbacd52cd20c5a5c92588dbe45c462b7cf4d90995c1a979278f013942128ed0cdf356eb1aca0f10204bc515b2a2c41ef08748d22b0f73d39d481700f60780df85d6f8df2bbf488f5821a2e80374cfd88130cbcb7ea4cd9b6b1a02f815462d53291b68df9cc7a7df56bdf29a62cf5fb62e4a21e9eaf571caa51501c5e323315374ce24b9921ebd3efb88bb3bc8b9a39333e32d881dab7dfbb884c0bbad696bf62600af37d2087f5df82c60de429d783e6f4517fb8bf0fe4f78a04320505c82848497db3680848aa58c1b4479e43cdc8bf75c6b34bbc7f528cf05a7d07512eb5dec057ab4c867a515288ac73ac3cf0f29b83c6d2899686933c5b37fdb3bf4c8d6077bfc2401ae1fe64c60db35cf8d5b1664debba051f37327b20e39b5f9b390f0aa455ba02db211220953340fd8383b8d47445bf30583aa9aed3878656de865ff08e51437a8b66a7e3e67f98c47a2360f278a65f6f82e5ce88d7a95f5943f318fbd9120caac986e7f448ed9b28002b0c2be6724d380d9c956ab7a9f7f657e8b00ec68d65df61a122b358e85f2eee508fb2917229aa4247ce15704ff29afd02f3d6afe9f3edc167ef31795a3c2d4fa75e7edd3a449a33ffba1d16a976d9110c7b50c879e829bb7e40e63cbad50b2c928a58d6f154b001194004d68c190b38f31ca00ae9f4fc0ebf33b71f6a498ade71407cc36d0182294404fdca062277ea7013b9ce7269c2b329dc8279fa97c3f397bfc1f4456b20c8415a6ab45880462f55f9f5ac990eebc60c7876a420b5820f6b5fbed1070409f40b68e2d2b12bba8d6ec4b100b73ef38e5035a983199d762bbe8e6e97ea178ecc4381ef3a0684e0992cf2c1310ab4809fcfa91f8e18491f0d5797fbbe4d8144898f49a8be43af5369a721a02614cf78516252ae068648d300ee1921808f4f6cbbd9578b46321dd12c505902d2af65daa0224878de4ca4350d2326d66c8484324e63c33abf4104f248aa00ba3130c7710cb78e79c645513faa3051ce93853d72dee3582825177aef4c0fb80069353dc62c66a0b7e6e718dc9244d9eb5d67d1147edd7ba0c9901f761bf91afc01ccd7a2bb3af7ac0d9a494270c004a946c205aa0954cd49d04dc9eefa58a60179d069083884260fe95f27ba7603a4270d7bfc5477068916508d73777b4eca403b0e69353ea6a8f2d8e4825d4d5286e225889215dc430576f235c3031a9406b68d0d9b93dc477e55c90a302bef2939de8add2e3b7ec1ed2a80b8f3de2bd5cdd026b380d700c7c551e4f928843fc599f3aee4577635b71a8ce63e9c70ed9008768045b98769df5b42f61b5f272c98985e6033bd91f9ade23fc56ea24294c561aa55b8d07ebd2559cf59694415d7f5e60e30ffd0fa30d7b4105ee77fe98413da873e167fa4d182ca0037c1c8d9e757a8ecca8e839262fa0f08d4764ca9c4e6dc266f99d8eb44a62ffeea4d2e8c33782b888dd1054e8b74335d116b80a637e401e48406e788597555b766c76e1245ef4f3211c0b9f6fb2ae0f540928237bad7c2f12ecc60f5577468ad0afecf92323f1898f283c7aae91cc33881880a3013a3c57cb2db2ac744c1384dc7e532c3b8c82ff32370608cec1e15b623d411276a08481506cc835fd368f59e7d9a116827558dda7e982365bdec6b84495fdf1766ec87b4cc52361a22c86bb2a80a5b0e4e27e86747294c9aead401d0ab6369e660175ab1d98ce91885d2c60657e461d32ed0209ee5c0e2bf03acf24fac19148511df24a319953f530d571eb3340bb430ba7773adc1099bfd43e261fa47c9540db59853d2dba85d4ccc91123deca7b78129327993b988f85d73b2f90b2ee0671a769818c9d275bdd9866b6971994968bad71b2a0d4de4086fe35dfdaf3d527e76427fdcd6e5765aca8a70cec77d884d701c729b8e45f7c01635cad0d44959c789733e602cf7f52bdf0bba275fad81c55c1d7f1f48b976d0fdc5f5d0180d9e3f06091be66a0e4d3531a139c6185adf99dd55298c0b68323983961febf92dfe2699faecb4a6acea2fd91867ee861676ba1740b33e7b88cec11865c6bf7a602666acb3e65e0c87ee936415d1435775970b4e1e24a3971882d6bd2af0a3ad1f50396f4d38c01d9325569faaa45282c8975c71b2f43b5de26c2477b81ff443f142f9f8229fb44bd9bb9272a747b3f588b82bd402d7b32143a06237eaa9615072fc15d1c9209657536e92f715f3232d0ca801cab27671dce9fd6a166dc2b4f2861e32c862e711bd40d00cc5bd24665160b1b6cde939b6c43294e07be67e0a688102cfd14f34992dc1192a1d26cbfb6635b3a1004197fb5bcec9cb889936392fc98c5817589db35e79e03e7d1eb42b4afdcac3aecfc68a259e3473b182ad0d9982e75918ca46ffc929a20de914001ee622b7221686743534a31c38ea5796e966327dc0433098f29fdfd935a7807943aba20599cc2c904e24e32f9b62523eab873ecaf5eeb1f9a788cdc783306f1c3676e6efcd2631ff37444766df1f4ff327448a8f38468c423f1babf161ee6c59a2281293e1a2d86ba3c1188e3ab5616f5b09a40dfe2a09fb55dc81c38992fc304025e4932e6cee6ededbc0e68aea425578ae3378d9373c0cc341b210cf5e861fe05c9eb671dae07e65baff9dbe7dff38757a7203b827af580a28429e56d7787eac840bb43be836429ffd2744254b738d8fdb5ff7da1bc813c2fdaa81fd4290509686d8e28cae0b252446b4ec3bbca33a0374de483d03e5915d5273bd0f04fe86ff49dae3262d5b506cb76c63cdc7095a19502d5929b4af23daf105a567ab3a3ffbe8cce76748cee17f5b43a60f25df271c7234bdfcbccf8da410d4b3b1b8340f105a322258e7be19b726a023a4a7530d597c09de928f7e7f1692c58c9dd745a64db92ea236b9417807e0a30e6e67e999781748abb7749d6f4018508f5a0d696d1294d91f4b870d0fa4c1a012433d31624428c5d25fe429d0cead2b03c2025d3c7fb96c694239f1d58e455b5e00097c376068878fb19d05a340dfdcfa03a6576ae8c09838f6124d245f24331527a6998185f702923a40949733a1a719a1a413692ac5e801f1f96d8758488445da70c59cec00d63cb0995afb7c062348b75ec044d9ab15a95515fc1fca4dd89b24eaa9e17c45b8dc9725369c3828b409372465757066f5e7a69057a27e7f2ddcbf19c45a671c4bb0d90e4b1a5a9230cc5c37d41ec1751e302b608ac67beec6344af0672e3faebf2db76396de985b41acb2b04c684f98ff231fd761ce229996eb41017af1492e0095a4f8cbd0f0b666b070cbda3e6e4577f1d09e8501ae13925acd6f59f52b85bf3b52ef07cad5c3a2b79b87e99092ada4e10ee2cbecd9924992c51c882377b757e5ad82bb011764a499af7ac872a1793c0e98b1771d56fbf61817b386ef50b324679d35aec80dcaed8fcd7078c02f6f02a10276e3aafbd9d97139d4d3d7b3cc1e6c3292c1ff72bd9781a10768720083e1e00d68113ebc292523c4560ad0c679dd0ec3a24775aba72f7f77755326fa99fd8cf4ae64377045e93231d787dccc8f6ca8be0682d786750a1cbf9ad292958fecf5fc1aa6a0ccaac8b3926ab55f79090197471f1b570880e0bae6c59c8a5f8a798cd6f25cdaf3f68210d93253c3be30e7d593a3f2be94b999edbd0997db820ab026788186e6af3f70f8a07236ddb1e25a26f49a70a490b9c683c7ee7a14c2da030e27019273eacefbfefc8cf74caf7e1db9c9644ed43162b0f25ca8fa6102289da38ba5877ba864ef2be6a93abe31527fb501083dde40d620a86cc148d71e5ae85338b716c77e71c82b3d7e4446ebcbe3c92efede04a3e444b555d233f8f50c6d73bf2ecf0d7ec5e603d34d55e375a894563fbed054d0d57c6527f7ba70c0fa8a07ed3456428bfb2f9b9e4590e273f0aa5e41d7ef1c73d19566b10655babf45c793504694a5c292cc497b3d97b44bde90c8e733400fd0a6482b298c0dc1646361fa0d97630ed9c8bef84ff379416cbd16984f6305df207d1020b1a44f7090c5b2a074d55690d78c47c337158917dd2f53db5ba5ca70ab689dcd821d2ea72ce54d87642d7988b44d557fe913dd8baa472b232cd0705aecd0f1948cf387d8d32e7214d36615592514fbf255c58ac1f8fa58192d58c07f18058464148023a56265e790238f8cfce294539f8f0e1f0ad59bfd36f3d9016c4a40e51e4dd9c786fcd63a3f47e170f6076b9729f977bced81d49eeaa7292480483a8109ccf6a7c4c3441b6a6d488303f6e5361730d8ae9a5d37e42e9820da03342aa712645e8da3bc3b8143f6fa8f98b92171a789e7bbcc3d241ce6ddd5e6335","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
