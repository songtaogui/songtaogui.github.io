<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14e11aa1ad03f4aad4ff76cb87dae62f8febd4d3099addeba3f9e3d5fbabae24401a73e083c99e389a7c1b2d3b18bf590140ba98a2e9664b4dd40f32f41eea7ba938318617b7ce6d635227d8965df625ed1542e583afb3338c8440b358b2e02483cbb82e04f5feb3bb46457278d93fb394ba2c0a91154624e16a0132358185ac6b0f4410c73e3063ad05d458a853fc99b384053b7a1ab6976e200612d0893d37bb55a084ef5f8e195a0def1ec11c31b52830f3ec6730ff9cb9d4c4d7ec308909646b9e349ed210ca6e49653d5e9c99fe1bae1d53cc38a47aa692055f609e37700a1887eab0bd3aa1725bca3523e2c82152d3a2d272151d796a3f6183a499d373768dc6731f4ba99077a75b1c6090839721c189d5f26f06089c96cdbe556b7d65e81442ce686a62257e1bf34f7c4fdcac964779ab88a45ec95aecf2e7b705e49806f5ae64e084cc8d9e33c8268c358748ea1e182ebcabbe5eedf6d4af6071f3c7ecff5e993e4a68f189415509c96c901bf205a9a51f513c5256d9eeef3fd772770548843f185d077aa1b9b4a2a15ac47e1068095e20a90443f53791011ca731c7daa8e6cbecf1839410b4faac31c4cb31f751772294c582ff20b5ac2dfb2a17619047692c91eaf8e40520323933a71eb57ec6533f2b772776206e75965f3398ea32d549f9e76d82dbe70c94f4f7e4b737e4b853c449090a9fb04f7f5172d737c1a4d2983b5ef83242fb1e9ed958aab4a7765df606b710bb28b26b4f5f831d8a1239f58522c3d086e92988de43542310681d9886be37544cb09ed4b958935e8f5d54cb3c59f34eef2ab8700039a158b7faf57f00fd2e9cb93fcb133a79bb8ed0ed66b4d02b5c3483e07b95261e17c5fc2c68954d00e629d834f0aad077d9beb135bd43f74b78e81e2d2d79eac20f16b2790d4ca098427661bb2484b959408590f5a46914ff0945cca035c16328482451b9801d96a61590898eeef872805e2a05e0ae884a64057f2326793e9905120f1c7d46e4907e0c4abd5885467c7ffe9aabf19102b0418f5a4b3a9a4cbf72d0ad9914c7386c8dcd0b7159b5fb0913cfa4fa02c88abc98a3efed88fac15073aebdc94a54cd852487dc4161d91c7bcc1020e189f2522d8dd83ee8fd0f6176fd78cc850b811b9508ddd400e6a2092d4193d138edb3472d190763871724a5e86eea77005650fa168730bd8c52cd9e033c4926c1e0587f5ac485387eb2bd7c11d7e90be560a315e7c04f5b0750b6c672d60cd62039d22aca6cfcdfb339c435ce7312cd9d9ad2a78e6b5f40469fc9fabad57fd4c298d5d80291bc374cce5fc6afaa78c76e9effaa36a81bbf93e98e5e4a24606db88565d8ddc688a35d7953b01da7439174ee9de134fe2527dd430b63c829caa343375ebde01a5b9b9165a91e700db3774054989705da1582aa9c094f823f2bcd965c42a7548db36ec1ae93e229826944f3cb9ca26d1f6e48420dc252034e3e1e1d80075db2d316a58ba219891f84ce5b35471acd65052918fee8648fb65f0f1932a3fabfa842352c317576042d7ca5afab4aebdbf5815541d8532398177cb158012fa9c6b2239208cbecc6ce9a734991a10d3eacbc9615b324ce21c8b4423d06afb6de558cffbfa4008c0233737c21e0148fe3de65dea3869cbf2dcfd38d3b99e4a3fe4babbb198dcc7cc01efc2018e807119829b781b552a47aca068d31bc1ee85ff157cebb84b0bd7cb4e9a1d3390eac2856406ed736328b04497c1084e75c8f59bffc14b285428b7bfb49ea36ae5bc6d1470eee91cfa618052f8d94a5ff9a56523fd830095d2c4bc78e8c24316a0813d34b2a5c3a470a97fb558624770a5c564205ac681ff6aacbfb2bc99245078028edc966bdf6a2e01722f89b215a1e5c1798dc2bc856d9b47b873e767fcd9a4345446bd5111153509c569b1fb4c6a662d5ba82d0f222940df21a457a0fe117387ee2b4b708411f5c560adcafc0d8e518fd31e297795d0ebfc2ac3130cacd177803a50f59358c20e0b2c5b8e61423fe5edb94f03f0e487da3b8fdca90d3254338633d7e3183264902e5734397259a938b7ea39bb86ea5ec909c97e9fa439a67c7015310990b74780ab60639c0426cff3fbbd8aef548af08c271904684f9f30941c9cc20994654a58bfa966016782f7856c623b00d885b0bcb681df4e7ae84dc624a6aef7670bdf74a8a64d0aa5eb9d611db9c6f6828b3b2b510fa0b113b78a22a1a1ae0c142b67b989c15d467582bebcf4a2779e5d8f0f95c66ea141635ba25eb2b9cb20695d15aad0bdd21f391a8828186e151088bf6303e2536f035315a5e4fc48803119067866df8c89c088b606dd95f4f74b237c43da34b7c3076decd8707801c20c18bd868035f8c5a5652484418a89ad00b5d61843e6855668fadf91fe293b42690d9f5129c11a8c2315806aa5dc89f3890dba10f91c4841e0bc3156baf06301c6c889b7d1583148cb4b08e9cb532adfa93d8e13069cca30ea28b42d98f0f744a3bda38126ecb5792c1f40ec39098a17c0b80d8d547ae148b5d35886ee25777449bf8f30b2b01a2faf78c9bd2f365f5e81e3588c1be6f5b20f644675e524e7837d994185f46eff1b1d74a667e4d2f32b071707f26cf5874e8160c97a67425796abb699bf4525403774ec3d7e675e3c91d522a3e446c7405279ac7530b4517e007d23a7d974b39c2ac870762b3f707e5c36c338160898f973bc9285ed27a8829aa89371b578d5d184a7a9a3e18efbbfec2a528867a040aa45be164c2306b37e66369212a0cee34f0d0eed4b02482e3be97804a5e80f552cbe9d5fe38810e64bf94a9fd09ddcead493277ce4d1295fc80750983e7039e19f0c9d90ffd128446eda2c3396c11f4ac38f151188ae4424a94549fb70c4178b7a14b5d1f02ae0d048bc36e8f5a05bc21eaf90a2a11cd9c6e2f799e6598bba817d7ddd3e1b6cf50fb37fab376936d98eb6986c290738af991f9faba6037501398d8cfee86dc12a037c3c8cdc7c6dc003764d8b2a92ec6c68f8bbe18688a7e3e9f716ae00ebe2b8ec0dd4db595aa4b3a6c84c2e2763a742c3669526914b9af3e47ab500da1287b9ac0ec0756bf40b9bee02b1fabd6bbc1dbec5fd9af17ac4559012cf864a92709655b1a1faaa1792cdb95ff9ad655616f25e6d2d17075ed08ddfd1df59c29ae5465d5ad1479621d8522f076e7456c823445f160385dccc68ad055381d175b801ef1b3aac480dfab677835b4d7c757e404ccbfa7d2a50c15c4d8b16907db7385a1b87b1a4f469112c55b8297d3c9437c9a374a55d75e33188f8087ec6087e02e19b95d3a066e7674c3b8054352f7e18721e9ef62e8086b0f2dc608a1ca40b3fa06e3da1afd55854cf139979f7a5cd4601b692d1ac9949f1ca0baeb7920dc110e53a71f8bc04ec69788e5c72911f88878d439bdb0b2466010a07055fa56e31de2d37efec33d7a0c0d26d546880cf7e86cf2ef4b5a7c8bab27e2940898b9d31b849b37cf60de11ffa20c40b0b8ea475afaaaa11f956dab215bacbd18a61d97b8fe5fbc0ceafc77163616c322a99476541dcbad933c212c487558cbd6eae5034c9c5b24c5e8a6fd80e5c09d8fc5b2f2bdd1a3d42f6d1fccffa88efd4010a9e036d7c8d00cea8e12a1dbf7896e40e742cc2022f526f41fea587d6cd18d5646f7c8376b6ff8f5fa29dfd86cf5d5a08d5a7c143fbcfc87bc9a1cc1e84489a9c3ccdd5ae1e0b7e9c067fb62fd56e515059029d5adb5599309fcb7d314865b5023a981adb6db889cda282f28941cc6e5ea291a04a670e3b35341467da461d999d1bbf3a0d562b760a8c77051c28494019b08dd2f38ea4e690529d8fde8eb3c5f0fa3a43705844505428a1a862146bf973fd6a63a7a09b27afae12a7ca3e967b13ed42c3feace6fbf0233c991244b913922e83733fc320d5ff987a6d00ed53bd4451f7f0f45e4ee43119762052d5f12d96f4676a92c605738f62b1bee203013470ff356d2e1f69c8bf0edcbe7441e5eaad31e1fdc768730b2cda3aa24331c4e6a0370ae0c08170fef2b57ed2242999ddca3cc991d4544dba2fa8d5fd52f533188a62bb793a16bab660e6df95d3e6195e1dbfbcd215fb5a57e876e03139b275ce76346b0826e81a6b00ae2e29c26394d4dacdd865384bccdfa97d9b0e46f07a5c5db5e963cb20fbdb2b1471446a49cadc79bf4e741f6b5b5cc342a0d492f116033347d490994b3aaaf10ad71fa70e0994c0334e86873435455726926db9c55c185f7994f2b2fee0520626c2d581bf40ec70426c0bbe537f75868c04aa5372ddb1e04697d765c14d35cefdab6af3296d2a9c995781adb46a6e827bad276d50b874645997e3dbbecc7a0090965b7088efbcd476aec7907337467da02c9231fbc25ee8738b7d3df74f48d4da8929bdc070bad5ef904e115aaef0e8745352249b887b4715bcd6f4a548bdf6b1d53a1b5f2eb0d20755e3ac31f8aa113e6e08c9d2d403a888ef130790b40aee8fda16e58530e230dbc3bb07c3333d44fc2ee67ab110cb99fa0b5cfb75344f0a47050c142579ebb8993769811fc4645f508d614c7e9964df59518381b628f05c4d9ec6118d5b92271961d7dd420b3709f7435de9c0ae403d396c51ebdbe76fbe5debdd29756f38a9614ace76346bf3f6caa7c82f5002b66eb3c1fc143592e1acee2ae1911c7659d98a7c7a5425e562261343e8c4f8ccc897ae83d4e87f49221ac1e1faf170e43d84206a47f2bf888207712e945b31bdaebf03e06378c0a712dc18d3e09bf14c3ee13f4a58259a97e8a065eb635ef5c88a29ce9d01717813877261890ab67eadbc442ac497333e6264e04dac1158685a506a8a626cac514276dcfd616a335f03a3309cb53b00044e01b518923a12d96f7ed67e50e5be4ee7b48e0ea44903fde7a345aee68f534c43803207e5f45866432ebba66f7cb0dc4278f1851a14714c226e688c12468d4f4b0c89701be9f2e53c96ee68c33a12761d4ec160d51628c6bcf5f6bec0a7813a7bbe519916ee0516ecb69ee8ee2c3944503ef047a92dadd53474978092a86b92934b910103661cf04e1969c8906d6036591740e4fc86782f4aaf9be43040affb17b323346a2ff430137fe631fb240a88ee8873e9e4003a8456716bc100608d14daa4ebf928e9c4a1fc72c013cc297d7e36978af7a5ee18c7233509ac5277d552cb0d27ca3e584ab70c3d58331944ea7a5f748221353bec543d1e2bea5677aae17a7fa9e41526f97f5a7ba62e35b0e94eaa624a8d6c86640ba17dde886c2e67b546f352b05ac341ecf9ed34c1fa80ed79a41451b43489f28fceda40b1039b3acc4fe5f48c130a2a9eeb11ccde6b42c32d0df36159bd2484299fe3ebe4d2e9138d0d7c7fd169e1aa4900105f1fc324a76cf3a29352085e011296703c1de714bb3066fd9494841c41314229e29ba527c9396a8eb9e4d859a87619438f901566bc2502c4adc22b3180b181ffa56f310c3537f185308d522a3202e4b9c0786dc7b207c47bef0d513ef829d04e3582bfaf589a09750c7716a7754a2017f5d2a6cc350b1cb897a44c496506b2326cf8f0945669ddfaa952a6a685536ab81e4a617a5daece11597199c3e0c8e934ac83c766cc35bb33c7b8f8d55c0de392b2737755957698cafe016ab838a358a9a6b9ad9227da17c9d6d060c37976a76ffc83e28c938f55d0925172a02a2eba283217e730afb215f5fb1ea43d1a239f79ad2baa7b9776b1ef815f9e84b94764cb11d1d0882e1b9ad1b51ac69b92274a9481786294b2404c790600478d6d975cd8bdf3b9146073f1bb700e8224d6032b80ad04ac63bf94326624a782c6725e6b9f4186ea0cb36e0210cc92eb2a4eecd369159313bfc9e93985c0f136259b735433309813b18d2a44010404cddc06c9f54608bc117528cd2579aa923b9644927cd76bf48c10ab01e42bc01e468848130de619ba0f8ad23b3d8e100c543e657047302890f3e9bd475ca4eea46ea5c9cd2bc3f023df921b3c71d607fd50353fc612d2f2182c99500ff42fdc20c93749f025c8ebba1e466dad1686b3930a8536ce8fced46fe748705956e23d6d637e31fb3e552aa474de5582b45aadfa54c3cdce5aa728e25f7c875f7ed18e1250b2a6a562791aa910af90d79696fd9b28d470037b8395106e1fd3e8aa937848e791e168e4e8d234bda42ba35ed5cae37dbb080b624e2b049b6fd346b3a9809f81ba20cddcaeaba769b0cd5eed0557412057e061c1d4d445b0caf4aebd2bfd75dfa5651f86c640068ba1992f47800bef55a4dab178c91f1d9894cd1f4a293a87d9406f234d0124fdd5b00ec681d5e2eda25b721d38a6a03ff334beb1f95a8605857c886d014c1a36eaba61cbf1d4b054ff2f907568903c63849e1cb6992e17c39cc3d1ec85675e1394748cf10b66d37e23bc337367438896e540d960e46cbfaef4be0b6f1b8c166aae6db9ae1788005379962f64b339835aa5a07c273e3415426873d2f29397ce3535a50fbbca2270da34727e4fbda684aad5b96c3ebb3ccb3e8223afc41b485fd8e55b9bfcaca99a64f96282fb2386b7d89e46211e81dd8e8c360c820081224a2cdd5b76bf715cf5553f4a738758a459bd5194f7d3a4db0cace65bcd2350793c292199110d400b24dd783a28e62b0feb2b556aace1140b9f052766e3ae6447726f8cfebf56f07f3f01248373bf2e2d644a9a37ae755d20584c07fa4244bc6c5afc947c93dde38e8e1226ba95f844d8ce77dcfffd1a4b06aac1ce9968be8d2e53b9908d9b37e5584f831762996d3b21c81e1dc01e692c0a919c28b6ae5ecf65c0c47002c9ffc49842095e9f92a06b4707e4213e3dc34ebf0520377d99cad58aa652c5874f0457ed96f0b50f0cd58d5a93a398d5663be51c0f10a8f379c154b16b366d39f6ad817de3518ac98952e00385de868c6e6c56729c78d7b899aad086abd8bbd8071bf7c553ed3a4b988a5deaf8e5258cdb6fbe06529eceefae60412a4d1fd6dfd7897a8ddd9503b46943b86c4a917b84bfd8672ffacc9389927c5793ee4ef446e08d74ec227f4093b55181b34ff13a7d32a5d39cc2123989da6a83b441889886d8ec688d51ce6bfb2d87a393c2b7732ec18c94f3e1d2b293b84f1dfa25f504960f996eab8445ff7406294d59d0977c004cb87b86722892ea1de0467844c7ef6a44f3252370a2df961fe48cb9bcbbb6287895ff75bdba81df0ff12a2863632ceab93e86db2d3fe0b6cecc5b5601fb1488e1624b088f175723ce2a7892c2b0902722d4dafd980f41495a511fb0e0d1ac20f7831df46e9f2e2914150813eb28ec3c18395f1a149c33d9825d54cd09900c687c6113dbdd58dde4c230a092c301e15a7618e0fbce1d898d71547569cdddfd5ee92cda8afa8f961a67434acbca341311e4e47c2d42a8765fe7c2370bca91629d10255e3897e083d9adf7f1c0cdeabca5dde38dae4d68b0d302b7005c1628718504f820be0aeca2c615dba02a09d8c6e5c4ad471c70f1eacb7edf6038552ada78dfb97b1af6e6befd2d0719d7e1018d38b9fdd698ab078025deb8bb281e4066c777536b56b4f98588388aa94cf2a0c808e9dfdba5bf25e239e2ad981332596ed9688b43e961bcb94792243d0f6e430dd7621c30fd08955d2f351d037653c60a201408d47a79a57810ddeea4ed3b0134202718e52013faf4a3dfd3ad982fd8eeefa225c7a3f2cafabdf40a726df6551dfd3bb923622b84c63bda8e2ad69f803b29c0b35863bc1093ee264fce2aac24e948528f0dc336b98845c7cbdc24d781e24ba4058f425e7c2e7e9510912f6d1d8a8b33f2775e8fc44b1f98d3b6d098569c6f32afdfe7a7788247438080f024105867264f150c228743f1482e1e90877f322ce42a56f1f2c7b2733192b42eeecf01758876bef311ed4fd66992aa9387b9923c81f360ba19ed31343903ff8fa8fc08cee542ba7cec5cee6abeaeae48318df82e8f9ef0300920937b8ffbcf1d00771d3b67445962364c839bb968c4ceeac97eccb0ddd4c0e6e05245f03abaa2c5331bc3795bdfe0a7b0dc6f57bdd7f94fa9c2af00b4431e1ce3ec641c79b423460db84c2077942a265f4f87fabe0cfde8cfd63efc777b1f7738ac158af59ce3f2e332eaaf82e2224780f0336ffabaef40786f623c875bf6a4c66ae192e2871d3c1599597cdafba5e834577ec0a6676b9c4fb276fa36415b4a3edb6f6d81834def12e9aa683fba0aa177b7d32d1e2322ae1b8055b60fb1a21c530e6533538341f6faaf8ccd461d2242bd1e2d16ed74950a563a658e6964fd75b11a8817f8be1e0b280cf69e9781bf1dec90091919b2fd0e778ea0bbd34ba45eea11575845a580ed35941a972c47be84f4df0a43d7121d80888e0fca0bf95e9683ed2c58b2c47736d2fdcd806277270dec30e60bd62bcdf9f3e278ecc09069dc3899496ab1f2ba36bd299b0b72f4b41d20ea1e111fe238a0d37d927b5038efa365b81aa3420a1be0146460bb550711276375c87fa892cb0ef403e68a463b03107efa21450cabf11fd50213acabba8f3a8b1ae8da3b41d58f6bdaba2d94213af4774b9235420e439962d477af32f95d060aa801a01d34ff7ca6cdca891d5ab9f882f38523733570f1bec668b4c8b66b0eedd85a5297aac5fcd45b0797389d877acad36af75f042dcfdc7a7be6e212b66849f063fe6347beaab702abe6493193ebb2be75297c96b4cb731c402897c9e2718e80e04a1916e9f2a578c77990562459191a63a4d6cdf192896a8bad64773c73a03be580ed3bcea9ff0f859ca47e6cb6de29f9a2b28c127c4535921459c23361fd5be6832527d5c6ccf95663159369d722099c3f6edddc11fb53ccecf6866829f41ff6124d7b67aa38bfb9cff8d5d0b82e0c3d59814d9c27f357f4fcf397c0d32dcaad3b5e4b419aae705860c12c5032efcae31f455835630b2ed5dd949d141aa2685367d5d5f61b49bda7cb4909614a9cd7babd09bd1f21d8ce8e2638685857a117f18eeda6ab43f9fa64fbdf23d8ca38d55e1b1f4d90e92115a65bc97723f14b7ddbc5a14385aa535d024dc639086edb2d5d23e02889b5384c09278a58c6d79553a436a77265f65b2b9c37b5276efed4fadf2c353b55b4937875bffe0c33919ecf96347ab2907115d4e8f20c25abeccaf1c87d6c3a6a41a87fd11058518f5fa71424f498bc11f0a8ad1fc63d158c798d462fff53da3d5dc5dd05825751a7c4584acf0a0c61ef0e4a58a9ffdeb6df9239f4596ae10290812b4c33fadca9a6981c5a06093084db0d2c2a4fee2c3a2d38e11f88182eff11ca37ae6d5dee17b872a06e6ebf599cebb8692e42bab3fb42763fa998e8c114f88c4bfd9c0379efb858609f6e4bae84559d4f0ddbde7756db2e9870b297e6e913e7e0ed6a37419abf7a9e33c06da224b3eaa49fe66bed4491f5096d2b3411d95ab007e6f038b958c29f0b1bb2f2426d4dda798fc2392099363c18ef4c9e18bdc7f6e86bd8465961e9786b52f38ee7cbe57a954559aae8f1a568227b9471dad8693a27c8e795547698d0673cd9fec1799fd5131b029d133757152ca3c386076e58e145f5e4e3761df6ebf3439eda0a5d0f6f0b7c0ed1ae1686e859d77337509cf6c53e0ad8b1599c094313b3f852983c609d50242675ed8ae7704e1b38c0b47048c5675d629c20179ca740f78f94078fa7be9e8e55a3a512cbd994f75f4907f702fea6ceb0e4066647e9363d7d1078c8f678c5356fdca6e9a8a32f0c4d66ac72bbd89c2d8656db5d0edd503a6aa86bce5635e322daa8364c07efd503570b93255de864729ab41fdc7859b97da358193d19e4b6b9189c8267bc4446d495c815e95fb785bee45fa6bd355b7990d97cbe7cc2ef19893e21ca61beaf95aab2e1d2267b82d71a26339407525a2821ab7e626dfc66126e51ee4f66f482946b728f185a2982040f9cd00c356da71014ec142699e7104d967d01752569e23e0fb0410fcfef62f651aead3c6c1df47362948381ac23bf58bbafc02e5a29d23b1138be797ff913931c63fb62d1b5c2a06e644adea51d68d968a6f5dd004e714757f85eccec8b163d4307b217a279afbd753149dd34eab251a6e03c970d56c20f3d01ea9ef3f5a276b28be0321e757d7a4fb73e485fee508f5c473f2830507dfab543ea0c623ab2fa6268d7e175c3c02f2806a530211ad8c6d943acd4cdd8af6780a3db466c9068ac7a9b9f1b3874e41e8eb0b551872b07ed8e932dec3cf21073d8c629c575b6c3aa49343ecc77d2d3b1479d3d83fd53d64866ca4907d1735b89ee761c1a56393a34253379ee0b22edf8c330f0d1aea4bce0184e4389a5172cbecad8b7ed1bde085fa06a44d7fc789f6e8502d54f539adb3737e24a33db7fab39009e7f476fcb720ca4326fffb0cb91dea099da94749b2e387cae14c0b3cbe51bce89eeff8c315d15c0af79ca1599ab0e845f0bb92f1fcc3c7be9c139efd848ca88d4c5d01cf5fe79095839af2b742c17279454f04b619876d1ecbcbfd2dff4597fd3dbcd8ff52559f09b056320c6cc52edd465e7da972550f4a0bd9b3c5bbeaac8d9caba33a3e976f7eac8d28960a73a23ba72f384d301d8edde7f926bfc24e81c42359026d1fd19caadbf74c53fc6c0a515a42f5a8ded8d411259127ade2c4440e09070feec699402f279c188d2f7a0e9526a8822c892169209d2bbb505b2eb5c515e5344793fd3d7be28a9a55bbdaa7469c29d62d7fd4f88a9fc3b61f064ddeb30b00222a669755e07067acca355488566e8916b49651e30cdbf897b210f3874f372e0e959c37a992293aaa08f98c85e6a1f7f98c961bda828d887aadac151367e8afcb0e4df329f3a34375b59d8c4aae5d579491fbbcd6b2b14585f75e99aded16a9fb309b8baab6d91ac017d7fa1eb23737a840c5832c5f4737bac6f476d3bd2495bdfcf18198a11ba19d781fab1666acf7699531f982976c976e59a50b94e4c20653e970f4279a4dc7d0c71453ec8db50e742d879f99222da9014804fc35fd9b8b47954c381ea1e83cbb621514c264c9ec83ef6c5da57147e097cf2b211377b5583a1f8b57e4df7cae43cb8b32d3bed4243a8f95f5fab477b6e2892d95213c8797f236fa497ed354db9f761689824362013b71347f30d1622773954d246b5610bf098ff96484ee186dd3ff4a77da72ab38b0462c39c4f6bd955c2eccb7c7169d89a4651b09cb234890b3496ccf0ac89bd3fe9ac3b0661bc801801664af9f7bf695840a97c00884d81c4773b58210b003fee0d3a46f84b459ace4c333003bc9685c4faa066db57e1499a32f45947777afcbf09314b5b28cbc1b5f3542466ab0c06586834fe2efd677f19527098c417b9e4895e15a73398422745c8b637703eb9eaa410ea7673074c9cec9a5ce489f9a5612b61706a6b07ab03fb10d9418aa40c6f243b05fb3cf66f89cdf07e5ce3aad3e045cdef91f11c81687cb15b96231979939b627c8a375a499b3a9151494cd01182b000d9039053de89bf401afac1883da22aa7a7c239e7e7eda9cf35a3be8a2e7ef2fc8e2429c680a935842abc28c17931428d1407a763b5d166e4fac9e51b86e6306b55a6356cb4fdf73e9f234c42bf779e19e9db7a128ab45042e4b8bc5b1f2b852bd41f892610a15cf8683e63dfc803d27b6ff72c80fd19a8d82126ab338fe15da3d5c407a1ad87c49ce294a2e90bfb2d62fb214a166ebf7c1409f84596759f15b3ad9d7e86b35972926685bb8bc9170741d0fed5899e0691bd998cc7270b145474f50d149953a89f0e555ad644073f5d8c63af76e853c8cef7f464abf141f0fc4e51bd3f1c730fd930db689815fe418ab0d74d8f0eb6d792725a5f5c3fec91fd29ac248995bf63cb8fa1538b02f20d07a40af45ae622677a7e9cbd400a6490c80a0bb85f3aea7488f98f6af7e603cdfc4b592c57e9107d17e5bc3cd4f313b00156bd8523f882347312fa67180e82ddb1f9211a9952cbc3300b319d116c615e5ac554dd8bf283913859cd932e6d717d4c33f7df41dc83f1d7ab644ae9609997a965350b82c8fb441a240b564ae1ea2a21df011d810f5aa53b638693e44cb22127b552e4bf506c6150c02202ae7396e7016740e1134b5a81bcd8b1ee32c4762070e6ba458267aca4e73b5322ce4f052575f61594d8e51ca76ba0a41d179afa51c2c5c05fbc24c10d27e2dc539cf0b0a4ce151684b0207f8f01eb751dd5f5bcf40a4969c4628c8a6f97e42291be108e3a6149a573413a599c998967603786ffe0022a67d0385d3447d803bca99a21da21fe4fa7c93fe2e494e149edd671c5aa19ee08777dfedc9f1637b97e0e24bb706e122c8b3607885b8fc43cceff312c12d5081c3cb0f0ce2f7fa42a5e1731969cf586eae7a95e25422f6b3609ee33f91ff13a27b7f10a6853af6cb8883cb60df8910b1fdd909c242d85c3a413b46f4252beca54cce15fd5909d9ce6ab3cbffd149ce0313bcf1d31091653086a25b567a3b3504d98968e7e430459ed26d276fc1619efb5d14441682e006059adcf75984ac385eba68fd0b0b3c5995056f296c1f2058e143f6758cd4c18dd484ec32397571b843b84fcd53c49d6b03760a9564f89454b34ec31951f1f50fc9b61bcf13e5cfe65e14c602a9fcfca29ff426428ea773f8ca7e92d3076441ed43b52089e4927653dd95ac82c7871993438db2e8f6d307d69e11052b12b5c987d94414ba41e17270d0c14ecb489f27014bcadafddd5dcc59739231f2f5dff84414f2d9f8c1cdf465f92fab2b426380c2ef7cebfd0fb032cc82211e1733b8a63324bfe4227f46e3c2719a06a3bb4c609df35ca0c2293af6a474cfdf12c2cf1f7962fe1c6b7dd504ee04331c1e50732c6bc7efb2b4e8102a20931087333d21026c1f312168f977ee90108b720470d0901f730c449a9a6ada210afe6737ee57ae0f2c24ecac6476891b885949f519e7a3b46d1d9a3858ea2edc52f2d942c48b8274a9914eb8898541e1d9726e05802b6e89b0448d9b74a96f72f46767558b8422df4e469afa891c7457567b9def86e98cf706665a0196f10a1d2bc7faad50bf3ff395c411311b11a5fa9b83d97be2cbe5f7e77882d5e4103860f9899eb52d4be49e96c0a90b9c29c5634bcfcd4bc33d84168e48f6ebab297dca8f5098e31e20aa6953f5bab111df836849fc4d334e7f7c882307c0dc7ecaebc986ffd11210653f3781b47715c9a6d8249612ec70cbfaf94654741bc7d0ff0e52b554447c61a8defca76a5d3d247bce4dcfb1dffc682c7c4e44f40934d29f0a4aaf732589d3d4ccdbb3c4968d0aa78a7eb26337d7b45ba5cdd3552691915426539d5eb524a44418a7f9efc59290060894ab528f3892ea61a316f74fefba721537ff476d4e56e0ce8f1edacac486b1a0b7b0ee92660f34911f741bd22c1f147884185a9295252e92fd98174f8867db4684448ceba2dc2f23673a1898f77d2b1f15338425b6e085e02d227cc9f132b41d7651f51e0cf0baa948c5b6a893b698166bfd5a743a70c558baf5ae24d431a565abc6ef50056cfdadeafd9a59206ef90518845ca12d124e01f32d00137720c8f5aa3a17ee99139feafb3afef1a686e8f69513df41f72ee8a3ea37517baf293666e1fa8604d16b5053e70023eb44995c6518172e8b044e828ff6a61660275f797368b5d31f20dd8a2b5b775a7ad36a8dfc84b635dbfb90af9a82556e6acfd600e6593b585d03d3ec7d9cd7cf502443d0b635c8f508c829c9d35ac1bbd5d3424bce624e10053912073a1dc79869ce292c1cb4b2835f54fa46e07093e45ee261727d665505348c2d99998b01a22b0e67bf5a7435772b37b8b1379fe3e13141707d80948624097287744080548d77f8bdf8ab8269c0edae5ab3d7738707238e7297af26ccfbbfe91d37fd5410acbc271b3ef525b36f92d68656970f02ad0846b7396b5ea2dc6fb650b058cb52e2d4a53f7118e7b5448ba1eb07100820b428d408dc784a858d87773425e30a06a5c9fb97707b15e5f30537eda16acc0f5cbf0a99a40afeed514a55e29347669effde083b2219d010009c2c853f89b55a5734578f9958ac8dcb4a2cf69d447d0354d4301304d48da8317215fd42f029ae33df9a3ef309b11ed4e8abb22551c2606e85cf6a898ad990e164c293ea9d059287ae70bb5f78378abe71ece4ea0ff5b1b32fd87b3fe4a9aa7fea22aa7d5668ba299196e39ff81b71fb28ee49e162ca52f81bfaef5b9516d7bf576a887660109f6942e1251018dfcd59a6f7ad23548fcf8356df8c0f9adf35f0852a53f471e30e9e5fe648f7e1b95da82851c0a7b1eff936cf3f706d63da6d86e286163426c3ff9a631dea70ce5f121fe12895c758a9db1f2ab851fc6782c502f979899da046717fcb21ba3e2050ec7fdb6b76f45c0ec8eba24dd3381ebdece808b387d2482b13caa4bc8c7542ce3fa42d278de577309483a05098496bd2eb902f9bf7ecd8ba711a8976eeae288873b06a35a9b03b6fc8845cb1cedcfea075e28febfa712fcc1aed57b3724a07f25fdb18a4ff12b7c574ce05ce48985621e1e307a0a2d0623cdc5dc8b4c8347819c553475e29743693b58fe0a08e5e174bbe2df9a2d44a6f60d8788ac62d0da4aa75d2649b71e6640c556f999504e1a79a3b461df34ffdfc1541e5f81f0bfe234133ebf24ced15b3cacbf10c7c17a9e6ff376f6fc03333ce983ba7440f7013a85dd7d0a3a6f980edb4866fb20c68ba39fcbb047bbed2b7ede1309813d5b8019720ea66583a6d8f4c6ad1a972921f0b47d7cf28b37a44ad8ea021b0dd5d8a5442e866d3352d52854fa1108c8d5d258405139e0bb2a5ae81eb11d5391b42259243b5ddae845875759a8f98261389efe667812a622b8cb0a78a7439628824e07b607934dfef27391fc1905fd54adb69f23ef200f3e8229e77142cb3f954bb8919c79ffb87083c9c9c0369437566d8c485c79c68139a4ba8e31583e7c5020a77d361685fe2d5d11993010a9c4b09e06769a844d0927fa8761e1fe9cd6b25ae147c124717b43237678f2944d2b60341553660b9f959e638e0f3100a59f63c6f06cd7306908d95ff7c5718bf8ad83df726b4a539e65b89e68243ae0ebcffd62f1d315bc88804c54c2c742032e0afc16db4f3fce804b3a8f6b553734d363381de5d497d64258a62e2660b480e0ddfe0546e6e0c97156c9951b4e7a512784c274f7d3c76ce7048b45681ff6442ad5e3a45d3e96e0580275384b852eb5a87cdc432a123bf588e5b9422df8fc2ef5f3813d03f945d4eeed89b554e9c8b307e37ccf97ea781fdbb58d3e5b8779b8c1ec2e4e531d32c9be0337bd75dd53657f79871a31571295da1d26b5cbad7b35886880dfeda1e848816119b7d31284225715000869075c59f8cd4b58cb9db470edb04026a63f76e3780394937045a5116be5f362fffba6dbd1ef6bae570955da6b753ce27c690c2759fb5f05f8d56802ffa52b5becfab48befe2700379c6cd21917e62ab884e5f9e16e5096708046d568cd40cd79303b38e998ce597746a0abcdfdfa892b0bf18449a7413e1d0e3d4bc1e26a425374a295d293d89c55b30bbba21a73a14a70744d47c30e7a8c14693f30390cc2f8bd3f231e920ea37e9dcf0c08e5be82f683a81ef92939493220a28c3ea4753300b85a69302db0974c6d5749c1f527ab4cff5f9a30d2e816ab172b6607f2f30f05fb8dbb0b7873e76341434f6e6a9e1f1a136eb72ba45fea90df1ccdf0dc463d5d4ec353f42c7f134143eb9aabb48e21eda5a14e8b708ef1129c975b11ca0597b1a47d7e640f041cd0d86ebf0b61fd142b36e2d8cff62bdf1f28e690d02a3115f4d0f01fb5100c7b3e31d4dbd7e3bf7d563df1eb52087194fc163632334c603ebd7106199ccb2d294742b4275ca4de224d28e33c8ba2a9ed2163fa8aa596d4d9bc45dbfdcd026109455cef851eaedefe30f7dd3b2e9a6b31d3c0c035a466f0f05873ab35ef7133f74598cd75062e5d7ae7ae1ad5f63b2e147dc8f81c2dd340cd88f113fe335528027f567d681610a96e7985153010ebf9e6f9aae9d3bbc5c965f6aa8c136f9336973c43a7f9a1afdac30e26dc6207d2049752e3e51d1dad2b80c2e3909310de840fa822d6bb7376895cb7410be1aaadb1d5d49989c51177406e238c4063c7fd1cf7643f2482d625b0f1f35a9aee54fe986a897fc61b9ed104878f7bc4f4478489726cc100662e8e1981c0e0ef8eb80c704f40f1806b1d34410885d449105f498e03bbc676e79eb66f8524e314e476ee5fe0639b33766d6d6d1e3f26eee0868c3ac3b88e0129845333b09893d92141a3523a544b0764fc649947eee15d9ee6585d6ba878b0ce1d6a0af4307018c24bbc814fadaa7e72a171153b9e86f0691914efd0ecab1402580373facbbfb246c0e57fde1bd64e4b36638a04de704ba45b249fe58dd556139bd97cec81d48456aac5bce9a9e72f93460661c360554237b43b64b73651b5780939e53d47dbbd83729bc8ea3569e625637eab63be16a77194db5990c2a1d7001ad20d713b5306dd383e9a7f9abb996d1c36a374aac0bc7a50434bb932a7a093f8ab82d42ccc90cb7e8c60634534bda30d6fb39b59c08469f16caf05ba526d3fc9b5a9614c0a9ef0ab3e11fa5c0ec45c7bd54e59a75cf650c769f9b6e48025d86728bb8c5788414b552e0c9c2bf314fe9d1ec813b2ca039c049f8719852c757cf4d880e767b2203f6a04d74dc905764c80d8f4df039053bdd44eb5899d21df868ddfc0ae11a88c92da17f772c13feb26ac18af41c6ff1e9fb41fdc1b39f00340c0e201c42609d9dccca9fa8b61690e86450d28f707082a966ac2dc56a1a315b09eec55fc36e4a0a200e5acd81c7b2866913bb22a230e183741bb4211bfd45368c0201be7188ea5b60bc1716ca2b77ee11210c9f7ffb3e6b6947b8f5fff1905f1be9de75e2d4ddb911d2acdb85e7e0207cef9a8132b8cb6907fc88ea53bf6e1ee4d958a67f10631354f6f88f9201a3970ab39093548f5a3f78255fd6d480d6941100eec04280038cb8ab06ffa91fccead3bd75d3dceefd6d418bf1561e4c9b62026c1abc0df0e211bab018f32061509f5b3da5a09d8314e33f11409220afec063ffd629defafccaae05e01f6c5e4cf07fe173ff74b060ea202cf988f06808da3a14295df4ef4dbdf7473578a80f16e88513b6214d4091700f96ba062ebc6bc16be3af49ab4bc36ac6c8f14d58fd349098ed8d3d33a5b9d7325af731a8c56fd97f3f33c5457a22c26dc93b3c42cc79be33878f22458d0d1775da2354d02920face5e157380288660581cf6d9bbd0ff6f999539deab05d115da1287775f01083045f45ac80c331a83f4093a87ec6aa18a839fc32bdfe8618587cefd3e564c407d921ebf6aabc0766662f65a126d7db528c242104ce8ec0bfbbfc9f2be5ec37095f875930c97efe4c515d3b678ef17c6fbee04c053c093df31a81da29f1fa6a94521f5104dbb0b708d4ba72e8c895b91ee278a9ce4c5ee7132982e7e49baedcda34250d2950baa8c356efacd99d134467c2d68daf633f85709ad3190cd43ac02e14c2404b292e42c33f9c8bd1a71b56842099f29f9ceaa6a4f05bcc14cf0f54ebe4f687fc8ae3fbbeca79746a91b19b42a30dd04f186eef34aad462e4ae140ec92c240fb74396f28e9bfe5df4a5ffb9a8efd06f892714cd450c3b3c640ce432232310c28d76ee975532c589db7305f40d324715707cd65d3ae4312997a9891891c8d431439d1348310d683df365172906d2610301fa05614461e18ab1baddfcd07fe8b16317fb312376128223240ad16d3ee1a1e655adc8ff166e71b5313bdd2088a521a18408b2b205fd8671892545e49ff75ac86de4d70748bc34329529247e6827ad16696cc14062e81e60b4d955c5027e3ee780e845eac903b0c31854d4e1c12a0cb1918874ff0da09a23236169641966dac531f6bbfa4460e1e19123400cf2f46979f64073637d6dead9aeaa31fac8e32c8e1441da64b1872a46f3fae551484ceb68ab21542262d196923b596d1af1ebae4e52268d7b6de959815afc97c313b4e24dc4b571625a09b913647660a55363df372c994f1d231de648cb75f5e5e4af0e23fa0ad7b9d010071692fcf46b935af5f73c48ed018f4c6138506b51654e67db034a44eee698600f818b1dbec17bb1ec06b01ff0fbcd0c42e355aaece328e2fa9d87d314d066eee4a68c4454057efa60ab61752f102c48bb766a369206209133055a1b3c595879b06bc7eb7efead3d419b5de4801207aeffb070a737db07a4efb6fee97e14f02cf6349574cc69f00ba1331d9baaf5a108362387aa1a5e2bfdec3a530ec0ac2945a4484a63cc1db6c91888fdd55eaba8b03946ea3298c0da90562f3f704bf046fd191d04080c26768dc595eaebfecd025669c130053eae7a836e02a72c5c1e5c54db5e1338ebf28cba7d9ad0d963f9c726b767637d5e40c76c4ee71cbe1e22ee93f9b02cc562ca77bab5ae406c5ca1f6f5255f9c0d5d224850229afb236bdd5c7f6e31a85f01d8e3d58ca9d2a63de23d4a6f94bd6cb0d548719a65beb7c9de7d4e4ed8bab96f26c1ac0f358eb1a8a991d001b835d0e3062e856035566","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
