<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4e2b863300e1d0993eb3570996bb24980f0fb6670b5f8d1b7db89ad77c102ef87007a732def47c7ed8a1020f2b0174aaa4bbbcd25528c4b124614f1a287840785b6287ad6d49d698c1605ec854d51cd5106973ec190017555e9407f4192eb606f845f75145632ba4e4df72a1c3d92d3a472dcdfadb8cdfd17268219dc2ab340a6d7aaf69a021ee087d56cd5636ace69b2ec5012e7ec9778c931032459c784e1cd5cadb3a6306d426ed3005f958b7ef9ca8909f556e035e59e8dd085df93390c9fc300e227e9fadb82841758a50032316c8ebe33c4b2316c5c7f371e9665aa7925f24ad17f31b23676fd85963938e6e3dbdb827e10265518e5102c027c90824dbbd255adf0203864982967b7bb30a943394fba94ccd0b83c68639b6300120eaee24e8971c1f0ffcdec2b4584472581d48dc949b131a13e3437467ce3d67fbc7f1154c29eeb3e052074867fc5ffb92650ce00b8032a9b071bdc6895f25d5de5a3d7dfc4bd9e9320a970050788b31cccda7b1085f601f105fa1ed01006b64e6243a3fcb5df640bee71fd4b54c0e15f02c6387912462c5be3e1727e4d1138f83aec227ac269f53069a77865f07e13c0162f403ce18e5234bc555159dda3b9c103948e5f8caffd53c7f3accfcaaaf71fb0dfb5c23bbd9b4d67a12e856ccc074688a9c73e190cb1bda4621ca225a3cf65e501b89eacb01b71b1abb486f8efab59e4a8e78b37b4e44f1d5a339e01a88bc028eed60ea2dbb6659c7d9820732f2b43ea29823f495ff1950b2dbcb004a9f072b05b23a071f4e02dba7a13fdf5575099542cb4955862af8248e01cc20128427f5fb9df08c9cfb4109159e951e288546f20aaedf32f4b0d2724478bab08c1bf56d2da4ce81777aa5954a6ea3290f478b52c8fe0ee238ded452c77aa2b4d69b2baaa0572575cd265dad138f43d6d8507a8af8162a146671113d57f205687b4584c3874cf4cc8da893be0a858c6578a0818b0319826ad2b99f4a1e052939f319553fa558635755bb8e85b30bd3dcb2a0789d0dbb8b3c8a5cfdfb3e526c137bf3252d45eaee2b48dcdd18a0badda2ff4f6025d882af24bacd7ad544248be3e97c414f389bafe6dc23354d6fd4089b91d9c271d272b916b2f06ac0544eeb46bca81f7178a685ae3d0b66ab65efbee88dc24e72ce7f3b48886097950867f9f0eda28c68a8f1ab2c4cd5e05cc5ea7c471e4a8e7374a87c1d04a71be01196c66d11f13860f0d1953d25ba4bc4950ba3e7e67ffc61716f9e6367869be47cc92f8b8db873cde593d6e019e8ba1376d58e376100632b9bcd731e6cbb0a115b77a7e23fdda76f60fa5a960d8bd468010616b59fdb3b957091cbb21872aa9bd7655831fc6e1a5ae22467f8b7f510999038b0608a39972547ec4f2b7dc1d6fd8a16c2297671c02b7312608caa280bea7b229b42760c2d15308325d664510929edce661ba60839c7a0db44e22713c0261a375595571eb78bfe23bc0b48440a60fde2998453a654e6aebe4e464a2accd0a6cfd5579e1f2e3e108652a41b5f76adb9fa04aee5511149b3fa166491cb04b46e094cc2201136d1174eaf506b8166e146d2706393e951339044fc4b46e6903e920ac3432e9b50ec5f0e742acf44ba0485ccf5c5e61f8bae9f5355f121c60960e96f5daaac8c859a366f52cb2b67402d2b082162002ffe5bd0f980740e78a80a6b35c45252cdc5ceac67b3534c4fc4b907a0a4a89fdcdf3baa1216d8197b4d1ef3c08dfb70aa83bcdea689b3de1e646e2f5da13389282490bded03d5ef6c9573e26b2a654a37d159d7e0d9cdfcb70bb36db1c1303526ac5c18da7535ac491cbf7ada0aa01e31b9d6adfd62ec7d51b828578c8166a1c1efeb74b38443c8dbbbffa0bb6fe783b872643aefe37f067dbd0c815bafc48b180448056a5d4cdbcd1dcab5eff55b2706eb92e1c03bc46f7f96a3021ea2afa58b1c9929ded5a00ab35cab76fde69de84a5c6ec084126ef34a195ce292ac73c200f3d847a54bf63738fd721e029640dd45c92c7ca3d05d7783dfd36206cf8c2467cf9193ee8238df24680d53fc851aecc8242881a6206400afc414761cabb20e341ca3b21f8c6e4ada40204cb264114c03be8ecf01085a72e8b575e038051fb01d654318d32a1f8bf1d9df59a4e12d6f28ffa40abfa99b95ff164fa418d372487c0d9e39acd7815902ffb635d9628469c8b89495f712e05db9203f96c9813d963bdc13284d9442ffd885a5487c85fe48fe4e7d8bdeb0dad87246966b256e1cf8f0597e8558a16b94e222eaa5ea339e969d3d705f6e9eeaf330776f8dcc11c218f1c047f9ee3641de511537bb8b9062bbc5cfc7455d5b9b3a229edae8be2a6fd920e6d85aab90fb75a84ca5beec67ddd200ec095c47d9417a1c0d467a592c093f6a30f80d423d0be372d9abab97e72d67f9c0c53f36a89ff0bd3cce0f9dc7c29b99b493fdc8b0f821baaed353d6a57fcc2db2659697a955d0de0a8a401bdbb43c29019caac9d0dad687311ac7050a193cb01089c1d516e9009628958ad7ef0cf77152beb184ad1c02df8239040335badc64f7d53f99eb149cae805332d38aefdbe9fb04534666c1dade1609a1b3b513ccf28750948c1019d546f01485a8680893a95eea02f9622118c8e43843f7678dda5dbcb3d28921f024cd3b96c0e007f108aaeb41c3fba0c76865d1f0290deac043c158113560fd005b8782d8fcad98f5fcf0f3ac9dabaf9afb5105b8516f2ee5f2825ae012324660160ed09e76366a9cbe4bdfa5af63b8f8ed4fbf0851691007540e2d7b71fb366afb0a19422ad4bfd7936f8fcea74a957500e69d1e9135af8cf180731aea6db8153cbf7882053c003db9e2de6fb92ea6f7aca05ff5297f72794b60710259feec995e155cbb31ff6070bf3ebe5703e4e9d7d35c55a150e5791587d62efbe2ee0d37986f78da7fa334aefb1c493b634cf4676ac7e03ed2270cbe0cc888b61a444272f3c1f227c60cd233220b9369eaa0ed51b6b8cabee295bd4965c461287e91cac8e12866f97b788191345deceb7f80f938a1e419e4e63e14f4f662e7cc65b9637b6133d4a1699ffc59375417ab6e04163c0cd503e3c0eef504ed25445a7c5bd926676a5dd9e84a3d3a32a763f5cfd152eb681dfc01e8159c560327dcd72b48b91a107c75a22c1201fc22f5946b1d68b280ac0d4fe90d4860084c56ea2043bf134d8af6d183094dcbc61a58c3382ff0e7c8615ab1c1350c3c7bfd16f9eb86d4f3c2dfcd643f25b39346d6f0049f6573aef925ca2848d8eece7aa41a871450ea2f6c493fc123f1a70d841621749ddab04701e9d23ab18d8cab83257499d7e0cbb465461addf81b34994c84a0be8744310d59ee680c6f04b5c3bf853331a6b239415c9c365e169f0cab5fb4760e9d8b1266a14c669a0aeeda0dad56ac0f0e51159f2559c6639b4ca00dc7f4e6da24968eafb5f00633c0ac5b7b595687d2770b416e05deda6d03610957b90ed991c58513ede521019d904a901d1309cd08413634c868b940d20553a4a76baff17234cbe70319e09a3194d9e28aacfa919446ae9d5ea5969872d9b4ca7887110137e7f9f9d2a4b54e6c392c580f5d5bb435bbfdeb9fe8371ea80da9c96b751b146cf9e7ca23bd7918a2fb94074432ee053519137d2de4b53e58c9a8b2050ebd109b98a49f8d75170b2bbd6f927e4ee4fc825d1aebf2c95551202a9dd6afd8709e55e7c9b735789c3b367ae39df8b60085b81d55435211814f1f869c372481e90c229961508e6eeb8fb987de641f510217a6d6210ece8ae0d7cb7ddceb3d7b13ae69bce3a6bb68a9580e68227b0ee070526dee96217a1e9eae88882fbd5760d6e32988ac8ecc09b30c2c46f63a996ee70f7fd98568d63693c8600ce5e63d77c1cd1d21a8d4634f1fbec4b9e5782e65326810403588e3e5c9f702497044c81bfbb9c966caeab9d9828136ae193ee79e4ab790b64fea75265125f970fd35d792798c61c2f4bfd67109aacaef04c4f8956fa64950a98b419b707076e34db477e05e5d76dcbf4105c52c3cac2620710331652c63f60c1f9fb16c694e28e2f409d1abbdb8c4bc25cdb586def2f7e4ac91eecb3b1a39788086fd6d90096e8b3f12eb760e5cee0f8bdb24b09520b8d819250f0de69bea52f0fa389db606fb2fe039e454e965470dfa30c45852b74843c4b2c87d51863d41c995807b4777cb412e7459d52f2935c71f7437b1d889fcaf9bcfaef4fc450aeca536bed32323d18d2b8d465beb36b28d226064b4f9b61db1d62c037a7f473a3695c585a60f6ec5b7720596f6e9d9160523f3064e729040d30c373addf76a9094cabfd35c83fd875ef96d548991bd190c164a86f2d0e8b66fae8ded123e21a5224e31a70e49fbfd6bdae8544c5c1f26aee7f31ca6b52fd893466763ef27d29a1f7fc35ebbf56baaba4a517d9d8e807269e6863655b914267a623207ee1249c242267b59983000542762529d424927b77cdc0ef82b3c4b3c231ce79d3102d8814cc647ade939b0851368174daacddcf8d77c9b73feac6d12ac430a239f22d0b99fd437834a5858b9b104e77106793a4ef4f3115afe9571f3bc62dd9a2be5857a48d61d67e81f9bf57d9ec1d9207a5428f89d7a44f3c3760a3a78e7916342cf68f7fec4e8242d667709a048b5c24a431a1c10e499f6a3fef955a82ef26f08ba0e94b8cc723b5659a2cec68c0c747dd6513c2c0dcda8bd5530b1bf068c3b2397f32a00ae91170c6512f3ad64252dbe03e660d7dd714106d8a396defc64586562adde9a7f085f9ccce576b4c2da0e32e749343cc130aba40b1286a380cd5df4e7b75a36bfec5f2ec407fe4b62a1ca7f14e34f75c7e41a49f375637778cfead5d926eb53386d9a12e3074692429aee89a114119790b073aa19e9e412b3da7d7e85fa7eef0852bbd702acd6178ec2a5f53849f0cd6ff16dfb07e3c2d3c3ab5e17a9766558ce584b4562cf50646935a6707f46b272ac1bc75ae8aebe0a56a77e3fe43cb92eee8e1cce6979dd564531756408505df15d9e4c0ffe99fe59419432b6d1c7780876974de0fd65dd5fb905340b61149fd601adaf3b7a20dc8810249719924907ae0e40786f8384d8becf11d534dff51fcf3a040cdc60bb1f2ced721f51c4ac5f73374baec4aeade16cb54e97c50c1bf3e310506713ec366001f9519361ed675da08822d1b3004c3ea84fed7e8eb70219c4c03e2790fac44145bf1afb933863e19926d000576ec46e8fc2efcc6ca54adc60b24864e3b018aa0435f799397b2fbd1cfd5a6685ad7d9d44ace0315cf7949ad06ddaff2288827acf51e1ed0edee5c3d60b9223aefb78249dfb804e340f6904161149302dbd45f7773bb6127e56970b2fdfe918d6e1eeac390aa935bf1eac54d2a53ae96b8c2054572589f93de3cf271e51f3b17e7febc37ba41083565c3855feaea48e2ed17c10cccea890be529317ce20cfe81a63868bed0638ddf1eb5a2f202a1680ef5723dc65e6789bd36d23e2cae28c95066098a30c8629663ad71a71cc9b3bcf09c8ff1eac500d50d35d557dde727c8884d574189a97240d648e0682b0ddc226e707d6e3a16aeabaa004a6c60617ea7e10decb4130fb76939c5b7855436b061a3b43991844b7ec096ee7c08c9668cf5bd79ccc8871ceffafed318e9b2b706e2b9c70344c669909bc4072a39519dbf86fdb18d77ac0349c7404ed19acc0150d3b764d8f379ef51b100997c31f904892dcf8d5e0d858548dd1f822541710b1226e9b8673068cc420c68dd3cc7d48c01a4548d25c0d2d8efb1c58f7b82616274dc2dbea85f462dc137a9e4611d893ac9a982bcf18773b5ff9d78c0e1f53e63885ab5f67827448e6892143fd792fac8915335365960bae7848864fb3fa8fa45b555794d4a77923ccacffd046ca54c02d58fbcc1fda69675f0dd48c6138a4d27c285da00ae6bba3dc9ad252703046d121a91f62d8a897feb7e52009b8601215c62f5788dc66611d07e63437af58f1c641cbf1f25bcd2c625eecba86885e1a4cbe956851478d968dbcdf4c39e26c9eec83ea508cc6deb1c82ebb1db8f57ab3120c55e38cda5f7dfd9c2a89cbd046503b5b8a2f349994798cfc73608bc6168309fd4446d62f8cdb45351d9cf5c1949e0a7b1437ecb2d6d963c2a4378c8d8413f63bb5b6a5b6ee27cbff2908866167cbac9ad14185221be3d8f341fc2e61f9c5d4b2faec0a95cdadb409873dc4645cc9717bbbebb11bde1d2cf8daabcef89ec3586c4fe2ab5951b39093356dc795542c164d9648368f45c83253c267cfd5cc5c652ee13eaf0435d1b7269c2cce31c06d2e51f88f25f04e55ae62b57fd5ae8be57f6cd871c0b20522e4c5e21d88b061366bf22e06a82e01753715a8bf4a64369b44a9d158669b124527c7e9c5f050fa51cc81be9952bb73cb8a75653115c5740964e431fb300c1327e246c266417df1e5b93bff2306b88df276ac7e2e361c587fa99983b2778984e7ca149c60be2fdc28c35aae4cf1900694a4ab490366fb5084180f938de3fb44221d6526aaca3ed6fac5cf4b684a4d6fee6146bd8220c4974dee5cbd6091568ae9886a05f7fd656a48b498c4b528157d44cc272ada45a6e3ac0d7513acdebe517a0e80067abba969a1ca3f665969d80ca8b7d001f7e26413a0b9c4b551e03e4b62582cb3fa95a06e7ace7238079aad2dad8bf518a16a41243cd52308ebfc0e4bc9afeb279552a96bff674c2d51b8aa8cd7bf1e751bb78466ba87d4f910be21b566db0e305f4e2d3204880ea986557a11d9cdfa160aa60f8b6ca79f074091f232f89b0f494a85bfabc2ac0cdf5db9c044d2efb75228f54522d984c43fe593968fd8eb67ab4820dfca7d321b2a3b7865ee1f7e296b98531b955a742d61ac74f1ef097a347c73f1b6678b721116c0c79618bf902ee5c05d5f22c3f8960e0e0059d22bdf302f240539f4102cf3438f73ceec35d4d46d01a1da86f8e5376bad65192a25cd1613a3c14779c57e9c83a540330e00d5e3ca79533e7eef395917094810dff86ea68772d0cfbf83105928696cd7d97f1a6e1e467b8fffb4c0fe14150733ccaa5c6cf1160c5c67037d6b75b1b6c39b0fa9e5331ae3cd358deed22e7dcb3f75bd35fa9b66440219c14b32b7cc8f6acc63a9ba197caa5da7063d6b86b3481a2a5cba04b18d7eed29cbf5c8389e5acfe387b2f2155f67bd351b5cdffb9fda3d08ec92a163b4c907af586c65da1ee6d4398bf63d393b6ba7d33f1cbc126bdef015db09ecc0675f6b1d322d48301ca233d9b18037a0720c6ac8d412d6d2dc11cedbcd505e018af4ed58d026c55ca54fde8b672ad596a9f5156b719681e59e5bb210fc444d69386e95a8a6367b34ce4c5d366ad5aed0f2cc8bd97c8261a0dae98e94a7029ef340361c65ffca0ca104a8e03cfc8d04d27a519e8de47ac1b8a40a58d44aac9fffb0174707181c43d5616a213c6639a3e81fdc4cc1cfdc991cddbb1b1ed187c811cb5d9c4cdfe7fdb98cdddce7aa8b479fb6132fa9ed9411362768d771aad9563253f9081c96564d45cdd373fa3f875f8b250b2e7748354a31f49e6afe466997e66bd51bf4850b0da26eb01a2526059e89c5e911db1180193882cacd729249529ed1e2de14fb0fe3012f9f9c2f9f7343e24ec05bcf9d7cad31f33d124de2eb46b3740f8b831e3d265905191d756c4db2b5cceb67761ecdaf3427274be7e791cdc1e4a83b173584268f1eefd01a7deef89f302ac17934119c0694a6210fb0ffeb6eca456ff402a1b1ce594c2c3f25a4466d24b5296f0bba06a470f249979404ce68ad2bd1db5f7471296ff553c5c345719f60f1cb541a240bce26852aecfee5772d5f6a807fa026542f15d1cc78fb9773155137854a7f171749b9f4e61597004bcebf843a4c16bf86169e2f01c4164d71452cd1cb6f28fad6ff3f41e615f3c55af65ad63ad3642905cbd94b205afc88a4b3bcd43a6335299474ef4587c8618bd99c2b6efd27bb86fedc101f1b17889832faa45862b519a49e5bf59790b026234d1795dfad1025764f5b1bba48424f120137f6edaf161a0ca2dfaa75a014923c2005b86623585b424cd86013c1caa61a8e4b241f93fec24662a3b266b5300433ac0439b2551d0f5907fac6898e37d542acd131d8c32fab4ae125aec787457582234dc80d36d38a2ac9a9b6119452211a8133564e2db7e8fe3fef76c251052541f30c1274e78651d040b8e031d3da5c3c67aa03cabe69dcd1c93e56f8cc6913e3a64cb45877bc214a24fd38929a1b1ba221c8cb3504c36fb6e091801f077b176682e15700138c607ecd39a295996bec2845f04b68008d13267a4e60f80765ca92ceb98f9446b6c988cdd7f79d4b0a6f0d1fc19c521287c9b9a78f0f17633553ba5220624fab0fd5d59a3c6f5ff7f313894efd6c6c3e772e8536e05d47c48c6cbed8bc8b2935468dc708cbe7022097c87cab5acd0722786b384e71f65aebc728a641ed82eacbea2f330dbb80248d845570ac84f0b0874805af83153cf9cffee4fd0691def475283c1fd48bcc1fbba2e1ce4be47c9a0fe27308940d3fb58f030dcdfa81e865b5c5574bc9fad0ee1910f721a3d10e822379393615744ad290ed1bc898bdf4dca176109239a6921f7fbb66aad255a609c54e96a4ed21a970d3730fe962f6abeeb41c678dec363068023cf22285ce70fd0349438d80edc5bdadbf5ce2b88bb0cfd0080c31db0a41528b1bdfd2516155dc25a11cc1f97ec858b3802f4499122b3409398899209aa6fe4cffbdb28c3bed82abcec887709d8642b36d55715537604985916b6299665ec641c6dd004edad6ee7584f86e73e2f04fcdb9b03c259d2466f408ed2c263ac3f19082de72ed7471ca64feed3f8ea26a814a9b0cbeafe28eafb5e7f9958fce698260aeedadfd2d2e67412e1c09c372d31966feb720d742c8cb9705c45ebc91cb3710e2a4abe7e094d39c3d36988d20e9cf9250719462f1fb86bf973167827192ec62c15e781b002b5adc9bc6490093891c50b1a96f5e041c54311dfe055f514ca62bb2a0fd3956d3cdbc252e7795e335180dfc9ce93bc40ad9df969776d0ad9d6a6ddcd3f2f7ce38612334bfd6af4a8184951b30330956dfa9e5fd705cfe159716eea407d04d5924b3443bea5ba0c8e877fad437fecf015df456dec94247cd79036f871a7f11e1958c8017247a23da0f2e105f0bab3209ca99179f5f18545418ee3aef0f0c5d2d810a44fdbf2bcb872de4e5dd3a8f8eff5b7c67c3f60656f6cf879186a84078ca8636fd4dbcb377e1c6f37e7bc048552a6abca957cd1d734e8c1d6b8fbf6fb21d0d6bbe1441ded97abf1ba281c13bb18515e2548c6ef6f09069565176c094594bfe9dcaae3f5763e05919f5d17954d2d8a6e76a40a386f73e34d8137134be9794ba4d87a0fa9db29b6b34b057bf563c66ee8f9dd209ba8882b010750cbcd3c2ac9ab28d2dbf44e290ccd06364d32620b4842d1596692dd1ce463e4b2479161bd4482d4e172dd719e113d91423a0eb40e18413a448d12af0e08d854f8d38e783599ebc12f9e028e89a92aeb02c03d2237951f7da6543b04135f41df24cb1eb4d3c27e8b50fde1dc09dc8629778c69d4e59776f33a58e9163699533bc7cfcf7c31e37354c1b0969cf19ad3045b78be4b2ca979e06f46c89e32a797299bce74718352ec71b3c5d2b5d493fb9d9677604ef4ae292236915656d4f5777363f6211a51d59dc7e3ff57a37dba71a3d2ae637c0ab63dffc0629b7e18e380f19c92e28d29c6f3b93d27936ea6016b3eecf155344db2abd50cd8ce073ce5858897600bbad25e4d02cb32036404c9991489f40edec6b92d5069fa389da7f64322b5dbe21d8a5e5eda3e8428ca1e16c29fe95855d2e634384037deb0452b205cb1379715f5a0e7db2a74894b0a4764a52e80690b609bf9348112d09ae2cd0f603d746eb10293ad7dd0f8a8dbbb5a8147c285488599d83bfca46174400775d57134440844b0e96a84b0bb37e27383bc2f264ed0eccbb52cf60f1e0f6cc34e1de1c4ca49f67f3ffb47c9f8ba06df9b7c0167c9549a712dcdfebe5816575623ff020b3a01e0751056f2cef80dda03ffa542eeabbfba7b7b0a4eba530ba02624dacd887aac58c0be06f37088337b62f6636154a73a8f14644fd2dea9e411e5f1621951e163db35f46c4595ad95aba2ef08714e290a36f5e6513b86258a0ae053f121670663dc191fb7f12fe71f9a072c0578bfe166ce28b8817ef1ed610b9ae29e227d4b68c1956094be0afa4dd4cfb9822bd72419d206ee079bfccb3fe927d5a0333bcbe233fcdd80884fc48e09533ba98b1bd9dad5907816069393c5fa2828bfbdfb4be6ed19f62d1357da1e9842524e012f9e5cf1a4e689139f81b9791de2c93b1b9add2ec76f75c437867b74ce333deabcdac6466239aeaeadf3e6ab8e380a8c8398d3fc5fe3f9a2437969d51c26dc7eb0d4d3a7360c08a1c2568182ab4e24c1285892b5de1762d688eec13326216029f64c4b5e65c40d29109e11009770498612bb5e3ee26ffd6eec5551ac6be91cfe033b6769cb23a264b2d8b520325494b7aa8afec905c14ed5633b189d9b131746473d17175fc9cf9aa02189812e0e71470d8f78bb853094b86a8c81c1994947a6c3d868b039bad902cf22c161e664ed58a804c6514d6f95e9959024a7f442b038ac52fc87fb52761c3844a92f8eca4fc445e970e67cd8e30105cc04405a8cb9d9a06aaeb0994e4d80070489cccee7217977fa8dad6be1c531d5da34dae2cc0e62316d5f5b53ff0a9ea06cc0e34faa3ed207e0b90e752e393d9ee7ae4273000b992108b50e65f0e248394ad49500a1c02db56284385dda6871be3f1696289990950410d9ad601352c3d22f40e50cdcab31ec1f6ecd6710749e68fa11bc9b853b563113c0c532df794808853546222c29613ff4a1d90c3af192a97a560b187f5627ef16d8998a08aa5ceb7c4985d433dba79deb343312c34c1da2daaad419198cc0c13970d10199e8440989e054684d48bfede62bd2df7f909e764c47b56a85eccc33067232f2045c74815ce1f8931fe95da624ce10b5fad9791ca337a792047573166be8a82c41ab7f9f572ae60d8cf3e61710d73a24850d6c9e7ec9f32d330aba30a735f55c7da0cf7059dc12f8768a8b2c24a306ca510cc237e9cf80fb7437595c25aa9ac9f0ffa364e5f1e6e07bbb361fee56cb3c2d5740c6ffc5b6a2c056c6fadd03575b63634c89c11dcf2440c40c5b85bf14280789fb5326ae1380b7bbecb97694024559b27ace0d58aef6eefc0154e7532ba23f86e03505a15d959299e5994857c94d961739b25fd3faed5602b8d6a8afc5d66ef25ca8f6e2adff528f89373ec63aa4a86d45a988895e76a27bc7994e3bdb01cd2fb24fc019c6beea3f868c16eeb80c7825f5e6d21d9f878924de0d922d112762c201aef3ee72e8a8412796a568ad29206b26a43ef4f9a39ef9872ea345a9025b27f9bb5ced26aa62a19e19fa97917cc7014a1a5fd2fb9d237fb9c108440cbcf3b9c1d2ca3d99f42092cfe55377627affe22fcaa408816ac156c61e3c6888ad3fdbe68a9ce5d87b899c0fcbafcbdc462bc8f9027836e546d75013adbc2ccb41d599c33f9b2e1a40cf5dab0f8478e50f1623f2ffd2bd78f94ee49a7a1a1e54427599f09121170fc750b72badc74ad086587ebcd1328cfadaf5399ba17da1070d8478d13c95ade093717f713f27ff998ee0cf5efef5d6a805c42d490b55cb715e9645df695ada2679a26ad97c28c8d173ccf6b0811478b8ff7a1b473e2e1d830676b0dd1a2925eca6daaf54a81b1e503d4477f5cc4af55f2941e9e712eb650586feb778274f89b095f76770036863141b7b8621de5b6beff6005900c5ae03cd98c34e8866cb58f65acf88e8dfd4d5efa9b16f3cc0457e49d7e8359226e77f0162bd2a44170a7b94cf124705f2d79436e8b6e95445b4d393341a970162b17806ed6e37af12bb97f1a64a61fe0f8cb9a2a23f81484bef8996ac8eea1ef88bb651b82825ae24b024a2b3670a5ea1388f874181fdf53412c8f53070feb3d2424878617292db09fb3730ec7c480675061bf68583748ba811057c408aa17288a4138e42e32f61148116d8c103689761d461ae3e05d0802b3a2ca287207129c4c11e6c7c015e23046a4f5fab7bf91dabf774e90c5eba185d85e455e91f9deaedd349122a7940da5cd090d211802ae3c1f6cc7f30d342f7daae5583a08dc23257ffedf6e10ad8e70b24a8b932c4d5bc199a65fc3b7d3c145cfcb36c8fcc9b6e2ed1d1e014b3ee897f6efa49dc5cf78f26438b429eb3be34a548434d7f367717de943b38ad171197bc7adff204d4474de482977fd4df6eaf460211290b3ad0b4b5c11791fdbccbc8abaebdb324c684fa11a647e1d2f6ae25aa795ea3ae4e8a4540930c6f7af7a466f6c89b054e1ba0c1871010d4f13214ad05a16abe7d70fb3d23e82494ff97a19b52a552d9e429202e33bc28a06913823f9153ffb39960dc862f1fd4a83aa9725c94642b97cff2548bcee0dfb1d28d7146371acbef7a8182073c2388a108d80216c787e038ee2be56603b23f1549c2d444e1941e035088e7ef8b7a58ddce39e58bf7a66d83582664629ee2fb579024c95651bb2728970ac24c5fbff6b9af8715909a4bb350b0a1a2bd7bd247b170c0d6476117a3db765b14f496880d32b67ee37737559f55dfb64ba7107a096d8e98d6a1eaeb62e0fa376c6d82927ebc7ee964efe66265dab4f35c11e1290993eb1205655986cf44205ab9197118a0671c592bf766eba4833334e3abdf320e11990cb52d248fb09b65904d6d2c7323bb4c8e7a0deb8643b27d1206c0508f8cd94e9cd7d77a7721bcca20475d88156f0f1e5af1b5fa466122c910cc6307e628540bfdeedbb7f1c68b41261aed0e7cfc271f8f36af58c133d256edd695b8a975917d2762cd903b93ea3e87d63ab52d41dfb08cdd18425953b0672a9973da276b991fbd8f7cb34079bc56cb2a36168374692ae923fb8cfa2a377fd1950970acb1008b2af29ea90eaceaeb5bbde5815e61fea1f86ddd2e9a98240b0281b9f1281dae6ba9a00891393e273094332e40bf979085f604e23c7cdf8a0ea7f34bb9c974ce008dcf28568d5902d1fc862937bdb9d4b3a55acb0df7d28589947d0f7050d68b541f211d9d307e1cf7aa84acc5d7a12fd27a649e180e5158b44b2e020bb50cde64d7576657c739c95cbbcb7a8286c27005246741fc7f7f993f0b8be997c2b443005cab86194c4a025e3cd54e4e80bee97957f5119004fc5248e6e08d8bebd140ccd0ecabae511d3d064fb0320848b88ac3fdab9042a67e26e8cc1a6ef526c6c73e2060b02a1880bf6e6a6e5faec55521db2b6b0b7958c6d7d0c4f3c1307aaf806efd6748fd75fdb36154f8295394c574b2a6837a18fb249c2104b6cfcd5f40a00be9c5695f08bab2f63810df9e2df6e58cb22b2165bbf92c1f74f019fca6dc2578c01dc8104a2c412555e14c70446a095ab896d9d8a310982758a4cdda2abba9357390b699bbc5540a960e1b1c479112da0d7135de31cc99e52ad68e3b6742a60498c952d34d3b0a46e410191369107d015331e4a2eaa483f21755c51461d2641d6e16d0fc9d8bb5d53d44a7713e2f059187d12876ed6fb04a90910b9331b29473b9645cdc652d842ccd83f994fecefeb56eab3755af63b5946106baec789983d03e16a1da9252e9727f3e0033bf8494b0b53b92c278947390afef35113b2b441f99451544606d90697b2f88d3f6c382a6f0ebb1e598b920d20eeca50861c7240407f304923e9c271ee5b40511212386c93dee55c1cd55d28d63f106dc41f723d93264308931be350eadf7582c901fb0c9fa7c7d13d29b55f9f81306e6943322c9fdbab95dd1eeea9a1bd173678d0f178a1e0d9b672738a4842a53714d1b3dbd59efac9e73c9ad7c96be98747bdc0b23a606325c27dc4126780fbc1a35b8b4fc1f64107fc5df83207ef907a55b25bb9e2b64f26c3b48e2b63188b5bd2a854fac707b6523b04e5f3ccf038ae753049f5695bd1dde219af177559acf97e98127302caa957e56b46bd12840a0eacea2d761919e74f38c3ab0a885cd858519abf1e91d3b7af4944cac37bac74339c564f471335c9abde8b3f62254e1e08ac1461b8d8c8462378d054720324bc0e16b07e5dbce3d8d7481b5fd6e8fff317ffc2812942b939b44b5fe60b414b64c4ec572fd587d16e80481da7fdcc9fe66857d780c3a1643d3b2b8983b7b0b7453d88c4edb191b3ded0168e36131446dc7781f3d5437416e705931a8bec4985d1d3d39228344e3d1f17317526fc71f4670439bd928cfaffb4f763caa28105e5415fd9ebc9e225d205e9c81fba866d4e7e6b34e4f2eda914242d7ae6580de6561237bce9c97a09309daa66504aa5d85a99ad066c5817f1ecb787c2469283667fa862772d7ca9ab1ef646242dd31ef684d945ed89457a75b929cfa037738681e04114cdebf2feee3a2352ab7f2ebdb9c3bded251cfa2ccd5210851c78bc4b9a1a742d3fef41c00ca511e218c27539365f7716f520c3a7bfe3768efd1e1a04c40e6fe7451a8d5e7a2318861eeee60ef65cc464ad4b378a1591509395ebac6f93a07b785979dd89237a4fde1cf5d9a08ad7d62a6bdfe2239aabdf0ee95f4338de3cb7242722774fc08bac868359c19a82c36b256fe3d886d4e78645b6e632e125076504dcbb847796f7325f69300a9c9e2f1d37f26223071bb0e637fb4c7273df1a73dfa347bef42dcf9603bbaa29d37f099769f727c755bf3dff3fefcf124e27d15b3b7eed112b80c31c8e9c76617d55c03cd1e95fb10ea6c5b6bf5e643fd7c50cd14441b69a989c192d1f268d5d30d636f664b9a75ef70808b34ae2d68038caf618f4f9bc2101b9dc4f787ad9458acf81bd1797fbb56f7ce50c51a40848fc36daa01a3271c2371518aa60d7533ff2c79f0f7b76145d810c5bb2ecb4a7139544deac2bfc2f76d3f2f7eb59038f13c64e1a33448003d635a17de00047e239a43be4cb35c577943d7c95e3c95ee488f33c7e8abc0a393607133fa6a79a9435d840505beef61d8d99a967c56862697ecb2bb400afd7b040e6e7eda8c86c8f7d5b5daa22ff012726ff8a65b8f6e5c314e7d59d6ffe7bc983f4c5edcdd96876a90fb1c470037111ee6abf879945cb0b90a98263d78827651ec922063dbc628b48f0958cdd906e702de64afc581bbddafc43310f4a6d347c88da6208c280d6ab017573113ceb44f44e932e41fec4656de672fe8c836d7aa7ab8145f1a229d8e7b3ae98cd50bff335677fb9f9430f3b2ed3572138c49f77a5694aa6b2470291788021590605e2833cc248c0ad36c105f289099b1f18a03d2810228711d297e2f9b107dcb1d9cb186023bf6794ae6c747d5ef18bec5a012d0c8cd89d5484d02328bea311401756a18698858d7fce0b0fd68eb9f2e0b0847fc0e8297155d5732d0b6a62a28da29abb01671c621c8f1e81ad86203364990aff0b7bbee903d2917ecbc31eaad6b4e02c6660bee642074de7c61dd4a6f4ce3e9b1312cbdff553eb76b29abefe3c80c8760282535750632d5bc91da145bb6f2b36014392faa03e7bbab3e6072174f1b1e47aceb416a5dc4c98e92da2deabafde069b294a34a485669b4de776dcc7e1e7a2feff1034e5a7df7e658d025c7ad4156b5bb466e0b7b2fd85642f206daac0601065b3be06ba616c3299dbbff014d316764e3a878d119ebad9672605944701ec18f2e5e40e2ca83abfe17b10807eb15ab4a92b27fb2ebf900cfab09e8c8778551d0d41ab4e859c08b378b9eb32c0394ce04bd4a10cd6e23418cb2dc7eb0beec08fd61da9f38375c8dce66e0a7f5cfa04e219cacad2e578f1d729492ff5463b2421b682979514bb731a1c634be9b66435e7d12cf56a2c41b33e41ebd7515596d8c3bd52d6950cb88c02cb1abf4a4af85a88d7c3eee22ed28281fd78b92217c8c6c5bc82eae16ccf596a17203471aebbaeb12157fc9ae71c2f8f5c096e507c0194bd52110d80d6fdb70810ab6918d39931077936e9e74d789a84a2e9c8190129e68f62d7f6a58831338ce39fc061a1f294aa86cf6831c9e707200d73c6c55a28d76f9655fe8cde5fc00c87fd7cb0798cffc42d31685d86b3bf44ddb7c9baa6a2d9e157dbbca69a357e68d41a419745f781135432e4ff3b800efabebca3949dbd8f41f6d9a35a46c123c298ff45f8a0ba5e00ec44d0c965fcfffe08fb09d5a436f5229d507cbdc5bf4b79c02f0b5e0c8a908ab85854f56fc17c083514ae9bf30df3b89644ec84db008ad2f740d936ab953052d5fad87227eb6edaa8b72eb7a2daa37efd17a79fdbec7a68b6ca7ec2218a1381d7380e43480044d1cbc78023ee6c43f7792f35a5ed2d21259a6aeac6d328d5f1d535e4f5d824624847358d36decd01ba0b69dffba6799d6779fe4172e292f44c71cf600180d773817e47cacb0094ead9eacaa578073caffd97dbfcd0694c8f4ee6b8f59aad9c76b6af3bde845864be51c833186f10bda2a626e54e72d377ee14ae705b9f91f2e7630365407a0d93b796b97afaa1f696c7733f20d4a6350cefbbc9697b6eaf380599f5206b4f4f828e2b0f5d746ea3bed6f3f22d07ad79862894574c2d4fcf2d02d16b811a15bc4bb7ff7aea20ca47ead8beb5808f105b49bb59ec02c938a0d4ad0ecc8ac3dc5d0656ea3a177157cbb9a1c92addfb9a5004e6c8210dbb6fa19b9de0f03cb15e1a81f713177f33c3e757a5dd8763d1277e6af862a0b8acc2ed356e917d2af1065b83b3a4c07291bcb46c2a8694ed4488910a4c8736176193145792960b5835876fdce71bfdbdf4f0bceb0d75c1a531a437d85c143a587c6f8b2d9f30520d7227f9808fca7504c599f34b3fbfd300f5fb109c5eeca7db5fe9e7e2a38048b07929ed0466a3da87b6faecc809f4caffa814be46182d92f01f4e3e73a71d0b8bc76b71fd726801c4875097171b81dcf1aa14040d3ef31d4ee67995c71c65f1b777d9cd2e7122d6a1c09472f80f58ea6e98aca0b51065651751f115b3977b9c43f79923bda9929af1e815a4e7b61cc4c3eb0d4020cccfce3d14dd7f32c2e16f11ec7ae67d9dee99d96f884ba1a85e8373e2bf86c3c4c2fa95973c91912d6b54952000620bcf2ef921fd8768681e50a75b9ed6ee310f5d2e293097148475dbc175df17d00b417bb9bca3ca2dbd44622144c2cb890fa0e502b272cdbc4f92eae3a7f2a739032e2c095dc00443362b826342a5146f19613c2dc1a24c2d5c3fde3ed690f28e48c224509542b97d0efb99d7cb22c8fdea4efc6f9d84c7efa48d9310d9ec959643e50fc03e246ebb2a630f148d2f70fc738bb40ba27bdb02dba2b2ad921b405521417ead3e66536cb51e3c7b985ce971c1c73dea9e044897a4dbabfd6763fee07a33ec10e144b0d03b457f06cf774c505432f93ea9c8679b19183fd05728d781e35c2da5ad412d936ae4750711d6ad7376c02394834ef6ee52745879d932d90ddedc536b85d576285357faba217dd67e2956f78a2942f697cb97d84553ab3c4d0217cee2035561279ff2b53e91b7030afcb2cc8e7bbb58408820c1cf2e7ab538197493933956a10a5145aeee377b632c63cee15b36a075928675d2887733996fce5fa2cfdcc01ed9dafbbc6f76ec7bdd3745770de19e9966f8ccff9a1e95d09649717b03ddb34a03cffadf386cd0f93392ff17eb7ad20d0f12a8ab1007ef692f4c0c8192a3d051423b0646e03d4f30a6774646481a13aabc4ac1472f77a09c88e1c5212143782db0fbb3b44bb8f80c005f1ec4602f0f397ef86db4fa60ba3ae204f7ffc1dc1b0f44ed7ded8c4859bf4a66ce7068250d255a75003366da0ce9db720b9089d8a5e78bcbf14aa258bd0e5a9dd967f9cab8b061a28eeb735f44f6b26d8ccd3ff6c51661921242f909cccbe9c59b4d7008aeff08b2bcbfb1e4d1d95fb67247734e053af825f367389675d769f46fac6f5d9013b651cdb076de55437784234c64d9014ee235ca033de3fb0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
