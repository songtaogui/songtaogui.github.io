<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94f4d651427ecad1c00ceae52245ea6e39726b2af976b57be7b4cf2e95747df47c87e9cafdb25ec93f26095ec15786df89ddf67d724a4eca709181f63142bed941ae97b83e78eba3f0a801bfdce401d9f0eadf10bd9657c4d5b80a641a70abd5961378a5b31fc1a2d3e0c9379ae448ff276e3063c8fbac0c303ea6913cc0686e00b3ff4d8b43b39eb505158653e3defeb3136b0d54e84c46c8824d8caa214fec5bcf4b15e50e852f322c3eae306d1b2640f7dcc56fdc5ff72cd7f2a09b22e84db5a31207ef9ecfc4b211747113fca47a10c2062bb3fd1fcfd6ca849aa183196d536fed7f026e6164de7179b2492261636303d28fde57d67e6097182361b72ee8084ea10f3a82e4b7441656b29463165c6fba7e3a3feec895bf2b70ec2929d371527542440c837c65a00583560f4570290d30b0587e09a3f0e63bb6a42f5f521d61ac0091012d9b89f9a97287afaf02bad0a0268d9536686bfcade1c246c17fdcd32769d8ad8819ce23f2726f7bad5024242ea2e740b0f54447e3422c235f6379fa783e3f239cda0e3aa7dced8291dcf475e5aa92ec3ebf4d880ec200551c2cab28fa9bad1f1d33e357fef24802c7f8e49092e8f825e4bfdeca76df6a3f520510169fe7d8be9684e93e8af367c6c29a1b43f5e7d900d516e57430ebced9b3410b7f319e3ad2cca2d90e67cee414edf0456755a1ae9f02a062a059eead00ef307467483cf1a7141d97fe42dce57e8c8aaa443f57033f9a9857851f10b71daca4fb6dc8d0e78c3a2794931c0a24dce3569bcda2907405a82647c0fe4d940f3c774ac797069f51fba9cc62a98c4e3d9b1e52b00c840d02291ce65aa037968f332fd0a3e946372744abeb425ea177d1271c5ab2960120d0ef1353f35b11a0ea46b93e35a34ede80e5926e99c95894dea8c6c9b6317c6df3bde0a3ea0bb23886f3de00f09e838b8a3814ccdee5b0d42857ae996c2e78fb377a1d23db846a753881fa8596653e8f25db424e31e3ab832659f58d718aafe37309ec85f6bfd290732002b90b2a8f5b18310de19aa34a268893a97a08c49633c5f2ac4ed79038e14408148314e94afa93065c2abe774ff01a8537aae6cb4a5ff60780fef719b7beb9c6ee17194aa910b6cb8afe9c70b1ce908447e8b96958f12bb8a4f4afbbe21d96e7167c4ea1bb142a30e6b5cd9e4462300adfc8c5b29398c94126ea88600b367d7db208fe941574a594945dbf19548c28568fa949139a8409185de12bcc999bfef2c6386207391dc027c71ad30027dd09bbf4024ff395f432647a9c51af910ba3208462d84c91fe28645bb78a9426a22312f6d0729a0ac96ff8100c7bd21b8397d822d50f723b1ccda6eeb8f9d6cde66184f46f612e7a880a3d57ab354475736f0fd0859e61cc7de17879cac6a1d37115a5f8a5d137c47ed4175346c8f0b7524ec3b7b264e0b2dc744be60e15817c89167e626f5a36a089042b61193f0ec32bbcda20a1c7fca2f5a98ba59a1d2617d5a81b37b9f7302c434bd6a48c988b8bedc0f6543f76fda73fb2de46c104a6bdd434ca4071c86f62560b72ec13ccd168bb30973668116166dceb498aaa7068c764ee4658af401c0ab80435a68b07e92a73b015e6fc039c9b5ff192f07b67f50e0385a5d6fac097e604ff0ff433a2edff74cf8113fd7f23ca121dee12294c1ccf1b5dbf8cf436d27a9726f514a93b919dc9aaf19e2502387384f7da7f1f3b5ff0e38342b8ccf65d029925d517825d4bdcebfd42f99189b4900fe38a9346706988bc267d7070d83a35424c47df6db43ee9edcef0b0222f8297fd5c5485d21aeba72af04c8b06c33173b540e9ce04767c9c4ea7a1af90707b16235a0ef3e83d95f7bea9593eef1e3247d5e0af864977525f005dc348380ff89d7fc20da9d8679785538c9fa6512f7115f97138fb885ba833ef7ebd43e7b12a70c8cfec333ffca7fcf6f39ed17f432463f7b114eb60aff3b8e3fd541518cf7a3cf6a8bab8ae52da3f4209e9d07cffa2f0ef0dff44d3f74b31a19f0ea5909fd07430df6ef99ea8f304f317b2eb5d6bb36d839aa7e35ed81a55abb774d492a3abc538fc303e348c9fb6606f82c81f903b00f8e7a010d6460400ef5cc891b834745a621468da744c1ee832f40a550b37be4eaf045ec7ebd0fcaa795a2c55cd42bc680f7c94d693a418f5d8562b1e8a8c6e084f78faca236751c1ffc2dc9085787f34dfabff601b93ec95876dddf84cdb0fd0e66803de6cfb83ff914f268d69cd6db96d32420e26c8408aae80edf92b26d42e2f5800020ff7305b2656e5d23072bdcc513ade6748895b0dfe8b25ad8a57837030c40c79cdfa78491a1dacbac65ddbe1e1bf89c3ee72e72b5878316052a71e24cceae7f7361d46ef4c8bd8982c9826bb86a92581273dfed618d4d70d400e46d504be21fbc14aa82dcb1cd626ed8b29533ee4478542db5665ce652c9b74e9780d6c3a64af4c17f3d672306ac4d3cf9fc110732bf1d4c2c64ca4b896677f2ec2e64ac42cf47cd0a59ff8ae374dfc0827843a0506148c0876a55f5c12afa182b35c2589f32f36772585ce3651fe0918531051e0c51edab8dfe1bb951c246862f68fd678066e431560c697356d5b5ee1c3ea614e1a6109f64deeea0a57277650b6b14c08be45783046ecb210b9f62f841f8b701089360307e6f76646e76e97309d9652a9ad0bcf57ab6ac72ff0d38a0b3a1ba1357fd237cde87255a73f51c422f9409aca147c0e2bd20d30264d993857cc185fa5a39affae9aee6df5b029dff98c4f8888f5428cc1273ae74349cd1dbe31087720981654c4666585c0fd0977133b22b9a62a5b2b079c040f8ad46d9dc16b9d9b7d3ed4e7ac518e560a6c0632a768515f0d4725a51c65fedbe74528bc4324080030ec2b8a65c0116517195f66a6ce109ce7e3543bf5ac228e8ef29c09263ef8016b8f224dc47ea6f5d44df16bf405cfbde35c587e8a390233a5a962fe59ec59cf5f9665c72f4cbd7eeac64afa31ae38109202170dd3b2b73791d7ce5d77ed06d3734a5fe888ac75a0a217ee300242b9e5d31f9ec14e887e57d3654a4159ae0d1dd478ba4c0abb0fafc7b25f6f9aaece27600c8287384ab84c3fa14a049faf0c26b7e98116ded9fa16477f9391c6ce7606e7eb198d727aa70fe0560c6bf5a10e1ab9ac204a307b4763312b6ba59321e0ee0bee31b1e5dc72269ff3b64ebb38fc8645d901bce6c54e8ee5307432a1e9eb5c43f0c2050b7b49812646a9993dd274f1a385dfb5f0d47596d192fe192f171c41222916c0f0fd2403fd612983b1125c0c9d9c2703179f2c574d3f900949276d1e479165070de0ae901ebe60c1721eaeae723dab71eab23d9a230dd37957fac367c0b8a948f696cf6423d42b89848cc54853e46b1da458a41bc8494a46876e29a27d4b42f35f8f9ca680cbfb75b199a55e2ec59db7d119e2c558191dd24def19294d61d139016110e4f2fba5132cfe6220a31c129d66d14fceea2d0dd768da61a7748c4b7eb8934fd13a1a84fd080bb309f58484bf0d1511edabf08a12657ae2f2ae39dedbc761d49af9154ff172761d39b397030259eaaeecb7443ada376217ff844f33523020c4fc1bb894bff67062c87f0abcc1179ec53a78d0306efc81e2698f0c7a25cdb875d872d8290e36cd0f46fa29069bf477a2ae31c276a8843bcfb940dfdd2d18b917602da7d056577ed14fa1e9db0d4d816c62c45801333f743e35ecaa3d851165975640d4b3cc5bce47321f20e9a0f351cf76eece11f1462261b00a41c9dc8244928cf45e908e1c9aa643a44d3f00af5983b5fab8eb235f313d5e2c671a6de9d531a8ec0b1a53496af57e7781a8f681af37f840f973c45fa8645a8cedb62f79270de7b32270f46dd86dd08a495b6a817e2a274fc5c4fa231468a01b5b9993c22b5c71c33fa77ca414bb39520b6808ca9f1705607072f1581a0dfe5a234fce2823d3f7eadf7e2d481216820f001689e49dd69aaa49d9b1d22110f2351c0a22ef19f2ab4d1001192839aeedb8243a464839ae7c46e7bdd6dfe7937223e572eab814e93bda70250c2bbd473cf6507658d76a1051b8f182cfc5680e4f21171d2863f47bbb7a19d504e9eef77b0fcbf89deb093f941b8425a0ae58493f5efc0985e98b29018256772d35054b40436da2d97d12fac675bc82e9a774d3a3fa5244735b71f4538d1aabb0b0f9b6696caa8ccbbde66aaea196e428c27e8cf96af6f5b703c976282c029133e8d9e4aa39ecaa0b00d1fa25b5409a2889381939764431d74f8d40686990fb1b972abc233ce8cce56b93955eb35f8b062e6472d0ea15642a671f0eb33cb2d48716408457fb81c34cbfd7da63d8f0b02e6c35f82a89e80d8f89187dd79fa2766e23725c0d8f2e1626094b189dddb0000913072ac54f1d8be7ab2fe6e236bad11afa3c7311aede92be5584ab7f10af684b8e9f1a3a76d6dfa2fdce6b08f289a5f7127a51c4761eaad93718a8dff65a4f2e6500e80130baabc87157d8fe7d4a4f8e3ac9af866a3cecdf3b9dfd9b4f39f248bb4beaefac38666c3c2dfbed8d1ccd1806b47a6facfc9b8ff282932ad65ed8f5b6b39b8b38504b92ca6fcab873d6f1c4d5a338acefd8a44a650bd8c78092fe2911f690e03524e96f4dc233844b9d736ba56c6658b8f3168d0f4e875e5a0342682fc60204fbe093df46040b99a0c4a527c7830201d627b2d3b09ddc0794257a3a910d7aa08e7c8bc1ffd1c5cad90ba12b3ad5ec1467c55a6df325ea6edac43a97cc1e8a81cdb8fca0f6ececc6afe6583baeff0b2b708f6e612058ddf4835eded95efce173a525ccb98792cc85f516821619cd373b2f0731258e25d8a937080e21d8ca6377e14077129441671dfca3975dd1f3888edc3702deb1e99a7cec8a726c7c6da5725f0030e9f7e4e74e503a019462ec0d4e63fb6651470c36f15631f2226daab89910b6c207a13c91346ee219312514b03bc5f4c23cd3dadd96153127ac62bf90bd47b91fc25a32f59c451582f7dff751ec010aab13fa622bb77fa0ef2a5c3c6f702c2b8cb12c970895e782b7e0747d8a8220b5b05733edb626e5d53a431114cdf7cddca7d7885d74c84751acfc009e6daeba16ad2b72a757c1e6c1920f8720b5e6e6bdf8440fb63f5ddf1cf0bcac0c0b6f1b8424f96afe4b070b360e0efa355f0cfa0454ddad401a82513d77d4830b6503fb2369a03a78b77b258fc3c12b40860e57da347f3b13127bb73a91cb8da524a801ed4f3da782d3717dd305b46b8a96596066f989a30befcd406fee1771900271de8218d83e35728f59691b52614fd72f1735e77d96c65690d75e26bd016621f896809f9755382e4a48935cf2a98fe89da85aa41de9c8b42e8aad64bb26dc6caa21b40c2edb0ed55c18b10c926c721e04af8803c339b5baf292f03f0c94ec6dfca0db750b99db11b2eedc564d3d0c1bc35f5adba6a75c971d35fcceeec308beab43f33ed1a8d13de4a61d55e1e0ee38f902b018e9c4d1a11d508a0379ecd36dfa7dae573a67a361c1abfce21f1c1ffd877a5ba7e50b201510e5a3fefa16616019c8d0b9660415691ea175b7b085c3836b093ed29c254ccb0a7e7b239c47519198e2260f621fff5fe739debecaf7c662066880ed02866ee87080402fb3dec5d2a571d32ee213dc302874fba2375bb12546df099da2d110c5d03e8c9114f7913283aae1ceccc0cbf20eec0839e5d4caf2bee719317ccfe22927a9a5d84cce821f632829354b778baf900eda3ab7fa11a555a6d2fae894d38f7f994aceed34f6f0283debdf4daac6fa263d0ad97e29b7acf55f3aeafecb8ff7cc45d938c5332926b14c297a041fbc2a25b2c112703abb18b7824e62160f74e7f0917e1843d038a0981d03b6ce128563f8028d5ec82f6c6262a8872ea7cb0bd63ff5cdb5b893842e2fd58fa31417146eb650899fe16ee1359c523ba0b2acbb0b512ab2f5a05b262e4dbcf2bd98fb59be6407eba61719440461250c85d3cb6841f81d6736565bdfc583eb54a7230b44c18415a9c6e4e47c92ae367304d1043af2d9ee0c2d40f5cc0179b98ce9a4a4c1b725d8771a5d92f43bd1527cabb3f9344bde75d624183f30315ac194dc7679ca16c29857845cab8289677695e19c74af1de39155f2216cd90c2e0869d4eabf1336051aa1f6c1da98d779ec41d979e2968f46e52727cb8bef88b12783407e562169433fcb480629246f244f7dfb4953ad5b0e7b2ec703d72d30ed9a1d1f00074b14489d865977faf3ccbd8828ec418596600ec21776c05003140b4c6e0e6d1b03898ed0e21ac517db2de96a6abc6626618518d6128461491bc838eec56cc5cc5dee8a6b4462ed132abe98902ebefcf91c6b16a371651d178c1bef4dda8fcabd4217123d80bd6203ce758196f3b35919bd8b4190d4ba114b63ab8f21619f828519687d4ebb24283688ecaf50ba373d852811bbd0eb5570df0f4edcbbc5e8e44a5fa4243b657b1b013b8064a40e5dfebda80f1490a4ca1a364e0b184385ddfc14332a5c10d212e75569d1572a0713287c8b8dccb2da3d48b3d11b8ababa2680de2b1b3bee576f3622d306446ac033344eac9223c9c882dec5bcbb7806dab811465c1c78b68553fd6404ec58ab4f05a0df969d05839fd0521fbde690132447919b6b1db9fab4642a41932a31380faffa8d61a3d8122aeccc320ab1e38c639032fb8e847b6fc78ec8e4f92db0b554efae31bdfa46f18c3b8cbc5c2c61b1a5c5525973fefee8e23da4c2765428ad425f35d1b996e27a307b31768309c56f35fe740185d78421ae5d1995af8f05dad9229aa7690c9b2c1062e0ee7ebac0dbe39f8abb2be7017736698936b3375eeea13bd6a97e7b3f4bf4cb5fdea780265b908e05bdbf5489a60d83ed7cc2ee88c6f85df503a3769f991afeccd91d6565997a4732612e6ac4f493e202e43648c07e40bdf024a7140437c55893a893eb2cdde14ab29a0847280f1977a1d5c27e28a6f927431a5b42d237ebeab1c32338452205f66bb8fda05bc5a7c2afe1030f8e83d35fa88ff00db949e7743d29f6a0d788368e5c50c5b51b52f5d58466a0959a277cf7bc02719717fa122fe5276f6a311e4147abbe31040c89b7676772c10b48d57fa8829b4cc634efe51927a28a8c18efd01e6f2b7e6d33c5f8eda2bbc949db9f98c98f7150996020831b5f97680aae431f091c97b4a6ba2cb83e4baa9ec0eaceb013f627cb36c3f8e1a355f3715a38f3fbd0d5d676bb788d6871cbb5ced3c77a0c4fababb340de9ccc92882aec25e4b8735692d8e36d14b7dac8953c18c325f4ab5b90120eb4736c16ab832450fe9f6d9d83870431cedd87fdd67cbcde58579590d0d8ad70f915e644a53eb2d6b127695052f5df7bf7c183e98fc1f7995d8d8aeb6f663dc5b1b9a599a8a12a2c72f56fbb26d084fb556e828c755510d5fdcdc260fa42cd56641e80d2ed037070c5ee3f9694159d598654d0fa49cd791c8cff4ce057d9312609813876cdef69fc220580ed7abcae3254405bb525ac21d7bddb00c6204b60281f92234ab4828b286cd8d4a00c34ac0be830faa9150bce8b9fbc7e88ad35c8ece7becac7f4b799e9b43cb0d469347555f933eb3cd2463609cef2307a99454bf357cd5e06541848703357b078f4be5c9cf5e0148ff8d43e1d4ca80252413b19856946a5153aebba4fd0104cc969368fa8f060e983157531a7d1c7e7ee5691dc0433c82043a95d7fabc163b04ec7abe426f24b96c1ad115169d652c3306ab231954540270301ccca216dbd750e4987eca99b0e0513b2a916c4fb37d775153f303de5c7bbb586af297676ccf6904fb28e6e8f27083b50d22fed7605338c0c3d7b5e2d8e19d7e79165b565b7d142fb755dfb55bda48843179ce7ef5b38a33850b8e9824b5268b188261fa81f17f89b69d435b47b6e5c83ac49630847406efbdc0add9497c56e2a555e4d1ba4975d583bd4a32f424dadb2e598222b3a427d973747217782af735322b3ed77305fb3aa14b20d447823fc3b2b9e7b8823a716c3b623a1545eb08920b794439078c214eb4ac95707e1c16359ed1152364682ba945c93ee48dd45c90963bd7fa74bd898cbe004620d6d32fa57b613f6ae8222c9f73ec5dd2cafa3eeb977142ec8cf5a5464a370f1d34437c448778275dc0714aece0c6564cc40b3f826e489e80d016409229b4296b33c62828286369fabc4e23d8bd4bfcfa4b76b510293085fc9f2a61384ff379fb09cdb78a79fde7c9306580e2a213dbb0c00fdde1ad7b5f9d21f4b7f0e310ab8d4cf4600283aa71783c727b658b8b7e1bb5fdcdbf44ac44d6803b0bafd1ff6413f269ee6c36d9610c24de6c68558f48ff29ff7559c2488a8012bfa247481c3651ef40f0a405acc05b2883b5042d8772065862b96b3a42d3a63e6bd2760ccf7c85365cc1b3e8192dd6e3ab1633359ef56d25f46fb2457a0c02e45508afb8d07bac21eef4d55183ccd2eeef289e44b3b029850e8f5e5da6cf96d073dfced3222b0aac75680a81038e6f6463ac0cc394ea126b3002d66cd8373ad2f2f99165e6205a5a4aca90eef35b9dc0d697a3af6fe22c21eabcf34d323ce0620271dd0f4c7027955b48a81a3daf8931ff583cd7d4e04a92685468cfb74dc87a40a833911134acacaa372df389e217c819907cd0cef34938b54f2795fae42740b905f58ebad803ea480872cef47abe04bd8000cb9c617e192537b3548b8201d9c0cfe5dba612b2cf77f4b1bb2e741537d5dbc4e094479bf1c49a581b32eaa0c57d16de8409c9cb66cd59fabe90f330c0f66fa96449e57f422c0006d41814b4049a6211ef2bd5c8c4e51566b87f625f5e6f2167188faea7262dfa59086fb4554cb0a1dcbd7c6d4a910bd86f827c78fdb35329e5235bdadefb7e26a3b4c34bb83ae94807e1264ec92f35decb30bd88b61b61c55398e0db8f52e78e544a49dd47039445f1ccd27c96d91c512175cf580d4fc9a951f38486302a37768a3830879971ff6e2bc5681d1aee3c312802e89df29f057d90963c1cdbf46db4eefa46f716ab9fe593412b25a64cfd7fa3e55e09ee31c1d3a0646be3fd36381841e255aad34ad62ef8832047bd5122f122cd5b616c81536ca0d296f298eed8960fd23b0b363bee55cfa42eab10de65e8ae38fc0f1a1bf6875a6a4b12692f5a4ca4dba39f6e16b5c48c3f0e182eb309842dd9152e8a8c4a953423469d28c0551a1fca2838a208ec971417d548a5befe97fa75750c1f251855cc243b127b40d332661b01d04ba1a9d1e0370b07bc5966a9d568d9fdc515d23dfe8c9a63f62365fdbc0cda215f289dea7817f191bac53fd7cc296de3cb4f6199ac20783ce1315b95f683e677a364e8b9317334e7ca24a60828933c46ae172dc6fc036a16119354e5a5a9451329b904d98ee870f1b4aaa549e5626476d82e3b176e3f18e58780ee0f8cb187a34c623ab92c5defc1dc664600c77b89e21a129997a26f79227c818bf03d608915039e3c6cd2574dc5fd2de58692118b9fc0969f3099bb43b41b3819c059b6c3276ae0dacda94980b4aec292f638083fac349bddf0106d0c555d86844d1d2ba641da79cd89a18ac6c0570c5fd365f228187a5fb722602ed8f7184cef395f6cab747328158e65cd3cce7506ac66ffdae47c93559d5767ad7e9a39a02f72c0301d3eceb2070522f9da8ab064d4f77d22cff30f9dbb93e4c12ce9fcf60cedf4064782bacb7212ad1ec99dcf24bf594981c86373a60c91c65c6f45c853e83783397da7cb02955cbba60d707d46a814275fb2bf5216bddf847ff6c56bf3d402eb700b69c128b547872eb72e0c81053e7e8e8957caa1be3f698d80b8340d1d4926b67a734b4d2638b71fb0e4f329167a15b49157b05d510916cae7c59215f408b8ad43ea37d9af91b3697dff7537f6d21c652748492d6b10e88fa03ad44f138c36246a6ad1a45746457c155b2e65692e8d4c5a8e95f7b2fe02f95e4cc7d17535989986dc3cd7cfa85cd3a8097c71f1f3a0b53a0571d451524951f957eb5ff6694390f4ff8733c1d800d64bb30be7771ca47af7075d5ad8bf06c6d37a08c320d0113d9131e23b48f172fabc638715eb0fbebb07625cee0b3ff8b167e980411802346c76c8c32b8acd071929fd1c6f0949fd5f8f6c254581bb53d57de1499b0e88c166f7b6c5e9637cb350b6da32845fecda79fe824b80bd327bc48ce4e20039423870cdc609bf23ac5143d4ab0f6ef228376c9a583ffb2d1becb2fceda69f1cf1cda0100315778e598fc4bca6079ce23dda2f8e321a3c9fedbe700de9935c5fa9dec3eb93a0c161632db69fda6f4f0a855267f6a7e4183a4c2c1736f1dc991c228603b7b0ff4e0ef5b807f8b415e660d0318c32d5ef96ed0f092a55e0ed4397d164e0c562adb15793a361b8ac84a1f914b845e0f704b8c0395039eb166caea847cd1d41ca731b36a645d680cbba63ce6b87e836e26fd156ce78ddd51ee7bb1ccc124acea15ab5992e95d9ad1cc0aa67a02fe64a9c1a88a9ff49fb34f422ddca053b77b822380d54b98c6ba5a8139df9d71b92f64f5ac6dec84aa90d42442640eb91d415975b903c01b31170f1c659b7411259f1f1653713c1447d1cd6e1a483e83b3cadee18f23e0be43de8d1448a91fb0aa5513839686b51896189fdc5300589aa29687a9356c552af68d8220076cfd6ed614a3b98598b49a224b58578b98c74d57e13b53e1ef05ac89b6af04479d028bf4e6aaea15d56fc5dfc948435250136fdfa86c2cab8866aef1c7a14c038d0331067172632d88c67ecadf1f299fbe0d489371088ef0858dd6617fff954d18da2c7d6f14c592fbd44f3fbc5b943f4c22306cee6409318096f2d98318047fc8cccda2f0f89396c39c453d4b93b595b0d0ccc7ba00b2bd96fdcaedf31fac87e19030935941ac0aac3cdc68274ebbe014e6d16c7bbd9d5096214f2c7e27ae86ca6804e6b9faa17070f7dc8892d119dfdfd3213260dbef1d7bdc44fb2f20b75dc513b406b1222c9993632ccf45c4da75b5b89d1e09c7cf8c9374cc43260a551318e1d77b601c489148022a1d25da94a4ae4bbcc6de957d853e41513051ddebde8be5d8a5ae0d0b343f1af91c255085c61dc9cbed023dfa12c5615778211e2cbb15b4ad67020ca234b0567e9354bd9ebcb641fc02372830d8e428cd370e3c26c956c8521f51d77fd91e8cdba44a54070188bf295f64aae367c770a68e78a9b9481478f16957715fdea90aef7b5227c37610d6a1e10542d6691b68a49e417558baecaf45688d54c752504d5519922569655f88b57490953f4cd38b00923b5b1fb6fc31cfc2ce9485f852793637e911f198cc809913509371498a28dc0a12a3adc4f17beb3e9d8769cc008b44d73ead644da22098d53b962a1c0947969d6c95e6370a369b0d7ea7bb9e9b594cea8a831b96c3de8c516f87681560ca3585d2cd908264a5732e4be6e4fe5582e021dc208184ffeffe8586c6431dab2b8a09928f2a1941af2d684a951b301b6dea06e13e5cc8fbf3b7f7ccefd15cfee662c2d366226f9f5867756d5c79ade780d17f88b95c5e1fd0ff9f9995ac7c63b9e4fadcf32ee070ad0b5c19cc5bec035f99c30ac6ed8c936c80bef1935c71946c04876faba26d2c21769ee0363a521b3802e075d7d53f6b0745180c0fceb7e465a6e1ca6e6ab719df349fa7026be42c26f2702269d6073f82e0873aedfef9ba9795418f6a01065fbdb1e53e9c2a37fc1564f1ae5ac09ee52f842635e51b228b01bb5751429618b2556f4561977ae49d623e689becacf5399b71d19b5a94e7e055d527515c6be3e000177ae150d34dc90a76be17d0657a95bdf195133165a27d580a90748982200b351cc3da436b0f98df951fb204e221921e5d63070676d354f1b88d85c2b23a2d6d690998714d107e1030c636dd3f2d055f6304cafcc8c1efa4b56cd94ec1945215d6aa27303de8737ad8140af1a7b5d36c7725160a74d4f20df263b4a5db2c9ecc012044924793c524355f9a7e37e3e0b63d8efecc9a034ae5cd2e6fb471ad51a5ae38a42a46fda0ec98f6e5946af588afd3654a6fdb8d7db971ceb6a65ff0d78d31c4855d581f59153ffe98e81eb84f5707749b3c0405fc15df09072ed438d754c66074af59f6e2eb3ecf149c57ce7cf2cbc8743043fe54d7cbb8f6cabf7b141e93addc29f7c6a3f57396c4818dbf70eac7e97e793fe31a797be142b581282b59be2fa3644b0a44c31b1e378f2ab2cfaeb36c929f2df8cbbb64ce2ea2cbd72a427f46732ba0db31face303d49f334e7c5b0e74df75ca6f187d3248891d3a5326c4ba6604f5bd0e9d43a2fffb27860b3c9b7cac002bf74fccb96d363be4096cbe3f261e875e032f1c7f5c206d1a9823bb549e6fe3fa6db3c75b4c915d51d82e3a7417a3e9d0a3a17c5c81c40f00b9a11ecceaf8dc7901b11e236379bc404b239cd160099b58ad6d8c5d78810e169d6a02579d4a90ebe2dcd22f2e6d6a024b129472e29fadd91c85963d0b9199e00ba9ca9a3ef16637e77f7fd8cc3f50c6d5203da9189333a9406430135c9a5cb0de0cdcd666300047a90f600748789fa19b5793cab38fac96d9000290f1b36939cb667467bee0a839445c68311f25c43bd912386e8ddf166ad1d3f72e4f9122a7b10f6ee0101654d3d8041e011aaf931a147eb969cc1046460cf145fc6902e809ffcaea1e545c73324612e42ebb71f9e5859c82436a7705da2e19d657bac20f7356a87ab53e50d77b8123c62b12d3153d022d50501a7b658eaf4917afac11d31e1d6d0b220496874599fbf90b0fa158ad84c5f3ccd48bc692f2666f7d12c21fddf18dbe6ef62d97e704b2e276fb23d17c793e3a8014456e79a6748b96d53a288e09663c38acef301b53c1ae599bcf6f86b50f004bb1a75355e133c8436d4a0bd68ead9d16ded3344fc4b30b5dd37e57bf54a6dc7ecaf572d7a650338e123746462e4a0ae0e5506770c1a6cc26bc76c1777ca470515850aa4918d8970b78b86729020288e83ad955f46b5e834015867ce818aed4d9a67d64767544288c9ac105e5b17faad2f5d5ed2e07b98c9a879ee13b0314f4eafe804bb266a3e39396775fb5e51c4d86f35477eea2c4c7302ca680e53518825eb9b7e4091d1e651a22a7bf043786e969a8c2907d4ae83b556764575dccdba3133229c8e5d004e022804a31e9ab9a7661498f9d74462b99f952521af7536e3a9551c316c4644fcfe183696973370ac3bdffd4150be9d3b74c6fba19e938e1476114320052f1888c6719b9755cb4b5d33af9c7ce5e60e39f11a50a7fa691c51336018f9aec8a08e17112bfc2140240e52af286e9abee69035e82f817551135e4229c574ae54046f833499ff3ac3834bb3e0bb90c84568bce018c4f402c150536a962e27bed0d619f096ae6b2a45ee73a50623ebd73d67bca25872f5328d65ebbdba04f8f2cf442602b32c7b6b2a213456c921432fe4721fb9b216236962063d17513afbbb1c649337716b2fc449e454bb240d368bac6639be72813d435c30180391694cb4ff7ef5099afb17164dffedb83484a86e6a87b39fd458db608bd04e576b9efdb6532c9fe191604562dd2547e3bd26113b2417352e38c6eb09a684829daeb3269a248053fb7645199cb99ed6f12a2c2776f0624377d1449572e76217f90149e16ac1b61900d7ac6159be3aa2f062cc0bcdc7c739979a9f853e591cc8291b961e0b78f349d7ac62b14233e8420024730d9815e9c52fbc3cbf750a5828b5756dc7dcfda36e93e6510d44c54a5faaccffe212adc589ee0f0a0f5f3bad129c56f6407d6f432a9e333c8de7afb207338dd659ec36537fbc502a382c6aa14a02fa1b249df4fc80c53057e840632638a93eeb04b09f8d540bb46039c37340a9545b7056cafdb974ed3ce5cf354f758a29b401f7595ccec9532cfe224417ea2d54121ff714af79f8a518eb1192fc40dbee5810825582dfa3ebb233b8570ecdd9abfd41a8e6f65367bb32389ecf770642b6733950e24f2f1729aa06e7cb90d796001dc544985633d28c1e4503804dc83aedcf4379ff47a6370eaeb52a7faae8f68769bb389f29eca731ea4cdcc67347ac0799e313e4cbd720feeacd74b20a2c37640e8f7ff43978cf7cbc75289b096097395ef393a84f97a8c4ac46d74e5b25f52bbc93f3d099cae1abc974f95dda9a13e9806b4b27cef11416b1b2a96756fe4f9fd0bd6f4108a0e57dacbc267e46f62796bf48707046ec5ecd82c8814b378bf6d753c615b3d5100d6fa59e18edb48f468f811a69368acddc7d192e825d64fcf2fb392980389d308b27bc997c7fd735e8a1862a26fb8ce2a82083715dc4384a7bea33b98d3408858ced05c7148a4df5db11ec244b45ee56b7569a5f8aff8827b289fdd6118347083b260c3185f06c0f5ef838b0a20995c9e4e4604aa241c4d3317879e308019d9a42f583d5db8b6e67fe481f312ab947ff92053a83170d3b7e96b48139b39c7829c67a34a5707a3c1085cbe951da8d42358199e6e3576a542a2ed2a2fad79c555e21c49c6fe30ad4aa668fb117bf5d059006832822cfb4478c953232d6adfd9b0fb66bf183a9be4221cad2e568ff12ef3ed4a787cd3827395c2b8bd418638e9b84ee1143c5d7e7178a52f8a58b65acf53e4f05f58b2dcfdca5b851b33bdd6106c79131ea00b252c9d1ea85c0878c1150b0bfe02acc9c054d5110a7d9b4ecae063abe801fc0fed0cc7fd2daaa811cc633b5adf9ca4721b9d9a10455233ae9b6f46b7db5eb67e520c9e55350a3f33e62bad1baf20ba4044e4eb1b1fde8e5583f323a8cf703f825c1580a4728d05fe203fcc7e708b69dedc7a883206b7e5462ea127f1ab5c5d75af0af8e22d8ba6553c44c7b382b074f5d85a9c02244d0c83fedcdca01797275f1574a347c34015018b83c7d5d21a8c928219717cfb200ebc88991f3679697b299ea312ac22fd185959e2bb36d22ea53db2e5d3d9ddd157172537bff18841e7c45e6238b2c1a574507e07805af804b97f3870a4ab03e6624bb459461bdd93c7803b2d98e68cca5926898acf37afe9c4f91d9baf206d3946c1ff27f62be9176bedb9c48057c9f0ab9e0c82014c3153a8e679f91c4d5f4b2c6a6e8588962fa0fb247653fe93c4c235b65b4a272745755be6f58e9f2b5f4cdf7feace43ec7a5d1592b23aec9032c7bd4ae25934f1bf34dc8cf6567c2e257411d7121149776bc09aa30846bb05b670eeaf3f9d5a6080b43578ee32ca7126ed3572e2b6b7c58cd85a05fa38fd87928c2e3cad06764aed3d83c1c17324eac5c34b60cc9dd3e5d6a6e0808aaa7d9758cea9b476dc63751c5dce81a938bd4c7f598f3e211afa18cf997aa3f0342283bbb8fc59979c315383d9a091f479bb7ccab285e71c133b8f88277549236b2f92053f48997ae70e304ddd25239380425b419f518b2d90d1ceb022fb4403473a2b4df6a8593323f45ed2693b06e0885b096ffe8b107ee42ca518e8d51d725a9d3c990f57b5c249cc27b1ab0db91f1c189381e63180266dc062970e67d71036b22cda419e22968ba967a18083a3b16d03e0b69070cdeb71d8b4453d39a88a7afef75cc60523059528a957cf332ff2dfe514963c71a9b2d3ac6ed5b143716754732a1566b26eca680646c5246f1caea68100d57c160d0a7f5827e1b5478a38c5479ea59ac92f0a7cebab6e206e5db44f9b9fb4d4701ad53bdc680f0d84e2ee877aa24c03af540bcca615b566edfc36b281456b170eaa8be34b6f816254d59005ab50fb11b834b0945c22f0a32ae62e576b7fd2fa659019f636749e718834d1ab302d95082ca6591ff32480f73cab3ef5c182cf67b9333ed0976c780bcd261f7acb48c58eea1db725e1177214e5745937a0741750f886753deec45d51dfe845f45fcf4013587acdab57d60d81632544ff844257c20e3b16b376956720eccf175ca6d512e47b93b2c5658dbbf07afc2432f571d53691b68fae0af716211a3c6126870f04055e70b53a8671d914b45c7c55412ae150abf4289729d539a65a4489298af0cbef44f78462111cafa2b68134e7656e8e6f5a764e416da1d277e5f0f8cca5f6c93b9d162830bcfb24e92110e3e3123747a41c539d5cbb78a8d1233e7f7535d8b77c64d7ed5fee7b8f6cf4768db45499f8e0244e0ec4b83c02589595950bd0dec03c700a95894fd1fc6325bf929392e0caa47934fdae8f72c875eafe785c73a270c407ede3a3016d716569b5b4c09cc5e9a01cfa0f9a675d6cc9f2a1f5ec40ce4a9df1e040a91e7952be9847ed34b574d37e41050a23238aea5fafd1895ef8299008e92cfffcd44c7e6c770189354d83e1bbb048fcc3d51c7cf0de1b9d594142758362c0c25fa2486ef4aec0aedd6e677a922cb9b12f06e3c47111d44e14777892248eb54fadab82c219ef1679ed78d84b3fa65c712c2d2dee22c20f2beef36cfa79f3bbc80605e1807658d63c7e3f770ec2226cc1c2eae71a43e3f63ceace86e11443ddf348eac9a19eb12ddd2a9783f6aa8451900dbd661e142b947f14ba53087ba14a9abd581e253e2fbd07ba595b5aa5d069e69e430bbe0ad8690668d158933237cca3bf06f5687ded8c188e4b8d77fb5172df761423eeef31d364f4a616d37d8438aef7591d6d76b547504141f05980ead492c9b30f44013204c1f976d6520d234a5e2a608c77da844a47ef12c046d97625d9fdb1adbe804050afcd4e58810f2f6a07d4b5c4805b572ece0ce247802af313c765750149e3ab9c29357b099f2ca8885564f0cb7d401030162b22d8ed8497904b0937887721696c546913fbe6a5a73331135e6976f3aff1c1d0873585812286267443432ffb3762cdb914f1e181fc08bd861a19739e3fb94e9165f578cabfd5c440873c5c1338bcc9e8e28c0f19094c6a5b1166cd35f12cb65a0e239a5b4d909d4b55d25dda2a8d8b9c8ef8bc6db44c024c51624332f7d02f7bc1a080d7b32c91048bc8e739aef6feb9789e49bfb8f2416a231054cec35f4ea3f8377166dc49e3b61ba01f24878d0d344a8778e657d9bc5661aa4a0cecd5232aecd77b84d7f8097d7674e9003972c3b2368260fb745f2b3695635d040bbd622ab7b5e6faac2a15859f8c106d67cceddda130a7adbccf03b74637cc2fd5ce9f16eeee91f12a5ec0eac3941795830fd8e026cc6de47a885376ade0d4c6fb9e0e4e69a40c78cb6fd1ff2947d5e57c0c6f200a6a3926876b78509cb6fb433b0347c92b1369f74c7bbc0e238271b043e56c574e3cfa68f98eb999cbd48a6fb39faf170840ecfb71033b8de3cc1d4cfa60cebf8139cdbb0ab4452bfa7265c6829f1888aabe309e89c4713bd9623773b51d9514d319559d816f87a4e6d556a276242241805135c9decfa36e8aa013e5997846d0975006e8a304286566b74b90e59e504fbb90a1ddbdea75d247db6065873ff236af60159e182de8c6f194b8d2101b4a3282008471503169b2a12e4a43300e41c4ba28dfe68f46d27c5e1042c78f12540800370035662e49c616518aea0f7a73ce8a202b3606febd277681f876814b0317fa9fa6b9dd67c8d4890d8f5e26ab08758c99750c13a1383af7610f2e3c33db14be07a6e871cd24771c63f5282dca34eded8132b71a3078362ec3c6dbb13c8e26e2e7e076ba5295b65569a55d380758b9fd47698f6063f117fe78d3a7a33a44ed3745494d937996d5b99c37734ddbfb5523020a4a6e668f76f38fb68e22bf1863819f85a7a7ec905409a9b9612c0490fe713201738027f36689d302ed0fa688571a8db0ababb96990ede3f7a1f117ce7fc35c733bb3c08b07e810dffe7287ab0fac7891370f5b54df2eefb9a737ddf20033063c71a3714004d39afdaddaf8eec0b7013d5ddd059651f8aad0ca5a6cd7dfcf9708dc8e8b07723328ea80bf176d078b72b1cb5f2c9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
