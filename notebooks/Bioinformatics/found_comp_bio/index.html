<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"afeae6eeaa5affe4fc86b9b51b94e3a67e6eb01f12a2b424dbc7df5bdbdbada957fcf27fea24fc73e3274581cb5a1df37f27c935e250248dcdcc0413e6bbc507cb440d93370849e74b605bf38c632104eabe0a4295c0937cb443e0aab46d346b5e6a19ccdbd452a5e6e639cae4232ecf5d3590067ea7592be4f89dd916e23b25316b26145b24f27eefc018af0e586ef2dce2ec7143540bbd57015073d332f447eada6a84fb42e7f16f75b1b9c093a5f1185c2bdd28fe3f26c2fc3b9dc3bbffccf65c0dc4e9a678e06db27fea70fa366d62ab130e1003633334015ad3d4504dd8b35d6fe1699a0b482bbb6a05bc1d9f9835eb328853fae93a10b67c5b8eaf401669ad44432720803c5a9b387b8357fb8502b84418c56696a2cd6008eb0968c11093b50ce0e6399e08cc9f27687bf05111acfd5940ecf1c974d3c81af4e03df4788ad87ee75e0ef76ef091be1abce72645db46571555bc7be1a399f3f1d17b0e6f4f30f8ff415d8d5b709c78d0344dafd0b4fa035105f5579bc2998a3c1ded94bc30d62e7cf8201824ef6fd1c9f3d0ad0857cab45ec04b2db78d03abb00daf96287990ab18339d92daad2b72403b7bfed3d1238d4f2eb79991a3e722859ac2d7820e20e194dcea8b4e0117f18a77a4877ad4460fa5b573c187822af2dae193b00c81cb29273b868f048add310f5218264cba3d3f782bd1d4ff7ac37867825a5465a349816c2cb90d3e3925d10fc77ea0d33166d315924577e162e9c2c444d5045533185f8f9c56d33e93481d67922dfb7d519200fd28a2900bcbdbc741b54775c41eb6c19f08865fc15d2848a03e4d09662e073209511b103fdd8dc3cfdb34553bd5e27c8a49ae29736fe42ccad078788565da2985099df638cfedcf9b0c7e7aba673ddcb055f99e8b1d45bd81cdd6c25eed8e4c50d0c647de56638100bb05da5781d9a57c28a020e55a1501d0141c24699b1adcf716e63dec8a0a6d7e2b28d0f1ab0da20d720fb608d778f12ac1e0ea0519c3bb36de9e15b7eacc4e15226370805e83240bd00400a0c4fe23646c2045a7ad46b7d9678af5c542a359bacee14548f15768248b5a141897cfae1529b523c9bb018fc82e64fc8202eb7b1fb5e71536748a1c11d6bce7dba16866ddd637689c26a69bcca9bd03317239a58789de0c2f84c1cba7fb3654dbf8f0f57c8322bfb601e85a1ef740bb90b203dc8fb1207bfd8126ac14638fc63d6277de05513d24bc7acbe6419715f4f93c981badeb20e5647e714bad9b191e5a09d43ce5f941d939708cbe016493cf4e84352a2d29755d7213f39033cc74d0736eb8b843fdb1fbcc6b0a8f700f02c26f404a924ce23bdf285805eb7ea1fad559e68b8f921ab404b49098fb0b1f7db263f2f11a308770531da2d5439d36c9f56d235711803331846c2cb2edfebe8c04b2b35cca59a03909426a21fd10e6300eb2fb6c91003380a49a72e8e4908f3a1cff11d00b0af4250de27e35ec5533ff5c2e2911e1a6b3593cd63780f874ab4a3801a090c3c5412c0dabed6f0dde5e4fde39171548adb0f654a5a24a99954b8b50229886f3712218498c58561c59fdcb442eeccd3f99ef0cabef3e5e7a795ff1c087b263b4aec9c77a5c5438e9d05dd83189024dc4e508f54785240a08c86da7a93d2efdd464c7780cca3f37ce41007c4a761b09d0e8c4cad52eae5b5509370634fa88fdeead4d91f5d664a08a8ee4eb1045bf60534737a4f278286ed2487e36e7f34998920105fda7167d8aa44b10eb4ec649c79568336094ec70cf578cc0afadc2cc5928016f7c7e9da44c4020ba9d8867ea68e0c677fe988bd49bcd7e2760c956e1238a979cbe0897d7bca600342fea2551cc3e8f0061d86b1f01ff95a07de2de9f28b827ca4c4087401c7f540279a449f1dd04e724dc0e3fa8b5de03a4c128122b05ae5f342f3fa61403c45f07d512b906ded1dda5443e3f6e828a750d5183d921ac50c59788a60981c9db290f9baa94affb1318e8a441c08145ceda3974ec827736143258b0ca6857241d0ac9636e01652c0ff14cfb1b7755534946151d49b26b53b79603318e037784011d8e2842aa5a112e1f4b87a2f7218c705edcaee0bf5b95ade99a2ea47f227ab46e2349f7b6184587b7af23816661191a613748457538a5ebeac93df4289db8868234b5cdc27b64c0523d48bf951fa2505e2e711cc345c86fe08327a678824a9212d18693770ed719e3f3ab0b30b2d5440fef37cb29555592d21ade4514d3295070466629bf8e378cb01e46e7be5347d6897ce94f954b6f4de2aaf0e401f847266b88890da3fffa18b78a7d27a57adb087acf9dd436809dec8888a2f7487c0a2349e22c0f88c85dbb13e56d8de74c140f1550e89f78fd6a1491faebc50d7d945f6722d64bc96f06727c66bc9f39b6888fd62a1b759225f9069de183083942a25602ea944ac3492f26032488c441c19ed1cb6da7cad5480b63dc95fe75b8d5a26e9383dec5437cdf7423659169d231f9c128e7efe6174b45d72744d884336eca028d833d0c01d3082d09466f9b5227909c32c0796dd5987dbbdd6dea600bb055f42e13e499bf10214dbb8a54e700f8f701a2749d864030a4b7e72a6cfc9eefe184aad8687ca8ec76ff531d2ee4690052f54d9bc3a162e306fdf8e83ef5a3437db91b662b8bb5c8e6e679344a6776ffcbbee715b1fe0851da19111d0c332525acc67e46f0a992b13ff242433e3b285b08bb73c96348dcac102f67bbc5309fc4951497b3584ce7c01208b71785e23cea6889603bceca33cffbf831107fb24cbb095d4a5e03ac291a6b6585dc20001b44319d56d302c8fd7109a4e6e91dc474222090e6560aef1974e641ac2e84508af20c25f7474696ea07ae6eaa7bb1c41d4db06311b5700c063e0eb35b1b33378fc99d34b419c83e22823b9c57e70f7454bb6c918ac1d4c548818104b21bbdf41e9715adfb453f7cd666cab3e353450501089e94eced0f46fb68d2d3aaefccdc893e0b15e7b1c62348733e94d09f41b25b3bd9183d51b11598ce401d4e648b9e39482684fc2fc20ed6ba9bf3cb1327f7e69ab69ff002db410899fd78092da30065420f9832c4b82b3c9129bb62d617490610488e6b955b5344319f13dd085d503b9342103fbdb2183dac241fbf6827ed0b6fc815b3cc5716960313c8ee4829e8b7a989989d35e2e311672f48aa611cc2bda567f7395b822ab46a7cccb3f0c87589775aaf9fcd1400fbdb8a66d925213cf9b7e1eb7b5cf7c2e92a47257152b844649d47ff9e89c6cae087395d2880de96b0544cd3b917526ac196a99f69dc6288ea5bee7d9f37fe85442bcef1ac7ca849531e34a5ec63472accd69a90197b56f563afac02852ebf09c9a2ab983bc223de04da6e1f1fcdbb0f0d1d9fb95d1bdc1377f5df239a3a8e4ba4a406fcf6954922f07a3a7613e5e7891f80c6c8a906a6216ac818fe26b481fcdd687c28cd9e24eaa57c5e2b4551f9eeedc87189be5c303b166913f956a6bfe8cb119aa674e9a435963706dd1196d1d3d27a418c814832f798b45dec07714976aba3cd84722bff7f49b8076fedea588a94faa5849002b15b8717508f44bdb40c817d806fb1c51c168b55d99bc83ac463be35a653bcc1a31a4a6c8b95f62fb4a47c0154fd3a590894aef50340aff785c82f754332e6b219c0308845f737b845bf1b997c473ccdf4694e9c26802d93e9c843c28a7241b39dcca435028a42da0b22bc9e48521e26e463d1f5ce78ab4d8eee866e800eb15e929f09f3ae5cd064c6c0adcb01839c24ba86ea6905bccf561103e107177c30cd2bff3e0e48430913c436363457d8c3792b7e74f5a3d02f6e45660eed4a40b3887f7c9a619f7cd92c95bfd64136d26f841abbe129a81f6a9694eece57b58efb57731a731a177d3a2cac654578fd9975d4fd902a9be09d8ebd0932b25866a73b4c573fbef961456ece6f5a4e0cc22a200fefe2113886d44a00f27a866ddbfb25104f5819dbaf07ca5434f1a9b58ff97a7a3a0c0af12096002bb100c853a1adf8a09aeb95a83027f2d5e2cba91d798803ab5515ed5e34012e2f19c06a9df35be8f2983a8d48cfa476fb5ee4d756d07919e7a349f48e196fb69cf5198c300dba3dd6986447c1edd24cf819ba26ae49c64d9c7f434e110d2f57f360ace46ba7044f4d5d68c5ffc6804417f27c88edd1afe63e8dc70f20b37d72ca766ab8f33d91533ed841526305db6431b5006b3d43c7bfc66070cbe71568e6be286e3e96db9d76ac77c5ca25ba9f7740e7ce1472543214fa3f8dbb374bfc00ceb0bb7f214e869b92a235c2dfc95996848c5c9440dfdfb0f926946c849b53f536fb3ea667a0b2d61ace24a04c3dc0cd142f75264afa97fb1b994f413bcfaf865005b9b2b621861fb3919144b61d7e8462d81bd05cd9a6e0c01634aecd9f156e1e7401a5f86e5fae234d38066852c494f1e65af5f030a612a4537946c4b03e62dccb430ccac2c1c1a2335b28c647d246f6c05f5fb0c756d66318b727a9a4ecc01b712755d39d5180b1c966e053c81e6465f3601cd72d122a49f0964504a5540b616550ea6e0ef766ba1e753a7b3f15d7c70c682acc5040de84f14ccfa92e3c03a73a693a5bc28da557325aba081b9467be2a0f1d1170094811f8188f39c9f6750b5aa1e880618d4dc53a2a2e7d861f651aa4ab01d02e8ac0094038675dab74940e55837e30e781eb674d41f8f50cda166bccd4b09951ef41fcf5e9ebe3e25eba0a4808f010e1b9a6a14573dd3620c7c6fe80837fc581160c27e743aa1f4fd5e40631d0656f00ea7f3e1f2a61bbba3bcfa52eb74f0bd1a40ab7bc7f7a64dc33bb8b89d239265196b7878c270abadc29e98af5bc8adc7391905eb37a0f770f61b3fdc2cbc9ad842fd730b5966b4214310f734b559d01555ae363746cadd135c0b006ae15cb9aed64949eaf3ccec54ff5506ae8596816d1cc166994ae18fe27b6ccbf341472627c5296139c461ed0451f654d69c8e8ba0453f123d457b83940f855f2affc1eecb9f19f0cdc59b636c34add0918b57d8dfe03e3ab974d9b4f513b07e6b08530caa35fec48e4d377e44896b546a3dcccce09b4c6ef094b2819358c208bfdd35654eb8003bfc162439940e28afcf9658931838c9c1c381ae8d6e78b8cd29aa875fad60c6b49f3f839c7812e2b528dfa7794a6ee0bac458dea5de3cc1a5c462493e03d650fdcdfe874b4ef7955c8307e59903b496beeb01e783d61b59d0da317ee0a6fc66b16afc6c53ea05f59c76fd835fd32870071b939732fe79098f2a685a451fdcaed3226d985dcb1ac102a00ca54e6f03c0911d07cb187b7b38ec7fd6de01c05c148d96e2fe2f69f8e98e338dc4373d8ed165349d7ddaeae55c6b5d79216286747194d55bc93cf09c98fe65dbcda2e3ccfa410cb73d917f319161f01a484f670a80a84a32967bb280bd9a036336a2d8f05a65b6c3c5b4212f469ef5615442c134ed4b8da5e99d85f500ccbcb1413e3fe17b73b3f907481ff8fe9559b998f91f3351044ee55dd86046d02eda19e534907e25dbf10387118f3e23fbe7cd4c9c01c85db1b33f37dc6859cb215bae34a708a381fc825500c98092375ff17b37dee5925ba6cd7321f406224b753602ba779521d81380d467364eeed9e467e2acbf2de7a48ad298f7444bcb4a457133047fd88d57408fca5de3b7700e7f1b50e3b470677861257094c668c8d8bce9b0f6e16d0d9544467e1eea68de9a47714bd3b574666035494063838f88ba7d2ebd4efc3abcb0e357a863f12f2f24a6be8f67766803c27bb0925aed0b09764c76767b90eefbe65b3c4caa05ea94e249940b1e008e6e34ec92c08684ec48312af704428268fc8fb78c91641d3dc87b06cdee5a44e72a491ac175f6f750646edf66a13c296ebb85c46b7addb2d0bb9de3a55c31f152c7bc3d7b87bd89a04d9ef8de56cf8b11951b46db850c06561228d739a48ae9daba7b3391600db0252d948b3eecd671cbff24646fd92c6232006eddf3f92449326e874eefaf378771bb2651d51c15808c845c2d6acef56a7f748e1c47ca83f50a7c78fa101c72a4333b6e2864ffe4978eeab683495c6654113744146f09bcaf20f0da442c9ad22117e80da93abde6b92bc2e891a539ea34556e9796fdc394dc732bf67e68b03c481ddbb7e14a76c6d77bb8d59b4494bb17b41c6cb18aa3939528f630e2befcd3879ae2eb44e58ca82661ded1ee7c083b5872ef24576a09f1b439f649f05543bcbf9ffdcb75706fc4c55677e4ad0d71e9d6d359878d6581895b3a747b0ec8fef12fd4ac71779daa93199952b6be9e0099bf13c7184aa35edfcf8b76ffd11cfcde27054dcf972652e2d393d2b27037a7c98a84c9756496150b069c82db46f347dee5fae6a3eb0ad176fa59341799fd368777fe2b9542d8ff907b74d7f55405f20fdb36d6952b0b3dc9b639488a63d320ee7dc7f520bfc0e09ba253539f7f9b01e0b507b819800aa1266affbe31bad9f32cd525f530e8c22eceb1384fca034ae3bc216ada7712215c1318a6a02e329d2be5cfe3eb930b20c01de16b95337ee0d0c027a6778637f50b26d91ae13824d17bc6b52e8b060b88731fc03c0cddf73639569e420a0d73c62141af2169f639d7cdd86b94b0208fdd2238f9ec0d44c057dd90b0f25ff77c954e7856508afc93ada888f567540ba636c0c620708357b7cd9a1b5065049888357ec36f41cb7638e19b18f1b6747410bd6c1d3bcf7db4398633a3748f5f3c352039340f94ee7f8f3f0d17aba1dbd56ef7993eed6be9a8d9e9b7f0b9f3dd45bdb2c95bd1ad7f409dd3967434f43bdbd1bc14afcd86db30e8b64870efa04c531110e514a76d72873756f654ffeadf37329ccc2e941133abffdd55e01ec95058e79bc31762afe74bb31594a3bd20c0b137370cf62bd27dcb81cea05e1ca18614ed81cc3f8d4a57288d8bccbc6db1314a41b8e2217cc6facd678d51e4e7de90a9cf7fc309735c65f98bc3531753b4642cf4808ef7ae32b62f5dedd2c67c6c8c1cd06e6bd6b09c2ee950c84a799b4aec9724c983fe78625d1ef21f35f672d63300cff9aa2f5e538cf498608e7634b74f97d77ef12deb27fae764981231b8e702be778126a7be3760d58dfde8bfb89e92b716e6c98897dd88cb1445abd25a44408d08780880fb1912450fcb2f208b6d31f2c836805e1e6681dd762ca9923aa465d5647a725ef7ab9865b5fd984cd75a70f3c3bb815b4c0c015b6ec7f128811b0f859f74c6fb500c986aa6c6c2783690930f8d299b463c57ce09343919e97c895f1ff271af12773615501523331754a604f419bacb3ccc33a6b0fe18e679b7f12c7f426358f1aec26d03c957c0103d21a5bd5a2b6732672e8bfe45f9c3d6bdd89ffe4c125ae97bf9f8159b59cdc23d2f107b3269a60b026c47d16538aed3b7467ab230ec90aa2735581e54145e9c8ac9f772fd7e2adbbecc8ee88b47f2759eacdc7a0538490da7d2519f92193206242e07ab9cb0af9c8e74cad3d4876b31996c7e314c6d2c79bee8b2160755466c0c913aa64689a5308689cc79acfda2fe576ffde638626666dadf16e4ee4bc16918a6380c8c79d8b0c6d615dcd0d38f5d7ee9443cf63749defe5dc09b55f291962e3a85f3fb0cf3f27a1a8f8250999bb17109c247445b35e9e83aed39fe711b1f802b2a6a44d438d5f55d6f758a017ca30f5aa80956d90c92e4adff48878bfc702b4b8886ea3bc9d384252743edb4db6de7877cb526da1f7c755178d4bb68fe586b5ce95dd999b4f69d1626fad16a7c661f269f605bbbf05cef5ac31be54873b5827afc7150ff83c497bfede6ede3f45af3693c17bb6fe635b2c12fa740671f27b40fbb14ee6d352188dc71b0149c78e6df74dda29d93088e09dfdeea2cc8c4044d59b797cbab9b1f199856bee7588f221f54d0a3ef3a6c8d6e650c8616f5324aa47b45c9a1c2620f1d4f201bff4b2f4a1fa26a1eada8584f02939489e3b919586eb8efb8d95bb470a780d5069f7b14300404352f8a56a936b87db4fb4bc8cfa02b86201055db4c9502e937f5ed8b1b8e1ece22dcf1f9d9d3665211e5b358a095701f6b55e899dff3a21183f0efb86c015c5d4cd0844b60df3550659dbf36d9458d326de619ec1c09f10566caed53c16b04eb143239536ee108b99a2ab425e3ed25bc55a5a4997cabe116f0fafd60ba8efe13912962ab7c99ebc39c9ceded4c8212583cb48b05c0b4aba1a9f15840112cbfa2431aa6b98a4a1d2aacd35e37e0c12a97a200857072980b4036e39cfc6e7ed45c056530379e636507c709438304e75df5a9c1d2676b1ed9d425ae3c11391c66814263db3b8d78ad473d4328a275e2a4585d2112d287612765bb16d0e75dc8dd7dc920412e091367551638f9d4c4a09c5f167784ca845b1511a939b9c9c18ae135fca6aa54af052f4752dafe9fbc3160eb3c97aabb390355aabcb72c11288023de342bfe3d60ad721e20f8463325ac1b5920fb09cb0ec2e3f33e98244d8c4360eac3db4425d43b75992cb70efc2e9e06155cc4e814c49124b47b151eab9538cc6b4f3f9601622391c3f3bad757ae550e7b59848812db6cc601e5b377c6d3ba3829b2a588e738afb9a235e6f7f52e37f88da61e856576519ec030ffbc8497eb5ee59eb6c92533637b56c0f7910990e261028c1964e20bcd6e1db0cada641e7f09270bf34545700fed8297b8ac5d521993caa6932d27f3da6e9e6b436451a948255f62b52855e78005a7dab49cf709b92023963237d4e38ddbecf8831a2bf34ae069469521c43d4ccdd02fcd1d6d24273c547066b0bedb8a9b18788a97343d9675d9428775733b72e0179b45821939cc435bcaaec1b87a64d7ea85b4b3b069a45d583b942fc1abb7e4f5906da8cf4034cd6e70c82fc4c89b21c878934a8c7df93eebc67d352952480f2423e664f8517cd96ab8949b3b43e46a8b48009ef26caa433c3ac4c987f42d737d2245f4f671ab9c952f551dd5d0fc3694202d7a65d3d2c8983a502801063cdcb8721ce31d9ec61e9d3a9844b3a3431ee142073bd49b738e551dc57c876969bb4b77c2d2cff19b8381359d456579851811b13a0583f69d02c7ae45d50622d90cbe71b6f6fa77f68b2b429677af1a310bef62640a5b8b7e4b0bbd7be5c335b62e2a095b0dbb1d38050391a397c8202bd92b06771f39ff5446899f78d4d25ba69ec2a02fd2561de7115b10c6ee7f2705849b2a0a76e59aef5f128166a37b5b75234677a5e21bd09a227fd75550d909ed7d5b7e997e334bbf39e197a7d2fd13291cab64bbfa6a72f5cf714b473f71fb9e11f76b1606a959201d7a1d65db9e9562907b6aa86d08994ea1165dc0b095f8b0e2712769f61a6c0157727e425c0ef22cafddaef2ba0f612ffce1b1dbf3395df544645a5becbe82208a98eb2f0f9c85a5a4a7d25bcf0448d39b0b75b7d0c0781503cef9899e5fc0c1897d8b1f6158641fe90b6243e46fb5f7015c35bff80d4f1f6ff6b38fad840c26b276116fd27f5a79c23380e22e9cfd6b4652349f693dfc19881bcd63e0e57b7508cbeb569a971899af571f6ebbbc6038b7e32c8e7f73ef727393245eb6f44cf4c3f39e0c5443aabb4a843f6aa77c87836560b0dfe0e26c551026d4747c12604ec8c12e502a87942cfb5e33c5ab7472837e18a134ade75e9b55dab9f7696ec1446543ce99fdce43159bba0350752613c9586b7717fc5d401756fa409da58442bb2d6694f4ea84bf34c3e2c3efa7340b392b06cdb9b719faabc815d761acc6419b24eff0cfddfa3d6c0583c969f5e6fa6b01a5240cd7af3a3e1fa5dff1a7be36330c0d2e1dc1f7d411d4de5d52fdcf37030d40a91c6ddae0fe44dff1cfa921f94270948e0118425716716216c94195f8ce4eff02332adad257c8c6508e662696573e54e2d71d13a8b08d2c1c73a143c8921c6713e0cec0d619b073c2c3684b3b1df3a2cc8c6e6bed6554ac9356f094fd14294e331971e4b84251405baf311b0fbedb8749637a662a70f81837ebd0cbb614573e7ac272210cf9de1e83cb927e7179485b168fd6ce811f93f262470c716042798d67235aff9baf4b6133a854c4df52b785674a0e8fc9e4acaaac6940f479f747473fbd49971a98d5d2e5d629bc6add17b91004d04dff1a99755c2e9e89269233c43d4ae71c983d01eb6cdd45e613725311bdd499009fc7e99bd2ae0f418df7755e8ce15714e8c8e41f43fade8705101740678ea15f18b98fddea470099e50918eac25a442bf81ba31be788fb080c4f4c399630eb131888f18feb3bbf37b69393367232f963d02ec0161b72405b3f2d26edcee92f992e5b5cc60f6f0b97fc1a0c352d6638ab83236c42a702506eedebaf8b9c5019b8e5b46cb07b4c04d10292b55b5463e87078b2e87aa2b4b52d23e3d6d633f43878eaae1a1e8eeadf42de9ce99115826a1bcb4ef746f0f563323a011e1e0adc9b57ce086f2f56180bc9bcbc5d37a5d1615b5001e5b0a0aba72f584d563aa781f8669ff66e105e7606e4453ab7666681c8670ef449ff71c1b330c190d0509fc05a7f51ee00ee9fb8b6aefffad6acf744d8c0fd146e0e5d808ba099d90f539ee6805d231af821d3512d7aa8e469b5174a432414a2211cacf68edddab37b92fc67237401a1214886002ce43c14330f0ead693edeea15e8c24e4f96fb1164a857ce129994bd35e922b0562336d686d1133e06014a27004c306dea114a3e21e95b57c9b2d9a16e8b4f43527128d219c8a1e0cc3d0d721da5265081086943e39a7d5d4fc3336605c5165a84f5736050cb4811f9c38a7794772d72c6e162f843691057a5f875175b434dd9ff1e285b411e756fddcb1791289abd5bf23c5c0bf9fbc0094b68e35cc2eebb368eccd4f8c5301ea0ef9d5c61b929b71c8435e0678d53fb3a0766e3e9042516f1126ceb64399c897a11666c29ed811b2d88486231a45574210a4eb3f19138373beca87078322495a8d3088128888638dbc2df6ef7fb184131bf0f09331352e912aa3efa09d1f51c25ad3a60d01740d43560d85cb296aac7c12d9385479c9c67680c173860074ca235546cdc953f1839400b2b3f78835d4f003db92fd4a3222abca3187f6149843401bab6d392dbb1f3f3ab028cdaed0b598bba7a4ebecdbf475fe79a84c00d98d02f0afe471148869f6968f66a59310842cddda01c5200f048f5af45279f926bf23db54a4868d10064066f89a5480406accff9736924960909d76cd1fc303303bd976498e3e3abf49cc6398ec4da69c1c5d343f24ee8fa406a49b2b4d0e0d2d8de4ed56b351ec9ad6a60d40155b275ec3d68e5c716721b8c56abf915579de830104ce251b3d271e67c654d77928c389a598e161316df6bc26740b770b99e7ce3e9bfd797ea6df1ff6649e75412b3287fd28b191e33192291a4176c83b19bb04a2003ae3b4fa29340f2575ff9df32cf45538478c2275af87f97003a5781b6794f94a1e0ae59698126fee638bc13e90b915ea3749219633a0dfdcf3745cda6ebb627334364e124db79db0d2e4bd33d8f5109d4d54215700db7da0437bb522e19826916f954eb5e5b175e974fa7bb9aed51bd6e2694c7a11b2625bfe8318c6554fde5f7d6f8420ebe44a7bfd00b4fda13405be36140ffd088f1ce10423ad03b1cb29966e465540e5acb7772dac059e807fb1357060a8a08b0fe323429310e6f1548a7a206f63f7c56264ab3602c3c69308dad5f5ec9fadc38a528d60f22ebd028fd5abeee25aeee4a27cf45c6b84bb59911985d029ebe20952eaf62852b830ea32d1bb7dc7913e894bdf5015b93eed6fba9aa8ad1e161d25157fbf98bd9f6d52c86dbbe9dc6f97b6cf6634834c1ed49b560886681aa8f9f2918711782c7fcb40c3659a3a523917974fe8145001214d3e4fbeb1a00bcf9d1e21aed2f601620880e12d2fb73eff8ab4c732369d0979897a972fa8a0db72081d4cf1bfc537059fd605768d924099ab8fbe351a3c1429b72659a29a0c58d1b6d8e0b8bad729f89b79e21608017ea97a997d87a9743892e6da5331c7e7692207421ee1d1cae929c77dac09d97b16227874c46451897612cde075e2d9d1f4a51d2cc38046564911a802d99ac0cc10fafe7c7d57898953ed33411c03508fe79b568f91047f21457030a4695a878fc9b0ebf189fc3751799e15e9535c00df3b2cfa51755d46c40a6365a2d707cd09b6afe7c52bc390cc604a7ec451076a75e921b1563fc5752e0e7a37831a5560f455234701385662dd1a3110dfe18076ab3ecaf0d1ddbb83e7540846811453a6d46667c02ff5799b4c854dc74e131a75fe4462e2ac8f04a35a25f2314c071f22a1a075fb783a3e7aa7b000d03f73cf51f374697bdf547e101529a194afb4264d1f4018c9038d2c0a3c26d50b2d5b82b3c9421cca02c654d89dbe2b233103c58ea4db373d9ef51e543807f9e093a202fcabf75e107892fa688d1a078a2a6cb6488663e585077dde11ce916d6bbc51efa328df27182963fa2f68fbc4e8387a94916aeef89741fbd11a86381ea7ea48b8b2ac086844f8a47645cabb0dd6d49880965bf7749188ecec4b5b9e5447ba475934bb420726c591790332322e897044b56ac601c71f9fd53173c849e54ec7a210c21c0004802bdf1366f2d216d8448cb8269336fdb39fb72c3b1d9239539c2a608d4c7adb59312f81f45a334571527ffca315ac811ac2bd23c2ab2dcb009b7fafe99a312533bbe642d77a5e04a2648d544a308adc3756cbdc07e654787a9b01b910fa8d13769b1bee9d0441fc254e31fd816ec64f28aaaa040c7d926bac5adee9d8b836bbdd5d4c83707df736cf4f6f2bcda0a0d1215c856b6a6aab875685114b9460b90d8a7798cb638234b544a7c9658ebcb1568e837c397c1940bb4e1e9bc7095d32ef11a6b0acfc3d1957fbf205593b50c5f07737b151b56fd82fb0b4785a272ad70e033366938196895b938e6ca7570c43a1d6555ddccaeeaf63415e15794a884571f204710302b938f2c80880ce0a5d35a5d34bc031c9a70cbbb47edb47e5dbf4740239e767d70471462bf7daa9d7f6340bd2478746db6b2ea2b76a34c93bdf9a3bc6b05e36d941122660c130ec1dbf3b6ccd7177aeec8aabc44f160b97201991bd4d957e80c7bd851bc9328ea0b93e3deee4be122a9921118b9491273264975776aaa2638466fbe3348cdb37562688b661e7e0710f96400eb88662f166efb8f8b9767129ed659dab391a513e767dc0afea67def4814f9280edee69e9a08cd0087166b397b66e705cb6bb8d9a267354f2f203b7811a3e1faa245cc79af82f3a0b0cf894697c8f945d99198eadb6b8d493770cdd33bd3507eca9f443f5175a3fd8c8d764a205e4a8ab776486006ab07aa68beaa1e0ef22805de93acf15acc7b5f3cab36a0b9dc0e127dac28233ecad7a0278631536c6e84b2175355b7ef84da84c4f09395d78d1d2d8cb5ca06053844917b07bf5f0e15b3540abc1716a568594323715ebd2948dacada374b53ca256f886399253bc1b431e4531d78846c8ff5bd27df2660f3471beb301ad062f7cf4da6781630e06d4a53c6b95f54ca45e7651006e84cc4c58cdd1ee53535996e704b393d7a1ca111cb5fb221a7ebf427f4b43be8ef23f40299cc2e954f928a7b41ee4850d0c1a56d42a916c3f07917604c881e936ff843af2ae94c741cb88c0aaf585717f6e4913dafe7dc3b357242b9ee2c7baa41cfe7fbeee211b8e4d5637560bb569db0984aa28806a4624bfc672bcd911e3cbe163d8d5d43d14367515c592178e75fc785c18792052129ff4545affb8cc191eb47848d9551f78eceff429cfc39c2924eccfc92250df76feb60ad0d9d8db77c4dd84d6be6a13efe90e4b1d37ecb243897600dcd66b1b5eac4309e37e13d8f121f0a0dff62d59bcf6ddc934c921fd29e804a10b49bf8686e8b1b2ff295284a51257f4ea95530d763a3cab9a897217a97363b11e19f8b7e8d946e41bf8a079b3f2b3d459c10f873c75c3699c56f16148b809debb809909b4bf9431f74457f23f340c25f559e6bc466faa8f2815e289e78ae97bf2ea9483fc2c67e1e57c96ce0f36929dad28a95cfbfe76005ead77786d129bdd2881041bfacd7b39f3d18a8f38faffe21c78511dc8303018142d45dd88290cc70f1f1673b68b71aaae1fdbb0d700f2a5ab82ecfbeec19fedb7769e24eaa3bdc13394fcc6000633e2578f0a48a8499209bc21e453ac4f686caa375997da53d720b3c3251e3eeca9f98a6e5e62f72f3349c4a0bae8566442bc7b17c809e7df1f791996b42b77532d5e6a3afacb3a2d916feb555ecbe84059dcb37e01de073f297b1f60478d13d6910d89f4fef6cd4aa9d84b8bb416e3dd62f719120d519e415ba9ab4479480f31711d75f78221d4b0f78b8c6d90678c0a16398d2e7cf607a6bb0d4414fb27b3062044426de50cfda1523eacb6d434ae0d394a8c4b8daa40ef1f27add0f912d8b29b078ef561106f1cc4721ffd5fa8cafa643166981f5bc4dea0866fe9c35b6c8f3038afb04f667dff7d8d65b690a11fd30f93fbd6fa2f16002d4cb8f6e9bbf46c877476c8f8629d86f345fa1d0a53394ab1c66d80f95c1c33ba5cd884537237ac0df1cb5ba1374f6b66d5abac9cce14f6085f9db5e69da155a476ec6407b8855a1d3a738d3164fd105afd6c3f36d12eac9ee43095e723eaf817a782739af9be5b66861947e502e33e75147f036583bac91492fa819766aec171b8a7674c8d963298f546922da04f9b5f255ddecaa8774e99971fa1dabe2a16f91c97b75f172bdaf92d1d3ee5181e73195e581a11930db34560758ed3f87b765bc46454bd1a308d97898b2c8b94fb943d57392089634f04e1f4db28c2493a2b9a751adefc97109a6734f9c809cd18c3de1eddf0503ea53979ec9d0713896ca11a906a414497cc1dd8d7b393763e937e7539ef3b89fac5acd98e15a1792eeb3132445ee51f05bfe5da9dcda3ffdecb156b1da011e59d85427385670f14393ca66d8e43e18c4993a3891eb2968fd5f4f90eabb97de3f90257a345b3b1b6ad4e70ecc00f02c7071a00f83e7b64ea60f0b0c8fb06b338ca95233841a009493a313fdd5cc229edda18d3cd4ddeab488db87b9d02f1770ec4c03ff845804b16db23e10f8959e14455e371216999cab49ef02b680593f80e5be148f527dd9d405c1ede3e4e489e5db318a7000c5517c74126e852a1b9fbb564a225d9366b66c6aa21da46e2176ff1099f68216b90c8a929daceb7b209b65ad30aa3e651a9fe68091e549a5676c2b85d44902cdadd43f542ef69b3e2238f7507e4c51b0a543e29293e98a00f2408c9492683ea77e08e08abfc97eadaa3b903eea53c72770c82173ecf3ca3eb0600ef1586ab82358628d96746a73a042416d283c16e6540b07695953208b2192f70b3bb1bcf10b6ee0afdd0b71b0c1d3b3908fe54cf0dc70684d69ef887521f899f26b1b64c1c778c33bd519f6a54be2b071c1e18e072f9b24006b6a783d58c1fd529e47ad0d6595c25a670db41dea0a4a092290bc26a59271aeb26dcb9af5415dd70666b11a749ef5b93c42087b4eea1876ff45708119a3619cad8bc8ca49eeb1e7ba7d8f6785c153d964a8564b746654b055a5b4d172e1e130c146c66280a02d57302b0ed290479998a17601d37ac5ea6a0a863df11fb08c2d00772b4f0b5fe1bd435712c216fcdd71d55761b87bb2e302a580f193d7c2c9eee7e82ae944a2534e38b3ac07b15c7438297ede55b6953978a4e647909437d9016c96062b37ca5b2b4f29a0ddc355c06558bc0afa00d9cffc39517e94b9b95017127cda4d83e9925f64ec882f23f09fe66875f50e5c0de95eb2f6beb257b617d3b387ad78158de5e0189db81525f969492d19768ce595ac51fc3d44ebd79e59a34f24dc0a5e0cd75efcec7e227d9d83a0f83c4ab8d6be7ee9020369236d0daec31b8519b14abbd425b4848d9c3421bba673572505fadf033ad8c0dc6726f12075f96caab034ea27c25b0178af16326059cb6588a8dae713277ee71814c7d05587876f0bfbd968c4ebd4e4fce69b3840a472d02294b113394b942f59db1c02d4564ee85f9b962cca9b54d6dbd80f332b2d5e7bfbb907eed54f1f502be718f66224092d5ca254177ca2bdacd609c68eb810b15cf4c3d38983ee3775d63f56f5897728527c8a7833a9df6e34929b766f2ae1fc8735eacc6300946adc35f073059243fd6155b5e2ca1b83cc779aae444afc8db1d2759d53819a58dbd0652751b8ccca923d3344f7f43cfad7196a0ceeb0b7a0ccfeef9cdb90c14db550f9b153db5bace81146d9bcb9b4e798019ee21994f76d3fe49cd5662f63aa7b9dd31338409f1b5f9ac4be1150cf3afde15f42b10266323d6ba9d11d76f2a7b43da2e568b0b60bd887931c5173adfe4ddcfcb2e417a34957f0b3d86df6c6e0227ace16ad7ef6fc23e4032f1b4f29c6986302bd5285d1b65ba0c401a80cef7c144d5a8c0c2659198dd5e9d852a01a8db58292848e2e1f5f444ede3912847316f3305aeb3c82470962b1ddb7a2cff72539a058faf73cfd5145399b6c05d894199f357d87dc605bbaf41623860727d469ee2a674ba0f132332a8fafbdd7485af5534fbd8e2bf883a2bbebda1da741191e494119083e0e770bcd600cfc1234bbc866b50915d9a79151208bab45cac54e5e1aa310b06ab2242bfaafecf200a20b2bc00ab8b607e75b72126fb734df940acd558eb9b38c663dbb24548a744e94fe408e5af98d230f0d2fb283eba92bc579a72390c3af786450669c02f21a7e62372b118793622c257467369d0b92474a36cb72926d047345885d5685ff93848d3817b404929736ae5a6c55d8899ce55f6e2271d613e5f3b4d170cb4bad78b42c91a1690ad5a879fbd6f5227cb845c3cc3dcbdd281e4de9e2007c95510d474463c535945682dd446b4e56745a0d5cdc95fc438894d3206c976efdc1d958b72ac12a661573c672416a2ec6c845bc1178db490b8f6ccc8091e80ad8474233662f29a4fec57a4b3695a6cce2c8363594b2fef11c536c50af73e60bac2721f4efad1af2f00a51a3d30e5d50ff4776d01da192913a7298411bbe1b114c521724eb8f31cad06478a24a9b7a1767cbb17ff108c60780d5969a03cef8fe870c1ba7f8398b640d3ab61efb1f69f29c76357eb916e7db5b69d3aa0269dbd0befeaf26629e3a229b83a491e006b71797be815b9d76645af07d698b4325b1445a1076131edbf57d45b73bed9d6a493ef21a928918a103eda6b9c49147e6163dd7f25aa3b7cae83a0695030604f6dd1817b3c66ed1acc472e5f3db358661ebc379bb47eba84d7c6209a9ce744132acfd4dcb5c43417ec87dfc51e219e15ccb9a4de4655c4ddeabf6dd3646e5c2aa3e92a8607ab591d9b9332d8b14a41eb00b41797843f277a4696ca90627da9178cb8444eaaec0efa912a67ef19a139a44f6d63efac584bb48718e771b97893b7d38083ddc335eda70dea066b0d4c96ec03787825e3eb33ddb8ac1f94149abbe4ad95fe195f65bea5566f78d41afe4af960a7d2cb7453312d9545dd0ebce70ab8960becc3e4519ab1cf342536339ee5d9dc9d5e44fd90614635ba53c1de55b4c3f95eaf7b40151c4c77c81f9452bb66d186298afff64c5365873f5addfa5b6b26e10f1bd13b2e753d4e2ab6a66d6deb27fd1f2e55ab912c069919f25fd2f542a57314f8bead5288fee50fac41cd50e5ee5a0edfc0eaceb91b611cc6109944adac47da0c89d4172d7525195f4543500d7b71fac1d5716179bc9fb1371a13497c4171b454c90e269985cf3f22895218b3d437d45aa556336ea5411722a7b3a86b6105e3b23068f70da52247895a7a66069d41e1306aeb24c9a82732474167f87d929c3577c0bae7080c86b4c8b257bf3e55e2ca442249dd0c4ecdb895656975b5280a813c4aa37b10fe3921fa20d1feccfa885f79a2cb7db1c8eb25a2db91ab3cdb27d472e889e4045882b6d956866c09aaafa6cfce151b823db0879142669ffb74e4bb72e8b8f060cebfe54e0ca68cd634a2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
