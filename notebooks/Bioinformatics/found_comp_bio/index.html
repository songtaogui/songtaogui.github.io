<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48117ae0fe629832f414ec3e7ebc2b5038fc711137b9c3a79516c3791c0bfbb166e0c3440f5208bbc0847e06b54de7b2ba21af31823e3b7fd4fbea930854516916cc21d3156a4a25076bfed0f5d41a63d53bd0de8dedc0ff30a48274299a30fb1a607d94fcb96ddb4661179a71dc74b8d1a941132b75a1c7f6c4ed34a9899fcbfa728bc297af6d32e0781dbffc9f8db2b4c4ef2a1dbc40ae24b453964d4927f6b243d3d39d7343f7e5b8c109cfc6be4b101c7c0dacb047f0532b56d8a79f81c7930cd83b830f662410d846f3434d722c136bd7475957fbaba2b10de29830d3b55eef1f841aeb3dde7e6a6792400dd2ca1f65bc268c1e2532c90678473025f62f530282ef1505621f62117490062461a844b3156e549ccbbe703606f442e824199023d28d0ab3577b0ce93422e0210deca26c767b02e161ba49ddbf63c31d2a61e3f0d481bd23830dcc21a54211b030da3e92e5eb1e908f194a8b7e65d91a43ca9dcf1fd7900db5855588fe7d2d2d97e62822d2e5988fdda7d046eef5989c3f90eb9acdab6375bf6188890655c551ea1f6d34d0b2d41e9c6e94e669c0b6b9fa41d2e2e9e111bbf1b1dd9de63463e13e8e6b0b303202713c767a21e88062bec614ae9f652f9cbba2e75e4aef2324dc46c61a305860c23907138bb9a6a2ad6934a8e3f84265d7f449086c68521272ea0a9286eca18ea1e39b5c3e9bc75fd25a560b563006ba69c764fbb099d945f99002429f5fb152163c64acbc540e621e4c01950ab34060c12dc7a3583a483967d27fd6b0477742fe4f8ba1445a10a4a2a2f9de0f6874f30fc95764333f17a642bc3325ce873cc895d63f5fb96a6911c38ad2dadfde1d9a5dbd924bb2e4571096f52e7954de9c8aca6f3d724d4595b689e11ccfc9c52f45180b24e4421f23355db25bcf90ef3ae84df4ce76cf398fc1337aefd3f81d6f76c089a8b4d036e883e9cfb65dc741730480c22ef94e27c4ce555b16cffde9618e69f2f11bb5840863753a8b1b962f6c409406fc3782c35160ea6620716367e1663cc6269b078c056d5d0e21da0b4e9cf6612b6128e19ff9e411898c2c9ece619f1a0d4bf7f2653d686601f341c89c35754f779ca25dc81169e7c92b6edc2538a4daef017ea6771f94d8460a0cda9eba3b42498f6bee188fe61c8dd1470ee8ee018725f05b714c7da642d6642e902b2582d9b6c4c6f15c44b9d6ad93e09a889ef83cb63007e9595dd61ff17e0721b7b2049d474274d5dc609af03843c60ab7dfd1d17374b2601e9d17cddef20a61bd59213bcb466b7a3555001572c35ae2ed2371cfc3aa07a4838837d20dbec8d6a90babe958d1b94dbd0acd02a92b03bdf3e5400c3f7cb600993884960fa7cd395fbc453da36892716d53b7598f40450af13acb3af8216a94dbb949e879e515d7f7ffb514828b1edd3f14406c8bd1f4e81636f435112d4829fd2eb02d276ce9f13b83ff200f9405dbbaaef9a27ebfad4cbac4e4048962a56d1c96ed0b038e2f03968452bd514274afc54a539ec9fc82c988a0838f429b6a5aa51ee811ba8c4ccef35fa2a0dcfdf6054834081a2b9b8f8a9ecc9f6d3552948cb7ffd0bb3717e3ea2d017d3d8ba72ce5924e8ebfddca19e4cf6962aae9ef0948caf12c4decc8bd6887653e4fd502123a2f467330f0e8a5f82ff65aac0f79a14b67ab49de84d0ba4508177a9d48592f601b263844f956f920e7b65bc3b9910a701dabe09b50408d0fc1452feb5815807270e1d1d4978ac8a3e56c395959afe13d4a3039924e9094ea942625653d828c1311235220eb5146ee8fa7ab176a480beae01f2a416e265076ff7cce33c9641095754cd3f696fff702c24dfc6d3462746691cc10e0d2111050a806ff065aae5a98a25b47bd3f0add7a9bf2c6698164e43dd14f38b4cb30c9aaad023a447c4589d99584d77d29e6becfa85a6c0e0603b8f0de11d81798e0c2fc3df4763b8992597cfb816afe084d840319f5482e5c444b4f01bc28cf743453e54a2b37525a7c968c39be867a4425f6d83e2cc717fd9e84e60c49aeb0ca677fe1d6e199e9113ad3f3d3fb8934c9370ed60fca93b34025f87528357eca15a81d0bbdbc3411ea421e79e568688da9c5f03e4c2a12fb121b8da225ebf8b1cb96f26254f2b2531ef2c5689a6b3cffd88683eef69f41bc80fd844521ee89bfc463b18a6b769006e11fc56e815574f3eea0e4ab2f633981eff5a32a7023e91c00ac75732358053285d75f7a9fc00024a0ec7e0f587ba5f58005cba4159ce75793eb0d4e84ba61c8e9c35da215e9fd172000f1d2214256ff7ad455b315aea4672bab2ee544afef108a2408f3ee0da4cb14c580bed3843d297dbcd65c494bac61525ce0ba6138f8eceb3fe2bdff95b4a44d60f3236f62cf200a7c47216d8fdffcd315816708f6e292d9bb6f79a969f0fabe79c92facf863e7d916e2b110d8f7288d3de86d07e8a3ed1b2184334291557ccc8c8b1019761a186010e1666ecf53a7482bb3dd176469bc1105b07e7b02efb025a7f5ac2ed3ab74f8f45bbab677bc0724ec4bd7ff2274ce91da546c245212468c893c8dae38a8f10753063c340dd1fc1e2d9c07969df3c207844ff1956f3eb6a857cf0c25faf3809261f993fd8fae4de9f515ce0af8765fcbd2fb3502b1788c0f62f237ec082b82d5f8a2fc6f17847c21e1c9b429c299aaafc452efe3168e28af0a907e31bc338d126015906595abe1243c8d43392557e53150fbf15ffbfc47189e0868e6c142b62212ddd9993cfb8a656b502e163454f4e426ad2c196713d41211e28700dd9156b2b613a34722e4d50242f1ab320acda89313be61986524b8187239d749c5a786faf27dd719258a98e13a904eb0b6e407c2e230919fcbbdf8887b4d98e4f2cc5de9918ca3f1f29650f9f28ac65e6932261c0195276d36767c19be943c3e875638f1afe711e8cc306897f3e62d324b39ff595a474f0e4344c44863b81b01d4ac82c0abe109934d25e4c4405da2dbca728ca04c63606dde2027273c365c5ce0df00f1ab8e15195687e78836468b8ababcb053d3e5b92c82a081d129ab224293b8c5f4a575ca18e54144c5b8de019fa3f994c30a5cd59080cf138d219426d0ea678dd6dcf88d82afa01fd092cf2d8b348edf02e7ee191d2d3e9a75602b7a8fae9f4399e95e1b04d126d440c83685cd7e638115c5f08007196356281b08e01829cdf422580cd6adaf83ca438f19c894bebaa400d53687f2ca187624eea043a94f87c5b723e8f1a76b83cc5f5cde71fd344cbba6fdf4b821d63752bd5a560be7ca209640d3541bd6826dfd91df00cde5496257d1d4995bf1887a8fb3cda81f4885362ce16af764dd167822b3bd3a62d2fba4c6479f736e1c6a6bb9cee272716bc1420c8b63634b85c97a02e2cd9ba2d15d9d8e36dea2adcf2453da793a7021314a4ecb705ecca3f1e75858451ed6dee0a6af73e109d48aafa7e669aaea1e827e84f3762372f0df0f22c186b1a6b5351d9d93af2ee3986a9a3f05543aa56d9fc7645744559368963b65a274cc553b66542ca27c8699d402eaf0692927d021157fa990417e0c15a1c85650d94fd961be7fe760a574d638c1c5ef3e1077e104dedf83ab0ae3c822f31f1d6202abcf9f3365c39bc26e28cc491b00dd0eb4312e701d743d8a23c6d973581527d6d8a5cc5866c1b6dde902a2f0d2dfc01bf54dfdfd5fa5fbf93dc6e64ee9effde5c6dd73f1c41ba2f4bb8981c9c6a9a75712423fbd14b9f44dc2d47b9b019f04c81f5d613c25619eeb32520417fb02110529b62e004520ba60bb90ff289d0aca5a099aab94824593c9d43cc81b2900cf0e71d4746c0e1b1cafa9c6939242c41fa053da23a900edfbc59e87d0ff0491a11806cf4c13dfb074ad1a9e5c965a361367a253160b15feaf862e43648fbc5bb5e9d6c3888aa5a60ba965da302bee235372ec40de71b77802799e474edf3a5ef1df9a2bc0f92a3313dec7af389d443ee9abbe83cb67fc55aea9ecb55c0fee0e700167be27665433d21b96150b6deb1bce35079462fb96f265f295eaa967515cba0cd0cb8659bbc19dbd7d121fdbf23859e98a383db37ba1539a4e01bab4eacdf0bf23d2b715031a8c9b05596c67a7d36926cd6fb51634790f621097440070084af5c23000ee2da13721930bdfc0d2b8f6341f90637bed258b57e1e07c173d874f177a8810517c0ecd430c18a7791ffac4e028af7a3b28119d12cba443c819ce7f916efdb58488352f5f2b063c791de42b493bd6effe56c0c6f6f831609e7442542d6e86edd681233d6fbc0e33ecd06c2909867a93cf65f676fc83ed67065e3f4b2565bfbd20627376f68459f81a3772969298855b3527e852a57fbc1f071eacba4c009b79670c8aa9dae10c6a6735a245aa1edd2db4f09ba072df34c21b800cc47538b512e4e5b43271bc457d28da192edfc4380edf57114092e81fea6b04efa3f3c8c42b1d80fc3b99926fe7c7f537b397abf127b321c56ffd6208b5c4337e3b17e2bfc02184da5b4a7687e45de19203b6d17e658c5c70cc280b828fee3f93fe66c4c7a5bdb4e26a340bf4dae87aad9f421e9b9bebbe97819d89f817930603c74b2ca6e998ea3258318ce164d6a358f9c4c21422cbdd91e10866519b7d8b8647f649de6534482feed55c94ddfc00b4470d934232e9ce6ed13f4591ee58c31a34523dfd10a0f9cf99112156c4bc364a8a8d9ea19dcfc287fe1082ab003d7746c211c7e2dcefb1cef66ecc1f1b8ffa4335b993beefa8efb7e460364e63141e1a23671a0324980ca48083466d6585025ebd4a3299cb52bea5759a062552dff5ae85a0475193814bcd502143756a823bd7922ad86f70dd93f718a37300c5f4cc530d9ba0d54b1dfa25acba1628565d46c4c78377c5464b19949e9d7db6448f364378d24e32537de01abb571a561d980b3bd14ad601bbf3ca02e10bbde9b0a5cfe063111619a084372b131646465017c4a237af055557235424551417312353a5d204573b2b0dfc4d8d787db1f3b45b3c12e94c2eef2af6ce434f485463f4f37a8c24f6761eaa240c432cb8765016e189a961d5d24c40a448f1d86a79c449b32702b4550174ed6cde5993afd534740e4efa5e68ea5c345821da3bb5fbd6458d8f0e0b5c256c5f7dbd8376e898fb56d2c6d160b61db66bdc0ad08d306eff410ddfc871db2af8338e6531d441e7da9ce6f580690bf33d14620eaeb6901e5645404844b547be46fc2df15f86088b36fc9eaecef6f0f4349269bdf98b641b72fe6908726df44093eee7383c413a6f49f71fe4da765561b7a7f1bb35f9ef4886555a7b7199d60c618fdbb3a7a6358c03e770643a7a7e15848ef3f22826cec32ec942e5859469476310d59b35021b634400fb8c801af3485c61765db3e4b688e04367b32f9ed04866dc4e99493e734c00a8df0750cdcab9ec9cdf04589ec8b63636c91fdce6645285723d9f4e0a3d4570ceee372be4f3a62ac42a2b53f0ea32feb9fb574466acd42ce7d7901c8e7e4cee0e7c13b483515998362b99cb94b1eeb33872e1fc2c4748f6544a01af3fa98e0686cc9954c1f0d49af928d461040e50decea2561c44b5d17c95a1cd527f930111c96ad82c5d203537a6b966b74f2c1fa6fb7e32a2e4c791fec569580accd9749680e7fa3e67f10556fc1d604fed36129fde95512178d2280a692eedbe2916126795bfdc5cb19de88b9172dcd0cfa19225278e24fb18697bbc18bae4ec64e79df41674498dfe02f656001c70d6ef2944c4307b0afd9ec386506f095a2645e0095dddc00ab011be371c0155288d3beac020778f0253405a69d73c1160bcd02a10e08a5e3113d6f9e31548971098f2ce0acf399699180b9d38dbc46bb4e404941e0fd52382347841b95b2d359d4fb84d5faf16c8dbb442266e55f8ca7282909837bd2167bd1c6bfeb7ca990cd9a3d41b63b8a626a705c710a1a988ae950592ff343814efd642d7fcaf1ffbf3938e99534a25a60382cdd44b29b490bf0e392e805628a3578cca0c03eefbb744c02465833127867c870f0ac53c83237bbe97183f3b44ba471b586bca5b86c416f89974510fdb145ebac9b57ab3d83a6646d568134b92044cbcb89ba6aaacd4f7925af91a3549c9b8ea8478d6ede0859ad399c3b9d1dd834bb4e6de1a21e5ecb40a458a77333f047cbfc486bf069dba37c0d9e0964401f9378ea495478f9a519caa76c5952474f15c8721b5b13af8f9e127a1e6f27de63a924e0157f627cf7a841c9a604f68008179dbed1ecb0336a15dac2d3c16448d3a31f6e22ea6f88ac41cf351ed062a1b3e5f517e96da0dd3a2fb63c49741955e3d2e65b09613257fbe0698cc53bd138f744aabe4782430e79ec0386a1d24d586fee5718426fdff98290338851dae2d0e15285c19df61a847175414970876064d6ac0850fa32efde26eeaf2c32f007c424f9170fa62a637ad0812986a4a98ca86c3d80db42ea58f195498099a47e99ab8d89b554aecc555fda2651ef9a3ff90ab32f41838f7cbd4ebed1a50a86f9fb761d871df815412d2f49e62479d8aa582c69ebad84ea2233d7986e92c956258248836ed4f234d3add67680465c6921efccd2111a8bd98ec2b91ce8cbbc0d440efc7a07b8c820b36a9379ec2e027d7320204ce9828041757facb29cfdae2c0792e6ab89a14bc85a252ca831d6b719f3cb1c8e909f9330576cb01848024971da873010203aba8c8dd3d5cbfc24785cb635bf9c5641a9bc907d35491e9233b7a5155c4403e47c3262f3ef8ff23798c91f8ffc6c54a2ca2babd411b590e15edfd78e4a30915bf258fd339af64dd31b7ec1cd938ee3ada24fdd067718f47038c4cd687547c762454a258d91f3efc6eb8b5c9d0a96e591760766ce994d621717c78ae8b5fb243420499a682fb32d698213c28258f321c02ab95252e5b5b68a276496135d57e810037e653f5f2e657457378bc1313ac2f02de2378a7231ff4bda0697ddfc54aedd58f192a208309c5e0fd79e019791d6f6e244aae401de49d1874e24c70f16d75a2fd9d7ad823b4528a16df6e9d6b7c04aa5a21f5ca65f082b2d325f85ae946f57bd7705f98589d536e00e768312453c10cc98a6a49ada95fc8e8e66a7867d948e0431e84ab2daf0356ad5c95aa178c28689bb26a06217ed78d1ee54f6d02d2bdf75e4a44d7678f2efcef94599437bfb57fba0157579351c4157af75a96c4f06b1a8ac838c79fd8f203044a95d50d0ef3ca6be19ad740c1ef6a361dafe9401002f664e55ad073495338c6e3486cfb785fbdbbc9c91c56c6a57f31f58aaf5284a62295f9e0ca0a6923081b3592a9b69204ac7def6da5693cb507302c9e339829bb311eee4a0b90368fdc92b86602a818d8baedc8f3b0a3a19c5261aa99bc6fcaf32485bcf14c71f5bc171151c67138f265f9902fdd8989423708b2fe41fcfeee8a4d459250662c8d9829d3d11da95396b5fc4fe8c3b9cc59744b02d639fa1e417eb7f39ce2e6db069bf1474997ef809ca188cd74602d4ea6610f140108d8e10362fda1d0ebe51472aef980c457300ddd9258018952b570ec4f90fc37b5e05793161de4360289f1f36b462e15317e63081a5f1ad2938da3127833fe56a098e1198234101c3ae2489c5f6d5e446b5ff1e400697dc59b9659e416ec8482eef6d7335f474fcbf48ba1bcbdcb585f23ad4ff5ecbf82f5e5042b2ca2a7a45770e9e3401b87d4ac5e8c9404b2bb006809e067977fa7eb349efb7b0284d191c44b8aa5ba9cb94a2ade6dce4cb3058b64b746a14051d710522a9c8e59997d1c5a3c88f7e925a7f8abf2d6b584e193ce667ac68553953bb384bae01133254fdb379422a653e33733111de6e9b38caff724057c521278d1b30084829c2dff2829e0b6ab5cd0f074f76f2aa933e146d580df2019cecdb1cb84b9985c89348ba54dd5ca5bddde4c9ec1ccb5eb429a98796f8b965187a6d7f7fa38373a14554d895b907877826ffcf3df21501b805dfa55584d2212953e414f9a635b3671e4d72bcdaad8aca939ea38f62fe990bc6a58f530fc4a6641d0d513406f4b1b23682db27929de8df34090a891e9559c219ba16582d7bdb0757e3a3990f45433cc41a881b325a309e6e34146ce4560f9ec30a91016b5e03c57702b1a88a176de4fef6ae190599e0e085c3f938e4e59ac9ac6b2dcf63eb1db4f9b7cccb2a281d2a49c75fdee50b53918eb840d55bd38c9f9535e1c9b5d26d466b749d7cc11337c031caa4de382507cff99e3441562ce3f1363f162f64a540caff5636310feaa7a1eba2133cbee1473a25f1d05d28afefda38e88b4567468607d62d2f18786ae7c802f019ec95dbc2da613c12306febef913cb7ba62414204e67daa477dd73a721331a6230f7011754a31d43f7418b1d38ebb21bd0f72f1ad753e37d84d7d824c53b83a7cfccadbb1a70af96df58810e40cfa6b54b2bb6991086f455ccf113608b9309c45c8261e6657073f059c6180c2bf0d42c2292635dd99d0d0c1faa080b9d15a7c08c127bf84dfb14fd235fb8415c84bcfaa5c3aa9a4810beec16b1fca38467a495fc638d3e0555f6024d2ec0dd16c4ecfad6381aa5213883ea39205d38494b448b9633cd50c01b43240f6a70be4af94fb533bec8129828d354bd63fe4d1057225a3d28a371a98baa90da7f165228fe12b4d6678c0c870e69993e827dd009fa805d9d144b92e3ace24cb80a8d24c0ed8a1433c05c44ae4050d996f81476f0e217c286d5131f0c8ec35b53f9b8681c1d0fe8ec0f0e80fe688bc8ed0c85150e95ec2798d687679978d883d61b94629cd4881ae32fe6604e60abb20d9a77e2618b2c100f4d89fb2a247ccdf225fc0d57d87a17f06e2db4a5dbc77b5508c1b470b13dfcaf87a16ca13eb32ad5ec80fa48fd6d7cfd9a12ea8de58ac99b4ed27f1c1644368936422c9babe8593737cbc059d25a7b61539c99ff23051dba8e20840a78c36091fd9579886f4c96612802da2d643b39ca98772947438aea58ee8154c89418fe8ba876df777d6957d6ec781837195e06e96b8b1c6fc0587bef06ec23afe275a2d97657fceeccd26091ced69f5b66a7d46ced895496a223b1729cbb556fcff088be2ac77fd8154e16f26577a001c31c3f1fb1047e7efecc53a123c39d2d3cd65cb9b501170fa45246be1c7d318bd37c74b379514540e8c7767ee9ccd653c8c85873e862b9b8cd831cbbc63feafb0b3a63ca3480224e4bc42d16f7c5ba7d492e188942fdf8d100ce9f54aa6d66e4a7a69fd612bc5ce89a01c795cd9f907e4b8e5d695f75ee606bbe918c987120f80f46bb061b0095b3b5ba16084c37a53c9e69dda464c88fbbe904e679dbdd9cb1e0b1bed405c07462a137f2497f1723465a6c4473433227fd6a7eafd2a672aaa3d0249f07a6b76f3c447b704487c31a92857d8bd10ee8b6a22c17664dfa00218f545a6e387a824a65284a165bb0584357ccc8ba33aca5033cee5f2527a78740e47f898ee8bdb00b9cb5b9b3b6e6b9abed6d1da30580f118c3994b7c3e8bb172be0704a7f2d3b7dc087dc83ceb09b30cfb4213f405ddb0bae7c5220c96fe78f905a222123e87d5eb318264dac793f7945058a1c40d9b37d4add62a4ecfcc218b18856bb2e50618717560a9ae4c203f6b49426d14a76d8caa50abf60406a9aa36ee64deb4b4f927ae38388890d594af436399ed0bc80c62d1c39dad2a9189695e2031cbc6c2b3edc5aac7b3d365f9759abe4daf042fae1436488992ef3ed2dc4f7b53b3d7592ec5d4a9b52e705621d53847ef0d2588d2361e6dd4dc3df19b717614644eefaa0740a543ee19663b7c682c2564c0d0b08f1a82adc8e8376f4a9d3e5c5f7e11b3242d77a8bd353964d29e9a88524b4d030c7879326f81f216db2fdd8579f83bb4779e2af5882f6b1a4996619ff9a4be800a049a9f08e208da90ab602ff12f6bb3c8713d9b75918db4790a8414dbe28a651ea47eacb00003240daec7d5e20c04d44561599c726a848ae9befb98b3e5931ac4cffe26c2143328414ca1a3f8b49d04a9ba7c9eaee51c8ae2c743c27546dcab66df6e1e93a7ea647590d125e243c39b1b1da16ee2f3ab10bb9c390b5b820f0148669cdefa0e04d2a02df7fa92e9f9c26e71271c0dd3da57d11cc5da5c24ad203a4977d555c1879e8a2c3cb8acfc66a699df1025bc5639fdf2acc2785eecf0009b098387831706018ca113244eca3f7b54845007979e478e7a84798e2a5d14302a3743724ac67ac184a070c6dad359e447a9b94152942bef0fdef945e0e7125a1403f07c3c4c2b629121940ad93ec4a90509e9bf3448d6fa45536f00b3741f1597f635c6751d1caf21cc727e76b4e475d1f3a7e27e384c3c7d551114b9667d59b847c04c80ae460e1acb1c13267601c68ac96d5cb82c47c3e41a818b057fc30ef538196fd34d77fa116dc91d0bc82d773ecdf884e0eab376e11d72c1d3d5da62687e7c069a613587b91e03aeffdc022d57248096fc9ca783857bb1b5ab8a5be293bf1e42baf0172828acb29ea9e30dfe3a43e402fdf2bc6678cc9efeac2a4fd5eb8552be6def5606f9c04d014979bfd742c6e9352b0ff7339e3e423b6042c0992008d7d1c6733f13272d9a1c04e45a164ddb4dc45ac7523f2f4a3761b0412a6093f578fb680498a59b5f46793f7f12034b93b04e225b5de116977beefd9740e72cabf19062046b70589f26f0fc3417aa291d36219a9a9fad06bbb5fe82d0b542fa79bf2cc3b8f08b17642ea2565500e29274806929ba78635f92157b08d4e9ab782db858c7e829f684b130c633795b06580a09113f3f49c347d55052dfed5e9beb2c8f4d541e82f58ab908dd0802aa459fbf92a38673142419dd2bb4ebc8ec7d8274b3f8a05bcaaf17e2557d703300f9430b0e012a18264e0290437be5116093d2f214a473c95f107f80859fa1bfc04f759d6c0051fad8f6ffd95d90447ff53785b60f8661ea8627e40c9e436e60e1e53aaabb0a94563b6d2a67631ac451f7337dca0a0458aabc1889e73f12584ccbf0fe7d9c42ba80f11c173e8c9e22adb4c75c30b6f7654e6e4d45a3a3ff750d460933fc664ce89262cec3b46ff8d38544738d297bd6784e56be70d37de1cc1b34818bc8b42adc3e97ae6d3f57ba99e1145c7c24d498574b3ee241488201f57e67bc91ea0d5ff449f4a0d8d1911424a735d177f2399b53ad6394795fdd77c6ac7d22b8c7b27a208011b4c5d921677ba92fc8445e88855359b25aeaeb7ba0d41fa47eb21e4f2513bdfcb958fcb696958b17b179a424907bbf0b65d82b92271b19355f5c07c49b4bbad6b52f8302cc1a9452e0041685371a21f63770b5633e42155554e71504e77e6f90696edc831b3f6733edb81bb6d465fedf836d76db26de62150c95c9c1ba83dbcc0c80f2163eba3fc4a026a54c14ef733fd8698fb788d9eac078e547abfe15a502d09da79689ce06293945cbd831585e9a10715da86a325245405b84c535d46dac3e19e82b25e8fa5404de013d56caf0936b1cf44bc16489b7b88f346b0fbdba9ed83a2137aa0696cdf2899d826263fa40c6da8bc78ac42993d71e9504e553f3de3bc8f57600cf93741c772e0916db25e6a45f6fc6e72df1a2aafa1530ddcc781124cc683cd4eb1aba3d8da6dd5b36b2dadaaccb4cd85983526f255d46b5dbe9679fb2be9cca4efbcde13248b11b34245def5da3945159bb43723c7356282d09adb9a1adfc9465895f0e9a5a29084bcbae87c3d15a9638a0deb391e0fe7403ee393065f36d034babdc7d258fe3d451f7fe2d63113c794496def2ff5005ef439eb26c21de3e7b6a34eaeb96acf1338d78bb8f5e026c7032717881ea82497ee2ce09f81ef7ae7834ed19dd991552e3cc9f83675c4b1bea24ddb520ade347a6f5714a67ca905a3937ec790bedf62315f48b4554b73eca1d02c31ae6868f206cb44cb92fe3ad29e9e5cc22a0a9d1c3d4eeabc69a17c9ab61ae2c3133990b974f35f2d036672a0b0308e688e4d6b070c984be3b12a6796df93db670166316202154677f95b592a17a0c42a8a8c36b122323979afaca1bd87291f293efb21de31b865d8032b348367ad8c354f8ccb19d8933bd92e4dca54fa0bab7836bce002df07b11d064e92df035528b1fb8458deae45de889513ae7da4a7bc297196504ce8fefeec80229de8204dcde00e545a6b8746b62bb869b99e8deb3dc5b80499992ac13723a63b438b0cd3d13d3254b01c7f4f07973645f29a311e8d8ef7aea17c72cece92a109d7af33881cb956e7e40fdaaafbbf4cb1edad31752cc683fe552634b94374cce501ab6e48c0425e1cbf6b4e4d45097f56540411391284ed2787c8b04ccffaf0e850558c33d69d6d5cb69e37acf610cf8f6b6c1661d0dc2864b8aa043dfd4d284d85dfc02d153af12eec88c12a6f6d40ae47af520f461151dc11c92389eb3b48d615835e5ce359422b7a98d2a3abd585492752644a0c7d89975b1880cb174961455badb80bf5ccde36f3bdaec2f0845f3f66bbc05132f6a2662048b813a7c0b92342277e5703abb03cc4a74e61e9d0ad33c6db30d9e5164a3876a0b966735fa3f4d466909d9a936ebeab5be51c1fee6b07eb69fe6a866c21c3666c5dde98225cabc663bfd7c3fa33ecc754bce4ff876f6866c7c4cf3bbc74cdfe7a097a3f7d00c29a482957632fdf80d93d9407c50c6d3dff7d63a9f57eec75d8331ca207055ffa021e63b934010fb43e52e3ca422bad8e1225f3bdb30b468aeadbb22926e17197d66ce4c88fcf15d46a9565990afb7555348f111574ee2246d904cacd6671ff9f9a3beda2235b9d7426490dc21be02b5f9f1acdf3a8eb30695e6d09f7a306f5cd4fff58ccceb5f7c3358c42c00a381ce235f34805082cda69f765aff6671e7fac820a07185ec8692eda7e4b85983e615b130ad90d7c04eb5678d18266f280ec04df7e85ca121f419d85e4e936bc80d93ddb9b701f43a6e43e80e2ea6df7f04394248fc0cb115706bc6fa411927065142ea6978ff59a05e10083a69ac3ccf0d9c93f16c6ec209a06b3846d1ec85852298eece7c8dc47d637b715a818a4ca983f8c0d34a3387c74272df5b81b03a6a8744e2a9064d3fb2ce4a09add1c5f2c2a4948fb85d7bcdb4b94006a5a8cb7b71f67097e2caf18ea21219ff09f790924c272d16468cec4a576fca30eb3cfa4d04e947e5a8c5c8e605ac7270af3f2fd7e0b4836c1a04a1cb5b61870557a21ebf44cdcf860bb0042ffc53dddbd26fdebaf7808220a0cdc492dab2a97fdf8e5d2264530b0e2aba8167c8b2ce951d2bb98579482578d621a963dd73c8da83413a7e07664b48a5d02f65d0754304dbeb9fee2625b47d1cfab622f76131d2131b394fbdf2fc4cd00c02f8e58d5d45bb56c2cd125d64256eca9b670ce53792f6cbbc89a0a8f7422e7b158de0b332a2aab8ccfa862fa4a93b38bc0a3f5b6cbf131be78b851eb2dbe7539485adb6a0e37794ca956d809611501d910f770acfbfcfa0212b33aadcfde6f1b9349faee15347719c41f32ef9af7f20fb6ef9023b73f8b73beb5cc19b30c3fcd9b9905349cb34a76bec17331f5cc44792c6116c4542c6870e9c508840fdff6e1e76b098a8dcd30ce0a847204ce13c6536261d24be3f06f100c6f4ce91e4e047675ed492fbf581a144ddc4b3e260e162b3a8ee9210b90716e37bdc03032a9f0b1a57adecc8dc32d1aac79258df29cf29eecf6b12aea57e786ca56695a21b00c84f038e82f7fbfeb388e738a082a05df87f5a30cda8097934ea3a5fdb0076302140ac47ef2da4789d570050e78d32dfdf1ddaf07680c10c750dcb2dd16cde723d5f7f0a08960c90852fdcf3e26c4cc603df45b10422f1336d1d8d23a68e2cfd1699af8a1a80df98264b07ed4b65ed3e32b4a9b037d52fc43dc6c6a6e162145165f047625ef587fff1ca5339311902eb8e9b35efad9a2b7926a270095a99aeec6f2f4f7d9134e859c9daeeb8e83a348b3ef3e8903bb0c91eada0d62e62b5f897361faaf81dd574d86493cb68cbcb32d9af4cb58bf71467a27ea673f745a7bef44af552199b0d31f0df062a6a0ee6ba373fcc25c9856f4bf64691630c2987a8a6768e693c60398d7e251cdbfc5e768b3cf100d5b4d1fb866837ebaad7a035c0e17efd2115cfb9af99ef5a647cd66bb3190c74df0bb74dd5f296ddedd33521b449034cbbbb2febc8f4013798cc47089c370b7681990105ecd04feb5d82b67efaec582e1a4f83268689b842c05fed8bb2f850a28b1b5730228439f94de0138413dd89acf501fefee44d9ba9deb8e06ff242ec4008e9fee21eac4a019de36c53d0eee6166b03b20eb93a1122ab8ed3244e1bdf7f17fb33884b977f6f14d417d2373b52c9c5f7e52d45eeda5db6603347d86813f6606eeb444a5f0875235b9b291c9fc32ac42efc076eb4c7a62a2911b3eaaee01494e850799f936a74c7e672aa311f551e8efff192ace471e7a7bb5d6f31c1740b18ccf09e440541c87b7e8d3bc10148443f3227729ec07c5e027e097c1f85ae409a330ef7746c0bbc6f9511db8e5dbd196dbe38b7e422c9c8c7643d171e88b4dffa87ba47b1b651e0b17648117624522ae283396c76f95de8b93103e805ce7253dee228fb54a2cea984750ddf1109e0ff043074203d535971604ee93048110b3662cbe678ada6f70270f405a1b854734e15620fc6f00865b4f0d46de1f9be2dfed04ccb4e868bf81595d67023f80a902a37061b5a2cace9b60ace7d88d2dc0b6a07b44f757e88123d4f23c4f30cdcb26aca5b217bbed0907074e08c67b1cc3d6de23baf96ee2cd04158e595d232cf07a4c000f229c2e2a3a5aa2816c3b49bf796dc6a213d8d428e3d3d6d7c269c99da17b13d51e3648c52faa1c73a78e91ad21d84972ad97b1c6432c581db804f3ba95ed5d9edbebee114cdfdb8a343a88b51a05fad431782ab5f8c9430b010c8ce103ca71fcfbde6ec58d7acb327d473229bc876693c4c66e837b5ba55590fad086ff19b82192db29334812f1f16888aacf6e4b7d55b7d2b5505162784ef8c2195aed6918d61362bf6842912b61a6c69f7d7b5afb283982a38e9fa0e43c135f2d289ce1e6426a6f01b2289e1972537c86c84991c5470eb16b16b7beb6307a123c75f0709ec62b00453309d60776e9547901578d5feddb209253e4f6380a01918692cc77932c00400a640f92222a2c17066b602756458a9a670c3d8db65d97ed6e40b392e31ff84e1f4ee642a6587ad8a3fb5cc9ffe213ca8e4de1c56e88d7bad674ff1c12ae05c278c8e3ee65bf5b6ad14d1a488d8249582c2d783fc3c093b0d9d9b821c1602a81b57f02eb8ed93828fbd70e0593c6e126b173ef4e799b2613a75162ceee6d24cb70e645d77d0193a122da410e0aa71150aa8605e83544bc2012bd4a0da96cf988e19324c4cd3e0e1ec9cd0fa0370c4aacf3ba9ed05981f6ef665c1695b79e322c9a425bd226440f8f18b42f077c8f84a398697f1dcad5a118b2ec4787334712448488d31bac272a8eed50098c53390bd7d28c741e376c45b93655cc91a7ab4a86b7959718103e2db8edcd2ec004ed90b22f51905d967c6fc40d8934655b3b4ba789bde101401a2b65f391a1d6e4423219fdde136b4b6f64a1f08ac47dd0242af58ec9d23d8ce47579cc0e58fcf9de803647bbce1ec635943521adcc05f7a472b2ca495c030006e0054872c73016cf1c72e85d6cdb8c5cc85fcea595b9a7a32985e3e0b1c821d970fa54ee57daf0f2a9f0cc6a08245f6c6ef4c0ac993804a636457efc26e945f5ff38076a27082a66d7f6bd92863e139d59c64a53392b812426b8f1906091e63f4867e36ff945c30fdd74889ad1bd3af86858c8b50a1caf271b87bd17b86884d544b7613de831895256a404ceda27bcbf3467fb20b0549a7421e506dcfcd87ce82e8dc79cf8b468ca66392e9f9c31380e61f9628175632d6c7d5206a77fae79601b87c9ae7f8c2e8bffd8358753bb6fff5ba0420e58af8db3a093496c6acea76e6560b641a8f4bad82883d6295de14b9553a55e5123566b8c1b96b0eb132eb50e574f473b1959315ba7ebba5f89a33d03bf457451e88f52caf3d23ee63474107c264f96ea2c3523c3841644e9ae315ce16be6e90be4b91b22a448be50c277b46ef8b51e674052a0126f44cb76039e4068c794c54c11ae13dd6dc5bd532ec7c3c63c129ab6ca7a23688c28922c7e01a4415471ee26d39858d3db82fee78927d48ea6bd5e76faeebef838d531cb8d8fa05ec586ad100f12e0ae66b21af22e5967887852ee3a5fd0243209bda70367a2f2ec1d50f04c73fabec153f64bfc4eb42e0fa1133c3927c6058d6179e4e212dae32ecf46753598e6fc1a1a1626b0ca74f644400f90e1cabb6c68d7d335eebd03116053881e3ee09f490ba5e73fc5ed577078a0920c85c46892219e5acad5f789ee58c482b0a61d690aa28597e47d0d7f4693f47297be43cdcb720b3ebe88b8385decb3cbe06a235a4463fad8340271769e0e75e20a834a90b8138616b7409108c4c4c36d32dbfca866b20aaa3599080a13a4b21fa08d4068559071975b089b6ad393656d4c7d72de4315e89748144bcbdd67985d127b7cec8814fea467870df298dc2241ad79a725b50ad8dda752546d53d4d429abf2f195cba41d61c93e7013c765c67cb095caa2c4c89810610fbd5022e2a21f7c59af74c92ff7a7919f87bb891d1b9e887cccf134abdad52f189df934b5351ccd44066f42d9f624f2a9a37dd94f9752dd82f7a3085adb062225e5ebed87f3138d9e4cb3397680eefe73803baac9317056191c89b765ed5b74cd3043af23e8d40065dc7a7b6596507eafdedf5061985e4a260bb8693b066fbe0c2acca01f190cd7b82019de44b7732e9f2e5827032aa261598ad6dc73e19482602ed25ce7fac5509c45e17030f33e775bddb5b7a9d380be8c8bab03ee7a302842b5bccbed0b31576e8407afe6d4c015369aa31840b599a82691d8702d344c968974c7703c4dfb4c68fcc2e85045cbf26d68258af65e95a59f3bf27ae61474c9a1957af5af2afd756f949198c64250fd14e83dfd58f8d054c86ddf303b3e813c58c78bafdf6b79b3c0fabed140b9c8b80bba9e1ca7fdb5617db987ff51aedda7755310fec13a218ed71c78219152956af768774cc7b69d19358011bdfd4d84bf40037b15c06609029af18e44e2bdbc7e94c047924117df07976cdb5c466a295c3a10a5e07d5d246d2ae1e58a4975145e69ad59683167aa72b1fb76f2a90caad6cca69a9dfa2cf5732ce0e507492341f96013e20cb074b1c345c849a769862888396896912fb2b1d58c8c2b7c31f4b48e52f28cdcf946892a500b78804c8483ea5d48f298eb0ce6676e1e72bb63ea435a9e4c56d411408cc686640d9f251bc0f7b45e257ddb8b91ee8800425b76611c932fcb9c8c89cb08071579ad9a89afe5d89cbabc801c9fa3af90b57a5785d27f71c68cdedc35f6ce279d3bfde726d00f64706e48a5726aa3dc9314d161211061a0ed10c324c096da9bf0b760403f4088482e0c1bceb9f4cccc99b18bd8c95d007a987ffdc29c760be3f1479e62c2345d6cfc9d71a07e4766bca9509a9f198bf83f451a3bea976c1dc6c63935d2efa3482a7a44ac8e23370b45333f66a5c36a6d2ffc737f8fde2c1b16fdb3a372c1289c36503a0e7cd88a06fe25084de86eab506f18c96d297e03355a5e5d98103f71b636e45014b89a0b486e95feb2d11dbf6e8889f875e5acff664521724f068d8893a0eb4b7c3601949d63641d503ddd5b2984bade6eab1b1cd8812e769aa15a447102d697fc5c373d04fed3b39f496ddee509f967909d841a908bc29036b1b727e668e9d3bac804573f5ee29f99c3fa0361ce5f2960aebde61ee558a4eef383d4312da8e900125d2b93587272f4f4e3d15e087b092b07f2fbaafd21583951fae83767bf41e4e2ad037999f793c72ef748fb59118b562dcaba891f4ccd259dfcf586bbcc85014450a02be5e97916f3baff8a5bab25fbba27f7e963cb2ef479bef83efe717fff1fa9529a77d702c0d9a739faf1ab03ed5b4a2b5e8d7b18f1152db03987b7e924313ad08634e8e00b9c9ec292e2af484943b9a4288a43581c69a3f467b01dfe5b00a3380914d0ffcea7a8256a6b3668c9e7b5c3a83d65f277dcd671a0b271433af1668e5c37afba3f980f0410eb7f791de5eda80282cf43a5cef86c84532bab543ab82ad52f596678817c7f6a9231429f2749969a6cd998b9589f18e83406c239b71a8c3aa4e21ed1fbf","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
