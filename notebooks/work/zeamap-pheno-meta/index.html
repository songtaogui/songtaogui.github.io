<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba519da0a19d3f75462eabd17cb73ec71bc77c24f4bfd17aa43c626e8c799b17d5fcdd023df9dc284471b25a7f28ce2084926314835df9292836dfb96fce97636ae63d2bf36e1b08363b5eff2f16e2aacf4c107ea9e4239e4ddae454329296ea63e96ba6c85c26bd09170b631c5ffad9dfa8588d5645193e8b73b4dac6e128e081564d07ebb21da903fe1b22cea6ac01e4b6f015b74a51e7258b3815956a663e0d964dc8fc64bbaa2a37066dc58b1c5145dd727efb3861f18fba805794ff8012e120f0206d64c3f248c3851f2c17c1e65e7dd5f43e94ce89c302cb97df78a0e3eee6ca7d4ec8966ed0430c42c06a0d65ff8ac2508229ae8c6cf8ea6a2bd7b9b8b4af81ad07928e26fc89fce6fe51be59d3526a9189619cfaa44be3ba3e0e4514ced23eaf2f76f7c45746f0c3d5d6523fa454ad1cd05f88cc859067c1d67e2e395b91ced69b08336c71140beec9d130cee3d10b84c473a014f6e3afd9cf4eed5c8c9c8230b1896a18eb5b66a4270f89c06d35666848abbca4638d94e46e708192ac7ad56a270a4c541baf0470166a30a07ec3b94541bc5f619ca9b87611cf07c7a011b3069ce02aca6e63fa2ec8643b7915df22e1f8e5013ab26387bda77a11874aedbe6cdcd9ee25a39798fcfe26fdeec68834cf04f1d1bd4ce37e168e06b410206770c4ae345433c3c4b0d582c649dbe007c79a396050ee5eca32325fcc0f6f9004b6d7d080edda5bc6977b876858a47e61b2319bd7274e21d7466b9ff380256bb08002bed5734fd22367291af1b4cd7556b4d1cd540475c5e6423421e706d3b96c359cd5cd7ec882f0558d2c3ab455ec1390e71e1ba3c2a61a5bf94eea42b01ffad785dfbb5f33402d304612398c0c40e64bfcc41be0957726b60d0a939a0fd8b1015bb2d49b1114e36ea4c873f92f8fb5f83cc6230e008cd273e12d399ec0a2919c4979c0c5feabf88df1cd37cb0f984f70dccd024f1c4ddb4e25942335f4392a0f49bfd914e893142f6978e34e7a3f67b1ab9c752d6ba4b43883aefd6bc35c487d9358ca632980fb55be0dcb5b125ba844f97c1493fdf472bcf9fdbcb5bda49e85be881f448adde0b6fb6aab6ea84507ad1ebd77fd0116389079dd2a27a6257629f485faab4813d7a94d1c1a758303bb19b276072d114e64cfdd806f0a05d943bc422bd9bfad3992ea6cb5cff656cb9d9bce6bdf0cb9d3a5546b7f24fe8485c4da1ad20ca425fb58b6e1347b5db2545eafc491210b6a0a8905c652a2d4123400c2b6813d8a8bb806c76622f3d7549518b7127ab18bf65f8b0d7ebac8b6991e92d72c4d49fa609bbd0601a58a24fb4af1ace2b57308a3ca86dd00c33fe8d74d4af27c07e9c2686e5178841f1527cbb2cd639ee64717350b586427354117b61cbb467773c6b628ee5c039d25b9a30931ef4189d56a79f82be3fc592e94594bbbfad98c5275d9ad7eed196e6402de6d0a7868b6c91e84a057ce5a9f729ebb7ab9d31716262f9868780d3ba172cca56d5dcfe59b64bc4e65d2513d4c4e4347fc24123c1f2cb715446c01634fc3cb2a4ac01d48ef8b559294212ec35173ccc2db21c7e95d06ffc49cbd7c9665b714a00b511b9469daab3451d56e731319f29606983d13f02466750cfe4099bbdf47f2353de546103b859fd45ee6bd912d7acdc0083b74a00d6b68d78386aea31c074a4f9516489e4ea82a42d10864a85f451f930e331ba3288103d1295061ae3be68a185e2b82164e62ece21e92de97b180930c760a4c0462829e268f0f7b71ad1fe28b9df0855fa8569388fda7e8223919cc52c95829233f4b0f106a4654bf116f03bdbc5a9715f747f6e1dc7fdd1cbd1f3a5f3b2e3c522884554aaf81cb4ed838ec02d1e959b52249eaf452a1d91f9c5bdde7e6b37b495ae2497d417e0e3c96ff13116c8291988a203beb8d381aaa71f5331cb0c3907ebe077ffd4bb62632d82b3fc3a54ec6ef09067664c94bfdcc9d813677de95a7e41c4ba3846ec21a1a58ad72cf67cf69ceebf180a1b09a9c50cc0ae37678d055f1b9f3d452b02f4f4b8f198c5561c8c5f1ccf0040f4b4db9dd62baa28551e2a222faad4cff48ebb605faa946792a83be78b7371e1cc2e0387e25130c1979cbe190cb8fd97b5fed6135f01e5a7b1a3fc6deeb7c8264aa338f8b45c94c76fdea02b9822948b2d455a2225f6652dfe599e31d3a7a7e89eceef616c3c683f59df6bcbe721dbc08905a29b1dcfff6ac43dffddedd8f33c532bbff919d57dda7e27fba92aed158cd3f5aec52b2af71dedf0ef003ab32859decfb16b38baab26c65a32b739ca66012dd2a44f73be35e5ee229588b45a3cff4d7acf6481a38d754e4ba8531c27c51008526cdc971bd86c9b6db851c9cd5bb42292df6fe037c8c66937729dc18227540dadb06b866a8818ce5c88fb4db1e226e06fafee518e76cadc76fead491427ac0f77aa5abb350145080d09090d17abc6f167d777925ab5888cdefdcbee3bfe9be526477b530ac3a436de1644160fa6df71dc2aa2bba7297a263bd9f8d51dca2b0ff401540e86609f6870d4714d33a368fcaa94381364389c733cb6c8f3c25ce229471378729a1410d65ad36a0cf4574f87bc34e9674aa5cc682f50c31d8f97f231f5bff7f2da15e3fb3c41b5796416de559f8e553cda8ef9a3d70d33f948de6eecea135262b3c1029311d4f113615a9c5a83f185ec269dd41cb76441c61dfc9739bb9e6f64dade1a4f93f8af8db392dd12c43f365f3ac1750939a9ead8382c3dad8870a009a6b7c28358296f71b01bedb0fc2a1df90823a6f3e654374ec3f6b6e78643a1484e878131c059283402ffa6f01d08d7021714def43e51ff93c3995348424b57a10a6fadb11ad38fe1a3b2c53bb55efe31cf9261c6e4880cfb8db6884b4c149e478f64298ee511cd11a6ee58ccd1ce0565a7b20b3babe78a5a3b034f75705b8ada44d01d27a8e9d16a08fc9c8ba8af0bdf169d375e26490c48006032d340cbcbbae55fa4774030de196aa7a190f1bc0db2652b379cd7ae32fc4e294060721c2f3565296fd3f90e8731d59a421fc6416bb43de860d0f7acb8093cdb373c9cdba4000c26d184d76b409b18f71c16d8b3a9525b31bd6a61c720d19637788bbbc837c3eb0fedeb3a7aaf2998a2d8e4dc82bbbef679d7a26affa6fc97644f3d45b440b6040df91c1558a8e41b391e93c23aab5bdb6aaa64573eba7e95846fdc59ed41064036af789b391409b758aa9ea6b67d4f14255ce800f32cce51787fdc5f0af464416f34cf9faf183c17fb60833cf6822693124c3105c63be886561430e6e3744632566d6656a0ca128d201b1672c2e53bf90fa4eff95ed1fac2453f8ddd8a63d755c578b3ba53fe49866522d8d7484a7c6ba7f37260ada887e9b5abba06c03b1e6970115d5f487a13f93a93c783a4762fc2a9a6087d852698c6bb29d86652c5270a4cce8211908f986809f62af9113bf39481ff8feb8a82d10aba8de2879b25a2c89c59e37e523279ec280182f1362c452ad1f102b06f74281badea34cc2c09cfc20d31fdb5771f42c8fe4c93a37d140f6d3c759da12ef2fea8c1bd31d767e482380fc48b13277a7901b55ebd1919d3f3a35b1dd30ae15b65ec5932dedea649f5c98cd2270a77786cf50f147d28f5a1c3475e67e6230772b1dd03183aa8827f5e316ce7fbfd6455ec3b5c833ccc385b6c0a814eadf050ea6c79f2965eb25cb046cfed714f492c973574ed957ea1a50c7ffa9301ad6eb3861e94d9f29afc339e0c0211fe2e03155b9654146a9b717f5589fd214cc34010ab3eaea19054ac9f1323615aa1c10c467fe0e316b6e855d87b294a1ebfcca703497ab9d3eda859016ed4bce3c356616aeed51923eac68391c10dac8c69377b6c79bb68c29e4a291203e435a9a203c837bbf7f0a38da8c0955445d66f0f5a99f63406374159eb08266384e45de2ac7d292936c4b7ef214142999e89d1f234b023f8a7d8a8098310461d904d085d82d300a6b5e40c37e3d8641fabed0dd1566a0c9053dd811b626ecd01132bb78842a2bb0e4bf718584bbdff8d79f87508315c90c5508a06a48b932fd6383ba7ad9b41b1306d7a82d643606a2ef71842094691f2dacb7de36ad1c7b65c2d563cf2c1a2113742e299240854d3e790e599ee1e21094bc10b501eda22713a46193d749cc7de0f3026a54e3d7935cd2b946987ec73ea8362d630c5b1115aca66ac234eab31170aa02286cade3378769d2163f2246e0e74b60ef4de12d7ce120d0f3a8fea8f6d728d1aed87f6749eae47be1196ee4bd6cd07f59a577b27cf68cf19fe9c283c51ae5fc1839ad43c4444654f342fb91ece723786917646854441da4825dc5e83b396d02a33fca307799e55bf86f9883ae4edb75b8bf9791a6da9b3efe65e60e895b7048d8489226d89419135b8d2eddfb70a69363df363bffd374c984a653f643a6b50ffe07e6f0f60d3bd41fcc0353bd3abfb1ee874b2e2575fe8ca2cdc0fcd49005c49e75430ee5421bd591c76fda9a006bd414a35b552b287293d6c777583db6a1216d4b506ec8c876763ca87e32bb238bbbaaaf57594579f63686e5387caf559d7e3a7c47a7f7053092483e313341cc06c6e33bdb30a105871ccdffa4df5c624e55da460ed1f722c50d3507e1ca86a4e3522e1c75ebed0c5034b9d79a6f81319efe07b45ac3cf7bdf753abb224ba0e9cd872c4943f0f7ee53ac08680bd71f59676827d3f9acadfe3e2881089ff5d665b5e8600f40a089e32549ea3253437043e26ea2674f60d2017509d053e478f90c43097cf7fb29d4b3feb7817a09f0aab216ae0a572ee71d8b2689669f69ff243967f865615bb0efdd116fceea9e438d78ffa28ceee9ea684255f688695c97741739e232de260a3bf8dd385da4cb1e9cac6700d968cb4306b5ee348a5e36bb5edc83c27456feaab8e1132a72ecfde093e73b9bae8920850b44d6ef933b2dcfe8d9670f4ec2e2ce45159fa6a12940fb999e4e4b824a1bd34d0c84239daf5778cb976d6790428d69c2b52572faa1f2b7ab89f7f031798ebef09fe91d2f2f760424a3b65f7ba544314e5fbe61444a8066f4426b9947a394f40a4115bd7d68007a0f5afeafe4d83293dfe5bde4b91350dcd083df6c6e02e6dea8b23d84e2381be5b5d5a70ea6615265a90a4480cb4835d662e5949949ca036360e3c6147423fec19699c0713ba2de89c24c2dfc369d1e0e901ad54de1d73ed4e5d1d3a6d43e031da9cafbfd9c2b6bc7498152c73b1b618efb55d49ea216c56474d57a81ae54abea7479276e7eb4230565282b6eec011cbb0fae4b5c46802cbe23fe759faa415963a292749c2f0738a90543f5f7ea2aa5be2c93ef9f5bb536deeb0c73d912b2dcf230b90fe0df557f8a5ec55911e4d28b53456cda8d825b81b2f41fd687f14719b0563caa3f71501cc86e8851f6e7f532c91ec01fd62c6766a2520be0ceaeae3bafcb48987fa4f454054c353f1d94c04868ef05842806139d9954cf63af9f0c388f373be5500e18577b7335763d80997dac4f482bcfd4f45d9192f28a792919e34e91299dbe4dd5a6498a707c961c02ab105cb8db13698a4b51db76c520a69f5f173c252ea06dab35da6893c7ce20234efc64ece6b33840e1cba83fb1f89dc8ae0b904075001a102429621cd86a8bc2e2e06d8d9161f7cb2d5d0a31e144b450b797c3f4f51da22bbd92e97d27e977e9e74835556a6e62a4197d4fd6282606aee9e614aec7dcf2862d2f138977dd0e96cdd50f4b337b0244bab6af108d120d58d5c4f43146d6da3db13e481b0d58eff11f6ddd024b810d9a3795b96868472044a06e586c0275b6c5913c389a31a6fce6495efed557fd7f800d58edb159f1588da05897bf91f088f552b9fedfbda652be705ac6cc5ebfe74d3da10091a0f347e8e403d7391f1e1e9004d0d4df4fb4f698dbf45e9b6724874b0f44a1af476157572a33c82186057c4d8af0497aa508c5d17a61280555ab138a64d1f7d19a313b17309fd9ac923797d3cc2c19082f3f1bcf60502421b6ad41630a68ea09dfa713edd087fc0f1c5bdb560f3cb428cd7ea04fe21d19e6c791b952510c5398dfa17fc5ed4ecc1f4a7b6ded43588263f47047a78b321d5c057901acc9872b1af21b71d0f3204650bbdbedce0a15d26fff66b555369906b3d68cd833762d9fd0b4601006a0f6853be82379c991511fcff3aa590ad4decd7b5d3e9958f2ce0fdb86f4f79170d73dfd2d6086e0c695f0eaed8750cf82489131c2248252991334bfd006735c350a1ba3cc09415b5cf2b97c0ce69581b0a69ce79b376f603fc2e8ffe6a8e0eeb309a5fea30e044a2c7fb86e6e62b4c8cb50dfe50569b48c4f43bff9cc45c86e899996970db26e8e896d0068955daf03f1915954da2482f68bfeb6be2cc9fa0e27558bba85aaddf2a51cb8cb52203385a2aa8f7317eb5cdaa269c9fcd49094bb6c01a80a1c1e33dc3f9501cd9b8ae987b17d989f55896c2d8b6d598f14377a42e6278070fbae6ad48ccb5e609a39a625ad1047f7e7343ae335b2645bafcbd0f2e74a3fe6e5682a2a3b2b32b903d4c962c760142dfdbdb86a2c272fcd355a7352a5d87d3135e607b67a2441e3464c2fbe6ce2f9fb9899b5d87f30ab2b40338b6499d70dc77a780fd61dd3fa333210d60baca4f83644800bce289e16b34bc8ac67c6cd70eb072f0048491c4934d51d76154e1b3270908461f85a41192452b342ad24f86ae717bf6191e7ad6a847071db57cd177839adfec6f0f1b45b7da9615e5cce89f6febef9ef44c08e75bec40afb8c23b2c76632182372ce42b47e505d7c4238072a9aa80756c1999c228dc55fdcbda880502148808f0948bc4ed1ecfb69c95b7621bb84abb5fed4cc03f849717a6e58d4ab35c6671d3214802f1248e766e791bcece1595aace663403f578eac03343c1cc79714e4a45b7d154ec4cd6ad21b2bf5774f7077918b9a4b4273e05e7b8ffa8aca9690c198bd36f45561b46831cf45348da6b744c06ce8d2103fb58fadff1040335d92c68936674f61a58ae04db2444868e04284c8b0deaf692daad726dac454548da063a4c8a7dea53523a7adcb4fa0aeba53c7bd5e07d20b30a3dcd34d801913e72c643b44464942b13db2011fd69857b3f43d0686c8897f9f24d9d7232e6f705b535d93ef57afcdfbd05cb991a3d5cf39d85b4ec8ed0295e7d954864be5ac69a8b0361707f25b6893348d8b022679c7ea51c64af4f47b597acc054604f5d8ace6cf506b52c1c898d2446b0606f938f16a56d2287ba659c5790bf9787c38ffbd5db7a62f9d16d237a5cec830a305e7f5c8ed93db40660f20cdfa6fb523a22adb02d43272e2bc1087c1cc6c418b9a192a822db968495e0d068034b5a18472ee0c37dfa0458b8158fbcbb39c40471d4a4a4a3910c9f2a40e66f1f710cb27894f7046a19797fdbf3584340a59f2acb7fa355b29a37babbd9553dc2fa7ac4641c6419db97e17bf30230d55e4e7d34ab65a3115319c9042b6ca9c45998f60ef9b257c169e5511f5a1b40ffba078d095d4af84f85c84754d89f9f8065537d9089d5886988c0c833d4d0f82a47f03ad38109249502cce074aa38d7b3e0d252b8ba6a75cd2fcd5de00bbb24d4f91aaeb9a03f1d2e1d92f8093783b78135200ddfcfc44e33c8374fe3602caa4b6cab3a1de560d4593b6b9f495060576a7184ae1c6c0a93df3dbd3736d3eac52f666f59ad9eb7edd8a0eff0b602cc9a00f88d180ea48e21757be62afe5cf5b802d90eed19964c0ca649326c08f4042c7f581ca053ef9036134fc5c57075361323e3c23fb589a8bc96915b92b387e8168ca6bceb1ac5c5c8f4cec7e5a8f1616c1b88baef9c59693bba31871acf7c8f7381c744f9731dd494c4693285f6b7435b0bf84fb533b91f0e74c0c19d9769f796476feb6a9e33b669b4b662ab9747d014a7097a1872e206170db91656a57e5060874521b8ccd710ed1bc453676acb5ef3edb7424cadae6aa24f483a4bd215ab39e738d55bf2f0f684974a77e28d80c06a02b16e69c4004eef4e00966484e3daaeb6a26a9d3b00ee6140fd82f7476258bbc9e5a96776e323411d9223a443872e14debf98118cd0968fcb18dd5a4b1ec8cc10b647a6ca44fe136ef9fa0497fc0882c4d75c7ab02b280cdd9baf80f624c9f0b307c653314c756cef4b8a1977fc7c90c2cf92105435839dfc9ad1877b2bb49631855a96425e763c784b9b5a3aafc06872383e66a8c83085cb8e8804d5c8b37dc5e5303056be5d720f469e0caa35d58371fbc3b197733461d9a7194403b838e542fe6e2859a9950ee7e6061fc9f5753abd9d7cbdefc59a8a2b4a5e72af821deb4f5aa604e72b0ff3010b2a8f222d129a4c7df4e9cba910ac1f56b0d8d15f06019d27e35bc239bb1f188f5eabdf072bb4936c5b1a04e51eef7cb58551c160c16a204098cbef593d2bc92f40f4e67027dc25b0b1918e74ae4d593360a315f222defdf133a51126536266743baefe17cbc6dbb45552c72bb7e11739706455c325f3d381238195e65a1cdd90aaebe1710a1eba2f9023b26662ea9e6798c3545333b73cb1b35434cf266d7db95794722b2899a783569cf768e0984284c864cd7b94d7b057623f356da78772e733773eaadbeb2cabc7c7316e420e4eee06edf8999764d8abe20a4545ea51ac4240a06abf528a9d87c0e16b6a3e2e7e0994b7dfc4aaea5f626a09be45c73a6115e8160fcbe8b4d71b70f5821f38de92e6c6e87c90dfacdae8d7ea387d3f084e1677fd35313460f314b95794187588d98cdc1fd5cd97a44c066ca10354322c329c1d76545b0ab2b27c80a5006834f93fa75b4ecb1dfcb8cdf0a90cef3a32e8690ec855c2d4d390feed208eb447ac78fc4b8a83fbfa6f3a28e3abc7733d75e198b8172e81cb37fddd8cf9e73219d48fa3efc1b043e25bfe458a6eb40b6ed725b77edeaa51586bd7e5bc05ac1bb034337ea4887477095b675cc1fcb256403f4c2e86b4dd1e8fb3905507a6742d0ef6a70b0efa3ee0e2c4ffe5dc52514a9756af2e1460c17497b7472347fcc582d409849884d5633946262908a01b00daeca258d29396d82ec31850023d34a1e441cb8c4fdc97e21f5de8c800c3248ca06500e630233af7ae73ef9425ad7f412a59db78375d2d856e7d8b50e1c5a0e386a689595c4e8d3a2c67cf9d4168695c135094b9df0af822b0b6747289966f6d437e0b69d440f27e274740098c8496b4360e8e420361ee0ef10bfdac9bb36bf005715881661365447704a63f9f23e6ed74d8c72bd87198b07a17357f87244f6c1dc8403f289f3b0acd14db44a1db6454e0bf129f7724fd630b29da1ffcd459a32dc2731dd80f7d33299a3e621c3fe47e7b8d993dbc6a2231fcb28d1640cc80d482d4219c50e9e7f8ae6b98828e6e5f73cc63b9d5885e515bc718168e863829e268e6817e1fcea99d755cca19413719197ffe01bc64ed735e2bb99614e240f4e716c6cad92ecca3dfab89b5b58b2c213057ff449ad66dea891a56db025ccbc7086d057ac9dd9d5b17a3430c13790dbc875cf384c5d3cb0fbe7602557692517571b6c73f28c47016ab19afa65ad1b3a38cb030574a8e35ac34ff304814443dadd9a1980d607d59982e4b034121df14d5761ccf1162c8e0b14ec69e56f0ceab5459869f8b17a3b569e47e502233dc56655fda8f7c7bc31aadefe927af3870976d7feeb791e98a2486d71d40fe640d6cc35277cba06e3425f87aa9b1a729a19d2259051c1cd42faf451561e4aa0204d9984766a8fe82bf24495167b2a57f257a4473ad1d623d0563e48a098334a9873d6eda3a29b192103bcf94a6396985818f80b896ca38f46629d264b860335158104eaa040538006ceadd7a7f39e7230a963c7c99ce683397a99a6dc7a239e9a90f302dc5adf7473c57588abf290e82777587ef3901f912ab33eaa0e13c42d7657a9511ae31673d2c0265a18486b3e536fb49ee71b7d18bdea84534c423a4ba5247336085d77b6167bcc9c390daef8bfc4e56837ad1ba2adce4e63a20118669a98aa0f777e6a7404a1f6eef602875ce53e18b6314818cf216292051d7136d264d35870e6eddef90c6814595a0e0929d780df94766445ffc55389af1686f86c3390f460670534df1a169876ea7c3ed51586465e3210c7f76324d1e079c422ee5442adaf5b10ce6d5e56f6fbf677a1b50adaaeafcdb4f509294aae51be333eb89252606a1bb7e1b1009d909a076988852acaba101607642763fce5120f940623d0a436f80ed2f18b863f72b9f66fdc400eee8adec84ea3d2083d6e42a649e1d7f53d9416750cbedc01e489376246716751ba5d53bd7499c6eebaf1365529b120f6e9e81423c9fc20c87be76e6737afdc70c64f7be26fc5d8ee874d59508fd0b5b9865c06bd6a1060520a9450d075658770af326b4ea2d94406311e2f2bde3a9471f5383d9609c5f03f7344b14bc889aa48607a91dd44720e50e690f712055378ebe50011ffda0fd5731b70df445949dc719d7b6038736ca0a23f5c7b2263584fe4dc1038b5f6f3572d162b4a9e94c281953de9fdf84fbbb10295ff49b3059a06664794ef0101584986cfc18829de811eca6d1f292b1a06adac8edfd843f4d5c23ca4114283fbff6a5726f57982d08d54bd8b0d2b25bea03ea8b826e92d1c36bdd646299d19d6c8a614eb412f081918c63af9c858504085d826b91d06016851538a867c5c19d638b04b054540d4eeddc7704bf79ab458ae171bd44d7aa1bdbfa0812d951dda61611c3529d54c1653d326ee85b8a90ab0a943aae86566ca6a8306b840a27411817e2cdf14d8035c5e9e5f56789e9b186612afc78d819454618f41362d6222764207fe9cec2867f1c718c741b4da2f2b23ced7a1c48a8637a328c23da7e70d52e0eb6f7d80309864315aeddeb1f7eb2068d4b8725fe30a682516efb836ff6a699894b6c4aaf85155ea93427fcb044599dba9a940933c9a0b1f74cdc0372e7f9c1874bbfa6c42a3ed670fbbc0f7c4223a070c04f5e9f73400ac6c42ea7e1737b096aacea045a46ce9b17e90b60bf009d1353c215bdbfb28f7db0e3b5a817aa209961aeaf3fa0e52c9d7b4c92c37fedb4878646cc00edb631541d81cc843c5bc1b864ab36e17572d26b64ab5bd02c212ce7f7dd6628d3ba4e50b88ad01b38be817f63c1a6f7dec8704eec3297cc22a4501c4a06687e030c77672a27ebdbd0b4f7b9f8589b87806b0a5a297607333282481fd44f33e02c94f1289f313b4cd2c062aaf37ea1a4ddb7f1835b2a8e6babc948693e3782eac4f6595e7dee19c66a9183dfb661715a01ebf8ccb6b4c160ab5835e44df4f511aa662b20f6dd326b46661a8fae953a8e6710860ba2639d2ce5f547f80adfbe547d48e9e3e79c8880d3b79d8aabc47cf5278cd26affb98f23d129193b289077fd87718a9263fd45477fae130c4051eae83c059707f1c0c0b9936fab2bec712a62415cf92066147bf5f5fae0ab6a220b581cee9a9df9b2e35833e3942ebc0618f6bdbf675233e24c77933ba6ba4fef3afa7c39e204fc39e168c0256c91cd9698550b9e5c88d1dac5256bc614aacc3f821fb225d4460f0e6521543b3de0841ac1a2e0092a1ef2b191c3d0c049b5cceff5d254b57b59473260598f9a8b674039c66b20a300762196698a8e24c15583226e287d2fa48a4e6d97c4dc532ea5b97f5b16ab6a88e929bc741c919bfb0e9cf2c60df9097bd123e18396621a5af0267671d224f9199311f30874e0427edda0c4c977d610a4cb9524ae414f93fefa079c2bce2e6b959dd0702f6035c93988a8d046f7dce2301b94cad146e74248e149417f56853548b857f1358ce863a4226e776860ae6fef839d108cd38fb4606cf2cedc32c10e3a521f3a2ee8e44876fb57e36bdeb7a7138dfe3ea1b9fb425eacd7be0349a5cb2eb270bc074c506b37b3c3be9f42e002db94a90bbc9f0fd504ebeeb412ff9dad70273b98aeb9f4fa3ecb528840d42458cf6441509b056f0e714a8de622b43cd77bd7c7f4e59282e1da12d538088a8e69dfc8e884ca7eaec1b83122a0e8c3fd2f71a8b2d72f134e2aa2bc28b04b562f7ea9485d8776b35edf012e589c5f63fe0e1998a6bfee09dde9c9a0db69c5c19d46c355f49b1c0096ba77aa73a555c9cb8c91cadea497876aaca864b3c46e988f70ec648450d5701d7a54dd6b2fcfc9f7ef30fa869c8cd41b2c76b577c1ecea668c6b82a834b1a332bd9f8b91e47243cbf725364ced3ca86c5210e288f87ab3da63e681dd4a2285d0b147b85319289c48e9c2f78018cf987cf1b5245e385f42572571852e1cc62de44265f21069ffbecee4e59f4d31c260f0c943f61106cdfb50c7220b449f9725b6ed10aee0e8386726f397673027552db0732db7c6ac4f61d6d37ed83532767a9375232b4713d58405bc135efd1594b7c0f49d8e3299e4e303c9db1933d93d01d0ced79a877c4343874b9b009bffaf1d69cb16e6aff4dcc06f4f16a8d5a8e96447ea51df0cf4cb06194740d82d2017c15efad28d791aba12d1129459aa2934a314cdccd3da441c2a63d8ca8d930a140618e7346db5f8f61d60e33af469b908c7f839d51f5e3bbfcf02e3a4f2fe7cdec51f21378d3308ebfe20650da5d7f85ab87f6bddf64adbbd66a52b9d971241e4c08afcec805453ae6ded9b38731a9b29155aa484de0fcc05beeb5b62780aff1195edabfe1694ad5909dee1255a657050e561edfc72872d67ea6d9ffd552c207c05e950bb76d9f2ae52324278169ba2b577da369a0c560b81198aa9e3d71663daec2ca2786e7ef80a1a3dafcd133e4fad1006afb99e95c5ba01a31e42d0f2f3b9acfc91be679b40b7e823944f5153d432db001b6134c151059d5af7095d929a142df4e08a15e517c1af60c68e2969806166faca9adccae5a716e1bc3e5353c2319bba1c93cb5195166df75d7a9cea3c18d5616a5201fd7e1d265010de69d3cabd94cd8775308fe504835f8b235f2d427b794d4e551d2bd6488f2bc4bb303244a0e453a62e298515e8f1b7bb5ba90a8c8a61b3e944642e8a7a480ae6c4e24c3d0d92544525c46227df4c9b5d574cf2dcd3034c300377fadddd5b759132f7ab7d04ac8fdb9b67d00c08fbb0fe22e8a59607dbf1de3c7adb90f64df1261012489a6bb60cc39a7ce5dab4b5266e75fec6e7862aee12e86376402c8e69e58ae71e64244bc76c4498b6d2d8ca1a3744c4c528586ab102fb2b4b0e6b5497c28c915390c46c25fb7c450799a5b52a7ffcb742e0beaec2537cd1dae86b7c1d118507155c1aae7ee45562a8e53566041b3809c8aae2726810741e0fb3bf0ed8d55d2fbce621a62227b929b0eac5a3e26e46389e4e67d3dab3bd4b0a0aafe17381e351dbbe2ddf4a18c3afe6648954dcc089c76f76a31b4d7328abf2da7cb031045fc1aed9c3ea9464bdf6d2f7f76d940e6f3d998b0ce9f3302029e85dc6090e56d777b3af4fa8e73534210f681cf0fabef92055f1aa0800f2c5547f9f89dcdb7ef607bba968afbff9a0ce9be4cf26be0a3ba50110d04fd57af184d0dcf4e4f0ec1402ab9f0b471ac982d52f6ec09fd23fafa570007552a4d46192a21654bf4de65a193f956334780be22f8f75aa445ae2fd6dc89c00041745c67d0a19c1796a74c436a695091fec932be726498c55edb24a3d91226ce1762b1212dd236319f81e65afa35a84d4bf3845b4c505b493eef292188428bbf717df7a34b6921ed636f16ad0a0cb840b9601039bc005064e92a83dc677c580648b1f878492f10ef8ecbf6e1d5b76cdd22f05ab854e5dec0b08dfd0e2da9e3a7a1bb1750331111d51bef176f265e7db3555edbcb219585a21153be55d74bd382bd3a6b2bcfb978b8f2dcfe01e3b556e484871dee1e9f06cde051d83f78b52db6548fee0d7b5b4ab0b2415d17c58b2418bb712c0e594c12b2988045e941418283f929dbe36ae781387862d63e67cd050a2f6f5c3c42375103f65180da2e37efb73bc005b879edec952e4a3725c6b0da5dbbee510e4eea24aaddbdebc66fed6bf75dac8b6a1de90000b323067e31900f18ebc62a1b7b6cd026e9428c558d5abddf323c0b1874c1601be3a8055665f896a0f89df9a083270ba5ee06ba5ec878fa7145163f3edac4a1fb17d3205da48013cbe6e59128e2223df6fc2b85f5bd97f21d54cc88d7d298ee333b9c504e225a4055084caabd1256c84a85ed34d0f977dc30ea9128b5e13f1e9c2afc83a6d3135bc22457657f888d5309159d4a7e09ab9f181076ef059b9ae585c0d947bd2911392c3c756b0110360a60d7a14d83e6e11d64821eed144e65cdccd8099e954d273164f1a92bdd6c7f0d7aa73bb1d2592d21fb4dbab03a6100474a71851b99ae0b8483342f6dfe4989d6de6a198557ee67ed90043dcda7d72bd9ec4d87a23e390559bfeab2a5372419dfbf2250e96c700e113c17efa13166709ffe9d1142b28ea6e848d12bb6913b698ef54024baec3e47d90115148f351664ad8e0cc389d1053f7af957a5b167cfccbefe256be2380b709ea0eda262e9684d6ef91b3f8975cd3f6b52a5d4c1555cdaa86047c59dec0b9862c9917ba50aa09040a0c2f781cff616633f17598af173f9ec1db8a681b467517fe24a5c3e37b838592d8cf97cfd90279f0cfd726f0273a387fc052f9022c818ef2c24292a7bccd5d0ced2590ca3a771b19ae279d22cafe8f687e9d6097f7e2fe61e331134e1edadbbca514080c4f03b27125ec9a689ddcecf28948062cedc8cf87c3fe6e083b8a4e15ad6bb4318f0ea20f4e408fd09b1d0bb09580feddacc3903d4e60cd1df0a505b0e617c6a46522588871fbd8d427819cbb4b675c084cc8dbe2693b4d72f5d7f1ff4930195751a9a9ecb5700e6c2e59e5c5d6c3ec62bf5a7a3bdff050b485be2205d59f7322665dc786b188449e4d73731525e488e6584353d66576e20b207a8c23ce2e6028942f47a41250d12eb33837c172b23bce27c362325a4ac1521dd0a6fa7a9763ec05becfcd90a4d263a2813569c7aa228110470336dc46eaf3469cf8fb46f72301fd3f13b14db687ab6e60ec42cde216951999b6f202e07f0c6017d104da0ccab7627622b5392f55b87244279b33b12468342ab47f23f03da7f8943d5254def293166075d3ec2b4ae6a6b3379788c45f8a457b55792ab69f545686da58e6de14a07e1cb822f478db516d4316bd4d3a90633e4ab9106f5b5455cfb17abaeb7db8128d488123930c83a315b26c2d607004417d0a206bd6459a24d0d8df368c96dd25b4c4018f57588ffce30dcd1791610fc752499c50df501b65c7f291c1647260d38162a5335f0459c2a4078bc221734b374667d50478815178f939c1f60ded4ef299e5c53a72f633ae71076e93392135faa36592b06c5f572bf03548f4108995c15ebbcaa53b77c4a84a3d8e6989ab47f60e67f22fa0af9a211331171797952c5ac1016192535650524261b55f006e77bc0d27239fd18c3b88088b6184a0167f8c1e3a69ce490bdec0ca8781aceff6f22d1e551950a999549d90fdb5f5f0f85b4f122c13bc5fab8838d684952e3e6544e2120db3cbb32e716b23a96d19e3c3cc2911d1a8aa48bac4fa595de6aa868d171af71294b86279eeffe9698d3bbdaf0031275117aee16d98234879e1272a10849caa2838bac2492f83895bd41be16e6f686d0898169cd5a528b52274b98fb0d19b3b9a21a0e1ac772c41fa1eec8d29f94f37242cf97fe57ac7b69fe5ebc36decc7b1e77e08d06308d56aa3527198c8af50d92ce31abbb832da35cf19fa40ed97f636e8321446f6a793cac91201b958948b909ec7056e8e69b3d4c082054bf6cbeed3193b47474b870c1d31baf155adc4701b2d3f81c9855a689479fb4aeed1ceff09372a064c70616b21fd355583a7ae3217e29de96202b6cd2c280764528b061e1a5b185447f8f32ebfed484571dc214205ac0f891a6fee28364c81d7a6e91634d06004d2a4e6b6830cd1b66be5021a4f721cc15529dbda16170d3d1814e9998d1971565925a220f0c8c32c3db27bbb4777c8dacbb60dbeda95f609c06903745c912bcccbf19260516211449cd6895e869177f97aa5e6436384eb09ce160be464e5ca84ae5982048d1e60817f14672d0ec6947a1a7bb85d852cfd5e2ae76aa84665e1a8915e74282eefd2f4e6d2ac90c7c08871db4e1daff8b23b982a24b302a169fb8a548a8145aae20b385c47eab697144afab27397341c4089bda0edc030cb27e8436e55a1aadcc9a63ed0db7e2221a66adae23dcb8632751a78ae05fe8fbbc6542f4efee3d0210e723580cf04fbf68538877d84095bacfa1307b7949f8d5c2fb8ff9a0230238478a8f176b099063ecb2449654f8c20c4af9ac9e40ceb6c699365d98ffa0d47fe615be4b7b8dafb30b58f96b18d42fc7463a4a85b08cf2f0e1032d5f41f600f843acb90219a076faebf9e33bc35dc9a8bdf1a115ed9ac5868e700e0d415c730783c3e07949c1c3ad9c1407a73e8c7f8edbeeb7abe8bc0ccfc6fd42877124fabfd77c8483d9884fa0ca2af827f6b02e24d9e72a00820802aeb7f3a975f8c2401738f193ca878a6d5698ce4c70064bb78b4154ce9e5113cbc8ba44460de50fbcbfa4a96b6ff1a2efec87fe5b3c6e84e9c449b9aeca74d2b41e487500a8f847b9b12da3f58843456141b481da75aeca5c3ee644aca6b6faf79c4812099f6dd13c40e00b87341c0211f89b2b730b524bca2b5e3ae7f53da58d87052e2521a43d6c4b675cf3d352cf79825f9bf0f385a83ad241c08602327b78fe411c0964f85b1e74ee3783cb912448df5eb1861d8febba9226461588c8a0d7dcabd72efbd993dd1906eb44f634ca7936506f680c7d6da33bdeef7b9b499cd64f2d1eb529b79f7e628864c69433646fb8caf4966a4c44330a909c97cda460a51419bde668988f93eb93eccb9cd2221bb96f9d2c6cd721f8fc102e6b6076da0de5e2d2fe99adaa20a36c3139c9ef05201163c19088201d0ecc74abb6683977257de580b83e16c70ec3e71e60c06691682923fe699430b1818c902cd31aaaa8e8ed68e0cd9fd635e11ff3b25ba627bb79221da61174087974497b68f27ca40a39953e076050b16cc500a13f42504bb33b0ade0af0290866596110f0d366493fe58792b20e0804106a680d509eee49cc4bc28db76ffcf876d2651944a68f4b1e618afe03835e31b2801c4f2f70cedc5e72672c06c28eaf8fd54fc96ed8763370335ba3137afed99fc1eb4e7105bdc9415b6543680c518f19ead9bf0eb1f918d99863d3520d774f3eaba2eebabc7cb0da8fd66da638724d1508bc5a1b3b290812d31eed338fcca1b65bc85bc5d736b7a6112f52b5bece1fcd6bc11908d4b2811ae8dc00457c408816c130b73167f330a4e57c8028be3d4b0fe12d9de2df0d70662f91dc29b1f1e03942af49f104a3d47f2bb9de2e9bb633f003c50b3d91379e7692c03280dba4f5bb4da1f8fe0114dd24ef938a6a42f7f171ad8d38ee05d234bd6cfe3a89e0eabe1fdcef221dd8039d8c07d96371a944ed04cca4f3b4c06f58a38035957c166bd8e4adb1b4bf9a5cd890ee89db90800584bac7163d764171f1f57a33360d7dbf1fe08d9715c75fa43c771105a6eeff965a459aa6fc7352cc45a11446ea21e4630a719bc6ed5b0fc9a6bc577b96d1f78b087c4a6a671a8285b0912066718cfb7ab14d17a8b6017cb1d9a12d6cc61c6e1bd874fbeed549083bce305a4fb2c57550a376fa32db1bbe3287afa93bc0f6d9921bea4e0dedd7cf2c0ea6b61c0ae9e58899a9f60ac28cc3b48f20f57ff2db456c14305178858592b452dca10475fdde62114b3bca0abed2e72a4ce88b133a754927bc28da3ab7a1fe1e7a4a8ffeb8343ee7187a770b9c5b0b5cc6da2fb5e17efadcb27f31cf8a5ffd7a22df3d5c94e3118bfef6ecfb6184020125d909e9efb7c9ac23ef8338a3514b9d6cb1d3ec842a8c94b6228e9ed1d867006cd4c03e6bd765db8330717921fb6445778b119bfdc4c207858bf0e452154a6dc16a161f36ab3f4410a3dacb406f3d9385648430da65ee72cf7bcb708f9e9301733ee96f60659a8c9b31fae195de6ce0206035b4aa105f841f56055e2b898302dfd618d1c3ef74c3b7dcfc9fe7dd","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
