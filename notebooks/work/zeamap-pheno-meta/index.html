<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42cbecb2b156a9b2159e932e51ae6ea63236fe3a5b6a0ebadda9bd52e718665666ea68bd5e4a02103e2dcfd40bf09bea6f68ddf484035b30a933a0d9a091ee3ac706f370de72cb69cdb226998c96b0f9dad5ab226fbc9659c387279cd27343057e242e5664a065845488d5241bffb15d899203585de81731a83bc6c5098e8e4a8d3c41f53e9bdd7b7472b0c656ef13bfa7ef880593f9d9aa384f4aa97c72ce9b34e03e0266f06f10672ec27dca39cf43f85cf4bae00fe4b6825b82ecbb3fa428699490c0a4144992787a6afaeab971738e5ca4587a8b26bf8d5ff387bb551beddbcaa00bc4fe998c8b6b838f8466a6dd2c55a7a75aa892a2c105da4ef844b8db73d5783bb47aea115a6483172ac00abdb26d2e4a6dfa8ed50bf0baf8b1f181093352d2984913aee7a77ee64f2830a2f9f80a63093ea2c698023ce2692817bdf6d230de51653e389ec7dd6ed4879b411b3f6b6f911dac1606e420aedbc36d064d701ca273e0e1fc0b6ab8d9351fb5a0cf4a16968e176d364b80f4514eea7545dceb1290a1b6723f79e8facf8e26c1644674db43812cf25f605ace63bc09a500cf96eb780b679b60cfa438915cdf7163905763ef7114620979a8b586b8ece1c6a768fa3903b4043038e6d86c805284b0bc9fbe608498db4e79825c6d77582d4701f5dc68ae205d95275c772e9d09e70335e84f1930619f9d325c6e2418d101f4987c269d65901c54765e5adf73c20e93798e6c1422cb26bae15fd993a244b81cffe50c9a83eeb008515522dc4f55ca52ac9dcc9c4f62b04730f8cdf2ca05325b5195900f2e910812c5cc90e3406346c8ead0af745d931885474dee0babda11258d6561e34697362185922fab8c047ff1cc7418753e613d77bde9948ae4ee8030659214b93ef880a2dae2eadb18d82f8fed3d1a5f1eb451ea029706df0f4e97f262c1978a290b25a65144948a317cd5a7750b1d936cc45f49c564905052372cdde298c4acbeae4e34361537b51be93b70a6ddd261e9dda7f1bc46b5b7a87a4b6ee74e056b5916b01496ab0d955a323a005ac82dc06000214057f57333cbe5002e0b65d68398a370b4e46d26d7eac1975be1ff80bad6581b8de996683a13fea7e970a0577615166386d58e56765e71f71555aec3f43bb8b82882e2928231015026682891329843aaa78ea3490d1ad3444f3b6aea17aeb3be00e98c34f4ba8d5bc730db1e6cb3b8b776853a4f220f160e9165e6952826d3de0bac7eb5211a10ec5efc6133d8242c473c614b2018df07df26496ece226be60145c8965918d14dd2213d7ea5addc80fea788709f5c009be62d5bc140a39cd367dae13f124a59be132dbc7d857b9a9133283c3776de41ffdd11ec61b493b2e9c7eddaa00b0846312b80901802e6aa76f0b1b0843c886ca28253a060a822f2867aa0e4897c855c6a4793a681f5509ff18fe7dfd6f29306e66c8a1fc3a12d5b419e4db225969db6187d22ee9441db9057bccdb05ee2c0c4a726b1c81eae84387eedfab1a14cd6f67e0cd984ff65b7c60f0392c03ee41f53c0df4534e248220c686c5012922fd80a742af624835deb98834d499a12928355bd258f59716acbde53680bc0b9d5f5568ea55aafffd87877617ec8888b16b7b67bc5edb18ec44bfdfcfa4be542cc114e8332aba0034f473cdc53f68eac580ead0dd5ca13749e96de6d601101a9c9a1a8ecce0a4a147a1fccde6fbc95e18c2febb34ec5435a62c3f1c3a87c3553c08b76a64b7206cac93648fac42d287ff836b3d9b7af3a3064653eded6236a439fd513319d5858f8bd5056165e65ce1ac4eb1fb53cc017b26087c14c73347de799ecda4e71686902b28bdff14574444a4fdf288d0ec32b415212459a19148c58c1a97ab6ebcb41335379cf0ba0271a2d020aef5c0a2d333372f60b08b848c796712b7c4ca2f21839c8da302cfd996b1f708d39cd717e86dcbc917babd9db1eb0db4cc0b0ac286a092a1eb91497d313b89d4cadc178f9646bb600214da2468bc1deb207231be6444ae0ec7e94de90b012fcd3b3d915e280d31c379553c7d57bf794862820d85fbcd7279e2cf7831765c99ec1e2a28eadcd2811cdb87a4cb272db9cdf513aebcb37a772e2b98987009e1e3e7ad7ef8aa183b10becbb9eedb12cac3a4577e5c7454e3067fc18ee32e33243ab4d961ce8925369a6530ade3b58b9300454e5b76ecfbd8cc4277d658aa4b44834327f588bfc3b978a47d3bf13ee8b94f4dd1f7f2e4808a67bd5b119b3093b2fe0d50e5087d7376ecfc50b04d720124209d3dba21d4cb709d06574cb38c39cb062dbb766d9506423556862af76cf698e593eae4fbbf0d62c240d97cf4fef97658370cca7a3a3ced80d3cf2d5124c74ea3516d1c27c7210fb06d0baeb0824f511c6301d38778671d7329e1488b7d6fc517686be3d0c81d67529187e6c6fa921bd821c29a783e3e76e6766d5b9eba179806376d3720d6ca03aff6b7b690b364a89c6fb1b17697bba2a5852c1691f2e32e56a7fcf5117b1b2f8c2e3bcfeb7ec4a485a4edb71fb8f5e6b06bbb53fb126fc9292724f907be36fc0c7a9512e19197d00460075eba1fb5f5c9b1e47f972090348181acb4572637d14068d49e2aa7a093fb2d023831d4adf7a1cfd30379f679de97dbecd3306e6854b71eb0269c0b0a5e4abc2e9121ed997548a5f9ef4aca759cf91822cdbe188ca390a821e4bcb124218c2a568ca53eeebf2857c8fa84f91909713a66cd25e66e4044990de035ac6529a38e21052923c9d05eb540cc9fbf89f65906c3f09aecb1e05c1724207b61f370a6702115e985be1518cd45ec90abe141b2b88bfcb6584cdb066ecbebc18eea7dfe79143697484b3ad4983695d8aaf4e89394497a29e5696b27ec83c4394a34a9dc77986904c2624ec0e8361e33a2f600ae5ec63d868b905e6889d0b0864c7789012293ddc9fd719e44110582c0990e024cdf9a39d1a4c39d48de43b5bb164be95ce9eca2957619c0d5ca41c2c018af0955753e290183a887dced81e4b697db73b7ee77ca52ac922547918bf7a6b433fba32bd4d6eb4b067e9b19c84ff55128e1944091826ace59c4995f31127a4a1d9c1a11b52b3e031204db301fb6c1cad6380f11d59b5acae8ada2d57810d3a704fc4074f1d17ee14181c64bd07369d5a24e89d091208f8f1c1b63bc17d4dc6a03a53967fb73bd7147b365df1312dda257e8393286df1ce481d8779c0bac817a03f3845a1d68e4c0c9db4cd0dc749eaa8555b280da6d5c64bbc7d590eb64c56a1e163a2bd255e9dd2927b2d6f93572d46f6ed04296a58bb8e8ea94c1f0d6675b6b903e04e8d7bf80b4bfa3927b850e6acc6e284c68a13e497f221f10ca42920e7237ea5072ad0f502b79ccd84a3f2454d46922801c25238d774664395dd873ef8e834ac0523a4533d53a7dad79a19c7df607d7073b130b28cbadf4e77a0d1add61a9b20a44980caa07ca1af90f8c5e1b1e359038253a9b51ac41f5666e13cdeaeca2a34709fc144229a7e198a50590d0899dd9036112c7aa754c8d9a7fae786fa8d8123d4b70d05107979a525eeb6c46536ac5ed596a0af04424d1104fafb12e5d9ce0849e8e0d8e30e9e3b8186b57105ce9cb433aade9a95f47e62996d84a7814ced6e3a0c3187815de9ac345030ee7bf509be8977b965d30c42ec05925e6519d3cb453d5fb11bf1c75c0362ef37f012dc01ae4c9844fb23043ef153db9054e3a82090a72844974974f15d8a0cb798021a650340d141173449d4027cfdb06618bb9cf7baf685ee5d5f6957eff842186fcf4593a13cd36770a42244a99f655e8766efef4b24ebf76769f151578071a25ba4ebf32facbf3cc045502dfb55ed98b1551be8db5bdac0deb253a663eac60c60d4adaa7505571d6b125b72cdf4d9bf1fa603fb74bd3586e2570b1758f0fa654986a489e439be77c8ebf134434be4595421a76c909e873490602d423749139c49729d8877c50923034af148a419aab522ab5672ba7d478e1c5bc6789e4b1d46cc175135c12d8c732adeb008c57016e414a690325f821b80d3f42cf6d927305172f9e0e860b88847128e09d8137e8bb6955be76110fd5dca1d3d034de80838e71f9eb8e3e68e4ef20771f1f6dc4b4535614cbd70b80d79cc4a994ca583c591417369e6671354ea496c8cb223079a9cb410de8fdd09b5d8819112e10a113754ec67b561f46f53d5fffa5bec884285ef93adbfefbd164cd103cb8f3c8fdd83c0c3e10c58d1dc5f481773a1307373839f67a3170b4d16353163087692a76a3ce6e24880852a8f91cd91843e773ecbf47bcc96f75f37adfea2e8c18d82adbf221d5b9fd3b4d274c9a1dd16b781fd23d548cac6935acb7b41a7ec04293080148af576f683b2c82b149b424182f18ee59ded296be5916bc3f93e2cc000976d4540bfd1977f96feca3f34bae7e4f4cee0fa53ca6a7517f068d3e795ca9381c85d9132742fb0fea41625071ac0a8627e74b0f21144329e3827da4b67c14d10396c41acbc3426325bfdb36632763f435832503effbaffd9238eb3fe3fa091a178addbf07a9e04f4bf0616b2f8ebb97d8136a38766b662c67bc2852f396003c200b45efac7b5699b3511ee7409be40b46a8161b24ad2878c0ed2b9c6a87c97a89906627cba42ce44062968a18817d317ca477ab76ec2b148f32ee31fb4b41eef20d66a4c17b77fda1378823d169cda220119f33ba83410d23a4f8200399be0882025238ad259bccec4d6935d83b02cf7693b4ac5661c995429ff18a753660278b437f7a54a5521b0928ed23c04c4be90ccc89ead3a31055ada1b4a15171f03b6fdfbcd5235a7d9d5482b746e97ece834bd95fce2c68b4b70af7415196f2207f3b748cdcecc5aec596f7026c7fec2a73d4688cc1f526c627410473174dca1afb0a8c940c86a48bd014a5ec7bff4c5ad025eec7ffdc57f5a8dd86f695babce148725c5e06a2391c42e826b9bcb06ff5a27cfe46e131411fc7d8569e381be71a5eceb44c6cc43cf32571eb65b841b560adcab7d8c685a918c19c95e6acd03f2f5f77c4706798f5563029476d1f86bef4ddb9e5686eaf09b8b46a8aba4bdea9e7b6381a0ee8ee4e9e3a8bf75443c57fb5a688c890bf9e21fcf216f058e6296249c26d06d7971f6f89acdcf6bbc9ceafeee498e0c9d7cbfe919278d9c12e12ef731647cbbc18c37268e86d630460bb8eb3d90104627fbfc26a54ba5d4332b28e537933bf3827bc92751873cbc7adb4e6787afdfff1c3892115f46c505407dbf3adec7b5b14503059a2c68fd50b7a8a3284f171e890266eb88e2088fabe55ede2b23e3d76452c5d0552df990958895d23139ecb1ae5a48028e108156c48c62b75dbbb086f9bc601ea330b00c29f5df88e2a72da25d7f06a169f01b07cf871c945a5c5a751d310fd510369946ffafae4968e6ab78fa21b0c868ef115ed77dd8e6e491c2c28ff35577595fb4abe3e76a82b23f30209d68abbddb4abfac9e97c9b644ec82b6deb81bed664e242e1cde91428b3120a7bf20cd1778d5bafbb7dba04a71996a68b0cbb449de8a17cdcc07931d213af67bb41a69f921ef68933270135f2e2126b5f616242f8a74b9d3fef9251ac223f0083c076b7d59e7866a7c948f959a923a6f4606766068eb09bc49ed68714aafb56d4f9af138b2e6e1b0b9fd8b4673f39ff093dbd80e4986f97b142dcb35fd5498f21674a085c57ca745b974235c654720ab8a7782c800fdbe85e13b2941a6d19041be4237f9000da32a1cfa9939f829d287b5cb4e0dcaeae0cae0668b78e13a098432d30489ba6f8da63037717fb2346ea627246ed5a6d31ecad7ea9575377ad1c7304d8d86c31985d5a23025379c659f84fd7d1deeaddd97946541c99b677727057210aac4ca02bdf2c4c34dc598f8942ab7c0d99b0f12e2a6fb862366db8d8acb832799216e2929e9db4f9541b389f58d036931d9a45b1d9220a67857c42a88132cf812d115ca5ec7cb0436d7ab91a7139c9d0779c7204c3c143033e1fe8623259e31e4dddf2376c150fde05015e5757b55448d719a775c427a32d115180559360ed97d0a8e23113c9764a8a99e01e29a0bfe5a9c6bfe02986a6a3d14cd07639609adfcdfdfa1bf486f4358163c9e013bf09d295842b22e828898fe940c47bd4beee3f8f68625f2bc592a6bebe56d96a8d513cc1c5db4e1e1808bffbb036f5dbc6745d9252040e248be5b62176d2d75b6e661b2a34df72de62e3f4fa9dd3122cba0697b2b33a401bdd934a63560e58dc4a11a6f7e2a2b7e95b66b0712c23589446f31a9782a5f73b9f55096ae1bd284c19d3c4f4c36db657ec4d2c9bff82aaf39189c997f20d808135d365586bfa96e4c0b0fdc9b71eaefa67d461ddbbf63270a1d04031bc9e9a611293454616eae2cf5107076d995b9d3bc6190dd1431f97e3e1d22d8283b591bab447071bc9cb6a68ef21fd99cb923660296cefec0aa273b2d811ae2a5db1bec4012963b1ee87b2e9be5f58e6099fb563dc5f3b6372a98e55bf16f0c8bfb5a0ecda926b0f8a8777b55740a8103f318a05d1b636bbaa73b7e991e3b28d10cac9d0b968a622e5752156e2dd1172c5b06d9087bfa260d8adfce902e0d79e1437650bbfb12e09629dad79bdc20e112ba3c6bb9ef01b4353d09681a6e4456a9f02b3c2bc9ed5e1817df0c64796e7f8d2bac0b148b8af66161d5bbc19facc12e43047484acfb27eb1f4c9e390caaf8318cb7dc92e57d22ba97b3e0244fcb249146c1c85f5166ae91c2f3fc4320001ab90ae9df1a1f1dd7039c65349830e83f4ac8cd485dcee3ad5a8271ab7da841ba53edd922fd0281d36849349f147c15fcc8d779695ed10850a4fb1047ee49eeb206b24948161d527b85a0820fda8ea2fac082151d75e1d30feee70cfb8ba3b835e5ab653683100e570c82c3e5f7f22820db4148b5bee1f39cc1c9d2414b4414d7357e20359ade40ca54f3cf7d367a0848538a2b5100b83b4dbf76b5c8e67f2f3ae2239bd9b31f3f4fb708b8a0457ba833fdb24269fa74b28a5247b0f15357997d70be9f2c7f17ebaead93f9490fb1dad7d34511105f997111202b76d7324015681699ca17516249bee3cb898488441835e869f96bc9a9c6fd2a8d8fb3c43f53b48777246b759e149c9ae02eee743339564ed07f95b252736e2a9f376f8e6ef1e65f77ea0e6b8d0bfc163b59eeb79c5aec98952fb43c67c6aec450febe78a5f07d4459514f52955f39b076d5393cc1f652bd9624c119746bebe681ff4bdc74ba84bb56a8e0b3dede4754e8699b18408127163ecfbec02c439683ab8eedea90c2e5a7259ca421fa61cb034dff0b1a1b96d285f315d4707b463fff2705ad0a1aef36fc52eb662399ebd0a39f9f4c5534d1e94a5f7ce31df4d790f32077808502036187382348abf2ddef3a2430677368a1a8338a4dfca99ba73197d4f483fd77c6b72b9af593cc24919eb5e3b24bb751748d405925ace57e95a88dce1669eb69965f12c8be473846ebe765afc80df2aaeed2b7a48a88ff668c46b886c641f2f9d9ad9ff3140d15bdaab894db37b8f6c90d7f1d06c47012af8638823822f1b10fe3c0c53be746f9283019d4f229193d06191b81d95cab8e3aeedd33f7525c4d7b83dde1a42746ec67b74154f99574980c03e0b335d0ff2e23705c924ed70a7b0a05f55573c498202651ee94c0c68359f5b4bcf398865deafc89dfc8362e172604c8cfc82f463e4eaa9a4e98377de0ce8570c4c990bd92a8ad1e44512f5a8bda939ecd4ef0487f013ca208ed130fcea4ba5d2e8666feedd7deb24c29e0b1d819ac40a814010dbd21071d75cd40150982810ecfea3a53b2ab447d0d1d74eb05d4337164ece5f0fbcf11ac9329a25d0bdc0e55a685342a6990a8f6a8ce06d1bf6b994000adf185ed54b63c72af9fcc4712c604aa3587f30c8dae91637e6fa2ca7b787848e8a6bc50cb2078b622259eccb4a90bc349271f8e52dda74ba57b6617166bf94c7cdc6b51970529d50c9a5b03758d4e66958c2d079fe60e84a08b160f5a5967b53eac352c72961b0a38a2ca6abe4553928a2edde141e93896638de632b87676f3efb526bce9922e694c780e8f76748d9fd2eab9a529b9311a99900723bf0ad915ab7022ae71acc0773166a86b1b541480491b3dd7b60cb0cda89ed988f80d84eec987fed24c364632480cce63ff0e480a9de521eb9bccc86477c02f2ae082ba26ef4e83edc7c1334e7cb54cd280c69b6e1b47a4d64ca09df03bcc1e01c0af1c3f0ffb92f1c3e264065d4d0c799f18cc6bc1dc11ac1b9e9e0c622219042443dc24fd9582a590c249def0d9afea0f595953ae2834f1bace762f018fc37c9dfd4832c31796204f68e732dc159a9125eedb03186ba1bea26fc8ed821f61a3748e3e89012e76adf0b99296cc75d704245df18c658e59aae58623a3639649c75f3da651958f0465df82fcf6832851df787737d7b0c860c14f882ddb41ec300f7a04d20e3e1ca5f5c53406a66a5eab3eb789eabcf1e1b42874d915dd5df62b96b48d506d5828903401f20d6908faab54d7fe8547cb5238a5c4cb9e9b8b9be899975efce9fa4fc129f6889ff2890b145432934d93d02f473f4c0cc6a690f044f428a5bc187b021774ae342be482b8e1dda3ef2a11b70b500e4750b2f342d9ce18dc16d8ccf4fb66b47e8dcdba796c3030774f5fb541baf284adc92d6cbeab4790cc55b5f1308eb03c9b445bc43bf8feeeb37f9cfbafb0095d002c652055d78b5ce5fe0a8840543334cfef57a08ee5625094d7cb6aac02ced77c55fb72f51332ae06f5aa5673d5cd2e063b99c4b58f50996da7c4020139515507f6023f47a1596226ae204b046a6b9918ba99791bee0abf079590dc3b64b12417690d6c9fbc5c73c274223b8853f526dd1ed884fa6a020366b49704254fcff88c3403ec41ee6156c57cdbbb8886d52d671b2c4b8807165f9b86210c981388bac07095e2d4cc3cfc91941f397ec43301e809ee98b061ac586a2a7074a5c6807a7432dcbc3e6b5cab52f3a2d810a1f858de9618a810a30e219d70caa155641d5753bf669b305bb757e4d026cdd322b08c9433e1dcc9f8c2b5a7ab5e589f816233095568adc239c25aab82c56380aa244303eb42df948c433079590be7c2d577e6587fecde55b35489aa04d767b1b85d6487632126a9fef7831aaa5719247e977d9bead9bda78d20508e93a6461d9d28000247b6695463a487cc75f55da949b681a9725783994274052342645afe230c3c72d16ff084b6c4225d1db303715754cd404b34363c589f31119c0dedee13c9ebf649b5a646ac54c6a8879111a5175ada431c9d0d002263db8c92f75add5a61a49b76fcb141370851b3a2f720cbbfa9100ec318cca79fd98c17c4f95c6758554756ea2c34d514b0131baef5a381a96f3730320af774360d466c4c52bf95a2f0c03e16937a46575b67376b8f11258014e31caf81c0a5181261c4c9e703e2d159d8fbe404378fb0bb3f4171518db4497fd6cc8406abde36b0d3b3d162cbdb06b9042f386f3e3aebd952c91ae1f71be42c01f0fb4626164bb9de02c21624583316f9a7059e83f39ca98e303fddd7ec5564dd33fc357bfdbe83d7f9f80bd4c891f030495bbaba74d8a8d59da51b608882eaac7c57f1d29a67038e7d52a7307a2f0a266b7d957d7d7302a850b097840180c82eb46378ed7ef12cdffc19c5806a4f0392b712d2ab72b538727a71936bc74036d56b02966c31a7ca49d6ae7319c73a1bd9d65195e399b50e770550136bef22d49fe623a0aa1045ace71c745cb494c9ac6e33a9cbad5989577253c19c15e69b476e10e57d7559e5dfb4faa02980c97b77dd2340648bade6de8ef34cea7e3033f50cc40435643176e4e635e7c8b61b1ffe40023a0aad9d037f3c85958761e04e8281d897b3667c036937a75dd6330fd7955849e5cdd3f6f979c9b93af6c8d556503c7ddd14869d693c321836b6b44cbba3e9a303b11371cee6401aaf2f1041f3c924c6f5adb527e5b6e503a34a3275eba23834c1698a95d18028d0ad37a6dc02ccef9f307e72778e303df8381b04912d6cb4c87ac5bfaf4429e09760bfaaceabe4dd7e167750902deec32c02162675b45c80abbb32e22f5ef0ee42e2f580f6bfb74fa08a0a725752bd0956360b9b245972d4308b4e221e58d4c476f0395ee142234c503e17420d92c5f579f35af24052c0851fb2aa47ad97eaf09c6b804514b009101dab40968f0bb1e32c5aac3a50dfd111825e6aa0cf1791dc810fa041faa0e8324c1e7d34b2ce1185b6fa6319e680df486f3008a385a201d7e7b9d3dd61bc2e3ab9a6d952750941f5218623e33f4a31650cc9ca62f999575d5c8ac678f47f346895ac8a47f5eb2cb6877d5dfbefe7a7ec1a1d27260e9fb3f50a3e86794c1f0cfc0962ed39d30fc6b6f1579da63ff71c99cbefc634993c18b2ed4f44a70f637a581669a573f5bbd66b328b014ddbe80bc65cf8a9dd66ca30b77eec2ba6888aafe6a37d08bc7bb608ed2de3478b8fc3fc17d3a2b8a94c7dab710931c6da61781afd4c082d68b424780548a03af3124ebca87d3bfc564cc5bcda16841580687acb1512e9490071a0f03b311da59d018b94c49b41d2d0a96c4f61e2c7240903334e385b3e2a93b19a3360be615132dcd4b11a528c0bc1908828f4ccba2df63a5036ad4f2e2877ea1645999eb1727104236ec1acdaff6b6b07c065bd52b880f09b4ad483bdcd49b6557efb4889265fccaeb50dab9c94f47cdd870236677910499eba49d3d41e621a35fabf1d4b32c766abe6989b34df6b2c741e71b16be1d1dbcac89f3107f82751ed1bdf0909ad3bf7fdb174c4b14044c4ee26ac36e06cdece099d8b0510e480aff5105d54af737e918b9c00105764de732d7cd8f94e0b62155795546969444223f30ab1e36e9280ee1ef7b9c58038d564b2e09e2172b16cf10957b8faf28809e60d0428e9e1ad8afb8d697ae1e565e3e4a053aff5ea50322abf75e7bbff71f90a254b5e3a96d10340ed282f90b7cc63656b467eb0140d4d24bb0e75abd528f4ed12831418db086b466bdb56d915983b3ab0f573a91a2fc90f9efe2bdd7450c191f581ec53fbf95ac5011e0050baa995da3716680407833c13c23afdedf73fad43e2b0df00fffe5080f175fd8f4b7007884e1d034e320854d8b6a1b2639919c2df18ae762ca2c7d67093d62772aa9b8f0b6afa7cfc94b9b7d6e133ead86256fe2d1ee195b244cc9d8470bad4c9204e7312cd80dc27c31dec2c68d61ab70cb5cecfce9d8c3e0c35052efc6600a70c8da44c22a8533d1473fa23028582ce663fed21bc470afcc1a7c918a40824a763c1f39a242db7234f3d55a66b1a0cb48694ed5c63248da42ba975f8acd1eada1d3d57815dc0794f228a5cd6cb89804b5dc15045e8b0e0a9e8cf04ba1546fbbd6a813d70fa8a7c9a3fbce807f1bbb0372d3e1651114d4d62f4ca01e28bfdb8f1c63a7e8848bfab78c522c008f506953d6e376efbe225a373c9e491fd4d94538126f74d7f2addb254712bb8132e888689e77605806e5d5c15beb82781eadc006dcca44b0e81e90d060a91f3d1321c9f69c60efcfa055023c89804495b329f099e42d45a178cc2ca90f710b8ca4dd9b197e8ad79a74946139679c2c07b0f362cbdb4effd45196a2bca07f7a8f90a20b8d499bbd2a2f8ef165bbe22de1f9cf36c1232bf873897c5cf19d3da65fe1e12042b7daea1029079ebe24c99d2041790ff5b0d1082b415089156ab663006a029240b53d897bba89c713fa5d252720774e74935b824955d3f15bc3a28e594052246b50b9fb18fb6b0146085eb60b0eec98e2023738c96d2711914562fe9533f2980b21c6d5dfb0490c571e757dfec0d4f0723d1512e835c8b98ad95f4c99642f66c68a45b3b602b4084395ce273082beac191dec3a9e5eaf1fd1db008a2014ef10389a7e79f37f1298eb47868b7d808e96f72261497f608aced425426aca6d368480ae36aab23872cd4bd5bb0bcf8b428c80c90a7b1b71bf9c2b74ec9c0db07461a37357fec323d6006a595e1e4ced3cdc45a2c6823bf9ae523b887af00925326daf9a051923dfe0c149743a83c8ad39baf354920ff6c9d325b514ace8b06c162bee521f0a1974b082dcdb9c281f12ace4c626224789609c529cbf91505e117d24ed3a70c9256dabe27aab27886470a76de81deec2577f4cba238f063116a559dd9f1c24d3a602f0ef1e12934750fc9f2a5312b105f617423dfe1d3fa42c09bba844e328bd33c7e3828468f3aac5a98728ee20e518c7d59e6ffdf4e7d45030d7ad2298459bde307c72173d9571a744e05db668a0e90c5906ae809442b2551d17ccbe97b2e0627c880a09d297eec76650e626930631fd49806f74fc29ed4fb4895d60917df0c1347a5d4b85a90cf790e0d82e4a04485dfc74d8efdcf28edb7a31c97f84c52a266036e180242b4c0d2435e03c12d76000738707ee05d5d7c6a784c2b9006c09096da9cee3abb7386f48c1cf1cbfe15d7adda74aaaaa63605173dfd071f51207d43c242ce56633bdfb6b29d6a85dc256fcea90c6ca9ceee0c55d821a513eede75bf75cfff3948cc60397787acf79ece56387d7d1caa7c7ad90d24b57966c23a455487a061f92c5c39587c20a92869f5e318a1df3a0d4ca9b653616591700c00b52fb6294b6fdac9cf0ec9915df0b3280d37d4a6a3a4fd2ace2737b68c19952836945dc59d0b50861b1a1ba8de30617b182b5140a9c6771fc8af637bf53efbe04c9995358ebfe3bee8ab0eeef106dc16dce79be0932665a4a675e8cdb780d3335519c804c9a7853734e05b6378fa43382710bb66a135eb786e3d540446fb297e57e0a63011880172a0e1f06c68d876db3a36a7a66a198c4a2a601550b1a3b611e5248551ebe787b6c500b4e873d19ee5b191a8e7e50010ec93a41129a3987f3689e9974361fe344baaa730f09c16b52209dd1518556d5f9f951f3d55f55fe27394592ad43b71e6219adddd8c3ad050c82dc330a6319bd074576a2be31b5d8ab774833fab27c1536a750f92e2ad5ccfa1fec9ffaa2a3746f3cb55486cee400f857346eeea619eedea9cf0fa64fdcb4fc59f8ae3adfc857246b38b41152680ad0c990e7d05afb933bcc38af951c23f803061b657f8d46fb14ff290ec21e0cd1626d8494d650b339a7d0e86abf373233f5af238aca656ddd6161408b696ce4cc2a2b83258bcf9018f5ed9328c92f27108e79854eb84658289105bef3785859e12bb9d52e2c9ff28c73051493d523118db8ce1a6a2e9f8a0e6b3b063cf1583b8273cbe50a9c92535d50a55a6f85a7cdc2d138d22f7713621833fe22b8b95dfdbcd55d7de7be1fe4299442c91156608e915154efddb86e0a5c95dca7e03781dedcaf111ecb8be59a337d4df0dfef45d9c94de4ab4a17b569372a501a0b5f606a61be8713343129b58b9330b8a43e9d170506c6be5ec149eaf61a58cf41ca9120760362364c33334e33e76d18721a760c3b2ef99ec64c33b465dc8ecd4087b2adb88b6583b90fdae72246713edea4e933f7c2db852fcc94c267463a05895114ebcd6319fb9757cb1ebadc4990afe4ff1ea5219a2fdaab51277dc639e4b62fa681fa98fdef93c94c2f5f71890f05ce0db5575c13397c7bddb4d2e877853187755b57daa97f0002633dbd5d97ae8a41d0e4960da4f4f83cb15d7869e2685ac7716cf31f5e154ff68df4275a0a15069c6d091548cbf1b7097d067805d9d43230b653c1737632b383e8b7d5b5abb24e01e38720f80bf93145becf5f20dd078cc86daff3ed113bb1fe0e991229975bc98d44516b7698dfb2467a0ff37b79fd9cd501c469ffca3f7aa6583ca1c177a64a4f8a9ec876b2d7e5a6036658e8f4984cfaf9ea14188c8116afbcdff5011717993db218c9cb6dfc0319d3f82d6c7b496a10caa5abec7ef4a4916ad920dff02e1aa02a19169c6214030beeeaf4fbc2020fff970bf33bc8590ff9a8f0ff9479f1eb2bddc181e373d7f83479c06d72b84cfcafb858e3b9980da4ab6339c86835e286522abd58118fc4bc0e6641ee9c7c3ff2ca906f88041d8d80ce5cc81c57f736d0e52d89146a5c7b05ff77e6124a442009c639470976b6e57abf61eef52bb9863c0d78b3e548feeb3d4c4cdcc7ea9b0f698a001ab5844159730de1ffca0c3cd3dcf3faeb6e9b321efeb5c56a67b69cb641c451301f900f6e5f8838fed6e9c4f9ee49568152183ab0bb5c97cb50393f2f5f67056466151302eab22ca9ddd6fd87d29d8abfdf62b8ea92d5a2a7f116116f388a1021a2b89f20be34e53622ebc63f1f0faef5535fbdf781e94452ddd7ca38974245b0e291f6181da1f868873b726af510afd8941213671846fec4e8a67abe0df0b615449fac5fe5b7e6cab98092d2fc3ecc0f8dfbb71723a6c1ffd0927e226a1617ee96503dd9ac3540d14dee4bef0f70c4928b59936a3429430b51d5f0e257aa5c3eea8c823eec4cbf9313ca2282ed94eb61e24b3de45e8c6922e64bbdcddeb2743570bbcd12565b98427d642e7f76166024aec4b1c2f971786a0626065f651e337bbfab6dff825c9826f61210971bb3dbb1a9df779e526ca6f6dd71e96f9455e0d5ffdf30f1f98d030e83e88aeee50ef286b905a3247e980d6534e497e2b2c1c0b8d58fed95b5fa4003ed0b14602ce174e9d814876fc77a39d5cf43f9fd8b25c7628b7f55ab98d1ad4b226c548179c4bf483112814a79d3bd9d551be36d1edac86a3b6e4b21527b1a7ef5b3560d086757995346adc0166e124e72eb38a45625e14fa11dd78eeec4cfb3b1b0d52708e1a2f2b98d348c702e5ef1b3388ce80e2a7bd1d43b81bbea4d5f7659bb24ed21e31c78eec6544b7ac2ace1d7ab5f5158a0bddebefc2ee01ee25b48b8caf2cf1665243038ed4fa65f7c3c3f8181cb04ae04cd43c0cd1ae4a3c1480ade553b04f7da660bf4ce7f26bb1acc2db45d9daac9f200145ee9e14bccabfed067820384b761ac4eb35cfe8de59ec39d1f62535d4aa60594714d0b39d66d7b3c683239fa3494bd322967b2078891abcc3c7ae30dde1b4afddf57087001df562204563311db2f68447a2f5c4e3c89bbeb3167068a590ab6da50372903f48c3b2824396a5a82f1ccf7ec4ce1dd2a2925b2bcc93505dd3f99fa5fc7a65b5134bc532db4edfb7d56a6c49a9d8ce796692f942414bff9879b57abf4cf29e4af16fe68d53e90469e1c757636efc5970ef72399c54ad0aa5b86c3a00061d875e21451ca5266b3eff60c5c4a6d0f1f67b0b8b296f78e7a3f7f2ac1358435226e4133838108e10d40853c9cb0330f414c39d5b14bb08f9d795472c8b91423306d9bbf5567d4fa7c40cc608b22c9d6d24eb129b7a9c9e630d8d1a8f3b2fc20029cf50a6f4f10481e6e24b61c84bfcb2c45f2a5e80fe2087b04dddbf7e381445edb20cb75394c2f63dd869058ba2fd09137a58b15da4997583999c4c1483209041a0e65d11f8233c472c0d59717c6427791aa2eb00015dcbe2313e3dc828b4e5088c6af5779d3435e47994c9c7e90c70f05d1eeaa89b23354e61e3f8d5d977f867ccdf00fdbcc5b51814d21213c9ba255c897d265efc5aca4da23ad3a84c4063ef9f32e884665286838447c7baef4a03b7b582bb8700e836f6b37aa0fc866bed4b4c0267318f1fef18d90792d43222bf2eaad768f561bb80aea600b0fcb9c32244e3d02a9c6484d30b75ec7daf94e1aa59db7fe64d9c98597ecaa016c06f1e3525ded265393d10dfb295753490facb624d661da78d4e9c9a9383cdbfa7811529287f79e8fb3a1322e0712f1c7f55767e12bb4f968ab76a8c6cd43c3ee67c87b8c3d78fada298699aaf0b6cfdfffc2b5b96bb42f298a56a98d68326234071c47c76caa3b5b1c8b31317f85574ce6251f5b1e344ffb7d65c98dabe1adecf15f31eed4009c5c155649cea9e3156695064f2fdd9cfaa4eaca25d3c69f16b64837d27bc4d2ee88f8393d45ae7d99f914df4022b4c39f609d00106d865cb9520c2c5d40a989a9a2e6044b46a57e2f740012a5714281f15dc072403ac311a7c24c38764af5205977184a99757116689d9f4e6bcd006dbe5ac28ee43d0fb2e4ebe62f21af838c5e7f5835015ac29b3bdbcb88c589d87ceb9758f820847555a28ba4df26ee1f05ad08d8b052575d8f88fdd67cfc36773b34f18d4e1ad97916f4aefa247b7825bb241cbd1d22bc3a503730e4543985b15b2b8ab3d13c2bcf85b4eee2fd2b902cdf9602aa8ed343827c73ef13863bd84c57e4b4f859d77c4dd58452f2127add09d3feacba84a74e4783a1cd4b4590fd6b05334a18c7d94dc1dd13d474258fac6ce00ae21af6557ca98b4d3951790da3fbba47065ec363d16489cbbcd437e4115510afb3068fad02d74a4197021a3fc34280545b0bc50c54efcf8b0e1c699200b2d35a026bb2827cf62653c9b2de0fe0d49573f79c81bfbd98279939931de461f7133a85ccb8e3db53086b4909466976b79aa1e72432dc11fa0fcde369b1b24046603cfdb735a641dde3c4068dd1a1ac9cab82c34591e6bebe4bffbd6ee4927bb334d69196479bb0115ff79bbe99ed5a954e095a74ab433ea8539a2c92d3f0865fa77f8c1a87fef0a6ff3f71450277c0122b9cf0e55b3ba68a3ec987be7104a5a78edcad82e2343aa33816dbcfb352dc3012638812250d6e00e884be746743e60927c651066a8d78222549e6e9b17b964655b0208f29f08b1c4cc2b4c3de7b9e286e509b74524c45f8caf330af059ebea937976766b3819d93ccee30c54acef0b991d95dd76e7986ad212c6d8a8206235bc2e0f669f76229a6485687082515b1c56b613bd0468e631f632859dc10a8d42712480063402ad947b8b5c2e4866fd4725c42f34e7f614da967394c4bf9ab2ef2c0e89961e91d698d53b262938b74d2c314c4958c7290beef57fe21992adc7749f71d23a77c2309125cab2a863dd40a4a78cf2c69584f3d8179ddd0eb13d2033e834c54c9235d47e3f80888eee1d937e7e628f01680ace9786ca7e99ebf49a36ef8a49de91e545fdbf17277814279d660024a7a4b174044a8c794551df28b2d1ac5d7e6c04bf9788ebc1c85d298caa8c3365fd89dbd6d074079915b4417773373d36e26449256cb031fe8d27dadef3da96d810d645e5712ddbfa073102a2d451d65ee64e4ccdec39ac55865023e3b8f2ab389083b08c132620f4907f32789a6beb9cc137d030b9d660c63faa27a2bcf9fc461610c599b43383a06f782646932c1885bf502345b62e85b63c33f64c6bc5c114d0ed7e1c48cb5742822c84fe6b7f0af80d6a3d8b59d0924179bae6972081651afd09e1c57ff2a0dd597dcdb23e89d8b12aa4e758bfd90bee20555ec852075c72058e181de1c9550bd9a33b5487755a71b643d73abb539d85ca6569477585ccdb246bdc3697315fa2eb00c2194eee6cd9dd6d54ef7b4ebd4f52889ece2f19a01006de611631834153abcd4241650f9ae3e8f0115897df3c429c37089271c2924dec356722ae264a6a23e372b7ce8bffd792a0875abe35cea302534b73eada01ac351e93db08f25dd1fbdea249f83df8bc51f09b84e992e985994c8e32a8737e3564d03d30b0d87a6db91276468dc9411167293dd17e7c1236c9ed11a721acac79b078990a74f0b119f1dfde199c0095d9b56e79a0ef7cd66414fd744fcfaa00f543d574e172ad0e689e0f54c7da643c965b635a2e1106eed0111aa7ee4c039e8e097beb2d46a9573797f5f0151511c7390b53cad7f768d2661cd7b8888501fc4300b7c4c1bf4ff7bcf63e49bf77a566cdf62ed473b33574a3dc48228c7b0bbabd0ecb3f4e27536407c90aaf8f3cb57af526e2bfc479b3cc6dc9d732cbe84c40f34b4bd540f3b1bdbdde2f203c7a4b8d12ca265c5226a52b7626b71fa76c83a9d83500ca363845750c4f06c997179f8b20e68888d080a5c49db61a87939137e7f0026f380fdbefa2d82fba949d1f3f1c78dbfcf934ddcae86bfe6252dc328c44d2b11c109c5a91017bc96dd22a80bf21f3411b0361513cd1399f849c180052f60bddd9354719bd6530407f6ace3e74a5ea6a8989b30cfedd22495c0c7ff8aed3bcef2ad224317da6c176f6f151dbed89b0f9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
