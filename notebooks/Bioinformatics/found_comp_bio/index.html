<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"224ce2ec47a3c7c91d9d046f4f7fcdc526c5b9191672334683fa84167045f9b72d9f54b02f934f8d51ad6ebb40f53dffc912821adecb1e7ba098ead2fda73ae9495750b2b7bdd3c8d6f203835b0263dcd737905d1ba34f30ad2b8079c816dad9937ecdb2d040bdbd1a3b3e9af4c3b2c03e0a5471acd57372d4f8d7aa23929fd956672817ceae3fb24b197e0cceebad3e7b308845af3624aa1f726865021e86c70a943312a5ff37db7f513317effd7db02a8d9e42571c08b4dc4d2d945d9cc5a2e3faa7008433d740c749fc77689f43a9f10e622207a3f7f1954f6a9bad5754e34f3a1e84a47875a9cb677e1cbacd5ab9f7e9ea26cf8a258f04e91a6ea85a8e4aa120086d1104d0996996c981d2087d072b9c54ea0444380d0e8cff9a80ca1e7cb4d6a9960179a7b6212617d7c8346a9c63b465e94a6cbb7688d23fd6d4135d0fb77afa932ebcb7246a679810a31f9f15c738ace4bf9cbbd5a6a7471b6464cf9751a3ada56843468a52d7d28983c308590454f758722ddf8b539b4377becbebf8444734f072fbb762e01a00519431c925fe7c80c9a2c4f0fb4499f8b69814d4c9f0ebb5da699b0ea52c1bc0f05bf18ab2c14864d172f529e3124ab4cad3f3282af8106844a385a37a5da041ac598024d3da2b16edaa149dcb2e0f736c000a0c689dae6d50c4392fc16b575a547e15f1bdf21948649ba9f91e628b8cd0999f981a27f14b343ed79f650b3e0861ffadf86e5912fb7141687e304f486cc922d4db93a1088483ec67647ded4a5cc1e383d51369a89ecba5e9c0f5790b1fc476934cba2b1e40b07a409849ae2bcc75eea850620fa14c01d234eddf6d824ebdf5bc1d13c502a35c68ecce11f22c079f16401dce9da775e1c68ce6d87690da817b73771393b5a1b494a47491d94c1ba33f6de96857d00603fd3712f1c15d4d9e91ed4a3924085084e99b4dd3d2cd72d1af6995e309bdb867683d796d0efc4c3cd43ce119561575fda8b944ab74294b2e846cc5e156a5393d77100f9754be104bbd3d2cf7e065734118c4c764d8a546fd39094b75ca174aa3294c2f9869fbd4e9a0d8ffcc56fed380d7bec336cb9d7e5e58fbbdb36d4a756370d589cdb2b22bdb6d4d56fdcaef3dbf66979e2360b63f28e027d922672cf6161786ec66c383e0d24fbc0aab53dd59d580be56a00416c1cacf143be02e5f9801280b58a8deb22f1b784f2e6863fae21c4b8ccc302901978e678944bf931c0b8aca37df4fca9789b190064ee3195295c8f5206d6845d44cdd087bc9ab78a1b82e25a83276667bf1f09c6d75e8dc190f8ddf383e73702835f4fc36cf8a771e77c192019ee971d2abc9c8b47fbdd1e1f5c2b6d3f83955433d4fb48711c701dd95abb68a7d8c3665a2ff63db6d0b40891e6880b9b23df9d5229089ba7f93bf81232bc5866fcafc4598caba954def5c36fbe07f6c9e300a0af4a46e48878a94ddabb84db4c555eeb397a5da3a912f7c1a8de6dae38506db2e88d7715ebfdd75ae626b4ae109d0c9fd5c787563ea59b6209d43e484034e7b7819130edf15d9c39882d8f4979ebdb57a5f46953dbc151c558d32f40cfbf15ac894a9fd6e8665cf57345b473e036a7bf6fea65cf3f508e81af42458b6ecb356539f3c1be31f0341bab0da2ce51d4aa5cb0138dfd2c7fe948f19a57c0dc581ade034fff1cd690febf8410bd79034e16f91d8807d279c8b68033ae707f08a3624ec796d329b184d9b151c9766a56e5f05e14c903c68ed11d472cdaf07debcfd500acdbeb341d602bd39a2a91b2d0d5bfc3516bdbef52ce25338785c67d65a53abe1748b300c41bb9906d53e6f6c42e3e9b2c6dbe1acba877034bfdaef1ef2403290300e27a79607f765ae808f965d41c47baeac4fd4f7acbc2a04f7632e9cf658cf2fc21c68b2159472128a7efb92f6c4eac7a768bd8f2a7a16ab9c78318935cbdae8674b7495c36a1716a418cd037fdf39f9be77a79aaad3bd28c0b6ffd46eca3e5963c0ce5d46c3231039542a65b72f2976b5929d16b9b906f3741872b6c175b2ede0e14608afd3f5c06751a3c663c98c5b29af223599b4339839ad16bacbcf0ef9c470f8ba79a0c0d9330361b44d9400eb16db6dff0c6153c8f8849f7bcb3e9c98283ea993fe3a0649d16b49a9d604639f763a012f6d68cb31b6987c1001e585b52894943788db5da9135c97c889a561dc6a61a8baf51a5ce7a873253738a4eb6fe88f8092425a7ce10b124e3c3739550803b9523df9e9c24003002c10413761cf6af43a3f03e3d8ad319e2d82a14c09a3011864916396656f24b913245ec452975ef6095373ba88d1ea86a02d67fa459f86822a483d256a1a61a4b50da4e96b90fa3cd96d6fb604ce35c5492be959bd8bc356faf812b143f068d6455161b6c0451b51443c853b4d6f44069c86fb0204b74a551ba4f8e7e9885f99f2e0946f158986b9044fa21efb9b17083aa81d770f0f4b98ca3a678bda6c2a42fe8c4721e6e88c07975b4922230250ce3efe8412327203af17329fd46acf834d23212509e1c5bbb67dd87ee7e688421ed5c9fd593d5b51daa62da91eb3ece712d003c37f8688cd2e381722530f32effc69244a51193fd86c8883ad5d62d1e25e0570ebafdc83b4c935c2e51a4ea3fe1a83d157ba0248a082779c6e6aa0e8acaa5ada6d681b1de531a641636862905160732137e81feae6b76d26eae4364cd4d8a5b16c82df94e6a8afd58eef1d97b6141ae7e2b077937b46c69d2e2d256385aa18370dab83d1b16fd5053d8c23300c12a6a03dfbb0d1ab51e2f7bb1789d733d22b8729059e7117b2128bfd61d8b76f9d87af41d01f96f4822afb15b01482a1ba66b9437701664c78326bd65def4f0da035b768e407d18580e9c1959836ac8e4165fa0f88bd6783849de8ad71674feed3d84abbd1e2791ac1cc72aee43deb552d32f59856d83864f8743de140d6f47556fcc87a03bad1cdfc3b0307702ff44ce04b5b36cefe11bb88451bf57a5ded91ffd29dd6976f8bce49265b846940b3bf19973cb6b6164a6c0bbf4b8b34084a8ef68083388ce8c64ea960318c24ab411214c0583256398699cb392167426f96080ce8f76c6148facb3f9a5f18eb7ff59fbe24b3a2b1416a8370e9c74ceebc44f7fdbc4a69d2e8a7ffbc37bcf7bb7f3b7230f4072bf1a72c489dfe15653cc8c951af3463ad11ca1a534a17d4e777699c272c27432ebc87330e5241ec785c9bf369fe774702ed1a7093278f5b0233c80c00933a698730a9d6819f6cafd225def9d50cacf87112d0bd56ea8772d16bae22abe0c436395694d303774e398dab0d9d3e474a46e4a09fe6dc0ada4db8564f2a384de116ceca988b88559160129f1f704e837ef2ae2addd3ec01f734044f46f4a5bec20b0a0bf5ffdcd629eb1bc0e078730d97f9e7423b3d37043b73a16e42393a6556ec03d38647586db0a0794586ff3239009cd2684d1ab35ab831621a080edf9d96ba5fcd0cafd2f8cc515cd14cfe6f9a4e848daf11f6fe78379a53c34af68cdb9053c2c0c3f50bbb23d7e4a5b822ed021ab183c884ffd1f5ac0abb065ace782c116b68d0b37525570fdb2eb3d692dc1e2fd751fd03f2ee0e4f4252f2212bb72f10ec4f9003efea9f5b0a33346440a336eec189124f4e6ddf0a130ce7951e9ce05d75b904c6fc4ec160a39fe4a883ea729583d30ba690513fad5a46bf171bd56b6cdbc035022db15cdc88a528236a4920b4221cca396216cb9acbd287d6080681d1118b7d2a561404a6a90dbde7307de1662343fc12ea6abf30645b7a1cdacdcb47bdde4a0bb1fcfac405e6ed6b51eb67e4bc5e768f8e9d05cbf5416e2907430f13524b64675a06fc6b82398ec8bd937439d9c6634d2dd25dfd8f47af70d8e904b8490def8030420fe156b773cdc45658f82f5226d308744303ac2a05cffef2ee359cf0be47f8fdb5e6cd4cb0451507b9797c0adfd23c838d883b180b4eea08d8e4130581b714c7e1fca98b7754c79cf6e6ae201d978215d026359cdedc00b4ea4286cb4fb0a05c0096c5417952999360659fde34e3ff6fac2f1f98cdce68dc26af2dd84e154eb9a05a7573f8289f320abaeaab33dfb012e30353282657d8443b24cd632560a347e04898c6d7139e879e6acea9e7670b13bd15c5d1b794f0aa5d6d1e6358e847723170d047f283d6573454363bfc5f59b9a611788477a2080c302e181f3763b030505defce8b321535c4f3ead60d704bb512b503b87b8e05c9d088c09f4f182bfe3305c36fcb8ef2972bb645f4515e8378618ea1ef10d0596d64350e91abcf8a679415ec1c1fdc462d02b3f556d5b70140fb228e288eeb8fb3bbac20cd5b340807b01b216825e8d09cebc458d6f5dd0f94e40e0011709b092114e42544b6bbc3088eb61071767c1402327fe3709af57075e4faa4b5561fc9e98e3e63a68ac4d157b479b62ecb7bf1bf33daaf3d51f8539f6c0fea039d2207fde0cb786f86e66d95efd0c812b3ec5637384595516c8f7defe92c7dca0aa3c4b7f478be636061ce686190f44463e0d817448831903197b0ba5c8e0355ebabdcd0b3cfbe44a91ba702735db0597108c6fda601a87c6a6fbf6db63f818af1a1130ff1fc996c0bb835cb1ad369047e7ce1c341a22ad724f14d095165af4cbd2df644344374f161e061131913024908ee889ea894ec118298fad88f79bd9e7c1d55af687370a7b393b5e066d42e6023c586aed7668b35c6fa5e05fe9f4a269c8371d2f7f51be513017669c0afd9911933f07211b32abf3624710c8200ecde95ac1f4e7a09a74e1a84f006e1f5968e6c7c556b5d3a93f0c373e9e450e813cc13681eacb6b92f06bb1b57095a0d8aaaba67ca8e46e80bdac8d4dcb5fe356688a3cbc66c516bdf3a872eae0a835cb88a6559bf36be6465ea9da1b8cb7beedb99f20298b42e1388a387fee18afd8b4d66fb8c125b392e650b3909b26c35ebc7956f8233c1fb6b024d1d54ac0d1dc6ad7778341306270a754ff5d74c03e60bb21ffaf8e726750fdfd8a8ae5988a3b7c72ce7586cb1f72ad558a35cad350828e40413ff2ee145229fa3451c260a5c1e719ea270e79452b3dbc6222786232a7379c2e9f944069183c866dd80a3868004ec24d9d3992db994e3461578d27b1fbf06cf4dc09d442bb26710dafd563b31628de04d8f52764900edd4dea7e020af720987713ce5c742c7ec4cfd36d1631732298b71bcb9e3271e17b0c4b6eca1b78d7ad39a1442c97d3cf4007de64e1c426d551180057e7fa1628f8106cd9ad75e32fec843adfda6ed411ea3d7b7cc7a92b71c9b4e2d6b2541fce6640376d6fd6b66ab461a3fde2db3d83b9dd03e94becba4061a04d1cc91f53a285a0a4f59940d5fa4c664c138c31779ffe81983de1faaeaefa5d761e340df782dc97f0770fa5730c88d79ba0145eb8d1dfe72d04241bb430700635c41507e4c42581f137694552b78c824f082c10ac690efc4c166011e7982603592fd82068085d0e814a3ea36e6850596790c1d4ada4bb8065b7b8545c427829dd9fa6b5cbfa2d9544e26696bf5f5a7c29eb10f38e32d53591deaf21511f271441e76fb68392d68ebd3bd11ecb354b5098001b2a8937d58a397ff6f8b3ade559b6a0c46d82904356bf2ef215ef957be7b4077ddad5c7bbe9acb94390eae98a7599c2ae1b94b6285b79d27838820ff5b8fcad606b909b2798bfc796b2ca7abec95e56acc136be78f6c35b2469ad8151408ffe65f837c279a5de776909cce658fb4e47824b3f655df1bfb017c3cba5fcca8712ecf2800318aa936a9aa716460c967f4dc76e8725c8866fa016471fbdfd69f64ae6f115abed7ad30ca88937f6c27150b3a5622b81a19d3ac10375fa4262aced0cdd8f7c1389c2179bed5f1f927ed19b22b989eea1543f9f8e483e71df7ee53946cc7b67fb8ecc75ab50c6ba4c2760478a8c4b6d661938178f3a92ba911e2c9a0bca804cd171a9db9031c74218c04c041111dc56cc53f1e99312c5aa32444f2bbbab994e396707637b1819371243cd1e0e26f52786696fc0c0ad6f04dafbb72ed6a66d34ba3e5c0a69da955408e5e7e98ea5bf033870619390cd6118e2d9d7516365a3fd5f9a776cc830dc3850260b7e5b1128a364921e225d12f4a0497c684dc17c0ac0224bf5a61728a0fcdd7b0b73666af24ab846944ddad472f3c262c921d617240fcf503f6018ab217f5911b6f824654a6333d07bdd378aa0b0a4b90e83413f621390b19c14a44c18c6df46242a5950032a1da6d562bf455574157d18b104926c91fff41e6ec96f202a98741f79db9c1d2adfc75e5f53099b81de0faf3ce9e54e5459c83a68a797aa7d85fbfefc04264f90654ded6f9caa244ec29dafcf92a361669bd2b65f0544ecb82b782cfc318b2d38740778db3e99252493edd63b07557f78b04b5bc12948ff90a0fd9cbd000047d83adbaa8053b2d182a20f305d2346d79dfbbbfd8917ff1a7c0a5968e3eced1ec3e0cec8e5830a50d49c803ab639ddb2673613581f181e02a2d840dd9409f2dfec8c9fc1d08d6a9b940c5ea2d32561a32b45d6407de618fbb31b11fac94c7cbff70dfcce45a42948f1c96c38bb5de6a71e4fe5aa25a0bdbc23b6a9028c5c390b7d7ec51179a2f1c55020421a2d7c4b65bbc5b3b8a5ff272eab2f5d46dc2fad625c451c33f86741d9e3eda25e96d01328eac5b5a0eddc5bcc5f154d7346864d05b94a7e10f17c285654b6cb50b84476ee794edccf3edcc967b32a476dfdeb09a17beb5f2cde8e9351fb6a2af1d5674d621eb846e0f35407a037671e645afc416fc77d08c1e09dcc9c460587d62d5155e5b784097964b374685c909e90a120d260529fc4c2a78ea05739583934dc0fe416ac3b93b2289b8e5fe9db59a7d97541ca070eb0841acd7b5ba5c496271e6182dc80f11b86275893d443bea4003d662c4ae081dfbccf0ff10fea04be32373b9835a93c2119630fd0ff2e7ba7eb685b63367e70e3dd6142f3d44a356c380f051a40fb654cb15324d4143c111acce811cc372c8572984ba0975b3766ed45f3272e35f8168bd107c904889f036a6ad77f8c58049fabe127f7ee89573472d61fe2a7df40c9991954a9fdb167f353bd95ca3242de4699e385b8e9878a80eb65eeeb72a88590cafc4a343b5655bd83414c0c8a4218814bbc16cfb80d5027d7855d31cc2b204d36b144899ccdffd7ef6d0b32cdf0ae7ca5c4b00bca6fed7e0af26258b15fbd6a44ea189fa4c31273753182a506a5573b4258ddba41db5aa1eb98cf6519d68124d7309ccb5e02a9a38b0c16c8de13a486a244efe7837f246cc44f76d5a90e825631d87cd5347a042cb2a0d32deb2c84f534b2252facddd830d4522d2917737effd1141db5bfc2c77e5dc80ea213e485d030a40f6c3e15a9e44f19d728df56847e98a0f412987beb07cb0156617c4b9078d4506d4ec5a61fb16e3ddf83dc1bc77eddc4b7719fe15b4ba0b06195335b4b591975bb3958db7879048e31c6c524e2f5343941c39a560ca435453295f1e569e1e59b1acf3d1866de013c6199623aa2f5e95647e5e8bd0c9320c518944e74356d6d51249c5ff1ecc0572dc595f040428cbae84ee1c23263582e175f52539e9484203e356619a516e8529a036e98a3591ac3892894346438b56e4d6934d6c89eceb39a54e7e5313e5241aa015af65b502e7c3c14781978d0b02994a94f72ffb60d9d68e111b03b1c55fee3035929a99e1154cb102cc560c2ffc38e737b301cf25a2b862b996c82a38af1106f925445cc3d815703d09b2abeab4be5a4a516f4c78f7925f5696cefc8b21f9475fdbbdd2af44d3a197465f3ebcc8cb8d08a4b1d1f9ff87572a4bd2647b2dd2c0bd73e79687e0517fd4c4efda0e08986d86139ab7a4a38a4db6dca2d70f7ac5602d06870aad96fa89062b0dff9051520cff9343ceca02a21810b9f53cd868011af011b03574329ef9e97e8e1948d1764466827053f1f46ca817e685b04e0e556f6711c30bb39c32637fa61c2de574f733327b1e0e913e2024cc559f43efdec0e3d86f79ce9e152734b554a8bc1b651f05e0e8d92cfc4ae357d42306af45308ba90113418e0b0ac140185286778fc2708d167f011a12c48a37bf75f4d1d01f6c4a0fdd459e63650683f7a70d930e930d1f1ef51301122fbb2244c39679c445d9f23bc9fd74983b0e9d4cef4e4db42a472916013d7f496557c2c6d243e999bf47e3db7ba896c9674165cdca7574ae9290a1d0e846a3690bb2547228dbbdefc2c234b9d4aeeec19921ed81dfea05c40b1a771b8360b01d7cd5874d9a0dd65811f4abb8e39ba05e2377da9efb97a11a292d787794362c34a8f1248d2e3945b10f4f6a5e61c994c41ee5de680ba1b61c61151621751921abf05ee0862f66c100ecc58f595159ad4c955136e53574663579727f00c10feaddf7c0141e9fefdf5cf3d5704c971838b410224c8ebaae57e54026359016b81d8f7c91a1b65c649c267cbcffed74a050af07c2cd06a83f42415085ebe19d27ade65aa844e870d3e20fa39442d50a973ea8fbcefcf6892439d7cfae7fb22c53a84d56dcf90b317a78708fee502770eb84d16473ae227dfe1902216f9b2f7600df83c44ec83eb9751c6d2cdeda608edc2ce793148dea444cf8003d2812dbbd563862e09c472f4783ee9b7884b0822f73ef37ae94010833fc654e196d8fff8910159f0f87472dfe52c9434fcee0e04c3847671891da68ecfbbd07a32ae3fa8cb863a4716abc2bb2701f4bfe8317ceb84e1472a50a235814f4fe758d73f6ed81c75a170834598dd3b7bfe3f367721c287e6dd9b9b94696eb801b0061822d2b2977f43f5a7286bc3b135658d48d9b1e9d9ef9e69a41485eb1e7c3dcf41b035e6a9b237624398a7fc453f5a02a0a936c7755a4319f3b71aee3ffcda9f92e71cbedbf084b12816ef4bdbc5d354d97b41b480bc94e07a5194c75db48eba1900a99838ef99d38fdefcf5ac852dbe7520ce992c05d1a56c0411f1d9d178fd100d671a46acb555dced2bc2779f61176e8a0c8234b2b72b34e8ba10394b7d50c28711678fc4ef96ef64b5603a7dbcf53a6263356d6fcdf6d3b6c000c126ce957bcccf7be92cf9ab74521f5418ce6f1b8049de8ea875970366e4f4a2b07cbcbe3ccb1c612b515201238abb2b30c7bcdaf6216b35afd9083eedc33cc203d68ed55e6920a860a323083eb99af2154bf38a1d10a7662b237c155a3bb5f8a1aae159444d82ba85da2add0487e52f32e7ac39005bcfbf9a185446e414e9726c7d31a851ce8e28c64010fb675650ac0e9834973725fe941af5efce891e81db73cf71ae468e7de7900731cf5fa6194ab13fc4330b3dcb516704398d159e672757746385f8124165ed0ea2e4029ad9c8a209ccaf64e804f662a4ac31dfad1d44ec0d8bc3cdddb527c0322648cbdf057866fdf39f7a2a5431a0184e18b8b6787cc76f2ac560c44d221f36ff805d49bd1e2fcb709003cdf4e69127a2d93df68b22ccf9e27699942a570170c13fef15b02e6a8485ddc4cf3b857918fa8c2c9ae6ae364eb693ca5344d09baeece1cc406ab9facd8ce78b02a6082ed3193ee3ed60b4bc6907162de0d96f9dbf6edf34e6852478f2681ef8c8ebcae7c5854ad01753dee758e180b07605f6dfbce5862512884129cb7892b3845b531c9462a5ba4ff5f3a01f8c0df62c4de6076611bc2befd0d4d3a497e2ea09d2243431025aee92e5b21c6444d12c52d87fc6f66914185cd820394393317eb23cba56a6b4107c280d9783575415a5fac29c568fcde2861555dd08a3468e904eb00cb974bb1724ff8e00222cc9f1f913445699c06797fb7d348323016093a07474c3aa70f29cc9bec54837093409088d2b0cecf245d3a8bd6421b6e817280827fffead955aac1787392b4af94acb4be882614ede8345a7569c2d108ea7502af6cdcfecfab1807f43e7551652761f8561b7b3fccfb3c00dec72bb6bb176b510ddfd41c4395076dae571a62c4fb209c36e5759affdc9604d7cfa3a107ec1e3d1e528520a00d99504862d9a2ecc3dfcab33edb4660e9cd8e58dad15dd4c27f3331515482f32acd8bf0485bd84fc6c9f22f378316889e00b1fc538c19511dfe2a77e5e340ac9ea6f76ddbbf8dbb82f7092f729a396cc8b13c0a60556c6319064d73a05354e9b632c8051a7eca64cb78a8cf2371b7e99acb335bb1740012be1e00fe4b1e4c991cda284cba944be8271afd8b80f1e194c006402069bbcc228255a96b441bca47833e34c5e2d22df12bfa4125b39b8a4089daefd614adc68ab35c8074b9771e928d71bf20a74468f697f6fd7d89858af8976484624e251bb2d702e046c38c4b7a941bfd100d624ba48daf79e43b872c448c6a30f2297ce75aa14ff09a004dd008572018ff3dcc76702e45f4d0c0e94058e1b6dac9f52b9b2e4d69c40c44d5e1413c5f7289ddbb80d67df016d37ce5e5f683730a8dc320cb272d06bc78896852d066c4ea3b64f406f6c56ad2e408f13cad06eb772436eac3ea13cceffde033bcdcbe670f9a518036d7f89aefc311e697f2f3c13e4d6ca191e8c6e886d3e983ffb14ca3bd78d09d6d355bb777e46e073973a72f7e65dc710b0c2e50e5b7d2e1fab33675898ce48d62d2e19b50e113ed88eaffb41bdd7fbeb0a204a3fb92ad6fcad2137ef5baea767bc5570e15490beec8e02e5c6c89334375477c27b796ed4e4414d1f236ea4abc6c59d62b316c23bf6c643ae8b99a728c03ef88fbe8b6fa0466834ca477147c62c7e99f670ba2f82bb49369e319011297bc3f47c9e7470bfcd5a1bdc01cc62ba7edcd091000dacb90ef9ad5f838afc77918ff995727c7e09ec54407989e9972245bfdce531dc7ac9a629419fe544765b1cf8719ac49a0f8ed93c77972df400756873b052d1774d71e895354007fa8b9264d95069efeac65bcff7d29ae1244e693eaaf22f227f59828c9857e45038f4c04b81316b491da790f5c5989ebe8e9315cd330348b5dc43e84f76af212c7053a3dc38131342738fb8fc88eb97cd86209cb45c687284b9d6d3f5e15ae9f05578d1139050b9637be7727447284b983f91237f646b7adbb797cc7362c3f990a1f377bcd79b9ad1273e04b09514a9ee74631695305802a9145a4aeb48ffa9191d72c3aba641ffa7508179b66f89e430b4eb0c214d8453921d238b79822633b4f3426901f951f9a4e19274a72b799f312a55625d8f629d0af6456453bfdae8488a3a6efdadaf7ecafb32a6ff05c5625caf3185d53c97e0b23af1dfd35ee4c9c54ace9d7e98fc51327637795cc17b995cdb190f86c6181f9cec969f389fe33f8c109a7c118f50c960fe648e526935fc1c8b2ab2ee823fbc6a45e4dd2e3e5de69e99ec88eac073b39ff58ff33fb552e5c79fe8a678d0fb39f4edc8f4c232e637f4cf39fe6ac24b562bab7450019b03d7cc07b25c2f587413caba548969604e4d958aaee8c69725beb1160a461e986e478319b1e0cced0989af0b8dd98a67ff1188f53ebc29a7cb5a372e49ad9b0b85777034c97482b68376b446e9da22065e7acf61b698055df76682ae6376847a68fb53258878eb0beba82693ef7374dee8e98e2ed66b8f50def6bed29392e9ee8c97917a5d54aa509e977e096d84409895b345618b6c5550b5d4462e43b83a8150ca47af5c3090beee8b30e41fbd877777b2f790c2ca86c706f25638bf9a0818ed8b74e0ffc5c6843a0a495c8b54f41a9b9767454508c1b137380e52700b97cc669e6ac46ac04435ae0a670382b6d117252b8c4c5029deb0d964ce86d328094412e7e8266b72ec36527f079f6e53002b17535d17cd56e8ede875aed950433068897b99163d397cfe499a1a74f016902d0af998cd8368b3213af114bdb0ee2a458a6b5939057b613e4e2d0ff8e5761b8324613b2508693b8350dd27ba25aec0872aeb6e824aad1336ebe2985e46f7de88a15c9ed33e1e0c80437cd9e24da0380345d6eeac283e1e13eef92e808d59922f2acf3d480e1659d34b14155dc28669af856a74b9bdaa028dbc9e7b819d8790d02cb353e10c19f3d6387f845ceeda47e5f922fe2bc3caa759034eaeef112ee05f0d4cde72d612e1d1258ef21619eaa8437caf262c5c7b7c28fe61ebc31137d995b419774a3e3df13d731d6e728fc6c4c85ba5aa64b285bda977fe229bb5c4f2669d0f23aab3f7632ebd8f960fef30023830e820b5e83b5f66db2841dba02db8abafb373e3b1c69de28a29e3c2b5af0a5a1315893ee1a236cd70f72f722fd5b76551bece9c5fdb708d13c92fa01727f72df1186af8f4efe04fca1ab1a8f5368aa3c63280425e99e121984fdf30c3a13886a5952812168b19204303c7511e80ceb06306252d9d0ad89f9abc053e20969aa218ab2e35e3c69d567a1f0e5126cd9f049b79a7daf08f9ab89b1bec70960a2c021706ac279a7d36e553428b3a07e2a5daa464a355961cfd6e4a015baf61174abc5e7859cbf9b8e4fdc92c47b37f78b707e901496a752f30bcd2c1d4fe72b7d83e3d4787961f5f283f4a8e6c4c326434fd84e615bb0fee556c9c785fca5676b460a2da117ae11ed1baae857455cadc319db3e32fd8185d4e2bd4523f4c884108e47570b98fc0c766f187ac314997d1e63efcecc1af2df820da20f79455a6ed69e68da170ddc49b897fc83eb83ae6f3b9af94676ba09637e8e91c3c17652d23fb1d023b8a5797f16c1354829fa5ae0f1d60350162e3fca2e3ee6dba76bcafd3c1bbcfbcec88eb031e62f59f1f9cdc627eaa184cf1a8916192c8e4a22cf4b9a5c036dfb9e884651004db33af6ee70a91dd700ae844300bcf9a93eca6e2bcc8da5e67cf772bfdf437ade3e81005e0a57dd3741735ed0c284713e75e48631afc4d1409c2332c09a1820c9e2a3be3599ab9664d15085ec5864769b99635cf52a8a7b4a9c8c55e7ce1903c9d18756e12b6cccf4cd02b8f72c44ac640fa44f72bfbd2c93c7a680c0933243845127aadda8c2a83503463b80e780354ff8a742cfe50e60b702fa4bb7e7a7ffcafa6c3f7a4958555496419df907d685a12fc04f24d1dbff6747ba4dd5dacc325b16f0030d127047ebf1679f39d28a7e25013557d89b2f429aef492ab467a5c092c388f784bcc174eb08819923ff1fe1179ba63d4d44b26b5fb23d063db3016edd3c67e847c8241a5110653f727f6e71dac3810ae3021ee2d6b47531e6fee29d577df9fa63b8a7c69756a1904d543b78bb65802c8166a3fdca80c65f2d3e2204937683929ae48f251d7dab801b0dc059bfceb32522557c01e7045fc1578f3ce7e39d9462775d68d386aacb4f720a7fdae67ee0eadd89cf8aabadc52835e65b81a3f184d18691fbc66f16265303316b9cc9908082eb17d594b36842bac58cdc521e1c3c780f1c24c70b6168375188a916b93c6ad855da19577b97c2bb37cf6835e8d5fcacf5bc7dd6d0ab0429e99f5920aaf8b662353429f4c105c3eeddea62b62a6e46a1469c9909215218007658d5d47c2a82df643c13db28890c381f4b055199c0b84a530f18bd6a5ffe34b0dd8afbe7778865d7ab46234824a3646a1cd16dd8fa77dcb0c28517a2633885b461791a21879bb952aa16c49bd5dfb4bf1c57f4a9e3e87a490aeb5c4d526de3673cf09560f21d2f3e177e763ff9ae1f8de308a0b45f6dd450a12c25efd58fa118e237b636b8573deadf82833b1d9a84d3e6bb53540ae2d3a8110d9e48198173f1a8686aa5997ed4b96df0c355a11be375b1c7455dad7011861c8b5b17aad7f7386faa46f504b231b874164b56277d053ba189fa35f48b82ec4b71f2a2163979c0ab358d25d80ddd7c575aae59921bde3f7d8b21d77ce31cb1775443cf70fac29daa8b471755bce627a6cefeeba8f503686204195cabc48af0c0ebaff133ed281992cad79f9269f96e93ddf8552b5b8b7aeaf4a7bb6019d11f208bbbe7fb61cf14f9e68ee577488bc877188818047d5a0670c6e462453b1ce7efe0841e84512d34357c16c3f1224a727fdf5395eb26a28c7e5c935cf524d2696675b2b6719b1c53b488860b344b4611caace88e2d0e30a08ea2ac9c31960215f69e5d227a8b9768eec77e29a301755cfd49f65bb82ab2a6c7bf7cd580f8aef77445e0cbf2ec20e4bde3b5d66e0ff3639382dcf3d96a03af8aa352a303a26f5e75693a3cb0de4c3d6b6dd7d4adc7f74607be1bda97a95a5e64741c87c2a4effce5f7447759bde904f844d92c1f7b53eb18b0418cca005e3d372fd9295386c120abb88b5d359ff9a87712a72ac54ee18fe3acf6ab16761238bcd6d3cd3c858b6bb976ba8866a1a6259f5764423791e4983ed4638f6659a605f6e579492bf7eade7d91644b36c64f47e75cef656d2d354ba50f9beb497723db8cd9ee79475261de4db91ef645624b7ec730bf79cae446020bc1cbe58aa3f407a838cd31e74e78072e0e22f921e0ffc749f3516c1eac9827a71775dfc1a1525b16600f8738401427d828490b93d475603a0437840b0d98e964ae334132d963577bea9851a2e23c602ef08165cf3f11a1aca25228522ae8bc793f624f34d2a0cd69ba705459b2c70a0bd3e97ebdf7db31ecb276a027f6a544961625aa4dfe822175a3d279f54ed3a254bb8bcaf40e10df1e0c6417e52775c95ad7a66d5a4fc5ab03b035d6dc72b1e111fbefa6eebceed4cfd8d111b70bc804c6ae63a5c01743cdc4055bed26329afd35a0b948f2941302c69aeae0a74fe80202a5626ff15f5026abc8486a9825b0b0eafdf083bed91d1a12285c0b87348d4e542bc80ba1e4a1d5df1a5cc62ddebadb25600649510b96da71ce09be8a4788d4e495298a10dc00642ae85a8d3b131e5cd786da2619176d52793f89aaf8afb2d4a0adf6ea8b1e499b2850746e0e4a091ebd40bff0afba4a296c50f014a2946b822806d511eb3af71ecdd87ff53d1d70fa2ba632e4a2e780d4b6a0069c701d915c486b56c0cd3406074e5bf79c54b6293f388972ecb97e41aa3082bcc187ec8b2dc670cd2ae5b85c2ca7921ebcdefe7c4ddcb9fb70009865d21e3cceee03d0351820b1c900ce9d161a75861916103b75aedebaa63c832d53dfb2fd3617d5e0a8fb6df44d79e9071d19241ed3ecbfd9ca61c5f736a67260e0640a85450e11ef954c055d9ac06e6d5ad998257ea67733492b3bee99a9dddfc8fe5becb88f91afd15b113a853d915a051a59ca071a16f8282d070adf1428ea3bc1e22ac467dd8f8cf279073a7eb7535cefb9726742043f04dbb376660016909bd2b0c57e12e8c97623f7d4acb1e785d108a45cd879dc5534a6ad3f24a5fb6fafd2b7d06e7754e1a4c7a0c399cf4c2d7f71f400fb385e97c1f0fd9f3a0f5a5d82d9fc62f4004b6a898d85ca7dfa380d80d2d07c58d7691d996375340c01b7c7104fa331425894d3691a9130c9adff949ab72e4e84a7be977123e64445ac40ca6ea94a3663031350aebc10808012622d6e96e35a7bf695d96d1e72ce28b040bf9c1a71bb161c93718e39f15a3cec6a1e63b2cf46082b976a2ad23888f2e59db2ddbad30b18e2f87c5b321c65479f345cc829852bc96a4a3017a8ad4ebbc59981558201dcd365dbd308a1cd5423b316bee8698780887aceed6bd25d3ec0a7e581d69fcf6b1caab11a9bfd86746c6d29bd3c44586826287316c71d86650f7335abeedf597d2335c76f864e5b90ef563c272d44285f8da78ba3265b32648e38ce41c25917e738ef525e50dedd439d31b5eebaaa08ae9ea36945e623a0362c299a084eb6ea93a28f18be63d82a6998da5334e905896e91a2818b8e619700e46ced02db782a62eebade89709e9758c5b2f9616164937aaf94daf9db934eac91000ccec43e8ede50c8d361ae4012e4675f82f8419aeda73977a95f0c1397d212760e7d26c29c1fe8ba5f5fc8cedf544e1e9741987d77b2ee181d26679173df9b846a44a77a73fdb05e7d0e05813456a654c74a01b9c0d8a110b0be7b420532b8179662f495f21e2faf995baad8ca8ca07cf6ae67b5f69efa621f84116a0d556dd17d9912beb7db8030f316533d546416a680283063e070ee12ec8b71adceec0048c27ced08eb1bd5ecc013de775254e232926ee9f2a6de2c1704596e1a7ed42efed120693ae3f2abf0a8137b40bb8002fd2df17d413241e56b36bc6596c63f2b95f15176e6ba5856a3dc7178f7b165010135784ed303c64a61e17ec137c8fd04a88c5cfce6eb0f783fcb91da5be6dce309c5974cc08ec84a7bb643bba66d8c7f8a7230753e588729fc920232876520ce9ba77af66fa986a8f41aa7b0f93511173d2bb43bc32529fb59d8a8099eb8f0e3bef36e57caf17cd386b4095257ecedce23da30fc32d352855d3dc3deeaa75493811cf18eabafb853604e6812d7146e4a0fdae88e8592017c23a0cfb5197300f6df3f3a52adad1067268f80e78ac5aecdfa543ce3bb0c31fb986d5621538f26ab1ba8a26787fce1885909bd667e0a2b0ef512241d395b66d40ea37dd17db8c0c94cd36e7f40e7396619182ddff7bf23ffa40ff3df636be3a23a100cb27126721613493d8e9fc014daccdd59dacbc5f606668ce21953c190290f89f76e667e8711fe4494ff2bbbb539ae1d6df4e9d6238d4e48e4a62446001373d9f72a4dcb11d06efd10597b76cdaf0b1b3220dce10869b5236eec021923f7b8a921cc03864273dbb879fdb04c01177a13454381d3baf87afb5a9f72fe9aa057da0605fe6f2036c5fcc7ff8528cf3f0d446c54568797978b973bd81d94b82d79b782d0ee36757c73eb125974b4799de323c8db7fd4e66469d83c44fc0a7d0d76b69b7f2ba935fa692191dfbbcc348f27320f55e3e9668b9b962f4007a0089dada0bf835cada4fb908a3f28fedbcf2bf572c2e4ff093506815a0a38b36abddf6661e98e65b55b33f6d4e8944ea1c3f21c2e7329e90483562fc88adc45bf7b658004af1561c52a25a3af5b8cd7655f2d88320887fbbe3b86b0af947fc9eca03440a0573225ce2142f1e6180f6560415afe762da6f2c44fa72a811816c274b935cd96b5dd29b81104c6177c9b011bdd249274bc596ba58eff1fe9afaa27f89706ff5a4300f9d2d783d9849e43c4f2a3aeff0337a6533d934b9fa28eab810846a15cc67dbb6084a4f02fd875acaa1a42ab7b0b0a9b5fac41f487638f2366670345a3284eaff47df31d83f945234dfb9165307f99d6b5f6c9af7d1f7034f7580d23e3a20b02429514b49593485f7c619d38cefef12ecfbce6528db6068470474e6bfd90915df59f192003307bc4d696968338d1571f14cdfd038a18abd8a1f9df42862cc7a8b0a1c49eb8279c2a537ee09e53df0109c64ab8a9b5971af9d96d5d0e78055025b28ef37c9f055967f6d455ede022e059860959c2ef4b686824c5ed548b98181523cbccfa38c942b044f9228bc7f7c4808ca53741f71a19a7b910f9bf746527baf1f5cf372e8206bd903519e9e91076d592c270af8756ad81d20691d1d3a708cd4a8e8a61ae178b95a543fa3edacf5a2c70fee7facbc92b4f17109166e5ea477fd8b3a9ea041d1f00426a16160f4ec08789ad32f4b05af1e7878eae808d3aadf227eca237c66e57e628251ddc3f4c94c491de4395ba0a9740884f29156fe8b33c1623309077f6176f4f4ca8dfd94206de3c3d631b949d70c32372db207552ae2f7d6123ed42e0bbdc7327bf3619751c6ba618a68f6c844f9da2f1d34b8e879e56fa42debd0707e0deed8e29a0eca97124f619e585a3b428e167af0803e38625aa803314e57fbba0eabaf3d031bf1a706da9a675da665b699d1b7c9a5bf0e94caa5c3fb7a78540fc6cd6c6a7f2f4b7ef4c49a62f087f4747de679624e848c01afd1a1fdaf6208c60d19f32dc7ea40af0ef6cf7e49357f1b830fe0deea39fd1d48f75347d90232647a5fdbd84e10a9346f8f21ecd00066c90a23f9476a7d581bff730aa3ace34d4f65d7e95e22aa1abf53f88b3b3a9fa114382af0d79e6c78e9b721b8a04396f65fb6f5651ef86b657e2c08ec645af45892d6eb092043b0ea35a9d40c97319fdf85007ae02f269865802675f9086cebdd9ee2b3214e0a674e0857d4a3a07d922cd9a21dbcebb46f515b724f4517bfd06970ec74b383ceda356c8b5b2a9674de8d3a606f13207587c272961d5295d1f69f1dcc21abe3159c16fb8e4c01a690c242a13d0aff9dfcc496260f2bb7c3fc48d68a48a24713b4cd4b08759d8e7b5f77baef4a5c381c4b0f7b8c8beea4170c009926a95d8bccd4b577bae75873eec78500331d61066a8d4e1c688ca5d31","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
