<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6aebbab71b2f00df00b76a5be1625cbcf85efdfa200812221bbce1acb47528648d03d57024c84c045bebf8e8088c325607a8ffcaa66b3fb84188cef13f8875fa29493ae203e7cc13ab951b41079e0158afb1e526a67ebbc825038512afaa6630af908b2fe8edc0ceed0a5b372e63d5b4fd39dd40dffb9c8614cfdaa0b6a12ee779c78d169c0e2ad4fde69942d411bafaed208580a661d991fa62b376a028de8ebb8860c44b3e09d0d578f550d776a5c33a498473c4c3569a127022127e3d5c3162e7196f9a49a53b599388b8475a5d63aeae67e972f337e2097b5d44e3cbf7b4f7f397341fd66425c0cfe21bf760ff6871a1fc8272acef6d8d7b9931ae529aa9df1b225e65b0b760160e6e4df6c12630fec14a2a28f7e85e756446a4f3b1f8c38ccf0c61c13d18ade8bafaeb4ca0a304af8364648a1765a5d39da0c0312c19cd3f35a570d7b05ad84a5251acf07b824868b18eb3d6397dd3bb348c636ebdacdce49aaeebd478e653cebe9ae92c55334c0e046bb0307d32b3b80a9ba4e7eddc42a74c043eb8b336158f87c1f9b0bf69dc8b8997b236e9d8df745efd975114d89f6406aed38543d2a871dd6f87fcd4297fbf43f955d29dd2f44c1c2742f7ee2a2b429af2041a4ee17891b4812af7416fcc159fdcc4adab5eefe1077d5c980237c96a37de3ed698df0ea496008a2563761ca2572b0e02c48c3b13b6f6a1771a35118a903362435d5f161b143f9e51201fe132f67cd0bfd29a6196d09b32532165166bd793936782ffd8ce35592f8adbea30fc953c38d576e4ac2e069835832fc2fabe7b7801104e4ecca61576d3b0cb3323e3db9aef0d384c4f80346eb186cf54d980adb708a5702a6c8b0b2ea86b937cfac9025e5aae82f72d716cbea6b570c9b59c20cd230a2c80e414036f8477b64ef0feb3bca5d542e0f02f5410ffb21c9259378c7bf15f0d4ce8e3f24cdb1bdb11b1ead8a5b6e293d58d4500dfa73929ada1e17eb4332e39d7a4628788557a568bfb26e544842e31199c53eac2f0b578284e86c4f2e566eb767a17ebe4d686f882af32c5f7b6cc243b4aa4278a0c048da854519586dc012381fa43ac00155efb23cdb17103f0b9827ed34c0482e9f904a019f72306aa0982d8cd7def3efa4a38e6e20edf96edfe8edd1589f537bcb67097ab773c67d14fa7c8a69bfae4eed6f80b8e263e1fab5e3456a3b43509e85fa010b0fa4f4a99e3d95e56fedbb05e43731b9328deb4832dc744a31537e961840f98817368acb657438a6999b74295c5bb1388512d3d9b4b1aad80782e1a40b3fd7159109f682c987e474fa49b14ae26a7d8ff003d60c5526b0d0f549b724bc072ab65257c7e76c20a2d5b009793b1c0e174763e07a7b2c488093611bddaa99fae684d863a3e8f9d699b55bbd2fb34b5601d3c2f7895e319187045f9f74dbc060c2fb15ba68c68d053270d7871a30c70af940217d4f03a996e1a3dc1bb7aea60ab723078e508c755622ebda2a88f6568403fcf52d1ff608ff27a4aac82ddd14e7fdabb394c6ff204bb316b1871c6d8e188396266a8c8b9d66663d77437ed9a02c32742c6b330a5318774025c483e93255017e9bd091ed68caf66bcd1ca8c7375ed821723f9a154a7288fd7920e35156bddb40b6b3540c9a3da5c9d812727076b5060de96c593773912a4c609dcee7327f70c2f27e317919c58bb8bdbac84cc0ef4f6221fbb3cdae40804f15a8daff65fe6cc32e86122e9f65f70c3e73eda0b5b5ebeb2589a8cd20e8cfb98e749fecd358b5321bde67d86aab28f446e12233009155e31de7d356e859209abce43b0d46902693055412887a5b15609dd2a56c8aa2b7d11c3324fd7044ba5c8434837102ccf877675629a46f6400e3929a716b9a80b21512fa2a769fbb76b7d5b78e1a33eb12ded7bd05b39943e608c5b77f9afe2ebbe23f3f3f2c70898628502bb4b722c89e22e23e783fd14126f0e9e0e919bc8cf3144d25b293ff11bfdc44c0c09e4b98114e8b38c36dd036480a46d6c94bd9386b15e91c858209c18f639fd7107496ed8f4fa581e21974c3cabd237b3262d5b6df43058135fb5714ffec263c8841482db484d8a2fa1e9ff6b0b2b5460fe84d989ec2ebff6398d2420ffa934d553f50df12d16f42fb8ad632feb95aa8180e03b3b5c251b85e2745c9343fbb40d9cdbdff4cd9d0a99edfc0d6ebc981ebac8c82c0b852de9216c231b91bd2c2d968a97b564dc2b0ece5b568a09024dd117b5369c675bf85ca28513238242a4b4ab231107a42076962547f3b9f28b800b3245efbb8483e4621a70dbf56c6fabdf38669163d04b45be7b28f088c488bab66ea03e7d0e217eb5f0bc1051afaaced6e5306a2283ed3074e23c0abb9a743834d28319eaa0435d723638242b22d875a1aa93d0e799b3d0ac2f969f08150ce2175fb56805cb78c94beeb26ec6c7cadc310d474aae842dc96e9c7ceeaa89f5dbc2e221805ff48c32665f977e8fd160d64844f53538555870eadcafb2fd6f45030c22eaa47224e76d1fe02a4ccf1ad255f6ee67dea06070235bce07dc2d3bf1fd4a6897123beb467f483e8a5eb590ec2c8b969549a48a2fc7d6747f923018a5de7789fff086ec2c9d94ec579928adf35a9a92d280bce834906a4dc2a5ffdf2d9a46d742b8de6242ba7c75ac26fdcb6639dc6465bccf712193f645c292d6c6892ae1f8ff0567854f665ab41eb9d5c0bc83aabc21f8d5de10791b9411871e62f7635e19911ade3fd877c90d18c1ba59a95134828d2e1c1be2799578aa95565bbce2bdc04a0b30942a903ca55adc53f7ff17e7a411c8b30d5cbcd709c666e9387befb1e601d64b3e6cf387501ac448ee133ced5f85da6d24f4d6ff12918057ea28c34535589a2c969ba22bc1e349c40bb60347f87baf3feb84b92171c67c6a232e3de85863c35f5375a3be36d6c6f272e868cacd751e4d268dae4bebe805d32d3614f7b32f482317835436326e00dda7c01af878fa23e95d86d947bcccb1e3c88c72b6a79e3d763f9f80c01bf5a7bc02c35f928df3b4721a5697178017675f6dacb0248476bc44c4d00fdad7c3fe2c3b2b26d02e1f2b6ceff6837ebc9443660f64ccfccba99063f044ab859ba02fc36416d8b840a741d76590e15d3d43e980e663d846a137114d74b525ed2477090867e17441ab162dc33592f3aa598a3f1ee2673eb8ccdc3cc967c7992e213c6ea86120a09f1314a0781c66d2e3703d00b3e792e86c2942fc065ac4355cc16f1106e92a445a760fec584cb00480cfc52cc0f576b238f756ae3cead808016868aa2d294b5f7412c1e481c42a03fa2fffb00b403497588e23eb8da313f35b74e068a184e83ca7fd45aa46ce247021ed0777dda1a1458a991cc9c6183f615b2a8757ef66933768e7c0bf0707985395f6068847a565502bc0e2cd765f4d99c8bfc447d9b8a75fca2a0412dc79f7d12ef379c55eb1bd57a0d233652c015c7ea7a9c1201b81fabe7f97daa20e147bca57768c723d31a5bb448389fea1071cbb3dfb473e62779a5c9ff5e8cd2cb6e32d5acf69448a3af390dda1720a5f13c98188fb510df10a3af71e242cc610eeefbb9160569e856ff0b07eb77b8512bad473ed75796a7a9ca7b13f88378d2580603fbc2c4190403a03707958fd53c87280d9711aa16614285e02865a8933446a8b292760f69b515fc50564a1c15c385c4512487b82cf569047efcbfabe4a87af435cc83959ac1aaadd0c7dc57ebd529dea610e0afc99eea95f1c1d4cdac3fafe8637e9d855f9f0aa83ddbb0dfe82f7fae8b70726f0100626ea577f95fbd4d9a08e41b000fd030ba9406783bf3869cbe14d3f6fec32d209987c9b80b84425ebe4802738aca821d5cf62f8832581663499f53cf7325065b22cbe268e7b06d5890ebff8f11dbd311b8be1d9db785a3b70dde694fea466b07d8a4de1014aa8bcd2864b8272574d27df15edc85d75fa0b3aebfa69dbd1b2fef8c60116245d016c18bfccd7b6c2f592c39dfe5699a6b631cedb538d9a803f3fe413d1f9a83224ecada8c8a770aaa51386963ed3db5aeb666e0c362ce59da48e36cadf3e1542fa0b1ff145d5d872146af30ee4679ca81ed9d488d8f91a23ee4e7b936303871b36f94db111830a8a6e642ed8a7df83a13722092caa24b8e673b09ce67605c1185a82ac0dd2588e1a8127106ce70fb039c66cf3b02b18fa53fe05d75cf2f7d98d454d255899bec8acc2b051eeab46b9915de6c6dbe4d8b35adf38dcb81332278892f0f33b1368d10ec3d1e1a804890497da06a02bf73efab2346ad6290bfef11bd3c07cecc2963b50d70b59a949200c63f5bb1cb74f3021508356db0f6622c0b1496f2213538d541e941136e06a34cd884e7cd69cbae3bdc74226b7cc08968c1a05b26c2a9cb5eaa868446874021d10094d213af6d6777f6b67efc8b55f6e1b15bee474b90608ce52ed17976ce5860afec03ad674269d872357e876fb28c9837f59804ff2dcd07258c3298772d77b1779f19c2c193601430b26761bd2df1d9c6bea463bcc4269677e9f8412cb871a81d8799a3889b51f0e766b1ed9676b8040ce696044ac164b5e48054d2bcf59d2bf28bfdffae297ef94f7b48ccb3525be2892a85a25443b2e29936f9c9b7c5f6961b39f71375575056ff8922d5a8cda95f97d30874a119fdc50ae2d058b5105b3c7ea1baed7b3375070b9d9efa51192d221f89a469908a569e1e90454afbdb10601e51dcc92df380b3070290f8eb714d43d712f1959f20ace9c9fc13069f544aea78a27e73e65fbc289ccf18bf9b1ddad9268c0314b980e4acd19c6da79fa12bb04052adf210dd2eccbbb27bc606c21cd2ebbbbe03aeec9b0c82221259de3f33a722c85fe6fa9fad8b16f3dd4c823dac9cfe6dff6ed1285625bccee89d513c09ea8a97b709b556a173b3b8c3d2c298e16eaa28cd149a92757dcef866105eb89ddda8de78c70bf4e0c65dba716b1bd0cf548fb8860f02c63176532719989082459a5b5616d78bbe7fd108dfa9ee1b72a8f2065c301429693ffa394cde54a5a07ea8830f4a9cabbde4e4f04ce52156e793cfee85c129d43b74ebebaababb354f063e8d671c214693cedf9fe43cadcac46e69af47ceb514ecb4b47e4e74481794400e44ebe695af685c8215a02316d583d3d6e3c4ef11a9bb4a9344db73b4e50ae76b63485197aed933f3b57c071659d82984cd07a26b663fe90c2b9c4a8b668801d7b6cb51197c14c0c3df39cb8c2477ead0ecd401f5114e60962fa43a76ea9a5ebb9a01e6b3dfe41d45c71e11787505849b2cb0a4df2780610708dcaa09a36e3254c70fe73ba5509afa5a5b7a8e83d36906296eca8657c088b60f68fa6e6c589d4d61bcbc6c92f7319ce7892f4de3ffef7543897d8a70fb24c26facc6557b49d909c80244e77166d3eba28c548303d43f9d963f3f758313e03b1fb816b89c54649505e89d4f54e1109c53c0838b028392ae8f4141154a4efdd4d0fabbe107197a13618ed5a4ea64fba9f4bc5d06e8ae56bd66aff7d9b79e06d16c87de295ab362b658c099976543924825f29999bf73460038af70f79471ce029fec0c8c4cb1520e27f7be4f0668bd08e1d6092972ca51670eb1e94238ad8f55f7e2c9ccf9e681a5c24d6ab9768810cd8484341b6472188e6255997e1704367d465839e96e2cb820ec472f17347b3fa65dd6ef62af13f12c2bfd814c245c3995644c4aa34c04a6056dc052d2c9f87ee44117c2454dc167ae4d582f46c17ce0f8a9e9775833ea53428c151d20f08b2d24ce09381eeb61f7e9d0455c7d42795f56f641bfeb9da1c9a7046e12bccbbb9166958472f6fade2bf24d3205966a8f4259d66312778abc119b5f59744861ce4e61bcfcb1626eb1171fae6f8231a540bd5660c8a33769877cac81629eff1b3870bfee14285f5976cea91d21314a3586b38067309909e447ba8bd6f363ac16b6c13619ad4219816d15e6b6de2e41922d6d365c9fa68db5083a0426902b66d7cf03e9b10db1b91d0f0d4ae367c81577ed9347adb4560a1c59aa18a9e30f5db97d6315c0d207b3886604f5d4ddc7394929cc905072fb16941e2fa9251a6e1afe5c9fe8147ff79f9a516456694e63409072d272f2ab5a7f3c88c63fc8f651198fe9b05148e94c5770ac33064c5a9e74069c73dfc1563302494e50cd3f22208d90bdcc21a4631274ef2f75a6db84d20f145606824811ba579c1f038134142b721a45ba106fa1d1ec5a5c372739c28de7e4a4577c3b6eef220a3fe25fb0823c221a4917a2de6ae53d139f2743999916c19dca6a5450851eb9db82f8a008e68249dfd792e8816f53ac57b466dcab93f5adda983a82258d58263057eeefbba2085439faac31cb3ca2d43557e92818743863bf77f513dcd4cb4a5d5bc8510eec6396b4b1227345d710b0bb4448540d790523f8bc0ea222932f8272d481ee4ec54c85b394f04db6f423b4bd209f2cf37681f9122bbbec5308682ffd2347259fa6bb447c2b362d173fa06e3cd44687ef84df0bdc072c257c275471605f95536deecfbe00e5dc040dd7f2442066795a2085677f8895bd979ef3406efb788c48ef15ab5e54839cf45b71ca75d2930aedead41db1e2ef475f8920a54bfebdfbe9154fe1950e6845029b5711bbdb71f741002bda53ee696bad298725dfec215a0cd195c6c3529d5b75479fcdfe8f8c1c75b7c2a46f8f8a8e0f2830af315aaa3799d40d432bed5d8ef3ccdea04d6f1346a6043fc324b0478e4fde20ab209f5a23e6e9591810f0f63912b573d09f11914e9ec749b7d013c5dcabc64d353ee517a2f103a2f73fb28f19846081f50f6e887e9bc6168edeb53f235960f90adce5fda501d7d1cb40a467505f2cea285191a1d07807d66b4bcd4a18713cb807fb40ce012b8cffba9c2cf17f3da4715f5b4622b0e62361ef739da0722ae08c020dbca4a6052f6d904a55d2abb3bd423f1c7e913f338c135627b38bf223d9461cb8ff3786b73e361c808a352a5a17a8063c6585f685ca237a1ea6eebaf89ddddb50faec0e165f233be2bb2a38316731b586e00214288bb3ea000d4b91caef093e1c814d1967d284f2e79ff7c2ed13f660dee39f1929516811a5e2b0cd3615af717f6b6f8e6ed733acfe4b854187bcecc271cfb873f40d68e14296af7e2df9205242992b3e8189644d081a2e94141f05814dc8ed52f36529612363dfc95327aa3a480fbee16334e6bec3e7150355637345d5f2bb0afa8b70d16f472cd228145a635bea83a8939bfab1b7a12f838c31205b15686a7c9a058d3719402a6281c5a50dedb2e1a2c7c7e4666a59338f0c471a7f89a6f8d2166f1d2e904bb479f3cab3f9f3a477d5345db9d26268941fe1cbbf48f26bcf4f3375877a387221100d61e398e6025df0d40488b0c9376b082712877ac16c1d5e3f772283d55982cf23177fbedbc49bfef6e3c3d36c6bc8008ac0fa0ae8c3254660bbfd05e6ee6a810a323cff768880f96f2de51b398f648f6783828d711e3fd19e41534ec731ca384ea4576246fee3d52ddb5964f007e6bed715f90b682a21cdf66fbff6d476de501150212ce12d4d52d3c88edfc7720dffdc610dd39fca3ca23065e038b91c679e992bd3d6df4b4f9bc786eee0c4f4aa3632597134c0c589e980e1876a19616dca2a94a7911ae62c77561bab2bf6ebdd35bc475efb08517626dce60b5708a0a6b7f65b134ce4c4a3f50385ace2d43d58f48b3294c969881ad2f6983a2fcaff76fa7d996491ef044d6403459d41d52503c37b8b0e2862cb0abff498abce0a7244ed2197b53062d058cf9e08e299cf77375d79aa14f4f267e6316b79dead3067d7e25d35a8caf7ced2d133f3cd7b30eada73c2e2b50177fc0bbe74a96bb6fb05b7a17596892758b1cbd1c1c5b15cde9fb4d7132154927b78e97127e2a36947553b6d732b25a69dfcfd633eda573a56285b6bd49fbf9c7ba207e643a0f2f7dbdaff67442948c644f39d131d7eed94413a4e02d9952841a5b03c55ac08fd6fc1e56ee6e3ed5fac463b0ed53ae6c4a69cc09876a32d1c64199fcda0fc813cc62710522fe21de2fb54a5f3823ac170a3893bf9dae5621bb510f4917f36af4f30dd9b53d7bc7e99d60de86d265e555c44beb23639c867fee10f2c5da4df91d026e9c723277081e06e3c1a18623475ed23457ed0f2a92e19436b4b0a5bf50419f8cacbe816fce11a6168470573a916fa97f0f8d282de4cc59467ab09514d76624a45c6f927cb0af85acaa2d8fb69d41bd9da06cf5916c0971be35d2bbed4bf47b85eefbb4a6e60bac187a02b65deacac7b2ad1278e4663ba61377d2f75de249201decb481d2b1bd022c54f9162097696cbe57924aca3a7126bb9f6654f816a541f601423d7032a36ff0b3f52f97c8799065f300f076458eac8deae0466165a56c921853a07a28d3dbd4fbdef32d92fe0ba77e326444c1439dc004e4ae25fad99a169698f1294c906f8680f09a1c37c3907c3d918ee8699197f5204e1106902f8f23f8f7e446828bdb641bfd2c3c10bce444d9535a84548fb69a069bca0df6e6722ea0f45fd8e0c29a6b5a8c3789264c287875487e02a066b81f3fdb5d5dfa909c2810b7439e0493a40c7d8619a918c39aa7b2c868929b8ebe4db5b7d83889ae7af5fce84ef2cbe134efc011d0d3f2e7dcf3d61c9aa0489124e88cb33b8500a305c7a0ed7c646f7c16f4bdc24343f84ffd71ea5fc061dcaa26d0a8bc3f72468f5e6ef96818292bcab45c710c6177a1d0ee0daee431f078820900866247a975ef434a209c7c053a6c5490e258ca03567c0ea6ed33041861c72504393fa800b8cbf7d5e372e75411aace3598c555b309f364ace6e09fc019a764265ef2d8d8a98f9dc9c931e3775e97878e9a603c5b03c6aaeab5a1802c24316e9751288288840fb879378fc5729862d9248def8be00400f6503187528dac1ce6c0d527df40e0b20d777b822a04c22cf1dcd9795d86442465da922e337bddbd0b4a3adaf1d958df529a11b43baf603e07d4d9a315a7c164d14be9503e09a555457f56a433faa0e164147c5141d98e23f892a79f1d2c64799afb888ec6780cd3006eb0ae667bff312cb78b7b6521fe9234aee71613c6ce8126fc5b278a2b6ccd5b5d1f043fe9693f8f9d345be0534661c46dbd812f9d82b62e5cca0ff8c2307c35fada0f3e68f2776c37572efab5484b3338343b1ade32f2b5a3e0510c1d3e4446634632e20cff9ed3b28b34a4a7ab3feceb1c4b1f99e946c53571b7d949c5943e4154d7de762eb7464882535d1811ed1fd04af4100046ba98012dcb907563f9b9aeb564c4a8452d4007a89c972257551a8622a0a1040b6cee56537f03eff2e093554991c1b655424ed6dd576f9fae3d6d5687e8a7c7403496e2ee8db07294b892c5ef0ac5fcf60ce370b2951a2226b93be9389f52d32778fdd08ec481c15433a2a5325bfa58fc72ab83b1f8df0b1fea48456990719bdc27abf7d4982d69d64d746e9cb2c148bc37aee3f706d0436f72771c3db6906f1f63c2fea4d7bfdf6f78d764496029164d0b21431e8e6178ba279c1e0bc2e6a2a67ba17cf9d18806d6dbb31d261c688e6165c4d20d42aa613942cb9f5426c945efcd0342bcb37c0e0609be275d88fb27aaf3c4c8a1fa22815b99a2196a6184bd78f810999a041ea108c5390277f05258d5088a0ddbb4b75dc8a5d369b6a8625bfb7e66fc7c2730da2e70f302cca9eb86ea7ef1f906b18026b84b52802cb1ac92daf4340515c3e4bd9472b2de2544d017eafee093dd47842fe0eb61ae2bf81462a22e8421056b34d80db1182d832391392778ab7eda049b5f3003496b9b0819325e087fc78b1afd979032b4140d409a7aad77d44495a4c269ac38697a1d5d5812a2b101acdef57be2d1e9259bd0f3d92cb50d01dced3da1c868bcfab49ab91535e5c19cfaf7aeefde19d503cc2379efac695e947abb439c01b2787e38eb08d10860f6fbde98a5419865899148ddff4deef354c993ac2849baf15d0a31a2585c8a3e6aeb3312392b1ab27ebdfecbf6444717a4c9c4dcce3a4111061bbaa97aaf47a8a6850b642e6751176d30da84150444ea791cdf976eb68eab63e939f0f9b54fc1c7686706b37d547e7f4ec615362a720187cae560e043b4a844f819f3cdc8597f69b2315ad7912409912f2fe4a841a308dfca6a1eda89d892dd6fe7701d430d88b2d442b9ab0ac8e7dcfecf6adc86b5ebe3b208b8095e2aafdf94a9887ff276c3df50b66a5c23b1d71b93d62ee2f7398e1843f1778a7c12a0df0d0f4bc8cfd29233f9f7033ebbe32fca8e49533f6218420fe1eef292c2ca4d6066ab9c4a588e6691a8997e76095ec73d9f01652a73527123f8f64c3cdbe4e31f2113374ef1f7410556b72de2f9e3c51f813bf9a0622c28bb10bcfa513763e6cdd9905e315ef80bf48f94234b228ea9ac8e4fa4d61c08314d7ece1b76a8ebbf5614b7c1d9455090faa55c46f5938620115ebbf5ebe0f9bcbb07825b3dd9d04bf58b971cd0c87e2127c2b2a72cc61512d5e8ab59588d6611efce2c1f5c46c67d9512ac8631929ee7d4055d7fc7bd34656a78444df3594c9e2fa48f81bebbb832a27046f1ee7ab15816542e8ceaf8db13383b283324db28f436ef6643c797098b33a691f0ce2c108819779e3dc3a1291e3109f8a7a70cf8e2832d88cb85734c12b035e44fd6e212485859d9286fb7f3f2f194d8da6754b5afb6ae545736b651bb957a4d8699a565d2b1e115b115c329699b96e226601a7d6c328b2c9bc01118ae66ee3ff6e85e90f041676b53cf9b1a02f1e33d84dba50650a30b9343f6ea151b06374d37978a3639963fe63830bb49153021c592b7ae259fb6256fdce8cb05f0cbb5a71dc0bab89fafc747950384cad5e24f599b7846bfc460f095150c8dc6ca7beb826edc43a3c18ac514aab7696eccaba39274b2c3145a491d7c0c99f61c34bcf56c25bd81bb5e42106499e86f571f6d8cee81e1f5196e232640bdd4d54597a9d40fbe3a045ca9965d9891fd6968e67dd5d67a3fd128d756cc5aaa9d113d9d4dbe5f409de96ed7d28a5668f27268b61f3ac89c79f851c756f26e0a6980e6517fca39dac068823ac65c02ede9bb413b121875f1c8c5a539431e10f3ab28b17a196b36d161354fe2a4e611633164aced0568e27b23cd65d314181127069d021b7ff19dcd776ad1cb22a6cb4e597bef2aa82220aaa22c62450463073287f350f2c23ea65e25ad2c0b5cd3de144e5e2b721c04154dfff79980040532b19b5a05458084f91188378e59351fd4347c5700a089ca110b9221c31cb3794d096827884089064b0de6dd55af74fa16f0d23ad1b8ff273e361d61bf5fa8c4acd5599aec1bbcda7234e2ec20c90e45d9793a9e9de5420a80d8f217a09bc8c43ac018e431c37e02685c02124524fa0810bd661229d4e83e40c47bd52d1823082b6e6a598953321dec65d6c6d02fd5df349447fffa01664860f2a5420fa8cbd25e77333815a318fa671dca569f2fb2f0a22ea3d228c6a70c044a7e62e02682439d921f07178d8a8aa5a372e2483c99f9321b32044802b68988915e70afed563e40e1e9169521b09d58d2f5fae0d9c898c47e22a06508b6ba22d1e7da101eb373231600922a1eb3faa88f1414f898161e706d56adba7526fca7816e1326f370ffa2284e31c4b448b7315017b20a0b031fc4eadb65cefe0f1836efcedf18fa43b9a537bf87dd85aa7ff49a03a84d89633de110f52800f7b5db2443ea9db24591ca84752a6ef53e2aa9bef479313dd62c80e71ce5fdad476067f6e3d593d96057b0bda053abe9b6716fa42930c6e1295e159a11c7b371fb20faabab70d6cbf3ea3a97feb2ef9ddad9ab039b1b5db579be62310f4a2cd5882cff1e6dfa41b792b8cc3e6029cda56b9607b1bb6651b4472fa329edac31f54e87a28eaf13f73db1e372f7b6f25c219433576cc38760478f25ac6536baf240c7e558edfcd37b944de5704073c99a84f1e14849c12e89b66bb761fbf63be9085274dee0fe904b85c5634e523b51822772f9a7b5a29f1482ec51ffedd0af7abecfff2a3c0d01b605a72edd613d932097cd4b9dfb3cc6cb692c64b702b8f92b6c3fd20d131d00a23e944e7ee7e54ce2d328fb4d67fde599ca52e782970409fca11a5c9643dc4cf4af4408ee5bbf62721f6d4221c68cd49ef31fe48cfcf84a6dfaeb82ec645de6d8758a7d0e58bc9a2963d2eeeee212c8edff1e31677c9e732cd718595fdef3f4692e8d77c332db3aa5b334e059a7036d41f8b622b1b2acdbba90b736b2fa4fb3338b48d917188c47ce71fd21ccd3605d7b391bb5a89ead7175b27f861e8989497b768cd43646f3ba3a77d88b46d1dc3ccde05402c77afd13211703b0c5f0b1869c68004f22cb534440505a9215b0766a04b6602f233e78ed92203e205e4d96bb3bf657f4e9e80e00162c15ca85561551574e18a9a50ea8d49a2daad8ce511d5db10315a81d9bbe1b8c97aff70b3421eb479152acd982a047cce7a9380d32c6c98c0402770f5c09a8d5a881004b3014158dd9a328ad21ac600f39c12d76b3aa3e82865fc9174f296adc80ba58836bf35cdd19b2f1a58203c830fcb15945deeb9bcbb61ceaf6494a7f9ad9b93bfcb5cabcfa2aad55314425abfa0baea8f0781ca7a36cb2a3c25c630a28fbffd78d5cd88073990bcee529e29cf06827170b348e2705eb5389619b9f620c9c50a8ed61f3d53a5b15fc75c7f1d94f61396f80467b6a4d21b682eedfeaac1cd1d7240a26dd8528ecabe67a3031f4ad90cc3760ccd956fc92ae426a8431747e70db00fe9f88fa578bcc19f1a2388cfb5af6437392eca9946ddab04fad378cc2abc3fc86f8ff2528310e8b33e3ecbf3fc19d224341010a5b2d4a666abf8216e42f62f34537abde5abdfbe5a4b8be81fc8970c8b3e420bd499816aa848f621a43db8f3671ee840e1f989bf9afe9773f159585a95c37cf7983a5b85f0080be1ae3548f82c9dc09df6b7878b66c872e6f4ae0304e1cef78d53aefb2ebca1099f5fb1cc6906bd03c0a8eabbb9c9417096bea5a54c12eb37d301fd8601c5efb9bfcac58d872774c3ae33b6fa24d932b78adb2a48c97c75f570534892ccd5792037abd948a3983af4df84f97d41ba05f0b58823b24fd797e8b3e94477503dd0d55c48a46e174b6613c8efcdb107e7cdc6e401726f8668d37484c77d4f893041e622775444eb3d41458399d77d40ba3f9b2be243c50cc2e3fd18d0dc25851d87da6ed1740d03a136f73de6abe26ab6521b2c06d6fecedd6745cf42ea12a6d347806173ae3317b85fb34828cc0a0a65be8b1b546669aed97fde045c851d5ef6858448a7eadc1db931314dc801d40a5bc3f6f7ccd4bc35a3cf52e4cb95b4263fe3d60fe1cb3782f9462baaa93239618fd87231b9b4d19fd10b7a54d80087ee19d6010f0a6dfbebfa59768e1317fb6cd98211ed8ba0c230eea0fa188947bc11d78ca012cab934991cae73c8af4d37410770dee3a635bc8ccda32b09638db30405154c4ada26ec8d1eaf35f6d348f4d2eb31f2f428c8a9efcd929d297040a4dce1cd38fcbfd4bcc0c820f7dfd7a7ed7e64517fcc23cefecdc7fea43127f72a7b22f78711ef788891e4791dacc607be2c0cfa007a34b15451508c7620c70bcae00989d90e09823d6df0eb9d7928cd7ea9fd193f0d3756fc659c1514cdb75bb063215789a2973d7cd309b701e64dfa57cdb480bb4aeb10073e61756e22528693e7a4bb468a7184e5c0751616fb4014b3252a8084340c5e7ce53b0cb500ec9f6f1e30e75dd97e35e336cbb38c4b362011f3f02a8a41a9f11387bd5513982bec9f6d688f095f697b9687640752ce19f50bae8573afed990aef7374fe3ce6720f2a4a00c43cde89d7a08cee32900045c82ff7f58883fc0613300432849c362e59304f949c301f2db0e5ca26941b42dd14773099050dab46b0727d26c52ef092b45cf4d707243cdd04db58d45234e240b06d00fffed7d7ba06ef3bd6ea112069f745519f484e70bb8ef606b42492fcdd9ff35ae349078859e974ccbe157470a6d28438d27c1b61a0f5746095b546b33376f0947e7afdbc8f71182ebba222b9be10a8b1df3c88ffb43ae42401f7a6d5becbbbc437da70b7fdd06789b2e8035d7099d544ca2027ec4c8cf9e13d15fb389b8b36aa03c1b04bb5e2a2a9a9df79c4bc61881d34e16aef4cd4541fb7da5ca2c2bb1be2c7b99dca5b40d1f8f5416361c04d782b8d7253365473ad76e0951be6920b2df37505ff2496127e66059eef1cf61ad7ff574c90f742b7883d3fb3d1be3b844ab392e56fd554bf7a5ff6434fcc92c599565adf4ab31290cbc9d62699458f5d9bfc0999582cf1b7adaff6de6ef74bf21ba7d991f31b67fda3683ba1da58d86ca2ed79f6ae8ec8032b521d1a9b302d3f853e8ec6022bc9456b73e19ae1628bd796e8ed868350d91b2ff72b8828bc070274a8482936851fc88384dcc6f424c471578435e68538a791399881f252f528ac683ab7ea0e158ef34ae443f543ca333ac7188ab33986ceffe0cf9ad2bfa9766806b0642e886d7bb56280ea258f8e20d389c39caccf324183192941a0ec1a48dfc8910414945f6606ec9597535fcdd1d4148aa7b2ed59384ec09a2b5691bae535318e27fd3340c38cab0a49c55faedf9b66fe5a4c6c4d6efdf5a848670678624705f49b3baa030cc17a0b96f7b1a485424820e3b3af6dd40bd0ee24efc7bfe98fbb31b502a0ee81d2eae0932bd72acd8ea0a0da08ee05acdd52c51256957a02f556dc60962b16809ca01d2607c8a1db5ae5e8a21f0bbd38e726d40e214e84db85930845317bda931e09b73caa3783fb3e5ad9396b8c578b3fb8e72039706ef1f2016a6461431290ce4a2c7b9554182c445bfe79d5162c8d64aa76bf573940097348ddbefd648ea49f00f050dc3753dc40095222315a445808dbb7f8861be5bfb7ec570d5414efd986323a42094dcd8cbb0a59dfe1b046c01d5778b8566fa2263de7a688de1b5c1f903543b3be1e5005af1d617e2a6a067752c3672229ee8fd69ca402373a0126a7e4e19dd5ecc3cb6c9a0ad5c91e1b2b082868f156aa17043effbba38097766e507ad7f7674e6a32813eabf99c47540bd3758ec2b5a1ed8217e30cec2bdcd4378a5a23d7da785e9a7cf0d305a7c11d5a22e41185d96f4a3c2899e3ec70e957e9a3463fb414314696213405e5224ec96015348a7c02f20af26d38e00086412f6d5500ddd4c3cfa0d0502e512b2c62b24c83c3c544cd8564ed5c46fe3193cd31c2086aaf907e24290f9caaef1c58d11d077230bc33a331be466ed4b574a962a8ba00914bf687ce39296394b0203e09aa304ead50f320e75918e5a71ad1a682d985900a596505496edf9e40eec7330834141c08f248f6f75687fd46b0972cb29f8375acb374576d6f1287f4452363305979bd8da8b640a1d1fdf6a13b9368895acf173671d736bee7ce06f58f1f31dc8c18625248062676756950b71ee811969f705d44d3041354db69c329281328a70abe180276ed2443bb9373082b660a09a51192bc58ecb18695f437bc0b56b7f64b85ebaca59dacade7903c6511349ec719a7cf82dd74d2667ea723226dd0d078bf4f271a1ce613a81536dd085cc8a1a2acfaa007d631b52bc7621bd84810a60005b8a19f944b2a02dcf4043a00dc928023868bf94d6ee72f0d78329cb8557a8df645797738c253c211c305bdee6b8f10dfc1af18e77be9a1bcd84d974dfa7f0acbbf53d68422b167891205e5f586e83c90abe41ee00ab3f56402f2f4019eef20985cf98c7f265382fe13195af5a528b128b96a0de809f77a1b2ee11c10abe9a3997c485deadaf1d1823d3cd958090c63591c67ff1704316212cf7be2ed8eede4fd204d75cff7f5ce94f3f3f6b028b7bb69b0e8dbaf91760855bdebfa9887a2fe82bcf4fb7f05a86ef02a3f5be79fa3632a9d2afda7d34aafa7c86a364968e645695c329aecc6bd2af9819ee606376de969b2f8693f3e6c1239c250b11542ac8d35e92bb7bec6c403d440049ae0bbf571c0f3de45de8a4157c51f8b71334e2d0b25aed21c3a88a54414219094c128d0b14833e28d4201098fb89d42359860dc95e60a70f559c1ed8794988825ba91cd2c0e9bcf7dba5864ed5e659544bed305c02c61f00c5e9f69fcd6b5e3c21d5eac2ccd643b3193cfc78ec3c5fd53f3e9856e4a55b28f6aba9f300c512d67a288788465cc8cb1f22d33e0ef6475aa0265b038177874957fe2d46a13f439f3f9d8d81460f36bdc0b1c5489674a2a98bd7b97b1a388b169de555fd130741e67bddd9a002e3087e57ff8113d2bdf15ee2f4216641f1ea11fdd5295804eddf2d59973e2b6331b12ec8c1f8845f0de7f6d6758473fa8c450464c8992571e1fc3fe52943a6cd5ff379256357e35b6d0ad47f1fdbe0a6547908007c5d08331c057dc770eb8125a0f69473c37b13966e0eec49bb42b817204c2c05ea62448bf1927de603a42968a15abc805caa1a2f9ce89b3bc5c543c17878b044b6cc41fa3811f95c9e2fbbbcce760cfef6e2748c1314ecc9a396bb5cd1526aae341150ac79b77487558e5759a4126d4828090d2bc98515717c30e665989c4d0d858042b458c3bee875fad7b1143db4f2562242072cece824a334e2719d4a2189c56acb5b49e71a4f0741b1997be276456b65ea573e6da25a6fdd6837ae0a4b9f59952cc44fac0009ccfea580643a397ee3907161865d5f38d79f722832af51b417c7d028db50897afc96e9b724a8cdc1d334c3ac0e489a53cd81f004a0f67b53334b54c811dcb4451960c540939d2bdc32b93a27df8b12031a22f0ff85ed05640ef96faeadde6a097cb1c22c21890ddaf2d6a38c0a833327f623dd3f1bfc3839de79d0f44854d77d7a78c9b6736c59ce1ada3be3fcb3676555f4ddb0ef8ef0b13af0a254976978634329f398059e6de562c63122b225a017f78982e6a7d369bb0094ef034f8de504e81428edf83bcf66b1c65a72d5505e722a973870ec548a28b2a36e55a7e40727166e9c487087d0bcb266dc2cdc666bb96346cc4c3817c5c0ec6e158f22b540f46aedd9e3585237c79c7ed9134516bc3ae5a9bb0c716f6e57d413b92f9e8d55018a28a6c35dd82cabf51c4e16de430f11c09e5c66cf0e953e1aef717bc3caac16eafffa46c5a9d4241058d82b0fe59d12c667bf8ab4f4cc9b5ed7230aaa42e89d46d081708f638892d29c2ab364ed7a8e872f7e32d675c45a0bdc25e440b5f5a641e8e8334420c0df357336de371e5e7722d7227f74dc175ac3782d44822adfec9e95fbd8bd906777f2c3846b25a8873cb4299cfd58045d489b4982650c6f644290d3fa34f889ec4adb43dc1c489c37f894580f48d887090cd5a4179fb705ea5b959f1c27278a05443e3005f350df13a09f9f330c30a0597d05c24cd3d618c25a1be86f3d86ca7d6c355fccfe84f8c50afb4ac7ef54f62e271549563e9bfd5ca017f869f5d628aac4fe179eb0f8567de833707c2c136be1928801c4a891c57f06fd457c81955938e646034e67b4d69719cbeb9baa22ed213d08aa81109f6e3ee012488e79352656dbd666c5a0c60e64294ce55add550d1274ab1816626d951cf782e0a880ea122647774b3ca677b985b3a5f095fe37fe288d81d42eba6976ecbd5fe8352e9bee0ba51af0d18f833dfe046d6754b38ad2c7a9f535b683ef565fb06ee6dfa986e6bf3dcdc7fe635e48c731c2d1d07ab6563546987edd67bddca783cb6bb91b5c008c4e93b3402c2880a20090214f7e1885542375cf05c294b75c7ebcec895f5e7939f91e52e41485463f0046ccf5388098ba6c72d6b800977db852b247c89b13507991d2eb87a2506bcb7e3422402918ab1a8088302f6adbd17e45ab9a4ed093c267191596d24301e69146da853440ff820051389a1703cfbbad1fcce96057d4bdec619faf2008247d46885ca54d2725a95903f89dcdd6af94e6c2fa8d9101fa18a0c7d091087b350e1e35eec199ec8de76e84c38d3957dc4137bd62d57f41a5c4fba9bf27fc64ecf00dbea9c81ac4a332d0bbd31ba1f243f65239f68fe7e58b893bdc7e119734045f62a715eb05f511e8d207aba4aeb77549e75bdcb74ab12e80cca16b9392e701497b5eec3655b6b0090373e2e5eb8b4abb5a48812fdf3461b9e9fca8e293469bcc7338afc90c51984f14ad532060c20a5ded7e5857d9947d0fd66e7e7b9a86a1c03b03173cae85deb92202b9c51149529c073c7abb41795f5045a868b9b48f46c2e5e303d3f2c7ede8a81c20a7e7b5d7301410d1937686141921447fa4d1e33d55fa98c94b7376927f74d208c2848d26f1077e770fd117477fe9a1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
