<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fc10c733d69651d0213c7b0dd903dfb5bdd7596622dfeb4ac39510ff9df2e448d598d1823c97ac95aca4c0ed20f255796e2db216990b440a9d03b052db463b22ea325f25d422c77e0775fa50e5a6604e4da632f6406731fe1283c3d46c12e32b6f8e6fccd0fccc0ce421dd63b6bb8809a3b2e971886927876345f83faff45d284e3ddf1568b1a2972442dd72f4b7eeb7406c00e0fb9b0143db875120730a8a73930a7c23f34d346f4a2d1c34cb76eb0cabba2b61cd5b6cce2420e927117a9571adacc99e6122a5906dde60445491987aa7a9197f1fdc9632ad256b7ee119264734b4e71a420b7088c52f35f4cbd95e1122b1aff558e0c5246fa9123b9120473668d646a3c641b383000d2119f5554f657d0d3cf592e0de889a65ef7ddfd067c78d0916b0c49379d2871f49a31e59d2db4e3af5b5e638624e0d1a9fde3b453dae9f9fabec18dfe67bac0ac9ab57b46b3899477071cad809bf91cde8ff78a7be4004c20a12ffd4110fb798671db591fe17982f0cf3859f79ee0f60765657313f0bd7e2e3f14b9c552ad9666fd5e6ed47f90190fbc217b4402a26f9cc2c8f2d6cf3aca207c29bd0485601ea22dfecae6bec00390539b91bdd4d19e57c95665d97b5d0caf35fde1d3a5b92559cb13981afd5da30e998e2100b63776c527cb533cdf86f1b81150eccdf848aa34075f746afcc89d2dfec08b4bebde30f5ba84fde5babee430430a9c78806b181b1a9945a1f233c271566451b0b6e55a01b6f4d050bce47093a76276d3d192f41086a0ddd04ef54b172acc6a0544a55dca7f78d148f4a5f9613b4f136a06a5735d30a1a75bc30711dec810718473cb580785662047bd996549c6e1b6bfb5b4bdde60d3a0fca36eb0eb5179c674e1210c0031565ed718f917848c55f822feb02248c8d177f635a2d99c81289b4f118f17c9e95dac220e9ff7f8b44ac5d3fcfc69cd5e94270de5bdc493b67209eda79f38b0babff0cf77d35b1007b3589badd66dba6bf46a900930a2ab55f507390a7e9c58fce7fbdef49dcdeb8b390e64034c39477948addbaf8bdcdcd3a9f263327b951e611986eacd15483f6fd5d1624806595176c268e723826f7f60397bcccb5dcb0e1facb0f8355903b706d634724be44a23c3ea1497edd3928c22cba7fc57f897fbbebe0b56c1c36e56732fbd9f8917354408865eb7170210d0f2471377615b5c0faf14e33eb5c4f8661882b91d43fe770b912773008249f95131528fb58c120d15b3bfe8656d81e248815439857f3d502d3cad13e36b502127feaa95a2ba34554873c58a280469fd883573b1cc50698cd1fd5f10d02f5acbcd4d16b8c1816fcd513ff74288fd6f12c451f228abafe8401359e399cc44d9a76666a524febf50c24f5fa6fc234236707cb548590a90740b87ecaa4a9e56dd92ad54cf1a2f8ea13b14a05f5afa9d99f3a0bdca5e0155f3a9dc22d326f447e1458f57c916b1a321a77136edb4bcf0c53e1ba674bb8773b8dccfad91f1ae7e52356cd4366d946cd496ed5fea435343d26593f3098bbf42e1a98435986e0f3525279db11be2053d5e31b7f98792e18abf8ddd40a1153d8663f5be7a17e09fd341aa132f0dc0fe7323e0492d69f3d545f9b316b82a78ced959306d75023639f96e6264656f9f8f806144a75636858ebec4076ffa971dd81de2a15b009720635e5544e647a2612c81e37645837e42452c071b5a1a2bbe205ba2bf664767a9ab664996143f0becc5b44c9e5a9e2be6084778949bc223b902f113e9e915bbc405f2ba019a24747a627ae0bcb65a3afe77a55f37351b723f7e25288a8bd195bd71bc186738a3d2371fef28e96c0d46bdf8396138308ac84b7a31b3142c5d296f7c072ace64a2d09444f724bd93c471781dae8f66994e33943e9a4f04ec63089aa7f44ede6f3064503029692b9e3d05d6803fc93ae504eea353f72ab2413e4ee686400de1770284c0e00f5923c4b304011f3f24be39299411147f9715df70f9e0ae4b0293fc82c1f9e959d028dfdffa5ef56d1ec68299fb919b01f37a189dcd9e346c044a378ca0afe59b760cebfd51f5aa8c4af4539f48cf4eecc62b6af543cbd0b1da9606ac15ab9674b6e585e37835f52139585d3bcb6fd72078fb0c0f49be4a3fbbfbe7eda30c594183425bf73a94a91d2f3e2322d30be6c547c434f54e465c206cf0765bbd690d80ea6490df745f6a0f60d32871b78242115bbad40b59f09a45cf1a7e567d3226947fba52c547d7268a50b5068551756b4ff9db517ee4316e8118ceffe7d29813d85929356141bff688e68a668de8ee079f4f88919aa5336a37a7322df6bd28aca744064379c23f47035dc356ae929e48889c9aded446002841ddeae10703b65708a23b4f0fcac0ee21039e06272cc6b97fc314e3779844ae997f845c74d85acdd018f6fdd29bbe13fb30193d00c2279572142d0f344fe04040ccaac07533ea50f532818f2ef14f8dcf535dbe54e557a9c4cd90be7fe75f527ed32a71ed400e3759478671de0c65e7ea2835bb9f8e5092de08a3f88ae188b3c900098c00079930eb30d1e237c2494c5f46c78c49badda6b71870a9ef96523323be2838dd82877fe87509f2d7c7e63fffaacee08094aaaf5a1d8a049c35c053ce89396ea75a206873d15980c13dfaf8487419fa459f58a31d7e349b569344f9827426b3cf9457cf2ee9ee2b7673df2fba981aa12c9409b34ff229d96f6fa87c2484a703b76434d2faeafb86603433745d136eef4f80d0cbb4df1a8247abd58e6a9aec22722f81532eef23dbabee620b41071e92d6a91dc4efcb6a8014ce004ddd90623529cea9d089f3245c9c2b7cb342b639fbfcfb61867ac5608229fe0c6b9752805e38444fb9945dbce8a46314569dc097c5c13ab323fd10a30e4bf8bedd834b2aa089b8fe0c40adb9a92628d18c43402de32ae5192eab08857ead7d7c6bf9fd9ebc6d7f1c4c424efb1c5b1afcf2e6ab0028980e5f8959dfae90b3a93c57fab2cacc2bba5f7186fe4f835c7bff59c27adcad8cdd590c11dbcf8e02072cf239b04cea55c2c5292ddaf2b7819d86478bbdd48d6925ccc0ec79fa9a8f60b2ce2b8b5ee584cc2a9f6e9c3e848663b7a6882539185f746e9e13a14f4720aafb6d7accc06c23b51d60d62db3f7943e465bf5ae3e07a039c54818b04a6e6bbd6f83702db29e85914d30cad366a60848c1959ba42da5d46526fcb741a6214caf0701f20e7a521305bb1682268617e28315376d1b1ff09ba6cbb34c2728e3a3a1819722a152c56903f30d95cd32e49dae82810842639e87447931fee6436af699489d6186371f881fd2ce646315cf388f9d7d08448bff7579af1230275b5dd9188b31673866b0724d436816f2e07b8185c58087eb8520286576ac6b80612c308c7b57600fa8c74445bfcd8d9893aafc2f3b024acd4bf8fe0fd215a2aedc322c6653af662f6993f571b28144c4d9dcc234db5b0aae2d55842aeaedb318f2e451e0c56ab08b94904858a998872aa9e138f488ec73afb2616e8301f121a451a9168165e3280a46aeb026600add8d762e4c23d01c6dbb07da32312ee9502274754f25e5236d4c815e0103f13d63108bbfebc5c28b3cc0a26e5b8223ffbdd30674b1533aa2529d4b6c93d85b9048a6129d67e41d99cf9b30c40ee8f8bb50913468e8aaf043e7724a6cd731723310c70c47026506969b751603b80c71751a1270d95d3902113d0f97fbd1dea61a238a8d035ec7a7d53e36007715763f454aa9e8843f69d11880585f41bf33bbffb293a1e170eacca53a0034969a902dc40ff81fa8353dae05af8ceb661cbb74d8d79f2fcc5eb936d94e01e2e501f35f276c96785f3778ad1aa39a1da34bab6aebfc94c1b20293986461fb9ad3bbb20f096efca19b68910d641de48165d62f7870c2ed4be4ae54373e947b32a66e65f6e619cfd5e1720031c1760618da8b9bb1b94fa76e908ef98cbb7b342a56d647dfe9d255e7f10c2693bb293ccf7e7ba56836775e914c2691b6f18ee600492ba3e5e46f511ad2f9a057cdacd69ad5cbba2d301118482cab9315c96adb71a24e352e16efb2c3fba885033965a4e05d0714901864f99d09fa36d7d52d803a36444557b71b5f61715aff8bc1eafda27b0b6c13496f5fb3bf11bbc9e0543794458999b380130ca23625b1ee6fc28338dc26661fd8cf417d9c00fa32b0fd51721e818b84a004f2d58051adcea0424a74cdd364f4a9fba57204fa0b8eace5e881dc411fc6cca402e1f16fb21e6f8bfce6bac2269b1bfa5a8d694b15253ba259af240bbf0eef75eddd778eb371f8459f1f534fbd25d786f448b8b7243729cd71fb237342820ff2abd4309f79f20bca3bd370a0cb64a79fae72210a4099f2bcba818bc01a67cd7c715595604c22748e250f840ce4d410eff2c2c54fc2523e80ec8703c205e0f0a79b2c293ea8232fee27060e546064778f800ef1f7f14e5dbe3a6672feedaca4175fb85b1d8323f26ec558f9eee6593132aa2daaa7eae187f28b3ea3edb0408764fe001460a84fe1b97cd2ff84f7ab10a795845078fa3f49231bb8b5734f433cb2eb8042d5bea49902ac0927ce63846f2f6c9763b997815a43c9bf9267eda8ab197a4c61cd1c1d586d2c393ae3020feb1a7b4def8c7e638933fa7342054bbceff5812e2f2f69dc35f27161d0fcbb26652b5dac9023e023626a68995465fbd0835cbab0f202908224bfa9bbf49e610c054cc464e847631268a07430e133622d868de1a13817dbed8bd353d2c0d02852c326481d05d1daed3890626411614bae5a8928812859f33786999464d3285c5cc9b2af0a656ab0d8068730f6cd34a5bede81a8241d7bcbf518aa6d2b915a3b54f81277497e1b6dec627119e592cf14323bd32c2e6118cdfd81d5ede9199cfc27414cac6fffa5855994d168b191259105e4352030e90f1d2186fd65ffcfbdf243636b6bdbd952e16176f4a961e05a8c184abd414e78d2f27c49c9f76b4918e873bbd9c237737b3e7c695c9ce912f96b7c2ebec73148cda41a2aff4efe1f5232fcae8dbadf76cd0c29761e33d4e938ac8ca7b1ddd35f1f6f9d87a9d4dba8ee973313e1c7b90a783d6b194806ef84f668ddf3675d60ed32df49a4aae912b59e7d32ee4729afadcdae447d3b287fa6679b49c3dd3c8b333c336eaa780935de516714da004d55d68be7c3db2d6707b0cddc8b0264068489c19727c89d0351d4c99cdaedb7e4296b5e074b3bdc76afa379e2a01aaff227b428588b85e39c6bfc745df3413fe11d4b7f10de964faf68e969445fa9697b593c5f755bf173d3481504d04e36c4d61fdee9f39dab6141b7c44241fd4fe54da5a807f866d011dab1dbae0ba716781017221f3bcd88246d50f447ee850e3ddbf5b43a8ebe5d3817191c3df80e556a60f85571c2966230d633b2685ae28bdce4280dbc259dca38cf9f4ea40d75034892ccff41370b5c2f138676af256da133fcec4adca877e45c73b57713371b74cebbf3d0228168d0222d0aaa746ecdda53868d3ce5094b96eedd51df883513d8548c569167478046794f5b8c9f1a81cded3383f6784c132b5754542e30eae9d3b0e217964fcaec8484fd26bdc9939ea4936c6a3a2bc99a8ebe9b09e88956793758cae3d6e7cfe8e609e4ed617e60595e337e38511fa151c4ee42d126f3814db6d70854d26339f2149631372281b1f1713dd7e8c3c0aaece245ccddfac05ea7e7406f7bc8b0d8c8577d7081fa048056a90199dc2eb48308f30ad17105723f64c0d98bd41840a6a92c7fb2022d8a4685baba0ba44f7bc324762ca8c49ad86d7e3912da4ed1311a34238a5b4062dc245cafeb6ffdbe891c8c0c05025672580d69e5e2ae89f432fced5bcc56e4ea9beff0d8015d3ee2b73a9121214d156d2c78bf86d8806bdcfdfe76d7d768c7ac162a4fd11688840d23dbd2f4f225b3bf5d299f8bb399b4f7f4bc92ac2702ffff65e3d991beaf0e31f4d355072f660ad57b3eb8a11a69454ffd6446859a97d8c8ed8bbd2859c195a62ce445152f8c661322bedf89ff5a8106bb1b2537b2c0c01b5ad34b7a3ece9f12b82109807113702fefb99bb3b1a4113089d4804fcb1482fd028620151a2083620cff4cfeb85a0f2ce2c8bea97e1a4955a705fa0595264cff63823b67d37a0a1f3e8d6cad1d9008ea783884757f8184a506dc87b9c3e605244c2606b39d266747e5329e038611c44002281936082cc58f7cff3973a9972b7cbf1526e479c249f6f602c8eafc7b3efeab06109e127983c92842addfb90f376b0ec778184017f3c8471947cce135bd13ae96d06e6550a1db71a073a67d21e6033b5b1d98a823ad94064b5e0843febdf971f39a28769b39d2ec9f4230d6196e7503ed1c5f20d9157835adeca6825f2bd5626aff66891f63714e7506934b0aad09d836ac6bdcbafda05fb0119d3a791a7a34f48dbe6084bfd2126e8c09b08d6b178a00cf0f7eca32a6fe86a85a0c8fc53aba92cb8cc345a121f6ed85ddabae0193a229eb08a21fd9453af74ee46d0d1949eae6374cb13822290f4ffc75dbbac1ad787accd054b87fac4ebd6f134f8bd2eb3db33f551823867966c6baef91122fb17dd39a2352a1946cb1adeb9bfde2f0783a172c1a0715a0f07de5a6534a66d329053f03d9779299f6ee2245e8524024764f9cb9b7ee3ed47ce95ee561b6439ac6483c3401d8e994db7d118de920dbeb1cb836f9e39c8415c7b7b9c91cfd87279af523ace52ca5482cf02206268c6aed2529d88ca352c54344903c68af5713130f19e459c214ceb5cd4e41f29f6d2c42d2861e4f3823d0014ff6d0ce96b66b70e1e4b28edcaf80394e7e8b66f692bdfdaf271634cf2d160a687bf4892f60f4e2b4be396da13d136171d81746879a986e89ed84fd71f191e06f391942904dbf149fcd3fe368cc39ccd7f54a7fa9d0c695bf35460edafaee3a760e1b3f48c3f861dc6213cea58bcb524291071140374aa0b34d245883e41469ce1a0136f1ead34f55694214694cbe6777b274d82af9904db5bf846d5cd167dbc105ea91414e2e3b6f712fec365a790ef145535f2593aa461022800502bae44a5a86ab04756a68dc1ad7ed832cf38e672b8a0ad2ccb3c60d1e5c3d46746a08094f176f48e9aa0fa8eaccf0843f1fdb000020a40e15494a1ca73799724f37f63123fb01b6a0eb4b361957db577c1b40d8598f5ee730f12945ad14e621553efde38f5624c8060af883142b08336e6d27e3c74017f33ff09768ea3505c6781e8bdfc72ac8decbcf120ac494fcaf8b082c0f2c3ff48836d84f3040b7da745e94ee03be446c4b45d2207a2c37560a84c1237b53773e5b4a25698b6ced30f14f308604409c0528654851ae81d5feefcbb6c86442659ae7241c7f0bcb11e359138b8d83822cc3edcf5aeb9b71ae91ad943391050802f881e806428e7bdf50ae006783e0a0de05d07dfdb24e1087e94a61c48f85a8fd778c5553af4dce5cf979369e2d2fb50e8ee14ccd09747779f9bd88bc5e116e5b37a03c56ee21a590641c38a5525c66ea0367df083669c555b2d2534b7c30521341b4208d7a2265486a64b379256aa883cc1bc068f4b9120f5266ca75dca422b52655fd333ca886b56a814fd99547e069ed1ad7ae2b26c34c10c62bac83a4be2cfd2751041248b28919c645243bb8a532a3715651b03e6eafed49d827f3e917c502c061a111a7a1aac4e91fce9e2b82c261f7d0e26b1d5ea1ca9438c645d1d2d46a4ecc05e3ad0019759ba13eebfa0771b543c4d4507b884ecf4965df6383f445e4d1612a00831b7e43d945b25683572edfea0431e8641cfd5647837f4debb81ceebcec1539c6ba8f7e9e52e90cf7d1facf1686a1291a2af9e4f054e84f361bfc3e4e3f6cf230102cc9eb93729ae438c4cbad923b0b89908001ff17438b92c72833163163116235284f4bd07af86dcfc7e9bbfdd50c63d4fdcc5e269f29e469ceb404433da3a08a77a07d0e1d9af540bed5baf3e11866d77619a9795cbd0880522c3e7388e7332a8d55f9ff8829bf01417b717cd6594e6f1ba44e9b7e717255db4ab40a34f7d009373ed2c6d8f22cb1f901ae2241a6928f0e1446cd5d78c93038b40daefdd7a930846d92cca17735c32e1504de4c85311b59c91d1b3bc69c16b6c024fbc015e2c65b973534bfb09321f0dae140d2b763d5633d9ebb0f3026738ce2573bd731c15e79fe954161af1ea4d9ec264328d587ee95463aed64d46d4a207f77d3ea203794c82a58bee08efcc1958893320048c8882e77f78c7ca4e73aa43e432d5d3f2915e238cac4ba903d5ac038ae82e8cc5feb67da23fbe673155e91f55a243c52dc149e7f1679fdfa32c3934103c3b9de541c0eb667e7c39f6be5e2e1cd6950cc69ee69dc4574d700a0805c17c162b40e1cc641c75036bc6868991c3556301f66e386d9f92f3e63cc5aedb4db32e314a524449ac0709a0996f3d52ea7c5b25bed829c5901e5f71edb1462e4e3e6ba7d40cbcbfc6329664d0b39821f61ec3f4a683ea8d599068e552e55eddeb7c1c02afa89934a54beb357d461225184fd927847c28d8731f7435e66f5899a313a4a5d826ec705b90aba102431f6eb640d6b592022904b3935b8cbe507199d0aef3cf97def6bea6c082b8db442b04e092bfa6ace20e5901e86e90a49085d1486c306a7696c383e9a6c30cf9d4cc2f43483dd858c60ccbcad87bc31fdfe908603a2d0496f2dd151a437fc2733180fefc42e71ed75733de63823ea05700158f6d969c38a69a9ce580d985f7453337df42270393ecb70021b562d8bce79e5c859e3331db6012b55b6785ab91f797c3102936420a14ec841b7fe589c0106a61beac464340a4d4f46f54a6df0ce49ee097ac5aca0de1a2f0a3c8a4fd2ded8ee38affc1c5bbe79779b6e55c119f4d8649011b91e69724f571b1cc935739fbd036cd146d7b48eee8df0fe1aa66500ac7abdf970061c5c550c4a88c700244722e3780f9f6a1ce86e420b4fe0e469c1c8e044d67d8eed56470ad1fa28d528d299d25d3737bd7a0f04d6ddf0de0d9ad2a7777ae457b7e50dbda89e58e66e20440357ec1a053da5f5b5c1aa941423cf7fc49ad2a191e3c4a1e225e533e5a26a6fbc1cbf91aea93516fbbce95739ee0500386fc454b932fc9709f6a77bfa89943ba2c99516e6a8f40bade1e63dd02f9afc4b866404bb4a9df43695ca0603168abd90cfea62623e1a7a24d9f7f8ef587c205b9005f01427377775a0f771d425d92d44e888f48615d72b765b90a81359f49b658fd2cf2a613655147ec9c018fc93757ce92dac1d8c104c62701853eaed3cca783694f471d037a77c3a6ded597dc28526c06e7aab86c5e2e3e5936a203e78cee7e1f5a293b94944bdb8469f4971243ceb87e125283f5d5fd037a8db8615030114cedffb0f035fa703d23c9c4dddc2453119f09398904e38512ae72b75973986088f7366a49fa6665a36767b7f862c1379935f8034de93e3f7fdafcd8f3a3445f3b7d6b42346b94741811eff053058c7dad548968270822587b4b9ccb54fbeda0cf57c66aa837e351054dcb0960a6c8cad12727f616a33c0cb92d150c0eb13fc7934c1a0d57557b18fbbcabfd6c002ddabc52abee26a75875fd49dbcaa9b167b71c20636b02e52d117317f25f11d16b3d87029e5d804cb27a6e023ee5472b3904e3395fb76f3fd5ae9b11517c9682ac288539c18308996c7e219ee4cb4d5d8fbf18c1c17c4b967b621ce694ba41e6009d0983229a3b389594dc3e0f5ce84ef133e6979dcafb2f3d4d61ec625234eecc69030d0c955e58d7ac66f501f165c423c5aeff76cdc0c1c48037ac099cef1017cc2758e40875f22a36cd93068cb579c9b93fdf027056c241b2a0a9c72e9d0347be0755f547b1b236dd10931a47c4113d5d55cdd2a0d2de0bc9c5099d0d02682fac0e905d5b4625365affd030e0d7da35d77bb97a605dd250be68ffe4888c63946e02cb54bccada91e072b712152a0bf9f3d664171d850a3feaad46842918dff00d079fbb3d3e9b99fa54e07a24cbfd6b650aa69a4a1a68168e79a197fc66f2d53640f0924cd881f124e8c074b8eff90f504eb1efa437708b38ff32d3ebe0af046ad49c6dbaeffdaec4139d60a701bc2e8c799c61491b9c6fcf084fec50511519cf0a3ddd3678343a4a32c28492a2a20781527d3899da94f70df15f17203b45588f3c6a08dd73ae06dac8907531a1123a715f2ec499cc14fda4cf89a3b22fef1ae059638922887479c8152b28db9436c8fbb9e4431f97427bb91b887cbfa97ea979e6493682f48d56f40b59da9c5804580269ae47912e9334472a5870b5e1cb56b4a9af5a0dc8c270dbdd0547b0ff3427c415a552dd1b27ac2df8e5e17b605844f6d7d90102726abd6aae5e5609c7ce878f9cbbf711d77b954711859ad4e2f0156417a3abc499a8713a50e6b08ecbcc3cad5eb81e14db573ea67957b8e2f21d482e1f16d5cc67edba2cb196762a42afe48746cf036e7ab45b21fffb67d1a75800f72d807130c24cd3456a1e59dfd958f45a3688b15ff7d797373b39387418e0d4f43c23d5f6aea814257eed84b99524fefeee18373fe179e7326a9b54ded9d54bcab197611a256abeb106198d2dd67fc4445756ec5c1433a0c52101a43f2d99071a1dd053b2093cd9faa6b13f704b720b2b5eb57bdeec2aec6e867aecc2c3a2a02018e4e4bf3c2a8933f5f99fe521a22071585be0d41a640947265d5edbf616572ffa3a86d550f2587e364c9fd9792b5c641a7115597a0268c02eeb26eab0c1f607fcd9c999274e25cf8b22909bd2682169d6d918bdf564e9b1de88e4a55b84c01b530094d0cca0d35c8a63d35d974cd30a18f2c83417afe0dc656e52d75807e55413567b3341387b9ce41015d431d2b1df52b2d77285ad99775f7e813a18b4ccde02e530a0972c42a199476be05a4eb370c6d36f5ce673c4f4cc90ff00298adf4c8246d0f111ecc4a9a24a288be63bb1092de018698fa87612fdf64f9dcee9099b7d7cb59d13597bd40113a3becb39544ad88f6e31eccd989fcaa98096dcc715cbbe5b0a8aa9101ea950859ddb961143327008a2f37520fad3af2b9be9a910e615b7e1113036ab6a01f920a5c5006148004cf264696a08374601835d4052fa5b5fd7b1108dc6204cf9c526ff114be7745b9966bf60f7842e801d093b19348ae7ed7b029cba36eb13cd2547b2e230134550bd0f2dc6bb8d248c7566471e7699230f7de7ea844491f7fe0090218e94f521d18847808c54bff87380f7d3da1f67f6fa41d3eec2c3c21cb68c632cbee786075e0c9f88a33dff7c0f2e19bd819bfd9424aa7169cd24caecbda79af51b7d05a17bfdf42d322fab618f3b9fd9cb7e4d25cbc96758f5870f266f5c4b8758c8888e2253a3cd47a60a79bdb30545badd79b86e72d5775329a28a38538a86f0669a9c36ea9c7288d2b7a07a79fa4f84cbb7ea8257ead66a2708fbd2f90c1f3707a6b33185d1526d348f823be439e26b59bced8f8b8d927ccab6b864ef9d5827e3058fd7ccbd70a2dd4fa6f5191d99de34eff33013a68514d8f359031a138c625e02c90e2e41706a42f0234049cd0977347527ea52574288431a2da9e21b4ef86654f0dfd4f33fa89e2f1677603d12791217eed9154f2c35d5b8b1dc665b77ba8a0997ccc5f1448ec828f6ed671d22a07891c48f6392f3c4669684f1c88444463a77ac2e956523eff3ca306dcd5befe974fc18420d40faf0346096cd22a6346d337ebecea3126af9ec0b91c6c5a4562bef34ef314c6cd4e73c48cc825f2ef80cc28d9d7a2337d7c318a43574dc7b89f0a7d54dbb6eeda9fa55ac7292368a8e66eead9ed8ad3a02066f96777e68a2190e16bc68b283d724d2581106c3c09b2a749f1dce366576d84bfe55060922d2876e99c9d48ab249ed51d14f4c7949e3814d5894ab38dc1f593080006d423626a198420281db77e9de7260ff08287d2d1fd7b0ff0f40613981598bb3e239cb4ed75b4f6db838ee1394771ad8b4c45f9716ecf77c84967be08bcf2ee9888d20c5a350a0562b62701253854a8d19d2ade4a8f96534a290084917ecb959becb544eb311770743c7f5d51f2c1df06a7d00450c7008ce6e720eb0d9d356f5d1d1a9b57bd5fae9c74461e7ca2267d0ebceac74af3d80422fe4fb89fb7a3f1e3d7f306533361a85e5eb9e86fd0e30f60764bdb7539a104fe8ab9ce4310cdde25a4e034b970d47db0f5109ce03fdfc8ec0f0ccf3efe8c55aec579370e92fd6eb7870dffd9235ad6d9a3d87228551bd8c6fa5934e02249742f6bcdcc1a0747ec6e3055f80c884609130244681e668666185265733cba1e4e0fdc8908adbc9996cf800b52c1909c06a6c6e6890fa308bbf53e9eb6bd14856ab2b4d4598cbdf61b6bfdeacdb73148161be379893947a9ac1a9917eb0a420f20f14cb1a2fbfc33d6876c4a86833016a675cd42d2cfed49e0f36ae840118db057e6783f238445057b7db90278a3fca00e23e703e622d51a6255ec17a07b02fc47f5f219ec733e08ec094c0cf1d4a7059fbb19377723351c86367c5b5ecb46322ecdf2a80331fbbb5dfdcf4b96e90b6bd540b5ff988865169ea6b3529fbfd21ac7dd5abbfcdff04bf760b58ba512646632bb4d3a7b211122ae08fe4187b6883692d1098b2331a02995d8bf6e4636a62b9e1b36599b67752c1117a6602037bd75b26966b3c405f62a80bc7c329afeb89658a639d42d57dc6c3cda43d70dbf7cd2abf66d73da9293f70216d228e017945d8297a7efa2c76c3ae54eda96f69f3f4c27a84f84c6bc30198170b51f2063f52393bb4b6b2dc79364d2789c47ae92d6a6d960e1669c9383e1975ab654f51a235f9050911d6f59820246160bf4c1e46d6af9e34ff4b73e8fa40d792c3ede9f53c47abad9d875d0ae77025ad33cd838e1999c30297c150c7a776301a51957549847fd92446f7f4f08df2b99020ea52f8d0464ae5988237383b533a72e4a490c8c9753d3dd4a2b3f3e42a819664ffbb47e92e90d10504357a1c815c175279ab207c7f286d3fc231c1861128d06ad79d34a994a8ef50736a3c600cd4fe106d91288b5a023d5ce725b9ef83366dc7da590190860159f6d1831597d5e6652172ee29126cc9c56bba09557f855c35438233c385d7e6273ab533fa85c99f0be7a153c8dc1339de4e943623396e355c5950a0d53aece1a255a4738fb34a702f43492c7aad6ddb3c2a98ad57422ea8b3e8577a78642afae5361468ebf8b792707f95d662c9f7acf14a6607854d828ac3faeddf23edac7027a8829e74741cb0b72e2762b1fd5ff951fb8060755090abbc72e42ab2d71e75f5ad8b7dfdede62e9c0608b1937e3e8d65912f6df4ab4497eaf5465245486747527d35dcbe876fa46ca749d700b0e885c974574ebf31178f0ef872007aa091aa467db7f4bdbecd06d1bdd14d7da964a244ee5d1f13c41822d354a3fc15e798d6536f8b24f36bb4993a7b7a921c2a5675a7ae64e86182bd958a69db3012f502c5fccb1e76ddbbd9f69181ac21a77ff26aca943fe09e07940e66f23edd5f21a9e0e6b5a34c76b83ba0bba5fd79934bc578b7ef8acafaa4d1a494066f342a61c9066215f4cd2dcafd8f776335b62be75ff6cf091c7bd0b589e474f033bf8952ebb14d79864596945824803f11ec6238d80b12000e9acc4dd4128c2963b0a8968e2de01ca9e1022f689e233e8db43ed696dc3c1d1fb624467f35cbbf12863a9acb8a688ce57854cb3b4bc299643f348cdee02541e75c2ab855088e1a4141543145afb1940252d98c502d75dc3742ddf4611e1859a278128a82b9560191a8c9aedbb4266655fb50d2329c112c2c059c81fb503bc434da931d94050fc26bd4914c3677fd7b3bb73091dd37e8a7465522ebb7f01574ba71849b26a2227bba193879782f81099a52901357916dd427baa35666aaff8cf1104781c80b139a2d104fe5d5c62ed2a3ab1456c74b9931d1291c38e9d86e9b9f9c725d657b98986c1bb2020755366d2edf93af3aa5586063a4c6476fac922da17fda37503f755433e898bd7294f12ac534f85e38752e2a65fd9eccb91cc0670f0a88f761c2d8b22fa6ef676e1910abc7f43f88980c4313d2d4949db1a8ac3a431c0e44572eb72083998d6e48d6131c5072d39c321ee79cf5133a3b1c820b7f59ead482a9bb0f869118a2ec6ca41d362ae064a5ca745632ca5c9e002dc893ce449e73fa53722715f15519b01a53a227b513832421d97f62ae260e93f1f8bb33a5ec0faaaec4ec2eac6b4f716515919c575b112dbbd03f3c2b534101cc1761b42c896576a4861908d82ce04238abb248dd0b035cd81e9dc7b3f32f2f28a60ebd2f31d3963b6a037ef320d6d061a6a24e42e1f3b028a5fb45a09768f14d0f66a9c682187f4b3078cd532b4a3352233316cdd7042b458a8a38e4f2b8a83578acb5e140a2195647e6cbc3e1c6bc37f63d845e319757946b33bec1bdc0dd41ff09dc01262ccf7233dc5f6156050ae4cf465d7c63968dcc27cba44ef1cf8e6d3a585d17a1a6327c27ad5fa950de04bfe75943396971a60b54357f377c29e33a5a360282026ed061ae957dc0c1788428b13ab3dcd21f431668ac114594c5c44ee544c9629211a91ddf003a95cc8e3d02d284449b687edd12bb6451bd66fc7576a538beccaa55fe15b0b4b3d256d4bdf626d695dfc99753966831f4bedee5dd57e98f868cf49d1c656ac2708b474b9a9c475fd6ea5cd17796de911f91cdd5b3a361112f500ff46f35b8da6dc1430828e3783f0819f24f8bb2ef167d98f7672a0487b2156b331d2ba3ca51a91859f59ee1cad12c183bc1d10abe4b56b30d9506c8339f8b8dac9b117dea6bcfaf1d6b3bd2c041885f4477e400011892e2a621a3ec5646917695eed86ee5e8c3b4a99aa32cece1109e80fec27fbe67481e31c3a8c4b54790e23f177e5d288c5651dfb952d35ffad2bac074061927771b73810c9222af02296c668a14e835be7ee3520c71b92c6256b7f45ddd51a84fdd35b0ec25552cb25a0c3f12955c5937c44d28feaa593f081d4df0323bced13c5e261c472c2f8fc5086fe92318cc3dd416012bd3c4072ac9ce41320853fdbc842f4bd8f7ddeedd51b65283bf90e7f8f6f5d95971ffb1acd26023c01893cf9635dde9fbcd1deb8abf423101ef4c51c98b4808dcee40f1ddc91a1b964098515ce9d8e833e950281e6d8265fd102e5b84411218aafc93a7a1839b0b98506d17a66d4274f59fd8312c904c83359b1d161eba403f65ac330931df62825aa990b556d247bbf6d4f0c461414d1f6d66baa6f94e68f26971875246231bf6befaf36ed40fc43314a04743abf188004a57d41518748b82ec0ceed2044abed801e151913fdb30755a50fa81623ec26982c308b3ca3361ae5f480f359edbb6b51ec5750cfa0d02965e62f3b6bc06289804938bf407328612a83ce017c1179f1243ac0e46bdb676e26dd4f154e6b758dedac3d9ee8119faf52f7b2101417af5cdcdbb969bf70ca0a420911242d80212f786f54a3c65d07201a23beb7daa3f36ab016479370bdcce4cce39993655d40720222832fad050662efe66b5506b7f8f0b3422d1636ef148c859835dc6e4685a8771289664328b092872e10bbf67402fd161aa329657e99dc9b790a0d1ccbf445026f09bd3efaf8dc68f9276c311b087f74613efea5720a333da1eebfbea7581dd7022ce7c8cea06d8259a3b6e1df2e89d5d03dd2b6d9d2970f1344a78a1f2b73703098ac79c8a3effe8c470584cfe41324d5d912d6ccf3bc273224a6feed4ba725c19940221fc26d181278af541424ddc94abb843b6cf8b74518c2222ee86c674ccaf28262b5b8d921614ffa68644acf5cfdaabc1fe7634cf3ded4dcc2523b0a9d4d4b9add3fd1761bcf7e2437fd52b673e72f17fe8b75dab65bc2680887b6c3643b0c76011e85b605889daef6bf5d23ebde624103590bfc0068d342301ccdafaa9fb00b03424d26f1b3f052f434ff5045d11e791a2527231c536b42c52efb742f92a3b9fef48de987ddd8ab03c7dfb09d1823d27d3c09ecd5e1c42e050175f5cf63e53f9dc550de83fb7f9dbf4071c3b243fa1bd95d766670999339f68bce50722aaa451c1674e97d5b6b320377bd217b31c796d59c71ee70d1f0a4bb2dedf7b8a08ec04ce6fa0627314fa37fa34ff460931251e65fdb98627a69d3e44728fb0a55dec2aac19f283e69ececbd340654fe50bc74f6dde94a8313f04cd8d6e7f8723a2655b1bf204e50d2fca98d2b42a7b52b28cb036f6069483015da6f7e6dc5f3972531f7e210168ffce26eedaa48236e0857e9ee0a4675f7076536533f7fb154f5e76b0c7917b53ff3fd1d25f95f0cc8afda8b595d045880b464860d96d44d3c97568c3f0aa56b8750c928de38e89c835ea294692b6c44965bc91902791875a12c4d3098219683b0dc2efba9850b653b480af6f0d559d64fa057ed8136d8f6a6e0d1ad402b49e3baae5c9f81fddeb4f88e3b9359cc2ee46563492043d99f83a5cec2dad36bce4fdce91acf4ad2303831640af156e130ec9a9ddb109bd6bb2a31060cc06a6ab24a7f8f95a93128761269230a98c6d07bd9e088bb3b29aeef7f7dba4c0ab8b155622fd217389ddf046c4964a3e811d0d20724f8e2c247ef75b90b1a6bcf99d2df7ac3de12b498b07361cfc431e18e872fd390c349a5b724dc8a41ffa35dd52f2e81ea7b60f1e8eacbf79608c285e7587b94257b7dfb78fe7ef364a476066d230adcbaa32836ee8b5df90916c921a6070d18dd651480059b1ec0f3122af094346f084388d568aa2397bb0a45ff2a164d793adbf10fe0e1a7864014c9a16089f986ec6d14f4166d87ee47a541ffe9a5ebb17ceed4be762b3db6d34c98a289f965fde408cc763ab31765f32572f928018c58fd13771cecd1e6f3b9ea824556c92ed1130c119acf41a34792506c17578b24989f224ad215babdeced1c19389b9a9bbb7b1e3a3b8e31af2aba56ec7309033c12a7a199fe9fc46c07a01bf38bbc787be7575bd38809d5d2cb5cb0ae05c693a9f1bb3f7bb88081bbc8531f9726074e989db126ba0bd3c9ac61d59836510f1feb50ca3116ad47781b5bdbce7cf54989219516117ab39beb68ab811c67d171d96777c1c2f9bc9a47b553a1dfaeb7eb2da312a1efb1888c7d7e27178e61f7e3ad0e3da9e355f1c48433e01ceea6cb935484924dc1106045a0420be390d9b79e83d5bb9061621de25d366b3b4b4fd33572b00081a38d45082eedaf88c17c2a2074f6b06f3d2e8a8004d7e669f68f4df4076a58054df2c4801f9d7b7fdfff5ee7b2f79b3ff78edf576dc166156dd17e0c15e846fd49e3000676944a57683fcacbad76288b8ae67651a83b0eb5b5896a763ebbfa31b53c48eed7fb1841099465f2390a2ce180c9d25d4dc62d6edcd0e048b564f3aeaca6c46b6c8c414f7b0692b2b2beb9873af6b545ce0c69b0fb9f7c47489a233996620e355e9a876fed8081b0cec16663303fbd9abb5dab0e52a2ac82649764f831e21c46ae6f374da31d272b783416453a969e8c9f532a263d68c8087fd780edca583a31e05ccf8a3b9ae6b2bad41136c43ac59c7b8a892a3a3f7d9e2d0a416740442f62e7ffdf2b6408ddb9bcbdf9aa726660e16731e7218f0d80e9c054e310730e5c8f4ad560401110f4e5c543c91cc48910dfbb3ec26b2f28b8fccf3203c2bfdad01492a48aec8f5d1af50d754396e5dc3252e91584bd1aa093c9bf11dafec907186384ae14df68a04fdcba758526a575ddfdf4fd235a1ff2bab6bac86e31bda683fdda203f7c174838f468b50ae583365e15d14264109195bfd6f20c9387dfca98717bda351bcfda53ab99809562820600adf35fd120733c07ea15e2236f1da44073c1c86f162cfc5fa1c25e9954d814e1c6b15856bb964cfec9a0d79fb7f43661317806b57957bcbaaeb6995091db9d091f34ff50155bf7f844589ed858a0de3bf55daeb85fb01d6733c037ce1e1bcdc3b76e3c9cce0245c3c251c99e1c1d2502fa476eb781e38653910d19faeb5394911f4194def0ed731c191746f124e0864a7a044ca2b9889d0270f0ef0ffe91de967c92a503a83857a72482bcc1ce380ff77f89b08581907cde423bb6c74683422f889fe03a60a0bd3ef55dd81fef1376829ffdd25d11df5901a4f344c4882c20a0e349864bd362021e9669d7f29fd37b16b6eb0609cb7a009cf422699b35614150f3fa04eef6577a8376602f8f966290edc9a14bf53be75556acf281d5d31c6d46a0e37d9d14d38514d7781e3181411a7fbd2db73c46fc5f8c908b998a901651c0c7549d4a241c541152fa7209fba1118c328425b0edeadb14717c0e1890bb50fc341f007ceea4694deaf5c4a394709ae00cdbd55016822f437e9245d3475b2d0e9fb1f205dfe424e5b1de201962844600f292452a34fdda59cbde8ce3d2d6c44504edc536e84da0949d87ba73d8c5c8daa4cbf6eb4f8dd176daacb99cb3071d0fd498b757576eebc34775d4770c8d9ea7871fc8812dfa4f03d31ee5be5008e35185bbf9e0529ae513a4afd3a22f10982b07794b2a3a170aa9afab1490b4f140fc67b76e0357865dbca8dcb70e148a8cf52478b39f0f06b46ea6ca8e034dc35d4dc05fc6ef7531c3affe5dec15112cddd82bee1e5d53d9bee3ed79d9c5507e1f8d1c3b8bd51fa1f4d3dbbed69ec386a31926316b3ce219e1111240f4b9c2e577c7bc57fc26757883471ec8e2adb1ced0f237da9e4e28a632ac8e234aa3e3008b468a5dab58b657a4c449a185a8341657f6f9a2875b69cd648578815cc7a3dc1c17f9dad376bad604f139a257519cef227f40523ef7f54b577f86aadf4d3edb59afb93d05fb4a218f48641baaed799db21ba1b39703df1163f4298c346dabaac2dd6c970ed48a1701feceec8a374c977d60ccaafc0e21d85e4b822f06bf190e6acfdb9b1039e7be5da0ada28fdfa1ee8eed624bbd9d8dee4bff25e557792730fab23c28bcdb1d66ec6dadc70d244151335c15db9ee8e9990f78005cb33d0044e41b00876c151bc6d45bab3b9dddbafea4414298929355aa5ac58fb2d60271a89367e3a7fc329928b2948965ff3a5bcee5b2d141c2632d7da18f95c42da0f0825e526d57b04ec78ba4f8f2ca49e08a35454d72c929040f546ffa2bf8fb31e3a783070767e18c63c59b2431d86abe32e4501ae99890af5a0a608e6eb18dde9a29cf3e5feca85f6e15c7cebaa163847f5abb7e8815bde951b9cb1bfede5aaa9775f7165c1a64d980d757d679760269921ba3519a50e7d6e083c35431e572577070cc61667d058dc39a070525c921b3ffcdc654d02116bdefef1714f54768351c87ff0213c27a358e0ee3f867b9784280ec752bcd277a89604bc44312aed891fe1119874ca90fbf0091228486dacb9ebc2a91ac5f5f7f9714c9d6ed16ea2dab8ee25e653a3618510e45d183540054f6ac99ad5ed77cfeb628f2f2dd1e8497f6ceb15b4734d1f16a4a65329f30efa5c19eed8d5ddc48b2652857ce76c9b442d058cccabbab8556f8cb17ad9c329de2c1e615926944e1136a59fff43af57bb064b2f7cf330c22bc16d924e52e1c380b3b77d647fce5723b0ea5cded31a5e96f45a6dad4e75d714632fe50123767884fbb0942d7e836556ef6e1ac874a40660c24d6c89eb7b869f6ff1d294feaa7202b4ebaeaecf5f5deee934a2e56d95f9185a0c6e3bdb2bf6125e7cb7791cdc89d2bf6f5cb0c1b0363104ca7095a2b5b313784073d87bf7c66aab7f07bf2c3a2097f48a2e6e9f328efaed7416a6726c57fce4d7be892ced34fcfad938db97f20631df091b9635ffe8228a0f9dc9d0cffa2f8988c64df05d3b36136b1fa1184183beb5978e161dfd3622ac3812b62a7aee302837091ca8240d721a96f4d54b671b55aff02698e414ccd7639b499093055d51b0339af16f2f003935bf61cdcc7e30ff3fa3fadc2225c3a328fb0b1b259966e3f71fa9bb006a692a945eed16d1feb8b4772618e410a23a227ebb937122d204c200ded8d6eee1fe098539b00be7d12c7289ddebea721bd58a55c5fb546fb7f25a78678d003e4df0a148f517c1960f3aad18490be5df508a47d74039776f7a5973558811a147afd9fa445d45f6b4f36561e093d6bb804cb9c9714ff801179f97ad3d2a2c0337e77a049cb824e5d2278a8981adddc9a7d5ab362b1730ba9807fb3d8c279ebb6815d2e49e3d090a2f3158c61be46227c390708bbeacf9a6f8695ee623072698db710c75d79f91927cc9244d310007a483955e59c34e270416a027fbbb459f01d496d277c81c00fecf32b4893411baa5f4398f042760f17fe5dff8906f2f88f1586d8d3fad924df5ada04da5199f007adaa6f39f53e2d1c60ba6be27e125ecf39f17fc8a16a894ff263d6ebf242f9b5847838518bf469411aaa8b502dd7835374d8fd4f2c8cfe652797ac47e32016689b68c7eafa5253af2f5d861ba1f3b015d5626a491c713df137c05e6be3c5747e1d2a2bc1b08168bd273747b88ba68195130b3cb6e8a6c5aad87d52259a534c831cf68facc1b98ec01d9107ddde072b699b4447a56c0873c94a93e3a6daefa56685ba8ef8c5dd0777a462b35cfb97da631b7b620b4883276a13c3f92a7570e59fcef4f785df324ca648d36d4b6f92fc81e972676d5fc32cfcf5a28292abd744e1e5c010f761f306cfe2ac0d7ffea3d84a1085193fe078b2b1fe9f9f43dd8353d8f7aba1a8a286bea7ddc709b9bf7fb7a4be78f6aed0fe7f67c88de422bb502702a0e05fd6488fd1d80fc02de8904948dc18e9e061b078e30675967c0f8cb0346f524b1b987b467ba4e3c58c808af32f96567d99f01cc17b637a18978c53abc02745868990f283b05d8b5f478a5e761df9f3bf305514f60adabfdf7c58e6023311ea3f6cbf3ad9f7e802ed1a42ddc5809f944c515c16d8cc108c1256881fea6ef51d12bfed5dd3911a8f9a5b924bf4fcf62c44fedb14ed34c051bc41f8c6e2063acca45dcdff8eab8711accc205ed8fae6d6407ed7627da967b6498a1dac5e2e99c3ba8c4fec0d178b03c442ae74f7c0693c15ab60047203c7d777d5ab57026f0ea671b73c7d56ca5bc4777e236a6cbfe6aecbad9d45f6f1c3f51e1f35973809fda05b85e63aab77e027bdf2530cfe46a6be43676be5b5ba1c23042d52e6a4986bba8f56547e771e52c0397d9c2c303251ab40c771bc050a9ce625df90e35abf3247ab84060468596fc02ca1886d040c0b87d884687262445ff067f40ed65e3169d00431de9e1288b431389129bb32b42942c72f6ad011ddbbad2fa236cbe4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
