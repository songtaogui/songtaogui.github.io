<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa8dd8275d598a407104ae80d73e0894e9d73043a9ce5637e06dfeb180dd75939f9af6913c86cedca3e1c1c21587808455de521dc15a9e35b7687581a16de0ab296583ae91e583efbe5c9608206d8977793bf00facfe6bbb7738e116ed0a17743afd5d28b2b66d665f637b2000193a05357759a636640ce70f55f88d2d44fd34a05772949997554cd41432d611178689ddd6c16acc6b77e709e2930e604d6e011c944340a76ba424638f4461c9ed1ecc5b269d2e4b9f7250f7e5353076dc7b25c77651de054b2d33a0028c2e2996da667cc7076a8cd76eda9d4a10b77d0d7dc965cc38094cbe946b09e6bb9aca5d94e33f5553380d2171917c2bdd54ee3f2ec8c975926cb3e5761050d141bc65d2b288045ab356fb2c539981c5edf899987c04075ba17c1c5181936d0c5838693b2be40da7694bbf368a3d677bc7a0b17a62aa0d3fe3f1d8a542a50019c95632ff68691c0a0c0bdb17bf9e5da28aa5da107a72fe76fa03b06b1495617fe52eb81c5899999e757592b8a6d70457ad514119ae3c5b4f39c9d1e75da1e7c5a2b49fd1ef89858a5ad25fd84e684d7a3f47c41819271d896612ed470b641b37f2793b7bf302b7bc0a3b6ba931df0f5c319bfe1c17584f88515a3c76f1563d1fb1459d08d154f628bb3c009efba547171565d098f4a859743f27cba10ce0680b1f77bb4c9b559c36719b02fd73aa6913fdc3da9815ca7b63bb302e1ee17ddf6e7225aca807c729c6a1cd8f8aeffa8053b03f6d94adda9585405aa4118065a0baffba6781be8f938fde63b8753a00fad6129b2f44d4b39be63218e286f473a6faa0f4c7f4c1c678fd7528106b40bc39f4ddd05606dcbcb12bbbaa4af4c3537a1ca6956d751f47a1888fe02dd2667ea2f6a7383a0f9bdafd5199a4596fb380ef9ecadd52951f8ff43c906b61999197828669fc6fed923f5d862a3648269567cc08c34f4a9af5e65f5c54470f4e25cb2cd8e44e88fbc2f8a18adc409a10d9bc55204ff69537395f8d8f179e33a9bd3dec3e951ef745db012e83a6ac6d0daa64dc1bd1fce0f390b50b9967bbf0e9a7e178068e75e41e452c4a7bedf02f5a32a27967e3550059e63a12b1115ccc4509a2903bdcc7db8adc818db33af7becbc946a0496f9f227b9958bcabb6b51c0bb261c401e965ae4133e1f644fc838b343077638d7b81c1451fd5fa64e4452732b8e96b29fc9112d4df9452ca4fffcceb1c0a7ac6d3324db5d723e63006cc18432d60d217157032efba06e74175a4352d9d8aea3efeafe91142622029b2798e76ec5cc8b983a15e8402738a89b04221a01a0fd48ba42de97a9cf9a039f22bffb44160b5ea255343917ed61780128a85fc2d82301313f8c930433c8de722a91f8ddec60b457d98431c27dfd7a678ccdd0ac3dd8017e0652ec91f36714278a850a53d6706609845a221d193898acc67eb8a44dd729183541cb34241f0468f94f469fb410f46ee71a58429a435eb90c4a7aa492f115b21c98a010fe1b7aa7a8beac97ade948838d22eb8e1d5edbab6b90b581f17692ca9fb3eaf7f86a39c776fe5cbc41ea0cb4392ad9e9749f24dbaa767c3e788c4c6a0e8029c4fca703350db8ce487ee33af5a3116e5519415bdd3715e3d31e61e69cb3014233e2fd4ec9afeec0a844e4528b285fee6cbdebca2ba340a802b6c1f85c420188249738ccec080c8ae9950395aa99fb1a936cc2a4319b5c5ca075fd694c13a86340ee1575f111e301982b5590a260b3219db774c5f330091d590665c348df1c55729d8bd789f254c3b3763f1d96a3469ee56529d79e83b0704ea3a94e1a609d929461292b4fe8c1958bb16252dae12d4c0a92fafb94aff2f0b5f0537615094fdc28a6baa9f501ba6e1feeda0ffbbef04f594c9a09c55aa016b3e8e5b929b35f1cf753b0188a171845d2cc6da5056c12836bf84deeb3c33eb2c4cbdba68772ede9ec94860d66b999bcf17b60637f3a20741ca2db00789043799575e0f1d59605060acccbdc0f4ee127bbd30649821776365d4ba8a6d9a3050b611272ffabf366cccbcb438fcd5199a1a64f04efc8821dd180f4349530201290bf8a324e42139b00985e253eb408ed3f4d180e6e32d4a8f31a0d41f8e5446175e4b8295a1510a9043eaac77b697cf44dae823e0e70bb556618f91943240ccbc33f1820b4f2aed593c929ca8c00a816ecaea38422b1ef271ae616042e87e1016c2a072a4abbdf93130cb2602de1e1b0d0acac2f76f182d5ac30515b12d96d53bbc3a27b642e4b6044fe1cc500fd51659ee65d897a1015bf11a8537ae4ca2a1fdd0ed77114495b3e864fc23d3b4d5e18d459b64d0d5316fae48e66216f411f5b826e9a957b15e643fff5e3be963732d371b646f1f18fc988aaed010e8a4bafe6a7eb26af20394fd88db165aa2b4154c7b2fb491bca89dcc00644373eb5c7dd4e6b43ea0d696afb66019f31a0e65cd18967030ef639b86773fd1caecc158c1ce05d7f82035e9d85c92ec5e5ec8a721307c4aa68e38b834a3d3e3b6918e89b38b02bd715748d7b146780c62d259030f7e468aa011ccbb7417a8541a6a185964dbab7874924f583b4ac6423bf3090836dce11a96d3ea2f76feb989be484e4c2877fc77e8e2a8774e510b49868d074fdfa51f54d15f4315a780b34fd3fbd028974810d42ccb5dbe99392e1a6474bee6e6af5218fe83b42dac1221de8a6d94604302552dedf67c9405f3b06388ed4590c16f9cda82595bb0c8012431dcab119a7af1ac369b015e4b2a9765d882e4c6c435ffa2f5bad89c74d898a1b0984af6d71135da5f6f9b8457c5d98715c4dfe98358f5ca534179f80998bd6fe52b6b6fb39ccd8da763ced091e35b56825d8cdbb8ffff1fb41f6bddc7dd6ae603fe4cd40a0ea75b7eb4e12562c2edd32d7bfa050cf2c1ea860c94a609f720066aaaca6184ee105d5aae861f991f492faf2237a8257cea86c0ea42d47e81972c921c49510ffff179fa5588b794a292f8e21a2d61bcd8e647a601d2a19ecaf1e970d1c6b0c14f8eb86a1fd76f4488ec444ab97b39195836e2531df3c5d3a9444bbc2097e6d4e6b851977a23971dfa1258df4b5f71690ff683aa67be23e53bd188f13d7b16a10e3e2760bc3f5e07ba5443ee48fc83c2c3c5aedeacee5aa87236b6b0724dd3dc7a999aaa72db7a03cde32cb03acc0b7c7bad4a8cc28fda99abf61b90a0584f2660be5cf4e3238b22922ec6010f6d9cd8cbb2b573ed9e8323e65b01414852c89eb558f0b3eef8b18949cdb11d948bd58cb90e6c7a4689545b0bca754faa74f7cc93be7629cb833233334ac54b34ff13b7de5c2f19318377414b6e0dbe9a094700a0317adcdd9e4785b52feae13dc8d3ded9dfa908256f76a8c649a4a797cfad74bdd04d108a644b9a89c69520d80767c4da06b41c3c9a95a7b7050f51f8816c09bbbe4aca32aac006c6444da97e2c65a5529f9126a599c7a3ae8b39d1ea176552311dec80bad2f195cacafb52e6f1f7f54dcbd1b2ffeae4d208dd9967037abf82ae14b49420beae253c1e81e15cf550410bc152290c43408ee295227afd4482615e0c7cf0ed0d27313c708ac1b1cb8cce6a37c6f420ea45e1650b2c272a1996085f4a77322a5e8d2c3669b430b2bbe4086d40db857514c42206e530668c874d3859b024e80701325fdcf0ce452c7d8f115ee249aaadce5ad1139e7b3fa3245b32baa9168ba36f4576d644f7c142da327fdfe28227ef27acefe6ee8e6f5bb8e1ca6b414d4e41abae9327e9225feef954253f5acba5e4612bd29bca8a20b4aef11dcfde2e826fad3e19c521f1da59a95a86447c26f99a682a1bd34d4fa37a2693ca51c5bfb28c49c12689c2c72024c09bcfb7af6ac42af2c16235e51fa8b1d7d633d9206e41c2eeaad56f22a9591fb24a00478287d6c59cdf5f75cc45e21f370a79c1ff9c53ebeaa11988da8e2181bd4240077cd38db44880ae9bd4296b11765c2cc96b3e05f24511ccef1b56ad9fe0695bc8edd13611469a21d56996cf3f7314a7a3407bd84fa7ef96381bc0976a98f6184a69d4f55b1ddc424d4ba3d9cd579d2632062060593e1959e624c1c7febcbc7b4a113ea83ada25b723f749d9de67dc1659e7be82b983fc98e8dfa72fcd5137d91d2bc3a60e9d6889b91e437aca795b0c5217ce28ea912105bfc33c4a4c013c9c04931d368e0177f26ad742d165152b1991f2512a2fe4d6feee555ff3cfc71b8ccfc57d7e38715667060a52af9f57cc782607fb383530566a9c08d4719c1f0f40b41b348eb4859344658eda1000e145d99262829679aef38ef50b48ea7120665ddd7390c44287088f86a91d12d0e217661ede26e1c6829ade2d7330b6a2d4484870a8716e2aa20f90d11804e91b339c5ae78f3ea12e20db7ffef0bf01315d8441b12322e197675c03880e90d61567db999dea3c7dca0607c4255fde9aa1402e837bd7ad0e6acd82f4282018100710c9b33307c977de5c9c0fc27c96750965980a2a74510bdece4717c37a18b18385e513d71df3a85ca85694fed72e2dc7a98e614fcde56ba921939d3c9f016706a3bae2c1822f8945df9c627c290ab7a9d9df6c9840d63202224b18bc284fd855b2766389fc085e424eb260e32d491e5719a9d502e0c84e44aad56b4e5abf76ed21794687a7e12ea530644a750cc7bc69d39aa09629ae0a3a98a2e0a2861456997d22f180bdfa4fedd011a6d8373f49ab4025ba6622002468737596ab049b63a973a27a92adf3e83505e09ddf7a5380a41382a160c5860bd552479f1c0fc9343587f295a442a554c6da33e4d69c73c7606e4783949477b11bf2845f769d40e68ac86e23a39b32038ed8f1a196a17f87938c4f678f683fd4a3aba62276b3b4247f5df9ec4d88dc61b8b4b9aa60856b6ce6303c0cf23e7965d2d077e8b2bb7254b0feb33eb06fe2847994996b7383f5eb0435f9616b39b334e7831f5bdac48d088d9962d97db9442c5fe186b25fd26c31258dcc4c0189b312f6251fc58fae151b64efbfd2da326d77c9467f0f42d2c4b86d2d3aecdacf2704b05723c8c73892de2287e04a703c045b2232e5c20223f55d5d076465c7e4e9756ed600cfe5e3e9ea9b09c0d8b16f1af2dde181e551c96d600f14f7b8e0404082fabb81b85c203c06e450c5dca5b275c2f600f01d7c7385dddb9f3cbda250a63d1cea626c38eb49c1b4836d2bbac473b5b54426e0e489e02bb3f9e8bb7108c0249a6b61af9907712a88e093ebe609faf86ef8e8608ede4151a962b682591bc4e06e2d030fb94e6c5e26ca430990b6d95fcbe17aa386a54c6b686bae5cd213e0a9fa6132688a282355040f870f02c62ae4ce447eb7e46a198dd9c5f089cc3317dc14cb1979f597e110012928bc2fb573d72047ffe732c5376099978786cfbed6aa96aae993e63fcd6f526d8caec59614426bc3934d418d03374c5c64e84d65361e19b66fb7975a9a16ee8bfd39d16ae7c89140ac62c5f9c68d4023b2f59e00e549b064a55c15a05ff9bc8e5547ca0b04e2e0c81f28c931a734dffd944aa74fbe7e5c8df5e2ad76b768b291eced87ca31746c3cf908ecc6c0440ab29e777aa7cd3723b87792da235768af9802f454184ee543fe83c9a1fccba79c6b1a2040a9738e8ab4e9787801ec297c3cda1f234b94eaf72e350c00ce5e1abed9b12cd62cbeda2e94a2b99449d6a7a0b92a9194092b6dfce25d17177d1dc66e81ea52d67fdf2744c430413b3c707070d507a92ce679e8e52baf0f36bd249f979013eaa435eb15173ce8bb3aa544f31ae252ec673f9db2e1835bcc8eb3d99da361313f6dcb358fe812f0844f192dfa25f0907055cc21d49246eee5cee10822805027b6b9a9ed5cd8dad6110b89f59f587323f07204fe3c54169f5a85e8435368ec71b5a431172ab47d6cd54a702adbe192a81a3c06e7e350425570f930cfaa4aec07364aabefc909a9e43ada9991477f3069d0e4d0e483a79c26f1064cdef18b08536002a59b82325d8e49859066e504a8667dea0edab25950741c9666acaa3f151d3fa3039273ea06ea163a11318fbac16ef014a5c5c646b4b4050afcd5c03b7c9491c37df34ba334162efa7fcffec0e649aacc1f20a2d7acec848f8b6a9d006e2371e0881cc50192a5d9cbc54a748c77bb66411005afe6f765336a199caa985aa11dff47dc7823188a810a6407d0baa0e2c1598d65e1c8edd37a5f4f275d52e3a803f463de521c48a53128db5600e5076a93d2419fb795b12cc018f78e50a1967913f3c25fdacb05d87f0dca61ab6e1b6f650118ee2d1485bd01e4ed10485df189b3dc8ccfb2abd6a17ab490cfb356961d48f08d962350107ac6a7b2240dc3fe03772d573e568ae1dad3b46fe4593faa6796cd9e823ccadb4c8e16d81a42e9a4cd685de0b05bd5838a2b99f56c005830e80ed595639294162d5618939cfd9ed5c638ee0749357f6f6d106baf1a5cc910da4ada13b4c6abef8c591aa1f9688b38e4c3e57b933cc7a354c9216f746d709dff8796dc137fcd3ac941dddb3f49a05b01a81e9cf7cfbc3c97209388aa069f0892985f8e40e30d587353a3c5b12b508cb8ddb602eed550341dd7d6badbb80844bfe6bd658a284ef47d40db17c15a8b53043d2ff99bb44fcc85fb3eb80668ee790d0cbd6b0876083c1bdb079b3280826f40f91696dcfa7bbb79a35299d0b46058c0fb5482e83740ff0f76ac74118b10a5b0c261f7b81eefa51183569d4700fde37b22812b9e73b6191fcb57ac764a580555a5a35fa99753d2b89bd66d1cbd1442fe0e2c3ae549225b9a3ceffd3529184d5dc39d346c983842afa31dc1c9c74e0618dac377e2dc066b76dafdb47f6ea59c0763ebcbf53db73fdbaec6f66df05b7fcb194663664080594540ebef68de29f4664bb6a4dc9a5fde4870f714f7d6df19f759ecaefabc8fc49b961628292dd2b8d1660683b05a89abb7a7661ec846681794cb0173f12244a1428245666a36289b8182f3b337e574b38b54d1ef7171b0e831b11636961f8c3f378ff0487bc66b5a81b1038109685479967fc36e016cd00ece351256efc793d819cf178505bc81dbc5d018a93517eabc25235cc23f40aac0551e399aa4f1a562bb6531d7acce43d93c757f577a63ce76e3c3944c73269f9f28a8f631293e77b8dea8b45798e08625fbdaa5bd617855bf069cebedbe90407c3058a95fde989131ae761b43e156f630ecf61d1b7376efaa8d3ac0661c8e0cb59b66a8d2f137ea8394e8f6d8eb8403c878a6efeb40929aa4552afd0e2d0943eef241f1691b4fd03689c04cae37c0b826b2927c3d963530b10c5ef3c5f061827fc2decc4060be633295fc4c15d6be903a981935a3093c646a3e12f1ec5b53074f39da7a639a2764489f1389dd12d2fc27a70bcf5202f26b87a0dbaa9bac07cefcf7c6e58357aa061d45a59104a74ff72f1539c484a076168bf5192cfaa73c516f0bca0392babb53d9345ec057a1914df398fd582195112ee0f6ed567129fb57031cff59340678661edb4ddddc0604f8c0dc60d74914bd598b6a731ad75eebafbc403dc5cc07ceacc6ab7547a4c0ad2d99df204a28d9b547cbaa75cdfaf853aeebb90d406400209058d0847855f7e6eb635268ce996cca0d55a4885c0bf9909b3d9bc2e53994e0f2d0c74f5d432b79b2c85d48f01394518305f24e19ae399950af1d56767b8784d86e77772befdbe477f95ae2e289e875ec215c068f1c1a68c8f3c1af874dcf8126e5de3be5a504cb6983af9e9c188398fa40c7967a4e0a3c59714c8ea29dc8552b096d8f4219806c944d9c6f612879ea91dda4b86b493274290e1cd3952db9ea6bd5ab92d71a8c45bd5ed7fad775aced0da0bfcbcf15ad05e99a268fd9e6cc9e85500319ecf772a53a40bbb1df2188b2c28a39e34eba588b51ae9f3aa56975b5ed5757760b837b973ec9eeb74c0994429d64792f48382673473a5c28adacbbb8683d07867ce21a4a2c7cb0bf96d42775a3c7014eec399791f8a2fb54538122e42ee8680e49424191d1be54947b730308f6be76fee2b30ed43cfc15e9e565ae37b9966849c5c25ce56fce067a34164e0e33aa1b6f25c7178f2476d9c4463db8625508f86b7aef3ab731007fde5909ce1f6ffb8b0f8f2840c6f47ae874b77c3d9b0300f1292855bae6732fcc733499d44b17ab669cd42c57757574f76e42d062fd88830c8c18a383af759eec21da4f2429538b54ec486b73d6befb0c1c6257aaf6f7e9f8ebef9897b3ec4c4e16e29c6d3c6b1dc977be68479c26a28032649154532b0920325007b07acadcb59e6b34f1f6b98cf9d24266e2807ca588cf9c6b256466f84e30e7b2833af36dd500c4f52f789923484c8495e5e6da1dd92a7694029071b1b50a099bc4d1de57e58dded3b5c8327507c7a979023fdbddf40af3016bc8922ca74be5832f088e7f23fa824ad5675fd0aadd775554bc0def35b4bd2855e46357164b0bf8b09b49f2ec3d173b14c9d5d1c9c16484f299c89ccd3d8828dc0ac870bef4fa00151c050951c75ce54471194ab716177d8ef9a6bf3520e75f846b1c1f58f3a5766f1bbaf2bbc27310bb9e983c3342351ac5d03dfaff21945e09a344d04f66ca7e4cc03688ac3525d11ed9ca0c82437eedc3585168d49794a5be4ab48e5957b77a4ee96126fa3d766dd966976e24ed684b1e142382370534b3312c2799a8e462921790c22348d5a9f9832d192b1ab1392fb42a041f950bffbce599926faa14c0b318b5f4982bdb367dae794f11caf369e79f506b60e423848a6cb703df078ff687076cb77c0f07b1abd09f066c75bc88377544323875117455b84d3c4ec0c5d5f7bc8e0069ef371fd2455577ee86ff4cc0e7c1a6ba6e59d5f84877b8fdc458266fbf96b16eb871a679fe2282d4a2840ecd64f0810375db9c30f9fa136f8007b9f136c373fc20ebfaf638df36b382a7a3acb5d89cc82a28d866fbe0d44a30563ffd258c4ebbba8bb73fdfef095eb03eaf4bc6dee1847e1bc50e5d3a00cbd5e88fe29bfdd279c20d7efcc6dd26dfdc3ed55db19a7cccbecbbe824f7d5956c3be22e28ebe76b8581ce1162a6889ffcdf2ea5e81797931b391451e47aa76b5e07764cc7159ec0514a2dba0e77818a823ce2435f1bbec621aaa0ad4e76544a4065a63970bf0f0e7c60f2aa8870d02c29bc2fbd698be6b6e8faf5aa7b8f97f184d7baf69e0eec1380fc88243cf8dc00dc2eff08b30ebec0d141c0593d9cf90fe9f7d9cad957a4b676eb1ad7da3adf790f6ac2899472e814ee09910ea557fdc6e7dbbb9464beae1b56857da156c010c6d613307e094ff6c931434ecd305d722cc64066bd798030c4f80445da08c8ebbc0991435eaed30e067191dde5d2c8ab8f496cff39f8afc3ae085c671476c4d10ff8ab18de87d7f94e53b8dca2a5156c52bd0981b2dcfb739114438aadf5b5865dbf842123515726818eb99caf469d8fce0879c3a5a3b3129c2778b544ddb2bb2ead968a11bbcdc39ab27a5c8113537aede71184a44b5a677982692dc40812292a8da92f920aeaff689112cd0965cf34b809b26dbbddb30b8e554076d27114b1bd572638f941c77741d35d5a8a437559c586e734c5cac33571b9c83efb40b536761695050bb1d159e650329ad324073a8763551510a2e69cfba343b4a6a51b2a4c736c9ac8e18f722d8ea4fbbb51004f2e08e84c595a7f538c629f7e302a2e8332b7ad1e92959d76e7f6c8b729ef9b9bba49b426cf1c9297cd5b2abf2dee633849779330b2202b53c36e3aaf384223ab870fbb153fbd8fd087a0200c46bd6363af8c6473b45644a6996649a89f2ce12f9cc5dada2ac7dc736281dc21726c3f413816ad5cabaa5cc1f6d64d30511bc762a71f85069ca22887a0c7164e913810a417ff1c6cae5b89efe68753a836d8055c66a037ab323ec7c6eba6a93c21ad9db1eaa59dc18aee1cff47e25fa1428de49a9697e09daeaaa65080f4cc8e61961b296bf812f22ccb12784f85c629f75547792fdb26d6239a5be6d6e61d7ef8d1ee12d7be1aba0c74f4171fcd489ebcfa67a669cc4dc6a8d6b32126c8cf3e4ac6090b8dddd0e10bc4e68a92a34c41ea248e1e513ee7f8b3b0730969f244bcd13f7e21caeeb30905a71f1624822eb48e9aa568b143ce55095417eaf3f2e6020919a09d6b8fb6f6af72b92420eaee3697426022e3a9cac10034051f9844588dcbd480399f716e10fe1155bb046993bb84967ba770aac1364746a76d1648590ec9d6f2c8ece7f33c788eccff372c7bc7ebbad6d58bd773ddbf90ab92baa336f4857251ccfd43301d992c21308d3cb4c09a6b2bdeb4f3a924bdcf0096d081c4ec3e88eba9153372b6dd66230ec9e05e78d038caa918819f9b4be0ea592e7e130a35eddc27215103fca3d0422a6fc929697e15f7be3ec64137156560eaee9abe409a6dc6410dff1b48eccdc62326421dc81addd639f68302a6a81a27220a566fd8b2a32651fa46a741507b91f07a6ac2fc55a61d70d1ae2abb4044b1b16a44c98ee72f6309e5fe3fe4f4a256f04863802690644c8825087e8fcde17e50a3f0107e1261bc78325a8127b6411e297edb71a35b787d03789a5c6ab0a381ad442137d139dc02df5ca0827d09916413045546a0021b10fc22dd617804495a27ec1495f5e8fb3d08e2d1455513110fd9a0e6ecc0c1c14d9627f5b391fbb7628ddc3b3f542332411f97fa0956cb8a7368f62d9ed9cb8a4a6d87ad610896b52f329e6e2d753b892a09a8decba304a2b270113a1193b29a49555fb30579fa4610e04a1888c6871674291e5073779fbe1bfcfd223eda5a203bbdba113a4e9d482ec1f91f17550a2706a71cbeeccd50d2b6dbeff53bd1201d705e14bac5fac219f6792765ead0ac7ae2c305756b73050b63b974556e814edb5bb997905358eda295a3b292096711f6593ed6b54895c4dc611e7c74791acfb68a79be63fa2bf9d8c978ae807b6a59857109d65c414349e900414ee9bacf09eef8a49ec212255491f4aa81a851c5363bb3872f23a3e7f8dd7e9f2f8ad5648fc2e41147b8cea6e4d49229bc8a5320927621d267a537d3046a5da3c1dfa5450ca861b1765e75dd222a576929b20941f1f47ab3a6008148d572fb6f768582016780b66a00807ae0668f8f7b6b37083901450b0e9700016fe53af3d311f7049810ed4f959572b17b423bd7abb4ab0a4d09d6fbd5fb2e109298e03a86e25710e28ffc7a99ee3546d2dd0f5907e94250d668725bdf892f6bec9053d1bc4ac3e73aa5584fbc32731da7c1f905b5eaac45e388b9cd67763eff2a087c1b6ccea889d7751cf97c11e9ab1a06a59b9565d05f090851ed0b8456479794f09ce06355d16864926219bf661fa0bf3967f9c5acc03ae122669b62fc1757941d5b5cd8037449ce04f577a54c5a64bff7edd327cabe124921b8561199c6a4fe87468bb7c709994dac9f6b327746d2bc8fa6d70ae45793d9f1dae9531ee490bb536e77cc424688b20cb5fd4a75cb3941aca81cbd7b31a14c4811236c1a9930bfc0a00ea47e007648258bb3e4fe0c38e83d105dde29cfbf374c801e5ddafbc895626061d0f31fa22d03fbb27a92f060313378d6755c73179e87b562b8bae32e6b10330483045558e1ed2e1b709e5cb51bbf0f9d7293954ed8ca99f697c87ba437cbc5312f7d13c26991f6dcfdeca2913baa447fd4dda518143b206ab9bb9fbfe7f9dfcbb2de9af76db9ab42d920cf7d29a8fbe80d09e1072ab32f1d65855cb85d473490d08078db566a2d2a97d2c8f52031777d6823ca1d4f24b9070f58403d280583ef17f0abb317fbe8412a9afd90952d4ee00334e74dfb325bd81193faf2dabc9b4715a033bfe97876edaa7f3def2fe5af24c498b918f00cd4bfb66438baf9017c7edbc93ba0be378a9718a09a55ce37e91c7534469eb5a098dccd713ec33e71c36cdd2175f7fc25d52588804fc312dbbee667ad207b435835b04c8d0b7bc6553dd7cfa7eb589f3a42b8ed72516dd87e687e4f364b776acdcecf0093ef36ded8b18875af6b7b282e12307d8220e1fd117f2ef100220282788a384f0cbcbd665d09e1c87e4ff85988fabeaa24d1305cb7430e07721ac75bea6ded88300c7bfd68fbc273605369bc2e153d6824e0216a8b842f6a22ff7fc9c5c80ffc3e8d7e5c411f572ef64bebedef37023e827063ead71a3cf3bbaf0b85bf32b51f92e0ec850405ed318bf890e5c16104b190ba7169878b990220b195e34d652a38ae40fcf17959d5e374ebdfad3b636ff446449e9243ab11c1781df73576f151c41c5ab9ffc1833e9b81d0d976f7ff57335dc25e8a93450a9c1b11faa20d0fa453557f23bdd85441f1b6e60ced8c0113036a4bc3804f9551cd68c6308bb5f93ba60b05896dd31d8040ee192420aa97a617ad5725ec4fe97e6b55c05a7958827100dbb81ff047cc2df6d2bd66992b9daccdc9ea571a7ebc17a65fccdd0d8040d5a944c2dc8bb1aa64ada45775cc4ddf3ddc6bbe06a03716ea39472a924f37469b4864fa493cc15e6d7dfe70b3708cb62815a07386af7b311169e6a46a5e1cc96c2683c7ba6afc4308d9a3cd3745c5bba6eefc6e83da7a2259f26ada6e2f30a5d065222de9ce0cd46fb41813c71fb8cbf367d5d3b6f5221b408f60a6720e2596f329f2feaf1acdd76585574d415c133cf1dc4a19190a6724c98dc1a9193c1583c0277cf618a349229bf669f677b9e78ae6f6319680c328b01c81478c765d8e999f851f7f4892d8feec29506860759203c850f65bfb09000265443028390bf7fd60e4b9b486839bfbf5ccf92c6adac19609a71a28a5163e2d362884a85fb1789a1ee6bfa60ee39414cc7880a794a87c22e536b544d898933630f9bbb2e86eb0f748a3af7aface0195be42d2de7769782b85903d1ae8b00427a9d2bf251cad043c2d4e7f3e3892c64b553256092a3b73c15adf046ffe98c222c91ecfc686618000cbee5d1bb0a14fdd1a40fce7484860d3636ab8262e840f5c14cfa5669440ead89a226fa1bd4812dda37297d7ac0fe9892c28660a856dcbb33f7319edeb5bb27f1b5622dd3cd140e361cf768e9065708ea5d3a7834d7ff3f4473f99cbb8141adb07c82fef049f017d43ef80bb1e0f85785652321eba5a678e901ef0a0cfc9115be0792563ea20d179dc4c25eaddbe1b919bf5d3bfed7d04be82587c7d8f64135bf21506aa4c14aa1fb13a9bfe94c3b5c1eaaa773581ff66df64a040f736a15f597e9c0c740ae67a8b5e31a5fe7bc59a077921206804e3b4b4596dc7d91ebe07fb2dff6f5418f8471629bee70658e90312950a66b7ce4efa7ff32ba91c76dd05dbcc6c6de8459ab87654ae555b84bceb05e74d1c6b2bc0c1745ccaef98990df5ee091d7dfa2db2017c9676cdd4fecd64007be32cde5b085da749f1733ea435961128513492a1b8d89bdef249a071a0c044d2cacc92b7d9e67fbf1f1bf693c237f690a165039a036c53bef944920c4a19acac08aab9fd559cc682f32b8017b8502c3feb94db630dbab8fe5b9e7463de30b4994b2f8023db5f478fc7c9062116fea5e3388a478d555711ff53eb410a05d7c83933ab780cf49b0eee143a45c5825f3fd705ffc46e97b029816ac6019966808377c4fb5af9f5eb928603083c3c5d8665f7f1e400e385470eb9e5993959f1ce13b332566323c213f7932e5902f47b91fa17799a510dfcb946c74c00ea7489cddda7cd1908316d96a037c3cb2414aab7d529273519489fedb0d799b3e28f562715b2ddfc16313f289720bd44bd620bd9f3bbf67e4a6f7feb66a243a0fa821d7c0625273f4f01f6da6c245565be5e5e112cddbc02ae74282798b45057877296d3e83434298768ffee13dff17936e6e86c4a8469f9f262ba1929e644680f18e580b50b553568f61895e5e20fda16e97aed36812a0a94a87224ba8f48d64c6d84e582cf4456055d873947a939a0724d82479103ee73482de1869b09badc94c2c93b72599ecd71aab69aa5faebe475e1b67a24d96e8960de577cb09d9b0993c5c56ad5ee1abcada183c9840f90ea805c0c0ecf57ce276a027f139536c5cd7fc4e22a5f7f9d560180c5cfdedf238adba3bb0af1e61304bb93a353f2610a9bad06461884ea3c26b2742fffe68d14084e89bd33ef06631425c8dc7c4496a5284c4eda0cec1cdfe28cd8b5897aec44aa6aa1ccc4ad8dacea6ab1b060db164dd006f2f16e3fef6bb5bd90ec2be1f7a236542ad63497b90277f14132cec4038acb32e4cb32d65e2849061d1a7d1fb5b6809e398cf0647c47600ee90f8c4a150ce36728c1aa423d37e9373ad4262311be04d17bda69901e5145fd2dd49173cd17a2bca72d114fb74324b1ee8568ace8931367450651678b6ddebd466a3a64d21a17781b6e3187f7c158f4b3b61b45ec2e61245005464521da643d62c3b3aee9ada3cf2e9f0fbaf9c090652a522a50b1ede0218471c07a3efa3875229586052eb7f650492caef591fb08d9f8fd6e2c4ed396057bb36d298f5dbca8e7ff5ad8815fa23ad35ba33982d452c8526a1069e71a8c281ddd8df62912504d6dc11db89efa4527ba23041b7633c374b66c33523ee0428c09312d1c81cafc509456c993a2da04b54bf9b51410721fa1333dc6279d49cbc509d1081c73d61faeec83b3eaf25c35df179ee4f8cfe30e7395d113416b359ab9ec06ceefc88050c9441ae488b42d5aaf15756fe494f26befbd9fb4a86a26acfc34e335ffaeb7b2c9b9e25042bec4d58f1dd9bcdaee198f5301cb91326b38fd723ff4378c227be3115a8f6c37aa04666265af71133daf956f9b5af0507c96b38cad541c406d084f14130e3e135022becf54a2dbc096beb74909bb151478a36b1228f7d5f7f800b21dd920b9b5b9f056e378451a81146caf378b26b65f04d0afafbe0a3581b0010b314ade239d8776d09565f76dbb5411b3e9516927833dae9e9616ba1b2a1113f912e4ef0eb44753d5f45d52aed52f1c1382a59eb9d0285d65ee7ffa32c5bc59b37a3509f5ceb462fe543c64e0816e9165a8058bfc79472306021a5f42543a3f22dccd12ab92535fe6de988ed3410bacda9b7cc8606e1f321d1dccde3e1df0b4b610196fc7f109b5d6783cdbc86b6856a1f8834ad3064e3d986b737c56b0369dc78bce6480d4da2397bca451ad7120b99f8a09c5fe636dbb119bd928de925db7b04e741aa24d1bb2c856f70c7aa3a3a9750cd6c1f38c67a53b411e39627c82c9bcd5cf06f131c2630bba5f945cafe08da4ac23ef096dc9eefdc42bfdb70a236da0c0ebaab1da50b352cd563dcd8d67fb1c7344dc99a16ed8bfa225fac26e9486515304f4f2bf95109a71ba3aa7b3eae507b21c0ccc600eeca07de494a161af3942f1bf719ba6cb1f31a68ed9a3ff1b09dd49afc31262adb857b616903acce7f781b8e8d7dae19e392fe52bdc190c1fab0b9272e59025b176d36eeb50e194a45df2282b0346c4d4b0792cbe2fc51a1fe2486d0e8084d05ca47d190da664c80a89925ff84be7ab74dab13717318d5e420d26ae8f20b9d643a8cc29a615420fb065bfa1e232752f9adfef37e2fff8d17d6a686dc2c033c1f50c16818d85f5398cf7b936f006a14d5cdef4351cb6615b2a9328520c4d769f6165137666fed64c6b757b4ed863fdecd82d912a12d6b79c40d95e2f910a6426b5c26c72b81226ab57f6c7f54ffc6fbc097840434b16a98086d3fe065dbc8d2067b36e861a4adb2615af0161d87971ecbd871959af9e5cf558bd4989a3345ea76e04266c7dca864eb15d17ae45e1388832031c9b94ccc783e4676f0385f277336bfbfb97db174f273bcd5c50cbe4599f77309a4d4c7ed503d1f6325a286f04ca2272803e77a8da3106a85c016fa77d7e62c8821cc2471bd5b6e8d800a60aa770c95919cff77d91e663c2134d297e1b2502aa37e8745294b48672ec942f7c680b009ea131bf61e99d0dfc6a4676a277ee42969b6a0b3d2044b968fb48e55150a45427fe14ee06bb9f49e566f8984628c4d30313b210c51c515ee97540333a9979e05de940e4fbfefcd84a8db65938455e3adc76bd52477b34c93a7f4a80512fbc25f1ebd7b1f6523fcffc0fd84810f7892b4b65a1f5b9fbbd409396fd22ddb94e8db61aa570df51fd8cc03183affd17bf2a2b69e3c565f14162b08c44336fd3ca5c7dd4d0add3e4603c6bb747e93dc2b32c041ee6a49edb64413107a0501f71274c71c695cefb59909758f0b7540c2a6c15e9cbf387c337fe43dced05839a26e0c0fec2ff6f5df6c57a6cba1780cc61462917a97c88a165060eae46b034b8a951659f51f5c9b3a9a4d6a0fdebe51f6db0a89b18add5c42c12b75c9df840345473934578952eeb0a2d5150d8b0c257e00d98f95eafd420b73ef81947c4c048686346c45abf59645c4a3346171078b6a2bb719a0f68305b71782c697f090798f707776ad8721e9bdb833424cb14663ee6ebb4ebb36d8fb2e8962c70b8e547cdec6f9a009fb6737045287168f0710de20244209cc75be0cc141683d3bccec194c0240dca8903fe8ac0e3788151fc8c57bc4b74867bc37849cf029d79e5bb7d3b312c30f3e0116c481a9c829c60b13485879f0f5c74fd16ff8db8cdd89a0cdeb95dda9169e7b78fc2ebb692866f4b49fcaa600deaeb9f4f6f4a8c9191634df607b6062a942ff393c652dce5d750a05b02470f1a962143afe70a337074ef2f018048de7cf084a69e9c3738ec7f3ffcf8943aa8186b41fd8a5eb4ab86a28da9926e8751486196d44699b6d03055d4d8e509131e00fb0c6ed5abb7ab21967b33f2d5e6fecd12c093a50ab5ffd1654a142df027546c539aefd42696489cad795754db51a5a226c474bd824b30c99ad52f9520b3148c8ef24a6b882c24a88558d0b16a4c949187e201ba8554ca224f15f3ffa9129f4361b4b7fa4f6f70842fda18f652e5922f61fead9e63ab25190c456fdc82b8f3c2aa201f3cf3e68508a511ca5503b1059ef9d80d5c9e704bb5a6ad198c8ff753107c05209ab6bf48dcb2c06b29f48beb58ab641a00ef2e0b52a5e076adf4db56bb9222eca521043dff0dbe1cea5b7013114c0fb86090ba61e05e78856ee5b11db9e77d915422b34474bdfac279b7939bfad3d22881718af65ce1cad5e43bb44a11bc5ef2aa26e4c81d3e7c73f04b239ac2832085e10b656bcb509c904bd1f9ac10fca2807f2a7a3c302684acd9d82aea9a4617b9f851f496147b7049a64677006653387f976d0e7e29b7773f3ff8a9f9ad6a323fe94beb179ddb3ebd8fa887b2da0b9da751a768efafdb9ec1a691e815fd8ec22cc517e0679ccd5121ced7250b2a6a1279250116b4e1549376b0e506eff8905d42e5d50e63af8996e23d7d551faec0e0978ad03777df727aa9d6e50948fcadfbfe8cee06b65de9e9fbc0ef14f68abe58c1b2d83755cd8ac9a1c715f178f3ca70aef496ecbbc61e980446152238e67ca0f5e440d11e6fbb4f4abac43efe19e52f0eb5f20798eb0fc9ed0a167d8cb2d58b1bed3b68ade05c66375562165e6e0c8f0d3212882c361c93c49010a5b8acc64368b55e260daa5370088eef332d71e5c1c246e181372d37abb9c336be2d0898beca1e7bb099d0acddf6379cc175885baa46b043d2714e3743ec9626a0cfbf3373a0e00d028f635713c81321b253a2a49630ac657f04bef366474426be77a3a041c01bd39e627d2bc0c581fc800318524813751b88653f8fe92924f427e213a76484fd702b79d55775b54bdd246743abe0c330ad035e77fd47916aef98b2cbdcade2ba62d06d05b5b34f01d8eb7702e3fd217c101ea085da919aa3a9a582ad85c47e31ef3cacd87dfdb9798d22bb8768c8e5ed6409747b1ab55e652f6bb907ed504a32d701c2840fda0c2400a012e6f9e4cfab08b8b70f749df83188144dd490546cb3b2a9f09f783312ea6153304651703ce7240ef6db09f7b46b9d243c07d07515947e0508ace8df48369b0bf576d30b0975c5b64341b76b6807a845395adfe6a2223fd288bd8776b74bf0a9a03bfdd5779e60ee6db084639ff11ecac22e157e158d81bcf43c4a0cece6a1c8563475ddb41ab6d1902cbb3103d1ccd09d711885320737a124a65e1afe1b5daf10dfd23e499bf43f7dd2078ad81b16e76e5b8bae3b17f188a3f20cc4dd0b865d3d31f2c6487ef17d50e24d42e9bbd81c27a43f76fd7bf26dc28c8febfd8fc2b1624668e5cc82049a3f427d3c534954946e978ecb377d12454e2c4534ab20d43f478e21154165e8e967ad1108fac3135ddf95714160d81cdc85cad433e7f240889d38554","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
