<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b8df85734a1ee0029e1b20d5a1d65902cdb44537afd7c7d050ea041729d5e20be0dfe88a55f5d48f3eb38fd9bf140c5961d1263cc7e60b578e6536a99e933c584df48fb28b46320a4d9495f05177bbb5fc077ffa149f8a1dff6b9ebf0a4075dae407695ba7ac7cdb455f52d1945bf4fb98c6c213531254693db4369509531cce374224070c76dcb3c4ea333ebd99ff88afbc358c9c9c2dfa1ddf6addbc6d3b80d07a4a61f2d3f30679cd51a20676b5059a8e513ae796d21e479defc9519fef8077911eaba5aebff98b87c92b6f30202cd6b3b8ccc30c48d59b6670dda6c888908387bc4de313243671863f75c21b0deac290ad67bf7de22952ee13b4408c16eaf6e90618a554c03ebbce64e79e8a16a4e9b1a17060c03679dacb1f79f488eb937316137f062cb7730c1b2eafb30a1c3bd3b42d4f82a3f96b883d31530c7c6f0acd8a5d518355286e9de61b3f2c8ac002eab06f77f365d7a5d6c07ef5bbc697f3a0ac5d8952e357259638d3eab3a44189cb57ca468efa72689e345c19f60d478312ade44b565a9401771c85bdd6f6393d6cf5c2fb15609fceb74f76e457b0977377f05901efaecb2e597b0e972326831a46fcd756ff93560b8fdee2948a6c4abbf3bb98a33fc4a4115c7c88785f68d1f334c4a6b4a0967a5a1245d046ba4ec625d0f264ff84ab1284071a38b5c839d4e0c416f2358d26e28408ff5ba0a6d5eb03d59808fd9498999cda53186b82f74ace489a3200a145cfe7449aa58cd0c46dc25eebd65134a4e66d8553b3e8ba4f9b8b131afee67ae07353925f0baffefa0dd60d0d98fa4d69d9887e20b94b9ee1756ab30b40601b9c81b04a48d5f97c85fcc2bcd0bc3bfa8497eca170f8f17cfe5b97cbbd452ca9a645c3ebf1b2218ce6b01082eda6de9b14e564afdaea71d41714817db574606a2d53e8230de09b3884e092f1fba4cfa74fddd33d0ebba91eca923dbb8a81a897882b082d32a1ecb6194ade0a3256cbdd4b5d3664bfc2a58a65e587160cdf26764d0a0502bfa7e6f3c73aa140763e8bce529b78a251addf9a30ed553a8a2b359ade90ca1acef43edb0bfb929663415ed0ef1fa0ed037f0e435de11a5cd9b79b23473a71929a059455848ce15a5bf4ee65eb1e9301a14e0968adcd2c461bf89bf282b2c21964b9927ad9f6c57870673950ba9be0330bcb4c782d9b4d4bd699a128cf4fe50221bbc9652fd7b436b11886942a707f596279a41fbe646f9dfe2acad30ac47db104769606c0e57652efb16e59d9501a1d9f66952caa57d909a09e8f57c09210bde4d08cdc83c7c3cdba12d48c6b9b31fce581c21b633ca974068f3097191d36994218b64bb8e1a9de4213f1af49bf939470312f99f17c108741819dfc3ff15d13e9a6cace84949efd774633786e2667c80949a92ed48191167d4b979897b3936cb90ea61b12d80cc3fcdea6583aa04b7f071b8e6a222e7abadf4aab9415d3f48202c44cf46734ed846ab810a58ec54f97b3b9df0a76875c7f57e9046d2d672e6c86f7a5db01f94928de2e045096c1fa6247f2e66245fe42dbd8df2f86df79f689ce5f0002f70227a542c364a6b19b78ff4b62188e460a120d72fe5269587220cfae21d52d14eb8d15cb1a7322d4022b1a6016845db64d6f714212ae72c370569c76de2ea04ac50e9d8ee5db91d898474e349a024eb59a4327853e62b024e809854a6e1a32340dd6079aaeef51d7821a97f9cbd7a98f3458183729583736178c7bf13d1d0fb3239c01e0c83e1dc18162ac2022ab3966f6e6c1905d9121b2a6cbc2c734149095b5675ceb382d6a8c3e5873e7e28989c0032cfd26946d8d7212965bade889f0cc4ff4dd8771249c56bf75c6be310cfe6d50c2289e6927dd1bdf8080fe40ec478440478ffba7c2cc2e13cb6bbced525fe582049c9a42485faead3c1c80740a84d6a0eea84fbb701c8c9a3e8603fa093784676890d6c8a2f159e80f496c03823ed8b2761f5728b8ce02440171911bc1f156fe12c6e0ff3f3825413f052bf19a0256349ebd2168c1d5429199591ec1f8aa1e24fcc0ac67217a20d05a21987d04d148eed70aa4e9e854b3e683ca94e727c2eb036983631dcbe9e8045ddccaff7bded3272198ec63fa4a375c9edaab8612c0b40b666a70849dd3a6c327fcfe68940f311d0af074a7c2bc2272f4d1fe530019ceb7f8aa557bef529518208ff399376279b5ea8039a622b79f9aa27670dfc4b3b359ba2fe718e7de144d7dc331431ce808817a59b21902978be9280328199aefddeeecb3bb1773466333c5e179d967c8e41f302cc2c33a3939d7193f12e2998fd6248857dcf2399247f21ca2cc1a9e119ecfd439d31dbef2c8b53d94fe0ffec3feb7005fc4bd54cfba7a2565048ca2c2eebdf63d15b53de8098ce5f57878f69c938e5817c40e15e35f6d0a6c2bbb30a2664b7df04fe9bb3780069c41e7816ccf7783ba004122deeb2e0a1e1d8b1f4ec861073b1e44721785571d3e482c62d4b15839784c61ec0d1b71557697d5a66124a5db593e9459c922e295c2264411c3f862e8e73393ae162c91b1cee8fe8b0c466a5a1918ba4152ff6bb1e34440cda5225f157eae24dd96fd75e9ba9cab0ddb7fc18bf5b8d9f697a85d8fc3590bb629a65da63ba5186fa4c997f5ede2ea6904dc512ada58efbe9d1694ad1cc1fb04f43e52d85a16d4cb2b2948da66cc8a0f5e093275fa170dcbc6d26bc136c68e559e74f8a5ab5d51dfefba82bf22d0f062e6888f9820b121eab3b13f8306bbb8dac4ae47290da712aeb183f5ef182e70b8043e9aa72408cc416a78f2936a6256a4abe61b43887059328e46b91975ad8a9a918717ef892fd137c02dbebeffa145494cbaf701d67820146b074285ee8fd6c176c60b5e1311ba868a7af804e576800949cd6ef610a1d80dbb95fb581d699021922fe9baf788252ee8141b542b00b5c38dcfb2902157eb4ee025a76daed757831f90831813d1399ba37061a22b094949f01a3e117f8a9a94969323144c98c9f98c6011c374c35ae267aa3f8f6a3956c0b7702cc5a300dfa9d56962143a4529da87b0c55b3c86f7285334522d74e29503d32562c835fe776ea34df5fd3be79332bf4c621a58ccadde077128669635e13ac69359244265a1a4ae8125124c7ff64da4eefd29b5d44efab74a19cc4507081621d45227f1aa347f81877ca56f38ae1ccb9faaf845fe48f98f2ce6981f44e53ff1f3b9e9810eeae9ef200ef6af164029d3bdae5a5afcc1daba7457ced731aee3179d647d49d7e06ab9e4bcfbad7a1f667643238e2212f462c7a56e65ab841ca91a9da2201d777572a8c0724441fc956e27f7f16ab277dcff08dd00805b84ab83d2d72ca37a5ba9b6ed77d9debbc97bee00b9e1a037e4c9e67ff5e961f2082636d92894d448a4d91bc1ac5d2aba759e6ea9952ef8abb4a74f7d90c492509bc8b49c1c64b1a72fdc14843fe3378eb829aad0c0c25bc31039874f63c4aabd631534af12efa816025e59de0110f0b6b9d741a60bc2390b898545acba3450311cac4145a253ef12e65731c56a9d7fe58bdc44c69cc1f7ecaf544870e236f0da50a4afad4af6fc633523e8004ba6783033a0cba54079ab525db18130f05f4b4bc9791acaffebddc818f808e6be78653d4c805d8ea1be9547cde62295b99dbbc8fea70dc7c99f6de036a2745698ce958853d720651a72e0ebdf97e5c8de79047af216371f4557fe2312840e6ebab94e579eb07b0583d45abc74f1ea4a811d424f34795fab0946aff16d4a07241d691134f528ee344e3dbac19f4ac759ae936aeb590ddf830ef0e4fe249ebd4c0fedd027a761e01746034abb88cd2febb51bf4e18d84e12d97411a645b5565a69c05e28b6bcc68c5a1f3cfde3247e8635f120f43e6432d751d8262fb7f7240e0ea8b636f200f04567396891db371977df3f9ed82b682edc589d3ebee90b2465b531faab542324388d29e82c8d49822042bf25cc5674138ea8665bf5aeafa3a88bc096d586ddc9fce834c9c0bde9be0664a9c092c8d419fee383869eed8c7e2265aba64173286ed308890945fce9931e59fbe94f5aae7257d81a135990e55c3bccdf8ef5c193547ef7ce5f8bb0c950a15fac15747cdd69e1c0564e333768f7a44aae02b420e60f4a2dd9a02f656126c0567b4b552a0671dd3fa55dcd49bebb069974aa40070979a6ea412752849bebb45436cdfeb8a3372ecfefbd2cd593163b3da752653fe6c774742b848f6c07930206730bfb1a281c7a3c1c6e216db4956d5c3bf35c2cecf00acd6f69ff392e5385a58412d6746117cdad4e04ea5d5438a372db6b2039c4f795cd4fa83cd981a4a2af582fba521893addfa26853b1b34a4ec7b63fa9f9830e7d6f04b1f69428a16782313f3ffd16086555361cec556a42a0fa0ebbb424b591826e73f132d473897a072170eff8181660b4d66bfd29208a2e2cc652bc697eea31121939de1fdad02254034a34b5e5d0b8f1e364f6b2bedfaf976f983b0945ef1f7ba425d48d68a7c56287c73c12df4ab5196d4bfd8188a6320c0a3c270696eafb84d514d217146182bbd8c0d6460abbdd41db2a4e409b07dcb447537cbaa0cbaaf5f57935da0aaafbfa377b4821c8ba36f635322d82ce66b9780fcdea2b464458fae5997243171c4ef77a8e93f84d16f261b12c30a8bf1b5ae413943d30156a1ba044ddcc0750fcd8b902c39f6cd11265b739b1c75f68730f4cfe031c76e93f87fb582f6f9a07ef805a00c55410083aaa0b04f472ebd142f0175d88eff9bfccc92193b76b12117d4b19557a679309ed0097db6e2a26f9406a165a202dbb9e656264a8746b9d91e85aaad64d4fe387f0b8137787a016203e430e08f286de2095cd73fdf9b76d6a344a55afb633aab0e774339fa773a977df71abd4cd7158a0f1f4519ba7ba213799b76359060c285b8f7d90177fe4e7e87883bfb21b7e07b3289e95d56ffdeecf0f2c41870f21d0023fd8330e5f689743fb26799b643fbe52b81d0bd0498a6d40936cd3a21297c353657eae78fa3a3580034fea92a5aa548d845f0a2fea7a91d2766cf42d19a0835920ab125e2163a4055717f86d33eb669b2229a9bd1424a803e1b3cc06a56e31b0ff211662c6ab1014c2a333da81e4b5f7fed96a8c009c0c75b403459068fa0b78568cea8d443fa7d00e4b6b0dfd30b0ead7c71a44762ccbf32147c251959ebdaf853046fa2353863a123f47875085cd5d4341f155aba5b0a5c6a7d52a34ab341e20facdeb8604e445a888ae720e86638a6011aee822e897ac4ea1fc6e1371a799a9590f9a4b5f49b39b83adbde7f0bbb49d639f697027fe22629b7e72b4aac206403df28c3775e7756bd9f4d2642927ead5e4e9571dc98fb03b419739aa4cad39413a1ed9677b721d6501a7f005b2f4a86a895f24cc9c005b2a17811b279f1c19b86a9c14843ecf8bab98377fb851539a0f36c4793bab57beb00f9da7e4dd3aaac05609d8c8b151abf13df423d942f2893029f4f7b2939e24e58c972c00d7f05528ae0c54dfb865eb1997f1181409438543cd2aff3a1f0211cea3c7d055998e3e3fe1ae37f26b83b3c02d4636e1bf667d1ba9798db1f531b6109d8fffd353512ce44d6f11dd7714bfa2682bd1f773484616f1ecc359aed18eaeb700de7c6014887da4246ae151455b9d3de66c8eef0dc83834936fba41e78db416be3d59eda7cbc959f074140aa23b0e5e5b7f8ee343337e3c060a4fcc015e919633e81f69e10f5a7b4fa8ab20f89f562619848b5f74660c63398a99a72181c224c78b2fe1c73a1f534bdd1e404abd4b26e49d2a6cc985e6f578d172dda5b6fc1f85cdbb71b2c3768a968cea0ec190a5f6ba649bd430af43cd36e7b15ce8860a8709552cd6b72c331bf60fe2f2a405b644bdf1f9dfe644f62687b71c46e42889bd37abaacae00abc72959abe391d7b4b88dca9c3e4bb2fc8449cc5fb0183d4dd02718167f2799c481656404357809fe11a7f2d7d12355bd025146bae62f7eca53ead1de039922385151d15cd89e9577266ef1fcc04f6a5680ff0374debf665c05087df4bea57badcc7aaa5d84ebb12adc4bb0e6f835fe51ccb32a4b74c00f7c84523fb65a85cd0d67f5b00674decefa943d77c7bb07a7da2415d7c44b50ac9d32990a96fe41e8ec3603a1ce1a5b31ad8c27ffdf01154cad1ecf52b7797847446f0b73f515c6dbee51046373cd153974b633fdaca5870867c4a215aa725492a0cdefff7d36b13de7da7a6bd3162e70f8806cd7fd2a92cdaea2c82b81e9335e62f3eb2707a0397691e6cba44ff3a9ba2bd72fbe4201b41ee7a409892ab5caeba825a59dde15c197620fea1db3dffea9f0da50d96a1a59b0fe8948ce14ebf62534d73f3ee0c068e5f68d973d55fbd7467476a57089af35b6821685856ebe9e4a0e998b67eefbd01544eda91894473b39564fc167e471334a9d2b8bae572a5e582ad15ae9685710542df00c73e5bdb5a6c26170c06b9d0053a3d577287ce1df1c244c1e1e795843639ce1e8a882586688c8eafe0d7ab826e249c61959ed155c6ebd188afb1e1b174cd225c3cbd3bf43c67f18d2308f407bb88180d8cc9cd44c6b2017328ac168a00f781267b031fa36c3f6d99d1416b7cad53f5a5a9cde65145bc57b4c4df47a83a69f566766767dbca5c36d6709f54f6a89065eb9bc4198d218a76e0079b97b0dc52e5f1a5a7e101482208f7347ecbc6dc434071c02dfdbc3e9179b08b446cebdc7999b5332e82df1082bc5767907bbeb1c1dbbb802d1a8d30f60dd0cb59f355e620ffa9037c8a4f0167fc2d342557d29a108df72b1f0fc949d55e3649cd271041c4f3fcfd34da8ad5974569e506dda36d1998041a1b6e67381b9195e3b6a40e4ea91f6fac6924fb0cc75b145b8e17e76a519673bd936b077acb153b4bb5ba1a43116a4170d78d85cece6eabc427bb5f055ad6ef86a8f9cd602773eee10e3c5efea5c6639bdc132e71e3446828227fca6da0a32070aab6a81b8e3d44f715b9c16ab8dccc3f931b12274d244c7f56a1d080fce84f71376d73e981827fcd6d5eb67e45cd30156af359eebd1a60547dee52083606e8f428265fede56f2242ef64abaafa6e27ba1715bd0ab779e6cef39e460260caf5b4e608e992c99951d9ecb8cf1bbf283ccd725bdda0ca449e1e2a5197758430c3e3ff61bbfabdb22559bf9a9d4db8fc4b3daad71ab4c60dca7f7be1c5b8067d1d144be79e64929f1a7eee46dba14fb8e2422622a5ccea8ba225caa6f585b07528a85f344d75187b4da3621fd6b078926bad84a76311beb50542003b34784f45c62d1d265ea6eeb5b4d38ca23ed4f29e8ee8329d971b0f0dc2cbc8fdca5b3d6610b8c3bd6c3db2a75fd1e077b8a1a3a7f3537b461aabcf3198ca8745f2c1aa48b1d35487a3f537e29b047d772829d0fecd462a2771361335b15958c2afd9c1c121e0d0a30baaa6c3d6937ad6734e23a0cd36b97b2181906c0414c592b3a8c14fb3aeaf3ae2c550e6745c38a7eab4cb46b553273e7b991f1f02847ba8c2ff0623ac63ad461d109b886467931f8fa72dbb87490ee27b7da959a98a624051f7fce999883ace6a930e98aee33ed907557c37823bafc814679083b030dcc74fe93d015fab3a4bc5b3aa3c9a3819230cec3fb0429d22915a5bf621f6fe9b24747c4f3521559a163d03c3d0b0e678efeaaeda7a90fded72c1f78089e04d08817131290b688ac594829434ee01fdfd647ccb1992f7821ca494ab871befdea442c4d912403ab928f15a4a5d00af101eaf2bbfddc6903676b078a272e289cc923db71ad314b163826b6780324483d9a9ad7edac0d0197f31bfe6177e8b253f77d3820baef8c27e1cf30b77fd3d7213a5a1acc1a0f7f880aec08ab10cbba88d1bce09f491c4b3eddb014c6039cd4d805c15006a4a6126def57167cc3e40c9c436fac728b2274d0e56b4f6987e50b3140d73d8fd9afd7215a6fdcc964480c18a2f75b5746fe0b13f924d0a0eb72db78e278089fc1c852234301e2ca52a9c9553fb7e5b900280d99c82d47f629f3506704af7e735642aff852a1a1b40e943619e40ae70448dc6679f69cc7a64b60ad4aadfcb7b0a832665e46524dc72a25daf859e4a3a1da041eee18ae2e207c82d34ddd3219bc02b6828697b1f620f24cf70e6d1dba599d8bfb15dfb0407e66be80ed0d039218ee5a2281875f0259c80a1f29d8d1aa0389a6ea400333586a33255470c6bd44c510fcbf9eaf079b2c044c665516467790dd4bac08a92b7be8a78cccbed2367729d87b95253a881d7528580c0feb1babf5f488c3de4c93bd6d6a190530acdca6132d03e6e88b5fe2a52f51fe3d7405793cb12bbafa6fccf012ed0c946765571079cc8c3dbe5f68e01aa563632e5624db6c98e436acad58026067aa2c6495c76d6e6d9c78530adfcf430aa99639862129331dd96d2fb2f55f2c7403daec0c232582fa852e7327758d0c6405880043427a1ee40e9580b92390f5333120ca3f2792a39b5c37f865fc7d5825c970ac5bcd9dbc8297b3263e50713d4ed20cc33aa03f279fd8b30bfd8fbabf7cb945dda1e1ab35d23b623443c57b28bdf8cd15f49dbe78d609234a0970498e706ea13c43a32e3804731b40b7edc19b97e0a71f0d4aa823fafab2fe8aea04958e04190f6216b1a165004ea128afd08035230a325836cf0d33b1f864c9d1fa233527b2b5b6e9fce7c5a6137035e5f7cdb23e932c0be55eca5d4623e8f4205a1b6fb3846507c7484fce930c7706ddc24e51bd7e0485c477ac16dee6d17b72ac79edf856400ae2db7b9e11eac26f6753a1fd85e3970f589035e4b737ec4bf27a2266675c3ddfbd7217c883d47d6bc934c0b2bb908f9749031168f3c7f55d272952e505341da92a37d7e4ee03e747645edc97c8817469c6d70af006859945ec21aa621d4da9d189d67d121f245243710dadf9e956eabee068ee00280673040b7f7ff800d7f3fff5e7f944ca15d708d083274ba63e0e651963830cbad5f5193f835d9c90542d8318bab21dce695f1acb3873380136a25285b2a2048e486cec5d4579e85de062b4b968d0e31cca1912baa6eb9da338108bb3e251c3e9a75a00fd41497c420aa9cbf59e0c95cbf2b5a9aed9e0d2960c0895c5b8f9b279a636f83a717356319e382c1ea7e60955ff286ce2f3ad40b2d037b8287cfa35b58e26b8c6697d69f19b4f86ae1ae1365fb6eae3632f9c3f045b473e829cd57cd93d8d12a364e580dba00620753b60fb47372ac5b327fbcb397fddb94f9859e2c75ca220a682db313713109b95525610c3c662bb2425cf8102784158adc68b901798674deb3e54766287024d3d72bbd151bfd2db65dbd4651ba179590fcb34f2d749f67745d2556e487454f7cf789d95001e9ac4493a57902947c0961f9ca258c255ac689b634621bd2bc0dc578ae589dfa6ef3a36bab91b5258afbee31a1b6f136fae5f94d05e9adcacbe5d1733b494753dcbf445d341ddc016fc39d6ba21047f527c9582f88c0c4cbea9556ae15683cc1b89f4766f0ce51f460e4b3afe24a98af8d3c17b7bcbc67e10e4c0337615e2737f1a4c6911258df596172e340ebe7feac065c2e29abf7ebdf2f7d96fffdf05e2544ef3d5b079fb90f3548b9614635e0540cb600da56d2e8d6e9831674fd4d7446a445503240037c38352863e80dbe7f87ffc0ee428d7aca543b9c69a9e25b360bf99c48a96370b7c137123a585724ced027027e7f2f3f50d644bcd3fb56aa84c9a27677b1cde6fbdba1a4302fad493d3a77d5f36d8ea58331e79d910d2c05b17e8a4e73e55c5c9ffefc183607bfc3d83ce8154fc303496b65b5b7cf9f974473f7ecb2ae9718d2b702b24d1be0762e39c50745c13f94bb5bcf68cd3947d5537ee9aae5aadc4ccc190e232d9666fd650768be742b61b8a8c6dbd795abe23ef60e3ebf52c0032699ad6a9a350dab8636f525711d6f0eabc283c0b581a779bb5cf186d158939a4ddc78d640bc85aee8c069469432f03c94b802979de4498936472634e27cf67cd81145a5c60a916ad6dec05c23c8c35cf16f14a322c056fffb474d1d019a6bcd4e787ccbdd277b4a1bebe456a8ebb43b71ad974a85784fe1d4375ceacc1e6bf3c8970297aa5dff267a0e96d74a4f57da38a0d6c8516d77a3939f6740cab17914ef7cd044c392ef8db8d8e574cf85294c522896e042a85e7eafc5a3605f97394d8be21ebcf91cb000192a83fd8fbe09d99ce4c0baced768dc6bf32de040e245e4682b68fd990817fe88ee02db3cc8ee9fb1827531b6122524a885e35ce180b71ce5e96642266357273bfe3df1df534a48d3c34b522b18c065b705c1a785c5bec05e443c77ecc614e3b74a3da80d1add1099cfd5d9d28ccbe90239e7406a574223a7712c31b3daf59f1de3ab8d8efbe3d5e5c8b302b6506c0251c45517e70ca8efa6e47ce9f731075fe6c170772059b2843602a6bbdaa2c8e7700c87990f6a6617c0b9561b0842684470c8df027a1fbfc280589ddc9219d462908e66de31db79369bd6e70e12baecaaf25a9a98ba5835aae6451bd1d6b74b683b9e083907fac4993fd2e5de7e7056de8e881bcda08c4dd36956d7010e1e95c992793419769c7117dce9740414158004ef3520e3bf96227f1075cc0e2bac508566a11a122835fbb5e0de8a68e89b757be76d17ff9062e8603e6d98f782d02b3f9e58924729be5e80d63fba9c28d04eb263f27274788b21a60b06be9781f882293c0557b5ea3e7c42ea737caf234211efd9cf5a790f6a302980b0dc636711e96164cdb1450b41ef42f60310a9f94a322128507ef3c46cd554fc137e418faee535d29171315621adbe9cf460f4e0d177f86e02cde6c7c168f50b337ed3e60a806f1ad8a53b1e59990f7690212ecb10a1dc4c88da1fb0b74f10fdca66ee8731c6d1bc220208c38d89d0392a8a94619b4829cb6aee1300f955abcf88b4b58ed122f9174d466bcf0b7d37c2e4958cb5b3669352f3bcf46df3430b33ade75f563bea95ef04bd4fbc74cac7d6ef285bedd716c6a5c25b75f14b5167dc9f9922a1a88b1f2d1444e18f038d08052b45a8156ad437040441adb84903d0d061c228ab4f3b7f422330b0e1b06942f66768056f776492a722550738f9290ad46464fe01b3445d3bd1e88e75b81b227407537f42e919ca1df1a944ddfcca6e9ac19dbb8d02fb0e72b2ac22309aeb88849f2cb4ffaf08752f316828ad3a2c94d495545cdb0934a75b7357514a0b7aaaa253aa3ba9bd723410907b2a0d6c366018d179e61a9d0039b4928e6595796774fb99c1748bdc8edb1edbbdfba3ba10f0ca37843bd0a48ef13b0fb8b544e6ed0b44797c4264a86ac7db0dd668d556a7c6585bcf8fa15921d1a18981cf2bb5c8218bd824592803036d8ffb61f54372d107ab3861bac96fb96115e2497d25e8bf0bea63b4f4f0e0f1e7db4761e4981614febc7f379243497aa3199476b0136dfe000f0ffee36a025c91588778fe1a6b6df9dca1abe4a57d7f564289fd3f49e09cf20922221b9d5534843eeafa0f3cf88698efffb76804265872a1a30b7178f6bc3db9e02f0b5e18bf55f224d98cfc37e3b0e810445552c2017debd0447d2797a5fb7c743f8d5f509f22c594139f495bb7f8bcee86d5600975aba4698d497d5407e7f9dbf22d480841dccd0743cc798a6c0729eab8b3110abb1ee97950f280248f4e9e202b67575a0185e48d3c7945f9a3eef2a44feab1e5d3ce4b2409240d53ba024c2c5024f24694c030df62b7562904c3ff04fef1eeea851a0b61c170e4cdc6c6ce30403ccd6a30825548833e1bfc84e10913b5ab241deefbb0260dd078143cf498b627ee24ec91954ac0ea14b2aa2ea292ba914de7d5665cf42936f23c33a1e8c5cf3d60489cf547f3dd9be19e3d0eaea5d4b9e93ff1a404b1ac3bc6565462ba5385db3648f6dd8528635138058313b972d44a13086cfbbc9c45ba1983a631008cd1feddf6d9d670da5063bcbaee1207d95384673ac3b316ede2d4e68c95ae4538a515afcadfaadf3fc5e81b51a77f2e3c87d7d440196e2a81c580f6cd6cc09d9e5aa0624727d47cd508c503d7de884867abfc0a93661fd11581eb252c3bd5b89be4a48490151996bba00d5034513715f76348370dbaa5c515db5444b5ca1de6719c7d834291d6ac14f6472bd2bf3127fe2f1ded4f6ec863300a5d33933266b335a7d8993febfac6fbb8a7fa65f78c2e60662b2527bc1cbc6963a9ad46bea36c2a9b65e03ee7b85b9aaeceb5898fbb102cfe0c7898dddf6b94c35c2797639c17866e356545863b70acba1368c59f54bd79c8aeadb9a644c3799134c8d1a68583a6bb0fc360a764f19deb8c378f1b03754d7c73e0bd552d48350debf1ec220d35d356fa348df08a3cabe3eacd7f5afa3f4ac6751d8d37e6644c825112e6a1dcbeaa996106edaa354fd24a399d31fc17f23e36ce5e39c01ebdac09451f16cdc14ba56d4c2a21353a6e535c4659ebb6e850f602cf2109304c4f665f7e9fd11c4996e6d4c099f81a8dcbbaa91126fb7046ed9bf59e7d78774a14bce18bb6085d1bcb1642e3c5ba5b1a1039cbfce76dc40ccf14aa738b98cbb0be1a5706a44bdcde6910c43abcb4da037c5c82e2cd0f73b39cfdbbd2bbdd05132636c22087e4aa2dafcdb53e6f3c75575e76539e3c354fa71f1a391f0fe3c1abb8b58b01e293c473cf5af61c8ba7121cc62adca7f1ca015e1636f7d2f7799accb507385603ba57851915067c84cf38bdd979f3b113c9dcc5f7a6160d19e530fe7f42c65710b8bb875574d781b76f9d1b4cb9a50cc8b25c20d0f044b079709344b2c884ea0ccdd6e1e0fcb949b17808f2115dbbc3039af7f5d15bfd7407395983e48c408ffa267a987fce413e2988927b939bff23818d24d93fe3c8da2e8f6a1ad415e0111f255690b58915f97852e0b7f71202832bb2ed00e48394ebc51268138f92eecc09087f83a78b546bcbf5afd016ed1d75dc94ce034e0364ed45875706fa7eaeb9646ea85a0a24fd0aeaca66b704bb517713e8f1c7320262bd451f5da8440bad2ba7be8e7eb8d3c499b545fa5f336747ca747c7757932f877233eedb1d3369dbbd4a99f894363ff9d43302034db2be4e72b8c47a6ced408cddf674b294ef31c66e6eef46a6092342245c4d0539c2ba7b958678812d0b3ecf350de620820acda4e1182a031b47f62294d5fbcddf36e8b074c63a9c5ea3993eb6cd3afbdf85ed5522d19ab0d4a20afb2f905eeed901384ece09bea84ab437e417ec37c2b3c45038a9e66a04565042fb4b4621a57236dc9612c445957d7b17e8e4ef4dda729ffcb40db84e398331aade03091b2ec54c5224c3e0ea1fb9b512046c52b4e88bc85937c0fa45cbf8bd85815b6a2b6c51cd7d16ffbaa4cffc4ec937db8429ee267800f70a7d4dbcb5476e45fe8c10c5cf5c69885b2cdb654fb7b7b50fa8ced10452fe11294735d8eb7cffc3bb870aaff3969b5bb8d24f965de0129962d57ca30bcb85456d28712479cb3e007e4597db6d0c72c1aa600bbb7941126eb6e51013397bb7ca6a20cd2a5ec9b75e6ccbdcf49f3855d00116fc5cd0d39af3a66801addafb6856e874dbdc10c6fb144b15f16b25ac9137130dc569bc807f2edf6bfbaef1fb6664c6a3325e2e98652828570870fefc8f0d4a69ed16410db23dbda805f0f88a6e865f167b46a1a8e74f33f05459ae3ccee3f365ee513af08ac1812f7ec0651346fdbd197863c7fa52019ae72b950f23d4e9c3bab25fb618eed7be0aa26d9b1ff32589b70b55d4dfbd97f58b1691f56beae3c17c1f3d4030f4dca7071bf062380d7ff2e116fb86241fccbfc721f02f1d91e9ce049aa8969278734f05eeded0c415a4c75ca3eb49501c207830d4d46fcf38cd168f62cc8a833a649f68f7bb7dcc78eda2f6bf8af0d380949026b1a2a2b64296d72ed7691f5b7c75188170dceb1cb58c0673fba49826cc9c8817377d9281936ac00f4f25d88b1f52baab2f3b6e3401dc7ab00722cef35c8130c6cb0d1c541b7acc6778a411c1d679fabf6317667f436bc6d63226e2b944e4d1a894217060bb1486e1eb8f83aaa26c52deed67e5058a9296e507677e2c00a820e149acb1b9a2078eed0c6c8e916b211907becf4727f0a32c6c98b10d0ce9f3a4ebee2cf0713756c3f42ae9541bede89035e7718e40a3de4710a3a552b1d1696d6980f6e3ae34ff3c42acbd3c9088c45483e7d4277df4a7128162feba518ba92c6990e5719b62f421ef68bf6e70f3dcf99671f50acc96addd50e546ce7381d4184d7d5bb8c353beb557fe8289e08df6712dd0ef9023b2158e986d13d9705768b81fc11a60f55e413b7dffc3951ebd1549c7ab1b60bd03435e9cc64e0ac842d327b2ccbf064e3e2ce80db48a2079243b35fcea02d006c6d12153309630c04158ef57f31bb1b83d9af17047010d7992598eff2ddab20a483d93745987dbad1c8102f84b992ff1b138dafa263f42425b188e32b5ba750ab048e3039c1a81321a95d05618141980668d2aeda8db973d1b1f0c03df4625bbfe59016571204df1b0c738e9ab998174c774698ef313a3655d05c0fb591a5c3fc38d926ddfb7e5246cd75634cfbb48ac7e0bfc186451b63b0a18ab6eb41b8c4fb4eec65c67a5dc7990170b321bae29dd22398a366aea89a48ad8a87a68211f46f709d2c3e76ec0eedf5696b0244e92ac1aefa62711c02a63e94caede2b4a12715df13dc3e7b6a71448d9f326ca8308ea842ddf94dc8b97f568f70af12165eb42e94bc702501a21158feacaa704b6c9bcb6954cf56f38f66856912573b3a400062a43a372a625fff95d97a392d2f72e2593c67af0f5d25734c01475054c7e31958a8304c873e8f726d9f84819a81f32941695213885a5b1ae368b0a372f553402cea415a10099d7e819341f28f4b8f21f4de7f5cbdad86fb1336b171092fa8e1a98532bc6b9faa262221ece3b5247ae6c84811f19d3db13b1a9e4e2f73df45ce8b5bab49a9037a81533eef3b7258a79995d165d66b3a24690988cbff1ac088ba2839df2a988f0dba7b1322df2a9a87ccc62032d7d3a0a1b804241874fd7f62be262502dd0734c05eb0828e42f39f33ac904182ed904c89e7474197dceece2e1ac4eea04cb248ccae8a8b94842cd62be85ff1624a5607fdd2f281ac232d82a6f4101407294318d59c0d4ae0e58bdb00a47de85f2835686b59582714adb4b34eee08daa698010e09b90cb986456eb384e5e3f07744869bd8e933b4b68780c53b8ee864efd936f1fd9a16980828c3457d89645b9de18dfa377582f877387a24d4ed3e3f4168c21e7f02b7b15192e561b55c5346fbec5b0293f003dd74dac0b45a8da95389cb45e9bf7132fe86c8ecf59526b0210772dec1c34ba086be4cf8f5d574494c37172b4ad7f9c766d12276e74127504b06cb11ddd5ca7af4531ceabfec9b34d8ed3c64263418037e13fd50d2b2454306ff6f63a80bcf1cf59001892926e4bc1476be703616e11ba11e3d1c284109c524d249e387a23483eb8aef967f69c091a07aa9941a24b102f114d766a460215f290745c41f3c0b2881673660cba02281fb4b040c20d2e80c063389cf46cfc299ec1f98456963db3dac042ed53ab83104ecf3eca0ed9e8b806c687add6f60d4182e6b4f4c7586eff1b617683a82151d39565942a3f805916f9242749ea5dff5947a229f8b89894cc6e2690787d5d6baa1d0205b4eeddbba3d102c3616241542be118bc1306332fe592dbd79afde99dd5dad7e4eb45a1b542f71992ae34f447507094aeedc964829ba10d6059cbf09f16c57edef946e0345958cd662ff2cc803d57e6b1d67aec2a588fa3b4373c8663738fb792882d34ef913cc5392626086405f2fa62f679c438e854608386b4fa7244badf8ea13aa064bf2590ac80fe6937e25b547a53d9b7e090d81b0e9f88273947eabca9874c1bcac94ac49e616d9103bc1ac6687e6978047c936530170f53848fdb8f78871807c570fbbad9142f654a6026526968ed9c601b78087aa419d46b11dcef90ccf53780080e2a42a9f94b7f0a9ea3d3e1706a0d0543c925496b31286ad0be1146cf22f99450a2c51d838cb70d5e3a9eb611cdef81b5d9a819e3b838936031787cfae5498dacef66309c654d8842f2b1ef1bd1409d4aca06e455ba0700445e618e7a3299411721af85531713ca381ce0982d44a3364a9c79a285dd518ce101c4ed93eb8fbee9a5386bfc640bfcf771d63808e26ca84890c06e2c33a4527d8fc93915430dd72e98db4643142fc308a35923cf2a8dfb149e361c2a84af0a7a84e048ba63ff6f62975ea0190e255141530ff681d6974026aa11cfa5aafd496f089ab663c388744f775897647083acb1e09706ebf6202940e29e1c711109c12006f58ca26b2f454452561e44e94f11a06c0e90e90a278dc82c61cf277ea3a63d121165c2d7f46b129ef374b6eeb40e25096ee88a0b329bc3fa70dbbb9059da100d0b6101567b0ebfcde93606f327e5e9f6f6dda8250344798a78d2ac3ade053a5de100c79c8f2c993d1325c6b1f5b38b45e111dee5dc54ce905b3c1730afd742c162c57b1b806c7f2300756df4b1cc50eaf47b632a20e3bb6ad5037393fe87bd14ead16461e41a5371528daae2488fd3da931e0c9b4a6161dcc7c49ce4e69a9a02176a250d2f455a867513f7beabcae3bf358fc5d485e449f364b77841ca8eca279a6ebdf41d3d91c46db24efda0d8d92be29332d9373443c19a087c9dc1eeb30e9df3c7ff06835a0dc38f3b9286be09b668ba850075de4e0fb9b3edb60c821e7cf87728b6a437b7e75eb7868c303b409a412f98859b05d8e0697063beb9d1c3d16bb71f0825646e4f64f6bb01ee7fd84492380757dc9fd7853aca8577d7e0cda5b74aa03e3b6ce50fc7813100a2b44c93eb21d10112a3ebe61862346a5b8b73e5267398f9b084bd5efcbfcaf5a116aae32e586e980ad10b7370ac9530dc41c3bf2dd4e257fbb050e20cc3869ef468c388fbd51878740e3d8864f62041689a3a24747bfc83fb43322151aa0b613aa0a5a7021920843bbade83baf92234158c2060d41b43eef89592e15d36d1afdbba82c8bb6ff12568a3a9df30974fa8a573ba1a26b7cd45901285b9b5b7b5cfabfd5d740d2b5b864eccc680f5c10fe2940ab8c2df2c6da81d8396ca33c2ef790e2cdb5b53f8f30581362ba9a3fee69d24029a39a4d029a70a1e4604ea2e404db0bcb7091c2e5e6e522eb5255e2171908bd6ad6c73d5ea4d7f28f6a8a39d9c65e7ed3e07c6ce035733bf0cf07177aa789fc8277bba4fa7439e8eef4eb2ccf2947c92a8f24d14add9fba484bfb017dbbc9c65d69e6dc740a0f9427ac991dddbc8be25994b3ee0c682ef5bd061cb4582895f0cb3c1c29e29af55e9cc85cae44f38a0b3ede084bf110b36d3ab65517a6a13fe4aa1a1e3af9826161c11e77cbec5062a245cf72a2ab091c2aca8d4529636e9e990d1c89f8e9063c79a15fc69c197a2d2e0402c31aa5f80104856f6fbc57e9785616cccc414f3d06304b1642c3b56c1a202dcf02736ceb6e23e6b9c92d1e0f068e88249ce51bd9e7c6f470c90fef83480829a9d9e83c6560b7f955effdede84baf2be7d5acf2364ee81aacd9b866d3dd20a9ab1fee951433e78fe34ee0510be470afc98d21fb51d4c8e0b41be18332081ad59650da474c07c52c2e19a0e9384922d4371abf4bed607d21a72e13866bb350efbf11c51a3844bdfece003f5b72b68bebed5c02cde3bf6e6c758daed2f243781e368f477a2242dc135357cc9c27f2ae7bb435611372e6af2c1a50964b96cf8bf3063201122c763170d906aa0b9f76231f4ae425b7083ac836ef538d03c3ca5c0c00a0f36d4b3dec284dd7c96743661cb2df65fc529390e730d3cfd36808bff80be03d0bae03005669fe6ab4b4acb656c3d431035b7aa2625a20236a68c1bd67ea229927621825692c8da898493ff43b3460e305a0d04a0b7f50a4f5a1f3be8aec6ee07616feb62ed2d28c57b46d7527e0ed30462bcd0d4b56c5108577203ee4fd4675a0b50553e5c37a03f9f8788c50efc7c8bd20c393bea7d0f7a74fe6b217af96ac6ddcbc21681a993865864cbb6975e8c5fbe460945fc717a2a22f217e2f3582eab5114f5bde09a67f6456210d567bd07c503fa276a9cf9bc00834ca9d7c9c66ad490aff9cbb9c038d8d0f01a7b4ac725d9dc3e57760323a6d3c262eb21b9b711b8f621bd10731b8a9eee65d34ee837e52f932b3ccba816517010741f66b5b3343f388f064d2fca","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
