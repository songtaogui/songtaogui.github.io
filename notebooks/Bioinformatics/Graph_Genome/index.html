<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66bfd109a40c547ac341470a7afbd27ec1cbdb12736cf9be920037b364014f2300ccbd4457cffcf38a6a022539f9f325b96e1bf453add4c9d0784d8d1b6120c80474ca16123984e6b1260139f9e7cfa6e3e2dd190ac6d958beb3934a15ddb6867e7847d60cb26b0632b3b2eca9a05a310e2dce7ff1b51bbb3ed7c0f9559dd7f53c6126063de42cf6210e1c8b8470dc0c75c6787010e6539384b1562187b4279c3cea9eaa1268a7435a199192f4596f912facc97d4edfbfa7cc8ee1efc1d94553581f545e16e97ffff8b5d042a740491d5a6e46a6d91d58bff25be2e4dfe9066435dd88bb953373355515445148223553e76701aeadc5672dda9c93a0c3d1fd471686fab653ad12c5bfd9d197acba6ab8ef5b6c7ac363c7d27d1f91483fb8750729b7b8aa4ea03b6a5deee70952b573b6c521c7391bcf5024eea2ce31872494f266a5243465dfb3571221364fd1757d6dc663f99fe3c8d5db68e9a8170f6f44e60cdbbda011c4a0900a8aa41089acb72895e911125578dc555017742759f42776897bf1cf9aec8cc5bf8b4b1523bdd7f0da098adb978968a5692fa8ba81acd11c70295ce7e761cdde09062ee3a74ece87b04e8499127df7db2f8b836864f4f68d8f0aa363d68008d6d814e0f24f972b4b486fb26d0ea6b2b671c02faf296dbac72229b225efdfc713a695589612081c5735c91cb692b1785732b9097d7dd5e76ea6c280a0ec9d74c5bf7fe00cd3d97d25548352560df7333fd83804615fe9088b39763a54e21270eb28c8ede70fc357a95dfacfe8922714b8e861b6839498427b5aa0051b0641887868895ee72e49483249301b5e7c0afa8d680dc6792e7851aa0a135c7a0ed0274bed001eda428e7cdee32dec57e897a3cb04f9349f3415d4c3e133eb51cf11e2c5dc26fca78d58b382f2620183f89533975084b7e8e9bcb44082fd0c5f9e0e55c7e2fd58bd1d172541cfd3e42eea4d12563ec8d22a6c899f2fb9e74395d94e7b80ca39069922fcba3ab3992d4771523aa8028ebe79ca53fe059e465003bbff7cf12e75cf3e47ed42c332a7fd18f89301c12ee36a63ec6d1c27a70d6697005c946fd057d290a37e17d10ff865909f83df2c1cad807b4cd9e391b76e3933ae91ce626230120b1fee05681a0938cd6e3c20cadff78113f68f64491a4bf2ef6131bd13b232a09bb9ec55a3f12fc198367cbfd0b98b5c12bf8d4143d3e73536df51be9ce3004e99b6d210bd747be1ec625effffc8e420619e2ae3eb9ee049729cd0459083405af0954f1b1d8ffc3a94973d5b4974e5b8a82f95ab293ee74fdd35368385a7cbd26a07d078f39b64497d012420d97f0ec761d406f61f6f5adf22db237108ce07e876dcc1b2fba14bfe811b52435a43e297d462c06d9431ee7de6b945848cef3a0a29ac40941da048fd474d42cbb1daed6ca3bffe18b261ed8eceb0440e9ff8f8ea7b42431691f98de2c1b1feb173adf8766a68aac51f8bf40a57444dda779256ef0b56296335419697690b4ea9a707cc124714436758e6173a7729daa6922970afe94b6d94de2854208765dbd5102d68ebd66bd88a91497c1ccf4eb670ece7e23a8e10a218dc66c8141b09fcbb83fcc151356d31cb954f2f3d70f20e10c116b7380c8f9648a759a0b721c57e15ce60dae3c2fa85f47b804d3621acc96026475de7c85916320e5e7fcd855b3eb93b9abf282ce2353dc45a2b94b5df7ace1b17af7dd716235e1de5e97c34a117169450b35788f801ce83127f51a4573c80d2d2f7c43ab7235bc94193cf69d72e98bed055c4468793c901d77991f167dbdc704bb6b57ad07397e4d5bc0d59c0f63cb2139c6864c0f2d7c57f8134a4f1eb04426da0514b78e05711d40724140086a6d3cb2849af15097e68ed5e0e0ceba15b5ea7a898e39a3e90c75d7085c3f203471ae1dd59964bdd98e1eb0ee9cc4ab0a833768053e728f67b0520915002040a83b9fd809ca9cfe98a23dd4afb582921f8360cdc0e5d10dd87ae17f3cd7d5501e77c3367fbd99dee2531e7a9b57eafe88eda767a39c3784371bf44787433e3ce626ff1546f777194104e6740348a848f49dd61958cb2a79b10ab3e77de766a0157c72cc96356479806e7bddbf57ce258a06f974be632e5cfc320c3e6fa1f318a65182b5773cafa90f9352df6ac87f64af97bf238712fef6cbaa8485d10dbb30593a5d9a73b152a2c2870e3dc1dded6cbd5943d15587dcc465e4a69b3f44a5d7f9aaa28e5de17e21763cfd8cab247ab5cb54e7f9b62af0826b13834fec673e200ba956fe25aef224c8b3135b3d41e9ba1e220e518fa489b902d9a8ca58e55201d80df3fe9a255b1e3647ba52bd9c974864d5366acc6cfd9c1872232d772bcbd424f2acff622bf9814fb50b1aabbcc76f4023e7dc7d7be2da49b24bb0f0245cb5e55c55950520089b64d5cc487dcb9ba47cbeec71907bd6eeb9f0ef720749a1cb54d2006f49e5ea191cf082b85762b1c9ff1710670e540c87f4b6c3a01b78cf06b0179a25e51b7b08bc780f96dd3b59dd708739c0cf81f17fcee7f9db0d204f39689f946f5e8f6394627dbbde989bf0d77b3ca858674293d87a5de50a4819713eb9eb8fac84788723d4ae8d6721af232ad617e70db8ba18a624d68b78d3d6e9af42c0a81c23193a4be7e6f96118769f324177ce445549fbd825f3de1601f8260e4c63bc5e3ebb026f86e97c2dc6f48335d539b3c5514babd873f85d0fe28c9c54112d9332c2c21a1a0f00f26f1a30ecbe8389f72d09a97689ed61e160a649bd18307b10aea8fd0e1aaa56a5a99ac0981b1bd84c5c2879bb04b6d459020b5b14454db802c8ab648b47ff380531ac2eca0e8927e2ee4836fcaf0f631dcfd1bb37740f1c8c4007d607eb3b157fb6a7efd588c4e25c31b0f0b9b4d21c5a353372d9b3a39d5c4a136fd8e681f37c1aaf6a8ae0c4ba586dff3f07ee198df0292ab3233419ab8a8979fa4356dec8e03081c1abe3504add196c93bd04a59eb8fc7d209db737bc135873ff2f55928214de292c73c1b99519021a4ab006a1017f5a501a79e55ae304848a7b26bd92cfecb6fbfe5f09d79dd9e9bfe7f32fa590364e806a9a8db6121c30845c0ed8709dcd0ec560ed1190e133978bc99a83c4fdce921cb7e66cc6eaec31c44a9410ff29b0fa042f16435107e04e35e6c07d3b8e8827107c9c6bdd303bdc98bd1d543addc392a74d1176e2f4939748022924a5eb310b3b0b0db35ea6480c39caeff1f8a10a60c948f377366c80a73c05fe20bd5c86dcec3b8a99e8695edfa79b1a65f34638b41f2557bd0f8075ae1615801599fb070a0e08f186d7f44074b289faf26234eeba5a7bf4f1840c6cc4ad550a1f4a6a574c74f50b490915e0d0b11cf3230cc7b75fc0694efe818d9d0505f0838a43c93b5f189cceff8cbc4a4ef558de9c8e4bd08c5e5456abbc6368940fec18020f84a2a519156ce0d87e8fc422b9bd9fa882c2514f7c4f25258441d3ba455d62b873969222be05788bcbbd7055a16efd11d9490a25fdea57364e753871401d76df170e4bf90e03866e417060f1da9e63f4b9db199b44311891b456f6678bc77160088457576a3d899dff08adcb689a252d17d5a6e5f9501cf6dd5d7f70fe839c40388e3e92e290aabccbbcc10546082e4493f6436230a2c74383e76e4d430d62b4379983beb629c77b5f22ce6ef58b1019c8b3cf6ac6fbb4ec64ce56f0ab6461439f5df904cff5906ded3b21498d552d7af0363e9f605acc4ab66da8c5cee4bcb494c8ae354e94b92e818554cd5e0129b76e1dac1d346f7407c7b7a27122289fcb238ffe6f307795b5faaa1d642f3ba1136a25be91ee6d5da14cbfcfa7268bcfc8e21bb329658cccf284d3762e06fb64eddca4eae4740cb5081480cf71be1e87bc0f9e4bfdd83594d1b076925323d176c9b359703ac4deb22ff7a588d5ee82617dc40e46f8f2d453395138c32130bd6df9e286a287035d432d69992d4e5736a79b321ec738207436b64aa2f707436f551464847dece5718509b7bd1908965be07f867730af52f58e5ff52bf1a12a562c1138868e4c563b6110d3ff1075f62982dce9e819cec2022704bb3ee76cfabb4683a90b15ea6d9a83d986e1a4a1ee0b58067164622a690a427db809881dcdb2dca53c7b31d5f1adb8178769344c4d2547f973265782551b3e25a8dc2334bc59b31908680ae1412bf1164a8a8466649def770bea5d50c7b8150e178e730ace0c83a8679bf78b4eb09c1ed17e1dda8b6ad5746d44239820e2718f2a6985b8b825ff236be6bf373caf705ed6860c3778a67e9119ec22c5b4d48fa6dd130f074394746ac256e25a26844a3fb507825a6975001fb05c2ff3555a38aaea8e59ad72c7d5b3ef17af3bddec859b62db9660b2b409644546667ee80c8ec6b97d8991d02c7fdfef8726c06d2ec8c2fb81ee5496736263313e305c30a23db5e80a9e41ddb61b42a48f25c48a3b9cd118319c7036b06efd899d82d6363e4e1523c49bd0d092ec5bdb801fa93f9933f1dd00b7ac54d4d3b7ea09dbb057f90f0044ea978fadc91ae75e237d2268d728d98c06467daf36ce677932976819326707174bebe50dbe6d8d69b64b843f9366118d1b9844f06bc6cd6b60109f3adc9b1fe3a26ef9afd1a2a46f2e715a98207f8b6e758b8961c5d64f534c96234f331000234296657961ee54843dfe1e36f1202f45af779c06a7d64809c8625c516f7e5b8d2bf8080fc857908bf3811f51a8d54c90dd22fd2d550574e95d37dad494ad1ab34d5a203287471289bf54aaf8163fda497c5871768cc6c3b7fd48541f2bf9442651b334719d968df6389617b3a9e7be1e8f75df0df21310e840a9728fc41e36cb744620f0a584e7f7e255a5728accdc6bc4ce17a18c888ddda7095f8c51051eafc2b9055222adc1d562dfec72d7588e8bdf8bf082fcec0b27ba19ad584d85a78be1363b54c840b7fcb3965c8d3501187a3048f3c3031305b675bf54f84a1056e5eaf5dcd8b97e78fd4bbdffd9665a6448fd1fb78970ef060ab457022df7753acf49f72a85043ca963f21ea2d5e487ae2257fee5d897c3c2633cc5c92b03d03905b60de5e65b1bce0e1a8874e8aac633e47ad49ad235f44a599b0ed57764b6c07dab884cfd0b984591e486b94bf4208e757e558ad3ff5316646b470aff387161f8e6e775c366176f28c5cab7c933610645878a5fa5adaf807338662689f679fa39d922c322e77712b49a83d3985688689dd185f3f6b8b3e81985b02b7da1d871ccd812ffd7e48a30192c1a4c924237fbe3d2f9ed4a88d7681a40a414df3c8bb46aac1f8b17052f944bfa67bc0c1126f76cc8dca059f302742139cd1d34d864ca430dda32a1b5d08b113d14034b7cd7939bcfce5ce3a3fea0db4075f46b5218e25b144104a83f9b5586802970d2ba8f5ae0839c1df877d610cabeeee62504c29665e462c0f7c4a477467d6de263d2022dff8480296b48902bbe1fab1983a7263c9631d6a0faf13e3f9407bed8c47b8e31144d08c056fc2b4a14b31ea375ee9e14429c2e36d59b4e2c4875c0407b494794777c0e0026bb61fe327a06fe0d4409a1b1b56b2c777514bbeed37ef4f099d8b3ad5eda4e1547bd9529b8faec93ae4b6548a94aeb3d3332768aed65a05bb1921e2fedc7e8eb215d203e1e38ce30852fae590b939cd17faa71ce53134ffa589bbe7310296412c4b0458424116f3b7fb141e1087a710338a1ce7144d738794b595cc874bdf8ac5adf6ba85708eb7f1d1cf430fbedef9a16b7fc2146b3c90655a89187c63fe6daf49a6ae6546051eacfb434441a03e70eb186f18c1bf4ea38f5fd94f45b40564ce66736dc9e7b29167e26e7f303b93caed429974ff85a76f2af64d73951807d0a6e2c8b3e6152a6d7408ac8373daed1dbe08eefa639f4483519aa260408b1747921af8d016b67e9436f315e8196f2109efc3232c07186f8d7f3a83ea474c8bf053e4ac904c21b3af18871bbd804de3efd47defcd091302f2595af9d26b57df0357cc9d45bc57ed492259ace00218326985881ace1f112dfd322e4c21b80da87717a89cf55acf7a76ddef5ae999232047f8802998ea61b04b128587c532f24ca0d0ec367faaf19a5a03957fda8351e53ca09635e5b24f2a9f12c56f08862a5bf1fc322484d34faea8b350cd7282f606f60f85f49ec0a25b34025d7c4a4445a7044c2cbc5cfaad8a8210b3e8759cbd18265122f65d4df4f1f8d5ead08bda1898660d99eae44873ea785d5183d69665e100e269b05dac94926d5a3c68c097cae2fe1729d643bcfa26927c9042c109c61602928ea970a1f405187e0a5cf4977585aa11885edd08706071ec205c8b8bc445aa509b0cd884afa3b0ea702361a7853aa39190c68d3c7e12ff329b39bc2acb1b6e834c94880d01566f49aa7a8a0246426ae7472681ef4506bfe9647e9ce621acca69d734af244b41b111aa102a49020743dd377ae7433058cccb4151ce77ae7333c4be25ae1d4fc49f5fc52373e8d3a1584eec290db68f94fbc231346d1b94538ff2a26a47439e7fb1a7b553c935e4451edcb181829ea66ee3e1b4505f95b0c84b1a35327b7bdc0d7f54e90ccfc64a3109d196c7d1b2fa16ca583f216492d27b4621ba1dc7419db06e19284d1b8d602a12788664989a885d6f2f82443d73ac8997f5893829720214b20aeadf9789c0a61ccce8b615fb3a08407bb1c5eb1c707a56e6424a19dce4bd8f540bcc8d70c9472a60a8cb2c975fcbc58aab046383864eb6cf31c57cec994ada60d3ababdbdb3568ab3a2374a47b75e597a9d2e915fa29e00303b00d6458d55ac98c8938de0bfcc3bf6b42f597a0c90d6c6aabdcf06b9d695f39588f1f209c11d38059664643e07fb9fd3e5bcef449cd1b1dee9dc612b8d7ef4c42e86083d5ebcac216baa31087d702de5f4a2762c6a783611de0f16e4e18889b969969a822c56ae58c2c41da62bf7b4a3b5913c798a0eaebe6738f6a3c19ecd143188e07537974a97ce393daa3fe3b58da83cb1ed9c47050e391192f08085754365bd12a19dd2b8ce3178999fd1daec51cf2a6bd9bb92e62688a9ad931bd00197f19cf49ba7670a6b01c0793678754cf63a3d55fb4852a6fb17223e1ac37906917fb214ab83e4abdd619dae58d64c6bfcef93bae0c7b1095a9ddbdf33bee0ef3a0792fda777a095c9e5e85e08cde50a359baded26deea0905f9b663bea7cddfecfc76911173f0fe6dd076d3a9c9f92c0d9a3052d829a0385fcbb14dee5b529941c27253e8706534b242096d56dace1b8592c62b93098544d8a7d459de417833c1e2efa70861e8993c2149ea1f1343f4498ff156f862811f63ea61714660eef9d4fea0a7907697c356c74cf127f0998416c3c6c6a90ca7aeeb2a07acb1217c286ff83fdd6afcd565493ee84f7e98e26bb677e26a8295a5523eb61235b18bb85c1d57b5f830f6b3c9286013586257a9b11f42274b2d9ea394fc8417405390dde7c34dc3e9eae0d451e0f2130c988ed56615a0a4f67806683da6425c5d9e4d369289a1923e4c17f8ace30724fd1046a7153a8db86829e647329451db4b4bd6b55af93a4edc36493fff54487c4fe86ca1fb42748de93eaa26173ecd6d9c351692fabad9d8ec51011dbf7b523d1471bb2a8ba96607e5d142f6e536133665f5f61dd0874a0db876230959caac896c1705b62214078252abaaa82c5405e129c0163ac87d25f382ba889daca314604bf3b75b83d682f7cd574a44a1f0fd1a2ac91c223a1fb65231e06ed57a9cdb8b8f8df7473a6f3a508e49143d374271b43c5acd6e52978899af8d6f22a065ab0e5152a1e6cfcd7b850b28586c467eea7e33707f778ce41c2d079fd1f930c3ce19f35d131bd093a6dea431c2a0ac07512abf2303c2b54aaca3c21c647c366c98a2f0bf21ca7c90c3f4a5f1dd8495e4737c3c8fe729626ab34905829a505bf2497f9d0a65e7dbf62c8bf08e4a1f489e7f9f6eac28be816362ab7ba8fd84ab8b5a01a27648f225603199a66085c75d5c065ff24de43c829eda23df06f427b47bc588dfa978bd8d2d37e55ac25599a82abdb53e7dadc82d8dd2ae1226abb6e2bada474eaf02bc5e95c1291461413c12ef7f5836d8fb28f193ec55e041a4fec57b5690d191fb5b33f6bda5255849cc3281b76435d5579702f478ec4fe55d6e6dabb1648cf231bcf4b3ad71039476a48facc66bca5aefb634b04926ef52e79a8b85cfbff332b35fe9dd20f016b1c1f2ce17fcc66baeac1246dc163bf62f7226ef00ff891f7c08e723cad9baf35ea0ca9bd07fb4005d505a642620e23b3359ae8dae9e6f73aa4f1f97519ff66ed388344ea477a1240d74bc4da0b16750844f909b07fb82f9f984c161b8b012b4fd9d2685a137aa42a43c3ac0a54bef3359fcd59aff32e5037ca66bfaa354eacc5ea7773787bcd1e48fdc39f3a69356657de630fe0106d8535447228a0c661c911781eb30637f56aea1e95d647c59a638112500c56e7222b63de925e4376d319b7d5bffe5b931f3a1383464361bd2032e038f0f4e43ff5458209ae0e2d146f3f3ef961e0cc98c78cbfc1fe185a77712d5f63b0a93bd9013d856874e6dac1bd3c3d2c9c29e508519f6436a57675cf93d5e38c0ad0299c8383e1f2aaa42ed53b101badda6bc1a5988c80b803b8a4815b9533f385df96a2941aa28712e55d4485335e8dd0c998b602dee76f381a703450d6c9c62927bc6f40c27213368096c190f4f0c39190f08e707da6f99c609bcb4289b7c9493a9395d57e80c73950be8a0302f35462a7cfd7ba59887efa03320ed866fd44c57cf14285bfa8263c85d69c98e374dca8df019b6a0569890e45c73c6ffc5b5ecac9d410307c4fef73dd8913aeffa25a6fa0de72785d6cb8ba1eda437c52d5395e9e41f25d58013116026da194f8573bffc926f6b8d13d8d117409aaf5e7f1a9c69907a6edde4991316493e4897d9e2a6852e7f1df06821f4d365176cd875795623db9d6938dd76e010292fa669609866b510e2bbad4896dbcdf4f7639c13835671ef58b9f2e723f3237a8d7d802f68b8077e3095a07a5dd1053a86ae47e453384c4b0a988b3f2b4a8395f37c58849e5be5cc40054f36da28a40fc0c5e472ce287c44e13ec3b7f5cc54a5ea1d187d2db056e50ea62deeb50b9344d72f510ad9243c0805dac380f6489e7c85ce463e78fb9ef5452e5a726ba381ddd9c86f4e83e76724b6b46f1319a6b89ebc3a8fb2ddeb0904902253f9b1f19fd02aaf3cf2a39e5a32b762a44ac29d12bff48f52f6da7fc0e31ae6b342dfa947b0721bbdd384a6b5983dad806286a7edd63efeeda28aae046360653815cafdd834be669d55c207ba9435eec20a1524c7262b7bf5f290d4bb5f07c4a55b2e9fc4a0c2bd8b673858dc6486f726096ed4fbc78e3d8d62afe49f7991b86b1d720d58ac95f00c4ae3ac7194309f0327cbe026995ede26ef017eaa2fa3719f75052b5a67e5064fea2163e39f0587ba35fa0a3616b633227d905f2fe82b2c9d5cab70cdb86db7104109a7d5f0a618d5b821408fe9a05deb0b969aab6e54ceae68110e51b9a40d58e281967fd75c22fb44a9f430536a3142b1f5770a03320c7573199b9858a71ea937653af435aeb3263d3fcca7b111c149f2d0f0f605a5f31a8d5a461017872c036ff252bd2d097601c5963e1e4598ff2ee20fbe30483c41adde253c3f149ddcbe39b48ce0fe0a56990ad4fffab39ff94452c2c6db9f40eaa5131a480a12e367c0def0c7c3cd4e729386ef5ccdad64a9c488b7c5db9a49613f1bdd7a4218bd01e7ece961e1cc6a0c5a0047aa545f1bcb61813bff3c298f735062e70b977af8ddd73733cec065123970e97a4ed2d7535305de9280bd4283aad079fe22ca95293b2b389d1b9e9f9fa766f1adac147e9dff6cfff80147040703041a2c50bd9d2924866a21a57028d1b766186fd2de51548e6048fb1759a2cc98dc8dccfc7a582ac39dec2e6f04c1e05f0ea4b87fa1009bc7fd3d12a7d008185e924ced8ffc9f8ce2ccb293f3182d53a270007c942ae8222199f1afe7680fdd8065d8a555cdb8517dea932b07245231a68601d3bce0e3a6631d14940124ebc1aafcc6ac81866de7a67f9b0db80821562ea86b2b1adc0bfad8aa95a92660fab6df891fe1bbef21fe03fa957af9dab58822830e62f5e06f0e2f34a7d76f8fcbfd5fc1b68c12d4b413532c151fb0df5f640425f472b66ade8c2a39abe5397392d3d6742a696e1f4e70d3b4f16fe388b85978b55be400ae0b75427cff8cd7fb06afdc9e852d67a69936c933b45f8d8b3e278c7ebeaf43ad882fbe77a91ad963b750b61d168c9ecc89acda702ad2b278ceec7822f3d7b29839c393e08c565dc9e7312ecb5625d58d6d8ea88b352dcb96ac359560e3be33e886f64f95763b42d3eb43b53f6e890cf175e4807ce34a75078d2fec7a9bbce328e93f7c0c42a8eb95eb809b0adea28a8788d1cedfa32b643bb141f12d7cf0ed32595de36c5336d76e447b10e70f449f8762f26d4eea32b79e668604cdcd8e9b987cf718ea025c210a716d619539f31dd810e7b793a209b9321802eb8ee249fc3437b2e67c2324f32cd4cd605553b36c3eb72ccd50fd3cfe3a9c92afd262a560e9fa79ec7cc679115a355f30f7d704b1c154aad2363adc3e1e0bca9cafd139646cdd281645c1c3caab02a9ec653533039968283350fc3ff3b51ac22e507096855b3cd6aca26a904bda44c770751d660b0a0be2f287369bd9e2854eda8d68777658511678dfc9d18a154a273526b5cf50c84c72f2f091f4798252a8e8d369e5439a070f6204afbed940941c9a77acd68f50a0dfabe593559d770f3c5958dbd379d1348295d5aa6519feea94c48ab5724188bc7ab058c4011ae054dba5f85b91d73b61829dec2e5b9496f68c360213b15bc3a780a72f5252475f475abfed4f14be97fe153802094ee9893c40ab9c8ce6474c3a9b5316f148805fc5e3abe2119e7689e635971bbb7ab0de15362ed0ff8d9e10731552259703e9359a4368a1f0d48d31248350e81e8783ede26e3326fd877ae84a057955f85a8932d5646e254d83805b6254c647dd6530e13c7885e94ee520a446121e731c6a4bfada6de0ee33094a7976f4c7a85262d1e26e5a434a5dc76cc614a91800c63afdfbe8c66e29ea32b28faced298f5eca4c59ab87fb6e3cd39cc31050ebf831bcc6a14c1fe7b31a6e356ba7d92c07f02e9753b31a143db4c720af6a947225008a1a41c868b6f369feaada237b53526ea32c1f0a3a0a341050b2da7e5a09941015acaba006cec610d0de044e448c3bd462f5d99f0c602793c38e6d4061f26f3e46a5cfd0f10828af5c1843b0389e658d5c223ca4dde0ab57e01262414291395bac2c79a2535d9a2c730ce7f66333069ffe8a63068aa7770f7e3e17421bd253ee0a81f008619b106cb8fa49b5fbad4dbf63e90e703c1c5c55a6f16af318339d323e6524cb806d7e96a23cdfb785180bfb51b470483deb2caed9fc758b21674b44f6345b93f778c2e36f8aa6d5e8f99bf11372daacc0f38b41dcab21de9763607392e4a84037c2e182f3e863e84c8445141f5b2f022aaea40b161cb6b3198bbb98a6bc616c98ef96113c8ff1292d23df92fa47e784182059e17c0f4819058a051dd7b8d9b1da5fc1297e3b4ca2df0b6d3ad50ff2a991fa09913593f62e0be177110c21209b3d2ae6d8e6517a517bac38dd5def2c85f83ff350f9c79e64835aebf32fc1fdf5db348333d4654ebf53739d5a97f6ea19330c455eb3deaa33baf7deac85e6c4077db931bc12418132f6e7a5aff79ae466517ec36897579592e4e24585968e814065f088ba8e5dc42bfa245e0df59a2dfe83260718cc2fde9bae3482d0dd3fdf6bc106360dcff3459aeb60f34884b17f773d1b28b4b4a62015bae8c1ee553d3410b57333735bb107bcb7f154c84dca5a7a627d01ba59dd741182029531b8174162b9ec191ffec9c6bf5670aed6ea760cec23127986b2b2e0578616e4f2972c61ec2f6931cb3528e6ecc0e683739dedaf33d515df14ce5aab886bc35826aef4761684a5a31fe4b0054ea1812e461a250e029f82f3a6ce21559232d9ce398b5bfc61ca09d2e2a039ec15265e0d9f2cc8cc46a3be763265a56a91927e6d71f73c4f013ceab237bd9df7472ea9ffba7bd05845bd118fa2a4a2ef82704a7d0e781f7f51da14d808ae69cc0ef0ef64b1d1933a2d40d20c66994cb19cc60e88149f558e2d4a66b87a72c6d24705f2e189fe050932c6ca1c3898cb2592c3246bca10d6c6e206dd0a1e1ad69f55ee784df6d85be07df7c6fd51576b2c651039289b5825a1117a42777096cc5a277f2100b20be640e70d7150099e768954ab5ebdabcb2e4418657d9967e2e07c0fea1d4fc7d2797bd61feb55def525ff8005b21854652e4a143fb765ccb178f7fa98b77478827fbc2249cfa4788a8d8fc5c8b75cd39d5eff4e1baa7dfec2594e0146ef4ba62671611503add1fab98e27affff484f726943559dc3433934f6a285585404ee5eea1397da730b60ff618b619afb234e9d801a124e426bbb62d9d72c6db1c32d70e1be2c97a4a6c4a253245973c103a0edc26390c493b0f4c1681f9708570e83763a9b9d9dec16d1544d4f503a73af3c73b27b7790aaf8229d55b938424b17883157f4548ee41d7c77698c750a11e7c6800f4a53e133844b2ed9f06e4019e918a358e786d7cdf6e4629bd992a896208fa4d857d93d14f9eb75076be2c8640a9714fb4d331117895298b48f2b08f146ca73865f119194d29044788c9f7608cc01b846985b76b64098567ab49958eb5a69980d6103c191b24107f03f10f2c9f05015b5ec81226fa23139bd80485d61f13ba440ff86447dc1de8d6c62203cb0e473735e0fa22a6867f42f24e8d3fb1116abbcd280ccd31bb3d8e4adf9ffa1f2132926ea3d4d278ab2f6e927a938f53b6961a5abfa1ec95b3d7e486794f7c9b21081d00f2d6b38b00339ad572741220fae01ebc9d7bff92c7bb369342cb399f1183c7890d7c8cff318924cf889fb2880d5a3a82ce6701154cd6a127421778fd230ea631a0ae96022d153970e3e81975ca58391e7f6d22aaf03b48ef2ae17a00549bbb0da7d053a62ed70bf7437e6419b69249591a3f1c17dbebde5af5fccca8ac45ec14af7998b074c2f946e4640408176044f8d5cdaf069d8b9760051722f763ad94622acd9c54ae766186a692777dbe2b998b8cedf28a1fbe621406c2ef05ccc6d267eba0394a5e04ad51b65e03d04f4ddae9e0d5c10dfd7c837c536018e73a7979b45937d9d9bb9ea316c3a73e27a700d9b0ba67427165c6356475c72b9ec02104cabf64179a3903bdb0ea96f4dd2aae98455fcab5b9de4b7bc421914660c8ea10890572e99ec25abc9590c3e20fe30abcacad186de133fb8bbed843f0cb084c8d7ac50345e8b178cdd93409e77f5693192ea6cadd9ed30b5b76ff4e8dab26bb65e7d7f1ff25a4580352ef069e046fc4c824eb6a7cb3e0b271cac6121d0a516213e8fe10e65e233b23b2529056aea02b380fc232b90787760d5a5174a35b9b8b90fd8ec6f4068c9ee8e823371a76032204b7c52baef517e6bdefd44671983a597015a951873ebdf0768e70930961bc9294ef284f32993dca73621aeb5369f0bdc39c33aa936edc0a556e66395e727ee67a92c45fb617794b37deeeabe9fcc3e90fe267fed5c3d1750e1f38508537c77925d71935e4dc5d315d62d56a9cf098a213cbcad722622d6f2400db1a04a88951305c5ae8e4102a86559351d198056565873a391d5e1751075b3fba0fbb8a78b1c5d5fa7f1e7716a79f33fab88fcdb068b3d43f059ecdbd77fcc965c39900bf472b0d35f6f272cf70b03efee6cdaee75ff459ca9f7673e6bfa59c98060ed896ff8575469854109e5467e39a1bde8f5dca3d2b7714e3a1f72f20d21c22068927e74bce2bf2e6beb04431386ca71b97d4d755e131df08d08d65d0b67ad18ff86e92086751c9105035dc05e49693995649b7e72376e4e48a57805968a6dfb16aeeba1269d294b0f427cc89d8a98083c53fb1b6b2b67b9505af9a311479b331aaf8789d8dc21055c4e474cbd82f27e36f3e76a596314f4ffa3e4f18b0254a134d680a4277dbf78887446d973f40179b93023e276ebe9728a3cc59c023832f4a1c3c06488531a31f32aa9cdbf869e3dfcea7d4d369ff5112d49866397fb6815515ab2a5fd7977d40ac1a8352f5b92f232a50238ad2e8e0aa23d53478eea8af58979dbee22e69342d8b54511ad4c4b0ebf708069cf916b17993f9416239abc3f1e3784d4bcfb0156068aca0a75237a20a61754feee8771bdf36bef7df4192246a5b0712b4483c26c457b561e0129a8a044b1611af2205e285576bee852bb15099f0fd5f254cd7b4bc59a9540b9de718d7403f6c81a43e8d72f1547502f9c5087ffc99d55fb6325538cacb8f8234c55bcd7b1a4c926911a2b6ae01a44b9188c9bfac94af9ebb493832dced742fadcf8a2fedf0cb44b0e383fdbbf0352445883ba9d10b7b2d044448e9aba2bc7ffa86cb7a315f444060eb0318abb2891c3b328c3211d5bb240a62479494c4fd3775f1b598c05b4ddb871a767569030683d1146c30ae77bc15847c1b0f3d85c8557fa38152f243fab9f88bd6c7a23f7eae97897b8d63d8a63450326800284f0c970bef8a90952c424e6e2c41a3238a6689e26089befa0fa9c529c344b187b38f41607284b7affffe1e537fd55107230d2d5cf97d5c885322b80b3284d9dd8d86f6bd5cbc86834c8029f4e1cb8bb616b7a4fa156c0de4ee7a8cbfb2fe84cc73de10331a63c6907624b8cdeb1b604c531facdc8706aac278bf180077820bb9dcabfe516e18ef68b67b8579d35145342b66415ecda176fac8253ae962dc3fcea5c1def26163bf1ebc483aab1167e956fbf050ad529897bb6c5f825449b1d6750b430a969bd5124ca35e3c331937c708fc2e02be16a25f4c6be84c39f19009e297fcd389f59087bce8e62bb69e425d102595ba073567ff39180de7b54463a08e7946d8d61438ec3f09706b7d0e33eee8fdcb4a2f8f5cf793b270b6aafdbefdd001079c9034eeebedd38999b79c74a974b3eb9ca676633d3d50880baec4647953c6f178df76bd3f0ea8107a9d45fb966f9633b1261c3fcfa66e37377a5e2e81538b664dd8cd28d1b99d274fdc1c603a15119f62b6633dccf79a8b11e764b021d1d2c81e80574564a2038636b546eaed06fbcfbcde6729594a5c319a437a4c6d1e16bcb1b2fe72f1947c10256a068b14b51c89e74d299dfef186651369796eb753c61a1640216a1526f0186c748ebf46ceecc53f358fa429e704554e6f6c594cce701092b8784ae9673fcc0bade82c0ddbf553cb6e26242fc9d7c35d160ef2b0e258e0710f4b234448531347f556c7a375cd16246d0a98624891b7fcb71d6d735c8e0d51366b8cf9f56a7672859dc544113c140f4c8d263740c5861e4533997a0e0ecd2afd116f913738548a927caeee28feead49d9689fe0af1a38861b695d468eefd3581fad93c6c101525d3b95768135183449dc9ec7ecc36a7ae4979108ffb4a1e1f7b72db7ed734c47a61d5ccce33e5c3013007d50f21beaa8b54f37a1b10c6c5769e5038f89a505a822c9e814b8003f49f8acdf4cf877833de72074d3e652661bc02319fc8fe9a302f9cb0eb05841e0f665b23f52c98cf0a82838dda384f7832daa627b2bf21c2909f61beab6e140d56c9d6155d168f64bf0f7eceff032bd273e28a58759e1fb0eb00bed9257bde5da0033cf3ca151a38dade370abeeba7b51af244259becd09117a0bc7a84482a5e874827f3be4f17187a05e3116c27c95a803d745ffb2f278814829d57776705708a4d2d10a3b8fed84211b1ffd6420e344de74559b095be72a646d3f22245785503393b644253ebea78bd43362a02f1a85680fad18b69fa8c72dc29de5872eb1d454d67b1b9df099f87f50283c530418549e086685d75e96fb6cbd902111f6ec35dde19f28a746147a61c35e504def3d20c93a6d1dc2b10bd60d16ec3efe78589c9a91cf530517e4974ea8e73909c30bd6f694afa20fbec38228ffe017ff8c55b1811ea18f3bb8f9573d8f9be45d11adf080ec868cc5713df6fed7c2de6be7a89f2657b8d961320211f7b492bdeb004b7ecd9e106d5fe50f8a0b489912150ab6fa74ad10d559935179cd3c7a2d341117c0cc327d48a358a90912e5cfb0918b65a5b5b97ba1ba0386a51cdff8846427abe90b6d77c6cf192f06f3009069af3006c99b412a1e301629f5091046efed1834f456803e5e8ae7a0c0b2d9ec0248efdfc939c1cec4744b64bd868ef17833f532caa3187a057a7b4fe675aa9cc5db8502bd0558672ee717a29fbed14df27515258929dea7b0e08209f1c8387d27151a8a6bec7df710ea83de82781dd061c14b23153e72442efb7788d5dfd6aeab38fbbb64bbaab385f228e6acce0cea369b44a1676be74d4ceb64f7507183fadb2d70d4c635d4cf590de172dfd2bfd6fb7d17e3bb59ff0f02cadcab50172676bd7588c01c4d4de19716a051b2e943d62faa52b318149c52f333e82925d2d54038bbb23b93291a6c81a3d5508691714c34e08c7f30c089efb5623ae02649e22798e3de8eab9b777a32496538ee6c07a7b7edd6b3040d0d98025bd623428483f02be65651b0d86e3932444f82d69de073e2bd93b23c6e5eda520b5e48c341022d2331ffb8a71c5b03134ae9f5451336f7068793683586eabfd22b10ead71b6ccbde91b2f93f0f0fbfdfb919387efaac8dbaf15ae8234e02e5cb20329b269358a5ad2a9b72f38945f8ce78f49e8200056e1be2a7626a5356e204539c162a53b104a8335c2e5ed708cec60e58b3504d062810aca293a9df4cae7f200f39118a1a4f244ef1b32821e29e01cc64dfb5cf2fb5b40b485f26e645a9d2912dce352855e310e64aad50c19c85604c93acdacfd6ae4f30a462928116a85ef673bb0634be784e0069b36b2f756e3e9f7d50cc2997a5f7245b77e5f81c0d3f3aa032f00c63192c3d9eca73fb7b55597bd8eb6730382cb2f1778609a03ad4abfbb79e1f2f85d18f584a8406253a509023d0b7056a3fba63f242f3f233faae16ecd2ec9e9885dfea607fa65549fdd09b39c188b832a73995684214831df7efb143df6c00738e5f655d892c551681434b91a09b2783f4038716e35da4d3195491f0395d5cdc7c2550637bc84f57c7d6bcfdd8f4b2877ff7360866410e89d924ce8d7419ee6d53f9ce26f1b599952ef887a01f48210752d66ece5b5b631253e8c18ee35d0022884405ef8037cc0c127edbfac4b333826729ea2efbbf923133f7dd2a8514de5a73dabbeb35980d43dae82d16fe2fccaec24955b87dffc962de91bf4ade0cb976d07ae98295ac25ea3c03c28d8d6af8262faca93158e167d4477357fd178d80471860940e1c44c58c17b27a28fb173f78f872e843be297a1456543fedcff1d88423aa509399f8c93fa419b1cc371c06530f1cc6c88cb9728de9147599a9899d31a1127941fb21093c954336805135a78fbdfe6e3e03da103b1e3465ccb1f70f0ff358c45a1760a74cf7766245e6f1564767a5887799f55e23708405987e6b686bc213b9c5ec68759437438877710cafcf4a198131f3ea4b45a3d08b8460620c98599407bf1e2dd74718fbe2a36cc280facbec37aeb8a57bcdf942e9ff575e93a42a5d01a3eacb5c9f1c29704e46f62927738219ff34d702c2d3f6fde4b1efd79033b947e8a99bf27d766b29ab21c76dbc099c9a41a6340fef845a92f132c46e2ecb15dd2dc29cf7ab0c65a6124f04e9880e08526d4f0861cf8bdb4c5e2ef5baf529481033d66c54dce97714e7a7749da09540a6d29e85c3d0bc4235d6982420a34bb2554f17404db9149f01555e006458c9b4482e9f34f8f522a8c77f054c92f8043ea431895d3d67144ef9649d95d9e51ff40f5cde8c01f8c35669818bd936d441bb57807210af754c0191a28ffd563a9c73d7082511e31e2383a3f766b385f02ea67ed28c19384c46ef2d400bb305229212ed37499efbe42d3781f599215f9f224a4d15e16be21498900cace2f084b39a06602fcef584fb39a1a3d5cfd9383a47c5988563547bf8f2ff88735b686b743a3ff38e0bfc758e3fe1298029585632c453dbcd9b73ce39d3722b95367120344e3f5011cd7d5e47fac47ee653507a5fdb4ead6d14d3259e71ac8a708eaaa971770a15b81af862c24055c9fa1bfc9d3e08a7585e588537bc4144759281670c1c1824ddd12b7aa8899d46f75e37c02acc20f9d022677ef342b7ef55bd9ccc60cf53fe52d4e036080bef6897049ca2c131ed454c7528734530066e533ca794870f00532ef7d8e23470214f0ddcf5051941fe0f0ae70910c53e1e97e7143d6629e4c9db1f92a52965e08964172b82fe3fb53ec4ae438ccd06d11516c696919e95e91e2e039e6da6fa9d11598e1f39dd63a58f51b7300968b669dc02611213d038495a2f3476ee6f19657dfc86c083c79b324d129f3fc5583c5cb92504c6153528ed880663c72b709b17fd646fc0a77167c6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
