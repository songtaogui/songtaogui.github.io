<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65679b90b9845120550b83a658df7fa9943704b226d8bacac5bb398a6d0a6296252322adc731bb04735d1298b6a93fc7dcf113466de4cbc897d384006c1a0e5cd32b533eb87c74468d567e39762a4a343eee892821b7a4ae69e5b85499a167aed97cec402f195c78b8df1774527ccf3676a622bc25a336913c4eece7bbb23877d43f4b3c34f5b81d60b851df1b975154d593d4871ac083fcabee62e857d88d807205aaaac7354f7e2fde77c81e6ed471cfab9f4eb4b53c2b78f633d6e740fc0ff0ecb1b7ed16a5f268b3414cbbbf96d5e0f293e9b481aea0ac78e32e43a6926266a85bffaf49147fc7808a71d19c93cd7a7986d7927c78c5305f43003cee8d07f8b8ffc9788e33f788e78b5afd4efb2b649a08f71b7052f2587d64a7c07817772eb2a603583e79423a72a71f36dad486c6fd7f19dcdefe550f68a950872dc30817165815e0f71fda7d25685384705332ab0d73f06ec68af0e9bfea116ce9a9c01744c6f120bd4882f583ef454573975f7d02d46ec6fc3d553849e7673037c97491cc83e25a6aa12f97071d9604a4baa7f9eb0a727507dd5a3ec7322beef950fce9ade4c4622755cd8c3e4d917194d49e728f0d8a23f710c55f20288be59cce4491be7785344d09b28f0dd4ca5ad245f3f006c2b1019cffb5cf32cf234bc90aa61cc5592e6dc72c3495095baed0a734106e6f5b076205ce21570cc041ca168abc36ee796567b4aca4f29deff6c615c11ba6bd81b95c50c12b31a6401f62c5e09c744d49c9fa2376242abe89664e5b479e2cc9228004def78628ac0ae46e309fad164532a352a6c4e65bc3b43a486d7b2cd45acffd5b94468853056626916b7079254e26543cbc585660072bddd153da21b8b859f4dc6a73df1c9a6c2bf170ef8d768e4eef3af9caa933c84e0c4363156bfdae8008e7be87f383458fb27c3edc5850b00683c9b1d4c43478c04829c24145f31ead93d8b886e3d5a7537046a89407cbedcfa17409507531cea15befee5c1a9f7c29ab300290e500795fdf9ced29f428693f99493c9acaea357e6a5f8c4ff10360c5c5107ae4ea86959466219c1b4a4ec2bb4184109a364ce790ea864eec4af26cc1173a7e3720035405ff4153cdbc454e0c82f83ddc27b57524edca4ae908b13644c490ba2c48044ab739939a14719013ddf63333ed40e368d590dfa75b1e82ec998024b0f103cacad2c9769f37a94ebe1b7f1b5f8abd6fe2ce7c5a9801902af089a30ef149d3eaea3169cd4a79bfef621b3ad618bd0bd164b206bda5730e0c901e43bc7635915c01cedcdbf4f5c6baab843803d53e3b7b8c8da613542a7971c9324d58290e37e8bc61f2fb47445ec28239d2730c66ad0ad7e39e73815424ab8d34175931c3e39d3c84df0113fbbd8f94f399d9edf4ddea499173dd6a7f99a2bc847459ecb1ca3085a6ffe89c5a964dd6c353eead62cbf8588322406145a8c11085e729861e2f701bf248929d4126e5958dfed54311f7b78826948a6fc72a1f50f048626bdc70ee95ae102d482e26be195caf58ac131a635eb528da9434e37baf0f9986e56320a6f7d5b5a05132ad7faeed5fb2c1f23be794619a3ef2f1ea55b72fac95e55d2696b3e267e9df337034b9915d38555331b4893f31c556312f2118042e71db2c4abd0729f3801896a27ae8df3612db2416188b6445a18377b18016ebfc1fe89df49c361e191ec6e85452edccee6555d7d4194a8a8a993b68d01231366c18a5e5c18394e5d484070f9d3fdf628b8fcf0ef9eb80da65831e6ff087a72e134d9658d3eac3b145c26830c0e9ae31685547fedc0ffa5047fcec940ea51ac2d73f985ec45941d6e19a452792b6459b7f68dc0500134c132cd243fda755ee571c927b0e5eee00ab72f58a23f71e8631dbc90a4aa0d742aea7374764f1410485cf7fc3ff80a376efb5b4bd47434081e01580e60fa57ebcdb0c7b511d9ab7a7fb1d049f2b5bb1492ca417b2b4d9e1425425f35e8783304c719004817476f285b96079e8c5ace9ee02981a45bcd5df1953fd3c93be26b80d970d5c82dafea809cb603cb7b0f852b75790697a0e84f63fc9175b30116272e812b132d66f6e4de011b5646759ecb407e3d2d8fdb54fec79e3761493748a0565f6efef2bb2e866f1222ffe33a91e658d5ec1eaa4d8334b6ba42a1de257f50e88f5e244085f76fd4964e31256a142ac758b45fee5abb7d5406ba95cf63f2c3bef356256ddedd17994b5747515e5086facdd5467cb0067e946c5961250dc442e8898ca5aee0cee54ee310e61489ce242ea8a89ebb00133a55b79c5ae692066192aaaafb1d19e938890f401bfe97e7c2f4cbca5c48b65b760e35c1d5632851c23799b47cb158b4a4a4c12084562c73c64cdec39d30f6b9b6c7337ba75e1def700753f0d00eb717a859b6a327bf4feec2e6f9dd8c6e3c5e20af397ed81313b47082fa8c98a8f5c1c169bb0c26b2000bac797110773efb6fc78dfea9af2235aa798f7e4faf8f263d9c76c4eecf586e721137be5a53ae99eaa45c33e9dc873335d348102e3ace2f5ddde4ab6f826775a7f6a5cf14b757c5bd11343c1b849c7960ea74ccbed047f3cd615aa1dc93305ff08409427c9c749e5941c35ab4e6f92e4bb01b4c78012d03c0efa0fc3d0a784958bc749902163fe1cdec09119263976c03b9cf180c64c08482d98efc5bf84ce0bace9dede7e6d65b85d30fb0f8cd615a7b0d2267c6a52bb006c9848da33f2c8a4b613999410824cd0443968978f6550b02d0410ac64b9c2fe90c21d2f566a81880d2ae2b25722e3fa2e1b1d9de0b3e233e19e172022c22abbe041e0f1eab4c94df7244b8078527e53b123b47e6deed230ab10fa88a1e2f2e74fa0c8fe2c85665d01f6ecc9d596c593552ad7f92d2c3d1dd29643818ffea9997d7065951fc2f4418a906ff0540c56cf2154247ee8a8761e82b8b65726bcb41cb9eefd16bb162dc11bab60bb31bbd4f627e15de761f9fe6de07587f085b816a457653a8d032992923d4b648783cf87578bb47d01a127e36d6781e264b1a1f68bd4ab53604e38a12f6a534ee074701d4bb10e8acc881842b26fc6e093da80bb04264879753a01e9537dcf5af7114084ccf6ae94f79cb8a4133b0f2fcd39c1f0bf4a0aea6701324139baa1a2e9e0c08b09e6ce0ec04bc0b010d3b36472232df6fc7fa9f95a950bff1c23e85f28be97a3e06f60abe5c05297cba6b02d90a6dbd343a2cac7a239abbd7b8b0a86de6648d344d20f26bf96a6a5464e5457b3027a74410119dbbef1ce032aa32d13e76242817aab790dc3284b8c351be66c8647274395eb6a81528a57b782cffdb6ecccca9cc01c83df2f65bb182f3838638e8492a926dac3626f196f45b1894c89f4a891772edeb494c630c45d9a34ce2a9a7786d86e8f1b94e2bb96a79252e833797ce9b82881429c9dd73836aa3b7eb70df9f6a0ea0f8701c2e4306dfe9fe7a75404e8493ba7ab76788f313b73211c47d44f99914f3e86ddd8ffdd5aa133fecf3c04a38c882786814fab87a82112483d6529abcd225330853262cc167c6fd6166597b8a23b5b3de72237f8460a5f24039c8ce7517e415a65acbfcddff279aa82bfe32b9e0c93b379d13074f2aa5db52cdc87c98390aa7327dae25ee424a78fff8e9ba1541debf2c4a23d2e8dd3863ad887e172d7b7044c4c61e2ff9968736563fe62f7d1c3678bc9a71fa22067f4b34f99597577524c8253924da49a9a9fd7bc7977d5af67da63615e6662147698b1d06bd3b10d75bad31cb03f8975bf54c7ada3d23c31449c4266d16673aab19d997fdb1b875f13c9537c09cbab353b8f1c75b9e051a2a8d0349bb70f1ceebf4bbc52f7895eec499bdf91c8158f81cb19cef6997a3fdf36518f1e5616c6d6e682175dc5f312f328376a9481fbe45b2770e8304382ffc54c514bf03702142d85d6a12c65e1a8bd067c2a199a53141d8b759e2731b004794ed4394a9b8c2c6633055eceea7fa007ccb1757570fe26d3cc413369b45877c64b18b8c7162e5157fe58cc493672239121810a65d7caf07edd189abcab0ddaed810b4f909892b2370bb5624cf8af7163ffb89c4aa50db5ae6864ea08e7a90cd5f3140ede0c24477a38391090476e73303b96f4ba49bed6a0ca90a7e33123a40e8989815260e3db18b11da06f00bb004f677567924c350459035eb29e36a6aa95b2838c89a209351feae049342f16a03fe64c3dec384b4e1ce5db571ce047c65fe080dfe6142e3fe0f7247322ba9edffd1226ba40048c95e2fc07d8be79a1358153ec0272d094ef45e81b99a5a633290f10d74646dbc07a836e54eebbc8557623db67c620ef545a54e53a02fc2dd36743d0be492ae9493e9e8d376c6624e814c4e7559cf1634fa9026038cc8471b567a89af90c340b27154c4a93cf6cdd359929a025690fdd3891f99e9a8357a15f1f089fd58369e22880eb16adc6bb5a897adf545b27c032cc4469b0d49990475c23644dfa0722d32422a0d634a4597748d43e47cfa17377f8b664ee0ec66cf3001fb9cf8b6e3e7f06d064ea9a0d5c98d63f732707d36c266bb3d14fae050ef2364c44122990bc1e1f56f49ad28ca2a4b220757c921c1e75b7691b68b2d85d776e04b92648373fd345340c7cc356c80eaf1bae33b9fe497bab35a998bc6cb3f297fd534d4cadb429ce8727ea425ee2cf3d64cc67aea7079c32df51f28c357bb52fc353b968bd159b3590f24604f639f7d0872446cb454abf0b3b4f18d23983214b4666fd1e0b70853873ab1b267c2cb355679a7f18779429af9498db4c658a3743e548928b81d63ff86a404c0905b525369928282423bef6f9ea33acc301bfb25bab82d025395b3bc974f1bd7389c245e78bd14bbc5bfe5004a181142593afb2be7cb9f0de7677c1450765d237198b6d7d5443b40a19b6bbc5b92ca18806de9f384eb2a1fd598c10dd62eecec07f56bb638a27254ff886561ba4f80cc00212f4a709d88dacc33489c58fca65b4ea27f22b607eea1e987c83c3aee967d20a7553592d3978d4c0e2dcd5d27c894ba59f0d99bb7d100aa0d995e134bbaddbdccd0915c8f08a1a9ddf5c836d0c9496c3752d95795112cf4f6991f21b6f1cf1b4531706c8c9a720190cb6657246a3e73c7732d84b78541c8ed0fe39fb2838b699e54e21372ef1d7a188e0306864391f2f48a0db99ab9f09d424f4aeaa7b53bfeac483a918ebcf907688d182e82db385901f8715d37b87741933166f0086d6ac93208a461bb2f70fbcc1ae451657d168353c4dbc9dfa6e761c457aef483e2fde6b958831cff2b8b6d88f0148cc7bc2517e8056c9b814845586fc60ddfe9f0312154545db780c42a840a66a49faa33bf1d7b73daa7f0d4375375f0d319284159602235ae72644d35e66a4ae3e0196cfd0e488a18e762a094eb13838667c0eeea88c7acd17a172dc868c1814322714797b9537843de7147d1dbb592402a9bffe70111f1547746c0c8901edd625c6c486418ec9b5e5b70b236dcc3acfc16f265b18b6b25f5ed51432bdbcda854e7fb7698be234f8f6d68467669bcf704a27f147cb2cb96060f1591e35687aef428113463fecca74e2f96a3a115520561e293697105e5e9acd24be838d1082a6e53676c39047d55b37b89220413565691480c4329a5f285817ca6a6f16257b5d2f2b8ba145ceca102614438078908dc021d68bceedd6bb4b604d043427f733d4bb03d8b86147dda7eecab9df5d52c39d5867a012243a630d94db270ff9cd462bd67967bb55dca0ca31239b848cf5c90cdefb411e9e2e2cb15533d845f13df85eddeb05cdf65eced6aa929641bf787a84a4e7deb58951b91ab9359efeffcf7ac6b4a9080265f621da0523a7244db4048b8294d9903d513d34d2c44777eaf8f4aacf4f6f4e960d72b82fb0f6d4738f41a5ab3bba13cfe44c07b3ae4a0c2e16e5e618266b6db6dc1fb475bc3fb4683fd16f9a90b42a9e38b5ad9a8ada42fb54b29c2440c1ba9211c1a5130b239e51db8b4bcc745820ab712e020da2d8fc5e3089bcdc5633551ea064be8d2225469ae8529c51450cf5d2b8443bcb9e5ace08d29e7b7e7871cfccdf25e25ff3c91709323f7bf37ef6bd5ae4b5cf6c8229e328ba80ad02c3d60a08236356eca69bb9db8ef01c0dd3cb59c438e317eb11d60b0b7b4c9b061d3e58074aac85d4418be0fcd82f8ec99252354d0d445a86deb5b2c5165e5a4691ee44b0b5c19ee57d3c02af8d91e94f3a484043243c2fc5c3a7c22d22f2ae8054f2a25f887512b6b83c587ddb6971b2b26c004cd1629e4daef9b5f914a0e2b572ec8c9029689ca62b80631f8e644ecdd97ad789d7626cfe8abdaa94fb543291f1373bd6f60f6467a33d05108dc664c6ab4daba0b110ff2610ce7aeaa476c817f1d74aa870de6accbffabfeaa2df03942e634cbcc23b694c23816480dd0debc6de164aa5d47de8b4d815d77ac111679d676a27655c6384241ff5abdd82f124c4c6007d6027804482a4e80ea6fcddc98d6f129cb316bec5ce7084a03ab4eaa66613d0c8ff54b899d40224c6f0c342372ed148b98e9d1774c740ab7cd7d4270c374812af85a8362f58067024ff493876a56331dca99c6e4f4ea189b7ef8965b0335629dcfd1bb7448f105c6dfd7822368cdd2e498a77bbc57546b61d4efa053f0ae3b5c5f38aceffb847ba5c94e4bd512c0e4e908aa24e736f34ccfacf1412aaffa03c3a3336a8f51a3e1472efe4268fb2442b0d1351b9e1a5d2f313319e30fda428fa521dcf9523d2b8f6392372a9f69bff51f3004946d7b5c3af14c04d82b89d0a80e81254ccf17dc6697be861e2880588dce0c0633e2812b037497cf7b510d0b171766c9fafc9c986239a1c3875e23ed9a19b6508a474cbaf2bf95eaf0a3e4fe2c48463ab7a71c167bee6b7f133232e7688f64cdd00247f58d4d621e51450cbcb5944f75603ab69376177c0fb0a9f3e5f0f503758e794a93c1a80ec5e727604ea5205161a606c310a1130e2be64415942291ac9195b0ef23aa4b02585c06c18be9fd2ac53e37c44b9588ff3b25871a21b91639ffb17e4c1e9ea1c95dab71751ca24bbb5918ff1e337b08db96f512c57aa76dd632773e3dbc82dd498170085de4396296779618837278b29cddc52c9d87502fc90dd26e6b5642d8229308cc4a89bfa78c7f17e7eb49932c75c178d7596374f297bc8b1740424f4b4ab85b9cb123986506d03d80e1724ac157cb787ca73c4374152093885d1b749ee2bc3e054345c506ab1694f49971676ee85f6aff0917fe41cf5db62bd5532f6f114e277c9c56757e0bb7ba18106a38f109cee6a9370cca6add4bd4dacc92afcc3c203b8e1efb51a08fd19537da93efd1b21a4007dec896c767d4ec71bff96777ba73943a7f79d5e0ce86252b2dca247f4c7dc52a266f118f4e7dcdb49bd582e620054b90a1e64a08677410cd5469cc607bc0b1619cf74a6912d4682f66578e6ebeeea61a53704479a85edd5b9081dbc725b70b7e05325c23096a2aa4169129b194bb875b78b3f9122afa4f317a3dbd97aa0909fffd04e4afec4ce71c3b53712acf624354f94f1aecbf17bb09f87e1dcbaa3509ea5b7188a21c55cdd523cbf165d90425c5a2fe75e34f99b0f29d6a743a5daef6c2ef93b3a0119e71f4aa0602af20abe6ba26ca39cd50e245c16eeb342faf3ee34b3b1eed43d757811a58a8befb1f8d942b8b6703bdb57ff114569e33fcbd18e4b747198337b689f32224f6be51e17b16818e0282d56c53ba08e26ef86bb221726e70a261cc0e1a634a2f696a09fa9ce69c3a377a2055c6f20859aca7977b5f6db0560d63bec26541b6dced2a3b7eeba1be9be144e7631aceb62ad040abf6bb380f5aa63d61426edadf919b322a2172110a0246440eb999c815b4675b0f8e98bdcbaf035ce8c9e8f8273df8547e8fa167a7d5b6f4ca42e60d9ca377e1b128fbf2aeebbf986df5ef9bee5612f21f7d7fae6117fe9b12e5abcf8de61e887cd9f2a2225024a6224b3d53c6944c5c3f93208cd1be18d2f426468da78b73d67ff3ddded9e81e89c4494d9f6188f6d833bdbfd9b3f2a0e5569da6a70cf28e64a87293888eee3ff781cc61cd7e60f4573ed8d4b85d4dbc50a88f9034eacdfead7200180c5c8da539ca7de7db0da633c4a0dbb63295273407c7c4ebf4558b15f0e6695c4ac34b126d772d26e9f51ed3e10b9124b5672a280f6b6d05775d6339d95025351b170ff75d0324aceb1b31d6dd7c67ed281fb0db82bb178f65e85b126e5f06b53b6cc3350da07905dac81ede3d428ebc4f0dd0b1a3df5e343113ecb5240cd875b9009145eb368a5dbcf26438ac14b40fca04fa7e0f56f14d66ec724705c7a1654083003a50dc3d6a63bbbf6288b4ffdb5186c8ebcefaa349846bbe8f812fe4acf0a35ea6fc6bf6ede4f3cce51abc661c78b649039363f673b4e1159ad4e6f41c19e18e875ae132c76ba3f33db50c24f7bbc288b142b836cb54067673e256da907f83e7854ff3128f39858a3e757bca089e790f22c4bf30d4913643ba1aa4e9a0a479b24fd1d77da9884a702e855e97156aadca79a6f9efbbfc9e2e6c18d3c6f5f81b544a9358f920fc9c0dfde5685b35a614da1daa9048da93d2a3d18617d5a85f5bbc53667323993926109682fa82fb5ed5c38e723775d2718561de64acbb789a159b9a8aee59370a47155ea0119b46032a0d7a542e7a969a8242c632ff1c494e598a35a7fe16bd187d6645e8be1a6c09cd146f3f04b1ecf196d2b92f172187d70be49e360e58a15999651a60afa08b917e4bf880a2cdc7b1c47a355e43c7328f395da0f1f5b74e32c803d43af252360577022dd7e634b982c75d116766e0a310e4039f2144b1a0437a6de517ea3ee8f5a622f161d399cc587f8753c5434aa9456c417af4109a240e79787766f45abd9cc18426d5f074be7c737a3ba5be15228356701d541f042c6008fac428666a36644f766fb85580093260b53b16bab906dc5a65fd5c5121e32d6be34868d0137cdf20400fe2ae56cfda0ccd32df4548d178e44a1b864c0d5af297d915b679c0372e674d51bd7a708afb54cbb25c3b1a782dba9352d44a041efad7a3558f8a7cbab0d439de4495e35ab38414e7443deb0d9aa584fa42b8e1b552d46103728dfbe04a1a73fb99f2a9bd9f5b0f8c13e75d4002e43778d362338132d0dd2ba2ca9dc186745ae29c9987f04a321229395724d8513ac4b74db662bb09fac5a5973532f44e0a427e4d742bb4b02fcfedadfe15fb2ee0962237a2b17c3f7379adeb0fd15518e92da5dca8ea9ffd739709159814e4f97e032517f87cc1d1121e105e3f1344650b3388a494fd8e71ce02e410569036db31037828bcf5727edf698287369951dad1c6af82ea30b20bcb22a6d440540a70b902e5fb7322a4ac79963d3e4b51c134df40d48bcc0bb523719fa036b2ddbf6fbb5009661e149af5d84c09109fc65f5b2bd5e916bda56fab8322a5668943dd01640171f1106a60df1b099ecfb6f802c61c6058936908354c78100e2bc7807eb59e04dd867650ebc52a6ac26bc8dbc0880b83a66b495c1fc59c89ba3e79983aed6d16c398d0d254b0139dded14c87b2941d1ad76a2d1ab2b57ef9c858105a7d9daded8dff50df73b7bda659494542e6ebd4db4cdf1817d4deaab9ca7856951024080a0b56354d66e1bcc3567359af37819dd1c2c90344ad9ea09af635793afa1a0a5bc6c190da9e3a04f9ef20419fc52742324469a1e16b27986d37064101616f44b52f14af3f4ba2aee48ef2fd1d88499b83169b38180522f031e1859dced681ed17a3dc09314304896700c72889dacc6e2b92daefd8ae7615c2482e824f29863f96ec24da363d2474f05bcd4b3d89eee7f09396935019efc2fe65aed54a35bfeb9d2994ce288883535fcd21ee10fa962f579956dbd87602dd599f0d2198e4d569730a0295f90821bf33b41dd63a0215c233161bcba708b5d5a66e7298550d810bdc75bbf77cf1d7072d69c1958983703bb7c2d70045fa307f1fe2785a5aa51d61f42eaadb94377e1a978166c53ae97cb7bc8e007204cec555948e69e8679bf02480c92df64b3e57960486ba1e3abf0c6b9360777685baecaa7764fc52c9c82726226608e091139d9915396efd04572487ce380f8040e1c06e147de1348a17aec386103858fc4eee25bd5e42e91ca6746acee2880805c0f9c9fd34c43aef8f2177f4068c415f43449e9b8d29acd2ae918dbbf6375f6a4b2e460da00cb793d84f364d0d8543cfa52b95cf5aae2255643e5794e52237334e832d0dd7b002cddf13727d042c345a05df7b122814dd5c5958353a6a90c0c0db9b780cf9e2e1c119accc148a473d190fe41cfa2b516224db045763b6225ed660b181b8be1d565c496bdc582a03eee4f488e72a19869785f8990202a85a830d444bdf63a2fccbb82eaaf55470bc7ae795fb73000293f22dfd93d2b062f4a44e6a04d551f49973c5e2096a7bc3ec0fd86ee46ed190ef4d4e12bbb245dc8930b73cb2022b80b71ec7a9215e0eed292dca4697d2a0b54a90597b3ea4ce55d018913001716a4095d4ae2451113b40ae40eaeb2ddff5711b15e8c482edb2c8108f504b3e1ee8602aaa6dba1c84992d17ed5030143a85ecce84d70dd0eff19555fd834c5cd6ad44198e5b43cd8f3d4917dddf3f11440a1589c367e335c6ec0ac4743c6d63137dce08fead9575b15f750c48bf4a583ed6809057dfb2305b6615fde9e20ad0990c771eace3225f805143be54899a29cecb2f242b54083da9ad47dd7ee84a204085234c4acf7e989fca967287f93cd439a01178341739706c5e41b6128c70ff211fd724dc5763b58b4581ab6c1195c3c5a63edc9742ca6c032e2ac5bc464f76a8545b601313ae7cd70de60b5d77c3bb40ff008b6743d3668da8a0d8e5a331213524acab7989d31ee7f280a9f2e20ec1e8a51586918aa245764d257353bb9b45441370601d4cf45591f2538c682c3942c44db8cb971b5db66ae7bf373af0f7fc9c1e8c890c6fff6673775ace4fe9094dcb11fb08b0775ea4090a0ac9f2ece212f67a7591f083d377e5b9697f2162b937b3153b0468527f06a1016a90f9bbfcc740082cc77ab35f08bc9d30174d160c5f72204c386aa2afeeb9ac689b9e95512a328bbcbe1b577fbba09d47d6e50b6ed0da440a5449edfef512aeebb77e614cf4a0df7ea08983f931eead8172bd495101a92b121e14d92b958caf3af06249f613195016c73d4525be116685c32fef4a7a796fa8ede2152a5d7de01613ff6f37300ae0443a1fde50adc690d1aa0f35c0a602342d194f225a149c37b9232c8398d8757a02fc6d80ae7a1899027ee80fb58c34a4f3b7ef47e2808c13a6af21458c4e27e6c3589c1e24e20321b1226d6a62e22b7f55b66f05d053414ef50ce7af174b778877b941a7207df4071bbc60236509309a3c0717bfe9b0f04c986a3eaec14848dc3894e2ca9ad88875ccfe4237cb5c64b4aa8a349cd15698c07bfb7dc41dbae09e3269ec82f92cf040d6678cb90ce752bc98b2692c7c94d6dbab51e68c05f3f23cb4e39db237016c2f358669287155c59c27dc6aa9edc0a6ce79c7de16673a393f83e887020cc64a030e2ef75d28c64b5d8783d932c77826ef9ce3d5e195ba1892ba73aeb9bf7abb09c86292943561f431dedaf51714cd96d1c654bf7556986151e8702bfa0d613648df94032762c993ae08ac12fa615724d4b921e381ecd5a6c5039d615a7ac8ff152f1359e0cc72f7d33f3d1eaca5e6864c0c4af07015ebb4292985df9bfecf094fad3742ee4f0e67bb5912d17b979601bcbd53a7f6ba3a4315a0dbfc0a255acaae53c6bbbf80df9fbeb698403bad87eee347fe7e1af1b022196d809ec26ff4490a7abbc34720d11a3b83fb4d3a29967fdd63d73968b4136af3ac0a8ad8ed43d049cc92c10271c9cf17633cfbf5af6c35e002f978506ec4486ce593da1463fd894bb8c8d2d02cb191169ac9790702b0cf69011a81ec7b2d49cd3bd702402b27eb0085f7c4c31e1b1add0851d0c9054e7a0dae43b26dda8f8997d6c60a590bbe5116e6e14e7db0a78a5d0217957f6443f69d9cf66d887fa94f0b5abe55e5f89d8deb0343aee253ee5aedb9333a5b8523e9b2754bfbabcadbd11a6394ad95a3e058937905322f8eea93f92b792f81c982774cae541135bc5cd5c9e380150d78bb55f8dc358fe1e0d4c14e47dee284c0f239947e6f9fb6d7b7347e16e0e652d815b767e92c84c67881b7005b5b7977a432cb800f8f028477ed38c2fb540184ed5747379ebf1962a994bc816899cf594fbd1a53fc7f92d1526173faec0db4d2806b09f38cc309f728ecc612f9030c2c771d835a26c40aa7c924daa0a41aa7b883e43c3f4603b2a86d8701f6c918a95530ea209b6676bdbe5b642af5facf0cacc867c4c4d8be45166be6f7b323d840b8e7753f05d8d2c19db85c5a8e1b77bfe8ee5bb0d48b69ae35dd0bf7f3bf1b19de6aeb1a5c21705f03261e031c54ba48ab9cf7ed5c6d1860333aa550088faaaa6c346b3d1bddbce1ef9d4800f7367cc8ee78e8bc5fcd5a24b6bf04d5906d322ea3bb7227673f164a2f8a99ce8127b23b3d64670f271ac481f7eac6b78ea071a226d384cdef81c02a5968b417971a90a660d417846f5d25964f95b286ebf1f53a429bbf12781a3f7495f7f428e577c556356a81470220161252d521d98611591b877e3b88b632f3993254e3e66d2f138a42efa2b43444becef772f4746595e355ceff9e864a613d1c715adca13980e96dfd452b472e881bb61e857c4d0cbce35ae75a34a8dd531014b46f6b2d161d84c723fcac739e27c17c53744fb2047291ec970cc3e152ba5a33fe85c0365ca9a50d641866551d656b56c7b9fc773a3e46c491054dd1df8d86e983cd16768ac9a7c872d3063c197afede1869ae7c3defff9d89dbbba7aef7d3b540be25ee0930bb430ca284e93ed269a0aad80b26bac60d96f1313062a1073d492ca1caa8f3a2b0f3a45871eee0bce9cb152f8f6ad1231608eb8f397bda81ae5737077f2686d603f1e68b18256799761d470aece23c1b7f6c05db0ffa7688c8a017057b2a3c450ccdb1a3214805cb501aa734fc1c24da189d261a88e6d35bbc73a31952a09d53423e1665b5f523337ff4b757e4e5457e5e1b99f5d5fb4043d827d332dc677a2af11d403b137d2f07bf98351403c3e87981ed049ec45a51dda41c0c1f81adc9653367544866fd404d8e11ee25bf1afe432c9f431afbc46c8acc75f8a41f975ec87d4ae83011329d63d8953209b1e4fed37f79f05627a359956564ea4022fd40d8115b61b7fcde074f29fe81bb87a1ce503d01063a9fe1433e6bdc83e4b9fdf392702fc194f8f5c4e0e891029cace2f0a006b33d9ccb46ffe61d27e25133c0e0bb93b1aa75e7afb7ddc60ee667b693f19494b806d207355558b3928cedb84224f1af8eb0b38adba629436c2eb19e8980158e9aaf2ee666da52cb8a2649a33f8644b31b1846227753f1bbdfabd32abf0b01a259c39de939104249170e05777cb846148efdd9c3245d4046e87f010d45fbe2c6d7cac2f8e2badbbdedcc0a42bdc431b0f69d2aa09eb16d6bace5784d9f54b3f5bb06a05267b82612a2d8411c16ea5de3c70ac255b10ca774c62810fd8358c25527cb2fd22cf44dc6eea1aa0d6b0ab924b204cdbb52486eb1055d7982b5a5a61b7c4b69ff899ecd8e5e94435df855e0a4b05cb5a97a8a79b61da97abfca3b4bd7e115f4b07559c09d7945f1bd98304eea3fbb472f1511e2c950b48d9adc0e64531c76d33287cb25c6b0e6875ca286cff60827772bf703f0abbf9372702afd0117e349498e6c9c4e447b4883b0a3da566237768710b19efeab43401648a13b462c358166ecaf0eaa2dce6613ae223da0f74d294b126798ec13de28cee183b5711e301e57127d3152eb8b6dcf676a0cc1f011e1a3ae86be4f2d8cb0f24d337159d06caaeef5e5012ae3ed7404ac130767b425d5414ad24b9fe0156cebe9b74100f0ac1dc1a182605d91268b6b6ca34bf517a8152ae1e09ce52f0eaf2f9acf6cd62d717c87126b0d7cac8d82ca24903c1b09c83ba452d25bdaec8282f7fe571c85013726d6a84dd4e4191ef3395ce22a38ce94e58ced8762e039e9ce45235807f9d4d08a954f4f0422c4ef3121f05f2c1130fb6e0da61dc00d4ddc203725e91f78b76887f587301e96c027684a7ff5f4cad11bce98b6f72c65a85795d81866c43533450b7e97123e26b7f550ec79a73ed1e95f53d89fefa1a8e726f8524c85f0a07a0e257b22b537577313208611beac920afec80b6f1f03b885cf497fc174900ca11e1dc1c0275391c78aa72f711c1bce885b2e96b8de46d51fa700acb183be891f2232e82557806c0aacc352b90c93a5d06340fd7a1741ba7c901306a33482c3c8ff8227c1fc2856f293664370ff22cabf1ea581f76dc3a33251035bd7f15f7bad19b92031fe5b498feacf171a1515e06cbb517a7c832a1704c3683329f08c275dd08bc9445bfcca5c141db1263518224a5c215ef8d3903ae1b11f77fd0abec77482ef2d632985d05acd37d923fe6b2530ace266f5f72fd07c09d65ce3c72afd64c89e9014672ee6b28f8082dc81f58987e87ab3cbcaee7b090eb111ebf5124d0c08bed44cf501e418ff0eceda7f6d1d49a6a1bf84c00d153a7b12b6824a2cefcad596e71fbe116b472dfcf7251394fe06a8265a2968d0ba53958378c2d4593936382ee18493f1e18c621119eaf333f1dda7a6d238e2fcfad23742f2def0818a5e2be2e4251150be2c2d7d0738a4e08f4f676eaecff50846af6993b1c7ff7bf27241a39bcf08fa0180a26fca2a6bac7027878aacf80fe8ef437433e074f0dff967a021b49c0cc384e9a38f8bcb2ff6d3931f4e39f93e65fa58721cd0d48f2e8b1022b4a9497cfa32f4fb8007ed2979d2a33aed09dece2abcf38e41dcc0fa491ace8749d16f734d0081689e4f80f7c93004b9b3cf5509140e9148296cdeaaa992ba555f3abba377b24cebe962cf2d7317f3baf1a5fd87b22e4f90f35d6f1d31441696f297e89a7757c482315a51ab5ed76ac45d6b31601440bd2703bee64ef394fbfcb82fef1cd348ccd483fd9768ae6a59aac695464607af33df8d368e29f30863044f8225e9bfe3ef190f3dfce202bd31b135a42a747b9b4a7692c9c2cd65d93e9df8b72348e5a12256ae9223de70ec3539abd5b351c0d0a591bb3087fdbb3edb70da88c698e2b70ac9aef0cb5d4019e5a51ee407216338135ff0a6b98820b462faf4f2df4e895e11dc4074f33519e82b72c77f09a2245c26ca55c93a845967f406bc87c8ff8424176f4a44b9e9138ed9919aa375b2c1650b02396f23814aa2d31a229ce8fd559bf400c16ab25f9f207900d6e72810ef9ad1976daa4c0b5f42917f4f9a6407d863c3e9aeaa1153b5000078d15acd4149272de355219a7242a47cc56a982e05aeeeae56e274dfc1797aa7ac89d84342987e3bda17ab0e4da4645cce1a1b94976d553137479cd8bcab14bc6d40d6f864786965fa39ea5c9eb1795de77d5d96200dcb4c4960813aa749ab3c587e770b0a9b59e0d17fe3ac37f9bd7497c8bccb7a6ffbf648501277cffdba3364ba660774c9671672d5dc368d3b7e56b8209dd3c141def588b0e966ec4c1e5dd77ada217f6e7b19605a2b454fa5c9621c92d6c9ed4f5301ecbd1681de5ada0d730e7bdcb5e32507214fec339560cbb001eee9c598a760c2c41d5d526903bff4126215358e1e0d28f8e04c3d3a21aa206b9047851f8e1b6a280678cb555f1dbc6e44025c10008ea8e59efdebde6b83a79aac317b5ea7881253bfcd3b684b0127ad2c770f741c7c81a032cd6a3f82ff46676e98ea1c234ff73255d14e05a9919846e74f455214d69a9dc405a91e6aadbd80b90f1a3fd78587d7c8596f8022dfa25308947ffb3af2a1b1946c1685200fc86a6e4484b80ba12bac407031dda743d5cbaf5163af1e19ea1c24a01be8771259eb248ca1323b6274c0e96b0cb4eb3654701e6b50ec07afbfefa24d103a0b62da0e8b2ba5dead23c6744d4f1860d254ff5e9cedb91e64a0db868433bf6dc0e4d6fd16d9188b22311174b949158de9b373ccbed3e1e2a1412a53f597e555497c085a8521aa30e9f21907b55d4eaff7db1e032b9aef8e6d3d10f43ca2c092b305cd8658f715f19ef40609806ef105d8e7b8821f98f462a92395da0117d2d1ebe101a33e02aab1b3d7d2cdf86a8453e3ec2e3ec8f6ab19b01e163042af06d934e406dffa49bd86948727464a322166da5150ba2b4e1ce3d0d3dfda7b6219c28cae9eb695bccd05ce1eac6d894aaa428c8da545c04b9cf1c741baae4103b8e300bd4a7dcd71fb5be8d04c376544ea307a4ee09fbd873eba9ca6c14447bc329ee99dcf93801870ab28dfb5e290c0d62a7cb664716b1d532e9e1b4e1196798c57b66b25cc570dd7820e5acd18287a2411a32343eb6b6629c65363f0ae279e4d0649429e64624746ba094524a575df50baaf891cd560f5d8b499a409e11683ca3859026232acd60417957795e84800cbfbb2755a5644e9807bf26fedd23db5e5a35fc8cda9a6caf07966283971a2e2db5c42fcecd5b002c1d67656c13c658b9972fac23cc21cf0178f8d26a24abfae49ab4a74777e8f6b144f0dbb5ce8115b18782a8a7882520ae21bfa58f119f732d4ba127572631706b96871f8b92ff535a703c93b78098ac0520373b93228712c0a9e341aa3858b4db5ae400f7c56d1c582bc69e8470d6f14ec761d17c43d507a387f42be27ca9aa89869113e22927f83ba91da4f5777fcce90a014088684103afce8d6f733d21a99ca4e2fcee3540e37905cd331c63b663d16fb46fe1fc6652bebe1a8d415f9a71e722a36da6349afa15cdf2aa769966cfc4e2ed394affe0faf28873878b429d8321278a3c564c8974f37bf57fbae8b66ea528976e54a0bb0ca43b47de86c98e3302d16dbe0dc9a2e1330fc958df267f135ba0c679e184ef259bd3ee93017cd166d9435cc3ec2e05a73c64033008d8f27e87b1ed194f363b690e12aece67ef758485a6df73ee616ff18cfe3b67e444cc2dff04b61965d4a7e823c18198dd06b7aa54fc25ac35139ba7e4eb21b9d6f9e72ec920719db3550aef007945cdb12b4f21a820e7ec944fe3ed9ea4bcf2ef4e612a62e173b0dbe72008095e56ed4cc1fb808807b7b2f69ce1a18f1556397dec0410a16d55d6bc72cb8d63883990e233216115bc79fe93e25a26cfcb627913c681b411f41752889ad22ce6f3a8d2b69e10fcde930e0a2703767dbd91e58eb42372566ec690076e2d1157e44abe13369ba3b49f599446f07fc30998eac3f87b2701bb74f2ddf0a5ecbfb2b99ba31959a67738281de784678bd8779aa88034c513821423cb5224e32b245b8c264732f042cd1d704488dcb61c5ca056faba82e79eb9f978a7dc3f0e621f9b2d2b11443360baf6685eade400cf5ade1f397854534acdef06f0cd8a0ab687fd1bddb1f814ad2a6db83d46a87fcbd721f49a52bc4da63430166bd1795df20d858d27641b34b3b8b1fcd80449938abc96bf1faf18c8d7912dd351558603fbb021d2410c009ef4d47d1be85a038708b9a726b18489b936d806b8ea1682cc4166f2c5327e7d29a27aec6a04645177da384ad1f6f11ffa42ce2c003846703c537b87785b20a3a8e5800d0c98d3c042a46544c4da033edc4f516a2e1174a043a8ed1dabecca72f1df27166b280341a7994bf201516ea0c5de10fa22c163961298eac88fb83837ddb482e28967da444f6d1d1b1b1427eeaffa88356ce054b9e70c79726924923ea275f00b29b95e920a29ada6b1443e35380be438ad5f5a4b134fd5e894596d53ff19ab296a04720482473c1c0ee403d044e0f765389828f362008e69436ed4f989c038853c45bc52a1f53abf09248d2a3c42f0d0df3e7fdd5fa6c98b299d3fcdeae2654f9aa80b2cecd499550889c7ef476b6d23792972f4662554e0a626a869d2164a019d900398a98234fe0d571f27428b7be813a172c5111c730a57fc8df3f50cfd78f5c61bfa4f6c41616e8bfff274ee4cc56ddf4a7929710856498769e76738c2bd475830f0063ba1247c4abf23634e20b499aad918270df22d862896d653c8be04","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
