<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"262c268532357cc801c83374453239ce6fbce499bdec045f5e9ecbb58898748a64d8f50a109e3ba7231d8ddf75ee489f6863e11aec2b9a4f7cfd28dadbe7e65d49c2588d5ea8eca8ff9efd78bd85958532a3a2ea1bb1257ca57236008cd34333d3868e847bdc2c66449a4eff18242eef63a7f013045517d6601b708712e8a7d5e0b472e97f6bcbe14f44ca99182cf229d68bc0230690eaad8c8833548cb7f9085ddb8584f368276dd262d64b6c4a487f0925bcf96c4219dfdd94890fd0b26257a069d7fb8edee6df2f83b673f115eb0b7e99fedfab26c9f2a67fa9609efd2c97db5a06d100fa4639bdd957ffef5dfcf9bc8954b714e621c4588cddadac68cec5619db44d979b2db7afbf111a38eea5df1d6b1a177e283768bc39be72d3296bbae49f710ab713cd7f83ce77718fcf76d7dd400531b3f154216a2a51a25f38ae21d96edf72c57d212029111ce17ba78ef11561765439370c62cbd8c99d356ba99b96bf720775c5ce1b63c8d253c8a1fa2ab70911e59267bfce78193b73d3ecf83c5f3a50a68c2266028c350b6f93daecea61ba76ddd01203b0a82ed5f93d0678dba1e0efa95c19929e8c3ad281d2ca10452386fe692e01b810539b5840c2891270ece2fa21464ab81018d8010626ee863a8b5e13e826929ee4237cbab48b8736753b15d8dfc6fe88bb087b470ddf6913f1e6da816d4c830f32e3e94421622be3dee32822b3c486430bb951749579e8390b56a93e7cf205ed73d68c76457ca14cbb018c36b4d58d2ef16caeb271482a77f216ba5223e3800a2ab49d07f72517c12eea225714b9b4ef4432b01a0ecd9e5e1fc84fa6fc5e270dc1fc08a1cd604a4cb1f71cec6496d6de7070a5843c2f0980563c38e58109259382e53733fe9697c3828c8bb2b7c94f278e69a673d80c97b1cde33d7c4548949f6c504c106dd9c8d505101293298ee8e7e900a3bd3641794f847f98b632a6d096844183b450e1ec22f2c97d245903bd4c7221300a58394a4776a0f163907cda6622bfe70d88cf1e2a9df8ace16edb783441e2fbec454de5a71b550c31799bbc0e92a63ddbda7661d0fdedff48e12877ea4482b9d9e615aa7ae2e96e04d1e2829b78640f27773f885c1d2c6d2466cf0233f55fd9d8f840085d0a0d2e5d54070dad000f0d42647e51fe4691c064b04d2cfb462165eae52cd4fa4c814d76385c47992e9834ad6145cca8edafdf47d637b3387f0a07095fb1bea6d4386fe978b567b9f0bf4b5fe967722651b15d0edfc2e0f2aed363151c9aa2b19eada3d2af53625683378971860b212ddf9eb588ba86359be2e1ef21ed8a672d477c9174242704a88266f0743a1f9e59cbbc8ecd58cbde3aa5a486aa36ed9c79c619347cc41177e4100fb4d3944cbce8ecc2d234349de9970c00b7afc9dfe9243e9b8635c70fe2f87eaeddf0823db85c1bc8f033fe6f8fcb9879066c494185c082aa3a408e661bb39a62339d8b811ea5a309f9d3a404b3d41651b6a34cfffb09707d786a43b6953f7282a91d9b42817a88e01997a1a7642ffe88a1b20c39f2fea8f59b6d47aa3ac6a04aa2acb5ca6e15fc007d4928fc528cf204cb271e93c77dcdb8beb74a2bb9b0864feac66d32e22f78c31985ac0298513000f330a2175a4ba5e4ffe5974f9b0492ef0b1ff07d67bf930d5c2596993f6e8287ed93074154bdacba90f1aca6c0e4098a5f38a5ce86f30197e0ae4a86a428908639cce4e97ec3eeb9a4a805cfcc55634d859fc20538ac4ac6449241df98c11386fc3ba796b586ebd4056457215be44b9bc4103c600a67d1ff57337647121cf7db6272cd374a9153536d67dcbfa04a3892fd03c8b345329716e4ce52c34a754c82c3797468cfcc1074d8f62901cbb993c77d8d97d1e99ed2c2353fded3eee7e391eac91c800891cfd76f05e9408804ba52cf89fd9de7e4a936351d79c63ff25aa9489667196b65168a2d1f88ea4729e1f69a63b50846c44f44a064bfc807db09a264acb5c6df77b479b8a5b0e568650f1d17c341df507a0ff0574c23dfbafd926efe167cbffee8173770aba872e1fa64636921ee8818c01b32be619d9bff38e53338ed9392bfea267d8089b353c5a78cdbd30bca1f287f62db96df0000565ac023f0f2d1ff94039218d72aa42703f3343b6de7670eb6828734b433b54c6bd3103ce8b156bdc141b32aa85374026f15131855f132ba7c56e59f3812a455aede616e6b4ade1c9d40c5fa6b6443f12ac5c4284dff35bbea7258f42b832e89eecf46a29588a7fb53f60ba1d83bb8d7dd73687385cecb307cbde92a99d686ec642e31c4344d67dbe280944f1c200faa6f9f741c898820903e6a6ebf273ef241f24d69380e1ca0cc14b4b672319396a066895d47c7b2246ef440299dd99ddb70824abb623e1080b96d78904c82aa4c20ef265c89b7def5e07dd889119d0a87f1ad69d9c6315cf1ac0eb874cc717555677c7055ea509d72a8d0801b051ebbafdde7577453622f4c19cb8d07d5958449ea44f85fc454591d5b760a7b3b9ab9372939fee9fecb6495fa55c7877ac898d53ddf8b07b43c752bf59fbc2011845b185c071a3bd81eaea5571b3fca6893f0865f3cf80c4edcfbdc4ec90d181036e1b8b223f21fbe35c23322477ad0dee73a49d756cfcad810bbbe9b2dfcd93cb205950fc4b72be34ed6455c0510855e0922c45f28090bcc5802f92d7f04e94bcc7ddf0f877318d27ed398a6425102e9f1e703c482c5c2d9648698f8cb0f2f8e1a370c1f3faae0be952b5d23ab12c462bba744f8f3862eac1a11125adac3e968eb6aa3d9dc3d1cfa192d8718c8b5ce89adb8d067fad787203a65d214434056381f015d0e0f63108302b667d8c9e2fa518ea266708029d8c85584dd5494fa133b226ef23cd5c9b4a04439a80443b76a3a4daf1371e9a91cce273f4f6333cfcdb7a1ea6d407d60f69737736f7484c8d09bc0b9a7a3df1f2c5a519cbfed39f8911027ededfdb9e8132324e1153d0b6ce36e8e7149abc2fef9a409b747691e08ef3ace86378ae057bdb04a7d5837c47bbb7aa1ec367e01e6e3bbee837b070ff7000dd0f61a4a486a0d26589a500c78bb9d537059cd9b8c79adb4880955b778c1f34435077e6193118a7f7a0e476f379e36575cdf46c03b68212066b39f21cb9b3e0e1f8673e67c1a5363966c1af49f1add2e1691484d3d92acff1b2dd6a198e75d6b05357aeddd50804e1c764762ede224e85a9e27113b66ef410b4f4f2bf2739f8cfdb4ecdb0f978625e98d3fb131b32743998b3ac0e25f12d3aed1bd7d7a944ad78c10e2c8b70d43bf87ab07a25db7b5567073fbdfcdbcfd44935619458edad3bd32c0437e6ed72e8ace695d5cb55edd492e1d4a313311ddcab95593801174bca71f386c5dbbb70a38901b0f5577f1a0df1c6434cdd3880e4c6d06bdad329934d5bc2681faa144aa4601b06eeb09581a8227538e52e47afed1a6a9e84c355a0562a7d2eb5f61ef43b9321a1def676843545a4f19379a73e9a9fd5be6e9d1a494e7af79cfd45dc7e04a651f15fd455016643ca09a083592ea5108bba9a2ee8ef7981322e2de6892fa978608ced5b4fd423c121d4ca6b303a615f27678099316a8f9d1eefe76c270cc496c5a845b82fed638e70326b5ddeed8785ad4267b2a238cc7322b02cbeacb3b63dde5d29adc8140af8bd46af9f5e00232ea51b9b18ecf0fe265704e5d425098a5d78cda093ff752222e2c1c681d65aef56dbb0b96d864bb4811de9dd177361d9157a2883f2b8b45d8d233f9acd336bbe1ad457785e055e1d9620ea7f4bd8b37e80124bb112622f5239e3a87d8ce21abd8c8bba9e4ca852d3ab8790f7f33e470190a4137bb0766b08cac13f95818400b3fc1b3e421998db3dcd76e559e594c0e60b0df4d7eb7c297655267616c2488593c3801532f328f0966881149b40588dc13d70b40bf85ea7adf1b814fa043b01940d24567d362af701c565d45eaf5097dea9575b48be91d2f512e795f1d11f0207fa42e0b00dff912d0867f120204bee931dbd60aec1827cdd687923f4d59b07538d0a8cba4b16610fd3d9c3ba758cdee71794fac1a7ee2f0c61bf0513d5a463469e3e6d9c6d1446cf9a743d90ba58d9b2cc7b84e3ecab5a9ea6627a3eb581f3b0eb67e8750d68d8abc0780eb9cee680268f9a32989f929c295cfa52bebbda6373b79fb26efb70954f3cf96b8a6481467d9a0231f2095df14808fb9a7d27db8f7e054b75f566a2c95b846488c9c013b978690a330063532137b037140b4f0ff4001b2b2625af5229adc68d507bb5f7324dc5c6182d2024ef16eddaaf69dc9713fe2ea58152e8c3da828c33609ab3e72b9acee42a28f0c6335c92cfc7f47f19eb362f72830a6b43b56f19427c0b006389e18d76478725ae5602f9442bc34ed24fe4aa3af0a87ea0bfe519443bdb7ecda83e51072d8520254a9a49563b74b54a0835ab0ab34e24509438e9c35c7f34520cf60b374f2cc6d131133334d20f95f70dd537fdf278d920d6c2955fe0fe0fec7bfdd891271442663118dee9fc7d1e4eb1998233220f8fe77a681551354f33373789a5c1af721bf118f64ef772b5ec660fdd8d2e9804a407edde90c5ace3697b0e977146f5ac9bfe827dad712909a405e73813ca846b147ce6af849d00a54f702733b9bab96bf51887225eb2442b5e009e21df4671626f8c84c399c8e3316813ac030b4f768c7b9813bb65c0c0405b2456967e306006093bd959199a194a19df004ad361675a810076793f3a85b9df5dde316524244efa236691065a6cf81c8a241fd5b7207aaf0391bfef250538a89dd33d97f737ea7a3d07c482fe8633a687c07c91de93d3a078db9f84e235da67ee9bd8d0083c2ab58b4eb9215323ae4c9f43c4f328f9d44082dce16e7f72d4405e0745b5a43240d35ca5f8b6169f6d6bac1ac7476c5760f32a42f3014839ff08b86c59f45bcd3e7209f3b67942d6b799d4d781f2e092290c806f2dc1c3269d9a69dffeeee51376d267613da255ba0894da30abb769ae3d8a0ef6bfb6de83ea4afabd081665b6dbbff7510269f0941c8172de240060d81a84bf8355de2b1b0f19debf3001f7622cf93d9a44bc79e1ea59f04858ed917c593fc74ee193ff31eedc9612b496bbae2793b7386877f1c18fa1e51cfedf0d95e14b8f345707395c7c6b7f114b69928c545e64dc7f64b816e3f6fd176f82ec1bc0d212ede91ae44ffb61460fe5738d0199f526c6027ba5bc4ed71e912ae6be45859132fd96cdce1259226c1df1507bb8cce32de82647b01ca6c7edd8ebcc51d61599e10e6e10836d7b3507c182cfba57afd04a069992b5a9d3eb8af42c65723d544d75b5f0ebb484e24af4e86c4afd990330c5a4d6f4dc017579918b15acfa17c655d97c20408a74f8d083c74ac99fdecd7f694f0448602481345c39922473b9e65e733f5435c76c942effaa56e9035d21c6ee75e64652a21241e6ee92007661ce71d1a3741c0a076954c1e18044ea05e729591cde48a4dc2976c8e17bde62d97e77b6dc02bb86f6b12009a7244f7e1414f2bf457b71be1a8d522782230479bcad6fa0c899d9544e3c9dadd77b3935843c638a464dbf96f8d6dfac96038993ffb299bc1273745d1df28dc0fb80f281d0c1f32ed1e55802a2e74384e1b02bd6070808d389b42c9a72e066ad55824a8652414d954dde5cd5ea7c30f4429323407007e124fb41d8d98e62c2b70eb80493ced0c7147f885c39f1b3816c341c1ef2d47351f997351c0a974850f8a0fd195e720ce380565337c58c08f20e6dbe3f1f659a1653feaa75a7eea42204d96acbebc7e07cc10a05dfe5cfec3396db59b03e72cbc8e27dda683d01f48b9459d9eb5236471eabba5f6ffda97475fb5e333174258b8edf89a547e3abecfb8efc17977b1563aa600d513639e9a9b0b2589ff4862d61610959ec30eab1760f733a3a2869ae0ab5efd0651a39726658c01c2a4dab33bdcef4c7b2c7fa58f975f5c83277f27c6db58262fdc8cdc55f53c546e6fa2f60fd343b3cea539e7e69484e2e6f9ab9398a5087bf6753c0eb03e36118448026066941049b8d51e28173464e07e3352d7c602e76043d7886b9e7656841c533ecfb2dd43ff0a1d6b6e4dc6b54e5dc43161de3fd57c3d52d65ce7c9608b6cf5903a8c672ec9a5054232854299c7912ed0a6083b06c8eb4a79a1b4171c0af5fa1d81c93c28aafbf0dd348a82a510941f8874d380c1e00bab5263337da784387b0f1c66a97fa5d109ae3777ab5c6b17eb302b55cd22e5ff23b454a03d3f98ac0f4eb38bbbd2e13fe5cf45811a2ad0355cf6cd461d447387dda501230166c8f1468f656ca1791b2c99873f9eb919a4f2e9d5c7dff377a6ca8876f2c78b1d29bbe5116c5cf186ba184d83f350b287f9da207256739166df45673484c55eceb04338eec44fe2730088dfa40db7ae4d1c2101e0c3024c7520606f660411818ed963dacf8836a92540259586bfb3b44929264f288027d350a9fb55fd53fa7bda90a77a6272c9f4766246c9b781cf7be5058069cb2183410a3abd344acc7bdd9eb82278987d19cd56d44098387d4402078b8d80ab9b61c3d159d2c7ce622a66fe2428d57cb548f642a3060d09108b5d088924dd0b8892003a5862f543e167b8c98c014bd7fe32fd4b4ba454ee1ebd7578f9f6535f023c3e89b5c6ee3b6eb3157678ce3d3c8fa86d81e979192ca6f69ee560b7bf828ae4799c03a01a884d03cc7edc447bfed53090aa5806bcf24c1d1179bac8bf302fa2088cad0e246eff25a47e580b898b5650bc7b80860c5776fbbecbbeaed5fbd156f76d8bc0515d1614e85d9ced712817a171555d1daf3c9265a189125a8b9ea1dedfeb4f7108448c137035c4f2fee50a2b6de6f7c7b1a3015c130e1579999f8d0bccdd29552a8db5744d964560ff54c441de7ecf806e860d4fbb2680f5169fb37d9b3c0b190dbfc2378f4b981c4eb412756781e0b7ab1bd86b411940f4f042a718dea31c3b7ace49c0702932e38d53b4aeba4cd03d2825a3c9da7c0d7c8c10e53ddf2522761f2b6f365cdbadaeae4ef8383b824b453bff0fe906c822c22c0344338c7081121e6077bca4de36324f7fac1270c769d7878b507a9dedf763616d27c40558aa61bbb8c07b39d6feb63edbc06ef806064710e57528f938308c6504a0b1f3ba85e4d5f8fa093c0f3917a595d8ce3d88d5ae1b103daf685f0ace90492b03b17e573e2b4ab7519e145911fa62473d5451ca66e76a748092545a1ed80bc648dd1b6776f54586134c0792a816a8ec591fd6440e8db01b59dc9486461f7cda15195b651b86bfa8f47b91c652e73b20f38554acd59d748009d5ba2065ad8b80e93c2a9dbc05434b8fb74d34dfc1892879fbbcea892dee0cf15fa6e8e99bbb29ee13588a214ac84fa7babbfd1268b124edbfbec016b37aad5548e63593135959aefd1c08d430ac0162400433c3853fb9737ecb0931e4eeab3171fb1ab0ff73faf2260f57539a26e7e749247eeeea63d82d5259683c942a6671761912f373cc69618eb062142c7134d2a4b03a753237b4eea65f154a1a73ec251bcc849e0e3c90c82bb96322bf344e369fb9f38cbda4f0af5118aafa95fe9c710f6c7f856abae21393c73735e31fd44b7960b2f9a7772a99c50953c6031aa38afe1c7aa99ecab6ed8d7ed7f40ab07e65b0b2e49ddd562cd65fad92b5ddc644134287e2455efe1d1d5460ca1636ee2f9cdfbac8417753ffbbe88f5cd039e074b3d945f85198df68abb2f36a7a912be988e94e996d4cd2ea63cdd40c0aa7d83ec6b900037ab677d1f8ce0968d5d66eaaaccc7428df83fb2a0b5de6788d4d187d105936c5d14d45882f44307d3a3696be7b8853b9dd9bc048253626a856937b831d69b27c8a533c4fbdead89e691a67a87e067b854dde93beb2d86af3482a2dc01d7d84e3c342e1824169915336ba5378fbb0e1a1ece82b27e78d9eded87059d6705438dec198b0ef7262cd8626605879d0a9b724c9f3f347e249d9a39d4fc673af5629c1826cdfdb3a3eaa57a2360d4f1d8d8dc33e7907953a22068883b8403ec2e26ba2b0f83915211eb9314cf8242a4e39a29b17f564c79963ac27034ca021ba254fcc21f89051ed27f60f818d7309336d518a9312546ccf66b17e6479e5559d7df96aceab71a1e756cfb13c23d36a1405d7c95f773878c3d17dcd6a91bb679b313b8f89ee2a1b2f7c1f966ceac1d4f03a4b85a7fd7d8c1a516a62f40651a2fbc28cefe39607963d2a3551645e60682b0dac3b53a79cd6e7d3ae6dbb71658dd379c4a5c1f831072d2df7c478774836d68c3b9b02bc59d608bafc87f239f041a8ac45b81fcaa0a3e0a12bd9259850ad644f378d4b212bb42b4d51dceb3f57336c4c10810e6be6ae96dc19d65647c19a3a151aeaae84024bac8caaf079c280760aade29cd42e244a27f23ea475ebe6777930851d77fdbd0cf3339d05ecb099ae80c0f8177d227576541b6bf981745e9a834cbb8430ddc9ab1aeec46c9a89996d3b249ccde0b8929aceb7ce084114d6db6a82360dbf21c7f0a544cfd97af52ea3a5b5e77f5e6db579391824b1d5eaab4372f153ac0986ebf55918ea86004cf7875dadd52465ba431fc145a21b2b6b34a43699a8d489df5a5464d918ba59521a87a725b34393a9f67a7fbce3600d47127f0142f36d7941269164fbd5af0495c3911ecb0f0c0cca2fcdc30b1c57abe2805eec16199929aa330678275bcacb7fc1a2020692559f3771a294883787e8a4f5c3f287c3c5d8f94843112ae6d9980a0f7df6ed350c7f578ab7243bb2e6871b31d1b0bc555db0c1923ba00f78d2c13e730b14d2c062bb8ce6eabd9eee895e91b3f6ea98a66e2d244348f00b39fb71a3118d0d9e97c4d4423fe3ae73524857ab470543dcd1633079e41e3784af3aee2ddbd4419e6747b97922581d8aa46c8ec0c9aba75123b01aeaf10cd3886dd3123489410a63f346872c628be055f66475dc9776d9e7b9e4c1b22c7c93e28f4b1f373a2001cf9cfb81765b9fb2b44e57c755e84c71693250a80202baa9974a0d6276fad046d88531642e169d1d5b2488ea58da6da1743a88ed90aabbbb427cb3e24b23b74de1f17af04e3141261732504e8b82562eb12051bf4b58b6506deb72723b9dce4ea6949d3a8501f75e422c7b917da661fb3630d162270f3b8e49db7769e68ad8cdf265da76d3269ea9066a8fb2b4292ce7dce66de327b2af082dbf6c22f3dc53fc9a14d0d880117472ca163fdd31bc0aa807afb5a215958d8480efb33ad1cf6e5cfa55a94620cd0f464219045cc37cca02746bdb6287b912cc9d084181293ead6007299d52bebd8d46655a4551c2d1251773b3ff8063747d4e48c9f2476020b0a3c86a238b10b9bcc8f2884a10880b973d6953d08a03b64c713dee2f29039655ff19b8ace15a84f5863395c4aab488eeb2ab4cfb084b7c4320c5abc60d7d3449e384709425ff2942db7e6f20dee3645faf436131e008167e5b0d3d9c27f562c554a3672f65917159a3abef4ebb2ee64cb96bba6e7decf23e0802317fdbc29819f6722dfd26f4b9720629aa35b33888bb2c935ec39a2e7fe57dbb8c6d561da16daf70ddac081e25e56d10cc1e6850580a6291b058eec7a0c71268b56840930b2b1e4012c3539025365cd738c11da809b88108dfad2b3114bb1a25afd7a544c0027244a2ee7ef9356026dd8ec5a683356ca82bcea0079747a4a30ca830a88cbadd7b533c9addf3e71916713cb403c86564a5d0919b4a2b2b23c3eb1d394965bea740b51f91f4f2673a47e81a19a80eeb2980e5c817efabf95c2c4ad3c9d9d4479e306c8bfd406f594ade97c1f52574ad9b37cfaac43069c1b86277b5aff66da7a3209dcfb9ca108dcdf5ee258ddef5697a293d5bf87d9c6931e3391df2f0d18f3ea5fbe9fdc254a83de428bfcde7326fd9cb6e9c8a17b774d604aabdb7e4229a7da6323371c811ec4acd0eedbb3a9845c2b8b9bb29d5332336f9bcdedb249f85a2a3ee9f71f786fefaafd3f0a0c9000f4bb366e36aa26dd1b1097a8ab6944be4c8bf999af000e9eaa4984b3727af32b7bd7cf91b3e475782528a8e8d4abcdf7860769c3255af9f5678520bcd263e8e2796b1db7f0d7db02f782400a19eedd2d67d402db473704b0ab4808fc5cae0d8f429f7ae944be436e77b256d90ba7dd3b1d917c8ef16242ddd5ffac328f58283fb484dddbd1f9a47c4e3aae4332eeb4054bcad9cbc52710cb1c2af2c61ab2892f5217d2fce143c26bc48d8de64f584b160e641f456cb9c9bd05a4a9024b5b2d4c3616930d5ceb1dda3fb46494dd2dfc73510a8a28c4281f1762611ab467d578dec4ee6eb0575d41740666f01f168602f26389e262268bcfdbf15c67eb97c76eb154f414396bf54ef26b588e65a12630f1429d3ce240ffb90ff7d69a87a85e53ef2197e4233e7b036b3bbe688ccce96e321e76cd5916288d2386b8b39a0e0741aeb926d6f86071ea01a5ab6206c4f46c22fba8b8add5f4eec27142666f1a40697dac7c4d996ee1cdbef911b84d4b64c3cfaf610caf97497e50270a302858a7eb471b62d49651fd0554a5eecbaed391d3df4861a637906265843b35243b0c030199b49a5d95937838cc89e561415d698e3d320ef67084c56bd5509a7621708a11b4899a06a9551ced0814335af68199c29b00bad747f4c1eee249e1ea721b973767e811a2911ab3047fdfbb46f02a143716a58bbbd1576f0bb72198828df9b0f0a5b6e3c93e4ed2b5ac63b8ccc511c536c1dd8eb2ea6f246347be1a753e203d745479c50a746b5297df9ed8e319cd2a35be1874dbaf3603ff3bd2bcb5e3c6570c930d3d25b42e2c2a6074080d1754e7c3c8d2f59e2e9b7cc5ca2654b00c19913c9b5ddbbb63c44f7b0ebe3a5bb21e2b5511ecba6b44fab1044b8c947ec4e8bc1515269e142e6649c6d5a726333709934a7ea2921fd784be1e9350d2b8c3338377a4957429e2f52de29f7af018c7be667b08f60bee2bc585b8b3806fe41559ef32c63b9ce570d2a88a4f89979f8f2e23823b166ca30d3cf4b6d8b2ff9c21626e2c6f08b782c64550d6a0e3bc3b2657bd4912db31c5ce4259df51d9ded5cf81c2099740a028442c75415b2fc384773396d15ac4c2a224c00a706662d7c6d1f746d674261d68eab80a065915be003cbf682de0462d7276f553fde64464530f364c42f2021862436237da2aeaeac0f9eaa51332fccc57d694b2698ed21227c4ba996e79a216e5d59341f3adba71ee2e7dff12567dbcb241ee1918ccf8499bb3e8a98d1808a2791fd581da82cc0e57bd259bd251cb3a1bd529e7c0125364ea28924c87cbaf11b5b5aac978b9b17be7bbafc7303dcd81a0b0ad86d3a81405a757d36cb08d220035a5167a6e8921c0d83d832c123ade36e5c4bc0dc69f992e7129146cbe64c795755529276d1f0d61bb9c06862d272b0d7a4eecb8629f785eb155f92d4d287ee62e81d339101e2197f4c64a91b640b6532c1d24289e392e93ce889b4a059bf96b2a354657b378825f0ddb2894f8e52a2650ec5ca090efa45e03d6cc19c1c17ee739ea4351de8277db3c06459c0b9295db28648d95ac8a86a83491d2b6ac60303eb797d3cee0611518b6eee69f4436aa7aecc8ebd4004f76425818fd84f4d4eaef66b9eab7354d9142ced47e3c6d14e386a2ce130f56582664bae0048768dfe2f82305e60bfafc93b6998f46de7cfd2c270f083318370a1eef0c064ba5f154c1aa33915709c0e7530d4853a3267c22274f69698df9443415183b542b99aa97a2dc59207023ffcdc8e53462e8116483abc2a2ebf3ea7efd61ba420eb7f0dbc1ccbe6c6e2ee8904dbf95f123a36d078498260289c78b57c261ca99c927c54c9fe425b2ad81f653629442180cb34e6c6a0d7ca487366953b112a08819c9d91909815358bcc66445480a5709fe19a3643c6e0142545225c88082f2c4f223a9eb2bb33e5bd13b17df8de37ec647136a697a3f85046bb3afd5a624434ab58791662241b0a681d5ccfa648a25520adda2df86d4e064e9fd2bb2c3d79b9415dee4fee1ec7bf587989b3d564ed2a044919a94d11bc92f9363c4d338d384ec15310f64095d5b8bd7d84f61e57afa57783ee1c5ba09837fdb8fdb4d09d9f6eb1b0136270b24bff4ad5b4be085d96348853c030f24dafd3fe60f331eb203ef0f5d1098339266f470b04afddd1e4335955c32b090da1fa8cf2f23e947ecc1b1eab68e725f39025784bdc89a551e33f454a40bba24ef97a87e938c6a25d63c386ceedfa0d4e3252f0e44cc84bb617e4371db7e787b4fe3aee6d6cd98af617e105cf2134995dcf30fa4cbdbcb4e12fe3ee7334314ca9ab77aa09cea59360e59ab9b5347fb1e49165e7f569f922a60dbb24da3e28bed1520d2b12890b42f3614677dba6b071cc5ae15e2fb8dfac19627d442ea0b08c3a7a07666b811e403b857b53ed4364c630fd62798d39fdf5a49248bbf6d1aca7b25d43be0fcfa709ff7b61ae85b7a29164193af34a2fea42685a97d53cf20c3b287e24556eb6cdcb430cf0f6fded1a3683054a4834962bec49f7ddc3250a9b831f8cb2a03f66ecc12954712527caf9e966b0e8e08ccbe81a285f96f7edf40f577f4e21964bb4152bc6ff1879978efe27f015aee9c347ab584039924a49301a49af2f5e905f2b9d0c858be26f2280e4972fe6eb4552b9cbc49bcb9d38ab1eae3235d45d519296833d633aa599f931517721369a8bc01c2bb8dfe545345e34c88036543be4012c80b4fbbdf0013684e8c2a40887ea2bace811d0e53c6dc5ad17142dd97c8eac03a77b8d9aedf7d8088b0da429531a125db1397cbef8e01243acb4df839cca5bc44d74591052cb84d5dd2d52a86916adc8c4d1de95ce0b434fc50cbae279b314cde1cfdef533988e800a93e6270da82ba40b6ebd107946e221ceec2eb1a5ab16df38ac925236472aa635f04b5d54e35c2949e24755f8547879e3eae72d1f5299941efb442ac2f86ec60b44561c3a45cb38c7c95c88f8cdb01b66f3e224f65f8f7eb05b3900b39eb73b071465fba00713d0515d9842242b927a1e3b67ea704349d7631951a381e13f489a8570bdcfbfc68b8d3d026bacebe0b7f733eb1ed47fdfdeb238a7412701550fc6fd54e85b53e36a6bc87acf256c93a31313a18b2f7afd4f3fb2cc37b9f145a381c25ebc93e2ea4c4a8ffbde8151a3a6484ab4324e2a767a76c2750276ffd8d5eba38a2f64921cd8271542f009c58bc19d98cdd4571a86b392af187f9f3141da62d45633ec05ba3462983107a48b06b696131e14615344e1f7fbaa3844662553de298747d7d53d2297719d2ce49029a711378b3373e56715804ef03223f03ded749f254f980251af8cbea1c8d89cd75f5f29ee053446c200c548fa5e34352870b184db7cbc3ffff3380fe84899af884aafa60ba7ff48cae21e10791421983d316da421883c6b2bade5a7acdbe37b558cc83db49ccb0e8a8169f35e571c80ae23ae56379e96ec436056c6c40fe2f5979872a3958388a21bee2eca72cb6028bd6d934fe393f7ca555a89f98d519689f6731d9a46b9e1c85385a17d4fd1ce9f529d3bbd4338bba3e176882bcd348d655bf000d400aa8c4954514c865ccf8d76cddeefde0cfc41ac931a22aea00fee8eca297e55395a64219f98b2d63132db3b4253e34f2805f9ee26157a5b63962fd8ec9ba728f3edf422d08f3f5b56ea08a9cc0c8510fc8c851fbad83056a5385bf8c6caa571ff3d2beedba65d2acc56dc6e17048370514058788fbd055a2042013cf4d19a64bc48e982931d07a393ee4c8ab1e2ef22b5c4520dedb06805ea6f440ecafb2ce59d5936f8bc03156622cdd87f509b48e154588a6b4ecb8174e2fb1fd0b0463d83f29bd077e4f64ae4ae57323eb4ae493bca9a0831c9eb68b41a382751729d4012de4f7283823caa125258ef20ba5fe2d8672536bd6d1185642dd675e01cccd84b09e01b56a30627fac5ea3c7c489dcd6b972d1a5aef9842642c96a0d27790b703581b9d5faba6852abc7b5dc2d67f988c8666a3a49cbb299d366c8f50564b69b2f3e7041758823d6b902dcde48da3eebdb2791a9e26acf3d157cad17c0a8e719ba25688f0cf927d2419cd455eb703f790da5fc79981d7c6ae9249c7e38609d592f30fa322281a9a0c45cc3913b13cba0502024534112fd607c87d9b70079438bdf08ab32fe2f7195a2bdb83915bf319ab68a4d443244bdb40a1399a2960c6a85207f593ac3a61d674d7c9dc2204f60cc134d878b498aec51c00a5a370e845f9e12a601de4c6ca049301a051d3cc240cb9204a7533ea6f3ef52735e1d1d9f8f692f2ec60b9572cabbc2602005d6ddc6425edb34f979dc91ec25032034ac86757269a80ee44bc75128c2d7c182a8c7b4c5e25b859f9497d6b3d9484542f2d1710e14ae5c657b7c8771abe816dc97055c2de80d7545546218e922da061d3b31bfcae74caba5e5986475f245a790d68cc4951b8d0de672521d7cbde05eaaa39516a2d9e21cc51c75174ea13123e9d0415c3198ad00768d34ab786387abd6ff57d969599b5bc1618ac4546f9c5df5ce1153e391d80befe71cbd1ecfb20ad0bab7f6ea6e8b8728bb80ef0d7dfb53c65282f2cef9b0153c957f978bc7b80decec8d776b37e6dfc3c93a209e5eee2085a4352842bb6b418be45cc5e4b7a5d483c4bbabb263e7369ba77f2ffa7dbac102eea0cf89d0b8fd41cf7fc45103c1fc791846e40f5d987b8e695c6bf2e2a8fe8597384e9f794b8084161b59799e655de6e9391e71588f96d20ac69af8371e9380b021889ed492785b5dfdc319dd969fabc750f04f2f9b47f19c0c9664dd3cfcf67cc614a8d251d96e8973a6a725e55a727877eef2957f6e2fd5be4171730860af83095a488370f53a4287b362ccd41b0587494a47c59af6f948c4f6b08a6656c3a5cc05fbe33519e337ea4db6688818e1889739c62f633299f0915ea699a491c56b5a7e4305ca92173f4a45feecaa66f9ce197b6b99eba9c5770e593f8f03348a8b82bdd94287fdc0a003fc3c4f3dd85a609271daa91334d1550de0077aee6c9f67a16b54f688dfc72d8c145791f83361c43197a6736cb49bf8371f0841c773d6214c9b4bdaa6cfa58c8f9bfc44c828aa99f9bf27d25d5bc4aaa92f0d374f0a1ee6bfbbf1352cfd8cb74657916cd13fe6285be0beb386d500332f5f270bb1a3ee445d5937ec86f75a402bfca76b369cfc9fd956f6d8ea15e05135cd961ed17ca355b380a6e9dd4eb3126af3011203cf12803459b7d945a56cbe886909bb9780e89e76a4b4170a3db7540deb2f394d4481c3a91262e0fa292b6b026af5cf26987bf774c61493af88c855bd31ff107bfdfcc6e7f47a855e73339da468c181455cbba830a06da18d65762961f8815e3b03e43bc045a558708117af39f96ae9e07dcf1ed33c6192f409dab27f48b15aeda21e7c2b3812de9da8672f9b072f5fd3e399ba08530365345199cd00a9300afc3ce6333922a85e907603b5c201e5633e5dc35a9b97b15a8cfdaddebad9f101d57e567d8bc951a51fff0c0c1bc4d4a04dc92312449e69ac98b047c525422987c0bc024c7e41f571812f0dd98dc35560a26963a870c8365a8c42fb2fd8f1e2c7ed763efe68a73a4330c72b8ce3722b21dfb8b7db2794f20906e77cd713b00224d50694056cdaa68662e08594cf284dcf088922b27012c4bc421627aef3fba965c7a2027ac01103886e753924d401e03e2ea1a2eba0124ecf23bc3f37d8cff651bebec164e83b815f490ef160b0a799526bda9c1aa16b75ac4bb3a614988486408b073833a7e1749ec400be49d8995a29b965b0687ca1cd4a5e1e39bc3d7b791f38cee175a042465b92a2d0371de91b5045580f4b6e16ebcfd26c1a4f13eb908ec0970d64c8571979fbe5c918cd6d98d5052dd921e911a9eb0a2dcf6d01aed3907579140e2702c78ce12c65ff644cd5a6d0fb6f2fb149410f4f719992cc9dcb540b67ab75ead07c6d39f648150379f04a3ecb77cd5312628c34b19d84d8175b12266298a5490b945ad28b078502b72ebe4bf587f03435d18c75a38b7a0a7dff15b0ff464bed931d847061121555c77796942502f22b9f86fc86ed7afc57d24cd03f785cbc65177f24b94d7b4e79f35ae94e140659e2ea460c2b4da13fc37030d8a5156a8ddf0f4d5da5cb6d6ba925d8f699b362a8e1d2f259e64264a941169649fd9df9ccf4538b5badee232cae1c60b72f6f22e64d02a9e78c9ac5ec3c769bf183022b208f69a0ef97c0ab471d21d1bc4ba310b7ebeec3a00126a48a94e08308ebf6e4ff69d33ee924bc0154ba6301589b1634fec7871c6482302b1f915a9899c1f24b637ddc354c23a40ea1380ca34394fd8dbb92d1e5864ddac41abe6ad235911ab62b72d138334f24a467493b33cc38ec94c944ace57dccc908497938d2339c93548a27d82a1831b37402f15a3d0f801bf7d398dcb54f8d0a40c8c7b7ed448f840ef4e5abbd21cda8cd48cd4a0cb6ff244d332db5bea85855240bb4dc189fcd007b5125638cfd0e2dee1a768ba83db61938c647d75da9b4e3d1600bd708e73b740f2e9bfff9a7baa88f6352edf185485200ea7c34671b146bf0e45b1e8a27d7478fd41e99322195a647163bf87d7085c04c98f476e1b37881111d2d3cf898a7401a0fa8780e58092cb744b94d22632a60e59a365b51872ec378bc7aac07d6544effafe8230cf7f1d13e70f99f32a9b066b464543c388d8687ed6943eb9e75f1a5a54bf7c442638bbbf73129eec07e137964b55bfef830aeba37554ee5898db336ec1d6d5c4692ba8d62217ff707c57827aeabd8b2db554c3773122dfb687d02e4f1b99444eb9b14ce216e3794d83af0477ad74cd6b10d761243909475c0cbbb4ae61bff8c47e43510d6f05145ac8c581c6763f390506020319ca9957f98749b1e5bfc843bc80d071d43f13ac523e9bf45d27c8285b84a3616774246a0fa3695332f5704f3b3eb4f52745c45506ec6a4ee44ae78256e1386c0d3d3f47fa3de65963bddd50fc4b837d36a57a63c54415c528c622b9e42e5bfd60aa0162d45a4e6e00bd0e8a7963052328b549859a9f008010665de72426958c67c09bfaaac9a0a4fe49c9e31ea72ca9fc0cb0696621208e95049374628282d6fb737d9e8956c610f0518dd6709abd66730414b79fccd348f4653b950ddcd5c6849982bafe2e0afea50305f69085b9a7ff68bb46c51e6de77faaa1d7ea65a1e1575dea8070066707aadecaa79ffb9e1629643f5fd8676bd60fe5bf8c3ad2e0bcfd7e104641fe69b7f0a8d1317454afa52b2caedb45ad69446d7455ba4c5b05fd482ad7a6e36d2ca2a2adc551fc3a342b6ae54c190e092e42581b107c36ed0fc3d4359657ff0adb8f9a898754fad33cdda17eabb74ea4752b77360567737db57694c1f5259c02f25480f8b343ec272b0b8ec8440ac2fe99c71936092dd40a930765fa356c2b2b4f1f6953b87fa20cd08e4ec7873e9d4583218bc540bffac4d8b32304f4e77b4c1f8313279b29bb203862fd7fb80f08ee68a6f482512569f83e30868940f1b749bcf3506a1237093c3136328fe4dca0f4eb583e493fae1cfbfafa1626e7933a348010037813865c701b2ff39bccc866e9444b3f96f8e4f9b91f81122d4094065142ef0216fd95d67075781ce1be754d4109437216aaeaa12fd469ea8126374ad80b73abb0ba77b7f7e089b6b80b2444299ade2c4beae710d92545a55388c941df721099b6888952c193133ef7022a94c039c3489737db4aebb6f3dc9bc5ae3bcb74d820dc169fdfa09ed3cd27164cb131f352d63cd4a0321329467e88d2f87b12ed06d58fd013044da0e8b342b1d8cd528f46887313b358395f4fe5c8ee60fb8fda40a4ff5d8dad6d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
