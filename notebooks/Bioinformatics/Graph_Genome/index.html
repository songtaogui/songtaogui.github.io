<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"497119c50913d87d245e5ec637d0bcd06ccdd98af4ae49b309494f6d5f8c9e437b9fe7b699d97a88630676a3d85e67b599d68f27d16a78b3a8707bbd2357f2382e00d5af42ad1928094f75454c513b8ecb2926326356a5750c3d699e9fc7b33719378f0fc0537ca61efe08234eea9806d2f28cf09bd33e7e7f88a5b5410ec25afb1307a74ea018e8f11361d75240fbf7fc392ca9366e8c85c93d73520570b586f7b7f90ea31f190a68ae1110c04c4bec60e4afd36f1c2a927da2fcdedb2faf0c3d5eb8d1406b8d4b9b0bc6aa295dcae5a7f6f15a163df7e8e2220a24ba9671f3a891c7875cd1add9c9071efdad321b97dd6c119fb495d40f645da26850db601f3f993af31cddf11b8c697e45f6d541bf859cf4861577be5dd7edec33219977bee5d0f2b3ff4d5a5d2e954f12fc2eeb2fc8aba7819e91ed3a05054a93ba2aaae1147300cbc27d04f9614dab17f42314fd23df3529ffc6c8f1e37c6f23fd65c1d2ad4f9fef9258ffbef3a904f97775e9c6753acf68c96dd3cf432a86b2081497f12776d1df5902af51ba496c7acf5f8beabca08934be3e8490c654c03749df87798859b78def9c63e5287957c631aaaf0133416e72f76e0e802c506755f841df4c762f764cf86dfd7eed9932bf47a975bff6198ec2cd36796b32a533df4b7cfd988239658c197293de2f3ecf2f3d8b27eb89fdf641735bbc9a6ced535575be294e3ca6298cc4c405143c6c5e030575b316eff9bf18978463e76e32d7b1e0ba037b8ff54fb8804713c986910719782d898f364866a90780aa06a60bceb028c489ce8b95969eeaa318bc30c45a4362e88589339b7aaca3be39c090682e2ce57be97583c31ace8d96a955dc891170d963204222f8f4d2c128704bada4e6f2be8474af7039522d147251c824617e795dd4a0749e084e1aa481c1b69fae6146837e74897a9e183e9a25cd398e8d1072dd383691888e03c8e10c0ce8bd8d073c70f0099fbddc284a682d54d5bc9bda32bd005d6099536f9ab1dc27cb7d6e9ebf48b3e775645f777ad24006c42e08de2564f08de61bed2acf8a3b0d09fcd431e041b76175039b591429e4c73e0046014bcd646a65ee50a59c2dfe6716430027f7d61e644062565d4eb5513f70b3baa399066218d72a83d94da0b726546dbbfdd6a8a1e951a59a1752010bba37ebd87df63838488fe27426fc5542605f74a3c229b476353c4c7a22dcc97ad50e446dd29aff1b52012a41f05e03b23995ad36c7516e037846a969cb1a97a64cfa95f98fd8f1e0891b6c7ed027cdc698d1755f9c9eb2a5c34a1b308004616ae76178646e68696d68c3082b26acc21dd0c05e2bcb4f6b6ffdff570b12c62d8f3ebdc105a8258da95cb8aae7cf67b524256f194a4d8f940f5b106a324d593c82eb32efb54ca44564fed13eea87d83dd01861eff2a3699bd77c77f74e98e9c749e3026673593af5d3c50eaae75cb0a3e067ec4026f2ca6170564674339333f85cf8f20f727ee61b79d30b792b5828ab1d8a7eab774b08219c0a0ed0335577618817abe934771e77cf3404dae24f36806deaab652d0510790e043915cc05e5f0ec60ef6fbc7f2701f805ce783cfab6d41c6d675bf4b8dc2e37c1361fd754347a80aa90c3f1cbffa8834dcc37b7bf9ffe028f5a1800b168b581ec63457036fc82610ca37651b21afef56bb5c7f0eb5fe2910a2b0a82bab2dde345a73f4f87ecdf1871d8aaf6ae979b8fc4706a9cc326a10572761a2950099040646df344f14816e78979d75fff885b13f25081e52d8cf6952beb27b01c8d9a13d680a35561972f7c17fdc5c61f12b36d7ec8aa4563151d432743d27b6d0dcdcc52a3bc6379c5da028bc6e0299ab51ecab7141388fe42772263b4dfc8ab05404c77edb74e8954d0a421436c54d54ab0f21a6edb49062b1fbe15b6d49b41ffe096fd0aaa9457723bbd8eb1a1b0de3747b08f11ca81fdd3be7cdc405eaea8292ba2d86959555933eef5862119f8fad58b398e33437ac61cce96df7a188a64d5a144f6db40b178badc32e2085fb089c3ba89c8ad1da154dcf47630548879cedc4f5bd55462ad0c0c640a0585e671d2d7e419c3976de286acda4bad0a890458f492cfd7cdbc6d6b4b30b71f5841962d8c526adf388bb74cddd7f1a1b48626b754b268b2fa377088503158f05a15ebb5347402db46ffd1ea58ed71f59142c9878b047cefb65260a3b50aa770fb195b702d531440802c1d35e93466092f9ccede35943ddca70b32597a4da4f18827baa9e4576da6606d71bf4c669fa4d66691fd4bb99012491d0d2fe1fc32ff9594fbcfaba0eddd67fde7403eedb06726715702c2a8fd0bf70142ddf316d515cd21ff577a2d2192b6df1ddbd38d26ec2ee1137861a1bfd3c65502648bf2fa80a8781436c1bcb517675505418c877e14a26799550a9a84ce82167c15b30556676f43d5f1c09b6028bb977be59481f9787ae7ab9032f812efd6992669b1c83c79abf6b22253f8b39af6d42bc3e9ce8b6ed0688f576cdf503c5ee0513f466358613621aecb8414b2f1b2e66986617e4eb91330a1b6a929ec496aa86ce43711250f1811e7c567e5879afecec480d0491b463dadeb2a2b6f636a63eb71693c7a03ca56ca87b50c34b731b8bd35a55c44e7c2c303762fa278ef29d879fee1ca9fc6c7f20ffd77f58d74f362c474a2c6b84bac76c4a20e0935f053b927fbdcdd9c8bdf6a8d811f0cd1766ab453ab636285590532eae46354cc1a36a75f78c049bbd23fe27dc8cfe9f83bc9bd73619362e77cffc2a7999f344f6a5df4feadf8fa4ca82d7bea1f602aaaccf3c11a99e615303aace10608c275f61983d5190ea38701efa4466c8f77248276c17c52a0ce9ff2085e690c922c7807ed5caa8dfb8757a9b91c1aed398a2ed77412cf2f750a6d715636a3d305dbcfb3621f347d8c90a72586398883662c157a80a39b4b4bb40883b9a3399c77bb6de84de38b6a86419782d14522b0d97ccafe3c0059431bbcf4ebd2115a0f7e8dba7997fe565d8bdeec8bf91d567459b205f1907c204d3f75717e9f0cf68d25564e683bd1c937b13a4eab38551e7fc4ffe558c2c3e8cbb681ac19bc8f0dc069fc1ff21c2f88fc9d598855092bc3f233e3fc16accd876521a764ebe49ad298d1e1a7a06590b1878cc62400300468c82cc8046ac21f4371e08b6726bae27b09fb937c5db9750b20bd18d8af5a9d5bc0ec004fe91e1569868bc968c1e6515a996e1166d1afc83ee08fd690612221ab5e70e8534582a081543a09fa4c9dea83171496d4e1b3ecb570fd9aacf05eee807ce019d532d2e499e744164c9e0e205263ac13c8a518f8a4318cd616f89fba51a8c2fdb6d6a4d2a83f9103f7a54b6dd9e57846f1b5af15c05dc6c6b3d10b6bbc20e13018e071a7462253a133a2b17f8833836a6d7507f61241198cfde0b014a7e5b5d9c757206c5a86e5fa07cb8db1a17446260a16a20728774982faeb6329e79ff0689e0191292e84f073669773c60764cdb14d1866c982e62513d9759f12d9f6e755f4167da5759998febd241c01e2fafcde2c33d713a13709b35a572480ed934e92a077567bafb9fcc6819c6ebab399e264479cdcbd010cdd4745490bb5f475f0fedbcdafc260c06af573cf5ccc43eb3f51d374ece311588d90e0af886a943b665c0111b664d5e0d7c78a949e87676069e6b16ef5535b72912c6bbb67cfe39771209ffe6a5c084298c4e961b7c9d5d221cd0f83ef0a60778415e5e8abc2a9229e969d603fa13146fad1ba7b6899444bb87884db6eb3eed79d8e379aed21a2ee8e8fa4727ade3bb149bb12cfc265b8e85d5c3b08a69a4ce7a948f8622f62e939456dba113b3462fe2b720537c2a259293892fa799bd9e6506fa489f2293bd598dd98e133ca10be89172bcef1c597f2dca99bcafdbc1ef4ff3f9c186901312b42be42df8b2de27eb381423b60e34fc8621a5232b55041bd07f07f96778b40e1cf1d918f94f821d8ff9c3f2b7af05b3b7956182c2aaba4c44ec819a8611569b48c7bb0d61c19bc62e7482ab322735b73eab76b3f41e037b0ac8f42a0dc48dc1a05664309079d73d7c99bd885e0b89417024b47be1aaea79da5d706fcd6cc0f39d04d46aaf3025915cf1a0150659bcb87db7087ea0b900ae27fc05ef643a6d19d5696ce63ed29e4b9bc760fa993cddea2e3dc8f861fe1e6da09c19a18df66e3dc7cb1104da0decfa1b3af9f307722d98a033da36a9bd97faed9a0e62d7ce23202ca9ec7617ef471da2092a7b71da964550e7caf49def24843c0d3e340984ec3a54d8435877311bb14049514beef211a709925749d999ee53be2e50321d4155ac37edbfcdd3a9ff1b6fae3bff8b25126c1ed08f0a96b6f5cbe9c55bfc62adc3941927a9e3cbae1024e66ddc130c018c93ab103af71e52fa5e22ff5a2285a253ff97513f7d82c1e0e01924c0a325c00a39cde378743e1e3e8fc07896bda69579794a395315c20b407a3d0b9f31aafe246c0f8271c43dc6b2d7834412521833ac3cb4e7af31cfbe7809432dad84fe3e75a3538af4d37d7778412b5ee77d9748a825e01404f9519f5d000372929cf8dac7a76848c72f281bf342be36f7f29200408c97b96ec0a80de50727bf4000aa51fdf704d8f56a6e236bb8ce8a5ab1f977621156d07da3596e462c825019d7a3d0666292e4d2f95642a8e5e63e5ccc9fc5fe47056ad52788de974363f9bdb865f17a85173d377e32a643e0ce9873ce7a47445bb34196daeb644332baef74d5c27cb0cee9832eb09f00c476acdd9e4d1a369fcfa5e2b7dbb97b12bb6610f01ef8ecfbb1ba16661d86288d52620c97f4ca6078c1d59702b907199c43292f760f23214737b8fcf97fb3fe8be1f96889722ef9d8ff08628f2c2fc30c1d8160e34b2c489536ba4d12a4bae9d0eac9fd35687887a5c2ca090f0b20619927fa2aae3b48639ee50131b1f88018af3bbdabc8326de392345ec962530431f62ceb91f286255b3e5dde235fefe760d6ade14bbde028bfcd01b2f230d6b027b6acc4f2908e58a35681d0e8e8972118c2b864b8c183c8ca262763736fc0087fac1afd9c65668b17a40b1204e624d9cb82d9666d26b5a09af9ee79ad9f8b4da1711e3ec4ff5618852ca311644b15223ee7e22a7ea324101795a8e67beb0d9ad8fa2e61705d639dfdd5ad8362bd78d408fccd7700f481d14807880587bebeaaac1101797d2a4476fce5452115b890eb7258059d59d4308e2baff26cd702980f71fb281db02ff3074128d443f295c6ba7cb36aa2f94ca726309108e10a03e463c6f794effd9c1ae079728ba9aa8832097c6a0799e13ef02a8e8f955bfaf153cf98f8ac988dbf4d603b8d5b6f7f0578241cddc0ae1fef9921b59e14b01741d350897841ef7bf3947bef6c86ed200c7a8476c928a1011b1937e474d9cf6ace3ce34816698f32c5c78f52515e6ef9c04149cafc728dc681181ed0811d8a338fdb9a04a9f5bc84c1f4bf509e08336e40ef39ccb38c14b179239e286b94cee3e6ad44c8b3d1d3d658c60c1256deb09ecd9eb238c31b7bf704f582e31eb8e7338fabdf58eca24e4a8d9945f6a9afd10d58b7fd2d135371b82a612bb4f2edbb5a6f1b563057373479b1d0819aaba0ac2f2c0b6628b9fecf03e99c8db1b41378d58e24e0289ccd6768ba6b3826e2cbd2d9530ecd059b94fe331e1ee5fe966f47bb19b3a8a8111d90fce9915dd3e0aec8b60771846967a8d3536beda0c2ff787c49670087847ca6f30896e3ea22f6c49debf1bd76624a78e8ac6daf92a571b5b2cee4105d6b2ea31658a6bf4ddaf26a3d7337a35348f6d55b5735a3cc48993badf5d3855ed3b1b775b8851c377bd41ab8c548a789935a3ae7655d8d77194943bbab302a1d10c2829b6fced2ffe08d7799414cc78d61c2c463bf14d100fa058330c3c9e7d5a7d1ea00f8b2667df2ff82904b3c8308911fa3463b45d3664b08a9f10f1f904e04d0c6d514bb1893b19e810c2857cebf6c02e09a7654ef78c09032ed6843a2dd0ca33f50b3966fbd7e3c8c549edda2881c92e97713621fe49e3420459378c3b350a995661d925be5b613a5e97719e01e9cfb2fbe4f89d2d7ee19bed4f92f222d616186a66e2abd3b6919b5883a24140cf946066fce564be1427fcf6dc1d6dc529d8764b939ccda4d0cf1bacf2e2bf4c7c352aaf4c7c9756816b632658aa6be2a6f81b4292b99b9f654c6fe57827358c77bef0a51e93e193af85de41e958ced1920a331a1aa66090ff4deb72ec5e807e98832350e38afd45cd9a71ca495d6149842e8c42d2bd9b221ba9119d8569dd82ce355c154f8ab3bb3aa21fa3204eef467d1cb656fbf53c5027e01b0c0ed5aaf4b505cb05966c7a0fb6262120f7efc13b7a79b7cb2ecf706714abacebb4f21909131846720b3acd56d50ca99e09696388ee6747c6bf92695ef0a4bc2a22e655895d460e027c3fc46f5345f9fdf77e1258fc03d72f2b297ae6facdd034bd36d7a265418b177d1b2fc6cfb6ea9a5b810d27ff26c52f7128e6fbcacd351d17d978ee8f690974c3088b78939309615d449e10e541f01dba56d91a15c630b5461734c2f84898573951e9b31a19f2e36c94ca39e83cee05991b01c41ac5010399a1910d17b6ab32b963c37a0b8494f84ea387e80f4a3efb0f0256db20afeb10667642d8b786af116e2b5bdc64b294652a87ff958ba4375143eaa2604df9c7d1d28034ae0981fcaf842364a0cbdddabf590dd7df21dcaf9eae04955844ba2d14bac714273bfe4a4570c134558c4bb409ffaa74ec5768cc7762fdd459759de891a3e666f693dd765d1d285c0778a5b621601a19b598d7a8e60d576a98eec5262da4117173f72c3f08097d325acc77b0cdc480729e741f04ee38700a27f3d0010a04cff4a76df1df6f57ec1fff350332e740da8a609d07749e8e1c942fd43aae68c1a27547684e146d61f08547b1042428edeaef753bbce843b7e9eb9c3226d981952c52cadd20e8f8165c199fe5e3c404ee5844e2ebc7be5d10eca8f14adfbc50799c61f5711e402546d6232b712f28d4bff7a0447f72b07b16f83830640d7492d70dac011200b7dbd5ecb8b8a1117d4e6167503783fec5b656d2badd2a59489f906b1a2316fe6669b78b5d2b185936727231e0f9b4aec8ec1c9d8a11f8b12e59a4d35d9f031da369ac4a1544bb8d49c03d2763b48088c240aa8b26d5b044e275c9169da2b8f88082e08e59cacb17b87c7b83159edaa92f41a64216175a73d5a1962a9f323d0c03c1332c958b3b35d8f38ca3001a6a2678b70e60eb95685753546a1b8c3bf2068b7236ffb8f3131ea3780c45da5634940a834c5ec9b2c011107e2dac359b016d4765e497657049e9b7b083c6a2203d8c561dffe1187655108f8ed7ab8be76a242ca87234d660bbce6372d7274f93b898729fb9a68785f6567b31e28981f886767574c477645a17d0600217e9d07e0dcb62e299b0ac51ef5f5407ad47857b2af7e3e1ccd99656aaa60bd76a3ec1ec5b13a844999f7e6ef2b0987bb3bee2cfdd7654734166d83289c32dd0b21804b7e76c7c5b5efba8a9e9c39e7fcc64df2799129aef6ac40bb6d3495860ac9ccf227eebdc77a6f55c4de97de20f1c402b6e3600e074affdf6a031e8ac864e76f0ffd68d7768715242de29e0108f90885023b68fb2ef7a739788b3305465a3e616bb1fd6a7a6544c778f0f324157ff47acbb1eced252516dff92e86724d3f4370703a9f0accb2fb5c1358e41746f56a840a7bb3d8eadbca7b9135aa56fa8308f2789502cf82e57ed0d7ec6da1260fbb9fa0115cb59c04abe78e4d43b3b911c46cec59213498f5893fed33cafedec8a70e77d518a4c3e048f50752e0f5453108e6377416066107c203bae4e5ca9fde46362d0887304a83af5902a09357a657f63cf1638e62ae260e1ea67761d831276e9aaf52c6725f904270548d2be53c5ac54b977f0205f2c45bf3e35d03afad6620d7e1bd16034a925f04935526cfd71eee5dae8a4a27c79490a6ed76b35adc36e7f2f781336404e0468fe97a3cc559b8f67fe7d34df6b15780982ab8f08246de93e7f86107fa9f4d5c0d532333ee06a3bf27a2ac34cb8f4c6f4ef88d334387d6ca3657bd12e0ffd7ad6bb48f01c55211e1a227744161999041df997b4f7ab0af72bed93b90a53e123bdc0beb3fc8647b9d2f9911e99e4efda912bea972f898f2cc5f751a694b5f736fd0782f18b1dc267f45e4926f2f3e2b45baa93cdfc45a0202e34deef575b88fe3d3c1df547a252f924317cb68cc6b575ce8e31886c981d1e4c4d28387cb71645574685bb0fa6bc11bcbb82517a5437ebc1d1fce04d3f421d69d468217bc1a692f774d616b5a9e22f6efa039b4084a6773ccda1acb2d07ef761b41aafdf4a4ffb932fa27d2afed56279486acff49292b8ab48c1bd394b6fac2106f90359d14ef0441e702cd7235aacc3742a6d23e001853251d7446ba8c5a5c404d2912c7cb0a8c6be537736c799d669b15e4281563000dd675196504a96491147a362075e3046b44341c2f0221a0e0285c8b37290e36bb8f2892bc2ee18810ee8cae802b7c1fd1c27a560cf3ffb625099a0f6be5a9ede76cdf0f16c0d531d416b2d234471b86c3b6d4ae0f7cb98263b38952d1ee748273792530d1e52450d2c67cb9c95afb629d7b4feb6588c007f5bfec51844c5a74b5521a7fbf579d6448fc6f171fbbee222fddc4ca9679c320824f5d3c4bb4cd29c423369cc21ec15c379f214ef071e0bdb5643b78b8fdda40476f46a1bd1947677e62e46774f145253b0693765bd0e08db28cffe0027a1d9353bfe48048c263f8272e34b8880e16a96e4670423ed42a0919e939df666e5a11bc115b3771c610c0a74a2aec8ea5f0330dd3f8538ba61c8cdff920bc26023a9fc6e13a407eaed83fee9a7042e4920d125c6a3ecfd1dd9d9c5b41eb59a0bfbd47acb4aa1c98cc7fbe0ff25a216b4ddf0055dc1a9243992b5774ba4ad97e986df6e3232cdbd3ce939ac21dbf449f6ace43427b56a5098701a28c5ae36ce95d1f10eaa84eb4fd6c1f911a07f5816474c43da353e29734acc788d49a5b97cfe65f33745383be8724bbed3e9ba9814a196d9c1df01fa9a7cbf480531191447ab15e815d5ecba83af85a729d4de054e02442641a8f39bc57e1169ab026412d6a1df4aff5255db27978e7ea27e2b18dacbc89bde541b453c496a610afb97fcb8ccdbe3fdfae33aa51347f0c7e3e49039a7bcf43e3e8782207925cf772fba49716591b403d3ce6a3a54ed9f5b65cfc8fa37593a0d1e5ef3c4fb9e8f90ec05608cfa188052e52e6a5352e2a2794f035423d08a001953e04f7e0574631748b572fa6f9cb485ff769697f00adde6e94c718c9b66ce13de6a8780f882d5c83830e33c4fd7e11de1371e4a9faa43535d79f45abf5f0992d4ff08ec4690fd095567ec08b06084188033dffe7eeea800588e426911f622a27ee1486dbe76924c68bed858a5b2f0171734c6a42ddd19f62a99e1ddcea1dbed3df878f1210196ff4e5eea08b57ca1a536cc6c934d85232529d7d476d0b81601c94b220f5f605964613b78a80c8fb563e476fac58a2dcca885e14504587cc293f45f2a1845e62bda9e0bacf056a48bf194cf573a4e61465a5731a521510f3dce699de302532fe7b3478152bfdbb4075440ee12d3efdf9ad2fd82e1bd129481f9aa6a30ca0152df1a4c46826cff7b115033a23369565b886f79af00fa58fa579e39f99b3abb378649d743f2ed450eff6c2c098cf9d9df446d50b657030b97d3e838b9505e5821f3ccf887e76cd87b8ed95519ea9684fcccfa83c944f2a6f93d76cebb10de4a83996da829667bc3d7d7aa5586ab6f3156fe0859a2fab970a87bc261e60768b89404cf0098ec8d77c275403eb28e23b185927252426f03478581895335df95f0475ccd5d40ec3dc40e1885641d0b7150bd0c8a76eae9949e28c9f5550b47873997170a5f9cd5039e520a4e24e6b696e646165c4c43797c122344ada5acfd9033f53c98752984499d0c9c07ac7741cc8023de364bed8cd61cb6f332a1190b23e846dda12ffbe7d40e25698fb06ca0a2ad8799c9e41d0c403fb4984a2581ed5bfdc15c631e89545a1f81cbec44c2801142b6841112005e1afb0c8ed6bbaf05c6d6a356fc1367f1116625034daac5a57e6dd9ea3c026bebd71fc83befc57cdfbebc1cf6717e9936d09236685599b30b7205ee8efc163c4fd644033cbec92df943099863bc57eec3fbfc4e25f6cb666b14646a616b063c922ec7f0aba64ac50b289b017a591b130b3868860341a8abf5135f2523e23370d2a57b4156f2c04cd1fb92e6ff89f548693cace9c75b975abff82a9a84f426e34ba63d9824d8eb88dc4059f9bb68a7e72d502f78406904b750710655dc07b021a14f702d2162e7558f6a31e09f16d27b055892009f5f04e9c6cca07cd2be398a959f5027b125e5c1cbb4fde806d229a79f78f6d56074ad6b9c1e9d356ad4561bae61da9eadf3a3fa21c0bd8d51e2505727baabf0b416e1128481badbd0a9cdc4ccdb7b544732a835ac269280289e971653e4e695912a44d81c32e8b9b32dda02b5df8f3616aa08f761c1032a657b9a1e6aa9adc6e30c47e9aa58eca6828ea0596796db7809dbba37bdb6a369320f4d0c401e9a4b4c35dc54db9a85e84c6fcb3688e1481b03170f03ab4bc4aa5daac33c2cf8db3408c5bd35ae6dad9e6f684648343107899e05cde8727474b5940695c1545ec590ab005ee9cadac9edc66c3cfc9fcb6acf311ee4cac011b9cba85a2d44bc32bee115c80e772f1e47af5ced40c972c577099934ea511187b189548d3ba342cc0519858f0edcf41710a44f8b072d0a4828ae4ac02211ac1d1681d35ef54e9e1c8193d4ab072e3d309221cdac37fd057d5ec385cecb848f34c2f16ab8a2ac74861321901a2c979a03e92ce29cbf665749eca605862d868d59265f0843b38125d9fc3d7055905af23e7a3682ea3c96ea9c38e8dfa318197bb68db3ec910f9f564f28da41be1c81d942c16c7dfb7493b075a1cab5dce54f84e0d3c67083c81d9f07ecea66cbf00eb18c6ec8559e3f653828600ba031b8978caa878e17e343453779bcae731790912c49e36cb8bf9677a29a7a2a7b8b54a61aaf9d1fca7396c60c5c112894df2c174af04807fb9eb191740034d147a96f8e2bdcb63253f164b8e242de50edafd0f2b890e64c643c8cf45a5bad9c1deb4b19a89233e09566315b3248ac27fa74eb577673035c8fee6a0b1db15749fc6dca06120ecda0fb5d013902c1d9d9de6f676e7c24f3955e93610912850cf9839f5f5da910adaf55a7cb3708316153a92442596200d76d3cb0e2091ad6e97eaaba13fb5812acda1c7c3d8b0d744107eb42e92772e059741fe939e703e621b878ac23c4b11b7a59e797581024eea5f2bb21f26e427ca3b11e57f8162e0cc0b02d1e79954b507dd0c3061ee3c6067244cf5e122d68e0c50e7235115dbc6c77286fedee4e6bde5fc1ab8724b6d1c37a3be3fed0267f977d87fe05705bbf6ce48c907555d79481a7dd4729e3b7334ebf37c3cd4d529890d61c3682d45fd6c873ff4783ee611ccb6912a9a91b3689c58efa0635ca1fc6c16abc5934ad0909fdca3c36f199ce28c6a29f6cce47515ce93405ce0e5790af29744a64f2214da21024fba8463a541a8a51be04e0711c46358380b662d0b852f70d1f8d8688ef50af4a49c460c37b64282d8f1a9c1d8f0afe913c50f2ad6d50bcb681225e531ae0108befcc0c18adda8bf4a99d786f78cefe70404f92f319d3b22ad7f1baafe9e6088027ceb474e0c5c16b90568d192e60c93cbbd1b48f5e5e126763007f4710252f371c042b4088ae6ec9f0af2ac7f7739a4482d9324c4d6fe94cf09eab1ba9d18c7e9b65c8f55171cfb3b418d65a61a4da2ee3218da0480bf4fa8e2c2419ff7ace4b6d01e68a69a570de97e0b0dd5f85c2275b37fb4705fa60e06adf6205b9ccf7f5d902f74bc0cc1fd1aabf0ff502f6b8685590128ec1400ffbc2174726255a69c208d09fdce043d48130c357b29a1ca38afe1df356c5b4468f19a353212ac9f23d0efd63ac5998918c9f7b9a159cdc9ad77fef88f9efcd499143d8b21d8478a73cc0bb128f302d10bc8ea98b6199ef25413164b59d6f408055fb3847ee597ede7e496a92236b5a84361705b825eb13067f4b1ba247a57483900af292ade071369d4f91e6bc38246b32a6f4d14cdc5287fbe9d97b1c0c89f355b359f6780a84a3dc6c0810a1d7cafbd81615af0ba6a9ccfe9f777601ee742bb1192510b8ed21cd84ab32870083bb335e4b58ea724d7a0c8e1c60206def8832ee8a4c56029c04b88023ea88ff50dac3b3d7019ec3776f319fffbd39c03490646188a65003d14731d4cee0bfd4f42a8c0c3155e3fcde7b56ef82bc908ecd9a5703da4da5cb071619ce30c38846660b5950c1563ffcce7b978993dd2087e3a6898204423753fa6cb3c49826c1a1d9d1bbea0418c703f2f9259ae6bb6cbb7d0a98899bb580ea26f69e3fcee45f8b9a43e7f2c0566d9e1dd82cb2cc38f81a3980050314992e7b9a3c9ae34726511dfd82394c151c2816f88bc068abc906c310964422ee27896a66c153d16700796baccc3ea912a9e37781376c745e4ff541d181d3b87b65c43abc3be54ce62e311e801989bedd7f2355cedc0f4ff515c883591fc2859deca4bc60508f1d969f6c0fd5c1925bb33f22aec71c1bb2b5a76d66ec2a284bb353f27e2b3387993db89c985cc6a6227f1cd3c894aecc5e5f832c8a65feaae0ab249e0e9c100117a2dde47b71ea023109158bef4e70f62f50b2a58d77d865c1a48ffb36eaad9641c03e8b4a2f8422003603b0eb357aada24dbb8c22cee35361939209849478aad266aa1b70e8844be5c2a17c2846ec76b0c43c7be361788a18b42a9837053ded351c62b4e352a7de495a44aa5d4b32ddf33fb3dc989afbf166a9b13031426244488426f638075401678bbf1615960f5c6a79de1a0bcfcb49fdf5778d88a1624cf86ff8df663af01442c7ed8f91241894abe15e063a2e0b89398d8d57dac554108a95a8f46135eca9f51f2a32a745d7a1fa495a5c244ce285ed073436418b4d683c034b5548dbedc139f90111078dcc62a4624f3eae6c464716f69b8dba29b039b53081186b7507ce73770000e6a5e27a4a150be8de72221ef5f0f112e41cccf6c4e24b63485e77aee78028297f1b18d765527d3ef1370fe526ecb0b693e547407befa33ec95998dc6523527c8254141c7e1548d0d3d498f6602d2a7d6c74e3646cd4408ea4fa9cfa902da94b8aacedfb448e098ce19c35a1e9cc04f2f75fa7c1dc1d4e2703c7226cd51bcd5efe167ae3f2ef92687a9660b7392540d329d546bb9185585c74740b99e6c70be4c96b3cc421ce7667a2a53dc3d94252875879e480662c60eac192634df6f0c11f2fd59e808c316dfb6057c2c5fdcd4fe74efe13e139972214cd5f9becc84eab90a8719758523ffbe124a67af1bcf36943b1ee99537310736ce9e36062aace461fa26995479667a349dc9658164774d00be1f87f2c97dc9e0853a3953f62cb0d82963130a36c4c5e349a8fa6fa47809f5016f79b1c8bb7f8db6f30dca1bf66350d83a4e8ae66fd6cc364bf9179bcab258c90294c762f30c8254fe250567a826f8e4d7fd9142a48e86f3525478ff49ec0d84927aa7ee38c3b6df3e32cd7af9c96a62690643639a57e162ef26a1516db0d0bc0540ac5b88221a934b21ed0b960d2c28fcefb704b0ee67d3d64a726bd854d785d05a84f0a0a8342e1caec1dc6d2ad0da784a90d92c5b821807db270a79ec5e4e6412849c72d852d8d9144eb6067515566f3fa70850969e1925c0d58abbf447888a862a55aab46e5839e53eb96445aa340fe93f932893a8605db6da385916d7cce1ffec11583889cdf40ccfc3a778181a876ef0fb823b2e2198755aad8bcd3ed280835a2988d385444ee3ee4019be069849207493aad76c46d644f3f26de7c13c6a63ca4873d7c836740eba51e02f3e617648e085a69b0d97bb77cfa0762fe6b99e03b7d394d7017a0b2988c78eafe5c3c7ae9499e9dbdd86cf10c0f2796c3bc074aa0a6716fe5d24b83eaadf5c339ec892cb63d13c0abd6a57e917b391ef34ba24e00b99f430ca97ba5408cd6d2c23a8948bfbe7a083649e5174545309bf810a0464201543fd1927f6cec04f2025083a24e9be67bf4ecee10fd31e679f366db63999b9c7fe1cb85801eacc4d79d5a8fef36d36e360a20f3c4efaec47c411e325b34bcdd533ac0f8f4fdd902f85c06d51a7a3741de5e44565381854e380ab2ae8cf6b63cb82a3752cad2204ae011df635048307f7bb023e6b136164ac1d4d25ff89b3e16853211c0b3f3c4a59fc96a0981bb56ab8e0c9d360742c96184067209f0a3ad2ff2a458b8b3d0f73bb49cdf79a58cc23b5cac64b1922918766c17313ee41ab264c9374e67403224c275bc1e108aa974d142dc436fe53114bd1482a69cad0177c01f98e44e1c70df777e6f4565c16c12d82f12b4f4c4971c1f52bbf3b06fb9838d1efa5cd49f32795728912c0377fc64f7a83a0ff9cb6e9168c4ddfe465614b586a1470e30c94284d1ea4365168883fb7ba85394366d24a34febdae109fe2243c645f3c0fb10012a2f0123d2701f1f556e6d78f3b1a14804fc8b86bf8311e8500195ed0bd8063e090583c1021a6c0e2f08b262f73aa02f52a97e69538fb06e7e50eb9f01aabc02e08b44243c920bcdaf3983a1ec070ff64b782997b3064bd3f4dad830f1045688dae280f0dd87073e09c61859cb724e7e38eabc78c0d0a5379ef92416ad44d322410afd69694824f44707bf0d272a0fe23893eca5c04bc6f488d9fff42dac5f19f8b009108e645ed28268abf7c187e39c50baa0cab6adceb343bbfdb103cb841ef00d67bde4329c6b56d3e71b8fb4af5e7ba9d8865576f767c1ae61ae93d16e817b10b56a5a2a48f0b98ddf61bb5dc1cd5f3a749e8f845686fc9116f57b080abb71c5d524b1d9855a363bb7d1991796d73d8888c76d401477f6279ea8d74c5e6cd89d2389845ff9e6b6c389fc20ae76cfa1e240bd945a17b4552d3ec06b39712a2eb967d3a57ff7814a33c7ebe6cf66c96d6670d083e7fc2e3ed99a5b6d66b572336d3675dce4737414fcb75c0511032d4d16db02ea4a9b93aeb6d61b4edda36c2a0dae499e9dadc15140f6ad459a6c9d29cbf87e37510ada0f14a9c29f5be355077233df6a584437e2e3dbfef8a755e393fd04d898e30c8cda483d1d919ce7f4a61bdc7fe7073f7971a9b804abeba1e3eeb737f342d1127538bba7b073ce18343bef86bfb89d995e0110718cf40f8365f0425270b6dd8a4e654fb65c906f5d0b45b428c453b329fc7478768e71325974c3e7c37852f3f90c0625b5ab339c8072e67c9446b5472e7cf45a01d9e847895ba8ca8e576e1b240d8241d76eb9d1f47a90d2b02161e7d3049a25157fbe6169ae58ea3c86677b2f53a63afa0fa62f09136476cbf145873b199d2d99a91a7bbac94d0d3c9fcd899397a8e17c201c43ad977d3891f92beb0f346e29c729f77e09470f3ef4545e544360008793e8ea9057e2ecdf6143f03ce5ae545edd9373680acf3c71f925b91539ac88a8f1714176a46ccd455344e1db97d546a624f4981b5f86cc8f4b7913100236d96de90b94db0abc3cb546ccf52da4ef821b6ab01e94f1565c23260c8fc26823211ce89a46a2a7cd2dd9d98f52822c3c829fc27c42ae9ed413b240f91160721db6d3f14dea9a942365ff8cbcf0a10133cccad2693116f0b5949133a3818cb4525783b2bdefe2b1344ae7b506445571cc3efec9fb8a6359b3617df5d339aaa5c41df4f1a34679cae515d457aa7d885bbf03059c26066706a1058679240e26c87ab45914aa4ad7e39409a76daeda9815f99dbd704c64865fa94fbebbfaeca1005ad7deb5651a7eb084072b151d5968db80bfbb86d6b3580cc25aca178364329a56546fca17bed8ce4969c5710cba000b22ebcc866304520b9901d9e0f1f0a6a3f178402ceb6efab63412c395079702456ee71aa5e3d38f2205ef2684c985a7493a80573ae58786bd23ad743065f04304b40e7813d5b8ba57f3da26247e0944e9ea677f5f858fe14d1b5ce504154899350268d34fcffc6cce5fea561ed77c7d1c78ee3fe8783525a1da93418f6a6845c03c4da7789864639916a50604aa0e192c8937a2708080c616e2cf4e84f51e55c3781d4b9c54d3ff5330600648c2a67261ce8695a40f31b6e7ca675e223590b73b510b69d871a517d7e989fbd57dc25dbcd53b979c477d8885b7c0c26f3a9c1c4ac9c09c27b79f1ca584cb20a03acbc197e4d9a1d293bc015329dda559b5a1cf23593c581f785340de80abcbd455baef8da25eace114085caca6473572e20c874276d670656e715d4e52b6dee8cd56440a737936a824c80a25e044316f33ea872fd8aa5d0e490fa04c2a855334a83e06eba24a6390b87f016aead6d2ff55d5e6a6ad9e66508be0425f63c47db1cb83aac0adcfb87b6e87b83ab25121aeddb9899f63d217a732403015a4a4f36e7afb9979b0f47f04a0a91f6ce1fc688f22000a49850b5902058aaef5a673c559c5296974f2a042f22ef4e18ba638fae06a18c15d4008a18d757230a3e5a9cd6a8e49ba3cb001df241e2f71c2dbc8926b05ec6fdaafc76901a6f864942ede792ea45c2a769f8f61941b6f0b0975f859521fbfd130e66f258bb7273fc61948d5da02d57c27d2427623600342e218f56a1a03de094898fd93dc4214655ac4f961a06f8dce6a9b6a19ba5db68aeea6f91c454d500f1599ac6f48bbdb54a51bbdfcf92f7d889ffa4d15a7fec64aa92660ec0a3413d5e467dd691b7a1d0ee3edb1be3b8c3454fba71db39f2f0210ec214253968feed5f72e565c1437e54c36e1412b6428054ec149b3d8cc91b3f03e0c23afe6203425a37be7ce136aee1ed247baad6b98972f7fe9adcf5f3aef78de969067481e49512cf186f4300d278208cec7ea41ee7dc67bd0355fc1f4d3cae7cff8750acab2f9ee499dac76fd788a8d2b40d4be6a36412bd19dbe03252d8ab0aaf23635db4d6c528b729bc6e59c6949f032604880943d52e3b2a64195591de39e95fc17fb237c5149c1649cbe1a6ab15e5dfa720f68ec20a9cc6d912d7d9feb94c44d41ba02ddf652f65dd6a5b9768139b4e6dd6c9b260b179ac162d957c79895c96bdd1ab3c5af413f9821ba2bfeb1f6fbdf6b8aabd3f19c91ea11a0dd8466a1ce3b85e7898bb83260d29bed6740e8b5ad80dd75a590e1b96dd2ecd12d16168053967bdea158e799b1bbe66cdca752c38d850bd780718a25002521481c9160da8fdbbb7817159a0ccf4ce77ba859b24013ff6d01190f6041d25835c14d79e2e4875297de861464c7bb2e8728f50923f99fd1bd35c04254a31b973e8c44ed0f1450669bec3fb9e7ad7679025d8e4d2b75fe850ea0853d959cd8e1584c0289a0014f1f6bb763c211b4cfeb7f5e9533a32c35aa188305f6168f9b7f7bbf0d7ca592330836069094f47425dc52b16ba2aea741a536ee258ecbf0aa7e788afff7790c94280e0214dcd1f80aa9ebaa41a744f4a875ae28e28bf7cd85322d18c0eaf77c6b479abd7c589380dcfe8292a086445d97ce1f9ab532f42830d93c5eb66070473dc5a9941cd9370c097812b96ed35c1d0da21552d2f8886c6719f861219d704037e8942a60336ad30ce9de389801c5ae98b7c6a13a186ddd1346269f5322e5a56dd2d2e78058d7befa03ef159b95921f38ee65a22542232f7cc5debcfb710278ee8322039852ba3ddbc0857ab3494f5aa0a5227bb901eb2c82b1873cb3da31151b1885adb6bc61d08f8c3b02f5b56485aab07fc4fbd7758773353e3f0ec07390a60ccfd3677d6d7165adaa9c1e580bc22e4af2511880e771cce698236fee4aedfd2afd139012799d97c1cb80afa969a71c8f5389ce14b33d32f78d226ff8fc364abaae9ab1d9f196a9733de4a86929f27b25d0518af5bca4f115e2f54d778607c73079b763c767c7e2f3564529198d1813c4db3cff0b3eb79d4994647d21713650fcc28806d03724c013ecacef41efca718ce4bd6863ca4a5e0abfa87e8e8de08a28181ebec3bd9933d03ccf9c72cfa95f23a7dfc16f8d7921381873c8e4cc4e74f05d08228ff5da11eea4a5b1124b3426e1f5e3caaba2271455fd1bb18620b24a35fced3311b072e47541cc969f6fbcb7bebb416a17270faf5bf87d07d2dae3d208441307dd4b09b81697e1b18ae47456e731ad7edd96af5666f679c4cdf06037efdd1fb14d9af045133473b05213f4aa02d58434","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
