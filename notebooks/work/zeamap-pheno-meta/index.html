<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5fb32a0b49b1ea6df8f844375e1d06571113d61b414fe50243e664f84f0a470ba2b92a20acf61ee299dbe245d375d56ae9b16c2028934a5a1b4190fd2b1fa385a09b763be803749601d047a0ade36e0afa09e5b483fad03dbc9f79e1a01c21341138f9d9530db2ce0f4cbf3bd2d8394bf4edfe56f17569bcd7d639caf3a5afe6ad94ba008a97ff06657383421874f2e23dc1eb2cb8126b9bb659655c610e6ed34ba8284ea70b2353a1ad684df23e7d507e0762cedf976f97f369b07ba71053ea3856306f87802b2539b69bf94e95322b33061c57fc8c765139e8e7432ed62080b7e4453dd8ad8466e383e0aed643d9fbaa51fc6cbeb22debf147148a1520ad63b80a04b19b3b23ead6b48161629830800f262983a8575da6e806955da3037e0f12f23a280881450a82daa514cb255d4197fd9e2feab626807b8ca03bf996a8b675567a03c29c522a2cc9c76047c6e2767421829b45068f7ac4a9496b8dbb0dcf6d469538ff05cff774c283fcd10541ab8416cf738055441f7f80835f950165af7935c943de4fb77b6b50c55719b658d13211b53a9e112e5cfc6e17afbcb7e550c5bdfc52e9d07422ed198ac0f1b459cbdcf61b93054239441519f9cb772dbab41fd59ecb54d5645f37b5bd2890642e01f1e6a98c3fb055ab42816076ec2dcf0b2767fa14eee39df7dfbb3319c4188383aa91d107aa4c532b6679d97008170a745defbfe02b6f16c4e385c2561427ab1cc9fb4847cafe4a0b7654b0a2b42d5272ee2538f7a19c50db7070d2cf9670dd5b4007f981bf2687faa42b8d809e509c7bb0e4cd0b67c266ed0ce8c96369b57778c682d6ee63a09b9934eb2079b764c18422b95af18d1f02396fbe648316c95f659b5e0be56d4ad14b051ce6a4975257899c19b90f8e51205a7c20d270b25ced526bab7aa531bc1076a6d1aa9b8de005a879f3e4e174eabd80676b5499517c8ee14af9e3d9f39d0af732850baf931d9a1162d20e48cc56225802cccb15a718f654c4e0a7e9ae3239ac34f5b4162921385c611c0c605973f58cc9d00a88b1c8473c8054d10f9e6d29aff85651687ea8083896c55f5a0825548a5e1a674e8634095e3875dd8953420ec3ee28c4dbc6a3c347e8a4930bb45ab02c35cb2be5a76c771b9de55712014fb75a08e60cd0225c67ea156ee6eafb39da50a04ae49590ba67d13d46a512e44d8321e196cb4da4bc7beafc5ebec1893775c45d41f852904e6643463f02c42120751ec6fecf3f4d19f42d7819cafc212d52481a82b28c5462423ea26f80c55e9cbb3db987bb64736192bae73a1d59810098c3677d6e5ad36019d1c9067313f4131181306d8f5712eff65bb3b27259ce939f43f7975624880d4c73a9395dc05accd169e2318893f48fb98fe194a7f40ff159a72e3815204244086588fdcae759e0c1889c5f25a577a7ef4d7b3979a1046cedbab5d556b695d073a86200de5ddd1396179bcf343079e6fac44f37e75185ed213d1510d4889f02f4b2bb4dd8176f65f9c105f6fda4ce142e9002d346a954ea948c49f1529689d1dc6c279bef1851335689cfa8732b779592b387da925d5fe57111ec3937d7830e4080ec7b0331c2e26b2646639d5c3b2ae9db2f0710e4f3e3845547e5ab42887fe875255a2d85e95ebd3d4c193e521d275bef86104c5c1eea90482427fb6cfdc8d90014cc4481513c77cc6baf16ac81c7e5499fe326e05e0a7100bb710bd9afb58b1b9b545349898edec3958126239c7d7f4b187d6ae454fced836598e84879b59ca5efb81e5c7bda4a48043bb6643646806c4f2063cbd0f4f2e6dfe59c0d6ee801315babc0696cb6acbbb0a36af2391cd22578a7a692f082aa3cec1ff41c1991f85dfa14fe04704e68b166c1a1ff79fcdd82ff207c13f22f05a0800d29e232bf948afd6232715203433b59b28ed8ac0a4ee25cd07c1f9363f161a81a9e02df79f0dd816e6104beb0a727eb8ac5ba6030231d6c8e7ba00492acc6efc4d8ba385a9bb434beb71f6eddf6db78d5c9cf86eeb00d0486786f1af814bfc293974f3163e909bde4551f35e2d571835046a995e398878de7c3fb62730be2a3f2a6016fc6c90ba3707157885000b2483cc2b5310dde3fdede163a7c65cf7c337221450f5a82af7b1b218d634d5689eecc6ed9527d715ab00f5bf709a832c93b747734b95c8c64d252c1e39ae2f54a49674ae1a64c49e408d58dc3d485e44a7de72b5b00b937ab3cc18da7efa913da72679664a0b6adc0575c59096146fc613618104a1d1375f949cba1c5d7a9d2fcca5f483ebdeb8cc026f34896d9fdf4f9869056592c73313bc914a2966ed53195d836627f7ad68a0fbc39215a35ad8a0ad6180e43b17cd687af0fe6dbd3328ca5106495634c9e2157071bbc617c901240ac7514cf302570a0458a86ec359f167cf8b97adb4b77e049768cdaa08a14754dd0470e4e65fc2e29a7c4b02e6963e4562e7ab60cee30380ab246eef54564c14f55b5ae3caeba782af486cfba81504936a11125dc2db6279974e69e3b7d548b4ef49ceaf291a6f20fcefa194ecd2bca577913b2199b7ef2a2570a8549e2ea8c70f695be1db662988267f92fe1bd06c12687b295b955ea5eb5ef657ae0b131dc7829e01d2dab44cf7322b384a7ad3023c5400d5c08e84fdddec112e958fabfac42a69097cce19458ab1ea640280550db72d42dc67275d856e851d5cff2c7b26c4d744fde4bcdffa849be0fc92f688a2e8bbdcacd3c1df6d9fcbe9da7bf1d78b6d52f6c869a58187af291410917a800f74f42a0eee21583365236885a9911223230106b8c55acfb766561ccc7e79b0862579da89c9c1096595bc426acb63536359c0f7382257f548fd588a102b78196c09ab05031fc71b72e45a13e93da8f572a3fd23a6c771cdc1c29c71e1922232c9dd86c3ee16473a4b513cd13cd07af83b06c1c2189662956afea288e0913932aea84b408e66cea71024ad023db23c7b5b92d1e6b7f8d95b1c3373e659ca91768c06064d3c7a8364d0b6ad3256cc134c72a75db792f07a2f95af1e7713a445a6730a0e9bf61f26d222cb9591c533f923b5db73d5930596cbeb8f227ae85cd7724df91d46402b0a9e0c356e9c8727eb0f5d0bfef792bae1e9392892678f2d29c48e4977c94090ad16d0cb67aec982d521ba11482acf713b5c288226cd9d9944f2c4b76001c212fa1075b0a570471e1fd6d92d91f27d10626edadae526e5442bbf4171181d9f2004ad2f343bede8fbe188a8159176755732bb5a453d3ea1d03dc7511133b358c0a6716ae78ea1a5f38b9d5de1e88186dfc8ad34b3d56eaa2d2e6bf2f9ad6c6d0ca6224f773d99b0a3bb89955ecc4c2914194c63d747aba243f6d0f640ac44ff81fee1e6c42c62362b4f0bf4d762f2bf39c6e1a346b60f75041fb0c69c61249d261eeff1be73d0988b4710a50b61663a401cbb4d8b7941c6fef29d82a9ea6179b147927eaa1ed0b95a791d03da75fc13c7a2bc68ac823f6b5bd178cd01e888c7af4bb4b723a69532ebe71f7c3c86c94de2d695b8e14d363d84512413ecc3baf3d8ec769ee9ba1ccf17d953c6782b070cf9a78dd82b6d40b544fd016d9c936356555ec3be990ac3b9b62b98682ce1b072ab09cc734cf6f2dbd77b25a33d6827ce88612ee27e9844360460cd6e81a5e62cd0c2288f956f4e791f941de382a0ce927a0501bd108f8453a3873e84cc84520d171488d87045ee050b99791aa114604fd498cd9b76d9b54c776937ad31914de6cc557d0f450bcf102ef00f9729d1dec93b32a2de147d8a7809403b6241cce92b47ab03f8e49de4f60737c6b6132ede75374993bf0af426c01a42f18f41463f1d6b764c9c3f7c919a7bfd7b35ab84ef58605e880c77dacb4542d5441c770989b6848ad84a042943030a8e1743f37d1ec77887653ea4065011a3f4718318f3736951bc07335e63de47976f77c30f243541b41f11d05d069faf8f3f2a9923989e4cfbbcfa42c79b1c76475cb38a88a0fc9c91e87bd3d87de622a29b328e671c5319c3f491b4aae751379ea103fed9989e0e004f28a9fa27105dd11c53c419f38d8bc1ff92d395077a381b4fb6ccd03cc357afe4fbc5a564e9cd8df37782a7de9dbc377f1ebb94c48e9aac862d0458c7e8dd092eb688817d21c7989a731871df05287a46d955eff0b893e6ce33243c342569ddfdce168834f96468949effaaca9f3e74cafc204798e18d82e7baac1226f618f17d0094632a0dbee87f50ff35b4b071d1ca2216b6d045a9f6a8e80e977c844e85ce09f51ddf5c5f0fefbaaa2443e4d4988ac376050542614c5b8638a889b15313e354381f7d80597fad74da9f4c138d3842feaeb6b0bbdda7219689ceec9cab3d9e7228d6a6a29ec423208360a4688eac1fcff9ada238d78e6af18e79e218bd219a9493a6d6fc9319030323ba0e6111eca9e2b9e432f0474b335260ddcabe49a34ca6b0017b61868c3f91c2492204d32bee29e030063cda1067612368b7365f0634ba5343f5d215490450e050142c98aeaf3c1ca88c7e465c6e06e765169b2ed8413dcdae0be946d4b276ecc606bf4d0a94c76ddafb1a38490c6d353b5588bc6b8251670d60602151fac2c327c7671e45be2d09ef0046014e4fc373ad815b30b4678d82e0b9db3eaaf05271cd35f721df20a6ecade499365361bf34b2baf80a82914d8b2c804261109afe0cd260b6b4837e41434159a3eb77cbdb3151defba07ff1ff0d41b2dbdac5971cc6a97e2d0cb91cce9144117ebe73d710f5942ad72711c8a122526e9daf4b99f4dd308fe1cde8efdeab915742db383101a005ea1d519274c6c5ce4a6febaa772d442919ea3d6d77cababe9cda1d183a4a2cfcdfef0ffe0979c3f4046eee150f832235cd5ea1267ad5ef9927a580fbdc1ab01b991ea9bf738a3800a659dacd7be6fb8a488319f3caca85b5b470194e6a710730aaaa1534cd537bae48797f2c5922a44233a21a37420882ab87fada4a7528084147adf49c2a70dc883b6974ed473857ea00a8841eb53270719cb943cde1fd5e4f8567f30ca85cd02b616c7e09002c85fd81fc5098ab433a5e980eaf4f741299eb076a6a6168e11819cf3e632e2144ece6eb3116f4c748c041d29b237dd8eec3723af1ccd6069435bc2ced04877a84662214140e36f71023cca95bfaf41a1a7663a598039dd62c6da8b9b8c8baa537d9b2f9e23a4faf02d6b628421db1dbcfca24e1bdf5c4bf97ff149b62d05e68ccb7d2824512db7466f4381d693e090dd9d66afcf33920fd40c5e323a92417662940113090416461215e0f91286c602c17a25c2ddcc370d6ff45d0e80646260c294dd239e36736f6d3469e14d184423c20967bf2be052090b2ebccada70c71401c19f1589946ecf7c53a82b7be9985db42f4beae82a6539db87e0d296a3a86502f55b0764acc20bef94c026933ae741012bbc0871c6557c8216bb8f027930967499b969edef2e383c905e140ee444c9c6210d520c8bcc052337a05a20c04e4814eb2779b03ec166d531424b2ff486cb978d505f0a912e25d7673840afceb3a08a7d17fe9aabb16b3089b833c9146b19c5030d4930a6a603e6e8e189172d96e747b96af1e796de4eb0fa197da57532cd5354f69d2440528d54d7354117a9d69a5268e9ed45abe39f3780063d258c5f3b40649646cfd2010c62e3a8f2a358aba08edd1aeee49dc19865bcf9c3fc24a165d8ad04f5e6ceb7b7956ee91a2b6ac279b6683427a9a01c3df69697ca554e8c7be759cf25ed3dc02d5610609773f37db62685ccbf1db56179135190d2a8438132370d3a5fed16761b87f250ef5ad87842d9a2db3fced6fddb7bed199016e32d45d2c2c61b84c0e8d5f25582006d4978a232fc210ff2e569375250fe1e704f846d99e57e79fce8afaab1a8c8f6ffd17d403a7cbe3e82affbb500f1415bd3a85a370526c531b952df585386d474c0d014bca534d27f06768a20d86cc2ad6bdebf484b62621e54a07456916a74cf5d30ab98acbc6c0c4452abd273fd64f7627092320cd5adf0768bdcf9bce4c768ce7168761c378de288af3e514e140b61af6dd22561a1e56dec55c9b334d9f8a9473d09d48e5ba1d75438888681771a24bf44b3b5963fe8d3a88ebb994ac9cf782519c54157dca3522fe1081916eed074a60c6cfaf9d0f3a2d09b5d9288cdda9427bc0dd68c60618a0f787c1430d3c47de1f2d93bb06b9865b1a02dae46b4d921a9f7971ad2970aee275b6980c1cd1eeb5981da2da36b0a256cd6d0344929d2c99df5fcdbd993ea889c638008850a11218b09467c526e7b219c99ee89c1f9e6b1000f9321d87637b87eef2a7017995e3d34fc80162915796a0aa2f89d471003015d0352b71b5cb18917c9207edad0d2718b799427ae3fc61c16017079eb856f5df176b0497f81d62cf07261d7eb59c0da393632019747554ac26ad48b00f50e872214b6c53dcc45e0a981c1bb0b1ae6df57a51c220103aab41f5895d78ee18d39cd5d155acc91b4ada4bbd8a113d8ea0a3d4da88615c8cfd141563bc0eca9ef77682fa8ce36954f567f8a65976415318c4d45c65a7c9612834a9b92d762920be09171c9a82b7f1b36aeb6a8826c750fcb3613c517078b408fd5024184f3552d914d2d85d4cf22997d2a1f86ea55483fe56b4a1b45d433e2ce6e873648a6dcb397ad9a796a384472f150a22da4b3fa7e44abe121f8746a0e58ef4b740130968c33c79fdd001a0d0f3d0ee0b57276dd986112fefa402591edbbbcb79bb9030f685629de36363b1053e9b6f75acba12924e411396953705498157800a0b26e0bc9bda03e5619eb3a6cec14a017493230cbaf6c32cfa33b8d3c88f034ab7fab71f3cc3d45fe0898b512af67c126427312f53408636a8120590fb0096a63f5863fa0018d13ef19ffc9ec5590213cc72b411a5d04157e0bd9f07d31c2c57ca616cbf780694b65b45645af1ab11413672c91ef78ae442a1e0878c821bbb35362c36915e8bffe43912af00642e4b75b34c223c68a0980eab45fa6a88b7ae497fa123f188f3991abd5edf4355bd7761664d153b0b33d5e20fd8901f8f5069394bff08c10da80c125cbb25b956f7c5c3c62ccbfbc0e1a58dc87ec05adfe7cbf284132b6729f3013fca5c6907cd04cc2140a69ad5dfed14203b949b4d0730ddde61d1b137b7280eb76aecc0b131e7bad90d36cbee55b9e537ccd8526a9259dd34c41b385c696607554d64664d04c8869dbd67a1eae9caac0b054df1e31a17acb4a6e8b39ad9d58fba8951e6e36c2e7a08aca93f59e003d766caddae0917819f7922846d0effabf61289b74157b3da46adc00ee21de9515052d0ee4cacce2d0d298620117339fafc68b31fc261b99aab52f3f996aedfbdebe23df4e4eb33c0b1afa395c80a3a7e6d83dda874902200da4e924889513c67196622f4e04550a4337fb718623a9df41307cf027242b009a7b93ea1dbb199be41e6471485ea04f019870dd053e9e85d9aab73fa286e018349086210e67134fc247d81fcd782f32c4d1d3303fd75d7ce7922d1f5dcd620eafc971218768a6d405be4bc1a62f1d5c60d3b5abd2f1b2f68a14c12d0ec19ec91a07c02966dbebf130ca80b5321d058d144eb3231f34ab2e711afdb2cd29e7605e022050aea39f922a3df1beb1ee8e5b3d1f28d661f796998fe4d72a0b53f56c50929aa6deeb831990b5afb508e627c2f166c987df7202fb9d8ee33a546d7882ec25259b20cc4a5b1ca40eb379722344d8220618a6e33e1675841b881b7405a6c29e24db14dd768f2f0417105d6fcdd0336836d561eb52869a5733b13f1838a2d736a114bbbb96c4eeede8ad9e6b34cdc2cbd4730de4259c23494ae94ad8349ab0e0dce7c72bc489cbca54d480d80397611252556aabb4057f3a96f1bfe0c53c2b4471473b25b3a4d0356995f29d080a8bb409b840472c257fa0d64ec17038357e29a7472c576e4356866bdd23c36294308ba675f945095e609bac0f69da47e749c2e0888591a863603fa0afd650d195f1efa37c541b99e87e5e66a3108f78d0799014ff9a40e86bae4ad7d9591db550a63df34dcc1ad7744280207a200bfecf1cc25e64c72fcf5a5d7c412616f71439628d074931c5018cc37c148f403cf83eb92990f0461f1a28d46bec0210d387875524faef13f94a8977cf6a44e257ed869294fda9ecf50205d37dbf5224013931090ef3fc40348fbc48d5eda88377fc3ecdcf8c6ba8ed26dd55b0371a353bfcfced63e63d30e239316f6c043dac34d494b8d41889eea72f63dd8ed6ad2c6d239bf16a72188d308137505a3feb6845e69f338f351018c0f5cbfed45a964004edc499e00047e15041602e1a60997bd3b8e061cf0cbc64e67651482c6ec0fcf6442b716fea5636b452a7a35b9a15a369e7d66bd46b5a9359dafed41717b5144f608ab8e0b90f6dab01ef60190a94bf7ee811137844c4de4e867559ce065a7b661f42f8714b904b739d93cc4aed5f4e7ef4bdd93e51523fad6aa74e2dc7e79ff8da0ef5f16679e8bb824bd62ea164804d6048f64238b897e34b70dec1effed0e15543028feac1dc6b9cf113de9051d559ec743fe9d2e0201661048ec0c9a8f432260f3b22dd7a6577dfea08726c8175e09f4d362bb3e8497b33ea903ab7ae3cb2e282df16eacd722160787a7a03f9a3b066b6662c2180c5448f2cd09daf29479d34d9f728ba492455b93e1b4d0585766c50802b5b33f6365ba2cfd0d1cd28844961f8315dc5531345e5c775936e5b74a411a6f8bc64e4b61950727fac1de37905c5c1200deac5ad16c9c392a3a4b1e7d8b1a1168439037034fb73893427f2ead492b6eddf059493ca9d9a33095448516cc5103df67620991b327103129969fc609f7067f178feb8ed1fffa1959dd4deca4e7041203569a00e78a27ffad8789576c27344b23aa49b2f6264eff2f073f05da8780038aefbcd0fb59c66f707a092ef43c176c0a4c65b308f6befb15e80162ac724ceab0906113a948d1d59f9dc45486987606ea899ae7b5a09a68afcf6aefe1e93b7c35e73eeaa0cec4278da7fc48eb39e96ebf3c390b4d9d91694e2bb104cc4ab70177288dd56aa4634c5d31e7cdd354f145ae080c14530fd6121cc448921ba109965ba053bb50aaec870e9381c225e395fcf5ed4d9f423e9265fa8c694c5b8a17093fbee94f8d990225d07ef06ee6622e5baf3736edf229a8eb8f3584ecd0a6d5a5771e4f027dd573bc5a801cacf617affef20d310e6500a72bc611497a87d0df1251a1131a69bb59def891cc1462077e8a5479b32f6f36b2ed081d5ffb45ec7e356cafc6472b8b3ca79f7b180380fe1592ad5986dc7b553bbd3e312ba5811eddee5311e1565937bac196d71c4e06adcea3b6cefb196a537be18c1dfde67568414bac93796326d40f2f3c2836bc19ae966428796500b642d7a416f2f3a4f3e84541722d2a45444bb8a68ecda3ef4d9109db92798bdc7fefe47c49edbccb476fdbf91816a8f96e5098c6885d866eba7f94f1ff48fbc1ac99de520bb338465a980c1ff3fbd4ebea6e6aae867902223b0b160b5962ab18736dca501d929752e3032c8637243492dabbe67e483f869fdf2f80e337b8ef0115477e37dc952c6bdf65dece93f683ffeae239cde165812baabe2cb01be5c1b0f2d14b4ad8b6a89b022cb0584c5205ef74b87a0661622513acfaa3a7bbef08de832437a7306766f1463133f7907a3c75b9c399f757babfc9c9e0d2f8fa01949215acfa004d7491820c2a427a418229af6b1c6f060b83aaf0d49b71dde750f506a67c03e4fff05aa5364c31546afb28a8e43425cba75def9e3debefd68fe1989531bfd4057b27ecfb66d4a9e163200b549bc9c75ec0a25d7c83d71c03703bf2421d6cc2fbfd1c9d3c7861ea600a4688c31015cd17cb22d166d6dc43bb7726dd73d8f5e1d445514a59500fc18610cd3037966c63989b5e65e86233ed8e87207c8760ce99741bcf4edc3cc5939d66daab504e8b98e7c3c9b105997b3b35ddf05ee2956db6cd6387868e8108b67e7b122e1a06418e5bd501861c502a71995c6ec664c5c8c7a6f7103262bce57857b9d2deaac8ea74928a1b784fbaf915e51bf1aa145c9fc29152607309972a46bdc5187c7235f81ef79e2c1a96a4c0d0137fd5fd5f67d9afd469a69678a51f8b82b8a1c24af0e2d2108c98e53078b49d182bf35d6d6ec5dfccd353b1c725351887fb85c11216a7b6e9011199bdaffa04e3a7d8da414d6b48e1707f3882dc8a530b019c894c7f8b83f9c28e3eacf899ad954b586118ba8220d08c0eb157a55d5a9dee09018daacfb37782e166cd24f3717328846df00f05a2980ea2592f8c8d25d3d57f800cc541e78932fd51e80c08274b438d9b59b6570b22a187fa5e3d0ed23a3980062a493280fec0fd799d0eb635f7aa24e34cc47fc79f05f2b18230b46895fe79ddf8a0480382272e7a00d28258f0871a07d76b13f119e93858c68c9edbd9041aacb1310303725add15a2f409223d71db4b641d1dcd20891fd7c49dc530be1e4763f1ebdfa01777a5849781d875d3861c83942664db8de31fe1cbc400b050ef7d65299c3fd7500c4b2c0473adeb882c774d2848f5b61aedf8daf49e1af8d5084620c854b5b17c96b01c1d2faf468e8b3b696a9e80ecd06031bd453b1fac36a1647884a0e0aa3d4a29caf187553f26dd7e3bc8e17d79e0cae5b71bb7aefae8fe69acddcb32e483c3a1cbb5bbb5a917543f87acd84fbed03bd0146d156a9f662744a7d98e9f280411494c6f2f23c9c3b41a708ba3131191669dd949eb933618fd808015e46f8502906f234ee886e37bd4ee074511bb0839ec49cd5bdaa3917909245975cdd618c5d3ca0927d129b1a8f6a0441c99f31981700f86c258b89ae9de5a585554884da972d20c739c556408a5ae27918b616cd78156f2d4e2016f69dd2350272cc751d50368209b4f699c36953639f48f07e07410b1f3c83e5a1079d94a78417ee25a0263687404a1d6adf8d4dbcb05f1c85742508d7f969d88006cd9f96eb0ef7b8edc688e44547aa45acd9bcfbbf925ce6b91a2f63adb61c64fa74ac71bb8c4fd5d7bb54b2e67bbcc88db15c3c9dd01ac4bb0c589c8d166a082d73a34ea3521de7fe2989cfe610e55cc4642bacd846e3afb2d7f84494c9a007994e99d088abdc900e8a04f02379b348e261e3c9d199226e5e420c4b2e0c9c52ad1ca450601f9170e95c4ad60b2765d87959f32713dbd622e5a5015661dfc7b848d9f27ef7aee531eda0f312043d3cd20d713b198803c3ec3a124923378465ccf6328f65d738c425f62c8ee897679ec126fafcc520f49d912d0385a5be2e293c565bb1ec7e7669c14a2760cc32490c976f4c1028a17a2aadcf7c4963b6f85e5102d33df6fd3af847c8a2b39185c02fe5b2e40004df4b6799df82b4010f70da5897450faab3ae694e12e098ce8f46a969f179eec55704a0a8fb8db80b2a90dc69d915426952af328fc3a6affb34b4acf814f730ce0204a7aa9b6ff0133ef9617052055bd5799e47c9ca657dc60168799d220ea959b6385a2cb4d627fd91594bbfc250aea30341c8af9f9cb09e9f5457309e895975ed25fa4fb2653942c67506400f120017262116677cc4907368f97c3a34248b6a39b42d5ffa3b834e5ab8fc5b19e6fb68c769edb695a85a4689cf0a744d66affc2213e4e3e92632909acebd114d4bf2414cab1fe142ecf037193dae33cc4c48f883f528ebd2d6eb670318ad0037f68560a62c06c1fae666724ad47933ca8caa67f1fceb2e5ee38c5b5d88ed0aeb9f1aa4086af9e4dcd5cee55ea83e435edf93ee9b9626c814f3ebd947746aa46414fa11bb57b2db13d6f20f9d8a00511d6ac98fa50efd20b3e30fe8b9266af517f439a57b41f10d5bc634e20318354e79128a56de7789d83a44e4650ef6c4df742ed6336ee48961d5913290f419e49a607c2fcafe1bba77a240f88d2630be0824e2a5681191bda9e0c08f04f23febdfd5fabc95dd8f141d477ee7d9b120978f0adc7c2e2001018099a28fd09c394e90cc70b7a4802e710d0e65a556808b362240cb4123cad1d31c806afa092a710103ac63c5fa4c71515b74acefc294e492637b224643d036924aad7bd633835b09f785300c55a16f2586a06a29e8709eeb41ebbab8c802aca2620f57a3b2b742425da3833c88a04ca4f77ddc48f2cd8927ec9762af038575e4de81043b5511b6ec7d9ae1d619157071d5723b2e69734af249123f5c581050396b0d31c66eacaec19f40847cb3e8b900bd736d0af1795bbfbb6ad4f723e65e9112d6119810c3f2d427b3f95e6286ffb477c8c50150c975aa55139a63972c0d9a034642871a89c5d30352958f1cc33fab7db6751ffc231bd47534cdbb31587101fbefaaebef09abb64e12ee183439f56da192784f545affcc32586ea699de155b82e359c7609123161f0ba28903ad888ad8f2b35d56fc6489105079668d36334ce6fd0a4c95e5886307335ae62e1f39156f153341ba0856ce1e60874e4c1183e48521d91046c7e9d32ef336bc87b4c27cb062fc745970de95a76f9b7ae6ecc6375d2db914c975818b2c39cf73dd4ec122b25eb9a1ee3ae30b1d7f14ba0e42be092d2cee719eae7723cb36d03ad47bab979b35406e895edf31f3f6bcdc3a3ce12a65bae823226d254b92ba7d93f25d0011821df687cab3edab3c30d81e2c0cbe0a22f137e3dedfb12cf1b38081b96a076acd7a848fa07b7b00a415a4a6a8f2e7bd489a6a38712b75b8c8b05a565dce14bcebd6305746ef519ac4f65862c066d70d9b8284e99ce55550d877f618c4f7c2d5462d85ebbae7068393f81a7063b213a3ae25ae06ecb223b58a2d7a31d682241fc2d18dc87440e237fbcc731ebc90adf07838362764c1252dee878238e8d5578f31adb7f28c70c1085b99082456e5ddb87f7646c695c146585e030d62fcd9d542926d3d968219d60b958f19b3c365fb4d189107168235d581d8054efddc6889a02a219b87937b859fad1c7d9ffcf144fe953e9b0416f51ca7ca2c133fa72687ff0993baeb51c8bdf9a32cd236b3cc71e44f0b8ce27a222dc2d63940c1b252a897f2bc820b59c1b8d6fd9ee3bd5214330056218a906d73ffb436392f0eac311067bc42da7960c309988c3360807f2a6c81532791d6689b39cefeaa6a937eac07ffc42f29c043a5fd136b0bd2c1c8b43cdb01e2c6efb89546c2893f195139c81ea1f144a2eb703748de00dce6d7cef0e24225ec7bab9e5d411a181e8e9abf17b73f0e5ef1328d3842dba0026082dbd844dd63559c670df5afbdded5dd9956975c751235ae43bb0cb650126e713d98c9763ab37697c33c82c91625b82ece4897a0e43f9f75de1556a0133ee3163063bb5b229f2f027cd7b2d53b823d13cd7621a16de7999510ef7f06dbf5fba9c9f2fbfad6778dfa3d37436198f11a3cf141f5e4d91f9624c967a5ae366ad6caee06d0a2a087e74faa1b267d2c22df544da7273c442a4928863c14cffd7b315858391b46f03df9100dd7693bf0c760b1b78c69c00adfefd230691b039a5fbc972536a690043f974fc3fd23778e06e6c01feecfdfb38a9b8ad20da2d22cc984f0c2792f41bb909e3de9baf120d9c8d8d4f3f8233c7de81f5d92a138d0383ccd940cf845e886587ce43873d57ed64857a4068d74476ec54ec9c5e75f93f777d5e3fbdb0579577b370e866753e2340be243ddfe86d806acf770e9dec7eb25d9566a586e1a4f76b6b906f1bf5a5362849bfe9acb35d9b24c94f918da91fc0218684d4103894f4d5c51a1a467d1710cb5a60ee22b9f1f4d489cd581d04dbfec3c30cf52bf811051f74dcec5a4eddc749dacae7444bba9923b89eaed016fc8aa2384fe8dcad36b7e05a297e2f6fc77e9314a20337b32356c9fde3c4cfb72dd64bf71cbcfe26ef5651096503bc697e1b1b6dee2bf5da8c4562b8523145b837a8675aa8fb8f84c01a7e931fe949d396189a9eabb5d0a3b7f8faa351731d7b55f840835f366b0371c762ba0e66864fcca3e387e167138aa3a39a274e8f90c567a5ab590168caaa83ee7331a6c8d9fb08fb1190e542f48a74182c91d2c00d304557bfebbd343d0f6f981bab7e06600730d06dd5db2538937486b437d393c8a984fd4d51cfea2e5ef76b557dc7d510fbea554683142a7668763d86cfffcdfc733457684257df2307a23ffdb8290d98ed5b6fe568faede75c3dfad09e73ae806640c64f1c5c98a1fffcc9c83e2b6c7be1fbbbadf04bc2808e49b378fe9c1bf274ebde68bf184ea58b50b769dacb43357b5e263d31e71906f55c3cb0c233329b36344504c315d539deed9d37368754f474eef28d4ed9f6a48c51ba71ef9e8b5c5ce66171dc87e844bb7d57c57731831a9341345c2c64f1daf809a777f03c8ffa5eb2313cad727248117db54e9ed0e2f37b402e5a33dd81abf768df625cdb55cebd0d1e5f77a28218ea180eca5aa08ab1207f7c37ad1118354503ab548f3816305e47f1cc1712b23d66b280d82924c22b50e530b68f624a24b0c0045fd4a1790be068193bb8d055769bb4b508560a38513a4eae2c8a52090b21f907c08419ff5450546a0a40d473e210c91929ed7a06e616184dc7b0a08ce21e2ea8cfa8f14d1162d05c6c711086b167677056542ff0d18e7b3c7ea012c75b3946ae27762f957f6676aaa7184d3159887c41701cac2b6eb8fc1d2222ad4d2491b9c1142c31ea479508875cf1948dc20ee9a595802b8b76ae5b4ff4cf0be5f1a8f55a1130d3dddbe07ecb091da4db838a0926360c95302e78849c61b3e70bdb64517925567a0dd70e24880fbbbf389983e5c840a61da27f67fc8f39e1f42923e1a970ece8480222d60082e23c4d3219ecfbadc6b438bfde370a32a42500378bb8cd7d0b26a32491103184c7dda0183d4c963d38d6966700a3e678c47850d94a5ca59a916685a7854d5bb4e67b646e4d331b6602943d8d9abce70e40f6337449b4613bb76afcfd0e8b20204f3b9d5d9bf4f38c3ad2e0b6f0a823837daf0ba8ec2d2d8909c0a159aa7a9fe036a7396990c85c2cab1725a4f71a07f6f3f1c7e6b52c0980ae5e9f0e1aa644e4f19f3e48e0412e18c1e6254947e059670d6c483553fda8705eaa6a974f305dcb7f1ab4d81b95d2f9dd38f00e79e4b968174a14981429a23d0ea658593045f8eff65ea669688190327395b1463d52e9af0049fbb304b5ec1887b66c5d273433ebc0fefcf8543cbf0fbc8502851f12d3e13a4b2c84b9faafe1730a0b319168d58c905b89c888796600ecbcfe7002225cd7cfa31aff6311531b7e8aa9100afe321f5ee4a582fa5847b6d4ccb46d0523a2ff95e39780c2ef8436b77dc981ea00f4bb51ab85463b5a79c79901b11485a2301b73a3a79413e140d5247d2524b223bbf5acb30053569ec7814015396937be41a91dca5e5c338457f11709455a8513a3c189d2a1bad33e82875bd6fdc3333524440da76fc4566eaabeacb8ef6094ec7df9f8007dbda6431ecfdf42c1c285f8ceecc856a38b535b5a25699fbe27dccdc7de530177de5980c78969471165fbda3f424ee6b371fd073bceb342a4b47d880b02f7372715aba1e69c07427c29d01bb36ea9203646b0145c81b1410f8b7abf0980e64d53e8b40b1dc302f392189d9fec0e9239e8d0ae1f58bc3e2c0536dc7cc4f4cbe727fcee69c358710d6df703b6f07fcf5cc9a6345fd599b06c4a79e25f0d7cbf42070a49185380638c7d697b427081c6baad3e455b1e81a8cb72e55bf4415b8454d6f523e8dbc71d84a1f883149f0bc72f139f981560a759f92286f759815ba6139561de794e24334f62b48f7bd97994b53192deeb104ece00a13efcee3848f92c830652cbced0edd761fc58da859cafb8692cbc37b65ac85b16f810f5c01ab930d2883972feaab6941f6997a1437d1f0cb7f49d7d1d05ac04f4b448812281b26fca050a7ad1125cc3825ecd9f9b51b37f5a07070de65772683e9cd1e2b877f62d10a92cd31150136a7e1a884ae8e6e8bdee590d9ae88c532e240b6358dbe9680ba66004cca2ea6e7822be161fb9b08e716d51e9243f3781322c6cd1a9c0af19d04c1d4aaa81188a6ca6d1229365df9c1b8b839a2777c5dc936469418f2bc375cad3b5c873ac5b9af6b4c6f2ba2eb57de95b8c6cdcaa20b524e3c2b2f665b4511e9f4273dead3053163a1686dc697e6273021e950e3637be7d37f2ff0f9ddac8e5b51c0b669566d85b7b2ae974f742390eee361fa4b3aad60acaf1d22480f0189010c2c5a4dacb97cc5e2b7c78b5b29b0e0ec54f0cfb76dd866b3c6086892c5afbd88b51b2f56b4616582f732ff52d77e631f1f511556f434a3e8d1cafe04aa6714fd2595ce663c670276d6095db17fcff23579784ed98b17e51f3515f2a99bbe4f2410d3f2194bd070df69a24eef959241a16f2ce8004b222c13117d4e89ea72baf9b22aef8cb8ea7da608e7d99165cfd9ca1c2368f3d7972eb80b55d8fdd4a45cbe9fe6ef52947169ced43915f280a997084e8c87fa7a6fa71459cf954165d79ce1427770084c9ca2620c79965956d382291502008a9d44d7b83996be9056ae83f807aae01f9f0be22b046bc5eb54fd7793113e2b28bb8c2538a9e19c18ad20742666e2b7fbbedfb3b67c15bb6c3f32bc8d11198a877370b2e5f4f7b8fac1ef3810bc88cc2953936a739000171516952f83647c144815792e1e5746f310b3e8ecd68308b58ef666e34852f6d80d45d951618ff0e7a96e253c683ec36626d4df82df14cfa02dd75e1447449d8b2d4a09badecac1864e6a3bfda58e86c300b3b623b60fc2e8548b0c524bf03ebd699d5d368182ad679319c6a839e1ef3e98664867fc5e5e6377e3e2a885892108b760434159fd3633fdab203a04f950f0dfe1ff8f701073ad777432fe1165bbc5481de934946d733991a1f4a524aa6a52919431999b1caa0d3cde9d29075dcfb35f88b257d1d17c5a9b5b473178c700ecfcb382c2d310b33f1286dbeb4ebde62e4bc78d9b5df9108a3bf66c53bd8fb47bf85f52780c3fbf0af5cf5188af3ff118f23524605429b792a37a0d03b51b047dd1438db4085bdfd3994b8e95276260b2ee7bc4e80c0735ef8accaa0f95432112858ed017b2984e06efb9b07443cef765529e3c657cc0c2d752be1574a170dd6bb431afde12c7d96fcfbed6807f92f6f19eae00d37b4acca12de96633c62160d02bafdc16435abf3d6a2d6949b2c12c9ea84d92c691268d24739b08fcac72e3d46dcb0e728248c32d5b87676e3e1cb3c9695edeec455fcda296f0cf8170c4254ec408f429bd064c197a660e0b3512cfe53b4db08b4c0ec2cfb8b5a782bd5378c5b566f67ff1a13ccbef165f58e266fd545edfeced691547b634d9157cecafa39d3ece8ba0cb74107597147efd0f8b411207e39bef3e3feeb5547d96ac1f84632c9bb1cc8d38c84da351d246d1338b4a6943a8e5bff5b592779693109811d7df46a72855430786fc143a43648625064cb1bc96088b120394af7a76c1bf97d10d5c08eb283cdd2ae3fa9ed8571e018f8005df34468d5bf6d4cfe6cdbee26178512522b9a98a0b48ba36ed465428396495afd468cff8653280854413fe6e8c25dc6e07e2b52b07d798c2c3c4cad87aef51524924212a0219c0dc1d71f31d64ec74951330869205c012ffa28b5ade4d8df5628780ad150a6c05ebfbc90232ff2fcfceb6888282e624babc601f21c058a47bcc4b591d7aab15f803eae7b892408a92968151ec07fdae0c2e9df7e1268ab6ee452f726286c7276fb00e7b3832a50cd576dd6934bf40b853c9f89e2237089f461c66be42e533fe7cd8c7f5f5138bbb9f5a24f22dc1dc7aac7659701fefe572bbb319f66b98dd118db1ef2df4f6b10cddea43adddeff9e8d4a8ab0a9de5f38633b3f20d19b43284e26c056e87e06ee3643d4b94b7c88d9f5f04fed1b3236044c9514316f6e149b4630d756007deb37ad45cea1368fa5238dc7f37f6c5f0bc3844b43e8bd5702104acaeb85fe284a599ac85130ed2494c5af1739f0028060cff06b1468fd24dd6b3a80d140ce983757f032604acf3058d57f77d8722b1ebf84b9ab10881ef5736f8221d33745ce051158a3fb2a41e00a9dbd708cbdbf7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
