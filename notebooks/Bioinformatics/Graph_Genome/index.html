<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0841c5dfc96efcfd5f20aa7e6557a04efac009e2b639142e38fc7806b79de921d89e770fde1874ba81fef1990315722d6b57e564c17f168f512d8fd100070de5aa005d7104861a03a248b9b74aefc030eb6aa3b486a4a1364779a2c8bd9f5574097ea148e86515193abedbd25ca3b8738d3d0f500120f4283a22aa25d3b03b62bc42a3ba860bc9f4b47e18b8d4584a47195091c77b846cb19d412dee2909449fd5bfff14cba1be7461cfc7c0a8d7392598fadcbd6894225e1becf5d260a9900c80c96e6996a5aaac4a62dcb6e764ccf2042b3977abf2066baaac77e540215759dbac8f5ccb5e32c6ffc50fe652e89097789aa74a463493bf967f0a66edb027e583bb454eb813a21f10dc357501c2308bde4720ecfe56e92998e7573bd2bb9e47eddaab3e21402c4cece8144637e9eec23f499db21067fbecdb08403fe70343103a6eaf73208826936cb826b178880c64624aedeb2adb22e3e27b06a130aee071dd85119fe3c2b5045380e098bf1bd29b8df0c6d21a52889e7240d59ab5fdaa57910850eec8274c086a804e0cecc1892aae639c237323e463e9ac7d9214b923016e6037e29dd5501cf654f655ac01544b00400509c02e859a1d08d02b4eca52d7f0fe9ce43bd2b53b86b30b7deab65edbf73febb50100c9ad9267a720394c69d6583620b995af0f7f0f331403a6e669e1b22f07416cdd1f81edb59c286416d1ad05b6d5ecbdee22d701718f2dc512650c520b4b5971847abbb9a96cc0c84d2ee1f678faf83957afce12fee5608a70d6955851c903ac6e30f6e3e92ebc5842f569b75a2b8b9d04ad5eb440499510f8ce7efe497f18b246a06ef7020b1cfef3136c5dae7f57e6dcf6b216b9aa2137ae6a9c696440250094a960455e1f76d8c42c4d013258878d3f237d6a55af2f11640d1e5e9d8d7f089377012a2d9b79c0fcab5314a84094943623654bb794fc981284839777323c7dedeb673c457733ed027a308406afe84985c447a3f71e49a7a1f4ee3731150e026b27a3100ba016a9c8733f4fb121b648c4d8b8a51687f9514158398097931c396b5b86714ffd2eaebec1cfcc2de705a70245a5d1b2f70984dec988312dccd29dbc8f587e308e4899ee90a666150a9def6223517939fe2d0238f0c9d7b87b6526be873283ba17f7270cdad036e42cd4951321287966539f8e0527ea6157120ede1105bdf2df17428d5c8e2a84f4ce7916841956c44aff97050065dbb2d24b633430720cdbb8204d86e7e5854abffdc94a82d0503d5639ebfa35ffa95b3954160ace4449b2ff4305461c62f2f854102f240996178cd91d738694b12729c56d467cf9cf26027e9dd6ead73fbc50f4d5f856d61cd4af9307e1a5b0a97f7d79e4fcee14bc637a0f1be3106fa1e96d3e6916dd72c87343400696225f5a80146b464c9de5c50a982ab2d21d5c898bddc589747154cc32ebb69637f8d57f933aca886be9e5fde09b1fc1abbe54e239506c0fbac129aca4cb8bfe52353c10a77cbd9e97135051009efce31ceb937221700a97e0f813c12bf764fae7d65b8efc7b88d150a96de0e3c6ba6cf372e1e0ca8a8af843a51914dcc7c2755b760a2fff5cb3e1621f96ec33db0f7e1329a74015b15800ed0d7251371031f7386764782f47686890a04dcc873b74c82642c21bce0f578a1061a234b779da50cab919fa0cab7223617228d56a41d6d283f293c0e343147fc61ff5569b16fcb6074a2f34c85144a34133caaef54eb75ca89c2a4a2bbf68499ed6b6cdaee97109f80f7f295782763614a98aeffd4cb0da3665777531b5616921fdf30fb86790618bb6b32f3c68a14877284e983c87920dcc3c3fffd3ef1382b443f958a108eade03bf7946c078a9237d02834c5834939659f1a2fc605958e493e68324415e4f4309c253a078654811f3cf47036a29cd579004dcfd627a3875632f1f9ef0015ecf24e8702294dcad627975eff45a8935b38449ad9d4e2d6dba0347901fa3f338ee03c97d5262d9061b1ed73bfcd487432c998f0af1b53eede52b44ec8a673afb33e19c24dbabaee96567cce14d26e4ca3124ac62137e16f34979399fea33b4b400901aee389abe84614231aac06a7d732802f194ab67a7a3d3395114bc1b61df7a7dd6154915a7de113f9c821d868225b7b50a29db4ad239c472e2dfdb3eae6754d391291468a10ae1c10cfb8e6b5c28aaa31a431d763ee25ac7be19d839e0147009754eb9e3108724efaa3ebd0f7d7551c294acff93186e1ea3c853c1c78c95b99013c4c12d890d92ed8fffc53295862ea2f8f8aba250a7d21efbb4c099fa9640622f2d80609954293ee21cb5b34f76b7c9e11626bb62c7a72ce43fe1eba1cb218b69588a7258fd0686ecf193c7fa79aedebb6831ada28ebea0e82b422feb49abc4bfe0b74533169fa7b538a659893371c49b57cd079f051ef4f40980c642a09d0354bd0489811be263da9990dab5a437373771eed7daf5f3600b66cf964d1142130fcd3db6c2dde9c9e7156fc466a51bcc0156269db3ebd1f14dbe3da51cef6c04e87b508c35288fd3c310f68eec0b1b5317225b4f5a7a6db59389830468ce6ffea18120eee4633ba9277c169437c82f83f087ad0d564b4f36360cf09fcadf6d4298ace2cfee05d9d16919edeef994191c327b752bcfda57b3012cb3f9d582cbdd58092498fa2a074dda9a007f4e7f9ccf67c75c6ae85f2668bc0a01aae9d80a878b88d73553e4c5e722b2692d20e317418f6c44f5fd13cb84975fa527a632e00807c9785969687aed2bfb3489b421c0a1c1b75b3c8009a63748f58fa97c9b20a391e0b1dcb32fc7bf00903da5f37e9fcbf10d39a724ba0697ae20c2c0ca0422d389ed716e66162a90e201aaee2c899876d86c1ee3917567cc74c89f5296f4873f2d1111c2b3df59247c30a52fac14ea23f7cf8fc08b0f0fe8a9f3c7beacebc217578342eaffd726994bbd3a5e55330326a5ed38f9f74c9ae039926ce25eb6ee73b1064d370be3df08cac9b233981f3409a2ccde984555d65ec3013f742f070f6193225da2225b14eb28eb97e48e9e7c52a60ba69114551f164c72155ec14fb1c7272741f77b5ca9f0a4bcc720a280ef9b45d9d380703d3de03476082acc6e9c78245a90b264f7b094ea0547decab796dbffdd331dbf7ca13c5bc12d55146b234522a729440165b0b46f74597f5212c5968d8060d6f5ae50cf6df356c2462a54b8d018b04bb19f5a14e4cf7d6cda7e2dac35787a44d8e9b1843f1c7fc00351c68195285d6da388f13f0117cc942c0ceadcbe68ab992e19b996259f12284142ec75b9216da787a48b77627dcb2dd43e2704884885b535b323fa2f095aa35884677c90c4800d7796660f7d51c353e2b0c709bd1a8f2cf7d978f4bc49b06b12fa5102cbc51841106ba400e2942a51a4136398470c668153c43ce7a0e43f42ae3acbc75abb2ea31199cbe3fcda312845356782f2b681d13bced7a7ac044247e56a0b5311c1aa263ef335e2a3f24507fca921af4f62649e56fde550408e9fa89e463bb93cb68a9f372d9424b27732b693a113c90ab1c3e23d0df84af29607aa34882fc40d83760acd12b39895ef6cbf6d62505c894164d716452a3c79f5bfb92305ba13c978721e86481f588aca565e56093499a31ad9f715296ef34eea415c2480007118824386d89fd70f93c49fb12470e261aa20f15e6cdc3ba439c2c16a79890e130999e256d88f77238d1d91257defcd5688315aea31e0a3925b3d980ca981665ccac54155679f6f506db26ed53ba33556ac584f2c56f50242b8f6f65821c85f6acb2070432c35127f6d07ace745084b910962521fe55b9a4c350853ff79bd9e4aa0b909731093513efbdbd9b1f0c9ee94f57152fdbf34f29046adb170dc0292e632e9f1dbe4c743bc6858eb4e486d22abed9c14ff15ee523b9699e2940d059816aa387ae6947ea7842ff7acf610951209522f718c20c4049c4625762cb5712792690b63ff8e29c66fa7869feaf193bba666214c7d332a134eaa7d910c391dc7d1e2d617b857fd7eaa04e09eab2b847225385c0821352879cd9ed9cdaf09617536da890fad521a29ffca521feb36c74ee9c412c7a320f68c8bb4816ac7150dd8859285b9851e065c2f1954e6e1cc743086259140b16abedf99bd770aa18805684a3f38f0a59654a224b524e6c122fb008a3f4279dbf99590ce489124eae8b4cad8516b99738f4c71ed32bab8e624f34565ac3e6bb24c9ec22046cd48af4c8d90e5c6a62a41b890a0a90c13e7caeec7a279d20ed6b110bad8a958ade55da3ac820573200cdeca8368f6c559ef43e3577fde02c90af47b65fce3107e1ff03ca717ab3b716a94a6cb475b4c1c287c4a5f6d0cb02c9593c9ca884bd9e14f556a744855d62f6db26e09cdb3600755b375a3d68e6a68aa4fba3123499930e7721b14c62d16cc092c8af518bbf1d83bab7a984f3be46a19bead2b82a27717ad8cc6688b0a0848e23574504f50168f6d513415038f64a6013561db17ab7b6dc67dc8c8bc8e88c244361df952a40b44d9a4c1abbe9c584665cbf3a8f690c8ce74e07a58c3301f0b5eab95650766180d8e1ba9ae0098cf34849e972ab94ca530889ee80e2f187984963e0b38258f11fe4daffd14c19f208fea032cca6f5b53e0d3ddf2b577c687c7bd922903ed86ef5cc5ad57cf55bec2fe082fc50d8c2e00e279fecfbc0f1a0da5aefc3e5ffa97bac77b0edf824c12cc2d8b5216c49b081bb0fc296481fa6a53d78b8dce9a98348c2ce45db223208f4014bebeb6f24e7a67d8a639ab708eb8fc40573794487bcfa2e42699d1b3ab82b6867bb93138bf480b761052e98e1f43ac09670a946ff7e99710d86a0752c0f20a111e03a29942075677d7974bf4bf37beba266913d380fb8697a66884eed563b3d8952afcadd5dd99ac852110d98b74e3d0d1c95dc67068711d61d04d0f14ed45f6473d9a911362abb24ab2c490710fe583201cd952af33b28aa81055158f8e0b82921283b2e75f23849bd255ed0c05edc42d8ce152708e00bc25ab63f14a21126ce8af49ccc52e347743c67ef7ded6364b8b86f78e630d8801a203823057185523e6a110aac34b8748e4d9ea4f9bda39db6bce06917d501bfa27a8cd4c4701d39d2577b57b375ac89391e00f437b48eea683ed9ad0544395aa6b3bf9d5be021886d730d8b94fe30a3f2e51129310a3a6a7aa340c0c65bdbba1126764e1b444c5564f7912e234f2c8aab47b9a03caea0d2026d699c2294b129b43e5e89dd7336acf54cef6853caf415ff23226118c3a63937b96eb832bb6ba3054d883956d6b607be43f86d23afddbb04c2cfa7bfa6c88d18ece8ab2eafc730455b281fe13719a2420c08d7000b14bcd9f71d3c291795493acef6f4d8a8c61c5548dbc4199b1296a97cda4e959f3aed420818125fc1f09c8515ff7295b8e7b2dcb92d0639032efbf5ff4efe5118e54bd3bf7c39cf06d1bdd0b6da30d58d0218f663d2b5c15521769e21227dbf33b148eee1c6d18a3a3155f75555fb10e93d90a0c6186467a405adb3b2b3d45b3a0e69657173904d6263c27ea4a7f7cf7b07c4c32c51eb0a9944c9b62bf5154a03a409c35ac6c9a7f82e13ae8c04318537c1eb8929a61c2043829342d3a87eadb3d5b068b67b73aeb0d536e7c0891162d7a4fbd47ea89e8e25d7a2328f62eb2f21f8c4a23cbeb57fe82fe18e7bcf8950c8c8f3d40f11e4867031a8d927cba6a75d38330969ffa1baa7017c104a184c95178cd39cf587bdc772d5b04a7edf48c58155c1dfa2d19df0d5b7384716548f6abad0b6ec57e8335983919c9ce493a5ed190881c700e57852082bfad2d0d1ba5a1a4fa3d4c7043e6f3e9e7f16b1610133205742526b460908750b871d562b9ab45d4dfcbc6f615d1386c8d1a7bd26c0cfe4d70fcd25412356382a990590bdb9137d50ba07a5340910d057909cee2dca0c5d991531ae0b6629e9808bc342984fed4485886f75e2e14048da9184f0b18c16d2283ff151182be3228268978d9977b92e4abd22d77ccff0f46fa1837200a15203cde5d17aa521a424cdcb356bda9b3281c3b6a11ae9168b8d836a8efdea15ce3143f8125ef598b01fcc760ad448d2d5f8420b8cf76cabf9444756a5a2252ddfbd5386682e64a45039df66389cd95a8d8eeaf5fe0159249c968785da0006c6d305c9ecda68b3df3168561807e2317cb80bb11b523fb19a93c7861dad9dc7b6bcc89cd82eb889fdc2e0be12e73643f28cb51b0622d961ab31667272054e1610979b75539c6168ee957de97028cdb4ca5f98d50d11e9652f8e93fa079d05942882787f09f2170ec44e862ff053c255e395e9d9f5ae1e8cdbd735d91a2b636bbf6283ed1a3f0074d9f021ac70f0d050068059512f1d20ed696b2eb6ba4d982f497e019c1dcbb81ea12dd3db4c3273500b9057c30986c0bf153c7eaa35adc326fa1f825287aea76b90752ec6271260a254c2f691f7a91b2c136b65952dc37ac543a01dd4bd958e0e662b2f175aa4676702d1fd30add37bfa128443a757eec546687fbe159262da5ab9673fa7882a3b839ef33097f53f3fba41806fded4de6984c5d5a83aa8f05ae4c325280f8489906959a0a4b02eb8fdc2543c769f602be399bf572e697c4934c56ffc1add6b02eca198fca94dfa22b0a9bd593c7aec7ab70e35f92e43991b9be2598ae017db28ee187d067c9202c6cd436fd582b2b7cfb6cf04ab4e1d9daadde86f83d75eb999f7c3f222ba9e3bee797f7b21826908f337b448265553fb65c26f9dd26bfc6f2148596d50ebe3faa9b77a2a8605a37461d193919fbd4b79db83b2e40aade0f3152b42fd24b4ab1d28c78a5b64dbd61c6c954f1d69f7559ae51cb47c302d2c864c9e5725a5010ce27b5823d09e860bf4fec8eaecc9e6aacb56d78349b006fa6442706240526a30db217ee20661f198ff142c6c9e7a98f2338607553fb86b8e86307ad6bf7d58d796e7d4869ee534b56006dc90fef7c7f3e8ac665c4cc675e4532e8dc49b10273f1ef193438abfe251c2c8b1c84c45203f3b7008eaf030fd98f3ab0c0af9b8532847883e257402a537b17d7f635dde4bd5727832eb3d072a5b8e5ba2566d42455dea59f575e68b71e87d39247cb7ded9e9d8178a0c45de748189b4e8753d01b67a72671d1a02ca7d31b8ab4d282917283e16a46f4726bce98bd7eecd698f0b7ca33f0867563f7dab6f88f2bb6c4cc934d6c2da516e8357969e81138ace9b78cd09853bc25edc3288cd8901a8a1894f4fc952513f34316ccf4bd0b242b8dc9221228682a2952036c48ad91999faf859a8df55bca04d4a40cad3141f9074a9bfb96c959bca3716af468a4b6a4a16c2710146e7404a186ab1e6841b559d94f07fa787782e72824d6da12bfb2a6102a4584ff314cd7b236183cc4f0f45fd3df65bd838b27c6959e0e275289af5d3e7d8b447b5c61f5763debd23d9b8d3afce7fad45cc8a4ef2499c61976dfb64860b95f3c9301063c1930591708d12e3815cc1e9826bc4569a83afc39fb5541e5e95ee6a5767f9211f58811c83725e2e4b11ea04303e93686cbe3e9c1296c5fd57936fa25ad0dbe129173e4b27b6c1d1a65ea624420889dd5c39a7f5bec6d3a9c0966f8910c70286dc90d0f50e59f525e6b9405bd89ddb9cfd0e879cfc28d789f653161e36cb8c9bac0a9d84527e2319d9f3f7d06a2c6400744066677d41e3c79eda7d6796dda0c3673af7ef71109984b1b91ef4013368b12eb80ef34914675804ffc5887bb0d60657aac52a2061e53f511b6e7b6547f980f9aee1f384abd703671aa66fcfff7d96eaf4b66081b7ea23be0517ea6f9e2fbe77bfbef4a019edba7ea087bd9cdaa1da0a04aa8b3203c4d1c116973097a01224cac9da5d60aae63a6fb8e5849bd4e4814d1cd54da09b904bbf1823d4895f53fb0f10a4fca212a6ef91fce19e157577cc249f74780086d6c5cfbe5178dc994fa1c9e2f5a1e57f61f65af05f892a8fd3a9fb602970568b518cfd9d181350a1dc3b193354072db91ed40bc74b7e54b8f249d40af1cbeb2487ce83a3f181b3272c5d4572a0d0eb511baa4a91d34725557ef789b1d497a6235bb9842df12330c3cb0d6bdf2c998b6caf139b00129e8d8587b9b405a6070367f223b2609c6868819ee60de119340584fbe7de902d1bf0e673850c15c769c27291542f170dc6cb095fefba0dcef7a57c68881132db6e7e37d0858812b34ca5fafebfa56ca8bc4f8ef0f091c5f051f7258c655973fcb83acb4c220bee745999a01598985a59e1847ce2cc2e0e37d5a2e30fb711da4b0c6850a6eec62734922324ffe3b387c4eeb98d8820ddd921f12f21d5e9486be087680a82db3b0e657a745a712a9ecc7559196dfd92d672cc553dfddae2462aa85452bcebaac4a4abe01f9fb7c03962fe4e4874948be923f64b7064cd46dd8b750b994f9669dc1ab0780f308fe6543dcac2823cdd216084be5339e7c8c3cb7136af6d7e5b0a519d0b61df25434a2ee0b984f957b9ca1a385ad30aab7047c66e212be67eca9c6d57071458513a3c07b253f4b1925063312c586ef10474027c8a8f1ba0ab19cbe2a654bd4b940edf1aef821982636c04bfd495d38d777ba95862a22a2f8c7489df9b9e5a5094f7d788c3a727b45b7755b615c3c6e52a552ab5942962b006f068947de15daa62edbcb4541fd2589eaf4f4384a0e4846ce28218175129c926273bb25596e50951b51740b4f9d5369f3e1ff30d667b24d641a3082cebeb8df641b34f041da6a472ac94a60fd39f649a963713d37ad26d6635158e0908978bb04b9d5c9416410fa0bf71f829afab63cd2a30278e88593f3e69909389416a72c2deb866e0a36dee01ddb00b7627d360853d4ae1a919330d5154e121e325fdc73e38320c5a257ac58f21fa3bbb8147d20eae27598ce58d5779a1a170984123b83685e998ce151848fab09870c0327bb8737d1946122a983c06ed808626888c0ef06dfb130a2bc9e529741bb4b53893393e5e91eb1f4e76b4ed2d7cc955a536971fcab479b01d0d301764f9e50b1aa8b96bfc004b6d5634a03e4a288cda92a3a0608337e248615145ffae35c21091d62c8a97e8cec1badacd8ba8da288051d1227e261c67ba518ee3c63f572f89fb081c85bdc6c8a25492f95b651b4a7dbfbc0c215548cc32bc87ac2c55b218e1f0eee7d1b0a79b3d60179873ec4f99705932d7503952a3fcb6335bbeca3fc919058dca290b0583f6a3eb92b29a8f0418b4137143d1c64ba05c66cd5821abae9baa7bd3dd0207f56838879c285b2abb74b58dc25e12019d2223e256bf0bf153564031e7db95e04ba7f25ac4aaa103f3988ce48edb987d66298507bcce224a6dbedd5c44f3bff7d5826b9d99d4a6917ac68a1e480ff64868e326cddea180413305b30a1761a92afe72b4f09b3518b319b30e48b0e330abba2f3b428f77be331b1ee32ed6f85812ee5cd973bccd791c5b824a519a9a507208b55aedd9d0e688a15c9badb0f236b381f0b5c13b1ccd90c326fdace856cf92c6ce7f885e0d511b2de36efbe3e5750ef087c15dee5c9b9da16adeabf363454760bd5a8e528e46cf5a657f5fa0b2c3f5c7b3ee18a90e1a9701af0925e32e961c8fdab39d62784dc521cb8cb5eb0b5d78a3c1ae1d023d5c5fc355bb26bb544e85ec3d1226f7500102fe67fe9a3c09044ddcbaf1b18d954d75f78e62d2a5cc9b66df9a7d2c4b725343311d46d6c824d45cf1120d8538ecb2c5c8465281aab319faa97759503f4e1b831a33dce70f48a9f6313da0b7e2da0dbd352d73c8f16782e2257470b63faa574e8b82ec59730f41a0d5e85a9f69a6e17f68a97d81700957a68c75b0e2080318e15d35aed6fc52a0664231ccc7d1398822a7e316408bd34410a0c22a19ab4d92ee14d20cd53ed8ab4eecc8a694dbacb03182441f23885812ff5104da6efb3f25716c652f9cedc51febdf46e62c0a5f8ba9f6894015a78bf9056f6ea31dc62aab4288d5fa7814dd04ac4b2cbaa97cba43d8c227043eb1bf31b1b46843ae0ae75d0f55f4c070bf5cf8c62cd56334aa4b2f8c88ba0f010b94f75c22c9196c61f08d923261fcf475cebb4863108b1150b29c463bfb09089093db876c07ee329def8984010cf73eab5a1f78d4295f1aa721433e7c3c62e083536874cbb997542df257dd7f51f3f20fdeb4cd46d72d6a81bcd179080b0f8d8d2b80c7656d2697cf7e525fcd5b0bbfb3d7baa9c5d055351beaa71270611409abb6dea11644d547f928e644b40613834cc94544418adef9039c08ce9d3e805d2bbb4709544568da0b0be67bd353eb3df5bc4e271765adb34ff3d0923780ba9e5c0216ea4012189b1478dc59504a68746022d97493007d4a723c36f69656e4652904b2b9854e784709e27a6a3bfae2e00211a8a8a9714bacd20f939ef18f24ff454275c5caf58b9a620f0760cd095f686d6596e338bcf37580f9b0b4924419470d636b96fca2fc78696b86c2ff35b864f6b3b51539ac0c4fdf95d46d8c84fc6a62f6c1f0b829380c923856b5e84ff84e8426d828aeb519d1caef6cc0f949898b517a741451f801d8f306105955db07483e068f37fbf001a927222bf67b19f91006e5c6f3d5158690baead872e642e4a3e3e77e42033c3601b5eb918a560b068a9c18019fc0370c1784e4da25a19179f87bb97d5b053dec1b1b7314e5e726c1233c83b0b363ca70598a924a28db1114b954b3def91b51706046df7ffaeb70506b7d013cf1712e81c2805a7c370e5a1f2373a047d3ae58097fe277cba284142301df23b33a9c3c86fa2cc4fbdfbc1db9c864bd88cb010bc7b60dbba9c6c90a9e8d284e54751124b99b6404c970c88cdd2b6b311d1b32c3d7f543c3c8506638d2e306281076922a090f394e88a4e5eb27eceba0b39522ab79b372e863b76e882d9a754208f3afcb442dc5459b53834dc120230b7031364a24bea9f4a8e77209abc6c2782457db139bdcfbd4d13325a21ec650657a88b195c43dfc1813aa977187dd62ece1968f3094e46fc2040f43cca5400a70c4cb5bfb40e249317ebba4ffbe34a6712024a9d54fbac9b5bd1f8ad7b3b5400c92c51e048e35cf3fe1381b9e907157294155eef2bbc65259dc6a05c171ecf9d25ada97a9ac0f1c65f6d88914ff03a4acb38ab36c53b10f5b471cd0f18441f59444ccef813399fa9e4dbeafa8faa1be64a38415b634407509f654f004e6068314d21529330dea3e34b0939228fdb88e5ee18f43242f36294769d540ee5a21b78c7e031a8200810345f12c66e70b19a7ee4b66804ac66ab27e3591619392a3358d4744b40098738a25fcc62a1cc217f3fc6f6c8c045f5ee71872d983abdef3332b9efb7065a81f278184022e2e6d3d20856e0c74237bd9a7e50b932050f6fead9f1bb4717b0b0bf1daeec4e43e4e47493fcd07a1850e2c7ab203757762450cbe01730fae06c5991f720c86d857bab93f429a08b81d47cc1a2c31e2da990d6f9ddd910221950aa9c7bf20fd53886c1e0b0e5dfb264bf35c4b298d03bc088f78a39ed3eb3c4f71821143ac7be6c40be51bab25769a88c0ce0bddb694540e30ce6ac6f1dccad454aa62a7dbcf9a4c497975d14cbc9a1dd66cc2d8916b1a1bd2912d9769b7f0316542ac285dd41350b2c0c079448ee690aacc7636711f031679763edfc41fe7b2bb5b852aef0068598d3d695cb08baf7644a94326b049acb385e62a2618ee1916f86fc529c131399ef122653fd8ba8fd8f5d466aae65a9b0c07a4398ad0976ab29988d11e034c04df248f59d724dfd56ed1e766909dd36c8d944819277ba638c0a5ded8e46f0a2684a78d4b7cfa185c4df63a5bb12c504c0a97222e0663b0a1d92ed0e2bdc643c0ea918497b72d8d5da2da4da0d21c4b34bb91acdbccd293d96a23950532f92f04db61c2afa0b4b3755c463913e75f8aa3eb407b26d0932e847a245c78a048801d171e194d9a3da6a63d2cad2cd25deac5a7bc282ccca78c0e5068c38eb4576af65b9bdd5f9874521ed46eac603b31f5d7ba22e174f9a1b7cc0dda0f817e2b2d44c16a11cd94a1cfea7e8381e2900b0646f3ccc0a3015e2bb2c86d4b11392b62018dd0a09ba2ce755f4558e3d570f9ca13fd9d1d44f88d5d375e58fdf6496ad0571aa48fa1c8c1e0f585707260fe7c830e738b82c10880cd43c7c3ae39d5ba09753e5ff9ae4f86c65011d1e47483442032c54e348219cd957876701dd0daf7f35e9203b4afeef250ae0ec27f6072372c984e602f97c5002b613dc8f0815cb8d6fadb809e0bed698ddeac2b6ca47c1a56035993ab7e4224bd612fbd1e963876605d53953ff2594a8973a43395925b8bed5ed02539e31c29ed4f064ddf2ad7db8ddd165d1b251f2859ba8916bd69d40211297dc6629af79b4db1e03211d8abf5ac075af0033c3ef703952c5b8863c597387f7e4878d087c909256960ae3efba37980b8e4c5223a8c8a062bb48993f62431c7c191f38e56ba0876903f674fd5345832b248fcc9240c91604905d59c8278183376da5773c8cec2128e34ddf70a673cbadff731b60f9db2793f857df72997b4b31ea8b1bb456f414ddfde93e55a9036e4c5cd6dce9757b9fc9e607372657489101e71c559b85a6b730752755e1e1cd5364efc709d0be3581e56760eeabc4948642d62ffd81b87a3a0c15f2ebe00310cf2bb578e8a809335b99ff7ecda425bff196363e76d06346426b27e2008b56ed93278aa3b013b7cf7134032eb643eae26576d035dbbba86ef02cf062a6dd68c5c79641491f9a6dd46139d16dcd26fdb47a187d875d774f758fd924888e90c0940880f54928c34cf2ac15d6a6612d09c0dafa2456c232666381696a51041fd8c9af5948264d9f5ef0bd324d81380d155df4fefa4f6e3304c7fb70918c979e474e87fb0cebc0b11f319e82374ff2e4c1a9529ac6a70049252e19d3f00581400e1a372a75331fe5745926976df17052546452dafd3339927f2da6b52869464fa78927cf7063a34288ba7299356aa702415874f53e005e06599e144cfcb8308a85a61bbb8d1ab27a6d09486ad444a4bb239167d6266675889fbf68351c983d61a5f1614209b359f9c6c406e75f7d5f42fb66fd6fe1e40b1af4bf5179b261e71b0b64c7635cc7d35087b514a07f6e908bc16d171eaeaaa8fceb4479f3c61dfc9d0956cf11c4fc370f94332c86385e70196acb216c33b7fb6ff0c98824261fe6edb24f9dec8f8d024f5611c715301aea686ec9a870fee29a57eadbbe33a95fc3f3dadcf706879cd352d37e6fa8b42e677297c0d2c095de273bb0f09c68783d4b72bae16183c31cf1a0ada3d875ecfdcfdf59aaf042bf4b2d5cea1857433504e1c570a69579bdff952becbf08fc09f78fbad9e53133efe92383eb798e8b18aa0d47461edcc8c52e61039d469ffb70752ce033f5ad0d9cd1eda4f6af6f2900cb22a7f29467d252bacf095c0842107750df62fdd3b3111a257eb3a955f6756fbb4c33b6dcadb869c16f4457918e44c7eb20edfed857a4a8c38e79d3cd212976f970454a4f162b9038d1bf5b736bfabda47eb24234e77f4a9fc40947171c8d4d7b949fcff042d698b03684c20352408238e3fd25cbd16523de6830e79046ce4049b5e6a23d4a8ddc7d45bbf68b7c154c4e863043ffdf8679f90904ed0ac09a294224b448f24c3b09e3415cfe0de93495ff5a5b2560ccd40d6c7f28738eb1c63e39868f348e51304031fe368a6a28cdbf758b358be686bf2f8a8d46dc6af6bb442b5123777963043220881eb40b2ce6fef2a8fd1154538b1a1a8d4441763f038d204ffe2dce6d476af88a326181e2dcdbf46e1c1183817e0b4f8105761e673c6216f934bae5e44b59c582ae0bf79448f55cca4933a2bd95386dd95c9d38899d59148cd41397130c72a08887239cf902c6a9e199466809861609da499294f0c401977335ca851139d9d0e8b5907016b065afb561ecc7c9fb2b54cdf039389749792619e4dd64ac64490e3726608aba90c6c050d8b36fcf5dcd04784830f90990ea81910cf38c7b8da9b50b801576d5edbac6c8ad098c693d3931df39be93bc75564c90aa95543db8ca84445182bbb84376b377666fa4dfb49d443b53103b8ab49f2d1bc51b14b2cb8394de4a84cfb81363a0ce12c6844e747c4d264291467bfc886f6683dd0723ca8c38433ef405f1db1606d33ecbddd2f33cff789e0c9a10788910040b5e37fbb49d394380783cae04acf9e8af8fc74e9588c6f321de5f1f2efff07036eb4d03268410a4320fb05b79f86483958b05e2438e90bce903b6dfe5db21d96115c9558f593972de93f1fed8d41f4c326b14518522f42992cc9f5fb03f8c97311b2ed0f1304e0c4b1c1cadf9aa6087c74fa438680cba5206acc68ca845b35204b1671307d6f309c21d49f3970503be97d1e497b6d4527c53c9852608d0b5eb917c7d5dec19c188b80d75e32db2fb252c56eeccc7b5cfeec6d7d439d0b2cd98b12812c96b7cfd53819902757a98889ee29308c260bd379b32cc792d7bcc28e24ce1e7ba39586053ab34ee806298795da544293bef5d60af9da529fbc2a4fc67f5ad13c3ca850b94a8c4e6cdf002adc004350afad10b9860a09eb8face4db317d24f0d49a5a7883149814aa99c5e6ab032285012af8f11a64968fd13a11be877c81c4c4fdfe2d108a80ae744562a67f5518e97debb4a0c0947fe26f1e5feb2cb86a046dc8c1278157eb2ba38ec069f21a0649843376db31b4ad86a2414cfcbe3d165750af0618115eac77145b49e2182045ba4805f7f963397b4e5b7163b2917424316079099263a25d48af6c53203b6ec021feccabcddf2efab0936ea527b391cd3554bcd5d376fd5b269d6ac231ebe827dd6860e2bf42307f3fc65fdc33b09b6f9ce0fa9a1d3219701ebe167c55c18705c5ecfb134a3f5669fda3635fe38a0e6ad35d6f6fea00b647e1daef3568374f03d4df797292010cadfc9884a27d58cbca58637c359494d1d11eb536a0b29e20655c33d0fceecbba209832b5a157a124bf4987913b76a9a4482b7192a9358e79142022c1f72f23ed7186d6877ce7f23336913b17e90d511ebb50c41c51ece340acc495e0cd4de92836c13b3e509f1d6055431a9fef9b11622588469eb8440640095817716c6fe5c40991a10b88a08f24a41ffb1285645e0a67c5677e6366b47b1b64a6c6db714eed819f7c52e4864f9357959450cf6597563c022ac8aa37c1cbfb9061faeaf960dd00784b6d638a167fb10d12b1793cfb43fc7dea795ddf6fcfc8f261e221c90af1e8d538c452a4b247627b85f23bd820ff979fdc8ac94efdf993b9d4dc05a679f26a0ecdabb1e52b0ed2bb249f8634c0c97de012c474210ec58b3bab1c274e9a4b4ac0686304c9806190f781ff771bfff370b8e314f029d58787a8f6db5a7ff3860e10b26483122ffaa652d396098b5b25f7cd18072329a78e310fd36d5e5e37f9e378d2c3e8309df8f792d368327c56ebc4140d15915df7a88f9c1f6cfb72a416c264684c9c07ef5bba19daa4ef5f9fe78123c66f65b0147e8dbaec743371780bcc6e90d22a524bb784b76b1dc0fc75108fdb2fc653de4876b19d790e7032431fffc1277b6f5949c47ebd8c2996e24e173924918f4c03c41b29398129cf9d93888e9d7e97e995704eb2deeaf402c629e8b8d6e6017593aa2c15a88c9b53f8f485ff97042b5dfdc18c5d65b4c67218d9f3e0e714d0679742f17ae6e455c3de4c13772f1263e0ef63fae0641e91e5d894be530410946d6ce7b10c3cf7cc78c7acaaa47794978d4ab77e24a909a19ceb111979eb264ac22f7c1b6b3b0b1eccb555123e40ede958e1e0c0ed73cf2c9e73be8d3815ff55bff107554aafcea864a9df07414d3ceef441f082307656fb69aa9a6cd8cfe70894a7419c8f323ec2cc284d5a33a369552eada1871584e59b900447b8fb910dcf0226fa70be5d8c1199232e1f1263ec1d41aeec806481f93297f8d93b6fef5d0afc15c68f030db34210ab05d0a7a3baa22ca5e4927adea7686ad814af95b2a817481d4e6957209ebb8deed6a5b54e52e260b4676a4b0e4c27090e4ac87526db8c5085fcec11596785291e9cd1de8d34e3331a41db46ba87f0f5afce1d5119a4d3a2b055b23cf04a139cb621c176748fedcf97742a1afcc341ded0804ff07852aa4ce283baa81830891d599403da374b7f2265946075933623db17a570dae354d0e51b739ae80ddae732db9eca4b94b9c340d876ad59ea9228774ba6ca690b9d7b841a84080b8984abbabf37e6f0517edd368e0d1fffc3ff95942e025b3277f395a714717a09dd7e5386c1914ee3a0237f023dcf83f86219bbaa6939c225a83f435240f70de4c4cbbde4df1bf6217d5ac9a1b1d18ba239b3b9231323eb229a8d259106c33294c44c43a2ffc55ca34b36365a3b095cc6a23d30b4004ed347125917ec0d1c83e7a619d123d25512c1afc2e3f4ba89395a752dcb6e2fe93d26037a1087773c0ad4471fe6d24e44ceb542ce2f43c80e118a1f5ee64cc107aa379af95e464855b59abe26b0b20b2af5b6221282baa740a87c458fced1529ac131f798ea7bb71f2de863dd377ed642a9001e8b729ac9d841c131dabe3dd0af3563000a88625b177a7ceb5a52d4dcf5dd947ba654b579c1b5b4d0dcddc2ee4e9e2df8a7c96845bf4355177179740faed8b69aa16d76b7ade4373ee04549d7c841d5a5d83823ae425960f5b533d4ad24f704d1daf775aa1295ede3e3820ed8258789fbcd5bf6da71d07634f80bdff18d9ea140c7445f5906ec48f77f60a7104a4068c31a23f13e78a7bd79c9f057656b84bf646c47b304acc08630832ec797362d2791d3dfe153ff22a1b0518f02a85d7d87a798ade27be6a3e3f104bf43646bd9845698ecb3e00583ed0bf3f871737452c2c7d9a3891547b30560b1c221d4fee3009c6ed34f58e1d944a85beadc3a5944fb7197be82196099d404b6cdb8c017e7264de0d4939088b45ef7151302716bdf016af59be49fd1f69aeca71681795df068c4cccb779298ed89be5b99ceca55ceaac4f9cdea17a62631ce2b7a4cdac77ff41b9bbe8118fbfe16dc1fcd51f53a1b9d5bab6de43dba6fbebea5b7e53a5180e1dfc55e46d1aa6baecf665de5ba4aa72928c0a37f2f57826c54fc42dea1681ceca37b40d72951a31ce5e34173194e16d3e964c6fcb88686582a61f057cbb226cb5bb78f529fb26234b19b481639d28eb382b456ed2b153b981d27f977c95779242aac3fb495e12f08b33f1c173611f49bdeff1879c3bb2839a41f6751c9541d2a4b4e37ed13d59c07ebc215c6f7beb88cbdba774517f75d1c233c6feb1d20cd11551b0a1a30694689346aff80f8753e49ba2415acc3bcdc25c614557be6ad669e5642d91e55328d992ce378a77bdc6d513737b45cffaf5af0fb0d9c5e71d755c7e4695947c55538d799a09b675ed8faaf2f85cb8c6eb331c7dd5143437dd80cc8866a7eebca4a8d0f98cb00a6ce77bd28a8f44186a2326c14bbfc5c715579e8213463b31b07d57f0fd85d0c7dc85addd268fcbb5b0dbbdf535b6a3047dd795dbc5dd702ac16b3913c617e2c0c7282c257a6c3c6d4f01929d5de7835acad1a2bdea27d2e32c9f7bf5bf51b7301d1d1101e9b30825caed97676ffb010fc302801bb7fd1f1d776322d17035d37b9aefaa3f59e84cdf12fcd923c34a3478bd80c07a85846252826d9703f3a5541887a90be710ee890a00a502bcecc3716ea3bb4c9bef6ebf197ee2c399d8de00f314e6d132c4f2bcea039d72aedcd76f66ae679f8a4059f3c296d05f60f9ff394ee62837e8f26a49d0c04607e08fb66593e320723c3fdd78e75c346f86c4f42f938eea935b27da257a32da1f9126c89214a9eef549d44f952b92fb597bee0d2579aa964b0290832d7b6be433891f74e8d00d4d1c40b82c5a64ca44dd4d97c51277cc2be543a59e588599f51e861d8c741a8d612818eb6930721d5084e87c2308b1671b62d8980aafd85011ccd336325ef69c6d2fbad8970868a941cfb508eb8021c69e5eb0e2c81292e50ed5aef27c8a838e545dea93ea64e2f23be8c6a85843e14c0e8a8bf67d0e4cc8fa638562467d3adae9e9c1169bdd22de9422c632aaf1204cdc6b6d6fe9054089d904ac8ced570617b2c50af08f0a3345acdd7b3387f43ee938a14ff15f2739fd27745ec528ce347a62bfc7e68db403718eea6b32075747e6da2818e9608ae3616935ecaf0fcc61cf664347e6ad70ec706bcadccb07cba2145731f7959c48178784cc32e73aadae4e71c009029de485cb5cece14ee31e3e3ff5a1a6aaafe1a8249e6be12fc21ca9d6f49d1d04e56845ed49c0f299c0eb35","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
