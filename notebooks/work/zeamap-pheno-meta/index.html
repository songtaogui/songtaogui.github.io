<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb90d42159b65a7d3d84e8ba8442f386c521da8e30f3fc5282c0aeed271c1e0c24038ec7e4f3a36da26fe1f942c2b10fe4b32080764d11743e76e9f502c252a0cc6fa368dede0cb6bc802b8fd172990223c9576ad73989e8eb0442632c58f215491cdb0f076de5e8f8f296502f3b04bb1f87338e82590e793ddf9d0114829c8d1e15835bd5c1a14df222c45b44640a7782a1ff037150ec7636c892b177d863182ce79d8839be349117ee06344ab0b20d2c877ab7609786fb3c2fbd0e935f8e9964f256acdc50ec6fb907f0bd1236408df1fd543cc16e948a82f5bf73937bccb8c4a4bf7120ac48825b7c6078a0cff23dd956dffe5dfd5c1ec54ed58c87e1c031eb7c48aeae15c8e1907865bd6d9552a080010095cc271f02c6a18b105f530c0106e6f3978de5d2995ba9e0ddc623d3a243aaff29b3ebb7523e9f0f2932fef3682bf27762e1deab55462f081eeae4d59a459d83dc2fe73094a5f18cadaba9149be56c049cf88051e22657b84e0117635d98838c04e2510aa4cf1bb3b5102c39071195a2d72b8ebea475d755ebe49aee59d40931fa27a3ccf5d07fde644210170ffa073ada6e741fec09fa189e5d939b41f4180bb711f588dd8e4832f6cec39c96313767ee23d7aafc6a430dd1a4d7bda08d6d7bfa7caeaf078c8ed8c9a5436245ac9fe1159bf04a2de8dc95ee56776d841713c0bce0a5d985fd58860911aa0e0e664a76ad3d9d3f30722ccf8683b884387644fdaf26c4a32ccd5685efb4fd06125f329af51d0729d267e27817cdffb3dcb523841c115cc9a415fd7bf82be56931a79a289a6cec4cea18fb867fcfd3da67af8bf347d55306a93756835ac933e4e80bb77c22862026cb510155c98bde9006e0fbb71728c2cfe78b461b11e591c21f95b0b4c1529a90a9999012d0a5982dbe3e7820cdd2c0584a1513b676c5f6216c65baff625b9de224898a0c574a6fc1b0a4f0969004e559deb9c7db85d7f37976b357b910eaf144fe6f420b59b9f4d5bb09b02f4ff3f2effe99903176208ad3db3fd894085ae894ac10b4f5bfb75a5200ec93e2325162d89978661aeff21b6aeab1def6e3bc274b4ad914043cf35be48d9db209de5cccf470fda678acae20610db67343cd3d916cc91a8e222e5ea5e8fa7be4fb51eb2c09ed948c3e9f3b04a4982adb7ab819f7c1bfa00ca0d5d0d45c4dd5a7880199a2b043f9ab86c2f2dc4f28b9b2b2cc892bd9cd0ce829750501165306bf493fe2ef690e67a61bf38e76975df0b90f4920cca8af6d5f63dc50e87cf1efa41751d35b03201b4aaa4fc9df1516d67d5d9d358841559012b9375102cdaa6c3efbb26c86df508cc512d11b9ff3b57b53e49fbe31cf4b76322aca3faaff4cc7c3b99b748df3a1639405c6a8f10621a85458e5e06f1a9e3b8674fb13e9062e7a14dc5306f356052cddfdba18f4b50fcafd14bdba87541d9fa88b8fbbf3c19909fc9d9dd650c810f3443ddd7ab53d65949aa0afd77c98982c677b531276399e81f99af66507dfbfb3f59172c90b8bd0caee16d7564e85b2412901b654ad74d3e846ef901d78d600ed9ce8e39128cc61ac0148a59529d8130e7c7b0a1b60b37d88cd75f446f7a7a3295a7ee88b98499ce132c97436bf7493ea5c62e70c9a3437e2d33a60ba6cc2bd59990ba158dc18d308eb98655378f28860448e6f097e37b6394b87377dbfc8299d506648c6e0bdb8677e6ed2496420d7636a5986a9954c170e5c6c517793875764de14464bdbbaea5fe0a8821c61e101d19db12120f4cbd767eb1176c23eb2b342ca4d0cf477153f707cc3fab58b50a278d6305672380a3d544ab4a2f83ae6c69c217ca55ccb0b888f4156c56e203b0f6f83ffbdea5734947b8627968cc93905b3bec747a105983656dfa2f5f7791ab4ad844432aa8333ac4a265b96a937944df449025fcc737d362ebf18c5ddc2b9a599b82603ea7929aa9310b3bb5fa487e801572fe8eb0a5b2adc2c27315ec23e85cd49c1835b614bf1ccfe2e6ce84bd12ee89a63c6f329f8a59703f98e22bfd0594f866311111b3d900ac3ad75a406a1612031d9849514b3998d08d733107e22cae8ead600bf6a92db2bb28b1b5c7b8ece48fdfffb5340caedce593c18d6579e5b9ab7291d7cce4cb32d05a9d43927a35ecd262f7c35df2f77d827b84c6ef2e64acdbd252e9afe8e7c3a7f00ab9b01ea0f840230fda186306d19092959d7734eedaee6ed544466bfbe417f4dd023e1dabad350299eb450847cfd9712e4d9d6dcd755f4bc0e3900217fc9482b25e9a83eed776e2bbe1a368fcba9215f049429212df0ae34e07a2458a2dd97527c83ff70c3c963ac65db657ec9b04f62e9f27214812d5084abdc174e11eb0c1e6b8f1051b687136fa3ba5d3d2dadfb2600ca15ddff2b7979d78ebcdedd58aab2d2a7af6540f2114996dfb47d2bef238eac8262c6327175e586f531d2ba619346db4dd9f3d3ae4e0cee1791ae86f176fd07f238c9587fde7381be4809f368a924c403a41a4073f75b08767b5120d6accadbb611f95dab8a3b1e03e9709ef21ff4ff75a364d1159a402c3e5f0401547e5483604bf0243e1124f2e9e99451e851171650bcb2a796fe056e930c4c17432c4401310de3787a4cdd6571d78063c8d9df554d58a9e03ab619c3725bd02a44348f6889328daf52b20abbc917ec93d0fdac0aff1150d78f7168593c045df5ea72170adb6b5304203bf27b22450d948ee04e8af751077970a342cf36bd3b48e94528349d3cc4b2ee5c3d79b26ead7889f731d0685e764c6b6534b097fb03bbc1e3e464d5260c46f91974c474087f79d396a80f587ddad592100df352d165fcff0f47b309997947304108ab8f415d04552d3557810fb61c015749d14c7fb1e41c061798fa504053700ecee137a2150de9bbf774fa6cf18cd7c8e02cd23c5fc3d75d62986e5fbfc0f0b6dd92e1c578585bf7998efcbbbd3518c7085ebdc4872517428c29a0239ee823e82aac9b9281988287b96a037c0d9be98b2782dcb41f56b3851c5863f658de62d5bc5a4bf2f6d06a5a522d505b0036ac0f5120cf1bba8be1dd242377c3ef3201b754384b1c1c5060e1e73f556889d9182a6f7b59cc26355da91ef6ace59ced8b95b50eaef3db3a6d5924647589ad656b4cb1645662211ba0d25d9be16439583d2841cdcea37a160e693290f581efec624c2d7fa80b07143ce083c16555f7dea0c4b0c7e1c9038f48ff5766925b3736a5728c0a34bf609448035c00b90e8887b32b0c104891b9747ab4ae99eb276d5d1cd9cbba337c61a3c400829fc0e15519ed6136fddea7d5ce8bacd35091203582fc5280910c2d6caca6562cdb45b04573492f8ca7974d1dea9365534379db02947d0387648f04b0781867d387ac857dfcacb0407f4ab1ff058c44c8b6211af47378d93d6607f19678218264ad429a855f5111f142fb27942cea7c6dfb8246a968b2d228b970d1b6725b07ae855bff72e9b8d905aac29aa11ff0269d1431786b470558f875d60315a8da03ab38942f8f5ef23f8f9c97a0cc208cb3c85a5b7927a0a8c7bafb5e96892433e6ae62a8c26992ab26efc2c241075a2e4fbf304433fe0e08ce9a2b208b2e3be0564b18c83ed1f1f3c4abb2701a8020f5e3f57782c3a510f86f0aac2aa4184306783b50f7c48996bf80c9119ea230d7c8408c8b2edefc0aad42f2b360bc477fb33113e79126a4d4bd8ad053f4ef5bc9d8cf15917f6052f6066d60cbab686467220cb2ae3add5ecb52b96cbd491f401ba429fb4de41a4b10ddf988d607e49c7758dfe1c72543a808d097a83aacdc3d12f71b1839405cb4eac1c6ee637e61fe1fe2c560d60783b3f27e74b451ea22e6665d7ec57b4c1636cda156e86186f5f6b9c434497bbd9550d91389f99b35890a06380265915a9b62a5b276a0c36781f1467e3f58089843f598a98e220f180d7631d86b205120b2bee9ad4f32e4b7c5c790a285305b6eb3c406befb3dba1dfb8d9cd3f0e08ad97af8e2869fb3c973e71b1820e29c19414f1736afea057a9961beddebf7e39c5a56d03b676a11d06b204df4ccc55705e9b93767667c5a4331a0695371df5a1d52b1336326896c558830e3cce48c304b2be92ab4a3eeeb4944a8f265fd6967a1b42784068ea9a24c1af5b08e05cc7e3194287039287bbe7a5e1c9b013ca6017a3922955c1827f3f806e9b0a9e1a5983b4dc2c9d373890686d4f0bed83398ff2ffcb32f4dd9b1b1d507c21b1391ab85d8cfe91017d22f5e714d5efbd74773b619dfc9909623e2f8c5a51f124ad066e1676476a2948f45828a912b186745ec5fef52ee7d0f0ea4dd615a282a2a66500b0e4a1555540e352cda7d6d5fad48a8c1974b3125b4170b7fe94f76c735e437c824abae7d3f695ae31503a63324bcc9bccc0451faa40b178f57cc88fd042bfd727117f5ae2ae9a40018e284540c887cae40d4d955a05872e28f05016cfa1ff3f2706b9c17e84fcd58597093fa6146b737a2689710a042b57493528444f2c3247b6e101ec975da0a3874a4c802408fc94a9f55af0291f916f8ebbebf9bdfef358641ab12da134cab77f507dd135b6d2d79b94b9d3fd6e92960eff4d5fbfc178c37af0649cf6f17e5f1d0e6650623109e0b0875c2cf08f79af9d699695656fa4becb55f0bc640e69651d242a571e02a7ba792b6cff8f8438d4dca5264272f39daf1920847fc2dd012759f5eba090c3b0e91aab140e57047d634b16bbd20a4c9281b63e54fc3ecd83888cf713ac0c5e722c81644d7400a0f2e236ea9b553fa3f1c8e9c4e402eff1a957c5b6d7f117c544e3f1baba6e470556b2f6f0b46b81062d3542ed25c52811019a330c83f95b992bef5fb9c366b54a6a1fcf0878375b9581d7f87cdba52d4c02220f4fc66aff8d20377ea99fd1832df18b236da69cbec29fca508717f41865d0a8cf1b873353ae1c841473ac3207d087e7af722a85ad64e13edf09b077b081e2767852e724a1cecae01610e180b46dc901bf451a72bc58959277ecb13446c682e5b1d775cf7a94abe4dc5d6d56377703ce1bc21fb1a8df89c34ed433f44e014d7558f34076213dfe6f539cccb967166ea81b1c8dca4c523d868a7d86802261059ff87c6b4dbe0c7b44b8ff88bafb425f3525d4aa900df22557fca744d3870abe8092f8b3820db3bf66b0c7b95783c943c86da5a08daa188252ca65286f297306b9f3fa9781fedd6081ea001c077c52b6ed591e9614b45a80185bd4982032916db0847b5f8a3b0e639e57186f0e9ada090b79d977eac24a27815f5da7dc2ca0e34338a9ab7445d80f187ace12020602dda4b38885bf45f6df390a6487e628103b9d72b19a7c46069a68a10f8d7aec713cec29877cd888872cadda9e97fbe195fe84d3358654daf6929331ef5aeae491a2838aa3db49913342699b0b30ef81e51f48262cac47a91ae9712e7ad53fc03d20faa64f4b6eb612fbaef4dc475565d7382864cb680317abdab4edecb16d76efc83fd313a51488b21c505632035aacb5807834a0f19dcdfea9a5c20d7af760b568070c064784c9f7e57479fbe39862b7b86b6e4ee3716e237c047945be28e1749c70180f5b148ff99440233d5ef251c92f909463b89bbaa5c0c9b6e81870c3152a3ff4e9fe2af1a43224b8aab91499b6fc52ac3e2d0afb99e6b751aa265759a87f88cb59cf769b2ed872adcaa4dd034ddf8e22dca37a69aab79111f86e5f8ceefd14cd47c420178e6cb5cb75f425c962526b60cff7edc0091ff4117f5bf6f2669ea361d9ecc083a0e09d7d8da83c8f2e3e9504c91413f0dac21fc68c247c3bcd8399813c1840af21fe57e35dd1a7315f9b50033d5e35c1c96ccc4f879d00ef9821c3b52536c4ec8e80a0fa664af757c4b8bdb9435dc850ee5d62665d59626e5adbf23a7a5dea4ab75fca8028bb2a7f26b2649bda0c30158ae38b6985cb8acc9075261c6b73f5abeb60f3d7683422490ef70697a5c1b1309e03866a300fdc083eabf65d75e7b3db1ba6cebb774cbbfb5274c74751fe3c06ac98f95b76b10859a2a60f0a80de8cd78a113ceeaffdc908375a9ba2a8e1205a56699636a158f80b55de9bab61d810cfc032ea7629989d1e33ce0aa8d3099e5603bb5e04492cd2e370b81da89575bf93866b211c6beb2e7b4e0ad22c762d47c64190cb94940e2b7b14551acae4a1d412f60d443238334b35a7eacf01b7adae6fcce0db1bba788cd4f4f5cf90bc8464fc2f7713be9e87da249784635625a54bbc1b63389d46d0310786a761eb73cc0daf403d5ec8e63d8ea7949c62c6e6913ba7a9f200ead110bea763d2dd4d8a2a94de92b3fe1f03dbb9e40b94e0ea08072b725b69ec9d7629fd80b96ab6bb76c199a6fa7117bc79c279c47e6c68dc8da406d07efe1386c035925236734f66b2fcef841c5777272b0dbd4fecb09c3bd4c1424af162ab6e79f782489b7ff5fdaf44e75272775bdceff89e6a292f54ccdfef3f1a44c23364a142a791234ce7cf47d0619c6884141065c375f518e0753a17059380c0f514f6195ff1d4cae08ac3af4c87bae7ebe68ebc2912a61d415a4715ef30f305d64385f174e8e0fb2fa534e7060d2c59277ce81368a4d5f1b6841023860f11a7248b2aa74cb5cda997af0e7e93f4412a5186905cfb2fbc85dc071b336a7b1587108f3a7b295997e4822c8eaf41d3d2f7d581e7c6d17df2a413b3128ed5c896570880c77019df8461a999d47dac7c600ffa236e845c903ad6f78246d3dda7f401151ed2901f263927244e52866cf9ead02ff5e62772956d417b3504a4ec0693d2edc1ec7403cf38baf3b2e41b7554499e86cfecf28c2079417ad173db772b008a7423fb706f5b4528052f2dac25f1b4fee54d2c1a610b2afdc7b1937cf5cb41d4d0b91fb5bdb4262b61e7c97f918ad9890181f379e7acc45a51615c2986013dddf6e8e721658d2575b7f404071a7d30a356c070d748a0bd8fba7dddfc2a3b3b766127322333f771c75a0f0855ba8a492b7ba7a963d9e97723a28dbe35f90b6e84c4c973d2a841cc770da312721833cc6dc4d67bee2b9f0e33d2dbfde3065cfde2844f12c3667f0977faf8ee4fca991a5dea33826378f6e25f1a17054039c181e8d49698e724c5cc0c1390649d6154cf0d74e2ab2ace7974d24709b9faac8583d9c70a4dcf5f224aa7e09c8701ae572aeebfa17cb23984111f39d59e79bbb312c99ed5879ab3c2022dd2bd93d5f0c9698d626f449e27fde129873f20c682270038efcbc03ed431ba35f08b4d92b134fcb1013bc674a958fa0a81b256add141b795791cea0a40e68e9e2813d9888ca1931ce6a7378253df462a2f0cacbd2d4fa86a831be535b5751cf3d52bffafbf53b65803747d3bc5448e1ea8744b919e36d36caf0329bedbe1ef7a57166dc46f121c86c95fc015b8d1d0af73102390b2ea868c996a8f175b202d5e33839795ba9993dee4593031a4720bc731e29cf3aeab7154e39e7423977cb6083632441cef27e6d235c90dd96d5a371bc7312144f9414d45f8f576edb3ee3eebfa3306b653fb2bde8307ea64908cf2fbd9384391a1b7f531d18147232fc1b058d872aa1b21f6c3ff78c8f94dcc7d1ce0cded9885013d630b427e296059621e4389bc89d1df30e1dc0495267287c802e4f501950a45a479811486f1bc4952a384724515972236c7d7611f7cafec2791bf1e1b97f08d208bbc747c33367c3d62f31ffddee0ed843a20d26c1f42cf58e58187cc9fe867cb9ba6443b2fb4d3e7b278509a3dde810e1ba6276040aff8d4b0f9f0928911c5077a0c2390000942f7fa8ccbb6b0c0217b203ac453bc7c0871304e2ca887c521d42b6b83f4419eaa467e97a44d22598d82f5743bae8eb7d6824c0025e38b8119a77b570508c7814601971d0eac05427f96474705cc6568bb2a375407d785b86545967ad3a1d85ae3f60dcc355497a3ee23c0fa2743d973cace408343fb6584f04d8cbdaab78f399a8fd2522fbde0254b9df8386269d2da6b11b33b24d786c4ea8108bb7bc35a442f2ff72184a214e41e8024e7d2c3a8aa503648d74b87f077f7800c15b5486e2811c26bac0678028541dc09d3cfa949d5227d1cc0f6025c13a5cc46a6ba03a3d0e790f69537e6f228138c149c89f4871a5dca2ded77fa85ff2a4bc60e3c77d9863bf54bc80ea8a52e72c787c25461012ea16cdc74c27f1061a70efbb83f468bf57ba4f6c3725ba183c4d0a090c87e0a5cdc11bfbd894c2780d70c894b2b3a13f22ed23d094ed7d21da6b9573476008f01332bb7d99cadb3f368b601a7a5c9d9180da12da84d75b8735186de4c407e1dc0a9b78416d7dc6b088e0543bfeaf6d7f3e60ef7cd6d9a74412f32b7dd2d32fe0c4e1d69509a619f1a98f8dbf34672cb2ca65eb50947fcfffe4e1e237cc62e5fd6036ff13624387bf6282db77b4864e44d2af38e6c016c328717abff059ea5f5f40878e27f5af80726b65b88c7d8171f69fceb350eff86b8a78fb646423c2d17bdfcea9e4e34a227bd108d8b5a9a812922ba80e7428206ae400647a1b8411857ee436832e7cc2ae827692c8306cfa59090b7c66ece100f2b832db408c7316d0fc7a2b8150008112760a458cb6474a8f51a8e8ad7940bc0ee8a0127456b870b8a4f1302c9150e7d552b42872114c31a6f73282ce60891159ca5b5e5bbbc20c67e2a79aed63cd711fcda29d88670a17c7ddbf7943f3f4a8e7415fa775c90d3113f749993d5a0b3d028ef77657453109d665a2dc46ed28b26e67d74ec7715ca6e6cf27db901f5544bd7d31e7fc707b0934ffa7378e756b41d18665856be10f3fadae56fdccaf25b8745b8982dab216a39a8d9b4d75c861d0a0830dd3e03a2550a2fb574c78ff74a1b945fd612c288488b3dec680f495e8b1dc721d7d1401918b1e2a22eab290ee4264060c4154095ad4c662f8aadb6a466aff6ca88035283e8b6bb4cb588cc572e88019449c0307961b2f9fad86f2dd689029a169f28eb368d7522e1a6be2c97c14e4b45bf28b3395cacc215277584d3b24965adaefa6d9383657406ca0a275cee96cf5de694103c9138063fe9e4e9fabb22ad2606053c8078623491209edc6c9041aaf12c861b6996e8f898b4509311d8148a79c538c39c82169aa9eb58f790ad3392db19e215ba479079aefdec23668b88d415da737bf08fe5918535db8733ce501519e5f2b25ff049055e0e29d0a6aa96d0a64653b230e2eb925967494e9c59ce07f080967148a7669718cdd5b88a302990866462f0c064f2288d316031db9dbb769644a5002f3d1bc15c30947b38fa240bf4d44e7850cb3b2a8abc7a719dc84aa0805337832551b1332c4fc04bf9ea9826e3e61427ee71c58fc8cc5b204173155a3b20ff12428d56a5ff655d5d56edd86bd5a8ac06ce30de4b63965bca1f9066f08b04f225fe8437b7385fc426bc7a0dc57879e3d517dfae4ffa3a45c53f53aa9a0a22a445900dd0798c1d266948766a3a17e3f3182426ca318ded5a9ebce97cd8331ecca32a01a5cb701b8c9dd8c86332a8a9b5f3d1b9705bb4abbfd15d45ac3980765b1d4d5050d356c6c0832bb619950031136cd1339b6788950bed9e819cd472ad890c60061f0aa24ecefc56878371e43045f449eb86800bec26071498f231b04401fde09523693c5707eb4c827cd15554f324ce2e5b44f843f35537b498d695701cebd06ac37fd64a23d768a914c65c64cad8bd02222ed9bac8c4accfd88b2c17392ea4b770c359d032d93b995a096978916ad3eb65a9d03bd08568763ff06264ee20e6df99147b97d8594cb5288b71762d2e71591cb83e60e602911a35554422bb79f6ae07a0bab3fc78c648650285639575e40b0ec9434888a4f6c455b090fba24f06df78b90a7aeefa6f2d231614742704f141898538319ebfd5042776e345963c293a024d3f7f58698a922ba9d084a7c6edce58b6b9afd51f3d42c26d5d2320cc013cd7c47825b99b005f81497892d4ab5d18c9646c61779f38a2247660537709bcba0b9d3a88cca40717fe088985d63ee882017fc540383f7e5b0603952b754258723e6433f34414f3988bf182df12ae9e4fe46b5fb9579622c7598f0d6919ad631341645bbd38b6dd9f971b501649b2d6474e586eb145f6802073e1c5cab495ab28f9ff796eedcf78a304d9820616f63b3107bb6e606beee13123d184b83bd42f32c5ee45642ed33e9d3ec05de3aa298fd420059f348528e67e6de72962b8343e72b3babb307451d5f28f95d735d03a834d89d5592fc6bf752bb8dbbb83c67078ffe1ab9e9428d436c9dd36b0bfc7fed41ce5b068bcc11b581625595e536948856e2567a2893e7b2102ab428fe4a5c3dc1c106c17eb807b929681c6d0d2991009ff01ffdfd464afa6a50c9ed381da53c6a118db5aa4ce5c316ed38852acd77ed014bcba7cdcb9663d99eaad9546c7df6ab0bc7a27357d743a8e98e815ac210a2567ed8b19934325f37f00be41775507e99ea2f0f9813c7b3f636ed365a5629a6f98eb1464eb1fac701e64d712a2e30093ae4793e266767e3ac99a1f60fc5a74e1ffde5b4c3d895a163977ea02ee2defe8c63c3203139f0294ee3fb84001914b05f1ace45f334212d2e4be940ad24f153ebd211187eefc3e0c07e560c3431568ac68c307fa875b7f76eefbbb62024199447e86ecb00ed16ac13c71b357acec85790c076575a87838d751fb430c4a5f0b557c4c49d887552d7951a5ab747017b2bcd67395163c954b9c73dcfb3f4a007a07ba125b447d9254fbe53abd64d25c4d56b168e0a27b13f00a923efad3b5311457bca6b1ad3208e0fc2b1b1d49fa293ab936c532eca93e78b3c093fae16da783cab475b30a225eb4ba084543793927ee4190c93731e1a818c75cc3ff37b0d5dda500fe93556a105d687baf847c7d38de780e89d77ffa68bcf2b56fdde06b685cca1561b3dbbdcbfc83168fafb8ae379b3d8509eca2dc093e66590c1c7eae66d52f912e31048fc5cb1ebbbe1242990fed13f9539a923e90cbb3009dfdbf61c38e73526d1e48c5c83d8b2e6f27f65f3fc3c591d9dccd5040f115d7834576ffe812ce3526510d9664dbf2201bcaf862b3453e37540a45ad2e5c7c5c958a22cf3c9b2866f0cf99999d2b9674aadb0ba466b05248f7bfb35b64305b7897d6eac658ad8b82b1bf6d884e5851afacf06edc43e6ce06a6bf487ceda8e97ebcd48ad0cd9d45456798d27aec2104a2546be80c2e26947971caad9451f6edd1f5ce57cfca5097c435cd8a73371e0622a4b79ed377dc7191568ff369864e8cbb2e1aab08fd42e0bc5408dd4cc0efb03746e52bc5bf0cc4b2b8fe514862dbdaa2dd0a797ea70b105a570af67440c5ac8f56799e73fea8e6710a26b21ad2af8d7bd1ab6a5a88aac5ecbbee7100e42b30afacc01d52679983721c020f6918ef2b3f0b3e0fa40d5368c29ce93bcfda1b08529a4cfa7ef5d8b6942e03fa86fa407ccf88ff8d3c277c5b6fbc2beb08f0d2a47cba0e0f895859794142030b119df7a0e82e37209b353d04400f23a71c9a657fc530dc2860bd493e41aaaa4d425813515d8f2675301f371f72183421475082b2465f46a8ae70405f87af6354a4df0d3e0a0fd2c4d26b190f3ee1856ed3f938ea3d84a92a402d74213d516af72dc86c0ecd8253341ff66b5c63585d9150f0b07bf3e306f9101422f8295516609216da881f3da81827c5569c7eb554f1cc6211930601745f2e80e9b1fe4c2275f3658ad596d9f9e6f50a555478d4bb4ad4c727720ad32f27998266f9c006511d8c24f01e26d9cb8bb6f7b4358c8f172419de9ff9db3e691e4b2497e9a2c9e067f0acd70fe84aaf3db545f96bf9d9ce82d3f966702a5db3f09fb18303fe4d65d4817a0b41be213e6f91f4e264eef289e327caf10cf7a37d1a97e0d6edcafaa8bbc46e2f15a1cfde81a459b1937019448fd35b2848dbaac4f564d1ceb80e1fad328fe876efa58b4644e13f16c9cbced7030d72ffc58c959392a37ae59dd127cc46e4fedb9c6ade589f7da59c57bb1008719eb4dc6661a494046579bec625d3acd2cd58793cfbacef98cd0b2a681af7f773561a1ce2578a99f45d6f079051d134cc0053f8f27a078d40fc586939265dbd77cccfea63cd360fc20f71aab3566c2251ea19bfd90b28136ac7f6b9deb13c35aa6adb8cd8e63a103a474a3b0512266fbe315e331c0889099100572b897589097027b4a79f8cbaf8fdc73d9fbf78a5e96a063ea829716fa7767977da1f54b81be93bff9b412443b7650ba142a8ca7cbf15742e093684b61e32893f103462319ec71995a126e3f01c74bbf28cf135eb44f5f6fc1b10f859124d81449c26118d4fc515d7a9770efd9f5c556feb7f1a12b69050223f687a79aa34fc3886013e9ebf2cb7c145a63191edc23309b72e08c08aa90925f2c3aa83f8d1a2067123f7a336532023711a0bf5c31ae6b34aa983c1b0bb34745fc749628fb1d9f28769496aaf15cca724041caf59b20d9936dc7e3b41484e6c00c08efb4efb2ead8c37dcde79f5db4c351989009e52cf5be3242bfafdd37886d643aac9afc8249c07097deb9e6308e66be95ac30d954bf12ce24fc683c836df75f4c305978dcb207f911bce50b989effb3fb25f8b8755cab7daeb854440c2e94113002b972fa16ced4c9be718a851d6912f61a2902abe56337e29a99c49b82fbeabf2c87ba289e9190a67db6df391949a407e66cd0c5a31637c9d5aaff8fe31ca9209adb739113d5171f103be7412f348e3366a68db1f3ec2459be14a8b72afd5cb904b723389fd298563e7beeb087bf74760763b9ddac940ca02b58728b51f2b3de475c2bb0eaca8733e3111ad6b1e686236c3d58e07e739aa12bd768360563dc74b2e23d34168cd9dec8f7ed92dc516b3ace31cf9529468623d42a60b24773b6d950da79365a8610422e37e57eb310182b1b5fbf8f753fbd5e188e219624ed944e486666e09493a316a5ac5a5d19ca0df9b0df73ad7ac13f3d9e306e99019dbbc5a405fc158ea23767db8e337109ba8df2d035b71b2573a9fd2bca62d1f716215a0a33f23f623538e25105e662c24ccba7bfca3b7a90ce315e384cf249b998744128e2e0ad9fb7d60389b0ae70f62302b33824a71478b7eb934c6185663267dfd1df809d652e4074bdcdc08e319bd4b43baea4aace382e23f216a0815588dfcf3b5e23a7cac99c0f930fee062e3bcf7905dfa0172aeccd38b19fb0f13ad444cac8b80910fd7c2b12fc205552d087dc69b2bab03f1fd6d8d5e8be32e19b7ba4c5d8af522250877157b67ae5e6b70b45e0ff02fe95f084824378dd7ba79c6e4085bbb38233e7d87f72c1209d935e3fce294f1675c3986e25c216717f2db8210229b314042f52e49aca68893cc883ae73ab7de8ecf5d6102b4642298735436fe10fb95fc448d7a23e3e45d77bebd965a98bab265ccce8c891d7a12b9a71314c8c1e6ffd9306b987654f423ac13b553606641891bd7666a9e852d7e7c8b0a5618b4e5ed023e3d70c5172759fb679319c99d055030ad5f2a70e0f94b6b7735e2b4efd0db9ccd5eed171d1e74ae49aa78e7007117d68591a53d2123fb560b23aa390f7c2ed389fa0a5e561e3db6f6d4b1be89d0ee3b48a5fc4137428b0e8cae3622a420ab58418be70b50343b0303b95924109602c833b31e64ade597195d4a1658393d5fb508a3efed358fe820f2ff4aaa527659ab32381c0331b37ba61eb80fa7175b68a67f9a23be0b7e5daab263c1d6c47abea81b2df092dc65d4a4883d6bd4b2bb13b5a6f46dc23ffc6272b509cab8245518b3e3e509388c099f4ec93c1a8c7490b8c066e173310207f278a124584fdf0f71f10e61a76de6eb8e92359f1d134b45b77e28c2771bb36bdd5df7b4fc8c02a2ea1cf3c1d3226099dfebbde0137df301f8a264046e76e3a923944821444e2effc28ae8b0d3f5fc662cbd44c39122d6b76d709936db7ec6720a1fe0f3418051d2b7a4ff1bf63880d66dff01d7f0181e19fe20ff3978cd39bae1177b2205e54bd8ab3d1ebd2d683894768701f0208b0e6bbedbc96447f7261607266ebffd5dcb38e03ab7a501694c0a184ae4d0d965fdec483a695bfbbbac1acdb35af46b92e30727f972067c1d85e3bc06f241266e435281f40e492ac091ed7d01d2651726c15d64d8cba815f042402a20af058df7f75d76bc0d732af0e1057ca76d7a23b6c737d93d493141c47126f974bf5837bacfd68806515b9061fd5e2fc7595a039ba00db2d0a826fd32690073760e6503bc5b3e1f122e76eaa29f0952c3e6355c80af566a543a1599ac98d32f292742daa4dbef326fb9219b18861c5d766d79cd628fa2f031e771fb12c4a02b1e0945e972e4f5967491843321200cd33069ea3b1b56c069ded92e3d4bdf73d86cfd0b194458fa15637f0a9ae00d0a43fea63ae60aff80990fad8128ee4f59010528ef977f3f1ef86fec65b85b96828e73ccff89454877102ea9c7138f20d77dea0c621928d1e9287c621297f5e1d995954000fe8e2ad558bdf341b050ab81965a34e1deb29ed03b1651074821c77644813b3c005c7487ff91e2901e81737ae0854d9cc0e28f68b1ed6fc1c4c64ee893ef5e1b4dfb50b075e424be2824da01922aa926de79ea96caf3a4ae33837e04d355928951af1f465039c285d820d7f9e9eeb5b03f0f1134889a6262bbefdec8870d0b6cc2490db59d939664ba6fe6d92d2b2f2c398f8ea7f4a6ff4ea4a569fccbad30d29738472cc2f626f143776870de68cd6e477616c87420df1c8e66e0d6591f4167381ba88c11a6050b6a775311c80092a4e298ce04cf90b290fa1a4f0b268550cc3cc5a057d805fafd3d79bf05dcb3cf2debd3b8238154b84c0c06afec69aa4a4d307a8a82dc37d7607bbb1adc787dccf33770a3e59c894f0fa2db153c788cf7bf9bd7af8fcee4aed7f92a03fd74478dc770014a872c5f03d995363b0ff9d51232c1fad9507f008d74f66f4a3ddc163295b355eff5b825e8a67e4b1ad933a72abe1c36990f91e6de47f6805f1df2a161aba10c3a25143c970d7fcf611aca5ec61e9bcf02f773218fc922cca62fe8529d9317ac71943ed576d586a8b1a6c178a132d7b419d88f2bdcda53dba105c044cb9feb5c2dcbc50864b8f06191a4bcf757c8df30ea103cb99f96e032a87aaa4eac9a6b02d9ce8d5980869644ea4a62869d538bb094e5ce52dc5e8806781db2c792a1424a32ed7e38513f2fea0847bd61ab9a6bade10b27dbb4af9996155cd5587f8258399fcbcdbca059de7debc7d313d41261be308587fc7e9593cb0bd60b28d6c5dfa8110ba7a6a34957971664d2e6e3c62d908d447618e9a21106f09e669a3488ce1179e7515833a523170370b1d88c31f5565e0f48751715297c06630a4d5b48005dae1f8d006ea47c054b65c832311c04c89c21e2572ab202bd0ee56bfab367cf6497a5fd685b025b4e7f0337bbc803f5d5dc9b2ca94a5528abe3c9b570495945c6053de69be966384294e242ec9cb5054540fb738ad1cc1fbdcdd40ac70655f31b0608c1eca43ae0d2d8c8edcd75635a26602c46e72b15bcf3c20f1c8f17f5483dc02bb21807d863dffe20e07eb3527c64b6640cd3322950cda641d90fc2e869b8ed415b9d2fefcc45ed3c6eea9e7c3eafdb27d025db8212e9013fec2cab655d3244d464c116beb86c8fe0465cf1459205748a9912831a2cfa397c7e92b6fb6b60fef91913a0c829a1bd657f62ce09c7a3a01c5e25760d5302bac861241cfc708569495297468ec857f97b1fdaaa0810fe0886a41b02005b8c81ac6796d4c778f5aea175677579dc4be1753df12743211cf9d2f20a9002c1f33c89cdabf083c607496bd0076ab0c4371e7f2f5493518bfac7491abe210feabbd4c3667bfe063480014132a5d7b8cb7bd4050170bb87523c964677ff62d37ded250e8a5e34f81ec5f127c47bd7757497e38e6173fdc3dd4e5e5be77bb6909cb8d97f54a1b64d3dfa52314d737d9b4d7b6108aeede7deab47617c4b1ec767a02a52badda17de1050b9e8c0371d203dacfce518bff38cebd7ea7018f5626c01bbcd281a335597604fb47415bffff435cd99ceacbd32b94e02333e366f2608ac3b847b0ba4af11e07fa90fa359cd31855e286e93e4556377c19a98c7cf497c7a49d2516770a352cf7e9ef951c31eaa85d0cb6a1724a147a18ac24c5a5d4fb224319787d50c37f351ba0d400b0781baa4d99f309d03f912356687a201b66c116ea7df7bd3a6e9148aa4ebaf426b9c8477ece918213f70cec875f738c594074e2116dd1d5fc960d66ecc0f964c0e3ad3e329ef67c300b676883ac6da3184fac34d99e6e0656da8e3c706a90b587e376625a21da9cd1db7ee5aad1cba06a5fc229c4d6cc542f8282d7b16539d6896a8913412740decd7c7e95ac0111622f14c2f4a00e1a4d11a29b6b7a8a41074ee808c8bbede5bfe5078eaa3b4dea9a0945f327b7b59159cca4f91a2349f47aa3bc98b4b56820370ca3be959ad3b0fed53bb78602223bcc293c31e3f805057839f7ddb56df1fa369d401a744a1a31275c0d8b7dc6e67e2b7fa9e3b8d9eb3901e961dbc725befb44a38c54884c148fc4a9ce1f9326a7bd2fad1d6cbe9eb3a9e12d61a770a5eb8e632a5c710ee00fb5ca61c3979b1f2f8e02509d0bfeef33d94bb1c5b7e735ad99272b7b3109dc572d4a16538a0cd83894d1b28dc6ef57e505837e2ff98bb21d242a2b35ccb6cae5e10307f2afbc57d50fdee03f273c92d971c295c1744bc926ccae9ed786d8cc2aa288d9a67a77b22ba7938004f805bfbf3ec575c963694f69c62f57b67378534abdce4b9d729613ec4c48e322ce96bf8895d27d568c9fe0b0a60fa15a7c17f8b4f10fe2ecf6af1495109dbe3b86e53cba9dbe6e34b44689c45f0fc7153130028f98e4c0799059e46d229f05b0e5c58938259dc87f6309468f5d37204396bb8e3e1288779961851ffc694552317f28f53f7b9a9a68fb9a6b47addae5e7f1c0024a1fcbb99cd52348f5ce728b07b0747015e002039866a713d2c75c08742d6917603b04dd479890c55ea33ee8d38b14d93395714a0c7b81f56f8340289cb076a03def2abc896219815c1d1500f79c447e56e48a5e6495620ee37b8f64527c09ccf3eebf3938768bce94d0179c47c53db1bfe5f991f66a7e60bf2586cedd2dbd9c54b2c73ad23e3267597422bcd8a970d1837c0446d620119e5c08d7c94b2d0e84c6c8fb4bfc8c56b069493a6a62ddb7a04f3c4b86244ba8229f8501887f81d95ca1ec7d092699bbeab0cfaea2996c050d3e86917863eaa19a1b3c0054f97324261f80e923816e332f3df08fd4999248ce161ab3816566dd968bee8d9dbd6d450509cd0c02c8d03a5df696bc934388a034a1ad86141d046b2db8d003e15208551367c9bb3f9809686fc135c5999268c048a9410366a46475a695b343972d24ce6e5e15a7a8bd97e7296935210809c8971bf1a9cb59bfbc9d583276a474ea39d3a2ebc045d6194b19fd41907ed9e266bd8a34b492927df7192e8ebebe0361bffdf2e52821012c24c6f4fbd2592148d146ae6cdeb377ed36badf48145e38af098fe7651e4c29afcb9ec370a7493c028527b0708ed94dfba91d3a5af87a1e0806f0a39636a978ae149cbb190860b7c347e9a58a3b4874cf5c3d3585bc22e5b9bd6654183d438589e2b6f9492cdab4805a210f8d7e938275ad342b111ff66c42ee70b23a0f682ffe6d5fbb9f6c25e22c0b71f733672ec584bba52c66dcf4f0e7b11f09322f1b0a6e60198768b549d8ae21bf9a26cfbdf8e8e9dee2b5edcc91b87578353d4c74d25969c9b745612a4bddcdfe375a3805a1040f1a951f73102616e5e932aae5a9cc60edcdefd6005a5f69c45cdeb844b79cb67d10b167f4c3031909d20df7240cfb9552358676a0d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
