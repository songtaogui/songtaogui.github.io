<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8659c8dd0e4d99b5635d5de18810c47e008f712eb714a0837241d1a5b952dd54f54e78872fa0d066403079b8b241450dbf99e1994cbe1bdeca7d7cc6794e25971a85dc872734867d7ccac97bd8ee045f9098ecdcdca2c478eca9a5a96a8e10aa9d62bf4bc2e1763d4b4117ee25de742fc3785185d4c111655f9fa9ed2e8903f71fc6f9cf50a8f9ff7e477072ad044b617be04e48cf4b186b8336a9da4e12c8b843f182b4aa04bc178eaac0d1bdc1c0b3918701d30c171910b2920a1a9100f6ed13edf85067701c177a5669e8ca410aaf2f99919480fbc54fe3116d66084a682d8e3256abe69c58fb38a0cfe25af7dc6463e78f6ff475fd088482e406e4d67c7e6723cf32164aead51cf1794aec6bb02dc3eb4b3b00687607f063072577cd404ccdee2ae8cc6db4ca6076d6cbfd43a61aeccca2d558bb7959371dc4a8afa7f9ed1632ad78122a1733984db164e3eccd6df9c562a98081326e02d9ee893d06a94cd073c74f61d546162a9b4abe684b94a242d53480b32b89c4a739e7e2fca376db83f77a8e59fc150887506bfbb9000b8ceded0b822d139dc91a2f0772797a1c2c394890a59b5e89cd3c01fe3cb31d560c910208beb4491b0e5b2a954e6c86682a064ad84d175e7acd364aa9e30de6400f66fd43eb0bf052e56b554e0b2f24cf3aef6d4387c930663fbd17f3c74427c94b246fb5fd2831fa3898bf298768b582297af99365cc3f5438ba8072bf537f3743f191350117cf71d76b7b10fdf3e55a8d7c7bd1ad72ffed899fb69cddf26c70db1dc89583968ad50470820e587d475f1b25eccb8579484688c4818c6841e2cb7b272365153b2ce5b44b891b1843214841720034c7082a99976a2a9e782de7d60849d2b5b99abca6fcb1a4741b05abcbd61b681abadec7c195c5b6b7cbbdc1ee25268f65d0dd58d33920220ff00a10aaf2302f97fed422680aac81db2ad7ec0e57d45979ec847047e847aad158afba1b06fe36fd7f061fb99096095a2395c10d5b229802cf9978883219d685d1ff115e4d59a0a334213e42e67986efbe72f4427e8d46b9fb59d1c998d96ee2356ab813745c6e4508de6f4fe1a562cd69f4cbc21465e600d273d6d85106aeba6769f60839669b0d88b58e16d3e76caa8a69b9739a964eaa33360ae410bf728350b9ddab37876abdbd6ca2be9f2dfea7900223571d4d1a07971bf94d278fd3b0658c4040f715fcb187ca750de94ca74a96052171f5662379f35e7d0f05c1de4eb19c53c0d08e40a642bcbe14c90d78084560fad9df8eef89fa2f0e2b1930263cd59ab476cf6344f155fd821d6fcd65923dc2a36f633ebe5a75dfdf461a2d9c4e15ab9842c7b3b2ffbecafbf31de950d8b530e8782853b513444d430bc3d83250b0ee481428e3a1d68e66dbaef2722218b1d94df5e7fc02403e16fceeb40bc0bd2e345db412dbe9d52b9b4df837b7dc231c9f3b7233b39d9d05c5698bd01d276435cc6ee18791fec3c2ee152fb6983738139b1398c971cf8bd3eeda43c3d20deeac783ebdb8d3c49b7a4323ed2278cb88c55d2252bf3653c345fd781f1df3f6526b7e2ac892b00923988c8a899e246874df4d11c0bc03e2b55a06fe7b1cf9ea89bc24f57fbe3d287fce7d6a064c1b3505d11d0cd9bfcbaf902db1e4927ad0a14978ead064670cc015899a6746676093a27ac3c34f8759248dff32343763138bb48804b18d1998753f0150bd86a520c8d75d140592baf9122ad748ecea84752a62d22b3de3bf6329be50d60bafa6cc1afd92604d382d5ab0d30abf41c34d166534f94f9f6aad0ba7c0e63c8ab6b31144210e8d7369720bc2315a06d943e3fececca53fca325e0ce3466379ff4c9ab8742b99e28e60fba6009a0e0fda71e7061fe398a6bbbecabe247014f56a879ceca08b6432e40db9295ff8f3c621c46f5e9345046f9c7c32647935b7b71d9fa83bc5cb1ab9d186d6c482b52c4e4117f6ba6e2197dd2f04f74f36bf8e4af27b05fc724841b532ff85ddf0e17d20fca0607594dcc7c465824c0b478b7c3adfe8be7be0f91ef80e33f229def3e9e2c1453bda5c70e720e95b91689f4b5d6c251de312d36a6401be15bddf0a9b619113393bc46241c8fc4f384a8e5b56235d413804251d04e9e7638fec98c83463f328cecc2b13be1227013bf5bbb2671af5796743a982cb825e0fbbb1996201d6dad16e88fe900af575d4c86c4796693a33523dc8af5a4a6b5b52927d5cf14472e19351dec46bd3b2c4e4797ffbbb4346a26cf08fb528925c5358256a4f816c63799a4fc230dcccd98f0e32fff30d8cde6d533de7e5a9d4ed16f4fef310e241a10f5378bb963b8e3f2b341fadbc1cd6c693358d988462c76e7d7710bfd29d7dd78940ce0b7adb8dac9913e3c4e3d80adf70a2abcc917f14c5bb72804a744382bee9706053ec30fe3417fba8f0070f14342bd896753c57cb90753450160da2e39bdee955c394919fd7ab3e6053e6c76cd9ed8af41b9dcf6e476da3bcfd6382e69b29e21423a4edebc8e4bc45dd90fd1afb7b131948e95489accc4a07b090fdccf4fb602b752444bd6f74fdb5ee9206b1f6ea9dfdc39026a440d171240f3b2a6bb6bc313b2866c65b78f8a9848756feabad2c26fa560e1ea5ccc76833d604514342b58fdf324cddf9e131659d9e81fcb36944549cf809dd5a7df9da182a0adc3798ff6eb399ad9ad21aa4f453000567bba53d694b028d13ded98dcb0e1b0972604f0f297cce4b8ea45f5207ae6b4287fd7a7c186fdd1ec657856136940391832e0b2ce873aec6a0dccadc1fda5bfee68ff16486d7e3016358f99faf304207dd8d615d9cfb5514a87a05ff437856f380700a38605473259fa7b72e5df36c9f28b25954d45281a6e0aa96d4d5d55f9376281ae7c01e5aa242fb403a9acd8908d7bcce486a1aeb0a1437b8963e00b0bff610f22e5cd4920248070a19f6dcf2a975efbb20386aed1c5ad899fd34cf5355e8d58561aa75b3c80ddb32ba99682275db1bc45848c37b0bdcc53a512e68d577443e53171c8057dcd11c99edd1466cb418e4f066adaab975bcde905575804669e2e3b7751fd686e9007727a5c7b7b8545d0e51109d7da05de55f0b91d371cf4af2ab0d01253e773cc414e936bb4381902eec2bbf507c8cb17b477f719892b0dbe0161d9570204d5ede7b77bd1c4360b568e349e6b2cdb99f96d4b273a68928332065054abee1bf93957345435c0d8021cd077009aee5d4e637d9fd0cb6f3ba1e79dadbbdc35cca9d5a94fa3f467f9e6f85791fb62ebdebe646e2d35448d05885bcc9bb32d48c62977d25c5ffb9c49490100a7338fa97c4f5c62eb98700c037dea727214f6fbb1230aa7f33fb0bab51b0dc9d03687dfcfe336a305cd28317dd05dfce2bef90c3a80cffd20e9d38e1d0391a298ba963efda8826dd5af4564844e227506945618739c97a5fe696e57a216bc9351000306e5bce219ce853ce78faa9e3929e632991e1e9742c077481dd846ca43e702cec795e083a8433a0a509a1b798d4719542ca01bf9566df42bad1113be91f63714f2daa9e61a0772e532ea5a5611c2f88c4cdbac4a5f309995a680519a04bd24b1427acf578dc00a1daf8518002379551fc5b02720ac3cf87734297821bf47c01ca3058618ba375bc802b0efd84fa0817e34efb061c478290d20aaad5c48bb6742d9842fe09fedccd4ec284d7bd39162d6fb5cf7abe5cd3c4cb8b25cecd07d28c94e8fd1b6b4a5aa2eadffdf7c311aae10a1fdf7966c0c74b3c6566f9588b524f07f9864138b774b256ba3a5ec0af2a9f8bb7f931dbf2c548689c26b6a01abd6192851a1418d891f23c2c082025e433793b6195f3bd3d5c05e3987c64b3adcb47c0530d059f4d8c79030cb84213c3f7b2c682e253f23563adbb27d9d0382b4772fa02ab420ecc7918c4fc41b89f902e6e747e08bd5f7347c69f1a64011db5af0b855421790de6716da0e5c3c5b75b004da7b8fcf48fd8eea303e48b79ccc85fd9a812ac51ca361778bd9333df54da80a2441c901ac79d798d58c05f3a2f60276e479180449befed7b80d9a1aeeeb27dfa221cfc6098b3e590e53bcf23663aaddac91de5a1c275b83fa29b1da2dfe9e3bbd228f4f13ec96b9ef679e626e588af2b7072d7ea9bfaec18e0594c6af89fc2ad42aa3f8256e9e87e977b3ffd3ba6b68f4b986c7450c1c1d7e186f585c9eb1b109bc4af4199800b52e838cb2d363bb1cacaa82b78fd939f509953d175ca39d37bd9b918b8bfc42f23f2bd0c550d4498e7a6b3d156d16f648b3a0658a59573f735621a7ace46280b349d70ebaba5d443edfdbc7173c105447884aa422817120b6ab1c6179199877fb3bbe7da8a9c97772337d356df1f55b5db6f67dd95b4f38ca36639866119cf98e101895381987c69d18c4988ee3eb20ab7ac22098880c47974873fd32aa7125a29d2b3fa51ce5829ca88c096b4872fab3c4256458024bbfc80deadaaebf8a3cbecc670c5af631d17d7e3cde36c4ea5f8165b70332f0ec1e774d48726c32be7e1488a8eb823baca0785635a9e027c99dae3a6f5ec34d63f490905f2a1443b848716bf1124a4a7b19f1d9dac0b4988aef055591c3286d413293a95dbf37702ab15e0aa9e58b7514bf2beb97ed18049677cbaa35ef30804ba973b709e62b31fbb4fcb5d8536b0b886a47755309277959eedf1f6f79f37ff60f7b624e6e32171fcbdbbc652d279731f49d4cd38024f0ef80549acf0a9aa80dc150576040805020ab0ada1209d124b467bf64db7484adf8ceb4e9ea3c8963c27189388bf1efd394c4fcda58f6189ea036ce097f1ed70f5d208788d10c1c2ab8f6ab5fbd6fc612a0b0dbc6d4398f57557a78a146b7ff2c706f16b248f50dcd6972e92e56d9ba1681553818514e06aed2b9cfb77d1fd68067b69fc08440c9d74898ce4ad5b6189c1b699fc75e4844a0ab438e20cef0f2444335bda68803200d62a77a301343513f75ca533a3af43f38a6801678b37a550158a0d9fc06621dea703c8f31159a25aab8bb1fd86ae1c23a05975f6b0dfc839bfce9c585fafa408ea92f3b95fcba576b71a0f8dc1625244e1227331db33f8fd9909e05f9154e8146c0f91f6499da1064decfce61730299c956cda24e12265b5fcc78f984aa50e8cb5b97dc665e0425da1a6de38872e888c845342816216733f2e39f1299ee6e799e9182203b7c9e76ea0bdb52f98aaaac6b592c4308f6153e5cffb74a2544cd85f31301d43720724f97ac74377afaa32f15eb87d80d2640f25288377cf25da2d808014ee2cb693b4f88d3b2eccd90b9cca7b58a16b6260aff095a450ff6f38daa82f8b4cdd4d25645859b65630cb96b7895efb469ecae8516f8f0a139e3c40cce9657f347d9f09ee9ac891a128af8791596b12952128dd5047fc2b0a2afd046d9a5b48423a8c8df49d877f8a3bd7329c1934d9d981c85f0e9fb8a2fb20d866fda76668cfec5a2752e7b21b19dfc16bf2b8a5576532817438d492f87ae199d65200488994e1273c3f8466909e86f0a119735ec06d4687b3c1d46307221a220f0f08ad01b360973270fe5eeb1674130ab8a13e16b4e4de2f51bc09ac281c6f2c36326f486bfc2f09edb901613659f7e06c798694d2393d4f2a75016d445c0f51eca361d5a3dfc7278ed7f78c1ccc5b5eaeac3b730113865ff9a50fcdf20ef2c60b7635538c1025bef9689bec1d7955545606919ca42b2724a0f55cb8c3c0d2405f5397f38664fece5b8788e1171bc6cb435d34555db4624e53cdc04a2b2812a650d56316e1c42079824b676df685f4cd30710ed5e0f0a7518df396e03057b43019013709355784323fe4bd21324a370737d2230e6474c3bfa9be4468f21d8753458e374ee680ccecf6b89ea8c924fb38983410adef1841901625f0b93341b5e9ac5e99180865dde8c5b97db4bf4a79058760cab7cac01f1c4e7b403ff22521208cd69d93994387c4de953fc6211957afdef440d050ade69fa55e3f6ba38d9f6edb8ade00f9740ea8dc26cb09d85b8bde7cc60aff3cc9485cf9c3d2ba65d61cb0790ea57917e42a79ac07e76d825ee0548b9b8ff520a5a10ea736ebcf2ce8004134a1e69ff8abd47a7e05debf447b5a8d4adf4eba17b2f9b3cfd75c8855080d3b2937a6920e67eeb8b8edf5bba243a90bc3ab7e06f81797e15eb241ee0f1a4023190913bd14d841b53110b4496508839d711f8b3f3dd2ff20033d8e3233e3add89dc90a792b0411126a86c16401920fb458ffc123eee4fba2fb56ea5200b77de1066fd5fb169508b4db2292624f5aa4b6c37c52cbb5135197e36d80e84bf78f9821fcf4db55fb84ddb3138478ef9e234f112f4e93d3b5e3f7f11727091a65156f630342b878399801e38e1d7ac7ecb8dc63a3896ad9913f7afe69931384845112c766f1fc832e2826e7586578f30c51450276c93e0c6de8e472dc828151bef8bf79ce145d6c6341880fe24e54b0dad79cc2b4078fe8e89c3ff558871f987812153862d8c4f77a6a8bd54c591e255354fe34cb385bd517c6753f9e5242a4bdf2ce39dfa07730410cc678ce03e3c395d689e75d964e4027182e82857b06337e24102eb98def4ab6bd9351a66afd5a61228513c507827ec7f6cfad34429088cfa1865f900119841f1c521c107a2a079ed4ba14de49d380ad34ab126f11b68247768f59faff79c1c624b66aeeaaf00c72182427044ab6a99ce6ec5d09612d2faf18c157917529cda45b668efb0f91e047168d478d57f08783671fd2016cd7a471364ed1f8a5fe56b6709dde8b66e13fd229e4f834f8d29d45a89434e6d580f4bded029519caa3fcd299373b9558a7ee1d13c98568216122d2e2282713b7bf6d46b79a6cac66d6bd1a0f052c64ea086e8ef4262b2515fd27720746293d36a50696a39ce5346458e04e88b6da2d5037b5574713840a33d0f2017bdd39a47ec1b7df062738e795cf3fe5aae35f08d0c48ae64025a1ff3fc0385cda9139efbcd8370ccadb5142c456e29698cb8798ca01c3c273fe3b3b411e8dc143438b283ef190e7093eeb90bed065921b1e0170e3d09a611dd083821eb92ca15d4e3819865be23210f86bc4c894149218aaaf709e48db5116fe1efddfbf0baad479e886125f61af2ddc9d7e77a03c3f902f4007711760a3bb9a4b50a9b39b9ce68671a1cf82cc1892c3250d12847c31a420e3e33d3b02a7602f5a4017dfb4e4cf09710deb0d584a9ac1f80588a6dfab0bb057cb27ad77f14cb774ccb45309683867890b668fdb9d58e316f70be1e0dd923236dc388987ad32bdc612cf36f7639c6115c6497e57a4e60d9a0533b81b754b68b7d1d7a69090865dde3fdf0a1cb1cac679f13bc2aca5530b84f3bfda48db8ddb97bf8e3d9a24ec74eadb8fb379b148107b3b67d8fe61ebb1c476c81f7f4755ef62277f89b9aae3d181e090c443c747228241e7d185bd7a417e91b7cee5b5ec68c792589f6c8a9f2c598453a87c3f453c48b6a203b5559cdea41f866703aed9fc54aa6df01ec127bf2457ebe3478a3a665fb33edde3501036e91dec4838ac4657607b98a77ecb66e57bf4242dc44fd3317d6e85dd935916a1c5802a3e0aa98bf6b490f8e4c8252848027904d07e1287da84ac020e1a0f1fc2911d609b094da27215f4a4246fdc2712eb4a9aed12975b7be4c261a20af70e04ffb4322bce04c3a140412b3ea6295f86d6cd5f52c2c1e83c4ec4cae05165b15f9e2479d2e4d2e11008a2d30777b6a71735ae1f08c772fe7c7b5020fa90a7593fc37a68464fbc7d58f7f98e12a5344ebda1be405e152013ded8d5a3c2b5caff4d446de0e7dd92044bf1c82e93d50a3fa759c9706a977698a6fae95574744cb1d39cb730601c351f4417b9670ac08e3800441be81988c87e1aee699de91fd5ed5fed0a8869932ed669e182b04ef76762089b532b667a0e302000b6b281ca693fafbdeca4a51aab95233caba955a667df4d3a9d3a347143489e102a8ef6dd9a23e05f20c2a822b13a3b0404d7af88e3a26b358f258e71958132987a7597eb457dea890ceee52d7dd21d4a5c56b39515b10948ec043efe535b0dd44de1e46602cde72f5cbd2938914b190529d64b1ddb96b81043a1caf238cf6b1f6c6f0459393d9282f4ffe48d2650af3ae6275c4bc1f6c61b23f0af3fcc5958ee40e447df42d4e3799e45b647dafea00fa0ae385ae9e2f31d498c774bfc4799be34762ca81f31b24d3e54dfc7c28a0059310925feecd5b516a51fca56cc5cbe62f18201f006a56ccda798d623e3fb9100fa288f407092b86e141706e43e5c6dc190c063e5ae5d5e5b3abe15b43ea7fb514dfb94379cce93c77b98bfa75f0242340adecfef097016aac317133b50205bb0e06654fa75c89be5701dbb10837de2b330393ac7e1a404c0971e3d1d4c0c411ecf03b067852b5b92b0b9666fdd418d025dd8133b3284fcc1d004c29a7ac4a139d1fd6f26370735beeb1006f837911ee122356fb06a3f6ebfd1afb1b20e4648d0b77613fc3a6beb2529b6379a82d7e3d56189029f1e6f3afdc694c808c195acc5848e2ea57c40bcf25cd0b60daaaf1fbbbdee5027a7abc7bda0215e14d442654b759ec344d52cb46b0f3da70c9f662caa3a8b501f85b439522634d48e0cc9b974763c58db488b49af23d4012e1bbe71d82250d80ffd161cb1ea4d773acdd9ed80b66d086019e5ab2ba496b1f41a10daa167cfa225633ed72fe5b35eb1b634c5570412fdb3301cbad4a940953b099755354a95acd0077dff0bc0e501d0de22a1711fb5a7ee2dec31df35a1d9690bb918e99951f24fb6ceeb7f4af869b61ba6aec50e4b3ccf7df925d417ae80cec0b99526686c823510da755cf3736a69fab3631dac90b927c4cc15b8d497b86fe8ef0527c095ddcee019f34ea6add0e6d8fddd00b762b03f57ead2cb55925d7663d5886370e0f02b38aafe9a6b1496551c78084f75436b91a4cc5be78f3c7add991cebed43efc153b0fb2e6f07796d9c48d035d533c1a31f319628e0c614c69279f996c86045656941e7d13b2e2d8f0ba96d5600292dbafd9760df426a57a76812b33a6ba19c04c64137f3d3c9ae61b7979c8f9719552e02da6eecfbccb59464146aa0981ef330add383f2f0caeab85d9eb4199a38a78149b7076214eed505a52ba32544e7685c9e113f6440f89bb3d48ba793a238e5b2bdf9ef1967ff5639ea8efe1989b51e113126afd75bd174b58307d8833fd148f6a9437e487da6a9f01a083287d38e1517643632fb9d3c634848b880be010b5c3af56eb79f3c12e12d2f8310f341041daa412731767fb98b18b9fe35490841eb1be0eaa5fc54a51d10d6e1cd3a67f41371bd578eb356944bacf4c2d52eb83147c19a9a3177e5fb3f66c7b441463186738c07538701fbcbfb70d6a8bf58887b4a13a11ba45c037f978a29d13dbe8fb38579a896bc246a00a3c38e98855f60c6e884431ad046a9b11e1ac0f240ede410ade5954a1cb48da3e3f8b3a8d597108f7bf2195fea7f511db34eb79b3748e167a8d9eb526a2e9355ab36396c6880dcb73f991633e8d2ca843f3595fc09e81f1bc68242ff25d596c89b7d942f5b98e5c0ad211cdd952a972f426b00d0738877e2389e27097cb8f62e094b7d19e8c2bf3d8fed11ff5056aae317aaa98a89ddd9abddc555d4bfa2c03065f22e573ee21a04b909b34567f261c946c4c44302d9bf8070e73c5fe28f5e8fcb9d6073785e119ab0abfb0119d51d7db538f5e12c8044cd7c690fee38e2b2ac0f4f990072868b1981f318de279adef5b030d4b6eb10646b6daa2015594da1f03e01b1b186fb83cfc8cd8bd36d737207b8335040742c565740658091e858793126313d42fd56d9018278b0ef0dffb98c6fd2600fa2b3e86e2559ed93a849fd0766e489295838f9af801b8bba193d02bc48f8cdcea0fac6953efe360e287bf9eafe171204acca452c9e16f4de70b74f79e03ed6469e0e427f157aa08bbf9ccc7b99edca7f981410b0c4edb3779baf8e7eac7f1d5710e8a2162773ca466885a97ec33c50c47ba3dd55dcfbbf2460549b5211edc6411c3322b59255b75f0728e79ed40b7a04ead458abef1f271e7abee89a3c83ace703736f0db515454ca4ebb2c26baf0e43d1bd9127f7da753b13847d524dcbf04e8c60f72f5390d01169641bfe50c592ec1ec0e70f674a477c1cdb11aa730b0aac64b21fca1a97a0c0c3b32b218565f35cfe18cf09762bdb9f090a8d08fa867090a1bcf5372a2f02ef2f8f661d75274b79e7ae1b0c1828573180d1a24ef43033cf85c2fee628bc3828a6df548f0bf0aaa588360b5bc2e2eb701e82c0ed8cb7609232b39e1f2e1ff4cb4e2d0132a55efbf16809fe0c0fab70a8d5048bd0f7135239609bc3db32f915d1e0cc2c800ed3ceaac952ef635da111a06c6f2ff047d98e12dd47a2e2654731acfbec851c35b50f71b4caba12bf434fe8f26a00fe2a52170eb83371ccda55306e0174fed26727c29b8d2853cd0697900fa8738b51f4d20ef0f7fc9248ef3f12bef9ffaef5e3906e4f7a99a093e2cef904b98e2c6597adba34a0078d03c20ee0f5bdc1e3c2395fee7905876fde1d3ae78491e9c981169f76d7072a5117e28dfb525746725dc42d24fc41a8ee3d0487922658a450aad03d527557359361184a7bfce1626ed8537e9d62c0a801356318020c36e540e92a56998263b04168d4cb13f8290c3c685cd9de3a3d2e412f9328a1fcd4d593be3409f84140eecb182f9ce175d235875d75df3a49f026d31e899c049fce778955dcc7cfbca940f442fd9f36b2e2a084848bf92cb583ab36251fdb3987cbaf663454f362eaacaea5ef785b4e55d4794d3068aabf4fd18787ef2e9507c74612eb73ba8ea57882e82e8a566e9c85bac5f42573a0b156746ca03846e28be00931a28ac92dc4ea12300dee8c66fa1e2141edb05c5d1c6aced1229ddfcbed1a138619808bd3915f64c834893f15be5e8dd9d1cf9838ccd3ec0c83fbeea02c50370151f8b703c3dea80d3c2ca6047493868d7a72f87a681fff20988043049056796cdda8c2868d8ef9ed2903d8e45a4a041ca2b657e3870d2a79bf08b73d9bf33290a6f0eee4ebf9d03864962a518918aa8d7c29d705a03a80457379b2d344fb85e670628efde2e136060a2b2b80a99c6c4e2ae05fde9a3c5ca2e16352dbe94fd98b12c20be2e4a967da3580537e77c4ed4eb82c293985ebcead37171ca4d876a6b444a1f0652871891e384e6355f95419a812ec87e7f0e7129d3153caba423535f57851c43bffbcfed0b36d4627a53d5ed3172bb5aca431a8ee33946509700b2854a6b3c785c5592b927f7610de435b529dd6965c15d92ef69c0deb793ae94c94d0a457fa072660bbd9e971d6b1b4af60baca0c8d8b01aa1ec8c718de3cdc58d5e97eca7ea6121f56dec7b422959e65f255884fff608bccfe2067802620f677623d070ca628ac86db9004cc95a8353e3720945966c1a8071e5d7aed73ac1cfca6c78d3559d6e4cf5d01f0889ee0887368db9052084842b9a6c3fa78068d1f781e44fde3c51db8f49a8b17be4627fa939bc05a895a822f00010b1449bfe8c5a1a74b428f16b477234757eeab9e6bc8b109b92f59316ef86c46977d689063a11632a759cd3ae018c3c52a7c76804abf296aa0af7495af9547d37397b8c1841483ef820f02c38b0c850abc0d5aea3f4e4c0831c743189095c362828dc62bdfff256ab37aad0950e206e176c7f9d39a5b72bc1fe0af079181434917d04c32c549722c42d30c601a39821184ccfa22917f4424494b1350fa1a23ab159c6d1aca1da2cd0c5701a5403ecf7211c0df4e11fcf0fee8f50c21ea229966f3d72ab3b17b46106f5421f86085969a26608b8c62e09b1163f95123e6cd04a7cb9ecf994ec6790b6c21b40c8fccc151d90b53291b70c3473bf3ef87987efb73e32ed0907160197e33f047e125272dd1caeb3e80dc9fd775de1e322973ed953642fde308aa5ec3479fd7b9ac807fac3675c071cbd6d95a8553f425ef7f341d08b33e935c1f03c43b55246018f0237a71ba7405758d9817229d6d1d7540e50a78766708630c556f333ad7982a8fbdbe6a868554d83f6066d3a0e042a0999d74332d361aa58794b4c72de85324072707914e5c260bdc8961e4e50ad1f65ae4745c4e60a99aa80f923eaa02d21d5d1a314f35be4a309690f419efe2a8a2cbbd913a734638fdb660e2aaa7695af3e506e56fb375885a2f029b73d48eb35555f0ee18caea17fcf4d9e06a6528f4085f14e0d748f6bfa7d9198ecf316d247e8db463ead98a360d42917e7d44264cd2ff7dc13e82658f785149c57aa9863b69cbf7beb4ba431c2d8ac9cc973bfcc12860eaa3c3c1a7531bed637463d22ab98b45ce5b4fa3afa23692e5b7dbfa384c3d6762c7b9a997c8b5276b371c1e9a787cc743769c957c51afe9b6ef5ec72a37bd5b0a1a005d8c242c966860bb18356bb8f8ed880a68d8074726745118a2f8b787887c982d8168d6f605166e32a7ca9859a29c789bad8c2cd7ec6a8f5ccb5b7b6af21e454eb8645f84eb34caa6e2d27c7211e3ea7990c396d5e50596e38bf406045c0fed423a0f3ca5ca3539bfab8858e44d3c1a062bbac987d24c844d077b44f989ef0f979d0585ebb64b06d7adea970bb69a57d72b0760887f6bbb96c0b99dbb2861c2f2f0cec8d3086bd210ca15ffcc028dda152a44bd1fb36e4f3270f716ebd3092b7a41ed4605a0e2b2a4232954499d0b2071d42a6541b936bc22fe8154443f3509fcbe1d6c2e506197f35a3da9c4fe8ca5983cc34408e234fcf519b2a020cec766ca4af56c4833e2880e8aaa02d2e88656000d820bb4527207398fd3781f241ea89dc9c49e5dd9af1dd5427fed9338e89fabc3c91b2523a3c48e63f65651b2bed5cc4f8ddffa2188cfb74972446821804def70a7cdd805b39749e4d73844e0e1917c93391a7dc8619cb9c09c4877f77e9ed3514f627ea8228346aa650c96d61cfc8af8c674f34d31c800a6118ebbcdb1dea2f12f3c27b507827947e3e1a41a7801ecb2982295ebb8944608c8c62f1583a90c04ba5198a64c0b1e7b720a5bd85fac6ff8ff315c04d8c7efb63d3d18379cb05dfa823bdaac513982bcd88c30bba2eeb5d4a48cb085b8ab5fa536cf57213548d46e257d0c59fa1198806dd05911cb8d3828c899e1558875a54f025966aed02f6670e64b18f0ce0475b7c0568dfac47b6762da08e56178600904a787a7ae0c3c9fd4c07850cbd66f4f9408b40cbf70ee3c58c1b4595cf17bcea13456882c52dc1b018e347fb8f39d444e46669118358bb188cd926b0dfb590a6f5f56e6313d6b91285be475bd33206e301cf4d686eda982d66203e5a5a9ff45c7bf446735674d35203a27f6e6ae2f76aa0823d12c03d3daa2a6d1dafc9fcff6a402655450544175051c464bbd55698bf1a08db7188eed52e6b5aef0738a2253c6f680c5acc6479801b1d2d56bb8a998a8468894b6ea867a061a39d4f8719fe7ed956434d504dbf31e1f45afa01c8ce9dd027fa48708be8d2c5236b87ae8628cf8dafb41770b38446e2eb5e53dc175f05717689fce6603620fed29b9f9f85e37239cbc843e717ede6a3f8417c209f2ad8df2ba977f05b4e23f47dafc25a363c5d853b1ad87ff342b8a5e733d4d12e1beaeeab4065efe2fdccbb7b4d4a14d0f104409854d039b40970949a1833a07f13f9410e8fc10f945a73bd212862da6e09ccbb9d06241e7a46c05adf650f248c320c6193b8551a36915e40546ad6c2e4d865283c6996887b5d34a844c4bb2376fc1acfae66cbe640bcbd7dcc8fd00f0278a6efaf86178ae1fe5fbc2f4db6b278b3f38a4bb7ff0d653fa04951da425a812019da83f03b4b5bf14fdda12afd9606f8d4bbdd268fb288bae580530129f74b796269b0f555673e2b1b3e32f91e494c2f6803d23631ae1deb41bbad04caca639dc260e08ae8cf5c360fed6edb3fb084e5cac8f69122a1a00cc9a1cb25dabdb28db4cb3841b9094fb832957ddba0ff67dbe10aad89287d497b541ad9ae71e96f83c9c748cb6c258a14fa066837436bcd8f889bb874e3e50ecc0996e9872fa0abfb48fed93d2db8fc60b60a476ea1af5d29cb586bbf6d48987807e998135058d6ab95b888080b37fe7626d768d97a889e634489937f9e0b9dbd699a671abbbfbb85ad5abc5a1c01d1461908d61f6b935f1da5fda8fd00006c57c54806f079bf596f8c8a78f5bb90920c339d07c6f65e0a952d062b618ec4bf55d8e474ad81b63168642af62bd86e59a5e6b879564f68784c53567cbfac1b7bd950453f2d3f514705faf50ad984135ef224ef47427abab908b9b6e9742006497565638eb0e4fe91c80ba2b91751b6e2489a78e4d1af005ab0bf2912ce9f286df5a76e3836637f27aeb6d1e8dec1a495d407bddc7fd86f466fd89baf5223487819ac497d491fe4160e1fc765cc5bf9b0943adf0cff006bd9a209b4f6711e68cd38e4769b78e295a724b3f248118a97a00c86177d51dea269d8e21a9d1da7b8d709ef38eaf0ee60c2d4343b7545931cf5fa67693d389b49866e8f4a7d002bde2642a71b5c5274ae745b9099eea1a646be5d16f68d1b098dcdd075626cf7ac68d10d74549f3a4d51017b10c2b65a40381af4a3a12c33e27d835737f2e7b55ebf5ffd6471c02f6d04ae249fbd5005a6b8e56cbafa8ea5a385e899d545f23826937a3a8ff16adf93fbc89349520323012ab54d5f051c3561078b1936a0bdf796d5ed74966d927893da7a6ab49d7f9dee18ac9e317d034aab3665086adac587fce06eaf7c1ca75a76ef1ed9e84bd24a110b9d0fd8f34c76ee8d78c5732cdf513b313218d59ca64d0919d0c561b750d040f18a322d2b5196204ac92791b5226ead0024e0542fee8a6495ac1df179b1a77830eecbe5cc96c98d20f82cb404f5a47cb2ffff30a75448b953b036dbed7e8337ff9d93e2f5b14ecf2a765bab2023975da4ddb4b2526994ad9b3252895f60caa9ecaf5e2144e9d229bcb6aaeb89e00d6afcd358b7c765f1ac9d7cdd453100da56fce22c5d00dd59fa467b989493785efe1a17949b49ce727bce2ebeb579fc9ef975febd8d70f16d0813dfa30b7f4f3aebd7b83fc551e201100cbae351c282d98a8e8ab6626959c7988c21111995f827622c42bd38d363eeeb9fa26f0711d7e07083854a41ee7745a54d60dbf1d98a3685d8b447c0a38ffb46a0c5c66a703d454ca8ee3f57a0d41cef87fd9f23745010a35d8c284e64208c08617bc0375a52c775289719a4c1047dc9bdc6d989df7d2b7c3d3e062977c26f4adcddb0ac7716758f0fe8f5149320a75f1c45e0a6d38d78e4b808c8afcf20a8242ff6c44c0f36c532990db0d13817e3355ed698f10d67034a0d9443229c58c5db9938c458497da6efe253b6a7bfbec833951bae9fe2ae2fcc5889b194bd54d704a614ecc74de35772af20a56fd61e1b221c274d6f3bd97264dd1635cfffbba30277949e49995cd34ed75ce5cd08f68420638332f68e694a776c2bbcb9f3faa8513ac2e74a0f0c27dd6557342d2b748031d2628f20b1864713d63806736f66605f0ea0815ab1102cf0fd9c35e3c058e80654025b36f91fd084448205b5e6c8c930e683328a6babfae97f7a9fba320d56e119bd7a878d1b3ff63d4b2e54855851d20320131818b37e0cb3625aefcc1f5133e33d258fd4ec4d70305265d6ca90c6a52bc917d1c7a6fbd08e88c6cc977d40c4de115473158fe17c613cc2a178ec42658ea44b27adfeb8f802af2b8d884efd9dab80767fe7ff25e35abf21cd6abf1f5bc64e1fe685f3ee7dbc0c6d49e38b9f201597c7d53f457dbee96bcce22a14a68b4ad157b04f92d1f428085bb4fc178c1f8d8486e098daa048e48c82e7267d31429e3e6ecec1795b77515ccc1cc9a8c0bb5cdc1ea61005e6b6cbf50a8e8b6f7be7bbf9bdb7d70f898498442f77db83b60da27e4a234266b9a7be344764d9b0b2dc33fe88ee51837b148b313c722f5d02949f0f1d9a70049e461b3624e21b957f60e4279a36433088c9a2104db61e0195bb130d8710fb3e3634a5ade3a982387ffee42865ea3ed3fdc80bb61d4ba4bc329ed59a5dcf8a157fe4d0390cc19fa944eb8f1837bc5bba43f3a0e8418dfc965c1b5b04247049836f6f7fe18eae19490d0ed9e045fec7806eac36f2d3402355041ccc7d466236ceefa4ed5bfef22da2265cad31007c8416a797d9aa9a37ed1de80fd6d27a0edb007317803d8f1a0e219b1ff95adb2bc0f9f58920679312689e511652ed2cb4e86d1e3d797776676eb3a903146e572bb27c774f5faf76e29b83d8338ea3c0bec7c54b83c3b0d490fecc0501140811ac36acfa5ace901d17d4896b7fbc56a824776231393b43a14eec71b7777b7eb797123e885e2bb4d89c47579505ee9bf96d2deb690b19b478fc0c834a9cc72603db6445f447a4eef00c5a609924ee1c4838080691f9c0654e47a92e5c2b923113c560492425fd307f72a28cbfc9e825abf00330f88a7231b98e9c5c5beb16b0bfe6978c25b02734eeda6fd6fc7b10caca5c16730efbba190524b343f7b6ad884d8dc11949060c05d1fefb58c4906e1ce138c02d22838582daaa6e94ff965f82b646e98aa7a2897341213376868aa066fa4d9c8d90d85c6f67ebfaf6d1aa3fb6764ce81a8da30b0daac3244aa5d6d4c8aa089a78f22e7a9bdf132d808aee314d7e815e06da7e6aba002c5fa890a94c2aff3f33b33fce80af107324f841723954df640f5c3b93b9ea3e3baa5782355fc13c1253239385e3112ed21d8c61181a55729700c1adeecdb2cc6159609667e32df641c3a62c1cc1fd3e83b19c5b66bfb893e24b84928833fbf84265455cb2801de0e926aeac1c90ee28b5ec1dce7f05030d05d8c264384f4c89359b50ca50578f629f77998d895de93eaf0d000338ef0b0eeeabc765b698d864a31ec75354306393b929b90e153b3fd36506e218212c1ce7fd05efe7f7e0f9ad7ee8e70243de7b4a5a611735de828fb490cdfcafb0913d5d130f292e9b512c428d32b621a295d4bf932c2363acfceded3f6108d88bfd8007a5b3edc7351ec69d88249d6c247507125de0f152c409ee3ace6b8765c774d4a5ff8faa3e8f53f29b3571e0793212c1340bccea1bfc72b1d704c1969c821c4bc5a3a27a8cd08d911fa832d711399621bbae39d6b8d4dc79b6ee6120c3d536439e531d9e35b2e03e7f20b307667c485075c45f707a58e5bd389ce76ea3cd1dbeff634dfd76e85a14a0f48b6acc7ef659589637dc1055844575f283ba19eaea8860db84702b4686b3f460823fccae3616a1196c40bb32abad377822c3e4404561ba5b5cde660928f91c65c9fe707fcdfe43fe07200c8b0a692b5fd76de9f49a109b2c57072048dcae852d79157f0d99d9af611dd1ee3d49a58419e6ac85919a7812fa3016d93ffd19e3d8dc1f48b0a55b065ea97666f9e0c313d98ef5d6b6ed936ecee090de89fce491db3bbb9009052b54791ea2aa47d9ec31a2909818aa3b5c216f78972c82aa48cacc80f77d1af6a810de3f5275a48dcc718fc5a4c5921905dab515c0abe70a26dced57081023443c313029ecb75d88f51b6842b07ccda0d477f11200fe42842beda140f71a1ad98c62c62a74532bdc3aeca140c31544c26080d3ba1ba43e308bc5b5758e3375ddaf69a52a228074ae6126faab8cc67691e36174c177ffcdc2d874f6d012e66e758fe6e7e65296d27770e5acec114b11a3ea9137a26298e02be8a6f308b2e096f630cb42f7b7c796d61dab7f8b3a09b3868cbdcbe2bd82c207b4705c1ff4e82ad5a1852b8e18b48145755f763fa22ee5ae7cf59188e4771292f751c7cf641c337ccf1d947c0e783f9a53f62fb59a6a17406d9bdae904f84d4cd4e5ae8b0b71bf228b0f716750fd281b389699d6e83eb11181ae79473867094cb482f79896af9bc7d0494872a84254dca38595a5238d325fdad397c538a387f7e849f2241796f9f7f548aade403517cdcef7cecc1fce1632b7aae793ff2d82c1313c1d641e56a1b295f15543943b772f87f6a10d1dace623c3f3eef88fb9a8ea79d75adbd7910d76c76e0b6ed617f403f40c2bf1323409442b40fe85bb91ee881e29802b746f69059baf826813b6b7535f9894bae8549a55708f9d63da19f7dd595783e1d3201faac5d7f2c970349a56feaf0d16dcb35350dee56b5b55d0e50ebe8690c7038a1d07d444aedfd9b35682e32d73aa8159c71a3415643bd351d7bc901674ae487e4e3d561254baf","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
