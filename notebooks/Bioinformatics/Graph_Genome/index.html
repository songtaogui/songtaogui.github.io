<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cccb21dd4ecf46b4db106568807457becedb947d4cf71e940f485b8023c9cb1a0fbfe23f93e3284151c7a8f021e8bab00097aaeadf138415970c197e52a5e329f75cea08dbe18a3117fcdd3a1d55d3591bfd805738e076f1969b6a8000e5ce447e296c64160b8fc2e6c38694e992f98f66e39779527fb4c7e411ecec6aa145cd4aebba0792be52fe1e643a4937358eba2ed3c22dcb1cbf9b4129da9ca400efb6a593bc1a375a1e758dd5258604011493f35b17cdc8be1ccc68eef2a15f9079a829df977b3b9a01d619a0277be3ebb82521d96ce8ddcfac7d13a80c2f473337939ef0bb74b7b29d66fee5ef1ae2579696ae1fd06f4c2cd023b1399de141b3732745b4e3afecc49ce0cbed3e136d575510a7e5df6f39600876ba030c334d007ee69b64eab368e97de8a84315128f210b62c4cedb6eb7070c332de0a24cc6fee793e2b97af31c19ccb1ee4a720a6598e281c4148c50a6c77a94a849a06ee19ae7d9202065e609faed875c5b9939955a18ac796645433ce9242c879493a76b6eda89a9c357bf00ef4aca78f71f1b70edaaaf0dc1351771cef36bcd7c6818159a2d60e69441d1b4f97b3ceadb633037dbdb141a7f75e217c788f653f1b24455ba2ebce4e85c2a6262bd4638ea1be7a133d5f4f1b9207aa1ed5e818fb98a40d42697e4b7e00b1cee64fde904f7f5a421d96aabe000a231d222988c4791ac90d484626c8978f5c20ee8457be2caee195bad65ef6cfffd72bd3d1eed0ea498d7c98320d09108c840a8684b71efceadd17f51ba74d45df005d2a728b4659a22187ec7bd96833e571923d365232a5dcd96cf5b8e1e02a2f685b96a63af826581762895dbc3e27298715cd5e55c0c717d11f6dd083c2b473da0c8c928f0382bbf58dbfdacf0cc2b3b1876772d86908baae21d518d390191b2396e84dcd72e5ece8d85623887f1fb11f71675808c7605f8c6efed11df08da8dbc1247f400a90833e137d9cebb644181d1204f5d0bc698aa88706b6cd070e814778047f65abc55d89313de3e37bd0c56a22766ba02f95b7bba51cf3700c78894ef4fb45bdaaf39b43b3a30499515581ea6133443e5e2acdd536db0a60ff3643b95234b24da8ee0b0faceabefa708913fb5a15fe4e12c8b50d5886f536f8aae9f919fe795aca0d216e46049ba79fcb5f3e8a1d9e6549d56d3964b3d2f9c31a17cfc961740f0f50be21b18cdcdf6b9703aa089b331d95188f23c3c44effeaa39c5e97add16de68e851d507c589f5b9f7e860490bcc703cc3dc7430a96f20fee2cc2565a78ee852b6fa6f1d92d8141dc0db474187b26bd02a1125ffac5e1d40a883f8e125b69e79a8818f502c1aea82917b6f40d31bfce72fdf0a11e1e229e929a6d5d8b0285d754bc4e6313b5d10d125c7940e73a6e626ac30a2dc8c662bc979c9968446a71213564d9108ff04d67a29013962b394403cb262e77206acd779118a8deed72c6f81750465bfb7176301c3f9d463ce6dd6aab08059425aeae6453c552adbc7b72e2f336672366e5fe94014824e0cc99a454e5049fd690a161a52bbc6a0a6ef2895dff2339ebcfbc9696c6de1f02160ecbb13791be28ea3ba10be5ab564ef61f8138d7da7009f0a694535c3730b36c71e35b27ae48e0245aa208e7562efd9eefa6af32f846be53ebe08ec25d4473a7cd7fa2e85c273da6e6d1e02ac213eba6b03a498d4f740bddc13f239f093e3f79b098a2a3ef982e38f4a66a028ced496fdacd9831dd4281173100061d2bc73061b893f59bd59b2b59ae719338ae7a0f5c2d6afd02f8b01c58e15fad25da8ddcc18eea9a0418961aec7c1629482d2f1ab97ac85d58e01d44457e4a7d111317a9d1140bdb14c689ad80becf45b408cf03925dd08f2337ac5adf0212cac1faa90cb8fb134d6c69ea7c8ce3f6aeb24a293d635abc9000404e51d2ee05fb9db46613177285bd442e3925e626fe3e6eb442496e1a013324302c1ca4b63231552a9f5fd183e792752002d6183044353292f0a0dca27336c05d1d17d710130b1e290d4af5e434feef69b411e52d09f0d61cb3bcc81533ff06b278dc788122715acee94db4b60de37951db082392be763238c46a2e27510d14c950ab4716af44d5ec3a570e40be550167ad13f13eccc08e42437141e46d25326983acd049895c2fa0476b0ca1e0c4563e7c51b384a427901ddc3ce8cad5b354effddd19d46de6fa6c3dc9a9e6c77eac3a1980a4cbfe0a3a3d712da2d9f523326d177dedbcfbc4b4f8b097fabe3d6e26fdd95990b75f9108b448fcdda739c0804793dace6ba973e931e55574f96fd81a642d4febc79b63e7d2416811a9d1251a8382ba922505c42d44c58e9a631eaa665cd2c05fe0ead932cd16951bc1908cef1e2556ad1a56b202c62aa9e79d7414bc55c17c82f040832e5fdf0741a52dbc86f2087c2f77a1766967feb3120cb02940e2870e6160081a81f673ec47ef7de7b09f3daee9cbaf9b793914f13268c36417b8769c8662558cc168c134b37a22a53f916ab4249e6baa4cc826e502ef93b98e21f24a5676aa044befb19b49fe2edb566b616c2716f74bd43e2b235418d92e39555098db155715497ad55dbdc9246daf5a5b94c04ec710f70ee46c8a284c14f529c68e2cdaca926fb9269f69f862a8a00800ba75e0c6973c8fdecf4006d3d5f0104e342b70f99c54779395165be9667983540515a2eee2dd4e923b43f975bb81c908e0353d6425b54a43387a6236964cafb4c7ccbeec2c66c7f2f52729dcdb8e29f33d7dd92b6a371e38df3f4b3d2848efeca1e9cc4ae00b832bae7a47c8142e7645b4fdb05fdd41215fe22c13080624f45a57dc5bb771c67f2d532d96d8d9ab8b9864b20acf463fb2e501b46d87346eede886217b4006cfbec91256a0fcd4d61aa89a745fc7344fd9be1ffab7270cff815b66870471f09c0d58cd03620441ccbc92879e69cc597a739984f63d37fa33ee255e9593a3d3ae7aa4a18c86e8933cfa8de65bd2a68b7d139a7a248a25b0c151ba14d67aaf78ca43822683fe247d03bae838eb009a70141eeacfc4c802c44057e55d12d9708deb50cf964da518912071d45867b2ee474b8da674f3958819b64e2c4e3fa97905fe6de3aa3e515e57baa0cd9858cd6cb19e2e8ede020ead6c9ddc3201bf99509fed9fc138e6c42ce2111c013fe70129e28700ecbc25467ec11c5fd424375a091e3df667103408c1e4e6ac298fbf785451b3288ee7383cf95f3eecc256b3804dc0c56005b8823ee57e9bb2efdb50032f0f7aa38fee30d81fe8b060b8731a4c2df3c8ed21587f1e61111adad27a8a865ac761db18b7516cf374763c3ed6107ef297e73330e841aab283d46ac7f99b0a767ff680fffac016176a7aa9293ba4b8500903792ecb5e8aced3ae7fc5a4ad5eeefc631f0ee0c5a56aedaa069f2be3580642e7f3d483ad63a1d8c6d853cfa26ccee3f3a7605d954e943c536ed9551d9e3c3fc6c13044968fe44989a72b47dd2311bf959043f20d59b6d45ce21183db5ee3235684192101b8ba2a9e7f4d66911e977c8efcdd7b81feba72ce1772d8cb87f41975cdbc44a52c2643928700837adab2dc16ea226113e4bec86eec30ff67cf628f8dbdafa5b4c4084c4c8fa13556a2747603def94ca4f4bda156bce388a5575d57e052e2ea167c9962927f89fd358178d27b20c1eaa8eef0c23b3d68bee91c3339424db81b5225570449b42936d2baea8eb914ac204ae38d6199324375e77f5e860585bd90f9d1df6869a7038487dbd0d787d09d105f8351e2cbe623c3407bbb116fec8b8e203b0c05aa8691574618f07e2555afb44c4266517289329b9063e93bbc8a7fcd488acf972f36dde579e6776470684c46458b0672a7a13bc9378ffd24769b96155f2062a9141c760bea9450fb2c0e46dbe57ed2e0d2f3db9eed0865a05bc89cfad314485e465f995774928a1098ba650447c4ceeb9ca0b85638590f485e05013055629e70f4ccb765620216d013b247a95857805acb9b7be07d9e3595bd00b36abffc45c5f382a800df8a8a673ce3351cf725d702f127de184d8927a4ac91c5c86b4732e75a669389ce7e76d095965e3d2889ec66e4bca3dc9620c69d176ca9a76b6a79da7b42d4615156e88e8e6ed9330e7927275923c64edcb58b196e8f41dc67c38a2dd717f08e52857fb4100b1785852a3ee4ffa95650e5516987e3e5bdf80113a9f9dc0dd953bd46eb767a8d949bc11b840e9f67046f218b94d392031aadcca4ef494330c712faf1d28ceb8fdf11a6518c001433affbca3fcc6b2fd31ffc4f8e7f15a0154cf57dbe8db3cca672b26a8b08f8a6259d872734aeea31e111cbb526b3d26c341762d6068a7f27c5c08172e3d509ab1bdbb8822c989e3f173507c9d14826431ad78ff562c4bfb067ac8ca100452be483ec161844b24b82b1b45ec0026ad41955f96e3438ee6f2a7df80a7a98ecc3901d1bf0db8125e9b278f66a70c4c331aba6aad007db2301817c26753f6ccfa66e96edf9a1f132e6d91b1a3a5a50339fd4e221d472ea691395acbf0d8359ffeadb121f81be54b661643b42f7611199490c371e3bfa7dc9822b33b26b3abea7ca25d2993413c541157ec0513721735b303e5b056111d7325b2cfaacc320cb4600b884dd5317547d2acb54b9529130b02cbf83a04c8c8ad418a99c096140e4ca05292e0fdd8383e37b8bdc7115ae0503ede9e53434a91bc564d7b8d0965196a7e668e982b959c02c60283f17afbc6717cf3829b2621ea844f111e091cb1478a02fb43f89fb05578fab63d409506454e06313eba9b19975a97b3d53880f9bc7fb12bbf68cb18e0319b9bf8668fa23da67aaaebcf2a59cdfbcd3e66e4eff888a5ecc3ff2f7a5aab243ae481f17ae8d4b515cf93697dd1dcfb253abf6ad369c85cde298b824f809031dec7976798f667b142d6eabd2fc6c9ac22c086c50961e17d82a5f36c98da17ae5938525b990becacff67572cce0a49a1708cc6db555562d7b0a6a851174e65932fa87807e20e206d396de8e7380c7651889a936ffacc0144951c8e0062f0039187e3e2bd3d189a252822f0d354747bd6c56fdbc39f7abcfcdb9424b04beddf90d21e474eae0859e681eaef3dd0223896455ce951992d2c16f5a0ed1eeecd3552726c9cdcb0040dc9b9be42f300d80521786d0faaf832ceb7dc7199deccf585737c5a39626856795ad1bb4da70978d90a1f19d1747afcedba5984d261a454f8e57bfdc4b64e300a85342d544827380cf66ea4ad5fee5a91030d8c40638a20fc7971a42426ed917c3917198d7beb0e9bbd386398a87887f5e81a0834ae1e6df7db8cde52dbb27c8d3e362f54b01d3552706a1cc36118022196d56fe92af7eeb69bace3d0f5b3804a95801e198dc57ad89677de4fb43757bc5567ba28b9a3715f58068152fc9b6f29ca90e359e90b53cb2b9bc707874d73f16f92ee41bb145d18adb9a7e0fda9e2262fafb6c7cbf80cd342ec1547af290e582a86b6ff610ff0e4d06744746124b36d17edf18c46a62d71b6d82833b12f8c4fc85ea1c70543c66754081cfc26432e9ab27932900a764ac69fb7b702a111399d0367efaf4df465b1aa0806f82c778766c8a3b1791d5804c98b7e60247c374418c35926635318c4a66a1ca108df53004e7a46053b968d8008b0f0f05264a5413d6c62472a39b0ff7e6b819de19312cdded084260c361e217e5d1013b7e0664d39cae3eaca772a91fd8aceb149824761e93a38bd4990d534416283bad3b085afd11a9ceac34880898c1568b2a38edac781a6b75145927d3af68db826dca8fd8548e54b8e4a7ccbe31bfe545e3d83e90939306058560557f5ac1ba2e01c265aa087c0f7f4201e79f3be4d560de092abd652a6487d47f0d524366b76c1a2ac6dd4169e86ff75f1104159d9c990302ce874d8586f72bf7ee08bf9fb91aff3786ba0725e4ece7e6bbc5461e03853d8b126c95c3d538cfac42a3dfaeb6f196a8ea1cd9c95ea3db56f32eb706ea8d1e0fe5b5d397e3e9b3a17dc9fe279afa193301c46d5278ec5a1cbc4ac53e3dd146f2c53ad54a89ec6426a511c1c38572838c219c4b9e0b68ecae8e8867f525a0d490de4fa459c9004d44d81d2041527e1047d4b05c19a47661fc56bc27879c4429f4642a41165032fc0dfc163927114717c0f316b70c14f9c68d5dbf5ba244348f4967832f60786c49d24f9896f4889efb18b1f366f7e77d0e474ac688bfc8b638c72f3811077802d6fcf763f45288861d397ea5e1e4905d60d83d8bb7e5ff5a0abc0137e4d74325ce5e1bf5efd060b734419ea216841fa8ae35e161d316f79a2a1e0bc8ae92d52a938ae0b644f914dba81e3d42cbe76ca493541f512b7899158cfee52512caa9e8beb727c9d41b1f745c84860e3dca2eee5feaa6e3edd247176ab1a36ae174352358d04d9648b40b668047d268ad852251636781a10a0397df857696579369c0ab8b8489ef64b29f4f987d1cf705e25b9b80c9cdfd548d97b91efa6538e7a7c70b36c9762525ae0a6a7295f083123e5edb43d7446bfd6883235b6b8d102845e5306744d3da7f130d897e989158fbc34b21878d937cc47cc49a5b0d1d65356d6c393502054b504dca6a63f685c467f8ed89b376e82ad45a02ddec51aa033f3a18324014fdf40e9729ca2b86c83dfa0e7cda8f8fcf8fc0016e00739e73b3451aef7707405bd0e04e69e3d08aa5b97a4770fca1966d4b7f373d4e65f2c965089af52247ff756601baa68c8d50b0ca0d05fdff0c93e3886ed23fba691c3cc46c29e2ae781d0aa8a8783d3b690519fd6ce989d4c1ca1b601a7706d2c4a1b70bae017b4174beb05e3efff07d3b05f81e6fda4d04d8843e50e1cdd170937e000c325c82e951204b7d753e727f47b31f7ffe46be411047e68993271f0034f358bc017405566befede272896c3f9b7fb0b0f67b95995548a41c12a05ee6ba3e675dade71ce1f99a9bc601bf1e248c1468e65e127499cdfcf65bb9ca7a47e5e4b17964ad8c88e2f8fc6d35b5c7ba4a62b780f09a99216d587c4a2b79a32beaa2e4fc52ae372f8056dcb0a0efaf8ce8256b37b0270bcb96794086cdbb6533af3024b9b9446b3957d8474a93fa458b09abb8d1c5b392bfaa63ecb3da45e01d2c5b5197cb760c58c2d1bd009afd957b6b74b4fce85462e6154d21aea3edeacb1a6721426d48906c2096704b17f1d6467bfa6a1904624e352ed9606d45f7a04c4b7709cab30e995ab756962b8f123d48fb6f712bfec1a622f6fbb5a49ddb2103d78350f8c8ca4b3c24443852446a7e5306258047cf7a986adba9a6465b4af24bbfdf5a83cc15ddbb66c502ca47c4b61cb68a2e6b709524335548e68e5385bee76e21a70017a5f35117c544762a431711b159bcd2bb4f0983a026af0d5894e2aa17650cc4309593a4d6a7c833d2524f0b1a48c1e854bc90ead84a4473804518b233bee0d030e49440f9705383f90f3bb329176d9995dd87a8acaaa0d98aa18c0f12cc9c417d26c2b71cfd0847d6af6bee1f217bffd867cb48e17cda13c923579d60342d1c3684dad6892395a0b2f3a62822e4cc9af9d1dfedc5d18aef90675a36738148f0800405c2586c23fa8710a90647c2326b3cea5bf502bd0ad864267536b63c8e521ad091c98be04a5704cb08a4c9ab51ffa2da564b41c4a2f8ac30e0117c3eb8107300c8b0af90763879a26579355882650a8b5ef7c4c58eb890e1375d26a6491622743c02c31a7fbae0268586cf1d6f6f430038d0bacb14f6c034575062e4ba6101696bec245ede8db0a0075e58c3ca811ff2a43a94b2474b3c16f526c8d7d878f2a21e8f5d17b34f7713aa0344e959047211aef7135c88505c3fb25b0a4fe51afa59ee9969431641d7c168c8cf0809cb104c26abbabdeb4522fecb1e197c16936fb998e1171079e69f6d3e701070a758cbb499b11a0510e1a0353639faf4a6ba2abc2686996785b60205691eafbef6e09f20a35d92ec0ef86cbf4bcf423cbddf8cfb05db07e69c7abea841c0c8588f18986e782250a065e0d3a1fa0f4e5718ee33cc83f3049bfb2ce57625242a0d2b3c909815344373dac38a302f36d7ea867cd9d5ce08bfb86fa5ccb88ccef045f1f74c53badc2ac03ef37c3dd9d81a1c340b96b02566a52b4d3e79bf5822596b2b5202916d3d15af27e1247218afc5c108fef6781eb1b0c3a1f53b3e5daf441935f02a32a08569f23239b3e7355fcc690682d14671afd55e6cfd11dd0c38894bffa0c50044f967df5f8b25fbca9fe55c9bfa38274c4c4cb46ecc60196f82c048c1a0b21ffa7faab32a0a2ae6e680b4e0476a25635f5b07b771ddb90cb624b9b40a3ff0712c8dfc0b8f1b8a743d2e1ae2ad4911f5b15f0d358138e08ba759a214d69b1c31155362c2f944f7ed1ade405b18e3dc0b56b7bb9448dac6344f404c6bae950dece13b7e576a80c73a48d96f30d655fb8d5a4d960b8cf0d3551b8cd17b708ce6f966e2c655019f0d9bb315935735782d3fb4c1957d8ed2e1d9e7d7437e75d146f4a01852126fe81cf7e087e735d2288793c4eff1d4112c9c55d57a2110ff3b2f174ac1227500bf5dcce5b2c5b2d180e9af6e2e8de4e227860532e50b1f6273fe04b56be0e161f33fc4d34ae3ca4e8f127bb8dde9e2eb53596dcd6e291b3f6adcd195bfadae68943885de5c20e0bc6db608455a60f7d9b25d32493c0af50cc4409edbee6cf8dd89b383f7def4fe322b4792e294c091bf731ce5467a286f24627bf9c8effeb34e38f7e694249afb82c7e7d981f1e042da6e61e172568b944296b3f63393b0747b1c8717c031b493a9185fb36cf82388bfdab9a6d6e64199d8b92744a457e51a7bd747b4b9d44d7cd4abb5a405be7c2b399793d4ddb22d888fb5234b37cc25f9b7950d60d642ed112ac2f5939f89ef28cb9809263f738d3139257488df9020c8e58aabab30acd627bd519a60dac04c6560a2f24ad588bfee2fc6d928e8fe05330df67f20ae83eed465a89bbcc98c8bc0da22a8dba184b5ab0ad366b0005ff3ea43a532228006816824a1cd555ebdba38eeb35e0541687bfde3abb5e8a2915783796f8aed8a2cb4af8ec01bd98a714b5be165a721e3b27608845aaf4dd96ea85ec85e4a138ceb0d271cc82ee07cc97829b968b74e732aec21a85a63298f19904d3eafefb58e10d114a787beadec5a2bc116678b399939901bfa5701f67ea3e8576ffba28b01cbc68ef3da97fc91bbbcb4cf9e05573758865aa3b28ea4ace52bb234115ce2ee8cb25d15579a84a428bffbd3e3545148e58e28c2d5a46ec5da823a227940eaebfd77f1428fb29c6b5ad0e770be41ba84748e8e768d9f4d9b332803b40863382e631699e3b63b709a419e3c1340e4ab5040ad9e5aa501b596cdb78dadc138a19cdecc6c9119d57ab714f2aecc5cc21da92688912b2f3cdc9fb450d304769fa0ccb47960c2127ce64db5c5dde343398a4e180f9f45ff7ca338996c1dbcee356e72fed966e1c81acc4fde30504546dcb793a6e989542ba9e7a86f04814036428c5e8a4d43e9f1fd30ae9f5ac77b7ce48fa282986ef18f99d939d8d76de77901ff473c6120723678ab51c3e7b34d2591a7dea9ba8f597562f6d981bea899a8f6da9ecc6ec0f74e234dd77d65032146d48343b3f31f2e49fa2a163b5f9dea62f2274cd9f032c697c7d4d7add86f3f017dc15e985e53eebae423c56230d174bdf22a6ad231365717d8a2dfd3ea84e52f3e22bbc46423a2e08eb77ab467cdf8216808ff7ed2ee01212b6529313556d5444400ef36ac6e5f558519410dfa5ea29b19f0bab11e9fcee3f4299257b027b29e02bc2fc4748f04f52d85ea3de2277304d27e2342db557ade0d5ea45f756c9f0d8aad60419029475ecee72218019c623d8032e9babedf4acbc1aa2e3139e0954f75ef75e22aae133edf14e98d02049c41457623e278e36761126ee6c3edfa18eca6fff6531e138916d9e6cd7ab37304591e1e94b7b58602fcbaab5d9f7628dc5b7138ecf3933bc4e79c0e1d4be559e901369e47ccc18cb02aaee97c50ceb3926d31f5f1a53423426fb3f54d0fb9ca63a8dc1ad9bec99b75962432eaafa9e5b2a21ae55dc66f73574efa59922ecaeed0eea4a5ec98e775b4de3b35d1e67fdfc4e0fb24a86bff429152a66ccb57cf48ddc47eae9c1d28edc5abe9178eb0669d118d7f08fafda3cd7070bf31f5860ea8506bbcd7bc2e7eb35d378558c3b817c4e13689bcc4358430f50891a314605d5f731891be55b42cdb083a44ddc6731abddf5ae0411596f302fa5a9802101bbccb0e41dd4ea397b01febecc00cb8694bb7e7eea3339a8b046cfb2f7400b2ecdb97cd501dc71d6f0e8f87cf863d301fde72892a001af9ec60b5da6b06f55baa77d0230a2a2a5b567b5681d53b003e98bbf34cd9715984bdede4e09b4850dd53065a9afa14b82d7f8c706d8fd3813246dd9557a22a3f3baa6cc82fe647729a634ac4902f8421e683751ee67c567bd07136a53965e547770f212547077e09addb215e104768aa360b37f53be44cbc4af54807c5d55d3db8093d36bbfb074e0fd31a842419314c5ae6b94587d4d58c1d0caae06ff47db53e6fac3ce0580f49e04ffaee5c555f5161e78443cfc3afa31663409e09bdd054152c4ded66f9d2ad3076f07b2f5db37d7ab28d107afdc772431b7ef41c4afbd09807c8b92b63390750e68bd8661629143f878fa9c3157220dc8e4aae76bff0b6a21153099ef4262d9df1a2fc33040fbc5d8e63d8f5bf94d18cdd389eb73a07b413c07bc04e8abe9367e24978711c13bb27b814391b8702cbd7a95e7c57e0fd069fe7e1d4fc245f7a1dc4bb32aef98c49c1a3aa8e0b3b54189cef44faf93cf342498f5ca54e61e21a75fde6ecc8c33a72b07717acb423906810286888728057dc66673642fe0e18ee14df5d9989d409488561480d39f2954b1918537854d889f2f6c4c8191aeebe4c5eaee9b69a2ae9b295c576e62941e6065d5864d0a871c26d0ebf2f4ae7f4cfc2e76c8e4f469aa15e6366266c6ec709e475eccdd6f107a98f66cb601d25abdfd1350c55371c0df1e4fe61cf565f47e881fd5592eec4c8f13bfc030f84e7dab18d8fc7f10d1888ada969947e4165518c9b690e4db2b18d8bb116a90b001246bcab29fd82fa643eb688051664fa8ac750561673453065ae8f153dd7761f7069071a3983f1d1622cabe86cea513fd18fa567e34492c1d8f3556d06cc2b6ce9ac0ada70d8d4b65e276047fe0b5822ea4f7c13b949fb3168d1a9ab72aad82519269d1e707dab7221f42d053a45b6a5937a112133d9eef883227bb85a03f335b723ce50bf839d6d432d1e1ea8915d1867e9f9ea3d52d26880cce2f65946a7f7f57e45f9018c4d0ffb4d4027ad7a06071b5dfcc5b3881ffcc0c7d0320838fc67aa95f9bc4ef792f4d0dd21ef748ed40d47922046b985fed5ab956b452728580db1df79a150881d048cf585466d4a25a62832fdb36453abd36addbb0e0a246e0929e331048bc45b63a2d7a1ab0b3eb9632222528f783f4d4f1fd9f008081e7a3ee3670d6435d740ff4c6759f261e5c789758ede3c20110ab17c5e23b0445153af3f8d22395969585646decf23f20f8ccbb02db9475ea065d3b6aee83291501e99b1aa8b271c43b4c05ae575914c0f769891581538b8bd07e8c69ab6c78e6222cf8c509cab9b9f067efa8b2c6bce342457deb22cd3eb4e162b62b2a83dc284113f90ea1b72b1fdb0cf659501e3d1aced732b873fbb2496be5965d92339a3f75fcff66d4869f3471304fdb7c6c6e58282e3f135e64bed450fa6045d00d79e0c691c4048ed5be398e4ed01ff8747feddb010262aa00b4ebd274e2e8d9eb81887b56ccf2b55e3284f0465efd2a5f54cb055bf11d76a9303b1ba2c694d133135214c40a422e77dad02dc205aeb61476b47aa2e624dae2e6808928f973980debbf91347e2ebeca52c51f46a43967dbf8adcaef7dbd849e68331b08872563886fb9798494a661c8b7246ba613731eeef5d3a00069b3b5c4b7c9690bc0760caaafbf0e9ba4b6c066d6a9d13d1b6c5e367608814c754d2be5a77197c6fe4047f837a969ef0f595a3dca2731ba7481673e8c1c14dbdd6a40a87a9ab9e43b11ad3219e5e6899af9007d75a1a7c46fe9632703dd0cddf23b9316efd4f087b4eb7a8c99842c86101bd4d60cf5cbd6da2e0df2583cd91f3ef9a02067d8b7e376ef088cddf3d966a18571c33cb27dd91c4b7d0c8694443b906bbc4f6a7177aa255cedb41e5c39ea7249084c3768e3f119ff256d37387650e51bb40cc97bd57b922574957dd680fe2a1190555d510a826c76183050fd8e822da93cce89e489608fee785acac7163fb8dde95b01baa1a927472437cbb78394529aa61ceec8fbe8c2a3c05bf987b9a9b1a3b4696e764a0f614520fcdb7cd8d73616192b6c3a1160b7fa5af6b51ad58d74ef830aa01eb10abc6ce7a42f134b9e99669206835776f0b6027ad45a473bd246fe40c74fe7085ef767d7aef57d6c531f2d1877e28c0c496525340e7cc0b0b33eca4ad692d2d9467871482ed2b4b9c87756f4aa93472a3569c288247622e3381ac30ac8c3c075b41966fbc888fe3c5d10e780a5be1e01a81aa31518aadf9c6062a9a2d5ca913481286df1e10a285f176d2927e716806c5d21af0d50939064361641bce1f3004d930dfdfb114ef39623ed742ccc2855825e45255533b0edec6e4c739d5d804f70d1345c25bbbdd17dc7af31cbd015c5837a2f79958cfeb5503d49da7bec11069fbf7a2f8afe8882817f56d7a79f740e67282389913c8fc0cb2fad7333ba5ed8fe9ade751f6226b41cd45fddb2582478cc4c18d895adf61462bd28b2e52712831b459055243d7eb84f49d5a21d6888726a458f66330c3dc94da554a3fbbf21dc8ecea041c62b33d38fda49e97d20b63d4a2a965789d895fc1d7b83e31244e1bed0b0e4e7d599313cc7c6b24b41ea64614ca119fbac7ffee928942383d3b168383efd7c2a9c1378439ce01c752e58c30189f60bc300a41ee2952074b88e449c3df83388192fc5544120b2cc3c7430335a848cc8ca0e37121becc3186bbe5649eb53505da43f5ab76c8539b25f115f4b9f34543c6f9bbddad8f51102ec99a777aef3982a6ce473ac27d1900f8eb8a5bfb28556cfead471de738c486b3e1779ad4e7e1cc34a96b0fd9c535c3bda74cda95453b776b5261c9541a6af392a95aeba419a97852cd336fa3abf8507fe39d9e492cbca46ad8f364853aaad0e896076c31d45d6f052d5a1a397f3dc85f46756fa2c2d35fbd0835a7d30a367f3959abe4515f40cefd1e6004bf0408b018de42a5a676887dfdcb07ef5c34ddef1a0dda81c4c97edc985b69af2748e007c0c7ba5a75287bc34f78cb45f13d8141104beda526062ff8a228736a94529719593cbd7d49d32c4cbf7927b8176acce55ee396c6c1dc4ad2fc530c5a99246b5f4957674381804798ca1abe596019e3345ad61595af9948c005a8b033088ed8855efc38591e9f629606d34702351aa66177405eb6609d0a29a36f5cd20019d1dc8ec88911410707a1ca0cb202e9761b7d928a28132d5f7c6aea758be5ae4ad8cd3196757f09192e3040fac7bd8074cf89292c2654b2ccbcc1d2c3a8414b15948014394408dcaafdb3dcd0b9528f7d50e7facb35db2d4650a199335f17e33f1a6dc71d0f930ec870178af7989d437653442339687fe787a6ace7d42136050ac415a507323934bae9bf35bf4c2ad34b47ddda16af62acbc460292056fd619c4dd6a34aca5f0f99f7eb6227c49e10c73268e7a94c9cba9af87e29844ca9c23bf521d1e3889862ff103491eb3463949d17b44b232b56ab0594c03be1abb48645b5b7a2413d7ff2d86aa7092455085f063b40c2eb87226f5d5edc42f9f60c56859a6fef521cf18b95e3d661356e8eacd74d595c211f4359d586d3dd3eca9ece4fee4c4a9ac43e812755bda9ed9b1b674a871aff8302257f031533d152df39cf0c4885300353dade28fec2f98950ab70a5bf8698e8e0f57ec1bee85affe4a78cabfd5cdfe3e27bc93ce432adaec464bcac5eff09db178e5c13ed4a1073fded2f2674b2448e9a3fe5557ff0067422b8eb1b363beca7f1bb01f810f31a0ab14d3473136fb70b4fa191dcf1428302afa5005b058fa387451e3da6b00f432960c60a39de4792c43c9738128147533b4deab3ad0b7e3e93175171aa1ed135a81af7c199d309c8acf0a556f63be8f7dafa823579640bef8a27980927cedab9ab579cc6402e955c6b2cfc8d0bb5ba89e2d175de2ecb7d885bcab26ea8e1f7f9e9d14ac2c484fa34568a50ce80a6b212edce2e2b8affdefe3fd067e8a252e3cb65180492cb917d42ccdea8725b7d756a80d0ad7c533badf24782437a6e201918000a0ca075c61040d109357475164d10751625d11c563d8885b624c5666d6f98eb191e3dc7166643c2266617fee320e8c859ea53222f104090d91235d83c73a9ac8b41b0ef4f84cbbfbe70a334c95f5ece85a16dab232c8e8887d9814e001a1485b34ba546c73f336f9fcc3181ffa1431dcfc2c27c785b212434d64699ca23db8c6cc728484ba0ff961149ac53ecf16ea4d183e6143802f773d63433f27965fe098c1769de3963d4018862164d828b8f7eccd02b93d06c95cba6fd57dcffac7257152c9544e02dd365dc704328029fc3aa9c7b974433c3bff959cc830d9ed61edca46a4d3eacab2c7cc14d9c17c26cd620eebc05b350ebf0f0def5d7d3617eff3312c25662a8b285351da5c34569680e0b21a6aeae1fa2f2d6d2eea4aa9b8c5e4e6b569e3a1a03e670ea93fa78f0167afd52b9ffe33d926342fb6691421dcc58863d89e19dd14f979d701d3e048cc34c2e173c63f941051fdccd616a4a393a0a7e7841a9b03368f4fd5084c2be0106c17ec885ecb223654be6fbcecc3bbb2f062cf311cbb1f6a6598904051b22e67e4f7265e887df17ad2705002a1e76f81f9fa37e8716c68ef6a65b8e6ec23fdc746d61a7b51b253378f29a633d21653ec244c2222c18239adc061664b5f5c55afd579b047ae5a0a722fccc9aab4378db985351b9f8457c908d9122b907366b6174b6833a3adc98611fa1e8a3d1897f68287d6dff856ec1fec65b063fe4d02014793b52a88f6e3b0d1283ffff5995ab6cdc31f66d8e84b1b2e1fdfd2ab59d69bdcac0e79bf2eafcfba08a3d20f2266ed9b3cf291c4c0193198ca6153ae35d194b6e6ca759c8a0abfed75746626abb2ed51d2d0a8f06e257e54fc16f3350fb81697eb4e1db03a629a7b5a8fcf027cff30fecae000801e14242a58fc1ae7f70eee5da7515c17aacdcd6d4ef2f78fc3ea3c14f66eb8c60a5186f86cbe398d9f89e7839b2261f294bfef71e2b3f697f5153c35ea5b1a82525aff8365968608d2b5febf9f3ddd62df6fda2790962d16b449875a465728cf949fa5c343ae89489deb104ff3737289a3b162ea079debe92471139b06bdd3ec4d2b23e4058ccac1b88bd9b7bcc83344cf74a423afa087de22aaf79d86a52b5372effcb6b4fb9a9aa7329640059405f614691ab575454244f1fb7150c47d120e8bd2c71370bdd1a46da57dcfd8b7a33abb1a93965e54ef22a94e9dda8b8a40488a5985e29d74ea9098a452fdee8e629dfca4d633581fcedce02efe15c0d52c8824ebd32fd58483e6529f184f0da34d23179df20033d5b339ae489d373d76ad25f5d8f83479c6bb77c9ed53a441c39bb4191c6e6905dfea269240b31c0e45a5a6dc2eb05315fd1327c22ed10d7bb20cfc582786582a3a1b9de88f87286a218dd9aaef1d58b1a3da082689659ae73646fbf5683bf1bf4b02ffa6d25cb3dbc5416469c448b682e3fb78e03c45bde12e981ec11334e623a2a35699eb62188a9a934d7884e3c137924776d1e5db8086eecd749d701986045f824f237a6e474f821e05b9ed4c7340a32f5599086c2a6bde9ad973a564f1ea68a40fd10da47f227a69c356510da265fd447750b9b28e4d1f643f3451d878007e22f8ae38bf91a953788ff1de8787d2fdac1f26692e993a4ac0260158529df42a4f7ace28e8d536cbdc7dbf390b517b06cb2afc2349638878f59e4ef63a8c683df57e8e7c4e2c8df6699b3cb3e66b3c5bdd6b7feab7ad855e81bdedf15dda11717759f693bbae788658541aab8e82d089bcdc393d7b28addfd053238f52874dd30ef9101cb4afa78d9185221ed31cc03d49a863ffc5ab401d3ed5ed99398a1c54dbdaa548244142465a22074a58cf2ff0e8eea2d1c586e134477a4ad408d68b8f7600d74537142024baced0eaa6ee75ea149c82347a438cd9b4ab31cd6fe3adecd7c0c791db6636ea43cdcfcedc9c4599b3bd2c8012d8ad9ed445ab7be20163a51d6fb4fc0c549c6eec6465eee16882bc05ac21b862257d191a6f6e6427b1c97c93fc968f510e2b495614069d158a2f50b31bc091473aa17eb9f454d2b11aa2c70273c94c392c541de0e48a5564d3e28917c28591e60a5437f15e7103858a87b84b6fe1a8cadc761bdb84b559892a9b3d471877a5bb5368acf1232047159cd463e3f76c19200bf72e3b68d0c108ec44777bb68670b62fad6dd00a564a2d219e42db8aacb7a7180c0759d6a8409f090fc80b9c01f5b34d5f3d712237ca0e05ab03d12e0534da2566a4a4b5d43b7c97f2f953cb6442ada9bf0784e09dba747535ba828323d0e33ee480f2256fddd0523825fcb2335dd841dfaed579b0358a44434ba68c814ff4ed0652594a1583172970acc36d305e68be923d46bcd76a04f14a75bd9af947d475ba3f150f5ff4da4753aa2384de87bc32cd52dc1a93cd2c61f95e2cd129852e5d98db5751a53029903d469af9d5a576cd7e79a474e32b16af46ab9ec6b0056d4b7b5e7dbf7b97096b2c687024a3611dab63a09f2e89ec616852daa34d7ca9442509650bcea0a2b097d60a4c3cd45d995451d1b1180bd13910ad8d56b08d138d059a838932fca6582ecac81641ea390994e419d79e23e003c3684c4261050f05b45808f15ccc7dfeeac42234dc0dc5c89d3df2edf15bb7ec693dbca01e649e17b9350f2c20842167f7a11f58bc4c2e30058b555b58e60cc2c7303b0ea00ddf2905ca7b0b06d8b34f7a6ad8ae57ea3e9f4268a7dca79bf9a37f59f0073bbcc453f85bfc6dfe8f6d64bbe3ed36c1299b953a827a645fb0ce68714abb06a13882b69a26699724d44200ce054b656a0e3b0235107bee87a21f118a3b0324fa9f8b2cf2edf41becb1e990c173668fdbf9df754635776ea70d1100fe34356e98d866bc90499b2432e4d341953572064e4e4623a0cab030dc9ac4c59df98c2930c56a309a42765cf23ec24ce27dd1e616c5954f6c209c6bda9f3217d31a8b1152ed8c318ee74d7ca2c8253f14bf520f8d644bdcd90dd83a01bf2b46e629af2884f358bfbe9b38f693b81fb86c2a1049b0857abb977be3c3ecc780924d7f8f74d0c9673fc310805a6a6c1082e2d795d2781018ef297cbdd6966648b0bc55f1eec224f35dccb20a8c2097ee407145208cc9824b03e93c4640a88051305bc2f9288da7c0ecd1155321e237131a03ccc9eeb441796e9fdd7821e2a9727b1cf2fe2e4db4592d8ff23d4b785af31ab97eeedf83f974a781c3af0f366984733b64d431ed7d2ff016414cbc9b78da71a42b39b77e7fc08ae9b07eb4f19e9597e818869316b0744f513c946340de2eeb4b0ec855990f096c7a9f641dc7c47fae45a0cfdd7818fee94a29b11b3f9b0eaeefd735d0559f7adbe57d06e3188159cc251fbadb6da5ecf49b8161dd0ff745a62355afb7d2e8be967ac15f76442318738fc16eb398ad40fdce5bdccb7c4f2eafc997fe5eb8b2228a607b591dcdfd8ab47a7a60545f13c24e95f192ed29fb669aadc96c13d9d832f946a47d185280559160d7faeb04eaa88b094f020fc25c88881a04c39dd18b1d189aab28562e86238d7818017df76d2b20951ed71b724b6b27750148455149968a3a81b442b4475e95eddf2b5c23d4f8a0f28c1a3119e8cc9809656d48935af3af70eb50a33a3f52dc1b2f98b7dbd1f566ee6ce0ab8051b293a5e1dd675974dd665cfde6c0f91f67a599d9eb9d71d3f6262cf73ecab50b0e74535f9a8df4a90a521009d477dc014787e23843dab0f002e045b473dc1bf9b5e2161b9d18cb0c22c2bfde2d269361bfb26cd5c47ad63e49bbf046bd0b208792e5d31ac8d7a846c750e039cf2abe7f9806ddf42952e3f08c449e9001983572fb1bfa4ff258b08061f62be813d3c9bd4e5d7dc3dc5cb3e2c5a6f71073719f5fd2f04ce37cbe4761a5eecb4a16d66416b01d2edc1d2edb59a2df7f847ccbfd9279479b7ff319327c4f3d3e6113ca8cf5d18","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
