<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9777088ae7213662d9416b5a0fd64a8240050f640dd3813539efb8d49f6914e85a48361ca8f12a2da4ad5679fa2240b99179e03e2843364596faef28a056da8c62b8c06781a246912e592bac9908978103d53e3c611355ca218f6efde3f1a39e645f6700eb3fb56cddc7a395ca9afbbddc19cfbcb944299408e52b6b572f84c6a80979eaf05bdc139fc939662e9a0d6c862022e49047b58d051e57275cf4114bf62d3f58de6bac7bb4b5e0c9950d01ee0700ee5d6653c3b246f206a5fc8961274157a255593f5192d58fc1808ae822a148671a2878dad53053d11eb5a221b9de3e94bb487f118b80c1654008760b918ac8343f5d99b5053e16606e07309a6eac86ae975bd32dab4504b29025f9dbf26d8752272e96ba6f3ad6ad0fab0a06f6d9c8fcc02b244f5d05069383aeb69fe63a2f01c19a4fc39e9fb65456025d52bd68d49432882d9c8a8421bcc8db6da560b042a3a77b21dd513f6644b9962b324d8f3706e77dd9de3ad9c4d9d865a9343f1ebb05b01198893fa149ca9e6e332cf031c1b79f88d9f7efaed3d457543037ce449e37f7c65b84d251938c95f1e705a845f11b910e791f535e01542d86199258bb2dcff61327fa507f8478d5042dd60a6887f02f877790968a63fafb7ab253ac43467b5fb7d7a059507274387e2b909538230be19c89c2f0e0e3d75e5a0ecde9dae0c821138a70f63e4de50f226947c0dc69e2161f35ba962aa9f57c0698c0ead2c8eafacb7c145cf555d85c9823c5a0bb423dc11174863e3ec41bd5d7022a77a18db70c65ed36339a123eb7d943f1f69dc01bf1462d384ca5dcf4a28509fd868d68c705b715d027abb73ce1507a34d55cde60bf740cfeac283731f5cdd25adee9c94a53c8fbf1ee77c8a785e32392e1077f185e99eb0a81b208a6e1fda9913e10be1aab497b8a83323806f8e7e9d3d27cbd484fedab37d170467873e9f7921b09ba5a5f42739857c298fdb0207353fe0b2ed5534033459f228bc8aec49e90c51c4ee77124b6c742371089af16bbf9a8fe98d9289c55cf55f97755299ef6980acea233cd976578281f62d90951b4b927540c08e978ea221210a17a94bf5ada3c00d6ef52dbd509e19a402f907a0f9511b83ecaaebfccbd6819260963019aca340dcdf02d6bb6e1ab28863ee7d852547c90ceb8d718fd9d0886eecbc3c56a6b9c54801d7199b38c9609cce943af545063bffe4e805a4b67e9ccf4ac3f89744e582a5d1227c5c87d6aa5ef09cfd37aefa15257603868322c65c1810f4b91dd637511bfb9d70f7b1beeaf3a592cca36da8f9ddb1407a159bfb0f356985c8197bf9caccae68fcc8534818c7a125e90fb349e8646fc3c51fd00f42207ca04ee8fd6d9047730ada62c9233aa42872d1a388e00eaa5dfdca34c847e6fd1d392607eff06e90e5bf0bc67d91ab8ba3faa5ac9fd29d682df8d4c46722411329d337baf5c3c3f256ef2e29f9617162afb240f43f2f2a356f4c5731dac081081b9ca9e58a1fb7a0322fda3cc7996ffd45576b16277d3ddf8a8e73304d7a1517f8b64f5b183d52562123245220d6536ce1a6f587eaac02bf98a164aefd308be590f6d604c797daf3f5d12d4007c1f8c933cc4b58761bbb3f43300b3bdcf9ddfecb46622e13dc5733f7f25a314539b5b11d4d7e8bc2a4c0a00372ab674ee8efcfcdc5125f251d522c54e6b92d41835f608679d3aa7c04a20c8d56b55d310f8c6db6a81959ca3a45769157683363456a9d40dc40a75e5c923b599bff40c4f3e5004b2a31c42438ef69450489dd41659018e2792876068916b36e64539fd88ec0f9558861d3ab79a0819095bdc36ff4da53c24d4c1b3ce0624c4927333b28dbacc7bd5dbb548796bc9aa1a249308118e957d3226a77a205bb7f3e3d735762bed3dc713c1ee1af32af292765ad46a02e8deef697a8400e5b3bbb1fa271b6c30cd2cca47a566ebd051cef4a6adb24ffa1fe54b2f38f5e91da895167d0f463fb396dd3ab53f280ff6a312394cce047a2ddca0f0b49bb2e8cd7727ff196aa633c74a59a1f80937538ff44b863f8c53ee5d7187897bd60632dcaa11af65176a3ebce4029eb119c93af769734d08592e140d342e476f797ef2254b53c68ec3dddcf4d8da3f9ef94798fa5a13f78ff6fe45a7cb8af9402083f93c07025a262e8a35f12c557e0e5424d64502aeae6162e17775a7b5bcc1fee1343482fac80421e3cc1f060f4e4647c7572790d1839c4d2b7adcd7470842a9694726905337cfbaedc4f00de48b750d4b1d196a6b7aff6a8feac9ac6828baee0cd19646e0a4a292cf16d122567a20c4c4b1854d1f27fdbdfd2ead1fc190794b32e08c350f73a55141b8d2be4e55f0a68b39b73883673ebb9f98772c583f636ffe0a87aefb1d0880f380eb8e200153bc71a2c0f8bffe038ddc1aa819a2c073899d32dd399eb2a61cc49c91b136a98b555ead20d0ff82672788dc8491e90eca5a0de6c59d549ce61c023a496874b9717a394d72587accd7b3112715261c5593cb851443a50ce6111c7e2adccef5451501a509299ba16595a92c001c2a824f386c00052eb3bdedc48bb6d68cac42071cd0cb37df8c850c203ec4ed267853ed1856018641c5803de6f5b88df205553aabae042cb84104b50f714c9caa4245d9a5bae02a34f8776ae08afcc963f5a212431f7cbea930c4be15a6ed7d895cb36765d4d6dff5de12eab9fccc2e35228df63e4c1d265a3a6f3b69aa51190b14e03c7bf5bbbad3bf9c5ba5f99ca4c72ccd40d32d43fbb338d44e9403a1b8f4ed1682fa3b1584466b3ff82147b95e87e70703735a9140388460d77acca8b2746349a4fc472ee03f5cfccdbeedacad58ade23a1a68f2d011993d8efa84cafd254ef780f45f1d8a0fbe9a38d3512ac9f57d77a78967493150f431e075075a41267dfd309ea4a31855ef15a47fb2dabc1c5d47d4969e09768222c83666bc6f0b7a4f18246e102761b65e13cd5a70d08da7750e8ff105d1d49e991402428549c642868f22fcca9cbaa2949a989d3befad140c206fdbb2d168970e25c20501812c6cfdab59276782f5315bf1ee9bb27f2192a864666a413666bef55108f1050db09fdeed1889ea0af52711591fdac366d81436ffb6ab04cae597c1de6a695bc5146aaa936f2270a49f178162547f585befd69f3df8bf832656ae8d0b6b1c2ebd5588ac6c1bbdc4b638262f1cc65df011a6d7dfea6aa449593224958ee8d0f6d5d039efc1fd073eb44f84064727eaef6a35f14c179dac5837349d68a54073f89bc899c0d4c55c81585fda5ad611b7ad93813277233bbfe356cc818736ddbd10e3ab0ec8c13de0ba6ccbd45bafb541363aa7870d3f89751848f1d1ee90f3beb4e77bdea3926301e4441182e83a7f1cfa8b9a3431c09a2aa034def03f32f5596951bd3e88eb0a99fed65ef5b8e36879938dd254308f88921879b00ba695ad92d7e2d7d61042f34693b791394d5be07e49761ed2bf7d5525aac3ab450afaac39b3b96b0e014fc4229f9a2baeec3216199167edf83242b1ba3ff465a050a47eac4685e2ed3b6e0e68b0a66ebe8b8636c58d3fbf782ab6eb21b313f041b626dcd349e888faf5260c5fa0710279d7f517eb0d10f05b4c7600e553f6c560373f615e55fa1c398a6e7dbc4d5a731884b9acd5c109e603a2cc9764aaae95c81fddfcb26b5cf7ee51138b25f9272dabcad62181196fa560d422fb3c0f19d4cb55b744f068b8b19ed3094d2deede1601b5414631ad33b382de0e718c5f224f8a08c0a9e52f49b64b11fc83ed07c6f3159a039eccd4298e908a98380db896b020e6d39a13c2de4d6780f640d54fe8d9a0f1510e3ef1a8025a05d5cc514658216b94376bef58f68609847078268b49bfead3f205b950c5af3317941abbcba57c332c40aae6e8b3ae5e1d8046410416ff9e7e898e8cf201c6ec93baa265a8d22987327e106597af82e6ac3bcdc3a3f2e46c367ec5849b31f0da0e6b4e1378b69c7614489e2af07fb7cdfb1316270702f7a73896fe38747464b3ad916bae79ac2492fa4da4fad259b00d64a338b1c3e31455aea083fff311222f304b2baa8ab86f036ced7f20bee7e54c9bcb586434c15f2710fc5b2321ab92a76c27438a59d707baf30f06eab631c683243946be0c5488dc012a53e805fd9c2e22e626a1985be0fd2dbb275dfcafb273e6d432dca7a761262ac6a0836d13a475a937810faeaebd067442290c169b5ef0fe0b3aea314516b4dd73ea0c7d8c712d121385bc50e66f9ceca47f0dd136011cf1aded8ac35d80a00c393e8e286fb65d672d5f8bf4e877b8bad201849f9026371c10a1ba4902acc773b31c5c6aa65e50275de3f069e0c111648f6072a67861cac90cb1dbc09c1234889a4c0584b859b4eb77fb2d8ea0dc50e3a0c994bdd2f41e14718e685dbcf61829572ba01886be68076ca3f9c454d008244c32098d88162d6484aab08ff7f60b0c54f428590802c2e90323b520c62557b6aa7fe611de1709cf2339bff3b0f56211a1ace31993a6fcaecdd8f6402cfd5b091387e62a075ce740082681edc549991baebad88dc06e877a8d55a2d4d2c3cf2de005f84cb5b945b8492a042674569dd39c6e3eaffbcb364a6144529ab5f9c18f35e31dfe218de5df280989da2772daaa9639beb1a5a366698f6c01f428ae234747c261cf28e1a6cf1504db8ee45ce981fa9527cfc9936d448605e3b0f693b19814a88db1a2b64710158dfd8634077d11cf891747634437f4da4290345dac592c26baa3cf5f50beb2e0ee5310a65197da8a5af0be6ae09c78fa96a493f8ab226904cf3b9a7be80b3a3777471981f7afd9c8687604d14b338898596be50773a1dde6bd42b982e261ae55ecd71f62d340a9d071d29fcbf8574a61f94ad1d0f6369b0a71e8f9c57f483e280ea596c7c35d21dd39cee7d392a7750d1766c13cf068b3950ef5b81e4f6e9435c5fae14cbd805dd9a011a1ef0a5af7835ebd79291e39c234581a7d6ba7ffaeb538da27de0071b0dac0c7991230fbbf3562bb823c2dc4d0b537d682ccefe4b8f325e7a6f46ef6b73bf2673729d032f30019ee9c703fdcc933f9e0cd3a86d3c4951afe9eef5b61a385f1fd310561ca41c41a190188702e144fee780b517677797a2fad2f985f864ebc4fa9aee19ccb7c713bd240cf56ae8b4e2be7f5448551bb3699f8d6d8313cd01a783099053fe9b51563d72d814daccc2a9adef922f8631cb2968aed24ce4b2b048ea894ee940c3e3c0d14b99ba08e9f8eddd3c9435f3bfd09c196e9ab6939f3d47da370d13230bfbf5f322185167733a1fd096891b2dc0ac583d98290f97300b86fd500ab5d2295e2a4243931f6dc1d2c76b7d730e1c4b8d085a291efb59bb6f2ebc386e5cbdfef04d8cc68596022d9aa8c56d835248633feb65398e6e4e911f4317f5a3c6f39be1d3e21d9c12c0bffcf7e15389e0a4e90fde16b89eb7ad49e8220a0fbccae904a81dc298c51fa0aa0dddc957e1fb960d6e970695418e9007d88cca292c71646c60d7b679ab546d6c5e3da994ee725a1ddee704159673b87fc8e3daa219dbf83777b8bd54188c5f5a6345474dd974ae48482135a33c017a3811571c81bffc7f2ab77ceb697509881f2ce226736c1d0f4653e67e8c3d46917f58d50c9ae7298b598cdfb51b34a22f8f9bbb573540ede359fc2c4b97cf492384e026595a4403c32505008e8d7e879854a083366d02dee15b443b6a9c6c60feda9b593667ef53e5c8e9f7b5cef11a76cfcf5c4ddad78fa76ee940190a5d4b103e95755c1ab1c102fb6f4402af116e874e911609fd0d104fd8544318696643210c3fbe1682e95649445a851e1de495344f2139416ce1e2f5e00effc1eb0a61d6cdb54aecf77731131dfc3a4b189cfe6fcb785c3f98c44771e5f1d29ea8fd5be62b4b30489c627ce01f8ae9a090ea649ef89304da1b515a5e5a7bfb5e58e7197352c7252aa24c2ecd93fc54755d2cea8835857a510bf8752be36f3208b78c7969a51dbe98f83b8827c8a7c1d0cdc64a413dce4f0a289ca8871dc141a7b132d003bd5cbcdc777c1251fd656cc39ae673e4abe19d2b71177f289eb6d2e787e6888d00d3b868b178dad470835f298302bfedb28b6b9946a28c4e1d22dcabbd0148b477cd162c482b07e524ed1193f2af8e1c3d7adcf9a57db8656f35acd657f6740b8d202a8bac6359f1ac72405fe2e9051ee1acd4c27200cb13a765c687f29126a7175020d1aa2a64e6c1e602a4e14917c8d63fcc5b6f771ba0e2f6558bcecd56c9a907681b4056e2e8ca5d13af4a0dc6fe61e1e41ab180cc2f19c534e5ce829ec2bc7200fcdf888f477190edae5101a8c3c476d86548a9e2be2c71255149c78ed0f565f6e542d89b10446cd8f1e11b67259cfa967694086266608fc13bc0b7adbf4f003a65a4e8c3edc029ade1ff85b80c54ce40723dcf2a121888849a1a87309fd6dbf6fd3805c6c2583fbcae27daba3e5d09a94cc6476a560e9c1ea59d9351eb3b5294c84de6a6f186a184271936a88370152189125269a95099f3124882b3f3ac74abf100490cb65161615acf5a09ac26bafdae93d4ab822137f8ea296423ca057647491da6ab03844086b096ab4be8bd001b62277dec3ba077de67b8e41a51b3f38db2bf8a4053255d0803c6fd83f21dba04e460d6c61c5b9749ed03c17acdc233b8e89a765824637ed1b7b1fd06201b6a3eeab2568b7430f23225dff7a58a54bb5f6f217bedbb4d95bdab1004dd92eb8bb0d2418e086fe8bd10889c1e62ddd91d66cc5d522f533ca19e986576b51599f809368046eca0c5a965dfdd5afa9050caa84139a732e8e340ee4cf5218e4620bc0c4c6dbbe6bd1f94b6ebde8867c811c153f7b66ae123c1043c74e77434c674fde1b938d2c77179f0222421d86c2f7cae740ad482f77317bb180a00d10e9796b24a8fa63d1dbce75060e01cf0b900b5d02afd8750ab8a8c3c591cfb37379c83320df0b5870d47a1314e6b8768c6a13ac118d0645ce4d8c47c563589d7d298eaf2424b1ab0e16605b4aded56ce5be097134551d16556559ef3e93ee19eea3958c9f61f4ada3d41df8c58f03d748a26186641a191f4e6e250ba80c84efb6cc157ed510bd1e9f9e70b86dd83b195c9901a112ae394d631869d096cf08e89f1c42fb87f54976e15e93854791f1a8624f472bf420c6d219cbab7a9ffdb60f95a4a5d3200ef09a9cdb9ec2190609108062f741ba84432e6e5b0734d1b9719665df11a4a5e6d57abb2bb2aac3ad8484621d086693034f21b5f97dfc438c72ad601fbda16bc86b7cb344c14e621d2cd6db1b9f1c3c7b0167d064a396986e100bdcba888172f812c7ab5b0ed1ec00dc5ef0f0f962fb6fbb10eafbaeee8ec758c1d48563e10e059929ce3ae4e21a697288bf3223bb7adc5633ebc7fcb1a9e17ef58b7875d65a562640bd0c2c5cedac1aec85f625bb75e8a84c0a226519acb9d1f3add3ccaeb27420fd07febc1a43a977038d0f0607610ecedcc7fc42bc40d791f549804165476ae1e3a9347a7562a3c4f90f99b2691233557a0028a5f37ca0c10207cf8655a44abc0e1ebdba56ae7cd7559378abd00a7292b4d396bdb30cb6155992243975cfe8f88e3378c3c1f86beaa14c8eccc20e5c135eaf92d3773809c0c1bb2ca27ba6c4914382cd4aa726e052d50c7e318e22add5801d261b43a767f2c941fde258fcf66d5ef7e4fe6319ea3216a271b1437f9c2cdac9329e96483d63aed9ba87b622d0da5a26129785f97c29f570319f8ab31804f1507bf1603376129297c6a79717d97e2e6be14c28d09caf8e67b8f69cb08bcf53609138ffe0c683d163cd5a61f5854d93a88b5714516eb079ae59cd31066668705ddc279c99d4a0fbe8e4502eed79ca1280151f7f0fd599b4016d4fc52faadf842cca128468d5983294f5f45d881db776781c2fb539447cc7e3e4ae8deb55402243cd85a7194a47acb768a5214bdf3fd63e097ec4049ae32cddc8bcd2b4c6b7f56a661c8780f6128b05ef47736550e590329f6b43f8b3c90859ec620553b5f5b373b25b9b2d7c31ea7e24dd33809a36a4a44c5cb525986453210b129fa907ec9ac1d17aa797f85d213d5c7d001ffdc247f8a5c4a8aa4f65b872731b3bad8a37e4e3febde2406c5809578eaec9a02787dc225eb9530ed3559671ba5e42349c35d9f9210d967be7a659ada7a51f7d6de9d25718ff43904d9f26485f9eb2fbcad46d3361be3c81f5facac37a1f664240a4029ac47bdf9cd796b01361cdc1e0c7320741423c8a44926443144928cb83a888b194c7492e39fd1fed839767dd9208eef17f89deb127d95c76a4ddb00acad81c5350f8c4b03747ab600c44e4d7a623915d769462751fa85943b9e0a2727c943230f2943725caec2f3eba73ab9318c1a6629dada423b7769aefafcc4e4c707bea777c494b1ea0b544468d3116cfe766a586e71bb07aa41f920ce3eab04e72083e30d73fc30e91839a0cd97073ec045d5d4535971cb2c0ddebfb684d8598e956adc3ba8b2b562c2f50e06730be0b6932828ba63a9966ab93fc08b8eb47ceea22eadcdddcf93cd77e472bbc947df069fbde3c94cb8e1dc7fa28e28e1ac98366bd8ca9bf630e007cecbdb952d192f1eb63d594d91c068efaaabafe143c9a008d190a798437395fa6d73e01a18f0e946d8de68a03ef3bced930c067130f73c0c2d33fb9134da9eda9aa226b0361005d671f57d4f18246a9f2ff93adbea8b22cbc2ff57ba7f453cd1f40c54ac535e18f69c1c876621c2fc8c2c571536bc185121e23ac41ea67ec6e4c2119f51f284fba0c3adc5ba8a5905e6fe7c42470a0020d087d9fa2a24be409e92ad294899514126e7f906ee9519d4cccf5cdc241399110d957d7ad4c838ed15fdaea72bc0b1c2984b27d1146d135989ca49cc25e837a8df0f7f87fabcc58cc13106e2c969f7ec0a0b59c2475ecb56b64f03a9ad06090f97ae4f69f2bb1fca02f2249aacf911aa0ae2b0cd626c65ea397f15b71462ae1611b147de2e7a6f0e643c1714275e3981053389bef6609cca7e1ca563241cae66e7c315ac4a84440f9ac1ab5e1a0ce071b0caf0696b7721f7f675edcf08b16342555bcd6ddc0da916afc06f49e5c36780a136735e3c1c11cb8d446870db65f378e3e7cae78a5882609a9f02f24c912610cf2443c64b82caa3ae84d5f71a30994d2c36d6a9051d17fe440bd4e7a8f26ba55dee76ef94a80ec802004899fa75840c7e8c9a4505e819aff19d7456038d58ad94fd4b9bebba70cef13c0b6bdc391455269727928783068125c8b2b829cc07bc3966b893454204c40f7100addcac1b481705ad8d5a6c5127f24a1f64d31b895ade5b2a5e0b5ec2fad2e65c3fcbda864a8f8ce48c9456ef4c33328392d5b2fce3d03e09c125036c8f0bfc9e61e99a3d958dc9d08f7e90e7085011f63fd89d6a26e1443d2fc2e18972582677699c8e005ec53d3a206d3375b4da020a74e6737d254622fae506a6795d708beea01685254779e36be1dc8c225d43a3952c1c0afeeb35ad7a916f44ab5e83790bcfb2a30af1c2851eb721aa8821344cde443bee3578178453999ef9d15fa2f1db89dbfb53cf14122cb5c9aed0a68559f6765fa0b29c76870db07dea3ef9bf7345babf6639c280b8c4ad423845932fbcfd98120c0391ace9baf06ca52eca44950840f50f5620c19dcf520177624196f8d3c88c15014d1583c09db882a9dd02e599104101f0d607ceba5884a706efab195d9c5f987850af6953378c0e8f2d27de84d699df57ff5e63999226295df7e5ac2e8a7b7fad6850f0b0860778312f8c604b68865007cb077824f0fa03b209f6bc98a5ed58e5b9b87bdb67106e76b681c96d3912b4d5a5574e0b11386a20ecd2983b86fb708ba80be307f5394643df49cef499a81e2b7e0b52e84cc8d7dfbc9978bf94d86b1209b613b2d8486f68cc625951dc20ebb55bb10e41ef2803a7ce6f1b41ec9addb1662d150d81a6287dbd321ae63e99c4df7ae590e1b6e4ad3e26bc8bc145a786f7395229a50568cdf71502c82bfbb5e04c65500faede71e1855cabf275d5105d63665d168b18835232365397de8575dac2f9727f63bb17208ec9237034ba0b1bddc5e9d18bcc9567b98c0ec8ec4dac9cb67de9685af6cb9931dbc175f6156beb56a32056373ddc6a46f1f16758ea6336f6ed914ed0264a0a110503d109a1dae8b7b668edfdbd4fd477d206c301923ee2da9e6d1ebf8aa9f949fb7120a4dd12d5c2509a143be067d0f85e63fbd7a61f1cf64e476a1ca7a4afbe42bd4f735381be2b8e4c75dfbbe00f330fbfd4d3528f21cdf41a11a4ee7f9dc26a2188a27b45618ec25bd5b6a7eee9b39b3d24804bb79fb21c602ca3965d1899db0204caa1305ceb536d27d932589abcdfb6cdbdfc407b70a3874249e8bf85f577d12319d93f672595658a67ac67f4abfa96f76d14815252a134dd00f10d407e05e86cab780e99edb8d7d4816d4007e24f18dd7c5ba373c7f98a3bb7ab0e2cc76d9dad448560281c45ea2f2db3968dab22bd0be0f935b2c6b8b1019319ecbf250faa9eebb591b755ad063e5fad828484bcffff1fc755d13be4bcf76a75c2a855f539a317cb845c4f5a18e69b6d732ef8609c8372871b4800f96a5e89c018381922f165a232315697638518577f9931a99be7b007fd92196851e4598fc9e4e40cf3a2391a99c9883c3bbd9f0a739a8280bc7b85548f6991fceda52899de16e206f5ca05fe81c39ec633a6b2f3eb683ffeb8f4eb5daf8ff55fb75102d2c33fdba7c11f5768c3ac12c9e5de7af66cc888ca30d0d57ccfb203002a715dbbb0badd0e4da378aa64f5ee10af6205b7201a647ab122f278758266b4406f9853c4cecf2688b479f953ebc91fb31ff82f8f8790b1db16e805d041523f85a3a75c852db44e4d0d99e7e07e12110d4383a29f958e86ec372071f4bad002fe0b679b6e8664785942bd1de2edb0e3c9a575534c8d324182e6e92a86a95251cbaf1e6dc15251674aee5eb6c3a8e6060cb54d33b0a716e5dc45d407af5af62b79403f921e1543d242f927ad0aadeeb508a121f12b59219f976769a1f697890be9044ab64ba49e7ce71f61ae140b0036e56f1cc82bdd444ae90516ec3e87e306fe06a0e2c7d53cdaf9e2acaeb59aee3a8b9d1d11db06914c6c4bf5884af3befa72df830e28e2fda153189d576d04d12a879a78a5d41070a952ab46fc9f2a29204aa22da5917f0db1901d649f8c10f70868f36fd1b55301b3aff38bb6ac734b7cabdf17ecb059c91e00e9203e79be8931198e7c9b88c65fddefccef4821d06044590ec2a6768af8de83ed21479ca49901941a0b2c0353abfbd05f036705ee9c6ad1ef2b436ace833d61144cc5bf6dbabb340d23d766ecd697a328f9993eae5071d52976c2a3e2cbfab0bdd97092c00d3c62160bf8df07027aae98b005172ebe87847aef86de01ec95093d1b008bc58287bd4bd0a7a9e913e6fe44e510b54abe555758586af67a5aab24e7b6ac9d19a28bbc9828ad85d1ef962d0df45181bceddbc52d4c1a586a487f26bf91904e14dca75adc766284d318de786d60dd606316c91bc217cb2f3fb0a68d29b0def0972701344448ab63b1eb65d93c9acd1d5dafa0b923a9d76fced17b18f2885070312906774632f3b4791212c870c72ce67b309af023161053e71f51b5bd08c8a9cf7e45b7b4d77204bd9d374154d78a53281fd18b614ea224e102142b6ec0495d430f08554be883999dee864df0171af127338e104dc8c9f67393d4c41b6e65fd5baedb4c9197f0762b2b7d8e4af2b81625f8b03db779471ab91cd5f23be03e40a049044ee906cfa6772c88b9fca25a4a177464493a64270368a6e06c4e94452e44a84584f9c03b26c5d2eecf7b066b91010eca286c1542d255c95b395e12aaeed1771f61cc80e303914d127863a7cdd17e61b57f3dbe06e9e00adfb21be345a33c08b960195c7b99073163418cc15b22d549245cc0586596c3111d24dc12de4d0e2d8107658c49cb8f5a612bf95278a7d62c37a27891cfc72f6615beb98c67685fdad06cf2646d13dffe51eb5a83cab59f4fd8b6638c353e40095640b4f2d807197d094f66d0e16cb67e38b3e5751b35ae828beb7c55a3a2928b9cb642f149a629c64df9ebed7f393e4392e00696d738d50c2c804200456587c2db16c9e0c847046ae903d98830af4a5438566f3882ac0129f22a81accc11eb5cc6a48bebee157e14e59316d2bf55ee6ee07bdf0cdbe897caadf546c8f4babb7bc09ea8853790f1563bccb220bac02c26c87b91ed2d17b700281dc706a82a9257955ae72ccad6ec1a700d1e4672097e22f81e0ea9b09e758a15fd90fbedecaff9f7d401458bb702841e5574582992c286cc6a40dd1482ccd69f7dce4abb7a286be0d8183260d88b7ea2e87b20e76b4aff90798b40326165bfb66a92edf4216b5e519de53b46b302aaece652c77ab0a8ff3a5ed9bf5bfc3f8d15581d540c0e43473b3713f610f9a61a4fa1cd64e20b3d103df01fd1851f46c42934826e8cb10a4d14252dc552243c48bcf41e2f834c01d752a07832ce52a16295042211773098fedf46b9aeb551953342f2001d5ff8d4f27d42eb95a9a62f0e2e8110033f1609da7f1b8ba83c424eadffbb9be3ff5ef899999c0f4600b1e7654a4e47aa4ed134e53273cdec2b5cd028ccccba8c40f0470a7282ff9152a3ffe6bb8aef333ca4f9cd6bbd029e914e7c0d328e62865b660ca0d83174abefe98b2b076b02acad12e3802a29a6bf337e9285eccc0985b1a8a460ebace085981297fa0fd7d746de8f091cc455a20ce67a221170e016ace9f47da28f114c194661503f16028abd5f98fae6b774cbd01abad28c799f8311041ccebbdc6886a00c86a59434e78c9d616390d978d75f0bf20f6af8b8a91b708431347fbadf24eb94eb44852a91145ad5bc2c1f991808502bd6716f93d3c06817e0c94f15310e8e7d976e4e843cb90e8c8b589d7ca4937148de93fd987047da843d4dcb7f04aa59661ef8324e0d5959a90e4daf640a413e1ad833d8196be11f01c96eb4791a68bd99f157427495ff437e5dfac8014cf48ef992aa9bec08c42f4ef5194656cb42df60a8c84f11a45b5e7bcfeddf62d63751b3234f522ca50236ec23ce85c8d2acf31ee6627d455d2dfce7142f8a38f8d8bbc884d4d06b1bb0e6dccd4cc358144e4bd1c0fd64441c01e6a5b22ca3d9b648357a315ee053b903ab8e0b657a11ba53a8f0600da0ef0572724d3f8e5382ff1bfdc21b26746c4b284c8b64657d7c7139d88d84f0dfe6c638a5409e7d3c7dffa02fb42a61473b09f84b695cf8e3667e285eded93ac514d1ac69a63b2742b91f5ddcf4081d4eee934d76263e9f9cc3a4b835fc760a9832c8c4f5ef9220fa96573596f6829a85bfe470dffed10eed3043057d324ccf66128ae81ec88a996d524c3b6a6173e2493a7ecc0ff53c071cce0e44d47edaf143b0a2748f85d78c1145fe00036edfd2d0bbc8e0014a651cccf5676309892f425457fb7dabf48ddaeebe32c5d1411e89e3f51b7f710147831bb0406c1e342baacf447e6f2de9ada21988d43aa6a3b50039a7464aca65301bf501dd809de32955f17200fa55c333e959bc146f4d6a3efa4f62689ad814cbe7e0a64b765566f772cf1ff3ee3d1b6f16cb28d262f627b8b607b3dea4ee2465ef6593c70354d7e1eaa8c4d747ce0ac5f93535bd50db617e26a5cc914be3f5b96c8cf74f22a22e7f8e884179f9f76ded46f02b19fc552163be5867cd7e01a2f633c48d42f0f40f7ea41d333e2290ba11d1ea24b2da3c613f0253b6dfd908ae5d7b8a5440bd6891c1cb15a5b21a7859404c42736999e5d4e266fbeb59e1808c9cafc8f829280b76a5deda091d306b974e99b55f100bddea103b263063c96501c2747bd1f1a0ba2bc612ea131309538c5b57fa53c8c4ea57bedf1aefe186c7c4d42cea4eb13c697fcce81644f59d93597b0bd0157bc3b4b41c640000e0c3c8b472d18a054fa0d81311298c072d9c7ab3f58e253db8c529e1c1edbaad8e232fdc41e9117de51ed5d5a53a946ba61441db8758628cd62367935c24554534ea3e485f4f6093a71d7b42bebdf6c77e110e474a4ab187cc08c5a41000d90cf016379ffd19fa58dfe1833bf98bcef7085321377d5405becd9f8bdacdef5132f0f6ede65b2dc380ab2d3c7ce770063eaf1b8f1be32caff6424fdfbc0c72d8afc9743b4de4560d23f2184bc9329204d6dd9c38f554a1185d2d8ff77306c204c3ae3c046c965d4a31739cb80dd61679aad4d6f155cefa0ecf34eb1e0125a6425973e38c95011dd5395f7e982ef95e2c60fb75c2351e6293d0bf42ac618f0382f38040807a087fb6aff284d3b1916428e185c7ff8a19e9a50701c722878b64b190b909737284a7a21ed3948262a5d4073bb478f9422de98b87c20bededec4de85b7e5aabe08e9c298908175e139cda33a1abf6bfd34024d11c2fe234ba3f04f4cd7a48566d5b45068e4067ae57390cb12cb2ee8cd4a95351612015f1b559fb87626bc67484bd4b7bbd8948d9fd77b559e72a2595f9f3d203dc3fe4d45ca1e254ab3b80879277fe55e820fb03bc1d704713a4e09859c092dd9282c05a02141a231d5849411880b4b997738119c8ea33b93488e1513b0466eeae43b7b18302c3df530afd2b87a1f7894766531c82e91e88c07620b7e592212901cb19ebf5c585a3487aa21b80da9dd85df8b7170c3b965ce1827868b84dea371ab546d0af457ab0cf1b142fb016c53fe9ed6968913c5c73b0f1ffaa68dae9fa16ec45d26e0ed56ee9249c7aa28e1fa4de94bb445e165b12aec7289bc3424589c055cc84c51c41bf257ec5a5fd1852a54f2679d03539b6087c784830a1792fba4dbf3e4a860c0f54b8c96e2a662cb184bff1d2c2c489caa7c3fdc95d3ae62d0c5d32b28652a1eb7947d56f9bb1062a6ccc57bb5d69f65e182154a68430d162f92c382d33ab00ccbecbaf9182ff830984314bd369b32b2143392b824f63d4cf8796a2924ad468b5b01d33532c07ea81d003337f0264501c47e6a6d51536a600f4ffa411ea21bced85fa1f89af19d064eb4bb12df9cbbc827f9397b2f0acd2c7c65686c9695b2e69828c39006cc9b055e7d20ecfb062d22e0671db0b0ba140d2fe3687f412b8b0ba683fbed5378c85b731d6e12f5ffab185af998c0bb2cc290f34aadda9886c40888c33587d11f6ae2dbd52f6b1b50b600ce2ee4f6a7d70aba40f9c7b2f146e7027cd484f149ad15c22a8aa60d9a8cb68a5be46e66a819bb55070717f50ea402a99feec67a6f328c954578597751f5b917550a508cf9536f8ebf1cce05d81761950eb5404d186b9239a76d049aec9230de9f9a7eddf0ce28ab926d24f237c1c1e49a2f05f40357e1d4709eaa84c8ddbebcd41e70e20c88ac734f582a614f9400656c47a80ca706d77d7cbdce97940c99edabd535f97bc2e4ab514e8f9a92892429f499f231c1b4f80f70ec5b793f334872afe31b331e534657a326b6c37666cdf6d13f86ae0396ac104a260b5412c63826204594da921579ead3279a8a75d2ba0f3c0fad5f675d090274e7ff4f30e6c04333a75a8386b48a287a3c9b50470b46763ee276f86e30bfd382ff9898b506aba52fa78a878f0950aa25b2f7c82490c57519dc0f746a07eb94938c710228db734f3d8797d580a666a7b391f373b6aceeb33c08b2bcc852f28f6c721d2ee5934fe742fae30e93e4cb989179aa6d80dc923c2967819f6e063777e670f3511ae23f1f9ac81c7baead75e5d392d2aa71a26988c765bfff07dd1486f6528bb579e6863655f3cf4d9be4ca49b628938b609c7fc8ecc326cc941b404648bc2f8a92ee092dbb5922e449600c375e76cbd6ac8db2d6d255552871c952e85ade8a455bf02919e47b48da7910b1360e6aa5cf2cb88ecc0cc9e7ea0539aafcd7b8b3730545c955496a63ae18425237b2454f5b808dcac0f751676158051192a8a5b448c6cdb58f9916f7491e3337ba83d5da0fdf883a97073bef94003e3ef8901d2fd47ce41c3eca6774a42b734c67c209c6ae811ed0c2619c68a34f7d7f5581fe17cf0f2b6f0f6ad7aaa482aa0d21427239f66dc50be206ce2c6f164f26ee69a76c5d264764492912e778c046f60a68bbb87265b058bfadec530f71147b922af51fd378ecd8ecd3855bedd3fbc0a9987094d35abafdce0f9e68b066f1bf497ace8e0e44bfeba3994daed267727c2a5b1475f79aa454acee4dfc1bf90025c2c22c87b89b863cefe443c5dbf97ed641adaebd90217fa7e9f552319f17e0dbfdb33a2afafb7f3b9ebebb06914578ccd23b36a7e8e4d1d3a91e20d52bce9c7b25a3730c3afe7dbcbac5883482ec915f580daa994d537ddbf080459b5e1e272ff1c4179df19c75d84a20870e0f06e0053d859590672cd67a6728b6fca13b9d083fbc3a8898a8a3697ca6eb0d3e166e6c83959713b40e0e7262a69cba659ed97f26847e2331cf681a087011fe557f7bc0558b8037e148a78d253c04e90c1c6fe6f00aadd69e8fd799d05daab4ad7e3649001fe8fdc21c17af929f485dc06c053df8f987914f1a7804355a0192bc80fba09147181bcb8e0e40bf36aabc2210df8fdb8cf71d33027ce7a49c1fabb14881f4b00acaa8ce07cf649c3033fd8ad7e032322d781606b0f7173f36e0273633e63c1dc9cd8104dce7beb9d0be01a9bb9088611b8ddc5cfb37b8622a1c19ffe03247b825004225dda24298c721e198201f868fc9517774816a2f740c1c620fc58ae88ce8841a4566bf7fa571bac7910f1273689148b097417dec692cd1fcd5adb1329d0fd42ababbbbe6c553701bbcfe65f2d0c1f506286295ea613d6d8fe0e57eb3027952c8f93d6d8f7ff77359ed2ee9de3cec0f88287de3c8e3d83961c6696f3dfac739ccc171b62980da5d6b17f7b2543f3ec3a7992704df8736c2515408c1ebd7ff3f001fb5950440afd3f880309172d85ea8210de3fa7c67ce8eb53fc08a2067ad6026ea548f21866c932c7763b5521fcf8e24c9a4e517a9ebc7ac064c9dcfbab234279075c4ed8f009945bd8bd0af3d2fd72ce98c395172a4c4705933bf573f5df9ab3c87817252486a657d77c50ea0d705c49b8231b7e1891d981623aa461ebca069c8aabdc72dd3351b7d21d3fd04d2b6bef83be587bfe8e83a9358a6f93e3130c0dde2a2ae6c44dbc450b525c85abd7b71e2c770a04a48de963ac46a222a6b60e93d3c352a72d5ef229cb499135d6190044b296a3477f841e21ee6c4f10b94aa26303603039a88f0ee085fea55ac3d6243071793c1cbbd006de00ae74b225aeb5f71c683a202eab1dfeccc1aa1d50ead936bb0b642a98121b76b26c8dbb2513604b25f47ee060a3570f9209b06d04ccb5ab8e2bc549af3cafd08b3cf86b2e218450b84db65137adbd25dea232ed9ebce6725aa646eccd2b8abb145c8cef178bd715b80aeb8595a62f82e36ec11447461e9e2b723f58c8f67e4b11f853840d64eef85cee3e44674ebeda685387be2f39334057b1e74fd8f086d256a254c3e2fdf87ef5743b388f2149792b402e8ba09fea110e97532c874eb519c8b661652ea8668f7e1d660104d4601d3314faa27f0d78725fbb50902f5ef0aaf3587b050d142b06de48642e6538cdb32f62cc1f7b13c2902f38ca883a5859c972f70fe22c73aae326bf779b6afcb6124d2ab519d560dd2917afb57254524307a66cb4c567654b23fc327f88a79537cf8a4ede422511c7b8e9a3a481078368c92df5af37220ea26240c26c0d0458550e9b32548824898c4b33a4aecd4fc73d18e22f7f9c21309568dc2de51b5e9dc1258a161f30f401a1f63d8a3009fabdb2d376380f1e72719784377d50cc2ebd2e392c0ae7256f3857e2c4bbdac239f94dfec3362fc608dd16d78d3784eb1b62b20f717921238a55604e505f8b16c96ea1310a8ba9f7d6650fb0f50b9deb74516175c35efa83db34abd43bac714696abaf33493b3c668d165649d8bde55bc1c623be72aba1216df3bf060729e4c4f4a9995fe8d56f7f61e8d041641f8d56740a013309ee03708e7ed9fb966e135a4d3cb0d813ccaca17fa6988fafed6af5cd6f2c197a4a1f05298e16a3877af3822fe6255a590629a2e7b624b4ecf92224d71a5ff581480c1a5c7c89cfe80efb9bc9f35105c7608eda8aa5c5a55ed17368b77b4896f77fc000c99e6d972df869d8b2f4314aa3b273875583ec87e52f22c156f214e49bbb9e19712b415163db3f93522504f5f43debd893566929c3571935423f7cd11157336efa2a975b1f3431e8f7267a64a8338987a5b52ca9f09b2f17f029515475d60e1ee2d61e98e339646be497a11c1f299f5342119b72409e564ca449e5255f78fb01a43afcfb0becc70c8a52d526b8ac404c9828bd4d37bc28b5c407cbdc2c2f275d85ebdd85b4fc1f7dc7e3237a2691b596189981f0fc3c94264a8f56ae441e9360b1d6b6cbc242ec5ebf40f1f0f22d156c8ed67cb57d13f1cfd460a653972ba6ef67124db0b7484533d954b4ff9aa20818fe384974b4d87da7749f179b53446bc814e1f4d7a4e6838a9784a8945fd","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
