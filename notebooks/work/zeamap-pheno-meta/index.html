<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a027c66905cef1951c43421bedd69f526d9d011a4244ee2039103f35057a658762d8ec31283c4a05935ba790649bb8f871f8ed0db4a1365a38584b476c8b5d0ebf1dc8d179ac24126b133b2b808c6d47e1df3a702c5356ff31183602eac36174bd511857dd26a6c852594c97ddbf2c5afb51e71ba8b1e0374bd9291dfda75de4feaec304f2c10cbe82728a150a9186a381d2d35b29d552960fd470d85e4ae33a280f14a83a1a8c8db08335d21176cd692613c26e54738374903cd20f977ee9590d3769d3742cff64b83f7aeb98beac95afdee163762139f7a3707ffa391ce733d98979b1ab91826805370c94b4e8ff10d11afa336790b89107481cc7f2200723387b6de037b934ebb38d4c4cf17f81d46707b300d4ecab2368901666e8ba8a7ada77e2df9c2bbe0dc2fd74390ebc6d581fc01005f084387941a436891d5d10eeaf8c283294955626f1feecf690290daaa90eecb8aa23884c223554c22c615bb1e549ea82511a822f6e9d9b677ce2fc0bb69216aa885ee649bc77d7e2dd2365b5e3fbf15fdd15ca8640f21f3d784c42d4de9a7bcc9f5b4cdedc156ebe81901922438330cdc12629c26842905351ed96cefeaf43cd488c6968b4db55bf73666107d7fb1e0cc214410ed3be0e332d03964e95025a4bbeb2cf1e4ae31d957dd193fd7ad30ad376812c894d2ca4b483740cea7f410adb1d83762b00d14580d00765d51015551df7db4017798c3430677e9c57387ab0f60d39c70c7d96ff68af8a1248b394f47a034a739df26ae5e68e38649edeffc7f6478bb671eafad5cde67df16a91e71cd7d5f146d1addfcdab774ca5b8c803d6481c4af2ab04908ccbfc70611fe2134cda116eaa1ba4b760f5db1296be554498f77dff1a3b2bad96a223d79f2bc19f0428ce98e7ffbc95c577b5ad13b9f59b12d3b33443711274db76212fd3e30f316d4ed66a86da58013cc411cceed653b860edcf28a1ebbe03891b034e44838494aab3ecee543beec24fa6a4d139a5a2ec884e9859f4748257b20c96b68c9f7e12fd1b4e0133c50774fbbc973a24d5934a399c8a37b8d58a94c4e1113dc63c2da206bf05201eb4848902fefebc7a658a2439fbc01affd501918a1fd80c396463f806f33d899cc38299fbf69bfaf5ee0fa4f0540e803918dc687d2b703b1b4f98411c5ae8ddfd1a7f25284208178a56bdaf9ded7634ceb68448a1f268e4a7f78340b96221595d5a9194f3b5728e0265c6b1a5ce63f8d0706fbb4d9c94573d5d0ada2f611af66062bf23233d08bd3ef443207e93dc81d34cad4fa12cf41804e73f0574f273d836a090ed2f6b12ea9e5ef6b7834593c2375def823ae4679cc3e848189ce20bdb97067bb0ba41fc3f836fbd282f0a5646a9df07d260c005bd5aff4e33f0ba390bce0b796fa7a8e0dee968a836793fd681ff606964f03f40635cca4d2de1cade54e5496c9f86c3d9ba1f0c2d6a22e2759de114408a592d5d050b324e1d9c870a3fe205ef05dbdaf892b2cfe0ade8dc681e51e8d7c94dc5cd2febc19de109ee7696985065f4ba6d4e3f698aebaaeefe670b25505732832e9d627ce7357b41834655ea050ce3d5a5be9fcc54617096fd141b0c2d583a50e496fc0072155d7b84493887c97d9d7139cf41bb6def6e4f446a8797d158a17e4bb9b464e6bcd6854e9dd45adbfc23e083819c7ca72d7a93d683966efa33570f63c72a13cad6334740636d7c7e07f6d6198a9bdd03003346bf13604826457033705f71b2928c17a16fc089fe1e133cc8026d14911e45d6cd572b7a0f4341dd98b15317dfbe240678363b0aac8456be419f0e4c773e77c7ca85dff58cbec342c13bc087f8e9cd31da944ab5208afd0bea836e821e238400fe788c885542d21d78bd0442482b0664a29247ba8c47007d1a340c8800b7399bb2e6d1916ec9421bf61c614d3fd36695148a5564cdbaa60f931892d46c1d57edcf38502545bb4bb82ef965b2f4bf32f9b910785d9972bcdf7f6e67e0625542ca3906fc2b69c209132ef1ddce187839dda4e6820e05582dd3dd1868e8b0cd0ea98411dd801892b2aa88538adc712df2eea8ee195ed176bdc0c37f2518e89f634aeae387be327d9208969bf5dedf648b4f337bf908b451ece8f09d12b5c74eea550a1c7e0f9623774032d841f45295d3ceaf133a705ef17750551e771242157173ca34439ea47eb9edf352175b68f13e875fd03bd82097cbc05fb4cc168597b39e4698009db3b895976783a63f0a6f5b4e75f22f23543a24c424900219462e881c6b1ff6d2a501d3fb393ddb6a31b2589ecba463e4ed28e069ffe3692f1998ba057228ff3e5f45c451b5bafbe6800d8aefb64ee0d65f22cedb319acfc09326c89012e23c60d1323d18cb3b0d8160c14ada240dbc770ff5fc4513b74a48fc091573b28cd74d6ea61fe1569d3fd60073d68350a36d4a42d47481ac4cd3ff46a086167b119c5c3abd97e8dd16f5632a8a416b968ec976d938777589e27bc209167b3a2f8b3c7992261a5d9a1dc616221979434ad650df923402270f8d3af595b23926b9da663cc2679593efd42c6df604ecc7a23369c7fb744cbc6c70873f7ca24fd39b02b371330784756a2c48bbedd0e5f66c8f2ba1ebab128b8dbe6292a83e20a45bfc5b5e3b2fd6f1c89709ba66b93f680658d1d02ad93d18d8d1e65d90428ad90af95fe3c785d3b44bdb954746281e4e2d7385950fd4ade686cd822228f5726538c10ef0f22653afa118bebd525f6006184c9b770294cd62c12a1d074cb964bb06007dedd4e2446bb8d51f900d0ba006c7a1ada36c953d981a67e88ffc9974292ca465dd469f093788ccc87bf24485455c3ee4685b52353b93295f9b79f9f426f9523e5e094672234b36db44fbe182a5a6ae133df2c7843fe199d48bd2106054eaddd1d1e45329bb42ac73561bcef88ff264527b3626169cd86a8bb24e5a6c6f26286ce3969b7b335f2044a62813d0aa8d30cde6aa5fdc4dff56e2c7fbfbb242f7dc972eb41ccc5b834d3935b9a98ad59141e1fb38e4e1c0747150d726102f2267e185d89687c2733f0467f5a8d3ff5e6f968d2adfa7f07795a9ac862d3b468a2f31880f183b80baf633354e9b090f5844f3951c6f153af0e8336a84d91344815603ee9631846c79005b4a93c9b0f98ec2527cb5da215afa67f4c789334b34962538cd6d86663f708ed1bc82bd231396c33fed961f0acb85380d63411b458937479aa40a005b142fd4d54176483c0692177a77443d2ccd686b54489de792970b3982a43f82da8e176230e32048292fa1a8869cc8e372130ca3d8b5ea395f25fb34ff1340c72f6ba886f0fde36f88603c07d5c31c1d9fe53c119f0851f3843721f6801cdcf3bf55a00cd4b3a83843f186c582f84481ed6743a5a661a587fc29445bc0a44709bf3d4dedeae663552009eeb3155a7b2014b3d9bf7ef5002a5b6b5359dbbb8c032bbeb4093256e7ec99716e1a7225b2036f6d448596df4144d5ef383b85bfa84838fac92462fc78b548cd54e7de7172d7fd93827ffe0aaf54e1e6229657a724aee7903d2047baf5bcb1272bda8c5e1f0a32d97280bddf19207554ea3c80e5be9264d70f6cb11ab82d351a101048660f8b6cef36f29371d9a852caef6cf389421f92a40a37fd4d415c36a50410bf0b7064ea89df5e2aca7f15dc313dba48741a4128df55c3a1582939af8873486b13db19183a6bc6acf1643bf48d5a98be1f985661fd669d56f2f549fd2dc4d86563c205a2d568c58cc69a6c59b5b65aa818e364c9025fa2bd0afdfa811e693f8e8db33026efbfec5c90b10f755260fb49cd647b9d1967de669aaffd75b22d15ec45ef5d03122ebae59cb964e64aff8517f0f133f861877067e4ee22bdeef279703125c4e1b0e1addeccc88b068c7c6d44241b4ad08c09b82475ee864f32fd698e0582fb4039d98a1b85c8c48ef0d70630b76f381068e0f6c1aa7a9ccb31607c42b1f170a8ff7c5f6f778978016f63d783fec69215aeb1353994d7c9e87d5b0d04ddd90905071ba8542f279fd258d9f297a82b73f930fac91d94df6a7fd5807983a4d9c8643bc90e908d02a084f012d03ef9bdac743e772deb3bb99135335ee06b176ec1063c370dd722ffecec459e7e251a669af1a439594e3dbdb225e19a482103a0dba3a8d64532b9fd52532569a65d48d13dca95e00ccad044988e5dcf7f46dcac3c3cca1d34c69ffa0015255f47eea539687858374933f11d38585ae0c785bb5f5a76fdab354f1b33804a3ded49b7bb565d7aba0d6384f656404b03fdbce388bd9957f73d67bf83030fc8719b1e93d6b38e847bda2f2405c659ceed0d9a8be68aab92b2586fc2fc07c978d6d3467dbf68046c68b43aacf6ee87b30d9dd87b956642bb6bc5a731ab600fa5de8755a358c4261308a9190be84aad9d540f21062510380cac15e823fd9b119828561bbcab5d566bcbec9bcd24c9a9c25bb90ac2009730870b95a18c1678d2c6fa941e8d88e818d2bb07a1dfdcd123282981a929b6b64d5de9ad2384775a2d59049b34d4a800441426668782b01386a24ee4fdc5f25794b1df1739e1358df28b44794c2baf4d157537b305c0fde71e2601146c5ec49cb992524e5254dfc206abf9080c3a685199fb08df06526278f5e7af8adaee669c2283c1b886eb706837b9d467e28dc75041253d140e8d7420de60f13f3a148c6083131ad2f5a9c73e004c6f0bd6d9889a1f21989cfc5bcdf2e0d6773d9455f904b5a74bc3c71962ae38dadb0e4d0e2d3e09995553056bd55b6c797cbd987b8324e031165c14cf6c5fac3b0260d2bb8dbaf1e5a3b8e3cfdb4c00b0c3737e2183ae3f2fac882348a6313829cd38543b606992654c3af32940d8b772cd402078fda37067ad969e498ccaadb8d9d4b60916329937d2c8230af906b2ad508358a593967df7d5fb7586cc7147d6ea183c849aca11bb2cce84f18214c23214bcaeb5923f57ec37f3ad7b8154c6888a5e109f81e7af05717a648ea7a7d18601fe9cbf3b9aaf208b2d78395f7456ee114588dff5e7235f249a4a392a1b541ca852a7787e54d3268af5644a7c7e948d6c4d5f7628eaf51145b223285946835488939a2af5a53eb1f7d7b84e076076aedc3831ef52430e933855f4dce57501a8a6488b808cbaa6f964e613f799a32a355a4508112476c7903d8cc98a8f65262f7a0094bbfa2bf81016bae7d75c5837bd7ffa7fc58ef77440e906248fe1fb8fd43bb6d968f9c4162b4aefdee9e5ce40903acf46f6b831082ea3bbe55d18dc2c5fe5332cc060f97eccf766e98e41cd3cd6dfc497ef63dc510c66dc2073b6250857cad49e47871fbb478be2dc4eebbc926ca2c018d328a19dc308238ae3c305a6d7d523b2dd6598848e407ee91800c9e0bc79d64baa8bae8495f95dfc708b3904c3b74d88a7b902e1538ce544ce2e7fe55f66545b69f7d8a783456e09700cb8a9cfd4aa5768c86db8fa6f3f469ebbd85be33826e60e763101536d87919817173b897820d35ae8a5ab52b93ca8d0bd26c22bfa444effc2e5052d5d2f48b59481d5165f2567e8c169aa57fe01a002742dcbf2b6d689c38394f07a0f61a4449a60bc6b2c4cd6b7f266916ab31652cb27628ca6889f455492a9f9048dea26be91a203261c7e26c6a8848d38d053a4248a495e8e11236ed7798eb289ef4ae3d4cf2e3a7bc09785cc732ca804d757f392b569658596fda6c328c09acb35ba7b981631691e69bbcbb919a2c8476c2888c27ac82efdf69f3dc8997b3d7131599edad7bbddb610d231191f7fdab5c014afe2044fa49cff21d8316509faeed725dc882260dc4f52fd52db08f05d4e13987f845e9fd37dacb3d164e61237a0dea5b915b197c8a1f651524d43a1c1e4572a36d2bd1b44b2d861c0caed4f9371f17c15262e205a262da57f894c699c9ea859adbfa1a968b42032ec0db2a06c9679b56b11086f493b3054b3bd479b8d7baa9a678ad1da772d38a55c934931fcccac3f23e23efdc26122ab142fa3bb84c94877294aac4b12d861f3093b2da625b8c5912296b4c2f5dd60d64b8491d114a55e81ca66814cf21a84e794eebc2107636d67db2ca03bc650e99e7ce79c2b7f559ebd3c0f633fd7b833265e21c4d90d1e41e2ba4b566b15ac15f1958b6868ce4210bc599346f49f0c3af368439344b86a72b1d7a27963304ecc4bf8ef1baa9b9fb766b49fc872c5aabccb219449b69360942c330af61b539d099f97cba196bf29bcb0f2f2070cd2a0e3d5673c7bc26508db3639f526c946d22501ef8c439eb21a9b19ee2b122c43ac3933fff3f898636a5db92786f7ece1300cca4f96e1ad98c3167be3eed64376017b4ac3bb44a68b6bc4c066fdf1f272b0ea9bcf6e42e3f4dd3be382a47dd29eedcc4e08e48a8be106bb091e9c14c8f198ad4f8ee1e1660df689043e9a2347ef43562975a9e588a3af50c4622075c6b356aa6065a6092caae7f0df1acfd2fb3e3ec9bc5d8c8a1ad6c58b5c4e685329165a003b66dfa1f25628c92aad29b46280f39a5e605aded79d8d8ddec6b0156f3362ebb4a93040889d5c9588822cb7be746f4c218259ba22d29f55752c8fcaaac3e6286ca1d79eab4933ffc8fee8e920760f8d839145db193a46b9c65fe0f94249192f0755328aebb732e0500745a4b1f77437c755c787c5717005d0eb3cd548e23bd9fdbc0532afcab8a208fff3cd40f188643a8a8117f1097669c1c2e3b47a5b8a6bbb91a41ac7795903cfc1d27f1dc42738b36612adb5d528a10fdbaa0f3671f4422507bce068e21b07a090af1fd3de505001eeb63500bf28e8d01253b1d763264996c547362543406e69e246d9987d77b58b7a38f571def74c9dc729612bea7e1626488a133471eabbbc8760427e6d63a05760e75c4c3589af2da1e244ccce0cc946c301964a8e6e2892211f931450c031e1e59f166fc2f8f5dcbd3bae723c791a0c2489a737d6331a00ad76777fce76e6db77508b6a6d53b6333da9a75bc41e309845cf9e530f3a900d730aa6c04afc5d3c9c715e3ada375d82c7e93feefd957930c03d95a58aa289fdfa22dbd7cdb8015349ff24f3283ad564c305e1d72a454a2e6aac8428bd0ec9844aa095b236cf38b9a4c90c3e61a129907f053a49c8d7917739cbdd6e3d5cd51a1487bd11c98b45174c197d3c6da7d7d062064b42c6a4b9e516f5440d7bd22e6a0e08a75cb20a192d6cd099ed4bb8dc82c60279b597bec9d749d35add76922c12098e0e8212c60b0a51bdfa8fc0aa3f1343e18b3ff6a4e261de424996bb25f3fab8b29f5774a0e9a73f4f4d63361edb7da2f8fc1f3fb380c04206dd6729c17a63bc5ce4168a1d58f485480e7332650d10a2016c9c745159c292d18c91414ee70864275b915ae9b16c6df558f7aad92fb1f2a6aa8c9854e61d9c956a042cd23d8967b0a9db793a48dea0d758488e693786999c0703dfc547aec3f72f96535a506d0ec89b77f54bd8bb747114c19df3807c9a2271fb90fbceb8c60a5cf7b4b8e8b4db62aa6ab2bd2f8505f6fefb39037feab3056a93580afa996abc2b8b8b66f8a644163cf8c1bb903f1ae7e3654133b62b3d32c2765f88cfa1887866e148656a20a929231019e7f2a9727419590ae7dd30e9fa545592c0e7dfbbc8dfd575da44d80f01024c4b1cb01dfa8f978aecf70a4527c96d652a445fca5792c184e69264673c46650f5396a4df2283afb39696abfea39906b8118a68f98ed7760a3daf735963b9fe6dfc8c421df8b570e647892401b7b7a34b816c232a0e763cb8e74927ae535d5b7f06688afd0bcb4d0085571ce41f9129aaebc66cb77ff77a41c89d759c8df848e87fab6dc52a1f11f157594d9d524693c5edd41b7052b7b21efc12c981960eb8fde57f6989887f43f7d4cbaac54db7459f6de4d11e69fdd4feeac3fba364feaaa0f2a7db14c4e048c35604efd5c0a15e4a6a49895755d6330c8dccaf4b9bb70a94c117f239c4f37e51fc207b5a76a427c4521851ec8914e2eb5ad2a6503277e229710b98f272bee2a62c456134d5f4977e1ed8e84686107870206460cfc94e7f2d38e20033f78a526bf8e3a47dba1720ff21a4779de513fcd15a4a2eafa044d5a0f59697bb3b80187453636735fc1c3d2abb5709aaed9f9abc0fe5583842cad65a0fe44600fe9eda0bee3f946ccecac2cbc5d9dad4da4fb7e1201c39e63a9027e10679a901e42cc9e999e89111bdf35a468be892724eafe8963719f607ec9020a88b29819942e252f93ae7e8c7edfa175a38a61e098821584b3118b3e79f1bf07fa89b26548f3bffde153849da56120c0e59cd0085a387953199ae76cc0243a760d7d53dd177cea07a5935a29526f0e40652a1bceb9a5517c5e8fb392be613449c2f9c8e14952fdfaf136096934736404d9378661eb9909ab28583f3fc469c694630c73b44b5146b08d5b9dfa1e7d0e49506ddee25c1f6879dffde1ca0e71bdc4f18c6d1be5111137adb4bb362a4660127ab672c06414f8ff07adcd92cba0a82515b33dd8b94797749a0eb0672e9b97eeb4e63200042513f5c241a412c705ae51caa47d065ef1370a506809a123e1fb0381062b3ee170ca5a2428459d2ba1c966e496d35a6abbf9654a802ae411a4f448d7f4d78c03d576e1616617d601607462073e5d99ef1e1c43b5619737ffebe760874b772957e6a206e5b846489b478f401d693880d74d67aac72fd0a398701ae0f42d8218348f574f3a66fbf54e963462d3a15ccee592a7c0c47b751dbc5e8e79124bf6ffb2f958d807781edc98047f538e6db7d4356a2e119f0ed7d0398cf645ef32fa39ecf70b7823fcc98f429e2b9b6a7ea08c367286fbd3939c3b3190086591d630730732cafc85fb86eb4dd6c6846e5d9ef6c2e5c4b16f6fe3e9eecf9ff27b05fe8705240a5a547ad76c6284a4b567ec625a6f915d1cb6b567687aebd8d430e57ced627f535428997a1ce6a89e705e0f11d4b450332773e506e525a997e639f7d71addb9dd39a216d92456247dceac645d5c21e93fd21cf940a7f34ee7a3feb3e2a216ee300aace9b4dc6d37e0a918f6c65dadb52da30c8992019b3b6bb71c94a0bf7ac90964ed73017ac41e0f0e81793a0b488fa61e2ccec252ce382786114dffb2ce22fe247bd15488a597bc7c384536f3e5b96f99321de6875da3e9621439e065b71d94b8d4f81b90f63ab81878f90a1fd4832a3b334c7dcb87a2203f77c7a2a80398e56522aa48e378fd45d575214a9a3d0e20c9c4cb4f69486d34464790a77b1d542994ef64a513f1a304cb3572c74787339d92a04f6bcc3316c63ee9ec0eb9fc96b72893de25d80c5bc08a9bbf85170004d7faa40055fe74de93cea985a2607ebb6f2a5d3a5ebf2a498e1448d874fd027f1d7a8c157352230f5760bb127bc427fecf6d2e3ce0fa003f4deb11e98a5a5ae2281b2e9b7b931c2a404c3c80bd4258daab751c3ca96ef46c20e6d5dd96729c18b999bce6eaffffd424bef22cf45b0c9dc401ce03e0a76c9e8748e58b9d177bbfbb01e27d8fa3b3034ac8a185acf615a23575129178913c8434c50dbed1e05e401a6789020d43a4991231e572b15bc3202a220f2b7ff39914a240264de6c678bfc601b3f11079622636a1039ffe1911120a12433618ba99d3fc20068fcd2c76d0ba626b418a85f524f70b1128894a8e4dce7b9defea3f77ed594dfacd73ad7541949d2b3c37e6b1624e72a668879b083182ee6d1eb55b5dd354f1d5e15c38ca0297906d1de895596a28a5984daf840882a48549792092397adac3f44e00e306a92c0c882c8260ee82c8259f52997238275d7525346394e2434c0d1837351d8e26bebb1e983e80cd9b5fb4603c764dd9a07407b8da1a4ce0c7309e8812c81dacf2ed334c4c315791ea61fea8ca10ca3a0c3ae2b6c4a7ad317275411b4702dbf05f20586dc4a6f9a99334395d517aa386b817b21eafee42aef1a37ad046d3f86d6b71990a2ac1b7cc8e7dd71bdcf03ec225317366f126f6cd2ef271dd6f807511bdc1c8909f30236db13fcbc7f5139d407911cac11f20889d0673a5dbfe0d7478f5dc7faa9c2e7a9da2130f5cdc62569ffe06c89aba895d06a5b5aed892a754cfe1bbf90bb52aa6c23c5fe1aa5bb68b38a49b8a1331bb98904b8792cdb8e5e1c36f1b7af855f16727c1f38cea2fb62a5a373247aae6c4928c415ec5f6f88b91bfea1eb8497900429034e3b340f8f4cf1097e09d98252f73c318b09c0a9353fed45c2408ce9ad8d0883166301df4ab6baf51bfcc2f0398ca141aa74fe7640d0597aa3358afde11f8283d6a7f716d3a9baee15a752542275d5ec1f94dfeee4234c9cd34cbea52b911cfca7ee88fdc7667b7b477963c640efece25b4d714ebdfa24388ae9fefbcb4c020bed6320f5651e51d055e7f9d9c2e78ec2ebdd5a6ce36b6f7aaa25b6d16f6eb0b66523e3f78c1073bbe9a9d19d92e231318411f7e939c47f5ce3541b3ed550f2a0ec9051322b1e5080008191160eea7dd4dd81da8c6119b62fa505c47d88c5fbdec4ec25a850d379450f28d2dc12e0c4be19dacebc66fb71d0caf24ab4c42ca24b090c45c5cb4f51f00965a2bc0e16654af717b0cb49261e49404bf02bcf9b14536eea3378b8e78e1c3fac46a1c4ab24b0087d277a1dc98581a027c2d4e62d0c80789a7cc8a1d41bab2682a41b7e4e064e5a23bc493070007a91bbe1cd4c0bf0450281bc745bc4c9217abf24e096825b99dd821902fd0bf808b6e695667def30f450eefa9403cd4caee65a6978dd2d7c7d584bf18a95921d40a3ee9c1bc73f7b318ec19309fb6d422f15e3711cdb8a30a4fe329942a8f34a23c168965f87f7a6ef742d25c2723c18a0bea632803dc6cb262fa6fe0d73dc8ac0d5e1d48a9e90f2e8f45e09e3927589232500678800b5f2ef448b4093316e8157611565627c1018277cfb155815d71f41aa8afe0a719076b2a81636163696953ebd13db527e67bb0bd47ebdd4abf08837232aef830b2868c6dce77eb230e8e9f8616b2fec8b6dee45d62afe48e1b2f3366c3f2512fedbedc37738bbff74f8dfc96f205cc3bf966c65779db64232f2e92765b743d59fe11600a2a6803f33e62bf5b7aabd2582ba2baba14b547ccbf61c2740742236cf2cf475f296c4c0bb68ef38ee9bf114806f0ccb2aa725e0f82195eb8cc2f5027bae3c9eb5ae7cd96baf7ae3607cd54432b85d15771610a7982280a6fde2d07e94efdd84e1cf3430509b68c948a6f84a27a70d0914942485c01396892712d042bdcea236a97af300dfe0ddc316060c36a8d408f652022d2dc85efda45a8205fe75e052075b507d0026be162306c2c90ef51b4b05b63ff42eb9d00d6c52ccde68e2bcf39339d8e1d4af1a72350fa6acc543e1bbf0a6089e7cd602a03729a21c5caf4e90b171bb43f70c01d14da7dad8b4c55be80e6991862ef3bb48a172c08f0daab017f2bf62a944e3bc3761150279e7abbbbabb3863f1074658d96c00814a1bcbe74a9c38ff088cf47a5f1ec7bfd395925188d35854e1c3073138938e780e5114cfcd68ab9dbdf414aa83831fa850252d051c4fe7b4497cc657e0cc544d1d4e10a09b6853da5294311d939eb40c7badad2ca5c275518aace0aa48cf3c05c556fa707f8d1deb0f7a78910ef720a530681c68e5ac92e86cfec1810151c75c13a1323074be38705f839376001e6f3f7a97f0e6468c3aa92842950d785f3b601f0cc18491d3f5717ee718c8740279cc7840fc2a1fc4f6b445798e661e3f6cbad613378cecb7a424f3f80fb11b38fb3bc55d60591bd01741da55b2aa03d7bf13e782232e7c6a601726f4c226ed18203e83e96b0cc5d495060c2f1c7fd22eb0ef57af8be370a0bf25b8c17afcabe894ec87d0e07ba8a8258f1c3a73da1dbea71ed986e9d70b31025dfb337fa3805fedcd0644f8dfafc38c910cd705e72ce090ac6dd9fe46b18b15aaf32174e2453a60d909543a6f961fafdcaa91a050717c8949ca76b0a45bbbcba681ca35b9dc1ff8b807b5d2197ffce22265431d98b4773e90a42857fcf0c30890a54437ec82eab16cbf9d8f9f46c6b8c41286845da7031d392cb603665f8e7a216b18b40735eee5c3b5d7d6c8460cd03cacc7ddb68c6af4b163d6a11b3033757fba78bda4ed48b4d33c158030d4f3ffaf4bcbd9ec70c6bb12e4c56d2fde2bac87aa6e869d1d734af5efff99d9c384ddde6879fa6560af78eabc9bd94b572d945e8efb2aa87e72ecd96a4aa2b5bf66d61672dcfce4bd26d7cf0a2b03550a259bb49c35a9bfa6ed1b20ea0908b776f10437fd3013d65c7576c6bc1498a0a10d76e711073a720136f74b589fcd95403f5c86be21d5d26d150861ec760a724fab486c2cdfb6e92c5f0aa249cf4d419097154f2659ccc3660ca70760b653aff1556495b525d7cbefe5f9c33af9a7016d8e57d1f8ece9df45df16f02724888cd52b74a55b63fcc6f46b678254b19501ed2f201387d2f7cb2ef0c2f0ef53b1a3a0d4aca664b2570ca2554fb598947b07c6837f07b3b9e15c3c5c1a113774881a8c2b9c62d2c43830bfb28fddbc686d08283400064ac81cd529e7f5c9b66d192c26f9443beb9d0d88c721294817b97becf9f90c3e118f7abad5da158f73670d232fafb6228a2f622c801604a6ebfbe77e824ad9b0bc6db725262714b900f2d0efa2ab64db3435a7631346ef4da9fed1fe1b939d526d5b15b8ea1d3cb77d0edb7ae73ae88a23eb48e9627d9798a87fa434187303aeeacd424bca41ed9456f22809aefb1f813f639467de51e5f4a55db0bbbf395c03817aba08b6a114beeb350439ec5644738c5b06ebaaf9541d1363c3bdc6998eff49487985f11486a4b5ca45de7b7992a31f56bb85c1141710d476dc2fe4ca2989cb873684032516a9e989c1bceec7cc4776801532fe993d81f046b8927cb62e360394eac43303b20ecdcbe0e5c36ddb2625466ffc9473f4962706f83d750a72dd0801928833d2f05734d822b4081f8719040ad8fd0720620a158283073ee00168f947e28bcd5c5ff086e880fb0cca429545fd6df100b5cfcf7b94f7ffd8f8745e7ec8abbdd3fb659b4eccf55408ad54a5b1226532dd87b782148a7250cfa037d6e9fc4937cac8e9fdf1629a78edc8f8be67df4827a2445881931ccedb7533fc79e82956c4544c05423859b47d933cb6f7bf75732896b03f2317af3665e9837c0f9469ab3bd5b0a0a719438142b0918ef57dcd03833207a8a68f397449deb8bfb79d63d2a41775d894ceaf421da624f6eb2196656101ce0954493789e9ddff2192025ea4155a77e7a56334ff48207a1a544e11fd36f103c62529d109cb5be9faf3aec274621e975c0b0829f85ac8ebf75046e3b5bc5f7b16adc42c3668dc5e1fb54574450b2555e8fa98fec01b9de0964acb6fcb513190c4ec443224d89b0b5a4e87f8bd6a55de50b5da5671d282439cb71b853613f928b33be43f1caf5e221ecc2066ea0e1cb22df877e8659b74ba603c3c0909302d588672b4a3f07f3fff474282b7761b4f734aa87d713cf1b313859054ea0787852425d192fdd68e761d06544999c00a81f0193850481482f902b1f00347110bba8139c6d0e865a7ba18cd7258f8c2f77e0e1b4160709d03f633c890be9cae7b796a4e27156dfe9ff33242c334a853e4dee0825522a13780d1264d0e81f347529dd54bf3afc36b189a6092f0375e41837bfbb177d29c01a9face60f54eee6f2d240d17f513545179bd657d7442336e9d542a20e01729901dfb07e790f3effc26fd801a980636b20ea3dd538ab9161299046868fe7171035592e2db91adde22205ea20a390401cf039569c47b5271c4ec0339b7572ecc73aaf3eb5c3ccc77acb34923fe9309e6a0b9da13de10792342fb29eb81b2a04b68465fa806ca7787039e1caac3699779eeab97498affa376e850f5173a8987757b937408d242b79eb2ecedf84aea0f41678da0b50a2f30ce507191988bfe0bb836d7b8140246a52dff92bc2082e5b51d68d890c2f8340d4d3048830c0bc5a4dc779e80b2f19a7c474627cc78aa09a703e7e816e1c5626f4ecd365797bbe8a099e5eb7f1ecc22a8c6e5cd596e79e23562d2a4786426d7b530729f7a549dc4287174c1b151461cbc8e0a5d39aa416ece3f9dafbd63540654650aa58c92fac8d5fa7c831789ab98280fbc839964573cbe686574ed1a38c50a1009f8b8ab0c83d8aa4833124b54243152302d59d99142e37246d1d46c821064b28e76f5b46dc7ec3b14d5afac94df98a9734e6af728a15d6d80ebd7f301eb8dfd799b1248817593c6ce2c4726f9fb1fa2b0f84abb7571d83e837f4fa98ee996fc7f42d9329fa40776e8ed51f14987f1f4062d8afffa7f87d467f190b75b1e800dc0e2527bb164957f735747de18fa2c63db6785463177d3685298fb518edbe730bee52e4db000a99a44155f5cc2be2684b419b235920ad7ddb8ce1f1f0de22156e942d8de61d4e9d5be6979a127e92694fb3b3e82d9f7a1ee52756ba45e3b3f15d68c113a7d5631e900816c1e90808c12ad5d9cbdfcbb389162c967abf6e819018c39f805b36976daee165cfa71de5ff85be2d3d8a25d668b4247e3b073791738fcc5d637f175b095721163b1a60d2c38da92fe0fd7ae0fa99e984268b8fe05cdf45f68bacf95c899129d745c89acc59d982355e749675140b9c9644f2a5fac5d8e1d83dbb0f3ad741cc3875cf25309ba22a483181c6860719b786362f407c090c9ff038670c10af5cbd72e1296db778de5625fbedb7b9ce06bf78adcefa68494b07a0fb38aa938f643a74ca233f8757f53696263678d2daa0173d7ef85b79704dc77f711acd0f1a4d63a9c4628ef56c1dc59ad215158e84135f15e453ee0174979367f353b984224056608d6e891717796a684cbffffac78d36d382bdc1e96c3bea87c1c7b18470ef4948a966af9a8de308dfb09f337b4f92e420def94a62d4400af9b9f9d4a3c2d8f06c7a7b07e9c724cafab7ef49bfb89174e6b01983b5252042931815b1f21a23823919acbb7eaf9eade5135efc7dba3ffeedc32fc1bb5fd4a6f5df63751083a31133f2d4a772a507048958ea50a845a62f55ba41bb7f288d5b7ccd8de5b4375bd6bdc71709f9ad12c3341235af81e68fa47c957db458d67ab35efea6f9184758308943c8f094e1fd6859fb66f8021a1436381cda630232bf3bd9930b7e8e45d360dc8e70cd53463ae2fb2a8be112c8f132131a051f197ce06c1cf2dff009881f7554379a2ddcae8111092b44b2b313e4e294d562ae3ba9651d375e8d2ad2dd0c025a5d2d38f21434fd98946ffdeda899672f7378eca95221671a3cfb0be9409da57e21237353826e55d093104da7207edc440c6a18282e786caac2fc1679733a9f8a050f186b13c5179d77cf5efc4dfd3f88d7a1746b97f43477bdc0e4fe63c75a66bbe3b0e7adb82899e348fd1ec02a0c47d4aa2f7294e1f4aae9129ad581cfbda1af571e25acd1e14eb25d577dfd550a424f21dda0e4015743aadfcb08801feb9dfce4551e557c67470415a5fe940de3a17fb59a3795ed8e07ab652efd29e12334e5793a849d050aac376bc38e7ea797e2e563ffafbc855d5993f5084ad5232555644daad60c299def99c7293ca8c877f5fd2ce5599745ea3111616ca9408f6b40647b35e03332c6f358e421cef3af390ed79339ffd4f382089ed18ffa4a82ff45a07e443249129552186ebc9cd8f1336a8aa44fd1dce7a8056dfe8c48d9e36995db5b7728d299b2238a0c2c22d28e0c396ab822e30ae8665c9d0ebe17f94506c0a267555df534af9ffe60de45f46f9df42b561d5d417e2d908a8fda311a6b0e981faa276eabe04be5bf2caa27b4379eb41c1e8d0235769d9862d8ade422da4f433ba80e8fc240c5eabf61efc9f54baa3d54f2b5e4f189e1c217d830beafbbf690fa1de6c6b7914af67383a6baeb17fb9f1e102177729199d533c95abc2e35fea3bcd7f936f58682370c07a530b6ffa47ce04bae52891883735a8e83db0ee36c032bfa4917f6b4a295bc32615fa427ffc6565f1742ec149aebde9074fc1c111dab79cfee6f4783ea45b230d440c2d01a375c72ed832ea00d595686cd5c1fc2642120967260846098e2734a80d276eaec142f6182e67a2fa4fd4e5b1591223069a08d436fdc0d068e939dee393c5659e57fa839deb4998fa938f56f198d27f55db11206e6f537db09fd4eae8de9827a6d80e5993bf8fdbd1f2a59e903f7f9e3e5bda83c81bc2e975d53bafa6ce4b65789fef71738184eae06d29ebc2154487127530c2f89be28f45cd93363c6e4a070b275b6453bfa6512b21ac88a162d99a6be48c9108f7023c9fe0b94c268defe3205120ce28a7cb7ad5332974c63cbdc096ef45edafdaf6d0963b602c0641dfab47867bb2b63bf7d0c1f1faec5cc806e62bb837d224551bcea00b5f936688751df79fa281a744b6ef1cbdf11cc567fa514a38e82721463256045432114f30369f9667419a5e4f98d641e6f35e4799665ea8572b9794429b84f9d8fc8d70fd579a9e2f37634663bfdde3c409633f12a14c95a6aca7e751aa768d1a57fc7786646e91d98481f2cd7d9f9789bf9e19d8fa3df7fc94f0e301be8cc7c9de56574f153f901dde4dd9826385a9b0dac41f48211210c7b2047ef7fda5e6224695b4f967a898cf01a41df4d163a670cf3329a5a19a653ef88c8d28e215b8e1b7accf74d59cb28fcbcbe878cc80cfe6968fb46b79dc63e167ccbb90df3c110a2cd89ed07d348517b0468b1db77e89299a68d7b127572f6ad1799eb997cdfe4f5ce1f1b67328096682adbc62f191d14dd499693aba04fb712ebba709ea4a2b1dfedee5dd82de42af64c491ca7563b422bd7b634b65350310ba1c9a971023283dcfdb74396cf6e94988bd528aa09ca46c977231ee1f9f84c80e0a6f9f682b04a9f9e57215264889d28ceaefe409bf99088ac33c70ae572ab9bf6bf2e2ee91c58e0a8eca086848c1ac1d96583287a0643fa3bb24e45705add525edcc8ade6d931d8d78637947a8cc3f4af654ec1899402f6bf865a645c673b9c776d4b026bb39ec7ac3cea3d9be06f2fcd64695ac47c0ce79f2321e5c5ad6a7077e8fe6762ef7c5a32e1c61753bbc402c06c7330a405e86aa19c659f4fc3501dd7eff0c2c07eb7947389f23c51963a3f9f7b5d3119c2d387d878adf4dcb00dfcac9eb91fb2480a1f1699149aed84555c07cb33b4b51a45cae0640be8b3e3afe817355f3ea35fdcb630c13ad4fae9dbaec1e80fc7dd68b3c1685885592e5892cf358bf9599a29378bbd2c7c764c848ac252809cca62e7572a57e59482ad8151e1f5506c6f6686bbb893936fcd355b1494dcfd129d7b918a2cf17e6ff68fc17c8f69e12d44c036186b04c22d43ca09dad00571b3a84cb92df6a72720ff0e7d197ce913bf0e5cab7b0506a7ca73d36e0b41886eeb0a36a845c559542eb289b83d59f387eb373929f38c2ebb3b529fd8767e4fad79526cb3bda557175a221f5208778246ed0f4f6f8aeb46a665ad92f0cbc54b3b946d38e4e931f2e8bd2ad4208fc401ebdad2a57d24655f5f1c35c04637c363280e3dbfff72fc2197e6aeb7d83e0bcb9252a8ce806cf13b5032c9efc2092a5992c7a3d4389d7191394ac9de476c1fbf0586002ce8325188bff3780e6d648e789438ce76b0e07c66d95f2eb1cb56e44fcac51659e7e134896cd5a376529a277b399a89ddc1692c137227f5e35136a96be8844c16fe2aaeef64cae7aff592ef668905e9f334071942f97545d376006262dbaba4fcc584c64211fc415f7cf4ee3b7a283bb18c7ed9320d8b29e2a5dd38acd49975bab9c2b2ffd0f1e9cd5aa13b510d8dead0a752ce4c875f9c1e72df2943c502c92680c752356618a667f9a609989ad200ed2bf0affb2c340afc4cf19bb182c9e080d9b2900ad691e5d300f67fb67b9eede414f581cbedf5d727a3bea34761c4d2612b6c76da9468c01eebf4f1c1ef4d44030550a60c46dc9e23e2fbc7a063ed4133cb84e64ae5e4db5b5cd98bfec7fd8df23812d6b73dd081b9997fc1444e73484fd91d9b07c66c6dadb653397a55b46af52739dcefeb678039f524f8992034b6b7853ef54b9330582bb538f01cf2dd67a3732670dc71d561afa6c4cc0b35d1fe1d06cfa31cf09b8ed911fb2ebbeeee47a463b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
