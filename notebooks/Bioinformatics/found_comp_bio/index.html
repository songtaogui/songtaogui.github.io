<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8de91541c8203b997767a6492c590f230fc0d4040d604e4f84f89add53e0b5aff29d80d5224e4d32ede9f1bc3351592ee5604092c07ba5e7cd5c5898cfba1f7efed286253130a0ff602ad0dd705756944bff1c8dc47615e31191d271eb045d1d2c5f0659df3c423dddb2d35dfa42ef81ac087f4e63d84c0435a6e64d67a085344d1170dfe8038b3971ed5ab4d18ad346e5660adfe5ece09ee6c67d6c8001f5a6f82b8cb891bc0126d8e89bb14f8ebb8f160be4f1c4fb475f6bb28c9afd5ac2e3d969a973befad4f0cf5a4ee71d372a4708b02ff07b4d7efb4cb3fe83675c24ccc60c1cfa0c29cdc15db73e16b91bd43f7397b672cc086724e0d82097996bb66470a97a941a21495c9ecccae21380e35bd9d3d08fc8cd924ce494f8b3c2b7d7ad0681c3b02d9f05d4e88fd4dc38071bd8ada14d00659cbd62652ac2ff3cfcdbec1fd87b3255d53531bfb00631d476f76e8029205c567429973cbbac14e6be4303f02f97b47ef402fd610f2f40e404f0d674e44958f0b299d1d0ec3181f9c474afffeb154443fb3c9dd0aa2b6a4fafe46a40a6ff3601bb24c5034b85623e94a420068d1d17430b3b95369b28fbb876d849279b837695a2f0e31c3ee31c63442d0a030ad3430d80c963ddc7909df5ce7b4281b8ea294470f13e38ffe56c59c5d9126a5dbe447521102d51a1319de9aaf074f4b8237fff2e8bc8c96aade6635dca629be77c2727468f0306d6d5a43ce2e951cdfc43fd1795d89d06a32f3c7d0d3e784162e3707ba48e3ce69c1853ca7633b46e995593dde6f5b7b2e8bc612ebf61e743bdda247f10d37badeb14a393516ddeb95efc8179d41f15087f47a9aa583de725302f6d09f913c0ba99a4c1a478cbf6f5fc22218777a471bc05a87f7937f5bcd0a168fca0cfb91099a45e3bf3956423590caa70a9756e051ec66a62b2bbb1c9dd61780641899d35398754691f27d35976952b5a3d277fa21d68c0e0f4eec1f251c27d7d6e0ec49813f2269838844615067c70f82264b32ea5d5a746a24935759a64c24f923f169187271e607dc21c21d98b438e28058232987126e7f3e467d23a9608aa0ca56c81d8efd74df8f007e45c4fcf29b5aaca9246ce8b7ee400f46847ea91637545decc511255f72de1b2c20954eb2dcde895ef4fdea5220be7ce56c1637517cd72da73927adc974546308824d45e7a23adcf4a9fd29d53d4855698ce2a343ec35de6722f470c2c9320733589df5129f69358198c64de7cc84986d3a8e2448a8ebf3d031ac34888c30e67a6f327b092a0a20255e87bc6484490a00d0ac8559888b531895e1f3fb9c7ede1643f681768444a06a6a84463960c6302e2a09684f6b782a60f2e4734f9a3afdec24249ae2827a5a79773dae4790e8b12716c72d6fd79aedba229d59759ca0f9677398c1434c8fe327b1b23fecb503ed62a8c862f1ba97a11331da9ebf195c57170f79f79046bd8c643ffb2f8c9f296c6936fc4cfb902dca9964a2c697c6bd404640f1f37baed085e2b76b0f0de8a6b399bfdbe9bd2c30f2b451723bf7dffdcfb3b03e3a93af3cf42268bd415c955e085d90fe11230ac359df3f973daec821ea26251ca70ac0a3dc8d88f67b9320da04b697fce59517b3a4ae4b77307e04aeadd30a11fed014a4d35ab3730d36c0bcec0cbe0807121355105646c7a648179b9987ab25377d3ac8aaed03267264796575a43bcae98dee2e388f162292e6a9f31609ece2bf04b49e6ec3517ef73850ead748042659bcc7666cb3e8deffa8b7badd2b020407a4dbeb7de94e7ae6448795ee028be195bc5f0a4b469e8fdb7ae176b087e48925691d325c06c416cbecb74a85fffc5bf2a90b6430b0f75f89ca6e9a501a5fa8751be1e1662b01ca2ac34dc7cc80b65e99e945ff5d51ee4484f6fab82fd196d81accdfce2d20fa3d50366271c7cc3b88805baddacd3152e7c2e5f62351a74c1120474f98c6e174e5576bb5bfaf4b6deceb18158eedeb986ceb7f8cef7863fb6fb1c9d95d2d1f7e6c10baa3dfd89d88e06c50ee74cb22527d1956cad5bf49996a967a5063c5ef90223a9359dfaf82a5303621bac6d327f00010a1b668f85d00a649b71704ad60e7f5db19b74e07999442f5d1688d7e8ad1e5cf017092f3291f9395d216b6cdba6194fe772106376ee28ac119f5b65a65f292de30cb71fcf41e89841749a4aaccdf485d77c565f53d254692ec1cd6c9a342db4108f2578d3cf7d9cc9db540f4b829c6e0d6aa8c9eb03742dad8f194ab8a4019dc8ce3e8fccddd2f9ef4e7aa0a333be913cd2013d7e0ce87e0fa1ce5b03871f07bc96ae7b5726e9c20ca0d9c92433450206d5745e28bc923c137c9263fa6cd560f204bfdcca9e59e28085d9e63a5aca8483655b91b3c8b095115650bf24bd99f9eabb9ff99a4c2725dde037dbc149798b633705efcd002731a2ff9e7339fc57fbf7c94e3f3c93ddcff1709b70f8d1975a66d3c52fa3b11b6a4cd51bcecdd51cfc92f3eeecc57cadb7d9e941df6ee08c79d66b2305bc4f9b4b55e339d35c1b07588e25ccd648f2310072c2748c791de7c190fa6e004602c64811cb579401c4c60a17d573c669287ba888cf92d847391e96bc5c58e87d37cc2a73a67afd8fbd80c9a305b796699ecbfbdad7a20708e02a49753ace322727b5eeefeb41de400ff826f77e158ab1b680e6c036f93d653a2d09920335807120ff48bdfc52a931f9eb5a42509ec5606819a305fff0ed18ee21c3558cc5fcc7a8a5cd792d3e7c24927293a922a4d5f710a95887492c545728e03903713e3d1035fc64fa56903c0642a6e4ce84b7ffe8f51d80b5f910524647dbc343bba064d6e9b068c736144a0babb00bc67b720af424556870155a82fa31399e11dc79042fd524e139aaf45f2f7384cb53548b9985fa208d6ec768b68248de27dc2fcedb5c6c89991787aedd3f1d3816205b77cb6fd5821b118154647a722df9f14bfe0e53f7d68505564e98d9e39b6f255e8aed45cdd20670d5210cc88f01f5cacdd42d6d592d4bf1e62b97ec2d27ece5791507180bf55660b7896c391381f6ee5a61077a7087fa609a121a3c164033fab27a0ba9f0be7f1d3d02b6055e8d7d4b010270f648453e478b88b34875b7a42c8bd9453b362add7f306aeb6c6fcd3d68087977db31b28eb82223a01e89b2369cd6f9d73cdb7920f7764689091a54fa7ea27570db651975d47cf4bdf9fab615dc9bd75721fd25e0af47ee28a0544702287df7d5d52adb513e41724b7a606e8309ec4824e80bfc97d712268f745c0f8b1b2de21b3fbc879842f5bc6f2b33c97a61b614454820ad504af05418f09ca878b256c2ee945e8a5583f5d3e8e60b7966b64c45d404a668003011281c85eab6669d179ec92d0b1c40b068edb902079cfc5b82e623d24a323ac83b8c2ce18003ac216c67e3ce322cd6d2d2ed8b8a85513ba4e0922899fe92e931f6b66e76372a5141236ee260432afbe58b35cd3fc37e912c50eea0df23f0920867e0d8c8f80bc8d50dca19a455230b41af1f858f4d3aa01a9e980c8f26cdc6b059d67103d3cf7ca9a6d0619a7044c3596ee668a445c5abf18c5bc8f79197393226dc5bad6b7c6325058236cf22ebb00299040bdc9a0644ad72b1bc6596eb916ab05313a6c2124b6272d3f58c3df0bf198ca4bc1f24756b0f4193685ada99f75acf432890080eddea13f0790d76a7c88e5290bfbaa6deb12f365ae82efa664c2f8df50ba251169e80f812376beb29ed0c508518df60e001fc90a43bf3ef2a3410cc1675bb69d03bef4530fba99c1eb8f2203c7b4eebf870fcf7ed376cb1fd56e0a3423d28063c3870d1d7f57f10d82566ce46ef833baa5f36c603608ad1bb8b7d958e7e5ddc3afa9990020d3d0f48a61440eee078ffc303db61fb2d7d4c687252b9c600193fe1ea1fea37361c976c93b8afa7ffd100ead842da069221c24c06d6dca7fe8bb0b9df732db30e4508cf861df9e2744789a857ef3f63c04f737df2d767b8b5d01794684d4525e297e909be5feaaa4162c6898e5fee35e42b08ddaff8425c567ad7ed51516b188a755dabd6d395e44ea33bb336629387d2d8ea89210091edfe41b44052fbed08308647222dc36292bb3211feae1fd72d37433728a46e76533838d60c391aed601e247defa22cee01bd00f97df88b62640b8447a9600722626f9b929f4624154d377507b9f9290490b29c1c21f3305399af14b3e897fface5854957f0deac48e4056a871816757988142b33964dfa6579012f30abd8b30e1a76ea5cb9b0c736e76cb73a5490da0cfc1b0e54daa0b71b3d87a30b2b658bf0405456029b10f976c1b24f4bcd55f80aa711092ebcc9f39d9f6fac7f6acb0e03b6bce67cd2e29f2039d5139aca34e0bafb73aad995b287f06e806537203d72e858e07e36f447e8ecf5037625dd103ebe97c40450fb4d9a3af986c0a5973f4b1f2df5a0973df25492064ac5bac29e94026f66a21156df03beb16da1b4ad7a5ccc9c0378d0e484bb24e33c05de12799dc69205638aa27c83510ccdb510e42bdc2d62d0f1cffdcafd44f2d802547aca00dade7ac6ab94daca909a123341ca723c7696a39aafce4cf788f36a25609998fc7af331256b7a5241128cc614ebf1a17e19dc38d4cf368f10bb4d11c6b83d758ed06401145954c5f7593756d5cd671791d9e067d2f08e0a291fe3fbe1cab064befd99e5ac61ac2aa734c1405438cd13b8c8389f2bd1bf3cc01ef384856d711f3eb5ee61fb94cda167c030669cc5ac1f312a7c7b707429e33c5f8a02aa19d74e3db7f6de9666e5a06199433a1ecc41611c8aa6015ce3c81f2ee9d4e36ac22bbc66a2b194726256144995592db394f7e3920ae85a699ff600579dcf0525b55a3cb005848deb1180220ff9593deafb556b0d679666af0446ac36c428477e8ac1e0ad20bba75a6868f326b7bc3ff04be2a619f10d2f921f9f5370b7dab934c03c2557f329c2cc87b2267f201f22c387492ceb92f9cb93d1f0d2bdad038a5626b9991d7d918547d31a3485de532e6e5065a6e0b61c8e6dac2a712e71ea660e338ec6c2c3cfe9a61b7eb052523a457bca6c98b10c48255efd248c5ef6985fedec03e01237a940dd5668ccbdd1cdc546b1d8cef7da7a504e7fe1d20bf1f8232a9faa66a91d09f507469d60ee6ea8648feb39ef60b5be4d088019b9882d1b07cf396a93c7e8fccfa5e8098755ccbd5b3a2d8af51249acc8a14e075ab7b1fd947f50b60e1604a0af53b28bcb42b4538a94f5cfd9d8ea10ed43e17279a338b46f87246a1cd79a475f87e0f8808a43d3dc31ec1fb3b1406a110c2f24c792693bf77857d77ccfab290cb47d723b760c5124218e65ec4a8a38672b10b56079b1ff0bbaa1d27c68b25531f73583b1dd5717495e28dd29e48089f550a64ef6df7878d457bd2a42f0ae7126d71195706bbc8e592854196d17c643c514a0af241bc6e71b01464f81a680bdde048866036f0ee5f0a94587297f62a53d7d18b4d6e61da94eb467f085dcde42d8269494c307d74dcac1f470e47c5326230f52c0edd8acebebc9c2b314c5f4cf21da69a580018bc7ea8676d5ccf25e16ab71c8611d3025e4451ca1e0ec87a40f153cedfbfb97319fad60f515db223c835a0ae0600bc7e55e09abbd252a7ec3d726702a5692dbc77cb6b8e526983740b264166be6f02efc3cc87fbc19c9127c7cf7b268b3b0bc989b40d740885686068a01bdde5970199c8042fe4a393b794ee05c5f5971611931327d042da69be584f12e15638ea0900f76ff6bddf1724b0156fbc79c86d6a49e50457cb2ea02e70494d8dc471297c29aa00672daf1d22463a5dbf43290e6f0541fa81d1a92bf2e6caeb69617da1d4c16e333d5194db97c3d3646c7b51aa04bc5c6258a9d4c89dbb45f401baca56d9cdfe56a1e1eb374126b45e657c360deba549a102d73995cdf6c1992da6e38cd14bfcd461fd528e2782606826b8c5b172ee6a575c554c6865141e83c0580ff216716940b7448c901da99ca0f4d30be1c586f24a692314b1d89385523ac3612f7b0d6fb287bcf12bb7b881400b75203284c1c42ba4848209c1807d2d3bb61f2821002ab0c8d4750e7ec00a2688d5871aa65f969f633fd96e5f38c664fcfd86157d70df7e6dd004a68029c6e20315a7c3f16a1a6a6fe93e7c58aec801536c7504369afff2d8d2cfcb01033d3e6b6a073521e6bc32ef943f58e72b995c94020ea31931a8355c813aec433fdf05d02b5693902bf96e1b340c7e22fdd7dfcbc9d70e904b3ad982c91d4d5394c02936fe22e226e3e4ae099d1d816d13dfde09b494e53fd9aacdc25bd0fe104f68c634456268dac9116c097f4f5b90ed8d5af09dbae909742870503049b39215230bcdc3d044c19023dcd68c8b6202d8e444358ee8d54777f994d2d0152784975c2bf529c11c3c3770554c0daa5aa1d50561163ab8b97a97af8c353889b9f0de49b994fe2668ca7647f7a79f451c9ad0f2108a014cfcc8bc1a279f5e9d41f4ba2d68c7c6a4bfcf3b173bfcdadb7b99fdccd80742df7b95ecb83694d726ca6f4d5b2bbefa56566349422431198bdfe5be6b304f1521291782c0c9aa2fbd618870d567bb79f50d6f68bae592e8b904c6796d9e5888064cc146480f182449f4e0f99b491a3ac399a8eca16b72a375f653b4cf6cfb66b5a64d279f1cf8c573d01b883ebfec71c277204018357e0b6e7f1fc55b2b739f0b38f40d201503d943ef42cbe022aa3b3ff6900d6f34441e5b59f19bc5761718857ed110775d2b4178164ed7c5b8577784f7d5a3b4163a2208424341486fdc677b7de88c70ba487bddc9c7dd613b3f1a22da7f4e2ee7c0f2db8e8b49ae25ff992f439639bde453fdfc9c95d0106333208ddf0472abb9607b981944d890a4ee27bc97ca36280d0fc3d69ba9d8d7c8eae4dd8bb8bb4c3ad66039f08f93b05c310cae2877ca4fd35a0b30c6e43adf9eddd5f689b9ba6633bd95ab3d19adc7fb851b9e40ba1d38fac2ec45e7ef96ddb91ad8e661e6ef3c41c682b35ec3742da6ec565ab069e52748b23c42d0b97118dac2a8da0d9aaa5172955a1dce3c3b20eca2c65288a3bd5b35148c0010fa12ab5de720baabbcb7ed26f5d0c9ae07f37775442bbe4da33651c7bd4d98a405743747df149a7fe819411136a852e05af42d9f7221cb43a04dabe1d6f829a042db9412d96f0ead3602f076645d294aa44eb14f9e37b7befdfda0ddaa8408048d6c8112f69b57af429f63422c2c7326f78e99268f52512b34e714a0b710fed1e5b956e82e07bc497a5e8c076cda3850783eb9228e1a2207ab1401cf1376f96288e229ad4f51413b9ae72c5af2de7ac6a0f2770aa73348c85ee269830a7654179a8b8470358c5d98f8617ced5ed992a338a07ad9a08c38479531b15288b8d3fdde5261e7ea8ee945fb9debbed2711410daaf4ade32042fc9e641cd2f9a793f39386840893f4f82e1125b5e339d6141b7cc2e95b231c84795d9cd02f82455adc4791e785982b15f88ea996d50a6b3f342d873ab542adfc70a4210b80796cfa8e0cd6abf195ccd7f85403f5346490195e4b6dc6361b85e910cdf05367a7573c0ee0852e1cd14e7d5ce5e35050065c742bf365d460b9ce02e5264edb8f89ab9120d3aa886708a9dbd5aa644c9749ac1d480d7e56ef9ceb8a0c8db3b1fc9af9bf8e11b60b924ac8e0fe64d8726615fa1a7e7ba353835831c6a22b3cab17c702a9aeed6f8f760d2a1affc007f8a11c454fedd574e0a26c3fec9e58cd9dbec226cedafc5acb46d04fee20233ed54578825bbf77c622ca299d776aaf5280aa8e87b6420eacdc4853e7a32d68e2e99e6d3b3e3ce1f48d742aa7021564252caf583a684119a9d9e6042d2220284334d89168d794243bf4dadad27dd25891ac52a9382edfe835f44b9c66f60909135cec43cfd1d802957847685c259261b43153fcf9d082340766568f58fa4abf0ea87af642da3a76561651a78157bfa5ec3b95ee93c8c034ac01ea28154668a660ae829c6dc7334668a64b0cae4c8956cbc2b1570c098646d53992fcbc31d39cfa05360d29aedf4f92acb9da9bb129cfbb994979b0be2350038c8a81df4c2f90b6d90a1f34d6caa303a8c8e27b19c2bbf1842d54cda1d5c1a9a56c13e00910587bda2c149a1bd30f68dca8894f496f91694b97c53f01e621031de522022dafd7d87760501152a40897bbede64946b64247e866777bffa5fc9999ff841818608ab027a46d47ddaf8f215d8a3c748bee2d638c303bf0273b0a8b86b0f522bc34ffefe4b4db52ab6343e560ff3d28d3ad9e9e960ad96b772e3575e8b1401528dc078095ac28063e773680cbf7020aa3c919c7ccd24e5a886c4d6fcc96f78bffb8dfd6af0b216dc5146042cf6bd2346436d3d68785181deb0ba71dbd7baad95f44debc7a4882c5347fafd7309857f33d05ca0ad4f35091d6ce92849398f47c5c5d6dd6bce0c707d66a3f1189e2fcdb7b9ce0ca253e42464d4c01673eb6a4ba9cede7a75c2617abe1a4fc5a023d4b153161ecd18d411ffee60c6244f0e10d127efbfc222f4b7e2250a45f8f159ec471d6dc9ae5d1567032cc536f46a336a61301670475b7bf56af5a48e84d5b6d5480a9ab410ee24c6167b1afdcfa85b21e525bbf2d926261363f381231c9918ce8405b05ceadc91518be562357c09a84f8833341cc57a9bbf7ff1e95bb0a7511160a246f1865d1df65456d5ab32cecb9de64a9f3b317cffb4ac417b2ba0cacba0b9320b9a5e86e4d7a5221158b5d89d3f7c8f2758223dd82fe895ddc46fe743960ecc6c7cf709c4df79e332971ed62de771c7512d628b5b1621140057f7a1a4a82304df5b2ce8af189c6e2750c74fe3218e5058aad584dc177af0d5cc7aacaf7e87900de24e99a438f20501c8573c2ad1416a2ae69f28d6b442897af0c40a59901dd89b06153f36907fdffb6f38974d19943c9a41a2cd65add366596cd4e6b9c9b6b9800f39c4667abd564d20fc79abc77b02b052cefba460d2bb200ac9aabacdfa1096dfc70884620ddd055486cb03186c976cae7eca03479c5d5d3ba5b5f7d243dd97cc4691d33b83a0e2d62a094667aa134b7fc30a1284cb9415ba42e6c6a4886ac32896ea52d6a1d71111572e0919505123d6f3fadacb60284fa22efad3a9791b71b284751c985f22b8e61f27e94fe599a627b2f404273cfa3249b288f18dd36fee5f33f68994a314b017113ff8b79d1907aaffc1ddab09bd5cc5e74ca677f85713f07d76c9c13be2e465e13ccbe185956d2786e4dc0c8f947318e4a335aac50364d5fac286e2688ccea99a42739872169e25a9da3e2931901ef8afb571db2278f3239a009e2ce49df985a3b34760fb0b6567755c828cebca8cd253ed0560829b2c779db77aad5df53ed791a00368d88052047b8ed38af587a91926cced24b8fde1bf6e371ce91fc211a3c829f7d4dbcf77f2e854376ab65253e2225b4bd5e66e47ed73fa787c4cbb162fdf4a69ba124fa6c60394d7c82a4d6c7d0c22760c3f581a0e6f284a912110e489f5f0251c6b9be51170a1fa877209a721a563d878674d8c7623a99bb0bf63d6f11eee7e2abbd5a3315141e89ab6b01f7914f2cd267781df20935158b123a4c6ad725e5f98559842cf144fba15dd708b9523dd3bb50c7ea8eac9f5816e96307b8af283abb0923435961b743731cd5edafba9746f21ee48abcb6faa95e8ea56a90f85bdd5e8f9118dd96ae857d8545b8b46e916e514237f18c15f6eb36f89ffeada79de17cd6afd3101ea96940ba231aa09af85a8be6674a80f374d3cc2c4db24005bfba919e867e2c4251ede5e85a030bee3257b5d1126e9f1f388a3a8dba2f340e2abfa2f9bbf384c0665e61554591aa22ce3d5f2827377c9acad734b5f2c775a4fa089832471bbf5a27e8c026430278f6e6f55c79678c356fd02a97dd35d941fe1d0f43cb0fd5f9f064b1a0a38684d0505763f60b55a09f2d1fca6b58a74c7a74b071b6e00379a5211633f1f51da92fc3787837946b6345247aa3067ddc0088a075a0115d227e2167c4d24cac0b2d31fc7b82182a6091dd088e851eedaeef3e8b95664b49b1cf9982e2507e75b198f63debc567ed57c47a26abb3f5df614a1671fcf255b7b886e960168f00956474116235b6320ec112615ca251e36e84c4f5b9c4e56040a46e6a4b87041a307c9aaa4ec91f480ee576cc2b56483332e9c9f1a52de2621b77577ede901e2a352915329259e36611651bc6d74c6a66a81a5198c15425402d2f85d71f22f05d0b1aae509190d7cba394b10d82618e976e82839d9b60bd617c19ef7f2afabc6813a939d6d7f22c97ec25f668971c1a06a28b3eb72300f2c147862edd2196cf1e1e63be3aec78a19cce5c6f9f12e60318f56f628aeb7a66116970ac5ee639cd8642ae9e3d0d0b7ecca2edb2324a6687beb1be5dd7d2a9284aa02523b534708136e78d10fe7e2e8fa27f93895d809686bd148d07d241bc4b0466335808becd813114a88f3e28c3c508348c6e623dc5a7db119e666cef33d7e69fb7be532645c3b00e1e15e7ff5a1f3e29c7f2186735fd27ca2110fe48dc954e42312e2f45891838232b96572687c24a6751ecd6746d26aa77614c928339e0cd8eee640d49db57cc180eccb828f395ab6f9ebbe374ddf3c51bdc3cd71fbf8c8a48503e6de6b0c918f5a46079342460ba00a1702a77c834e081bdcca1db6d11fdae731e86de25304eb6adab84c5dba167d0bf95e1090c16ad499bf84c60dbc482c2aff10d922dfac4ac0c03534600304e4165b3c849b0ba16b9f77a7c88a9f048fed70cb6432c72b71435bfaf8e54734932b9e6ca21ca8f164d332b654991f65264087e86d5be91762396c87c70bb3cbc48a30a81556c0a77affa460fbd9eeeddab8cfb8a995bf99b71ad12f78fd86acfa808d9bacf2d06820c160611405e7c901ecf0837cb77744f530864ca920ee1b4bf9f0e30882cb9018281ac966d4e182a24fad86ae3c2878a61ff714234119c603d051678b06411c49ebf4f7fb5c7d0ce445bbfad78611c980e9e52b53c68979f185b4fb8a37be8577e26be703fa59f8c26d5fc59ee3184426995dd6cffc7d32fd8da82e1c80bf3760906447622a1ce20ba8195a4979bbd46b7e518d74e4b91dc43c758bf8fce8d8bcb67e62ac060da86fcfc6a7a4eafda263c5dd6d7f85f84941d025aa7fea93f316a896e78a1c15eae1c4d66370a1ff9c017088075bb4b13ad0c176aa23b2f71c0d827111c9d878d92a717ae35d1dd0b97a9a48eef7c019ab02a991b2c5ec52da3363060fa4f06af29b24b50260be6418ad20d9e9864424b87d8abb24fc8369cfe390c1519f808358643c4e0d94eca5d318cebde2a6a50c67ff206b9899c69ef7ba0686449a976ddcb0721e2aab30b5c6621b3b5f9a29b18aa272433f863a2ba22902008af62ea254f6fde2cc5b8416beed2821583cc963afcb8f6745a6faeac265f6cbd663ba5c65920c347dcf6656f62f4f8c87ebf4cd473e98a29af4781b6c7baf3519569160cf7c417f957b3cf5aecf2233e4e5cfdec7bad10678572547490ce66a1ac5d8683c64969353ae788e264537c06ea8fe9d3fee3d578ee9938d8dfac1bfe196738dd1fab49f4a61f3d8da2f82cf71fd7d4feeedfc3020049e0d494aaf2fbdcf44cd9f3a1d7713eeb73add1c2df04ddc6977d75ab0c046d8b8d7bd6b6abae0a15e554ddbc9d1ff761b3c71f77f74597f3bf74c34e104d18d6b2c21d877a228e787239b3b967b3f79c90398dffa04ec76c84470c059b34f9d31d82903d61259a5a8409575ce7fb8898e557fae73f47b908bfaa375fb6342e9fc7e46a88063b4338d28c193040a6e644e6360d1c3e409983c8934d9c93635f695caaee5e46fb80be498be4d0dd8f924cf362935372a8a84e5c3f2c8fc0e1ec8fb28df2ca605cc0f8d679172f2fd351d344e60f53959b71c913cce27d3cf6e7c8b57f2763c016463095b9ec559bcec452b4826d7d748e44eeb0ecb58454bf63d4ee8965efd4c9650394d187fa712c3c59a6474b0db705844c04ff057404cfd5ba2c5c0caff086b2e0ad3cfbc00b52e43eb43a64a70f0d1eb2e6aef57622e9e3e2a56978f9a07cee696604c671899639484c52a2f7b853672cf83e67a8f0e4b1e5ce102a9da4c0db95b47561fc55ac6a28aa617c73c1ef232e7327d416b661b40a725c1f0b440e738ca0d50180572414cbd03bbeaa6a8240cf72c20dafb2bf11afbaf83b3ace26740f69be228dcd705ce23bcff68979939963862fa109f48491f1719cb13980b71aadae4e5c75c4459cb46cc16422bb3d5979281163d732afa0c6e72689f92bfe0301abead7b92cf15d87e5d9671fdc4e96c5b07741ed5cb3e92070a400d0bed651252a63cd818c77b4d4277b7ada0f1dadee2c5a05498ab5f9e5dc5a2c1f71ed5d54a96867406d473eb03e330887b1e0c582b125131e55815f70d9377816ca65b591a557f939acbfd0000dd3ee267acbad696d30ebe83ab5532a790709c17b192a2e55f0386e102027ef65ac340c707e246bed91121e67d4138baa04729b5d6a8e1d154fb8c19654027446d6ff7166dccb7ddf2aaeab29b0701fd0ba0b4112f3f2657a56b391119610d9d641f021de43c63dbfe5a97deb64eba2c2ace82753941a3e61ac1799b150c606d7d7ec420523b7a45903f63b3d73094c384b93be3dd5a7302acb41a654acaae229057b8f4fcbab0982f58a74e824b12ef943f9e4ce348090231a8a97417c4927a6cd24980c4035cc863f8faa8b4636598e0d7c12d805c8a215515e97e26d509b8316eb690bc74fbd43d42f7aa6f1ff0e4205325b18c221783b24a9ebcdeb76dae6747c8d5984f18d96eaf0a8b7d6fd9d2889e9581365288d4941eca6c72dcdc3865b95e30e4887c8a267a0378560ffa81868e78b78a6eba8b1baefdc37cedf1baa49bf0458b3bf89227026dc60a2ea945e097b5e03838cc7d683ff7d59b3c3e0c7f77f05d80e6fdc9ebcb514f0110e5bdd5848f1e7c6c4c0e03291c37837e9e43f3696ed1ad1f5e32c2a967096b2ba6e0d007a0faf79c1c5f09296fd114eac8b2d9ef34c9e8d496dab833021f5a4a99c5a670fb318ad15148f546a53241b4e19ee19bd7d15c7ba5f8ac846ad592b6c35563c29de7612c378bab79a0ec78d9f8b06d77c6e1fc8aceea10bf195f45b4583470398cf85b9cda4a63d4bbf7a262c58be93eb611de0791e0d172ac948a36786febdd68d7f607a1ae0512d5621aba428c03dbc24a71eb4d75cf1c2be140dab522fbb1eb03a51fc584fdafcedf5a3b4d8e380fdde34f956ac68487f39c5cd423024d525a8645f1144782ca948494e28859959c73a768baa192ec8126b87a54a6b45ccabcc9740af2f0177f84ce2a0a5acc1ea2e84eb5f9efd1d04932dac004da981cdfe7ea1208c3489afdddf3a87907a9324ae1b47929dac9e4758c8068b71b1860ca7fc4bd996bcecab1c517b9f1647836ef9d7d76e0b6e79f39beec25e86357820e9d1e923afe5fcf2184ae3817653552a9fbb0cfab8b9254a6d0ce3d730a28923447f55d8faf770014b19192f31be8e52c4cfd9d229a85e71c6e40ae4d22e225c0b89aea2f53d49548fc484ecc98c86f807e93a45081b3b64984c4c33d7e0800dd3a67f98231cf1da447cff746b23f6287f38dea7853911221e0de649542c767199d23babf39fca8c59c7ee484de632a8be688db1071203f6c7044b90a35dbc9be5f4fd28be1a12fcd9a5dc84a7def30ba085b19b6ea717205a5382b9207e8772aecb67dd933e9e8bfea98b363fa97ba135043b765e1084fcad7193e07c87d3098201e4712b5c53b50c370e08603b44cc6b6c32f48ba4a904ddcb7228878c30d49d966dfb65925ec9ceb0f899549455e158f674699fde45254d10d19b5fa3976d631170847b2c58adc90f48e2ce95642afa395cf10a63af11c9e6ef9a774a96622a32d4e02f9cf06cbcf4ec4ff281c1c728701ef55ac4840e2ae39e946f271898e57ecf14e371ede59d6dee98c4919840398a644e0823013cb50c3bbdd93764346e5ddcce966e2ed4b809d41355e00c35036924579477a2fe48f426b633045dfea37e60954d5d162a127732383b66122f217fa86105d18f29842830b44dfbc91da209de6bd83e27b8447816003578033e2d8f9feeac62cd74deaa4746a2b1776af9aff7311ca408a964d84431d37650c1b54d40b42f8805914a4f889f8976cca421560bfed45e96f8147695e5104dd42e2c8b85f665aa53563526776b8626377b90c9b285633437e32dd73c8ab8c320205575b2377af137f36bfb73055556dc3a6c2e2cbb2f27f6018c82a369940236a27a7041580d5e69bf95201016442d64c9093689b24b1e3b7ac8ac341e5ae0a098c0f1ca4ef97afdaa71cb5aa74792bf07786b471b0c132c377d4d612ae7b83127b4a908eacbceea5083c08efb229352177cab5770773dfb3f29d7369c53ac72cfb886589f5177025fcc49ac39d34e673d1a18ebcf22392186b0f406413c1269d489dd353ef23b1cce799ce083662b589c81e98ef97008b1e50276291ef7ad89397a74bf2d66fe8562968267ad5aee1ee6150d41d520d3a1223e3c9f599688514bc2871739a6b61e0ea5dbef64d136343ecf7026182f9ae4e0314c93b64c19838443c5d82f55b2dc516c5775e8ad39d2c70e8ac09d24049802e1dd43522ec9a80e3214b258b9b2323851f5e727e7cd5d0f31943596d6fa70b20c25a643772293178b2202e3f8a928dfedcdbd7ae1241501c28789e3a2f6cbff247f3c602830d059ac3f22e5a4b9cee56c4feb4f318dc2c46e12254725ebfde74e866dfd048412c629a6a6a2077004023dfff66760fe66abdcd937e21ee17cffea786d7b66afc1c52e7ec289b3069679a32ae805978052277f77d8ef12b41e9e5babc6a7b550562393018dfa07267f9518cb79852eb0049aa4446a963971474db26ed963dc553e4540a6c13482454ff275c714b9f82890ccb2d2c2807920f9243098b11fdc09681e334aa82a8757912db325c53ecd76c19f3093083dc9055fd1e65c27d80ab3781ec9c779e77a1edb1786d69e46a08b1797eddd2552bce57a29a0afec8122400740a84009a0672d75f8798006e1b9692ac7ed6f6d492a94357ad70fc7ca394f6344bf0b524fcf035b39485ab5ccb729addb428e1513b615516955417bdb69f20c1d57878e9e0b1f68be4bc6c37cc0509f7972666ad65dd7f72c62be52c0246c91f2c29df77df13a2333f08df013035e5073c43444a1c15760acab90c17163f9181adfa71b5e8d7f1cf35e7c6113a14ed5c222eb8a430b4d65610921cd149b948a4b625e85bb3f60e6f355ac318bf039e0458a4c86339f21e15262f04df449419e7452f11c281edeaeac3150fd9bd227ac376e44f96f5d1c25a45a8d2c02a97470b7e21c5d8d7fa0c712b672140426b00b894a287af352e5e0a13473be8a0e034f38f6f7e9b012ede9642e5db4c77fa198ce3b6f98d29510ba9ace003848ec9c7c376485fe637a8b469a4693ab93a7d79cac8bde4ecf44505c800519edb70fdfda5401622ea4c10004816f1905f019785f624e04fc1d7549be1869c8b42a03f2a83e6cb1b05b45b91ac025b4e5b5e066a75c5ce931bb0e27a2e0743be72d8aeccc57ff532d61c1c9a9df3017f5b3f7c0a2e7a8d0c45e325262d482ba13f35a41baee015fdcb10fa04af29e6d686a3672e951d1282e98d0e80209ee6b717cd87674c9463ff6fd0e302e063a21d2e9c3fb7670ad2455581c4c852f5bde82aafcfd60d5da4f3d36735d2fdce4a2acc77e2420c4679dbbc8ca1e3e0931ae8c80593c3b279cfa6d9b04910d33767a6b35ae852eaae949adf0dd803d788bf5573c4e6d927256484ad3447102b312bd8becc5adb5c4b8d7df453fee051474958f8a0b9d7f81ca93f94865564fe377123b6034c99c0a12bac0d4ab22eac28455d7813893d36bd1c775d469b0fcb09cdf939ca449817278694b2122fa93247bce8b50b57e8817d5a395236412453344db71de2c9bd6ea2e4eb77a64f578ebf52b201d954110f33a6374842967232dd6272eaeedf86ffbec275b9ee448d755e6ab351d1dc770ce26b8b9bde7158373f9a23fb9b84868363d09e8f2bee4a235815807f5c7c087f71cdcad425ee642e0fb1baacf9a1d95fe968b2b56b623605870ad181496b8b9d5a3a311cb7fb41c6a26b767f86e54886987e2cf5701749a7421261190ff65e19ea15d28f8fdc286a6cfd72fc5ea0e5df4cdbcf6611440b49a3d308519f23f31f7e84275f0203ab455f3cd2c1dd60037089379a06ab5a28c85bc15938beba165ede157550e3edfd41e801c366d05add4e4e71e3b04c31ec88ea72fe4f84c9e369f1c6f96694307ac511f944374542628261cccacb5f9a7cca576b3ca4e89603a53171735ee3af69ef3348164f66848916de1d00bbf564f154d8e19e1542f637ba54a21d5fb256ba5d04578828d71e2b217e76532090f0671975a0c407bcedf24be0681186f654bae52ddcf18afea046a3dc96508d42f4423ffbf71225b39b408779dfcaefc665239c37f0e2f1903960cff0c5506b691cc0c4c40cb141722a0883227155f8301a09db6c42bc9ac9c861b1aaf7064287436c1ee4b14e142538ca1f87c77f92bc89f26b3534a14d7cd7e93c3c2e3ebcc6ca24992112857315eeef54d126ab40ba5e53bbd9ffaea6e43139d61e22eb5b072750c195433eaafabdc48529b3fd2a8a4851ab3a1debb72990fb92c24e2e02ba67ef6950c4f43c9b06e294e8c786f6a1ae9b2b899bcb71f6a4432868326c00ea57ef4c442e484fd66d20d154c046bee1bfcc53db049ccc92833d633217c494424a35037a6a62a850502612f7f3a2e76ad9512ad222e78a5933ccd84562d1f08b619cde6ee13757c7703c3500b7beeec9da0efed4d6eab960bb9eb31f654014f4a0f8e08e82e9b0affcd72212bb7b8dbccd840c0acb5134dbfdd4f7b6be40593b46c19201edf22be9c6ed87e40478491e9a94587718575e37bc59c1913628e97daa28ab2f954f3a3318b9f8cf221d8bc4e314149ab7f84fa9ef0eaad27c35fe43932bf83c2bbc9d42b0561ba82907cc18c5f8001c3e13e4b07e0af0039f20b6de726190472389228592a08496e0927353dab23725bb80753dec64f9d1dc8aa4d3c0945da8361fa01a5143163e7b4a655673e74ff29a2c83e866252f2f18abc2fc06c1eac453dbd2368d80cc8950b50bb584af5f3d147c7a5571029bfc62eda91bd9c715c2d611995def90b501c712a12c62047902c97e86da1eebace966e3f234ef4d65f5b62c743578a35da2988eccee182ecb06c2a7b3156ee365985b933826151a994d95b8490bcd561b314430931932247277b209368b017a98ea8bb142177289d449eba44eea2433aefd9a63a5815146d1dea952b3ed39dcef87625819ec4f42523c5d28ec9d639a813aee5bb66e83166a896dd94c5279dd75b8fd2116e3862c71466482ec09544434d621269df2b1a14ab07f65484334d03164b62d425fe88582f3eb4a34f0a511c14064d9e6885d13fc13f34ded7f6553b219a7ea4b28375400e44de199d4f1b4fb939188464b51c30602a9dd6e338bd34c054e6ba502e4616a4fca7f99395941fda7ae02ec2dc1f085bb09a7e0c0f03135439667c4ed43e8d226fcf19cd7041caf7fa685143917fa61dcbc78931be34cda1d90d2c6d17bc9824e452022d90e1583743e4308488eb3175471db614a0fee22a1fbb1a1d730dd4a1e90a5a164017490a962ea0082bb2a61be9e45d64e39608299eb3ac045d66731eccd82e269c8134d2e7bed57d312d1ca55796dbf00f3f6911a1d59e6a38a8913a9f107638619c7adbb5aef8c0d8e1e70ebfff75b0c69af2fd7778c49cb6a5818b1d4d9bd74830c6803a99c9443f75a8b7f7db0f05286d02482b9476028776d29ef15c80b5dc1142a59e9fb39959b42a4d2d2c67e4b283e4fc112a4efee6ce13da8b087db825920d25790b4a4b27445948366ada6fb1fa920f8f1e474ea6a80243fd2b91df670895e24cc5f357e52ddd63b5b780915523bdf2c0085815dc1042c22053851aaa07bf010887e75f637f4c496ed3248e2fc34cd6745af112a65a7f0bfbd765c7d952a940e24f4f3f408c16ff093b0f94d6f32c368f63dd8d3c3fe653fa1fa9eece74e2cc1a717378eb2e7e87d5c41e79ac69f7e05facb0860ad9b79952e79a0ce9f7322f7d1420386da7abe8053d0379373846d710b05d93","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
