<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c45f1203381b176f6d9e63d40f53f53dc4858dc39ef89981bedee10bfe8783be023b1b85797b7190424f4de16248522b6f21b5c3252889d48ba407fb8dae4fdfaeb73c6a5f8d7f8366f02a0396a3dad8255cd82658923e1840bf0219cc9a0ec4bb8b3c544257b0bd5df61805b3e1f144c3c73a0a1532e279cd010cdf18c14d820ed27b654c800826f76ffacd00d3dfcc529407f57cb9c20f03a490fbe267600793bbc463e5110c745a14bd48184f1456df9fe9ded495a11ab216d753762faf2e7acb68bf8571836edff30f0ebfd4d6cb538a4349c58298d636569c297483b275f9a6c82217d53919fa4301e6710aa4771697e2c149c4794d269651a0abe0a63998a7744af46fa2373926bd367dd7ac3a8a2c19a62e57d5f0b593ac57500eac1506cbc4844056532c291e5d6ddc3ce38f30ac3c01bd8d7b865170ed17045ef083b843b5880f4806185ae76b0a01060a1054b4b854fcc05922eef419210347fafd94b4a0c9761d3d3999265228de15b9b7b1bae0291e29fec0ade2b70dfa92d024f14f7cd2a995c163dd67a127e2695c874884345e901f61820a418757f73632ef3ba188a17f956e1976d0da000f29f607b39a45da67b97d6540a694fc4d0b2b18f3c8dfa5394437f90a4c718b5be1b5f2121962283b176967ea30553f22c2202d95409493ad33b3ce40c0e7fd3bb2d1c11614a51303d4e779afe9a279461e1bad5578f5f88b37549f5bab66026f00097db50baa41ba506b5ac8ddaaea9c5affd323904ae9456f84256a0f5ddb0c61a35212adecc032f5ad12a0ea7055b35cd9790736fe0a8b0de08ab6ee987f8e19a5ece718d49f1265a1dd7f497bb021c99939ef44ee6269f781804aa3133e3dde80d22e45af8d8ddb41ed27cbfe1be184ad246ff98726dde00119c7e4b99ae2c2712f42d484c42495ae9ae2e86fafbe688537a8d8aaabe883bf1c4758fa686511f8742fe1435a8b332f13c6f4141c58021668757476cd82d75bd0c98b28191d30451134d7d21e4123c9417f8ca098398b70e048b876a3e9e28b3a6be00faeca42445d6c2809abc6b5651ab6674b065dd3679a8eb795e7b90b3aba7a596399e6a654ade20c7f64817a46a0e4d6494f40b243493987bc2cd4ce1825ed8f0f786553455a359b302f0ca0f69ec4f990adb9510d4f89d96bf3bad0424d65aae7b4ae8a082db0595ca42d69c2b06d482ed7cb6d6f2388a5fa2db68855f70d262d45cfae6b93aca48f42efa43b4f187649bebfe7b719426443a54e0f5a60bdeb5e2f734f8f922cd1edd9f51bd2ec20009e6a492f29000763b91c3162e766661dd77ff44aa07532175a46cdc80c34e4643a557cde496dfdd920c2fac2b33fc20b1826e88ff89e2ed5b47ea995d122ac2df8bc495ead07cfd4c88673d05c8f5548122ca2d988b6919419b694bdd14d7f0d393c94069b8200ee7f2c9e46439fef56d9d4bb4685e15f18fe0164c410590722fd5bd9df9056da1d99ae0ffb32c55daf0ed2ae087ff580a53ca149bdc3843e2b981d9ff9d52a816e4e6004e6ca43742e76649ab21279748cbc57ce96d43fcfe76fa2244fd87803e16c5e992f0ac7f620915b51566e6a9cb9c9ebf5505bd9bedadcd8027255c68da85abc322b56b09ae298c5656c769609b5dda0fc598b2976fa59627884d105391fb0c5b7ddeb09c415d3acd504f588344060a73e85097795cbaa33c2e6cad2690d3760bf86c7e2a1ef6f9445d793989afa10cf58abc62010b66bfabfa970f068f4208eea6569bdb840f37de1569da33c9d655799fd5fb442723f56bf5ba41f1f9db8807509011eafa421bb9e498ca4302c61a02d919bae604d097983b130914f5f1ae8e1b0a2e36b5a9ab5f317d98a799338a8e926eafa4f693a262c49ea7f5b518fd58e9c37af659b64e28ef2868fb7dfb35e9abbf4b4022f5605cfd2707f877369799a6e48a9dbdfd1376130807c94a3e6c6b1cdef1ce54d4fb510265f7737fb621f0abd57dd5221c8b372cbb40ebb0003af383000d6c10c03f837c2892cd472aa6a73fbe1a3cab3bb4b715b3f006e62260943cfb4793ed7506fedff29cd3a2e7eed85b065454ba97d88fe8b613a0dc6b9884b44d9aaded01d9e47d1570f706db15b751ea0b49e51a8d2e0396ce8c3b3acaa858f3051220e5a1aadfd2b778cf3ca4424be3e4489ba6deb012c1e514532b3fce7a68447d55595f06b55a2ab9e9734a51426c8b0e67e024ade222bf8c7d7fb9e11da591915a37e47bb62f5414cd5ae47c2ee1aa7dc493b2d9d612b3f5d27bd86a07af6ec22a938105fd60e4443fa8668a83e3349762b06b677644e26cefb3311d24389a2b829a573e2bf1968cc79cbd59e8883f44f04a5c07f9a17c73c249d1cc595d6a9f35ddf910dab640806e0ce4476b3aceb5e7d6227e3f0284e6b8a36c1f0eeabc22bcde929bba283ec4d9e3b8c9595d5467ed3df266446bad421e3016e5499ccadfca363b5e1a3ec71392017aace7f93a3de9d184dbbd5ac39d084d65cdc78bd0de0b3375df20d69c3c595e7b8ecd7f86018a559e7d6857d44db592f5e504f8652d4ebe478a026e7b38945209b8b8d00fd720b7683741b502c72e6b257c48c221314fe052d5a4a472cef961ec22fa9ac9a15ddc691d6b87d79869784294927e8a5f913f34c90cfdcb63ce86f53a9f4eb5c1214568f397312d481573ecc9a86c5cda115845c7d4cff3b5ea123918ffef4826816c8000f9f3394e2919ab2538260cba786007285b03a041067ae63c132ee0aa9a16e960c63236e14c7a27ab4aa1c0ce4b28b395f33919610282147e8c1ea3cf16adc9a4ab9289f3defd110d92a6153817df1eb2e9d0d9c004f30ae2a0cb5d5a340072af1373bee574676d00fae78fad57355b183a558aaaeec9b53e0f046fa8361276817157d5b0287569e4bcadf5674d292c08c526cf6418a5c055c1e3f2878199068a35044d9b8da6a90260773a20774bb0c20ebf59ba8dac310030fa3f01c44c39d134a7cedc8840717aa13be42b7e461d5dd6379c32f1bfd4eda84a634c73c2815728ebf59059d85a6f856362403b56b5a68b0087702329b7ca09800d1c7e723f89089a49782964f83f8f0371e5878ce33aac1527698703a2b6955557c28d2e9f0512cb88620d4ea177adc3c2ea0b6b6db9dd5cb0c4e00aa452c104528038cb2b8b21334b1d23765638f46a6cd19c3cce8fad82670b420197e14ce727cc34be0848921b62ae45bf75709a73f25c4ea83fe3d6a7c6c8229b33e087e2aed9c60f5e27998ea5624d89dadf4392f6cc6729637b4d2c4db6700543a067c180ee137c6dcb92b069d6cc6baba607e78906b191c461d143c50c98a2bc22f50e65700ba209970579e106b596d325502c75e5d7a4160c57c75f99be441d21aa812be15e629c1d07c20139b46610a43ab6ace6afc9dce2fffcfe414f9af09209d229c7b6069c20ff621b1ffcd261ac9549ac02d3dd3c039df02e4fcd070a67a29e310eabb4d0cdd1534a6d5950a4114e5ca3c9274133000c77d51d2061d2837ef3b22679b95832afea8d241fe4b893cbde977a3b0c74a9c634e7a2bd4c9467a68022e31fef9cb189795262eab832284b35eb7eec1b06423ee1e0204f682b54ccc229b062f04732c7d3f937eaf210501280f337d3d9725e43662ed062608dd00c331bae33a05a53c63940c689bb05b2d1940a12f2f93898fb7307863929f06bd23068327ca5d966d49d8fe1e82c0af27b1d379c4b8024e81cae2bc7701f89d6c1cdcdbf599dec93be86016338126f33c4ac5718e5d6295d56945ad195e12214f4eb41e387a6a73800e51df2c696510f7c1eb747f48fb9c346676fb28d76eb079f91b59798b10eb0d7254240d721b8bf47ba2104149c05232e01e4cc7f75e3da8350c490946f0b1935db5265f8ecbd567e916a68e1f9fcf836a7ac8445ee6cf621a510a1fae4f333aea68957b92f48ca4c6f38da8cc440ae1b94fb6c16f260d1cbd00eacf17be3ab1ac1865a0e322d8f065d7eedef8ba12b214cca88c1221f339fc336106df6a4e07b5a7425f78da2dea86565485a53702c8278ec3678d1d1f826fc9f565b9b47524e4c8817099754cb75aa70f0ab0454f6ee2c1bd59fd97f26048044522e6a407cdd0200d9d4f849601ba3b5d7174e303326b8ba756904c546f34ad2684435c3f9a965d5f3379249b5aa1cd1fc09b4d69a9d9c180f7403ba5189d5428af70607a87ac7862e33754c2054791d4406d132cdb38d18065177d10315f77d02d8d4c4089503c1b5b750e68c26fd63e5d8efb40648e28b715b6844845e5589d183d2755be82a27b10cd4dee5d6b0c6960be4a0ad6cebab93ea5d5c3627b4234fa359c621366d01bcd0d7e0877938194a51150ab9668e6a8d2493e378dacdbcb50591cbc5716722058b27d533adbd0ae8e07ec91ca4c4fdb48d0c01f72c5c808a766918227cf60742db8388bb338b4f25f9e33fa7153772bf9195a981a1ce6c3e8b8cb38b355bec83c6d9538a924680dbdb4a9ea864fe9953f8e6bdb7b020eecb127aace9f279524e55f1068dacf7fdc4c948ad94f042e7b392a35d52415e30ca4c7efb9a04e9887d56bf7cc3e01bda1bab83afd5e6e229a4cca0e9f0a48af59a565100369c327091e338376b5b340ca613e6731944953f4ee9c0a741f017761feaf5b8295c72b26f82f664c6c2765166aeeea0b0f95c9972c6bbd13082aa536a59cc993c41dc1bff56f89f1b06c8c654b5b02628a08cc7deeeec03e72f808bd5623c86c0e5298aa2c0aadb0b5876ac6a1a52c671ed5c963905718d5afc250e01f6885bf9f25d0b4afe6fea488efb4ab9fe30c10debcae4bbe29489f41b2c87f7bff18c1db97a1a915a0807db36c1b371506c54f8b75edcce8ff53251bd06aeb6f6141448fefcd79c69d1d3c9791113edf6e46feede1957c65fa511b12cc252936bade7744f39e9f5daec7a48bb95a8d1193476ce15325190f2ff29ff3726dcb6c5aadd5348669d820ed622d34d31e0c4af1e9cb43a83ab70314f96113224e4799938191e8829120de6a265125bce8045ec7d5dfb0a5dd9a6b73f696a2464fcb8f7e426dc78a737db56f8a530c74d3a67be2edc21bfe41bf2bad6b33fd810c9df6a7c3c35cfcceaf98a4a8f35815df38e4e05ec7b6fd67e6364f6af64bccf38fe3b846f9e20c02de7a3f63a8decf4b5d9e1dee03aee5b727d50470cf633dc19983561947dc57e1d6d1d0eaadd8ba4ebfc8fe1efd5723f58ef51172130f8bddf557bd3049733a88537a32ce8a9e9e8e8bedc17a0d65fdc14f78ad3c79876ac0f295c39190b3ec1843f0d8d2b0e4637300f00911860927fd26e05100dc556aedc6975421449fcff69633ae2facf3915c02413b0ae47aafc4f7e365f68b4dea75c6a76f83f91517192d7021157b632f997d20bf1241108eb0579b68addf653d3ad12c23c1e7f5439466a61ecd71d30bff612aba49870bb033afec04b18f2fa2124afd02be386006e67bb39c49ad88a44a6a276520661af1dde5d561f67a838dc4328691b4c33a0e48303220a2837cb37f580405b5aff2a507af0718bc70e7bd10dce8137dacc2bd844e9c5feb3ad9e6b42753cff6e8056d750c6b34f8d62559de7d84b6523915ae5ff99b271f6854a6b002da374d167ad8acb9ee447e8667b929dc625124e3857d7ced65bb8c6b225be04956e02de17db3381580f6a85b5ca169cf337efdfb12287ca902b6202c20e422f51883ed522bc822f6d0828445c5f90865595f74537e802b3b23c937b57f35517c255ef14c8911d76da6f389d3e4d3df5b783ba9ef8e96664e3732b798ec14921c114f3a98a1872f80fef030e0d9e6b0803d82db15ade7dfd55077a272d184d11c3be09d157161fb1c4cedbdaf082b450778a02745c8b5faff1dfb6dd3d4c9b3ac8c08ebc4f2686e09b54826b19db89233680c0ac2bb8650e76166fafdc41cd3583164f093dae6c146e69bb2185a38dc732e62aa8044e4ee81f59e8748cb38500cf0c5595f6c660456b821ee17604c0c9438dc8f5e914e41f0688b0248a8656fd3d08b8f165630718aaa4afd061ce94af8bf24827d32cc440d12e197f783a310691b728a23d7c3fdd88184512b6f145f59baf46e59c26ac19b6d0c3164a0ab61517dd4b408c408ab349aaa9efb0b2c3bb90c623977517ef99f27ac092ff0fa6a35b0eedb07bc41a7c755a9c692727652f94d9bf3d7a460e3e2486e1990c68b65a23b75a7acc8d56be2ab0edb4c38405754ad5ecdc99d2131595b5c2bfe5e778a982520ff1205815a015b863312c8081663198612acf273f926d8908e3adfe3fdb06030c9d4b30ac28c0e3078df0fdffd16c4e581795455843b0c12fa3c2d5a5a566130b5d06cc5fe29ce167b88fd4e865da87ace334a9b3c79952c9c346963db031a2ab326c494d3629209ae3e6d91c82ffb5cba258e2944ef4651391083a9df46aa447376f55e25e406f6f2a054830507f8e2eecd76ee08fe6a448e97ea18b1ec55c0668c6c94425e275a03b7f65cbaaf5bb857cc4dee128298e93558d3f9d8501f20b435777f715a495c80b2f7a7402385b617877a8d525483c995d30bf23c2ff92fbb23afe9cf41802f157f09d7a0cae0952bd8399fa7c027a994a2f83b5dce35486aaf466d3aca38092ad656f5dcc1eac318a94f8629f2c5ed8df18625a6cbf7be4a383b8b6d520940e3345db862ec8cceb3f6cce60324ef8b283a7911a74444e1acae7c7a3307db4eece79855c063ae3a0e0435ede0f31c2a64d6da0ffe5cc191af3013e84054a43c279ef8cf2f46bcdb2390370c668f45bba5c5bb25bafca41d856b6d81d261ee8223faa02a70e552c902382e0f93938704b71e489c74364ad8d52b77dc0a127c10cc10b423233c665d8b49d65789b9d2cd3e527b39fe58a2b660ea7702a29f41d6a1709e2e9a885890bbc9ce8c9c3f628718b698340c24a7490e0b3edccef0ce5797c8f6fd2d8a8ad7df3cf2b621564968fb69bb02942656398c7536da5eb2a49cd8ba719e06911b9466757932270011bfaa2c364e8e4a66b275ddaad5406874714b31990a07a11d0f2d164808ee7d5d144bb34b271b021b325b865e14947a7557e361818007ab87846a1bc309fdef9281e5949644a426053909d54adc1a61cc92ae17194fcc273d1c2faa8f151952c802131dddf4693964ecea52925abedf3751a8e6b1d8eed3e211e10f40bc794dcc21a9dbb1f8c1b1b5112c089b69c17c9375e0be2b2881cc96f67d46651e7d09ffb2c7712e480bacfcd6d34713759fb9b2c543a83b07af13b970d131aaff9b37533240862013088049aa6f4595a9e461a1a72459e0f6a1bd0200b1aa8418defbc57b0818d23d2ce5866f0da77f58a27a347495cee619ec75100b8b6cfa0e00e6f6c9beb604ef9358df42028725b8cab4780d53d33522d10ffcc55fd0153e043530d8f6e8c3101ab31ecdf638204d026a9cbca1f7a8d187ba0968da6e4818d508630a1e5489e61c3f590995be475a1638dc1eee74893c51ba9913de4b7bfd955ae1cc638dc3986a3f911a2810729441d47a90c79c6e2c0a12d96407bf08255ccf1fa370564d0b096b82445be1699944f12de6d0c462cf4090709b0952199ab0b13aa22fb3ce924add95806d69f5767f765a1fadf7ea67709bcfbaf413a9d97ae72d21ed0e83415245f30d7a44b742ffc4a0c18cddd3f24ac86dba70387d66a1c5fa9cd8668366fa19d3be1f1658e25d5613d05d3132cb2454d75346cb7d7cdaa8e8f9aca6711a67d20b653ea31b5475755899cfeab61f11fc33efb506c8b54275b784740b5ff73add55b50cfe6d561a2ba66ad4646244614f2ba5ee3a1f64772c5ef551f7435d263d00ad6e8131b5661ad69d3bbb371eddc6244e1fd4e5886a830d9be1fc77d45077249fe3b67c6a410c82a2fbf86e0f39f143487eafe5343be2181b1de274bc8dbf35355f7d84a3acde58f53259c8b257d1dafb2b82d6512a404dd579683de59dae5a51c636f16a192c78631d7c61474b48a8f29124046bf59ec6ad14cf47e398be3a5a61f6f85ba6746bc65d2fd49389d49947a69ae064aef96f00baa33bf82e650dc7d8e60acaee37e48ed0a5edcdafd50664cc4266fc79f694ee2dde31182f0da972887d64351a4cf28adb35646d1ff721e61cbd0728d646ca085005453f583dc13245e0d094cf5a83f727c82975b3001a67da49d1070da94a50f06642f757137f9ad1bc3e7ade13067b43ea8ea50293d3da54146a6aaf91ca027ac6deabe5a9a12b04070e8b9cca8d57505f3161ea7331029d69c1140da46c7a7e47e33bce0b887ff53b619529ba5c53b24eee818e35a98096f921dc5a50e309de52f6b0568859db9c180ad3cbe8d808d31fcaa1383ba6b8514d22245a5d8e96e8625b1cd95cfc0801047a919fd9b5f508b4f2c9568959946cfd1a65583a82101fc8c014f312e3a398a4a11f8c10366032741f7b37d40cbafb7192bcedb6ed0b1f01a33f03e4cbae71f6c8a8871e92f286a4b694695f41dc2b8d6589b5a07945665d36821fa057cfd7df7ba9f1a8c9c526e5296e28b89ea8ea0e0f1c5b0b360ae433bf3f81c95f80fdb28bb921e61d345ea7974856564a8fa36c1a37697e82db302cd3356a4ed9a805f94d9a425e1d3482270c9555c140208cba248f423cddb642c8d47c6f1b41aab5aef19cfcf2150c2aa7a87bab40c52d609f94325201856b30b7519a3fb5a03f759d8041b22441644e81d98a5b3b533fe4dc0e4bb9a13f26796dedc10b2038921fe6624851bc1c0b9f1e8b1da2634669332290e62da22d4fe8f75c1edddee6ed19480f7ab9c746086851bbc176a9d377320b0dff9e1f3289e05f739f3f4e5f4a372eb4cea694c3102bab5794b70f6677e29bd7bf4f4f00b1bdf698d3103e334ef35251b642e6060a02feeadac68c0b0e4b07348a618e24c793096b502cadfe00306912fb69890dbb287dc25815a97e955e58c194ac572168e0222b5f6658d78b32ec398ba0eaf1837daf4177ed09c3b0f616e306f1bcc1ed0b881f584179bad79502257e9a08c420ec480c94f5c70bf843cab780bb5e833271bd3c1987acc67f9db24c6ac050a850fcd7727688c46578b2211e4ed74fa2d3baffd8f17f92a2bc246d72ffedc271aa77337c38706b2511e3c0bd8c537f1c18fab7d72717a3caf3192f078be4fd015c0e2a6fd3c5775b296e53f460b882013da81e278190689331a1b73bd8c8f19267048d2260239d23ceed2868e6671323dc3ef3cd8ce92e670a7f6818b758e106d1985ac2159958665a5a6c9a3d8056f17df413aa35c3d077088a1cefe3ec34b011efcfa8c505178925a63d2d98762391bf566722f643f22c29df07e637a344ed66d85b507ae8b20dad2fc9993cf917aedb0506f82740cc422007e53139559d20a0cd8cbc9bdeb6d54aa7d27499f3cd1a459179e91c1fdf0dd6bbdfed723eac5991667cf79bcf728691370e03c85833dea49e01d5bc0425d145266d7e98402aedeacbe41cc93f2b90b3f8482d9aea36faf93aacfcb24f03ff124ef35b58fd2549e9ddab6a595d577a643ab95a02f5edc4d91c550aa88ccac8fce202c7b603d711426173b6429d8bc98245b5f141b7e8f4df7cb75a1fe2cfbc1cbd10be2c962b72f17b4ef51afc469855f1e9fc71b3deda03e98c9376c6bf8b11ed4ae2fb8e0aff56b7a0d290c1065dced920cc647b7d23fd99a4bf94ca4135ff74ca4cc8f7749e4d7442665ab593952b9dc89b32f2990e8a69916583d82c192732c8eece1707afe7684b39cf2dc675df7e4ae3a9407272df97939e44c9bd87710462aa5ee6a3375d96215dd5c47bd362d6e82ddf102106aa4375f074edf6508f41909aa6a132f738620d8edf6e61da6657c5cf3ad35e95f2e9ad18a02ec1cf970dc709f2927203311f409abc17208809331581a97d45c578460080f34b6bae768006ef06d91f29ec8fb87becfed9bb6f630bfaac086b4cbd2e47b268fb6f5c5256215323fb5bc73d29568b7e31a3575db2c1427a186f24234541b15147ef6ee541befd2cbec3371d98aa3cfa5637bbf370b72c001230b95687594f3e2dc4a3204764e884988c2e6ad333812b984cbd2864df5fbdd4e258bb871cbedfc8478d789aac86173da00a4c23bf652b3a3c4edbb28a75a30146fd8f74d747eaa00f5944db5783f42f302dc27f1ab00c2c0247cc46f893847bc09328462f93d7926400e1f7f694fb9af19053026c6cecf91a73bb78078d5ef33f157609ba9dee7c7504b0cded5dc9753bb8bdac70961c65dae9df5720a24dabef262b8e77f66dd15ae364f8962a326f8af4228e161b06d97c2069adbea582e2a2d4349d2c04a3f02634026db1db4cdbd5317cab5a137f63f2d97e61c3afa797c884369085e7418538a7071f02d350b9454417ffbdc54c5158bee62f9fcb9db4d88107e3ab472c051fb66e79ef0984333b99594af32c4162c5e972929af724bb230aff0ec25034b5a447336b8b125e34bde1920050c8087dbc2edd0d5091f01b063e12b35ac7b6beedfe760c8b6196102b6a31b7c47e05462a510f61891ea057b0b8718f232f38dfc648c2c95af8bc2faabbd2777d0bb40a00d0d64409762dc6a7a7dbe82cac985d3968769ca3c63348134f8b95274ffaba50d4ac0e3c11deddffbc43fbed9a27264c496c82b7c6341a494e1e3425e268f5151d2a951b36ae73f45f4cbb3851f03f654bf7ac820cb396097fe5ddfbdd86d1f4526edadc688352af87b0e101fcdb7d57e33246248573a34c715b0e077595336436c6b744a7bdca643cb46ca4631162825928bf11d8eca1ded1c65d192e09775a77636b1812c9f854f07dac57b0dc6598ef6959855a6aa8b86fe26756aa92654f21a658046df242a8d2c63087e0a441591a44ad2a46dc2a381fb4ca1239f7e785841ac85022f5734de3db5c5dcd697c37e6ffc9c71985c0bc65f9bc3ad013735430f38bb0a435fcbe41d2ede683c63820886995b9be64c883bf48ee8fc955e67b05f6cda11dea73646f92ece9b2a418958014aacf08788af1ad7066a1eb7e714adcdd8193e3637ccaf620fcb9dacb31dbc00ad443898bef7cdce74a1d4823648c71b1d78eb74db18b0dc0e54591c0195ccd6be3256e2a99241751a596f13fa164deeedba1a1718e52d8016cc1f7a04d8ed30d99938aff01085ceea678f90a8fef66b68c6d080b289dd56fb41fc7685a800902663202be8670e01203a68642aa8fdb87a7be5cf898bad0fd1d66ae3cd3f52cb6e9f71bd65cc6490b986006f68e91753ba49d69df0653390adf87c1a19f5d84174aca7c28534f6c105d7f2264b84ab8f683614fb93ccc2a29d3110ab52a076c429eb0cb10dcd16e84774840de9cbbe6ec9aefc9a25fb490ddc0b155a74f80849cce953c5289020ff8975fd03ebb06fbd5b708c582d31fd8bba150f37ce49161fc3a5f9229996c2e892004bed8ca6e72871bde59311ce38aa529a9e9c17051ac6ac36c4348e29f8bb9e3621318a5323caaac9afad648237aade353c5c0498eda974cb98c0f41f3f9321770bd20a622c37e0639347a36e1818d517cf781b3966642f671bf0bf1392f1a38e1a79d40b871086be5aff825089362e8adff40a38f065699f2d09df92891af5e9ad6cb2e30a6989c24df80da2fe8c90b5b126c05b86796489b2fc038b516207d0549f9791a6900241686907560749c1d170d0e3a1445a862c1540b08de1755eb42e99860d00215dd9b063275d87bea4ad1b2fdf5a2a8e21dbef9ee4db7e40c70d7f2b592ee37ef910f1c9e39f1263bb42a0d2b2ed44e885fba77a950234e4f4440876111c5b3437fd87dfd851539397e53eb3451977a16afce07a8e9c34edcc666f1dc716ded8cf3f88269ff0aac2d908ef96b8dbb7d358e00ff2a7f0d493b886aa281ec6251a4b26b3b2f0c202f220e47348f00b355e179570e9915dfda7085093ca1c8ddab764b5b780311db6ec7b13e20afd07cdfa35c4d1484e7f6c74a8b7516302c0846983d07b9813204c58dea21f8c8d602030becb8d91cff3143d93cbde02e5ccae2c32dc16d973576a65b6be3e7a72b910eb2d2afddaf3f299209f9a165bb1ce441fef17db7bf08d0c712294f7b764aea04523e878d04ca7bac80fc08a729d8a923d14fa624c39eaeda8d324af1a2407be53bee774af4dc13f86badc191cfb9edf0496ec34f0b77ef34e21f161e7e56468708ba550090fa34638c2cf406cb665d6e58c386dc676ef778d08454fde5343d2969f31e65cc932a26cf34efc26066f4fd976af4653d4031824d55481758ae25ebd0ec3b151927de800ef8b63b3771fde038cb618806367901dc9394bd0a690822e24b637ad74d896924242942d159ee918ac4ccfb38a515c0fa7a631d38fd2b9bcc03732627274423dbcbccd6b28227e0a82ae4f246e3d9613454c17b0fc8d92173354dd92d0595ebab426cda0892f21c4976ec1751c3b35a9c00bb977d812d1aa209c3a0fd1c8f673105369d1ff0562a9c6b40d6dfb05c956cca247e8bb4983216d48a1bc6e81fe8471a5e0a91d5892fd067b63ecbb1a47c5ff76b2eb55379a9b56903221a57794797daaa73926f1b630f51940065c6aa682acd53893d8e88e02847a73e157bf4166e39aa1cfcf32a44c15ad3a2ba913270b6dd5353742c57fc90a79b059cbc176e0f2c739729685b28ab8ff91d9756727a3c7fe76e48e8cb7187fd81947bc9106a04c534ef694b0331577d05b530aa16ae184702febd1bc60f4aed8283c1f0e570cb2722664acecb012a0b000c8878a682bddeebe3cc9952f1d462748721c490fd41cddef77ae4e5e490df4c83c9d6fc959191eef805595b8d3414ea9e39718e9208df0336167f6201075dd265d4b5f5e2a5f0b9389961208307d472c0833356eb6a368773d1e219d53b0e71b6f4afb04d9e9b2080598bb66712e59837b07f579331d085825dafae176562101d6f6dfd8d963d6507aeae80eb28ffe671869a649f6402daa3921921d80aed87418b1cca71a28a6f080a97d9943f40e857e61a3ec796aaca4237409b4b52e8d1c6efda252b4d1a285e9461653c974b1438471c7ed14ba7f1eb19111f4c47dbf01c3afb76cc426c27658232e386042d195c6ad1efcbd0d0e56c622578a58c3c41a049aded6d737f7b9f4c2d8419bbc4af26a05f0be59f460fa843dfec2a8d2beb62fb9fcafb030859c2905771dbe2c0748fd6772677e9cda2cc3d88fce93720fc618caf894461573975e1beb38771cada895d0b387df6404797f3613e7f0474ec1a14a843c8379d6d655273321c91453ecb2ce18d90e6dc7145e2d500ce6b033e2ac850f5f624594a0f97fe97c4bcde3f51775cb9dfb59c81ccdf18b1e5e2bcb13f19629aa2f48f7725f544fd5d735cb7368cc45f84edd702ccf26e2945c52b93160d045d5837e0ef4a9564d7516d07b9844932c84b036af02e5319441e403d5749bede736599c63f076c2628c81b0ff4cb5eaaf06faa5ff55e5512ddb991c2a063528f0f2f4c3ba074c7b09c4c7887bbae8d69616939296e73661a259a482afbd5e10e015c4456b5c3ab4037494670119468572c2fdf7938149f6291283f78655a8dfd2172d82358f0b3d020d867f79b831f934e1c3c06cb26fcfc0676f0396a1e45def64699ce8ac0a22fe866d268eebe0fe4d99f2ba972c3c60be4fba6cde473a142bfcb27e101e444d18ccf3f361d64d718cd00cac73fa4835349ff2191905c9ab422e367032205ab343b42c7c171af0a6fc6beda4cd4141ca80f5c68dfae80ad5aaf4ae5127b7170961514e5c881a722817ad52e65a87bbb93038ab273cd8b95805bddd135223d12e6d33a44d496cf2f79c156af33167ebe970e55e47eb588494b2bc8597eef490b318d93af3340055843a79ec36bb1d73203761cd1791e2fb52e24d14cdae8d7f7ea07cb896ed4d04490b7104d144810fd38ac283b54c324d5637e98957ffbb1b373c22af310b8fc378efa322fd063bbdc37de89a3234062ed5bfbb348eaf0864a061f19277b31dd09f9dbfcad2b4f972ae4d21115ff249b928f10be0ba027793fb61660c77891764af07b6b4ef1d65a6bb1d2871113951ad63c06f79c28027dec687e6a1325dbb9765ddb69838107101827c5eb889e0a552ae8a29d95b0aafe54492d94c102974671cfa99a49c1f6a269ec63f1ddb17ab2028863bcaacab14b99a00405b9eaf1f0dfd5dc9dcd59f7a3248e115172f2c4a664ef0886f51d9d60a581d8b24ba5de983b4f3638b51a7856d03c308cec62d9c6b77ea26b4e7a59aea567bec4759f55b40000e93d17061d1f9831fc69ccd92469f52fe3928177a9128404f07b13b510aab33a7526951a46008a90aa9a477084aa7fbfa365d6b13aac31d86f90dbf860760ec0732e888b6c9da49dfbb140607926c07dafa9951cd0439dc30d0f8bfbca6218b5f5db0cde22219f5aeaadfd696bf94d6d26af0267ecaa20a14843ce740604813dc9783366813e69dc915b3e0a267f4746256b434d24641da0c9624d6414bae8523373f4237e73837f41fca3fc3ea867c03ce95e2301f49d83bd5b6ca9eb9311698ccd2bf521c4bf078955ab11b1374b13a5ebb3f46e95f4574e72dfac7293f3efea4c598464e59acf7bb4d5f0a7540787e4e6c3b3f88c594431b15f738ab5ccc829f77dbfc5fc2ec1eb3e95fe40d8880e7e40084d5dc24122de70b1c82f95d04d60fb9e2c8eebfb795fcff1124c1e90063cb4d3114867b7ed08da418a29d657c9e1924aaa31d0af1cebec5f52550cf907509c9cc394b9c361d74975e7e7faddfeb002bac9c77ef7cbd527db5812f874553a53fb58afce5d370fd8e22af2580f01262561d2cdfc732cd74980e4805aa2477f1183dd03e8de00c2bd40522e76115d4e44261078f208aeffc286b5edf4bc76b900bd359b12980b003e6af3c7a974530217820c0dd5ebc3737671c01dbfdd6a5c169dd1372b0ed43210fb61335653381eaae200d0b512aad8773ad5ae92c3c7991640e5a41c1fee641dc08a97d1ff618b6bb6b81d8fbf8e91d3a4fd95e30eac330e755331aeaa6302d482b2c5b27dc494839acece7783606dc2657eeadbb71dfa86dfcc25f0fc45bc89ff153cb3e441c3705c6af7af5ce200be3364a8a2007602acd4eab2a05c4c7473466accac3ae430d4dfb524b302c9df21f71e1600d535f15871b435bee9022064572ecce5a5243956b75a5712d26e6971a7469c0e86f9e6be7b4de64a1044ac0b01764ebfbf8975c0d711309a34c7f15ea02b894ad163a545169a98b236df9c022a4fcfec5a74f19927435fefdc8fdb10b84ba761dc3fc3693c5d6b2c847024d108278807d098cd7b5901bbefc73d8c24a36cb4cac16580191bc1255b39642008a2ae509415a672bdb9e6253290069d00bc3301668100c4b056c3fea3e66fd315e482ba7ed029a64bbb4aa45225cc9445381d85df12c25a7c80ef0ee2f92240c4011adf78683fdf5fbe1ed1e7a978cd08d3e53c93a652d825eba06ceee71c5212746f3ad74b510049d963e6f0ca6055a1363f5c6e25513e3e955f43891b3c032047e20d7beddfbb46b6cab380107a9c95a50d3e5a034eca02ed892bc9e4778272010e3fd7093e1a880fec0994fb21b1fe57d2ee0bf1cca338313d3d8327b5d752f736dffcca0aac471e6e582c3bdbce4fa1ea1e265be5e35b06ba86df564ef8aa2220faac724d7ff1dd20f558a37ad7bc024069ab0f6e465c05b66450e28eff6ca35db19f7a982ac131c70373cae89ffbe84fb40bf8706e0cc7b1cd4c14436dea4c23e80d7c9e70bd47df3db3d003853ae89287f124d57b4e7262f6bb3c7d9d04b61df3aecd0ebb2dc187919c4dc6343ac093464d7010a2d68112c295c473175b2c2b96f0d9ef6e67fcc399f80039b727dee1e52bca962b4cd03112f8603cb3501cafb31079c2583cec2e66f221d5abab089f2d3b8cdb6ff8ba592bc38b674b737355016e9e052f8249536f6024a2a30c5f396ad7cbad15536860780090b0f344fd93fc95bb0486d26ccec555d9418dce2e59a925696c2d4cc119b02fad2bb270b38b0b68ed0bfc882e58044a4b617167ff01d0af205117a5ca3553b019a223e5e4f95ddf3a73458ab2d3a8ad79c8bcb6e55f3eb6ff5558d0d12ad3f97483ccb3f2bd4accc0a65fdbcf3fdc0810a44884c5dd0a8479e8b77735c1c993ecd50c986fe3f8d3bb20992fb896659f3d7996b626bf82d1cf9f6fdd37d5449598a9802061fe488245cbff9c559118efe69a50424aafc9835cfd3cbb9fcd66860f47d6dfb3d84bbe1e293344ed19052242d04419be824ee909f159c6f1b0e3d5cb6fd07558ff9a26679952ff17d0af008c203deb75b673a3ec879452c438f51e1aca7a61fecccd7057f39304e31d03ac9256c1e09aae094f75dce2c3cdff4cfb100063b884913632e634a166c480249e0cfe5c4faf39d98039a76331ec461619e90cec8d4269fc8310c058ed473f9029e37f43f462a9344c1d03db35316a9f7ebba13066456858559494a159a5a9201a7dede878a1b4232123da5399c9de34792132baff26cb710977f22a57dcfae65d0b7d24095f67aef166fa2f7699c304ac69ceb3ebd27c3a9c691e6d91dab6981d7c88e3763740680e1695003ce72304e415509fd3f6d181edbb1c292206ef654525dff0cf011a036c6f57ad30c1dd913d7b4b9ef300b0e2d9f39f4c9e413446c483656decdb4d4f450c72a82dbf66567fa473cbdf1df4633d2bc6fc8aa3de8a40d0a817567d39ccb816c6307238b1bbc371160c053d5d15671abe4dcbefbef4bbed155b576666128e534ac6a9209f2fddfd8ef001ee1c15fcf29d0a910ef052f2ee64eedb838af6e3a01d3a621c903fa4908f9881344b2b1fc0c0d965c5ac317d647da1b6b12ab1ccb23d131f1c6de6018d11a177199dbd5d46af8347a1ebe7afa956b25c428871ac15dd140a51ae479a8fe8fbcf98de51d1df548736099b3bf6bc1e96257ebd05d388ef1248d730c76e228563f4e9071514952a0b9cd3d5b8ea364b4fc422e7f1366b8f26a275b6f7181aace3e8554a72416038aa32a05c697d2e75b19de544e2bccfa7caebeaf87208dad5b34950b63d471c029f60f12ddb1da414f1f375129ad1b4a753228fd32d45d6ec325075f06a6c3ad64a7017a532bb2c1b3ca1d7420e78e2e8f9fdeada9c9540b058088afd89a3abff76474303601777a75e1a34d3b283466d7750a110dba39e8faf77dd8c072ee753c5049b08314e3da03a4add2ea7947594df61049e799def8208a400c88461825feffd636b2b0ab2d9db1bde0506faf4732443b6b81aa0bfd4885d50c6f947b78c40d747f7eae7bb3e1c11c6307bb4a94b9441d93dec11e2f3ab61ccf4eb13ef543585850d6e97d0cbb567513c98db2265545147161c44e6eba7b74c543a6efc6496d616d7e720f36b77429f9d05c0173efae6bf9d8bedcf14189efe2f66c0e74aa53ae726af7792b2569ec0aff1befa7197fb9175c7d4da4e048baeee1b427644f692e0e6e37ecb1702eee399d4be6a23d4cc8e6364801b50819b159d12866926eb95da190b203564cfcefb3f7e0956a32df213252c72404085e5b1485fe749f7f03ca4d4685f3d1b1bcb0ecdb40a7714c7f6e697e39b3eca413c1b1eb725e1b9e9683b402b1362bb7c302a907316bd6e45c24f565c2c5676b19fc815f1f1e4c1aef5e03f70236328222817e2d026b19ef423ffca8ee5fd5f484f34afdee8697d2873e737a58ac51bbf5dbeba4446c73d760f595aadb68c9e9ab072d5cba91fe6a5f86cef6ed3e4cadcf4195c148fb51c55b1d791397dd2804917543e38c4a8fe24ed1a416428c48770e0f8f6101f780f74cee8ddafe29db8a19f56b827457c99b6100986d926525f5ec4bce34aceda87f080d63eea7b49df8b4c4de77786701623e0d058fa7538d6f9797d2066af96a05dec1d5b58bcbeaee766690496c7dd9a558020e167b35bae5059a0c06d7c38d4af57a30ec75e0d5c15f72e5b5fac1dda042504f2ae0e2947ca34d2f490c6aaaa6d0429d6fa89fad89671f99bc20df1eac392eeb8c5e92d03c69a466cda2331bf33c7f5fb9a56c11b991626f544e67e99d8efd9f09b276aa418088288545f8abc8d613f6cf5b70393c2855f07bd94a90076d4d6f2c78b88c0122ce186084fe25e2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
