<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa9a016e96d111da386b083e586300732440d5fc1618d1467530009f698cb02e548b6708cc8c10a552a522e651ffe8347bad0358192666d9820eac79de656638e5252b26eb870a326f0d83bb7d912dc380ceeeec4664fe776b5080e5cbe3a66a8f726debaa39e2affab0cf1260d739bd00696646c16f967a57eced9868dd2dbd6eb3fcae0a7fb74e53d538db231682325632b5df1e606b9c27ebc52bde3423e1520765b3156dd01802c3c02d686aba63e1d38b8917c18a95f4e3c5e87228633f0f4a19762c3b5bde893f987b10f9b9ca6d96660b759134d6f301a4a77f575913574ce773f85c323cc7b27578877b5246363b095ee3572358369fff54d33f5eb70d9e9dfd55cc40959e155b06d90b64e6858d3ab5f6a9e861ac49c4f32edeca20b35ba552fa8074376eb6d2d439c420848b09dd56898b728168ba7dd6e4182a66879449d032d9fe40a42b9eab841375410ce80ba50e9459fd04f2420cb768915a07a3db310935265bf44ded0dbd0c4d3b0389723ac2a721166c3cf95966cbda68460bd824ec0acc7166288436d7393e0c00eb428c85ae20416c28b9e8eeb3fb63f05088f462152df97674c5c6efd6e46bb2c1944f2c681b734d15546e35e390db6b408786d3f918991fda21a07bcace1ecc1acdd77114d37f0e87278ff73b0d27902a5807650388e1e3c9e59c3996a9e7117782400fe781684793bfc64676e5fe0e545c330392207b5347737740ad7555f9977aeec97ff5fdccf2c4fb1a889cee4ced496d2ab11f22b2afa53d892425cba5f6a7256ba95de6dea20a5fc3a6e55889697f3a4a26aeba706859e3664f5b17fb28bddacabfb93d23dafde5ca0004b75d93450ff4629cdf304f54e554814467e7eca094eda4235c82fff878f27be6587e69313fe2f180b89d01aa6c4b9f2305c19c9966a5926585f416f9d4eafd61879aafbd84e4a8c693f96388409f9c856981d1debfc5afee27b6d21e9f13a77da84d8e797522ac2e8cf5e1fc5779de188de4bd182cc1f82d53995542f17e857cffe2850da7e9f437c13f5404f799bcd7e22cc98a18818a726ecacdeb810b89777cea5a263bc2803c136e18b6fca367b6d452281908f9b721ce14464bc96042487b286976c5f154efe371e2578305c841e6d98db9e3f531a4e5576e0f997f9aa04ccda914e8185a4b45e604e21b37de5570300d13c0cdad168135866877ff4cea3fdac3192a66fdb87730f0c13f4a9105ca3a2593094186cf0b9900c21fee111309be8267f6e880d0f61139af08293e74b5df9369a6ccac9a54069e30a137ea4a9c2b79b6785693fc62816c363d5445350d2457c2a67105cbcde3afa1e472aa4242d85b990c7d2576733c5ccdf2297dfec3e4900f6e60c860182c188f9b9c3abc90754afca090a0182b7d4a0aebad9a3b9e4ef37a838d90700763ebadad1753afcb3d766ab3ed6d8d3869c0c514646c251909fbb785060461c2da50a6d0ed5948b6af47f3c1ed64bddc71d1cd249d59734ac8c61ecdb6b0aaa1919ec5c9652ec2474f1c7c287e3fe5c4f98f6678a3b21acb5d902f7c566be232fbdb0acec4e403aa59757af92f9f041ba4415c7969dba9e66209efaeb6580d6527025bd46b8453fc681e8c615d058af88c695a9cbdafc1b078713f94af944f5f7967907f4a5e19ce74103ec34ce1760c6b123c3d6c903ed8494c7911ee5157d48e7a39c781071505017290b3f4d899bd15c01cd23c1901056e9cb3103f6f6c9e9349cd09ca995d85a9d65ad1a9a885b65b5cf6f8064c4d33bf5793a9dff6db1724c96f45556dab8e69396e401a264df543d5bfa0c056c20da986eebdf5ea7c15a18b537558dadc68ce4d2d18480479172f7e69dfe79a277ea7577a6d6e7a1de44c2007e24ab893974844ce75bf27417f30925f6bd2c9580b8903d4d9f02a510f7c15b02b06b9a9e5ff7b40686db4ca5940c05ec33e428c00fa6640ee090d683ec42ad8e4edca1c38682045c6bffe244d315785b9d28d9cce68b14dc376b99ba3cd9cd9edfb22e894e2633119e308794563fc15b14a1ba8108bc2f329bc5a2508fe492b0e8cd003ed5e05ed03c50c5832cc4a3bcd5f221df1b0f1175f4b8befabac0af69f2d08e774d0f72a8e799c58d007569559fc5d139060488358cb3517d6f508c31fb1e22bfa53540c901164ff0120b821837f80852cc81353d0049ea52c976bfb4fefeb2772dae031597bbb3c14972c400449f2d29ba089e67c1dad4a00149e0c650a59f6cf07b353301b339d61f96c650c3bad05aefde9a7bfe2a7cf7bc7cc2b0c294399f4a9eb728a84304365906de7be096f2b6ae3ff8d57fbc78634c0daf0680ec2690f262d6f3f9c3e840993d66e684193dd98969e03ceacdd93618d75440764c1f9313752dc6a44981702b9fc08364bae1a6918c562e8943fe54dcc122b94627f0a27891640f03e68631770cb1969d538638838f23fa2a17810f4251cfe14a9a007583752fbc17030d7f8600d14555f424ee5754480bfa75e70ea6b52474207469d189e0edb6ca694a956a1dda449b6494ce42e90987b71af44e22c6414c0ce97908b4df2701aebad8de6336b0256ea37d39798ea4a146a511af3950f7a519a48d6199e581e2881d773659aa1684af5afd2caf7e48b314bcdfd005439aa993f08368fb52306a986aad653b6a012cc5280fcbe340aa3b09eb2b29cc91da660ed4c2dbbe6a0a1a3f9919c0e6da9e02298c9b7930925eb51003fed8c6abc3f2bfd752b498efe4fd6ff2d4e324830afab57e00530ebd8dfb1504b324512cc3d0edd3341e9e56ce454c6d0f1ac97387ec1aaf5889f35fe9ade78dfe936a08ae3584eb741e76482b96eee31e01c35e81e3fc8c051cbf5fbfe51d0730c8753b646eb5d6480e8117581c0ce4bbf4b9832a951a31768aeada6ad6990789b0ce359a7bb56b0b47e6c29ff2d43aba7a4bd9ae2f6639e5b305e772d8a9b4a2990f67800d1b7b2e92e85b5dd068f72b9c4d015953061ffe3b9155e5337efa1d0bb8f71864848eaa6dfc268fce31d7c0fe81a2223dc2759a2372da1fb08acfb6e9ceca7bbd7241e266a2bfd9b5604a32a54bd0992df47bbe36a70a8ac3f801dfbc5752a5efa14f11c47240d223963b286eaf1d4b04f09c70b3d59907651c2253c959e167c05615a7f56fde14e47d847c87a49e5bc98cd8292a313f857297934bcbcdb25341490dd83148321d7149ae813525d644560a437e98d8c79f2ba1d4cfe4f692ace59100c04f45e2dbf1483109504ea128afede20b9561a35ecbc402b59d55c2e8ae434f7e5a8ddbe9bf1c717415ebb67f902bcd18f60d9cac79b0c8c48726c9fb43423595366d0ef6040865623b5c29076024a755f80b1244ad1992292c5102e24fd6c7c35b5fd7aafd4d4fa4f216d98c842406dcc12c2d107c0b9b6335e23047db9ed6f31b1b040d01e55d80b107e67122dc4ca3be28212eaa573acaa7bf6934c292e31f024da38fb5cbb3ce88316cb9899ca16e41a766a5ed056eb6a328c59b939969170a39a3550b6ebdc19a661b6d95c09ae90c2b7ffc6b01fb0461522240cbd05c65271e21cfa73176fdec366bb9203023f6ff3aee42da53b399c5cfa6b589d1fdf3cc47e8d9fed7ba4f665ab10db062259b3437d1a57ed64dd3dbb175ec635a6f8105126e30325d2bb76be20320f3110722be45b35f920a9db562d7431f9e379a11eaa0238969dabe45e7ca09898b0d48676c08f46ef50eb2d9a545ceae0a2770e850e6917f79a54ace18299710be62f0922dc88f6eb0de86a5b6195f379eb6d0a74ccd367385293d68ca2aafd115e7f47969da3c8850f17a6750b405a01158c2e732540032a4045eb6f68efce42cdb904fbc48faae233a89eb6f5b00034d8dac32b8bbdaef061fb75aedd8f97349bec554177d5c99e97368c999816a4f7e23a7b0b84ce086d8d149a88210114f3e29cf976ede1516a5406ea5b20c06aabc304374feefe1aa46a992fe617f3400fd634fb4b47983a40e14e6565032f4e265d1c669d1432bc43af19300c9809cd8351b1f816d54418f545050fa42980d066f0598470a15ee461f23e5a5d901920314020ca03536f8239e9506bc9a7ef03c21374298a6c63a85aeabca6ec714a27c4d7a7dbe468be485977c346f7bc859570878312c83711a8aa8f9db184f789c16cfbb82a78f4377214f03ab8e6e15ad046c11052e186c29aaaa4f8579f888c9a449d56c111ed5c840d53dd1aded97020ce08211733482c84b7fe86357061d9b990ba9a4314bab26c099e4a0cb854214645cf6a1446d53f269c33b2a2b2319e843ddf15244be2f48c2b0ea066b39a4e555efd32fe650e901f23e460d7328f0162870e23a058615f6eb52353a5fead6a51c1b52b13ed5a9db69587ca6751a6c32ac7400a31b25fe8c77870ff6635b5e5842fb7acc84220f02d19c2680e7422a9130b4c760d98efa7eca632018b1a207b678dfddb2fd56119b4f8e581f6e4b03cfc32dcdf9526a07b36aeaab7d25c825860fb2e020d26f0c505cc8a81ac93888aa7c1aed9ba959a2a312c94e10699a265b9a3425502852311006fca355b7accec6db59da7beef0c557732038ed4c5897eb286c8098e5f671dc9c52ffcacf4683c3a7c260e3a0d8f4185cf779891679324bccc9201f29ae674b8f8b97ded7261b6615616c75d265692587c0233c4b0b00befe0e1855c8d2d8ea2fe85f268fcf2614ca07cb2889e7c53c7ca28be142ed28ff0f5261439410f6fafca100bf4d6e6dfaa7ae232c223bed68628ed3418c71f2572669cf7a8b1cf3671eacfe25c711a57f1dc499767902f944ce9626be49c79b472aad9031e1e958eaa46c078cb076a48dcc34f11911d91225a684d2a45800473e9f8b09d4f0f7a7214aeab1a73cfdd50fef83fb9672f2109ed79be37025f830deddd11532818853842be3407ac4ed7cff880a608b6af58337ff9e46b366a6490ebe3de9843bb3a0882db25e8cb4dac4e17b1c3c95f1dcb91adbd35ad3a39c29f6384885be0bf91e591352e90c729d4c88e845c3ed4b0d361a33507ef96d824018cc1287e5edb784f7a057f9aecd7a92af7bb7072029337ce29367459cf55a2f6f015735d0ea7b8f88c99851d31fe6fd179665eb89d1c421c3858cc4d053ac8d8bf9ebdef229ab37ace454df982fd0d513a06f1e3e9f3fe3af8e6ab80b290201f292a8bd7d44bb92413224306f5e6be4ad8da29cc573ca207662e412efa7f0b7278364acf1db0da6fade5bb78b1ff7fc845370c6a6dc45a3a3cd5e18fe61bcb12a84ed60cbe1dde537e49e1405b050f37a32b23c440cdae351808c3122f166ab1f1556e34bf59d6b83411496eeacc054aea2310c95fcc7f79c2575ea041d0e6fd25f31856ad724018a32952724fd5139094ecfd3380070ecc4ef072e03795588e5cf38f8c6aacd18c5ed202eaf4b4fed1f12eaa1dce6a5a79ef67c925d30129ed2e56a90f16d7fca2fb5d783ee63a2bd1dc0d26b56545e20d349dfd1a9505d20f316df1c938e6866f19daa9dc4de3d5ddcbecaeb3d9fcd6b9bfe7b06d0a3d145185733f13aa86421b1b417a5fd38c576220216be5bf1d0f4be6457be45c8bcbfe9f9652b55a2cba8f5a6ff87780c792c0ded98ccb4adafeafd1557fa6fc814fbb826427017660cdbb2bba365126551d85a59848b3560f0c2e915f01e114c472cb521156069bd591720923ab047dad7f10b565c05f614c38429bb23a8ec4089265c15b6dc4ca22f8fa97e1474c66434657772563b261d7f775643bca98812d8caa1a887336da79260839f1aa245931a34fb2c713e1177ffa6a79462871bb4ff750b4c4dea31d9507289d51b55eb978751bb054c6cbdce46c32294bbf2d44d6ba5299bc7bb4e1a139e48b21b34139c46928c9700fbf7cea7aa073fa492d3820b8f8c69c02567770f0459ebe5220ccb1897c4d9cc4c1251ba96ba813641950f5002aa4a9bf8c7d66301533acae043d6b827a70984d0b366871305a11d47aeedc57fc16722db5fce035a35e486aa52f46a0c1b80aee24a157c75eb64a863fa2cccfe333603a4c2fa3b578d442f537c58564dff1d5e122ab5bd501ce7293468a0b717ffe71879e12f674baaf32f116c3f0cb00c33421ce02c0e7c48cb37075603d78e408532d0e1bcaac13a82c05a288828a3922982a16302eff472a9058962a2a4fece4667e814a9e81464d105505e626b5d838ea3765bd125b64bb7193ff32f5cc18431967e4f550527bdc45a0fa1e3b0ce676bea162b8c7241dad3eb2e6f38370c993df43370fa2f67380b1d374f779baee0bad1302fa891d5d94fdfe6821b22947557b61710e991b62451ddcb5feda3b8b7cdda1bd3e891faad35a13c1ec02db1babeb1adaac0383d7abfbfdbe39295eaa8053205b349e8dc07e4264dc877e604e0cf42df670e8fa35f9d9a413575dda09d645c54cf82495af80b43b62d505fd1bb248f09f407914669d021db08bf290b8dda538965934cd83ed459be2deff64a2bb6327fe48623ed28f82c5973853a4a281d6ab117d2d5255c9c0739aae64e6c48348d215c9e4dd7b3cb85ca3fcf0d89cb00c7dbc14a5df4dbb5c4ad689a14333010c8bf017f9fdfa04c630b9d22fdb15c9e95845f0cb800ec74dc69eafd1caaf6cabdac878400a54ea51792cee050b6a874d5dc6665ced7d0c842c015558ddcd465697c7426a02527bc5e1e80a54bcf26140fc64a096fe976d4caecaf86d06aa4e4b0180c869a80f5076c7816438883154d8e20765cbf41a167bca7ff72c6f315e43497281bc66afb6de1c315a17640bcf56cb6d268c142d41694d70c7dbed839d5a9af7fe1adef103a3d05d30095538f71ac87f3eca19bb9030d88ce674277086f7e8f29894f97209d40988631372e1ce6396df0e7743818bbb04d3c102e376163dfd2b90b35daa482e2d5834889f61183ef1146d6dc930430990720ffa020e644cfa128943b58c8706d1fa933d3a4f045f0be54f8b024fc1eacb01b7e01d5292cc93ccdd514689e2bf1b9d85f0edbf2d62e47d0d2a4ccc3b15c9cc16ec1effdc224a0bc0bba8ec5414d12bedcd34d1e8fd45324476869486ccb7e012a35e2626cceb6cd5d5a7247b74db7083cdaecb5f8d537ad77b3d4e937ff7130659b811b87593b0b9d47c5bca15b31e75dd6318fad1db647c2780aae4976fa6f00cc40f13301e5f6ee4b0ef94e7df405763e28fb7b951708681efa29473dcef7f3bcac74e85241af62dcba20b80a923354a5b57333fbd9d7015bb36b55f6502a51e5c1719e2b65a0611b5caa74cff235900239f87d376aba5bf1430949bdf11f9af3435f40ec914ecbd67a472cac0fe62d136e7b2c63e1400a28099834f9e80c7d4cea39386c441dcd263e4c089f7cc9a084a72f24255d163a78c1b7ee8a43ecf3ecde68e841a85f5ae04758e308d000ac18566235e6416d9ad521bd6ef3882a0a791d8a40a5c63901e32c94c06ad81b195ae6a15d3f1b2a145f2d8ccd122d0ede39b12188f56d0523e9bb76300b825c41d82cbe2183a9ed38a2220db471220b747f1ae8c1ccc0b28044276be2aafaa3e6d06ae76d4f0439b6260e9f55e2c768541e0ff1d7e7e912766d0ca589e2bc197a7383f026adcc9d6258ace5becec070be14dd57f4505143ed93f87e8eca44613b2c2d29565e5392a1507b180def045868c7257712a80d52f5524cd9a2d4c03de575b3a559d4c37b74301b7fa75883bbfacd22a2bcb8546e7adff7afb735f980004d9fe153922a96ce1f0d6f9cf30d83bf4a5386a5a810e3245e987f1b5751379a253990e8b2ac8ff5645df42faa6305f238805fbbf026d2ff8442b7f744e6acbf774e4f4a15df87456a30b062500ada16ff49dd0b9ab4695b2a005a93ab08800d16b0caf90c480fe3c4e5adc0c1cdebcc57ce1286ef5d530198b4ee33e097a6d99891a32c2aed4027e7b12c78adc0a3de65916fa7402a61cedd6e19865a86d4a034aa92749a21d666c1efaac5a6a57223ee4c6a782456b8421510c1bbab60b616d69179ff2b33bd454ca4a69ad53015f8b4faaaa2ef833bd441f56a931c422da37143b09aed3b71d05f54bf306689b85b15f8a64f1d64aa79dd919f12c68fe44e4fda5e86bef83e157e5cbb6ca2b6c62f76cd37cacecfb66b505383676eca7f19353665a9c60b1ba056b7da516615514283f2a037669ee212f2276f767b459ea35205353bd25b7628447a12066adc4903c8bf859bc48dffa7490f676fe3f96fa0757ebb136d8336063c8d792b7ae48fd364efaeae13c4348688ecee495e8955f37ab1c998e0b3673609789b6f4433c6e13def034e30b6429d02c0fd42126de3b8dbb3b2e3876cf0df854fa70b850409281f45294d604022cb121781c2bafaba12ed0b1e0ad0c42dae2fe96ffd5ec378342e7ac990faa50eab17022da10f13edbeb5761577849d67ebe482c452a46d541e283362d18afd005136baf1b8e2567a1abea2a0ef82bf19ffd9829035a813634cf2424ee6514989e7277aefa0926b9bd6c44732b89636956f36552a802c4e7ea70ac1603975c94546d872a5b7e2a5406a4a6f822d17e006ae1f22c4e18ac57063dc995a377f4a3acd675ec040fa41d3fc1d0b7a07b722899fffb5f698377a8016986f3c539362adfa0f8c73815400e9deadfcf236f9c17b0662a5d20142c8a533ac577946daa68f4638bae7605d6d9f4fe17ca07bfe53e197387b1d4c9b03eff5d1c7a20715b09b6b823a0e206c4f172ce1347b19371c4350f3529cbb2317965b5357876c36bddbcdf880aea62d29e8e2f33105af056734122dfec3b8f2af72672deba7293e85f7a29028d5a7de70801cd42b91489c4c2f64d49641711ec3d9b189012dbf7aae650dd5f796755b356c27ea896b4d6f20a6c13655e6d464d5974d93eaaa194c34096d3d37ef9f5e13b8a5619e29262799ddf68341eeee2ebab46f64141af1e58b3d70f214552026efd3062f27cf9af826436cb6dc45098c2dd061be4906494b948582314119c3859339b0a8cf43f5e4ea051108d426a5ff76251f7fda7c402219d5aad4db422e94dc66c7ad2722138a62bbbf3d0743c036e927e1841488eb947315012c47a6da97660476194ffac677156986945d1ea4dd061067935492258cd3efc9aaa02286382180a4d80ea434c4924dcb9b3078add8c43b02ef932eb34656ec39564bf3b4c663b2b961bdc975b2345a86f64d5e847861becf5584200e5df8ef644a90fd27c239de1b1a7153b257bf641078178d84cbdaa3bdc2a5ba01200573521e1ef906b192bc6873225f15a8be4d61317e303338389bc8c58bab7876caac301887abc38bb0f1b4d29d51fbfc70506cfde2caef6daff26759a6d2e1104b55ad71e270f567d2fb44772569c435816ee146ec3c7219afaf50dd23b4537b4771a67038a4b78bbfb797f9294e5ccd18b5e5147427ce004b51555b18856375c4a2ae69637f2a749ae8555d808e79adbb4dc15c3be2712fdb3707edb26d282c4a9093677610b0b3fea583fac0695e28a4743e88fd0d9c8f2f4d5955463c7ad0542933e581cdbe0516218dd0b84a3b4c36c3284bd8649a517439b44fd98f7f578f4a6bca0f71cbecc2eadca4a0877a7baf7f67924dd13c58a26f5738cca659b2c3a9bd9a574ee66d69ccef672fb6638804e9f66883266b5d2f9ffc6c5bcd2fba3f6a3caa6eaf39c5156414c0645bfb219ee2b92c33001d340932fe4d1d03aa7dc8f98eab38a74b83e9d13c9e0175644b4e4fb1541fb1b0672e07f20c4a4f66f37707c60a7f741a18032b20f8474d44e3d92597d9fc8a7cf0082137aacfb437f0daa37763db32fe7902fe2e2d0884899931baf519b76d20b4e64a2106c2d907fd6f9db3472e11bde8a615f7812600823cef8e7679f627fb1700c64d5bee2c29b444e2f1b897ee35f622c259ecf1960818c13ec2f325cf2af71976030fcf19898214a6ec7cb9810d3cc14a8c87fd1f0eddcca036a1f13ebe9fc44322ef4b6c02747c2bb829b68f4a109fc6fd5aa9a0016e57b7fd6a917fe2105c25d91ba5ecf3af4cb2260ea93b7e9c2317fb0d5ec65a4cb22e8e4b4c9c674b8706b6890164395b5f4aa6ece69ca28023ae9b8f0e52f2de5d62f27970820eb68a24574ef1044b277cd199e4846e373d8d95f1046b4f873357ab4cbd16207b6314e4b869e1e5243864d1fa35ad2696579a3f42c8f53ce6e2d94005707332da62f958b83933dce48acb2a24b3ba1fe6a437973240fd8f33d5890fc1e9a540ca8480586a2b9fe3f9c4ab01c60648ab3721ce9a5d786bb4fc0a076e640d5a4b42296dbbe92479da6f02169e96d95f5ae15807482189860797c4ba76b99bd3acb8d7be1d47ad0af23a216f7667d40cdc9e21931ab2e462b760c2793833ee4a896b2c6123a48f14daf787d709353248443e4fc6b7d2b9db4dec697b858a5fb2eac83151030e090b96eaaa94f71234f4bc743608f4b44c2e0e5e4db37fcb455336e3b03e0a0a88709f84b90b06c6d780191fb8715b103fc65149c4f47ae9754f58b839f54ac6a48fa338e9684dc0fda28ec492667ad797b669721625dfb9157968b5035ff4a388df26f523c58d3b015b86878d31d4ff1b957446dd8e7678b62214dc0b947bbb4cf16e6797f398b9ecc838ae76c9708e3a562ad29388a9420cd8d98b9cac2b0deb8f88112dcaccb878f981127ffad3f77327f4454a2e011195e0afe5cf1d92b53396fd429b7a83316ee54929c8540718a27ba921d004a8e19d90001b2cefbea2793b120674cef6fffcdc923b635121fcd77a411700e2a4f2d13e46bbef41afc503d45f847274298e2d2d0b825e2d7c3ee340e8ea6633bc398a23179747070a50d5f2846b6fa3f1a555eba7f16671bf1670baab47fb43f3fb923ec03a9e7ae64065f763b2239b64b96c8c5755a2d2371f69c641c22fde1e98aad52b8fe96cb2263136726fb83e914b72059e90eb5ac448062980f597741ebd9908a8d7ab58f553533285a17ddbcab2fc657620aa8472a1e2389c6f8c75a59bccc4afd2aa560b242b209eba1183b2cdbcf278f5fa8e9821a328bf9f273eff27e30375a9f41056ae107f918d9466c49fe23a631e8536376a4aac19e521e469e6396ebc78d9162f37259d41135eef18ec2c8446eef4f3cbe2c55e5eb7e373bb187b56c539693ea5665020d805ede601bec13f5e66a8de884e29a00739d29ed71b37fa308ec5b1a2b7707a157747b0574b428e6cfe4a443462421a9ee3461b261b41d8865710495dfe180d42709006817101562d60d6482068733c6f894ad60e28c203b61c4bb0b7684579b6bfa1f5302b128964d5393d8cace1be9724e5ca6aa60fbcc609ef9a09e98cd1125cca13da139785c19ebab1a063a3f2946723751356f51e4e076289c727fd03b7095b0eb222cbe606b9c4d65d3d094a10550184117c18d3d86c64a07eee0ee05f6988f21fa8a37ad6ad654e2ddc4e5a5611f44b95f06b248171044d7d05c86b7f330968953d4413a60d05068957181c4a49a29068d104308e8bf4f74ee57a32fa776ed2a17155fed5a0f99c689cc349c82e0473827452aebe07283d295ab27ede8d7abc9d2d9e74b1d4f9808bccafe6e76add539ffeab9c6e3806fd78c8e5d26f78f858158f49fd53cd4e9d8a5c66e66e9d37dd2127a189e5478cbe96861c975f2099874cdc56c0bbf8a53d8cf6e416d9e3b3663240553210cefc2f68d1a79f5b93584905b6698e9090bc103bfc94aa15403ee6d3fac50cf4e408e7b438c22fba9394075137183e450b2a5fcb31e4932733929ccec710b0986faa718aad6deca1735e75c203b4d4f37590d6f05085c049f32f14ec7c5364769e83303e88cc5d25de08c213bfca0134f77d6e9a6932e5511a038e12d296e8ef46deae5e002946f6b29569e4da78730170dfd2ae9c15c5441e37187f79edc0f8bd27ad283d5fde1c770046150670418090ce74c79c8499dabb62051b0503cadc00bdfab84e3d80508a9e256c10e4849f05ddeffc702abbd929bed5cb50a2617e0d99b12146012cad2df16286d23cb9d69f2d30e39c1431f1d35e8c8864e7a4f79484338142dcb038b8079a0e76c8889d4a876e8f78612313f7316a8db02580e1abc3c1040ff98400c0494f75ed9a45c971748e9dc50a78c542b29bc4c88bc66ed818099d7e507279d140fb7c3b2b5c82549ebd5ccd88d0ea6f3f39c9d609dcae1304fec046b282620dd89a3b4c18eda1dde1d6a40b2a10d12a3afbf777beb862416156040a47e1a8ee85a72c7becc9e7b4d0382c7d280de7f5aa9fd77f78559c92f021087645bf190799a4eeabca02326d5272cd92c68940627de0ac16355777c0494f004f920f26b7071be7af5f9fa04a2db06349fbc0c1e89320604b846d53c2b5c32e8b5ecd7a4f944fe43aef9dc75ad063759360cdec31ab07b3f45df100d7c900b336aff9682c612c2a6bd50eddd51cffcdfe694155189ff12cdfd4d5698ebcb70e26c0d7d684c6976ab0f28291604245cfdb84023a9ce98f87b6070a9e177c1a732874ab87bebf26e2f7e25dcdbe9223588b1c75228f5c681b0f120a36d858208a22709dd47f416ef076b82963cde78156c611d30c1d70415678a88e27f41b0610edd4b8c7adac96553829570b15f09bbddf255c0dc9d97f602d5f6fcf30aae77300bc02f5e4f791e28947fa01735ba40685c42fb41544f41f7b68a9e15525e1df62539b4a5ca5db09df35b96906e531292887095c39157c632ff6fed5febb4e57d48640c628a84ed8e297651b0bf48cd2d0a2b7c52a2a0831597d81690c895c5cba751f3e234cdafebb3ceaa63ee745a7b7864125f1dfbd7161fb56c4aaaa4074a93459baa1251d73729a975b19a70d0f39bb365fab34ddc4fe6caeaf74b902f5ded0b4e9ff456df7170b63a4f5341798d81e62ae173fbfdf05c188c7446b9545c56216c69b684fa3bf931fceafcbd8ed9f0df64380257210566a5ff6591b53a6225be3ce46b0d1e14c91218937a3631fbdc5b601160b085540bd7b59ffe0744bc250be6def20cb1b119c7a8ff7c6b716fe8c92ca425e3ce83881042c7a2c21aadc60f86e276b68cddb756ea174633d86f6bcf9aef36f12fc7c041093582e35a47e90904c3fbaef6e1a35565028f5f3486049cb9c1db0ba6c478690fa41a1f8a07bf0fd51d1f8bcabc40b7538d3b46266d7c94c3744a1a5de42f6cf0fea6f33b8eab136d718119ec363a4cab95147d09a570a3cffcb3a97bd97b0cd72b78108c5e23dcb302bacd22b40592c86a79955ff6a920122362850e378f6e92002cf8a813b50ba8068af433b463bccdb3ecc11d4ee4d54d9a33f371b52e20fd1d00d0efb09654baaf6a4454188c574b63a8c1b05e6e2d21cf8848631bfc03db726889109529346b2608e0c662f06a844cddf59ff7ae03b34555675bbfac1bce87eb1cd52671ddc1cb39440281cff24a23594ab7990a178558a17ae75ac3a8a2625f38714b66aa1491a27d249fca228b3cc92d27bea0d34481003e7496ce9aa92a218c7eea40a3762085d7ec068468045acd567c79d00bce1fdffac32c39e7a8bbe953569211b84bf681ec01592da4d8c6873ff7dae6612e950b2a85d8c7a3ffe409fff3dbc654d7b1ab136625bc265de0156b7d3cbad91f60bc211964351ae6b0b2581cea7d8e19f56f8ef79601b0c10fdafcedb4745c03c2801e96ba9a070d047cd097e9d235b24f313cf1cadc5cfc70c7978b1b8e2bba86229fe4a7591f4549d1aac6507598a47915c064daa502b73e16553756482fdedb397eaf56375fd2c9320391286d0469680ef1a655ed921dc261385b023a6bc1212bd3722ae0175afee4634b2abf2cda81049861e99edbc49cb35c9d873116237c3dcf6ca86a922391d817a4eb5e8b1c6fe865aea83cf86eec49ba6adc611c3f4c2fcdbd56cf630c6f9bfb67598226ef12720d8427fb569e49267925d3416a52a0202bb3987f85252f5166cab80fab74252ec377e7b258e1b6b5004675b61a061846f0198b44f22378066820966c75648f44299cb9e514dc5b51ce9d1c3669445f76f08272e0a038585bf53109e702ec2a079f205412b303c32d6dec856501b4fcb24d63981b472d706bb0cf6e9064725d065af1f9429b82c641b709a802921d3010e78e4b8fb9207bbb36484a3c6a37bbdb3d700741e0101dc01de3aefbea727e2059695eba7c6a145cf65e3571b2e634117de168e13b6a5d75bf8d8a68c6f12c0cfb67e516473582a38b437b3093bcc43e31de0f44fe71bb25dca4b1d6f753df699bf62728febd1d6c472fd51f012766bdc8180ea97a10c5ecdd5e4ec52c7fece7d44298e85f9c67eebf3201bd60b9d8eb4471d323573afb01c1cf8ee67b8fe7fb421820eb6e0777d6ee3a5de512855d0009c404b0bae0b11e61beb58fa3191df3764a48a13cba0e8ea1f306876e4f3c7b51dc72ffd85a3bec61a60cbd13843d115c48aeb2c1d5ee2fe1a7af7d26436772ee6ffc713ca0c5a0c5e24e7cbca563b9774ba355d700f0285c301dd786adfaae09b0d00884d4ec8693e165a8a99d2f9467e59defa6359e3189443a2db78ac4b865a1acb976d576ab0ccf78d28d3dec2e3e5000f4c6a2926ec2ce89b811e913584d12ba0753962c1d3fba2063877a145d5167ce5955e2807dfb90014538c766f4dca08f27360c064991dfdc738e3c34444d316b8b0a31e43f5218c98da5c81d827dc47f734ee0f740a4bf4b3f6523167f66e9ec432d06fe477f285ff30776785fb75c533c715a98bd0d58c7a9658c507bd570d6cd1d83956fbab3ce63d253e549804ccc34c60a3eade3e46225ad3f63e902c62023b1045fccd3475dbe462002ef870ef0e0a6aa38b5891bd9482fc2ca586bceda0bc183185f909ffd891faa9b9cb9b81514369c1d31814a095e5cf4ed53812123efd8493880ad21a9f10fb0c7d2a1854d51d973e0bbb5fb54b1003e9663442240f39da91d82942ba5e0e6d6f897477e067fe88589fa72df9750bd104c8fac792352803af962bd1665d32d3be03d8e65b2ff7fb256ba18b7e9e641730252d737d06a3bfdd64e0db435e9a6fadf88b4477ab55db7de81103df68f579426cff0ccf658f26caa75aafcde02e57c50bb55345d04f08f4d9efc50bf0eecba80c50ff0bcdb0ad500e2434c6200d0143a7fb67cdf0da71a05df3a21de239e8f1b712ce26623eac651b5ce6fd628e8590532e0ef70bfd8f9b4288cd154b9f2a0ded11a08e406a5717339bc52f7e66eb4bedca895da82e9ed56c6ba54b218faf3f16b0dfa67b7b417fc290642a83ceb86032fc4fe49724f1258783dd254036e0be0c2a282c38059f4b2eaf61842801c0aecabd0ec56b14decc73f1364f4622c6548aad4a5ff7287a658622bd600c4dc32eae6d604d96861451a9a0386ccc7d2b784264b2784acefbc6f8bad99aebfca03837cb73de8b2963d541c9510f0a0b9e1ee769d0d54df0281485f46faa6893a293d3770bedd7c8f701790a46ce603ff03072a60cb6be2c1110f8fa9005494cea74a1879c58e87bde4ba041f78f33a046dc845043916d5e6ab6796b20432661cd2aace1b682b33fbbb4e9c519e182693542fc72239934de95d142feb11d13c1d7ffeffdc5e279dcef0dbad68d199c1bf4bef6116a89fc3f336b9aa373ea34faca1066026c89051139fa49feefcf135a25cf0d723ba06ed4da55a46e0422e2a1baf26df2733230dbd970835dfd8fcca1cd48bfe47bc3fb89e869a13bfdeeb215ba1e8ebf603465816afde9f9fe53354e4692fcfeb197a8228283927d13eb6229f6a25ac82412db5eddf5aa61f0eaa2aa856e7ebe3daec0a4d905f9f0ac8e4b85879b7afc2cf15bfb1f35b853ca81c6fd09c8598d7805d892d78b0eec82174b517474b54b404c93c1dd8abcb3d365389323c24211c6c46db1da5e81852696761891bd3d50a9177ec94cb961e40714027a97009775d7d11ad676144725d35474cf1f7bc891f740631cfce54d8ae1951bab832cab1e015b2552ce3d59dd6be0290148f38f5bb0d72a0c30d160d7ae4adfcca140f7c5b8673ae53901945af9b990fa2639a2734bb6e877b7b8a2ef6ea5bf972d8b366236d75743e7dc60b6b0c11d3579b15a51c8a78dca46fcb893e17a0a2449e60d89d349967826028e55c16d59c78ef37831a0c2499dfc39243fbba668addc791762aaa15276a374224592d4d2760a82b0b5e4856962cbc369031b542cf0adee450334c79696d387144cd2ad9ee376870c0c91ff7c952023cf7ebbd3527abfe4cb35b93eb6c4aa76c64c3ec14036e38a2bf06b9359a6c82edca4fd0757fa5400d667887b504c7dd0187e3c61e25038e201a4fefdc6e437e395c9e6e28b92f17e4ff5b579ebdd0d982d5e41997bfdef869ba1cd7704dee9e7f14affc5563e8042af9886e9f3430fe2a203cc385952f61e33c70311ede576d69e8c68e6f16b8fbb7247797699eddd8f0cb6653187d0dafcc6fadd17ce1c4425ef7a5c16cf3e9725cdc006b3509586c37218a323f71e70eada12f5ad8193573f59f416c6a7d4f6fac8fdbcf647c5821a33dc656d448d866bbd0e2fae9a7e928ecf024756cd776a0174d248a9bebca6d519829eabbc4306ed63f36aa8e0d4aa6a24985cfa441ae8fa3270ce10c93eba7e4b76918febd8454937e900f670b2105463d00db1d8999c3b6861c6c4c2695843266981fd352ef202d6fe5c9c64c6591d51addb6c321b447a061a7c7a10f1dd738ef87611f69762d19bfa75c5c0a0ce120279714a0b1f0e42d73162911fac3d8a423aa5b982e7b6564e72611c4575d91435f7deb3221c68e37a342fad2d3a527e209ace381c0d9500cc0d4b071c0c3342f6259f5b4fdfa229e15a8d66b036488208a81512535f1f2d412a5398eafe1292f10080b359af73743404dafad31d69ed70300dd6dfb8aa2ae2881d66b6b41ede9f8e7726541f3b30ca11ca75ec67a4d6a59793dec52657c460648b76bfb41b7844d7f78e92a9f3fd8c9d1d98db1006f3d70a12cec35bf38a79df8d249bdec97d8b13f26571271b4c61775221eebf60a6bd7980032d83ff28b2dad65beb0d5eac6d6329b144f9049fa767206082fc87a46dd51bb58f46ca6663f98228b01ab99719b1a924095d12e45cff371ff41cb1ffa0acaed1ffe94aed35ac569c3e3a3951a36b6f6b101e59cec3f6c014724ef3872a0dd3070758848c1a12910bc49a91153c03d2a89eaede149d6f329736acda7154c4b62805de10d3b3b61b8a24f6a9c2c14319a1ac18471038a3b3cd53714d8a8c8ea70f16fcd17ce11a5298a5c4e0239c21c30605975f6e6aae04155c37e1538f25d02ed424a31d0e939fdac675515faf5ef2b88a139cb830801cf53cd1ee021f7a5b6e7f4255c5ce7b29c3ea1d2dfa1747bfcaf562a38c9155a49e0bf7035a46a73b857cae251dca74c70996a33640d28cd74880aa72fdb425782ffc7bb87fd3b391dff5dae154d5b30f3bb6e1a5ddba480f2618634a5e18789990efc212af9b68f060d50e387d7ca71225f576cf232f410ced9189322ff72988133f30b22d26c0fce7ee6f6cbfaeaeea62d4da0c9135de550144eea5fec22d3f4b792ee9d504b7acbf111532a1721b0ba486e4fd73d211712a293adb4b8490117064b088aba21dd0f1f2d60ec97c980e41618dfce0d6792da94a7271d6ffda9a0f40b5d0c3259a0c5ddae3dce1bb32f1ed79be8b4f519b05a1f8b5e5d50f4020e48ab625c422dd980470bf044b7d010714f9acd2176c089c9afbd83d72ac43e8933d51860f1079b35673a4f19c83fe5c98c752ce0537f76d01c473acd88090f309502a7a16c75ffea7d14655b43d2a138ece9129272f2175959e3bdbdb93a7aa19a19fc46d572f60fa7ec82716a7d1abc33588513c76c08f616a1fca4299e081d10e98b4bf994a227803b7fb8e2a5a93c6df02493943e9aaded0da502ea5dce512f4a4b94684639d74cbd0d49296bd6bc246036f2c8b8015c34410c73aaf2ac68e93d28d6b16471ce7982643949589203ec988c36f4b9ac0ae7396a43749dff1e5ec7429d1de5a6288c17fd147264398f3f3b408add76d4095da04056334dc547f8ceb6e1cfee2b638c258a4e019b121e3060d9c9290e8d907555a37ae2d8d0885575a21f5f430bd98696546cbb6f3364a0bda16bcb0b957bfc97d7d95a72f368723e1794cc7f467470cb19c5cf4440c0aaed3323c505559ef8c89dfcf1f28093d82273db2f92eec2bcf2358eeb62c53ebd45358c51a81465c56fb7a2f5dcafa6728c778cb38fc3da8325c42026eaebe5b3f184c134a2361639918b5af5e63cfc097ecde50c88e76acd2a9e7496c7259c5db1eff90cb6309b97eb38dde28ca8423cdb17b37c5f6e6a20159410afe8e15929b65580ec478c9fcff56d5dcf5b9e399814febd4dc5d5b4bc1aa32ae19e0d4aa4779a90252035bef62e4340054eada4666860583376d26b593d8cc6c2f60102af23f5e0dee7cdf1026759230db5309a7e3fb25d183c6edae2af87cd27f5fcb314cd5d26557b7e5b472355df48fa6ef64b950201383c931ed6f9c5718e804731e096b83bfb0400d5ed102ab8a66d47a1a037f4e94e8bb3ccd211af3519c8eeba0497bc7383805ecc12d617e4f235a6454235dd8090c79befed6593c502a44e89690b31a0623da163262a8d74443ae68aa3d58450aa73ddec204df42b44b2d701eeace55d3fa97bb4777ada8bce103f31ccc89db156a92706847e3a702c207e6f68b702afc9d1592d9e0108c2e6ca7b718616b480c91553865351e655f5cf8d40dec3bbc15238043e68fcd4e2557b056f3d6cafdc9e90cdb096c48d605ee5d88ec5c3b557d0a2bc4e2c8644cbaabbf42a2d142ef65e04384b9baae452c2ee97f97fa7641d4c00bb008c430a0318af62072411d2f3377bde2069bc722626c40732708bb5665fbabc7982bf81c56796949c88c75db08002c41b70b202f15b971eae7489f3f16f7d89f168255b226aba98d731d97c32fadd147e60fb814ffa859ad76cc61a06ca2a1b7b9836f86e7178f8c1eeeed413d88d047ef7370fbb34b5f8166e94f0c29a77af287380956de559edb34bce38a2dabe2c7b0f89ed9bb70e884c15fdf66cf7c3cb27f98c6826f6eca694da26f42eeee43e9c5e47a8d7c94b5b76d69734b7b024b339dc9cafbb20bb9a472f64581713f4313bc8e12eb6da4e89349dd08a6bfa329561cc4753a47c189c794711ea0abd0b63974b6864fe8dbea300c536e7db3bc92b138fa1ba9d22192353611d53cf0f5000da4f67164f78ca0883c9e1c5a66984ff4d35eb5cd16554d3e6ccc7126e5618d9a879a5e00d41407276891620bd0868cde90a386c73cd3964ae753640c736353997ecc0178ce5aa0956c656d0775c182c1a29d92720df76e2f9d0d2f58245bde82dc6a69017c32f659c498bd6e48b997732c28978188279dd67545ce3ee20034fa7b119bf80c2284cd0ad865ba13042d998ea211ec273c4ff130c31ad530c8c85ea778948a45f0980ddbcfd98defb7560e3a0baf316e1390dd308aadd35bd3642a781af489f82851dfda2925dc98803901423b34baf3f68b4e4c716fb805c8751c6fc701b2a482a5215de4c170978baea5341279f926aa85cd290761c40afbfd9e968934d99b23daa016874cb41c49ccac4cd8cc10bc79bba7639f651e20b227dee8132b174d4bc3e5193cf8d0112deb54bd995410df9da8ebfee7ef89a0e0e496ba7d8aa17b5f6abe134d5aa8fdcac0ed9a9ba798b112eeb478db468e0b60d94afbd39d64c1514127fc6150659f0d151f3d481923016b62583614a5028627e8c7ea67b0e83ad4b2ba227e74563d4b10c006adc00f15c404ad25433bd3520e3e432badccd8c14758888d0510ac7b0e7490fd86b7493935d28d1d43bcff786c4aa02044e50fda12dec6a400f2a7268ce398857c23e2b84347491dbdb996c0639f96b84ead9fc6927d6b636ce9540d3e12cbc0811c5a50186a9ee4e3c3cd3538960f8b4dc12bd9c2a33664dec83d8b9d89a33b88038f9f0f28a5f57aad68297ab097edeba512fe10e5830d899853669eb6a6395ef31a2230ebc365989734f4b7d88e1287d4ae01c549fbfe0d1d5ff809d1e00ad1518b48a2ea229182a3d369e0443508c9f0a4f6917deeaca9d0ece2e04ec86af478a1d5ed8678502bc42b66322b9427dbb9100a69bc9be285cf4c172c50d54347cd1ba80e9ed4a73ac80f2ecb3f520179ca375d99876b53b21b3810695e9cd9288ecb8724dcc20a43009a88edf2ca847b3cb3c781671d367af72b1d0a6fa74559c87511592ce9a71e40ca4c59631e9ad9ac1b25727e2572fdcf309a6638da67900279d3c41eb278bb96c88e6b535bbc091e1660a91e46c27cd805f76043d2fa45377a5b4fef38cfd645d865e711c45f33ea7499f8a0612e4d9908a4f000b2e72b740873826618677d0fe7c07b1fde953d39180c11315a28661ef27b0b5e4e29f61921f375dba2e458a296e2a69b88242d62d7dbc4933413e99e536e9a79e2cd4f0e443c7afd2ad09046bf9088a0d21c080ed00e2c59837d38487f3c233033c4f25aaf8af5e4255dae4c1fa3b27bee50115e27ae5b64a0bb7f8e3362ea234d00088244a606c078510e17bb6fe1b828aeff811aa8af20e8146f169ad40941bf4fda37145641073c5258e124b4e34105a3f0fa8db7473c8410792f73019d9f47bbccce2daf66181f221d1cf742acccf4d07ad8c77749c108bddbccb042e62cd334b10b1d32925978a14197de93ef9bf20fe816c7f9f6b7158b4168813e198b8341c9c984e8e2314d5ee7d6a48e219808e22e9ce5440ff288fb5eb99d216be4384f29a18e0346eddf3f67e930432fcb399d30ce8d5563a7e812af4f1c69cd67d8f85ae9fdb273961c175217b99a9107b38cd366e19472f580805d6d43145b379d17f08d0426d8302c542766052561c2a003ea1e787d747ece49c090b90f1093ef0630f60fe7ab20e915f1aacbd1efb6737d89a06b73fec1c0d07b81f77e7f78c9a4ff46e7fb964cc2c3e348f903a0c7f659c60317647593e64ac96d812016eca813589053747caea84f69128bae32c30fc1be026e39e8690e161a0328b36fc86e53a16901e3a0f06300dc7cdf53ff7f4fc4e4103f50eb7958f33bcd08d5ce89f558e1f7c5e63a842f70d8119e9415b26603c22c83610bd27f02d42efa771365e026b2dbcd1b8d2f7baec2eb50a5ffb91e30ea4bd64d9ee9d05d4e55d6b0aceff91911aae07ab1bd5e36c1ea922a5a82a85bb161a06ae4b4c0ad4fdeaf27c2660b810076d1f71a86acc58d95d7e1dac43eac975e2738aaf71005d4afd9e29224d130ecc498e0c5eed113c05a0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
