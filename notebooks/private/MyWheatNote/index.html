<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6bcb40102a7cb9efe8a2888674375a5e518a6e9867d6ec515be7899aa1a11bbf1fbcfdcdc2eb896ef6273c3f7d7814329d77ab1655052ccf5b8805db6ce1dff35ce705290c63c66979a171e5c641018ab5365b0580b53fc9f83a37a276b0df4521c23036af8ad190a64323891187e0c4d03d6349ee9062d246eab1013d31ef26166050b079aceb0deb56f77e550f5019f3582fc0d7e9dd82fba9ff9125cf876aeb14e3c9feaced222b9d03f739cbe8dd899ade86755f38260a7979edea00892a3695e82c4a7b3a5250a6b87cc989cfa2f860ea2c67dde61207362a510936f5fa2fcbd2fb78023800155a84a3b4ee398019e1b6f9290bab2419b48f055176a6d57ee3a99222365035161a9c911e6d8ba8e60b5acc18f1a2b4501cb8a8f3f07961923d1c11b617e520ceffbcd172c94e3b2ebbaa3be86a5b4714b73897b2eae81120822739f8d50193bb7ba4da26a32724e1fd57bdafb18757d51957ce81f6f95daca7451f7c26018b3a9cd71804f9fc927084ef977c3317e1556d66f11497608f44ed7e5c7545842cd62081c9c5b97370d0a03efd45992e82d2849f72f4cb9c9197a92a70ddca2cb38fb0bbe9a6be4ecaf90e45fe17f357ca3f1cac5812f2641eda35adf2757a641ac0e75ec77135e8176aeedbc4d3ece7169327578f59e6f45b37dae7b6665ed195364a3ba00401fd0445442bb7e6c79eacfc8a7a433b2c6625a271f307d083638622d8f5976a9aa9603ec7257ea49464a4c7aa4b7c767c7dda618e7bb03a70806e6d9a5df0c52aed24d25f5d61ac26ba0009eaa8ae7e8fe47578d4c738c873538b55b40b05154f7b8502477fb0c942192fd6a2edc7fc50222fed196ec44944efeaed67a8952264a53f6cea24a161ad40b7f035ee0cdcd9b36cd202394f27b0e88652432a6aa2d5d3a2e1c7dde9262045e26d05c7abbd24004e4c5e08edfc6caa0f906d2f472097900b81708531760719471f1170baa83e9908cfb46fd393b641ea7694cf9eb19ef0fd36acdaefaeac4e0eb79b81f47ac4b8f46b192adedebf0edda8902cb2e832223e777436e490fa511d6cc436a24c64f51c8b303c8f616efd5cac9a1eea4e10a3ce741dedebdedd4d6c6858d3c0c1c1b3358a17ae52b64f53a24e5ae8965ff8f5237f287b3b0beb9f35b2df33bcc0da10e2b44c1a136e379032abbf17172f762e62b2e3fef043a1edc7fce77e1ed2e8e2f982fea8a839514727b9d03336e779be2489b318993d486ea61be8e6281d3f4771fdf12c9e59e30e4231034aff7289a656d41092cf1b26e801c74da78d87a7b063748709f62ac67b02be2220bc8023e6ddaddf1a1069b40594c438a4922b0671b19056cda5d9c3bf398147be8bfdbffebad40b893fe74e95b6d5be6e537b77fafc019b0eb2d0c25b94edeaea2da8fc53e1d6d60b02717206580662f06e8537c7c966a55a589bbf282a3812a0ebaf40be0b9e9197e8fbd6175a15ee66f4fb5ebb908ceb32b2814283e0cef32a05a357549127b873318db1024155d6f2a512fff07c0d101d4d0f2e41ecce66535d7a337eb40e300409f8b179ac21ad3368019458489aab637451a583cf07ee4fa22957b4046ab59194a9fcb64a734861ca96dfde6964027c8b78f3e2182aca2f576ef215e72cb09ae6fa6cc4a6ac5524f57dcd1ecacb040929c36df9ca52e8a97ef9bc997805f7977fc245419bb9c7bfc9d3aa96fac3942a8894f5db7191f744617afb0965102719f0e109ffe9711c94c6dab45ec87bb255914f50593b0578aa6be47c5b52bcf460d25ce1fe1fbabd6694c68d4d8ff60b20ee2db327914a4888718d76325513f85cef207dc8b8e2d0c34d9b5d193861ac9bf746752714cb9cdc3fd7f21187d30735dde9e62ca5fd14ebd551b62a68a306084b59cc2f5dc0850f0e541ee045989c7d4d55b0cd83a218518cfa7b323853b3123ba514ea459eb1777d9ac0a51da4f086daf0e6284cea7f784f2eeba2590b8639a8073597f8ef829fa2c2cfb5f04eb067b5f9cabab6f4c7cfb470338abe1b006083041da73f4c848640840365e003d397019bac6227b16ee7e0753fd3a4588ec07660d07965a5fa3c8e22677c98c156bbb7beb2fce58e4f88daea71e8e0c2dc9b9b7bb0ab6a52472de911a6ebdd236461291c25517f205c464e20200cae60820a152f583fda05c99a77afd5732904ccee7c7e602d9047c439e35846deda82dba1ef235321a5989daf456f15101f10cf6d8dd6d608bee7586147c4bbbdb0816eed19f155e9d139f27098573645a746bee9f19448c7241259f34161b72f3ea772652f3ccce0ebbb4c95159ed724903b5ee6098e0a366b3bdf2fdd3adf7a6998310b5e216ced548f492a3d1f9b2797459d3ccba4c1a162cf6c264cfcdb9545469c805522c2d1b11397e6929e944b8eccfa881afa55d0f486dc0aa03d0a7be2fbcbcf47eb1e4e61f12f99361c1ddd433aa495ec2aad47de80b3efc37122be1bb3c0c75defb2864c3746ea3e792394bf39b6eee00dbe77bbe96f4b9286e9f977db06c858350b9877b04d270bdcac99813bc98751def7a93ccde4b1e95cc7155ecb9acd14d32bb1155320b9e10a28f4ccac443eae371f9d661485cb33180cffc8b399a772804496e674bc04b831b9e0a59ee0e4f60d89b05a0b09ae436388bc143917a77339f3477bcab3eeadc7914ed2a27a5094ebb91284ef51d362ad22c2159e93c78527b3620142f9e01b3c78f3025c236091d290e0172c03e5e0e105dcd34b9c314b812bc95a1b80842875e94596c566a2b22a0d86a907804ac4e3e44e34e60eb6e53f1b0e623d0910f7fe237cbf8bd1008362127e16bfde4ccd873e268972a2bce944cc3ce58a0d03651bbd468e3ec37487562531bb76952fc12684b53e8ec4cd4de5ca08a2e603a5f56147aef2fdf25716092e362e6cc9e51bd90102c0aa0c1e719d5312982d9e5f1c21a38327b1545bae1357aa079c84bbe384c164a22f980fef48a75d57bae409893c36d0705e19b4a877cbfbd03248fe56d27cfc1dc66727f7a18ed3d08dd735ad06b4d791d92d3a39d602259303d491cd29fe050736c956591719933614443d025a0beed7855b4da108b21843bff605e9ff224c88d9eeb6f0d8062549b139e7487280ff8798563a74220f2c5387eedc35101055286dfa37d706450fb216571e2ee0da3b145e23d1de09b1c5dcb8c6d9b70cfc86f072ee6e535475799420aa706dfe6ad0489267897c8d5eaaede5def888d3d3cfb55a6991dabff3753d0c4d70b65e06e0cb627054c92eb088de0ba88677ebf9b2099c3895f85dd68bf6438e63e2a475179c979a9b3d008fda18da92846de7f0a0de1223a526747fdc5fafdfa45a470f2e52ef7c32bddb9e98fa6983d0a36e0c5bdfe1d734d5c71de0dd7df225dd57b4bb9edcc86dc744f2e10f12259dfb5a6b1ef7080539da91baea6bca392839b521b871d241a3b813936d878aec04dedfb8bb2bbcc532f494439b5156cea0db6b5e4100793a870c4588187d52f0e6eea8dd57b0582b6e496640f1a2aec2a686b595db1c5cefd6cbc26b04f1b7e58cd5e2d27d5aa79572c1fab1f9465ba8e6350e161f14b86ffd8de7502884365f0e8b82352bb3e187b24f5a8e7ea957b8fdfae999eca6b3b5a5fd07bafa1dca029706c4b14bf3ea7270215329523c144252d8bc5d02afbb277cd77e80ce35a533c3909b812432989d558c1b545e9966ec93ebda0bb76fc9a1e03fa6e51bc9ea9e815135ee73f83e341fb64b2be49ac32eb53216a0d9e5fb6cf1bbb5ae7b86431f5866754e154137137d702ebb4d52cb22ce69c0fa9e50bbe3492968de6d46be578e6ab37a38f5289a993d8a4aaf799c3e7a7fd7c761f10d7ded670957a0f303f4a3b12e5ed03cb96ac0f5c3e9bcd3b5e34c9faf5468972447065acdffc556e617611dbfadf974e4bd88d532bf071471e17f80c64b9bbb412e66bf73fd22420d542a0c8b67089204df26a5872a8efe273afcbe8373f444be1bb7b241940ca4be71edb5e4b26970d227c4468e81419eba2a663f420f7e99233172911abf49b9d4c57f80cdb5e65aef3471ffb85a7b17aafffc0d1f4b2d40278ea9d84beabda1b5c890f1cf7d7fd8fa8f1028ebd1aee2d2aa4cc01444f76c7d0b0145b184619935e82ca5a292e8ea89ad21f8b1b6f778bc4ade83b3599f5d6a83897fae97be6584e64b0e8c8d22fa93f2b3f3824cb9b7dee80bb383fe3b9bd9b8cbb6115b1936995ddd10baa435f2a9b6a830e9ca62b4e2a5c5dfcc466d9caa91dc9a079895a3f223ba276522264aac1b2fe53a74f7aef78e72b8afaac2b8c80028681eb11d8cde976ec0109a69eaf0cabe3006a74bc48b77f2d9f429ddaf7aa9528517b5352c7017d26863db650d2801669eab088ede2f19fbdeabfe89075f2046f980dce0639c70f972be3a8f5c95746c4dc1917f0a66cd5204fb85912c1a4f40cec2a4ab48e415e6dd94075e52f9a8cc49fecefdfd91247fddfd6f9669fc633203eab381a3600aa17ce352c3d3f1ff14977aefaee8fa503c0882ea85797d5e4fa52e0dc2ef28fb4dc0bf00ca189f45d9da242cfd491575e0bed4eadb6a7da3791c6baf5425a970a461338b78269074c470a0ee2ec2b9c3590c39f38d1cf9c5bd8c64cfe688662220bdbbce8710f48cf15af191d9b5366daa45d28ce824d183f36f0a71fa3af4ba87073b980f1912b3aa79466dee90e717e54143d4d32029a3a6ed89bccc61e164862725a4117bc033122cd7a706c3c8b5235a7b3b74044ba994b2fb2c1ab93d2b2e66777737ee8862a0b6a85413e71d0d5c0fa3a9a9a5b1c3e0c9c39f1dcca54ced83c0ca0b0fe091125eef536f9e590c2d8f8096690bef00977bb05d585f0e6c6395345e3fa06711a1a95e21ea640e722a07d9bab7b3eb8c856b9076961e02e6a2b80121994b583a3842ca88e2dfc88fbd32d50423e5eacf159545e141733571df0e3c0e9f370274de6327773192c98d56b18f9437dedfaaf08d8923edf79977525a82249a512fe495e0bda3d10487312bd13e437736160e2a76af6ed4fa8a85ba02879255d73120250e45b9fc7a7d800a9fcb81a2dcb6b01f39eae2d2d38f05e5da76e25b8343cd3661408f1c3f8303dddf828ac551167ce5ac42716f6a4e595047717d12aa1ccd42d9ca3e0daff20789a66dcff3977c1f91454ed242a3b7bb6d86a5906977148b47d4480874d4e19c4652dfdd49535e8a3329242b36d3a4b1275c85bc88249e8b0a4a83fff90d549183550d14c47e1b32b5ffc6350c96b606bf41f419889c9aba4733d319c6bf581053b66e4fba37fa5c7f4a867f87ee1f6866bf865f02f38c50096fb63e15ca880807b892edecc379aa24fe476fbdfabbe96f828e54b8d9d2d30b71aa8aaf4c4949422891ec8c4ed548b6bdd04ac02f5345187c00fba66653d3dad3a1eb9b81c757de46c3c452027f8cad669ea7b847e2cfba0408d1551b84ed0b8f73b84e031729e65affecbd0266c4bf4a78c10644183d644a1a6cf3e5e47621d764ca364d6264818305ad3db4630e9abdb657e798216951dc93c45cda3bce5c8d3001681c597da8425c7c7c810aea04b90d3b0382985b6220581ed583151a297beeaf75c84631cf046bbb4cb8ab0c6f8da3b243226f9f684f2e800d88665b2b4ffb1f25281192c0dc5d1a61c340284504eb9eea928d64ce1e46d20132e95da62b894cc3c8a3fbfd11b72279b615c68bba95f1c98ce26125527f15d6ecec984dc115d2ee4108f47bb743cee5b4e543c146529a74279c9dc63097d5146a4c5aa96f5b91bd98b1454fc95dfdf1974c4f3c6454fef615638a00116961e01951a9a20b9c28540f9af6910b027bc70c333a82d12be98884312191604c6a174a26a7853a95bcc30069c29e6d271d4f1d1877b851490120a3db633b7e8a31c0a94a4ee3be5a7ab699646f26fa86e4f2ee4487c797d431930f35f2eb0acad1fdc939bb14410e07c6b1f9a9d93abffead03accfc3968d0d492fb25c2a00b1bad70c59434454c364c322d2167d9b2aaa51b3ca397073ab647731a83445c57cefb74b171d22c6ccf51e4dc9c0dd6e24a591e641c77abdf902ad58c9e2991727d20b38b56a2b530958027c8226edcb3ad118df018b079d57bb87b2b74fa7e9ba0c9e6bbd54f2a6c20b79b64cae47d528ccbfb34af3d1ca5d8ba26095c6566c09039fe40ccc717c3044ffee62ae2768316d9252d4e95831227a0d48010b8e3ec5789fb5c922e8acd9e777e68751e0836556e835ff0278aae1189b61c79791cf30eb758ada1fca144f66d62c7160d1231052743743305fd90ed3e2fd7f3fbdf659248ce145a795adf86982be5b2e4a8ba4ff8009ba691543ca92ef653652e13ec370b6697e4245bc64c82cfcf3364cf74331d0d25964fa3b7ac3765d005ebe61fa03767e646b930dde263b36151a1593f9270d511cf389d2ea70d686f89014899b60c824d487c661ee097fb4bf26be39592f8283aafd1b1ab7efa895577a06efcfb1bad3c4abfa8ee75bf7c5401eef1a88af034a56cd966dc855671b34a654f7707d886ac456074a28aed80c07e1c203b46d28e08de27bfac75f6f9f1b6a42ad292f32b999cc1bfa9bab68a519e2a561fdb54242ac23a298de410f8952ab978436e8c2586b6cd555d5d011b57a1d42d7e01814175277cfb611c1c4c523206703a10a78b782671aff9f16c158aa9c03806c178375d3c4dc94def67006314da7c0a87874e447878af0c3927ba5bda76a356478ee683d7922a2509d5caeb7ae1f9767a49036854297e9117ac8899eee07c57f4999297f28f309b3fc4a9730170d86246aa5ffdd94899df9af11c86ac49a0c6dd1aace975f8710fb7743701a19c2d9371a802b7227377236fc4a9835db42b523658451fecf3d79f222e91ef851474dd8e01a37faed657684a7a5cfd5ecc2043b7d61585a7be5ca3e8b093c380f058b525da093ac0d710fba6c98d6af57e96058d450097459c01d02dfb5c5e039e5ff7f17ba45362615c42f3833139640974304e0e936d6a3331a186f30d4e50d1ffcc5c6947ac92464e4f7365312033a53399601bb7ac6a809b4f63fd23baa94a61e68b6ec02b94448d542e16d6a069e80f20954349906311bcea2c58bafc0f7491be6142c11bfa79c777102772ac2b8ee11bbcbef9b580d5f173f0f190b5a8c048a5d738b1d7b45055fb08dacc421fe95261b6a17d6136c1896f4e2121a4db940409e398d6fffbb3b5981d77065e394e5d3e59a6f2807340e0dc1bc97b4d93df16a13ab2a887911c5f3e2f418f8901d03dfafcc016d6b7f9bbcc5c848df366ea896cb73c0989d6b0d01e50bb0ccd834063457872098e98b09cabd38b1e4169f88d30368524d65de407408849aee5eea8f6eca08f9032767cf3390b3d2aee5cad8be4c8d7fddd535a44e9c0b7a6b9fc9d08953de3d5aa5d758c779f4679d7ef65ee66a5537284c87751df83fbd390ab9644cae8b99e9bb22e260e9954561da60209e61325e5bb24f8dd21e6442685c701aabe66bc6d13db0917ea580311e866d5a4ee34cf1f51ed0413b8781dab34e6bfd018026dd9af79eb42514a38c7f87fdd0e7ddb5af641557635470e4ad5fa9da3e47e4b1856dd8bc0eebde59c5eb7d0cef97f21791b5bc37e88961b0280ec4ab41ab9a24de83030fef6ceeb2f584d668a3aefb09818ccbb24401c66ecaa8a68068edc254a9517b1edb12676cd28f3bb3b408b09a4a1aa365ef695b1fdbf3d63d40222e9485fd5b7656f2d10641dff621249b5c2388477b08cd7554454ef311612c2d107f49275a9889494f2efe8e68a48d39e9dbdc45355a879c6d179e3044696f12356fb2e7f01085de9de1684a72d2dea2c3539c817910c2399cbf8f346517f82c18acbc83e7a9eb649f93726bae1d7943fe70d8a5b30821fbaf8536c47a7af0d0aaec738494148fe73c5d5cac614d505c369b40066a985ce8b2bd3f7654be443eddc7e0d2c9844f8631eeddf6bd5a0f50ec737bf42a3310db59d850bb7635e9c4384cff3c3b728add7008f7badbb77660a33cfc2af44acb0a9c33e1bbcf3d001c99d06f1f8ba1c83f4709cf23c63f31573fa107f7364171a9885443c471be584dd6c8bab7312e39b58a2105f78837d1824c27eada15de8a57011b758724d090a76b175760cadf261b3e8bed10140bf83e6d5eb24d6f8e7651ca819b2b5dbbeb649f27b41f8d66c59659dd8c8f1017a9180f3f590b91869fcdcf879ee6145e0d896e01acf6d8351fcce328cd866657482a405cd551df8d68196d6fc5bd60dcb0c6369543ad375db91cfe69c93b35743ea27a5dbeed2a0a0dbd7b38a680b32098b60b351832ac5fc75e09d92ae47f4eddb49ad313c5fdcb58149e97a7d592d4a8d8f509dcbf16b93fcf8584d84b23c4b02c90c68208ed9c624b874d07de384fd1992a4cf723f363c5c41060df327714ca3cc8b85c7a8d9e5b0f587b458cb14d7aa3de964049ef5a4338d133a0e01ea134d3003465d7c71782955d5956e2360c65af59aff9b54b1bc502be5359fc0156a884337e7596ebfd5900150bcb8478e0c87274d6825ad8c6c70ce8209ab26e45f0755ed3f3fb7f85fa50fe8d7a6473c4d5f4d5b8b484c2144025a78ceaeca4bc7104f64a31c3b29153933ff9d31efbe81ed93d070c2cb67290df00a23a3678a326a9d9e955e81d96aaba8a98301d7d15eb3d2bd6ce746f6e50ba6fdaab821c935d474cbc083d69b0948c710047ea4bae4e6cbc502d29747b05ec0377d307d6ba2f7b2ad842f2f875a488887ab258d59b1a483366ed3d62b1002021994279893b4bce1a1571702ba29c6bdd224bcc331917298d1e72b95f76be642ffdc874936ebe2c22bf4b0ba653dea9719ac30a4210a46c3646610b802d5230a11cb9ea2b7ccd56c08d962ae98ec29980c012d5f0fa56f232c0f3a6811bc9a6ecb133718dbb6086214af926fad1938b8dec5f28289bafff97b75371bd34567c2fa362b19488ff097f2179cc0205fbe17fb42c8276e75021d7d10b56b1cb5b3aeef72eb77fd4682f47aaa16d7537fc19ffa72ee5cf7e1dd7b074a9a9bef06a81a028a55fd805b05ca0832495ad3241e78a26b72cad0022ded3f768617d99ec9373d78b0517f5a5647d8cf46daf093a6aa031d385169ba455e6fc3f7a6fb5d438b13b9a23baf4ec5677a25f0c36b7ed66abe764fcb7faf8ceaa7abdc122cc4acc36d2a5ac0f38bb61e7f7f4d9cb853b84615ddd741d2b24ace6c1b02e1fbaaf4e6910ffe00e2b9e276adbcda2a112ede25f1d7792f3c44e22fef3acff64017deba6de40ff83450a7f44bf99575c3a3b60fc77949ffa5bf2963b97b2bc076b5cdf70a753e63e1890a16638f47e79b761824dc1277f83cf621c5862346a321215668c9f0c8c20414fe6bbc1a78aaa132d7203199383412b40ae19b4193801212ea3f8ae20f5ea45521352968bcf3857d6ba2ff1f3a70a5ed5bda49e11c9d7bea4bcd3f7a1e802f1b898fd3a449b8b4985068e5849ddbe3c4618ad741ca19043b6407f9ec42d4463ccec2c8b4f6b6dcbf52c939ad9d820ff685fa1512e4b84135f810ff548d4fa0bbb7a26720ac9a1ab31825d5c5a48e7cbbcbfc40c13faf25a6d2ea0b987a0d7639560abeb6e12ae807935fde90b98802f71cdb35c09e73f595659df9fd097a6bbf2e253fa81cf9fda4cdd3a5ef5dbff31dae6a67baa94279c18784a5dd44d46a0d4197dc50e24c4bbcab1bcda4ab39bae8607cd58962f815fa5450220c8f165ec2ff7b984efd4c5a86a6d5d7168ca748b34d508269c3a2408c73321162616fb58fc2beb1bde4e4720df88b3ce007f4a9fc017011790bd8d847afb21dfc6b5d950b8ea78dd5e541395d135ddcf10660540a5f3cb557463ed5359ad9d731a35dfa41de363c1bab07966f33354a47a6f05d12f95e93f5d6b12c698c3e71a507ec8fc74e72f4fb081a83d6c40f44ab16e04b931780c03ea849670cb4451810b5c685688b2f6a214a07bc01ec93546682b22935e96d03f5f1901dbaef14c89601bf91fd9ad41e446249429ec08c76147aa7625332daf1f2517fa06884de932a555dee21a2719ad81b0cd90701e6f74d3c3099e5f19f31b5f9dc7318606d0a7088b345fa2ccb8c259db900d627e8b63bb795f85bc5e693ddee5094662c4d74ddd8c5afde31d8d44d99ba3138f8eed316e23e06db21a2877d08114ca628500330d78f0fec877473a4dd6ce1f34e1838164275fb4cb22393e028f15e23ef4db6396befa0109ff43f98971eb920134ef2493e6128c9c58db797fc8987517ec2b5447338e286ad4e8962d032f7f69d33db59eaacbe70bf1c783aa4c7b8c4f9fffc86edeef89c1e739608c14965fb52eb1638e846c06259beb2fdb2f71c8fddf45c266f7f3475ecbeca289b218ee57c95e514eddbac0e6201e1c15d48886fdc244ba620fe64a4f7c5f828620f4f33d9784c7690850c46922c62bce37067a6fd4a37215cf613a81a5d9d856c46be9e074c6521e4fe751fb285b411d179a286dd1aa3543b5abd791e216134a8422fcc862ddd873cac6fcf570709a086f800fdc0065e28e81733acfdc0e7ec14e03e30284da1c21272da1a76957e3cf6e188047503cfe8170c52c186efc06c14c694dfcdd80fea37ec009300bdacd39ee136c990bfbdf9a12dd0b1b68ef66c01440c509667e781c55b2495e16da1e31ac7e7dcf3a089f6fb47235e437c1b8d3d5127cbae5328319c8857fb007fd35388da91ab9a80b53a167a6949f6d126fc6a15470d11ecd3675303bc896185a6ffcbf9466024e2e063de5d867238d19c8e621e166013b93766258ecd857c3d747866dfc9c68470b0bbc3fafc9a847326c176d2941b3738b1ca9dc5768d0283b11c426f95f5541d5bb9ceddf8ad88e70fe6c20cd6eaefb02f8929dd7d04bc591cbc96bc5ea8547dc05774a1dcd4fd580245a23fc6952a871e5589fd7aece521d33501c1af7a9633da34dd889dcae195783242caca347e108e09517d5443f0ab7cf64e1f602dc4695cded4722a5ee4bc90de5afd46a6990eed378cf81644aaa9b09d077522b239c6724b909fa6208474c1cf4705b23082c436b4d83388cca0f18e9366bfe33457267216e9495ea1707e480cd2a1df595443a5dc36db1f706ac4f9f8141680b07cb9acf6649c2ebbf8f67d8c87c8bbca655e447f9d0e2588a750bcd469583c3dec1ebb8c3a85de181aab571f624729092d00a919777ce05223b3e8034ab83bcffbfa59bc724a113fa1238a03a6fa20707cf561b1d2f8967081d69e2b02fcc94aca86ac9036c2b5816d2a5c12e1ca59c9a3bab437f07c3a21af54652aa0b3f682621c24a1f3b38c8f03d971d077081c46e2dc2f5891ed2cda6d2731441728631756b5b7904600eaaa58a894116fc1f4fe59687a7a02ae1c77872c7f6f7e269483cfb7ab7febdfe7c1b55928f3f825406c15bf5f288ed1d72603575dd439c3e5e8208e7d18cde385cd8e64978c55a3edd5721c1513b68d0f7b05e3ff160f65bc03fe7981002564a676d91923beb8ffaf7a120f407e02c580c866a224bc433e1a62f28035a6e3c353d732efb9d029dabc6d06f604b394ede9746af36f5d3700e5c50ee6400906b433de5d2f8e5de2d167f55a911e4961a2b765e441f8235a4397fa1b27481424d829b3a319dfefa6364c04d4f9b62a4ebada61b5901c242090a076745f4d440477c43ae124e1280e0fbc958de39c377a3a877aa068696e5958cbf2c3636b5dca5752ce815e6b332d9415cb0ae9832a9dde22599190ddb74653316a2bb748b735dfe69ddc62d911a1072c0c2b6feea011f3c8257f256cde3311393626e3fae8f8caf440a4e3346a8899209a81d9832b6ea73537d5986373451e7c41c2ee0284b1dfe8652df6706a0574375ac32562ea1ff2544cd944705f9fccbe63adbe8a0c7427d3a016809f785dff0519adb4d86442d64e22586f8ca25a973e2b02b45ac56b3722fe6a528b307ae8984bfa98e1f5684b501d892cf4dc094685dccb77f05834a9c402fdf269bd8eee499c4ea7a3960207f30ff3d19a2391071948c7732603cecfd6e5c1550bd361550b8156aa27a88e6fdcd8c813c717d7f3bfddcb1643b2cb8b5cbe8683ba1cd947f09093e5ce12c76a7784b475809ebad28cf8d2f3ddf55d48816deab27a3e4ea63d75c40f3d178ed12dad2995010184f5fbcb76241da975242c41e616f22de42a1076dbc2e3aab3f71ceee90787e23e119db3489224182b6dd320fa1eeff46e9bfceb626752ecd03154e6e6865ffc13b2cbfdd834e73a2012fd76e42c6ba218638ee1afd4593155030133b8f42410ef7ddd168ed98ad501f5e9e285c90c2a87f7ce30635d34d5a6211bd0dd0bb3724a3e5c81de9ebf2171fe71642c58c7cec34e88a8be7af509e1027d8e0f7411f340a8d4b344b3dd10c43fab21b0f90736e26c1872e42e0aeb79899b28afcb018134325d56b574bf7797b9f210b81ab1e3dd98639671b1a14060d4fe8854ff92a3b53d0af0260d943179f5a811a7505fa01d2c192239d91a871844e22ac8125e103ac89c909781376ed90689b4d1f1f87cecd666a73d4e5eafdd8290e5357d571137c75ec348bfaafe22da15f5fb618bf2ba51259fea8f876567c49e5c1cf883d3529b2040a25a6cfa0d7dbd5a1c887eed76789039d75deaaeb02b40d3dbaec6aa2a636ebdac95cc1a8c52771e2da8a078fbf464d3c9bed288e82bf1c12714768731800cc99aa2a2cc43114918ae62873c4ac40e0c7192f85464b20db9158c2729df5c8c690ffb0e3909e6dd24bc6a9907fb1c3d43f6b7acb768476af0033fce83dc8912be1f7acf22c80a80c04f4f17ecc6b3019af88f73b342392158fb525379f8a8a63689fd2fc101ddce37e097269908f45467d5751ac439eb7495de127b927d3b5bfbc38c0b3aff3d19e23599485dded85b4a767cc6d44dc0008dd4005aa7ac552ac9e9fc39c70f5e0026637f25a4fa8e4c499a5df2d0dea5f5670b74244a76115adf75c022a61c89db363dde5adc3036093e0ba28e7502fe5c40f105308033828f37fd767d589e8bcd4b0b0a09ff64ae1b07dc36659032dc3c45bec77ebef72158118fcf0c8e8adc327b1c6cb6bb7c84a099d92144fb9036fcc7c9ff901c06ed30d84b42d8f63eb22a6c44c56a1fe06924b8b5baeaf87f9b3c8e3174345d5a6aee3c3d2a9a45ac6b39fe527409c5c8550918542b10511a6a442802f14740281d2a17f9d944d86ac1752ecda293e12753316e848ba7017644359fad838a3709a456c53379c9d83c31bb95a0df634cdf4cff73c6b754a3a8d6578b654cd81a84850a8c2fba42c45ee3921b5692c02c5d71fa314625c23ac609e60a57727ad2d79e85975b95758ec0afc5189e4d5739662ba40e8f7748edb6d3343380ea5b4095a52007e147e32ddd80e489999b0f747c41abc3af029f63e6a7819ca3eb135c1518540ccffc1e5efa7b3dd7d6d8877430f167c621cd4c0ef41ae9147914238a37d3c6374f2b9d85b8ec1e3010bfd3398779361225e0264661c37826c797802a21d892416e91913e4cb24f2988e5ee5d9a304a2ed8ad03b94a64882e60587ac3da3e74cd0dcca784e02bfb38e30151cfbf1cfcbaa83f1ed0f439c264e10f56e0e3a13e58b859933bf98f4d2ac85679816363489db5f9c64c1207998b6076b901a807588519e0057d7d2cf175ca7ee035d1f227ed3036028ef50df95dfe9a9faf6f0c57bc6c6203c66a4d4f0c4863ea36cb539de368c3c00a81dbb96ad6c7e2514050b99220a4e8969c159f2b070987a778ab03f389b3cfb5f6ea8ef9db64dd3edf4f0b2762911a108f27ae3630a8332c060c9822413e11811967f48f74c31bcb6201c14395809f5333f1314cfdcf498d630ed4534acaf6c006f30ddd98f69045a07dc4f98747f3d6c53d8b8a09dd8b1eab8360d5f9c735ad4f687bbf7ea7d6eb749f97a7ad18ee8ba66cda582e9b49d32952dba89b448340191a3b8d6d060107ad0bdeee63a9880fb48dcdefb9ce03d37813d5cfe395887b1d2a5aebbd58cbe5b478b912d499a18853f84dba58b9014b73f87c2069daa721bc821db1540ae888e4d5d8f215549bef818a82d04b800edc8662116b67531fde5a47a912cf514100dc9832ffb0948bd7c21f4d2dc207951749e1f4677710068600d08d7322ada4c01736ae3c1d3b747f452664012db04bbb756847c25692a29fbbce3aae2a36fb807ab4db90c446a24544fea170e885426d834fc3d821e99f206592d9ddd984216d9c36ac664879f55e8865d28783223034b1e346f0531bbb0d8f9cf3c55641934dbe4dd041b220eceb4c138c4ef97e313f94b87cfb04d9d48b62507696d78aa1803464e474b8b8804f87c0c06705bab2aa313a1bb4d307c235caf3880f871e16e3c69cdcd9d5d7993c9e9d676f36ea505d21c8956b24aba26166ccaf6fe91d89c3a7b6727de957cd127f0183f57b0e70e03d58cba2ebc01e5af5f0b8ebbee6303fe2f6efd210df1fed478a4ebe200975c0c4334159ce699d91542d9bc3881153c4f6354403003c750af79b1b1a1e7308b80c3ba12b99b9ac6cf5451a60fafcfa0b0fa6b7b96b64884aba46953ae6602d7cd380dcb091f7d407802a3f92240f172af4b779e15e47e222b081f93c651ca06cad4941093797288b5db32a8391f5cf2b78952fe9440c335677f70ed8b33d720f99090f5597dc25f52aace03d8fedef21006ed532bf770cb6374b95d336288c8fda5b1be9634b0ea35af3fa9f6acc1e332d88a01fe0864fb41dc760802f3506c83f5918c0af363cad9ceaa8da9840edfba9bdcb3b34832d27e73ca3a2d41b3e69eb3e8b04d60f143d890862a3cb333de6f559ecbb317f0c4559a183d0287e48bcf75f8ef254d0d8eb6504bd7391345237c4ef04f61d5f5cbb9309de1679ef8372f08dc2e68ad485d9298d145b56b0a5793a4b82d32e8e834f3001813beaeabbb0ab870c989e694abd386894a320f37ff00d41875b835ebe54f1e7ad935c383851246a9bd203231d5a5192994a21b79b4eebb1fb0f105545a04d486054d50e47063ee5ac74dc6d110bef4d92cebca81997e1a714d4dd174858963a7d153bb7576c81473527bc21d5bab8b3f80b41d91fba0054268c956f38d798274ef74308949a0b14e116ec3d932f76322c687bff201a5eb76cb1906c00f1bdf1029029606b503e417a36b7b01cd4fe777acf939065531a2028f0c782ad5ff27ab3837af2357369f12ffff93feedc8f1c78082d2c6e62e27282bd954e49c551a14085fb9b76a2771664d684fbd58ac69d63f434c322429d9504e172be5f6f228999bf4124d127da22e176ea3cf9639b443238e2f95ceda490b7e8722ef61fe73547cd80757f5d7d07652fab343802d96fe8ef1fcace0a41cd0f57d384fe5ef3af739a06929be1ae51d8f1644cca14a4276290c8c1fe110df6c4c6cff39a71cb2c5e0e863293870e18b79dc868a094fccd65693605bac2d4b47844ed57510acb2fd843f25334bf5193d54155a152415e61a58d3838c4436bf21e93097f3ce00d11a0bd94c3d2eada0a2dded24213d0c0cffae5df549519b015afcc2879543ac844afbe68b572c5e4ef944dbb226c1b73196e513a618b87e1ada561de1a70dd7b6499749a81d3dcde3837df00d7671347945d65db1680eb8eec3d648741da889912ddc45bdef87c0b1779c303f15e23176c3d780f35170ff70ee6cac069ca25c6cb1c0453a381d336f6b58494568623641a1b56eb134a868395bd944fb90731f13abdd158b179546fa40fdac3c05fb5a5b6e130165ef588e1cb0e0d869cc35235a961bd3ebb6990c752e76a4b01b28548f1439165aafa1671d7471b3b9932063f428ba6a34ec7a17f8f26fbc2e5dde0294fa2397af37b48d805bf1490c03db07a34a2be2d738f2e88d1cdef7b2da16ebf45f337dbdbf1cac1f4ec18f25f38cf2a5899ac178030e324ef9d6ad88c2332d1f640050a604fdf10186f112428e03e1e1df0e267b74559cf9ac5a0c6361aa63a682080fc6af5c553bfd881b8c86cf73c8fe8ec9ec1b0bc2f56da6f30140df331ae6f2f3e88cb3cb572d4e66ce4851a76d470c030780ccd0589d98574d724da873fa2c3e5b62c2de97145a2e5e459cd8721fdc49e9ca0f5cf0be4468d8e336b7acceac30991f528778f1288cae783106863f145d9ef44688b1407deb7cc5f22ee6087d52566c68103c530441adac237954173cd0769c8e598d56e8a673964aac412311d2b5c1d8c4f8eb25e0417523f4fd96d903650d1943472dc805cef7fa3882cd42d84a1994413f0747edf2e4928e141e4e9b481daf35fbcfa8d1cc8ee9667cfc0038a8bc33a34934432bd36a183dd05507c44a5d87fa5d1f75c8abd166698924b40eddc7b7a006203ffee39dc37615c63bcfbce92fe582a9bb032553c02dd7ce28c8456ba7965ff3181ffb49dbedbaddd9c5c68f0dbcb24fcec9d5ff561714f4c4b84e66f324c05afd97a803f38183d8e17c69008d8e5fd17f3d3b62edb3e59ac5aa7295300a66ce8f9c0f6796f3b815495dccb05ca85569214d8dbc999285370b3f72320a247b0467c3e5e820fc55adc7c39fb2b27ad1e6a4f009673e34dc40e1ddbd6a1f58a79a6b7284e331dc6a576b4940ef214e17f8bd8e4c6d5377302181c7a91ad35f629e0710b758d0800e0a9171875bbb83fab80ea1b27e87227f99b32d7bc5ebc97f14968926449058d48c21af23189e9fcfaf6a013b4f705aa481f2ac1435d8b34109c0a4c8c12f780e42176508375bc9fa4125d8e2582e5f5a7e6954d365267dbf7406748b5d893e2bd0b873a16e463c44b417ba7443fb98c7b4aebb9bdb9d08d02c7977705331457eb8b2781f36299e21b8f30765bf22c744bfecea4c44a1377136446737cb9db63f900c3782a3e10e1248b21c626fb30a5758c13840d9af19b32acdb969062b8ee370eca269b560645cdcaac66e4be45425e42624d7c7984b297817d22180a0a6bcc0ca51fe3d3b1ac3dadcc9862c00db04877faf74215aef4aa3e84e49731f4840fbe6cd90a4e80c1965c3765cc20fe2bfe7a4731dbf6480460db89ce8a76d575ff3a937c900a252651bfa297efb5b2cfcfb78b9bbf9e2c2071fa1417673397824d2832d47679584ad45a11aad71bd1579c147f28fa81d91b4a36fb6a81ff8e670494a5d760b093dbcd2eb87fc84895feb89e3b4b6dc3012c4a3f16e38d91a64114b1c07d57ed83cffc611172503dd8147aac35b9b6a7e17cc00c2744076dd77b22a92608e482352d2981e2ccb28d078acb5fb8780b18f33056c994da09a1c22d3290785a95dd233080b010277a06d6f9c3b79741526b5e4e1894a4485563c4012b740e59ee8a5e256b9e4ddc9a467fa59772c416b69f2199f36abca1a76b85d7d966aef5a1bfa959cd1fc0eee8ddedc7c92ae16bdccc34b1d285fd34dcd184dcffb04eede362b5379746b57f03bd5c7dbfce88183e2abda1a0927b006d4c880d41a4f2185d64db91b2f000ae747b496d3f254a84cdbd9f6ab2299da2b9b28bb19d03abf457973f91209b223588ccbf82f0e88e2e20f1ce1841cc0d0c4d9ecd9f3240e4499eb065085000429b34ae2e65e9e7bf3cee04cc56b961ba46edbed3e063dc2e56351d72d980a6854ad8b60859c7d1b5afc6c8fb7eaa51f7cc0b37d8e149e98072e71cf8184e22be8286cb5236ae6be94502d04f02847c67175d16264813a27630d0a799ed1e7c20ebfd668b9ced6c134d5aba544ec6db8917a23be62a99695b932e5a3bf44f1f76155c9992ed01caae347c6b6436134dd0a2b895165774d3340b57e5ed7df6d40b7b0ebd83c9cd502e21285c273d7ec7a71f48732eb9183cc116ab3315e1858e0528fec76ac65591242a514f3c2ce4cfdbebbbc0f70634a633f59799984fbd7860bc854b5938ecfd852feb954eaa0af94a7c9d049d85cc8c85b27e7217488249e968ba87011c5af51ea9a4b4760fe09df55ec338cd11df6e361195558a8926360f8e2325427fa5c03ed38fced7eaf82b125a7519b914c877dfa70cad16d208f1c5ba5a89c826cf749409b53276fa1c987de3fddb8cb8f322d4f70fef6146a5874a9ed588c3abe5543a116726feebe25b295a69a4eb04ff5ebb757262886447d2e49d66d08636cbdef184c143d24307d95bc01d7cd01ad74da9f33ffb533d8aa2d87323651c5e0a5311437b55931e2693afaf6e6abe9a5a003962b60c01aff63f9650f646ea27e3b9daf9bb0db6bba545b1b13928bbf8529091f1a0f3213e64c31e09362da8d52de459a7ce249958fd12be4c15479722509fc49bb15fd253949068786fa7acfc39db0b57137b95af4fa37c12c3ca119aadf99229fc1e732c30f6a561feb060d292ec647501f2b29124bcbde52e58496bd0272a129d034567071de355d5cc804077bf1ba041ab3bbb124f3adf470bc87d818dd6883801428cad534d2f0cf52c8d830ec3816cf455d8e42ff5073b169b50c95b75384b04237a0cc2ddc584a2a04cfd5866f80dc3c126f71a8fa0de4893a349b66a668183a7e4b89d3e572257516c916f7303548a0fc9a080d9c6fd4bb81615178fae08727b3b05ba0cb179ab07398634c16eec5d6751e6a2775cb38ef7d461abdd2e3763be813ac4becdf8035df23dc91941029b99d5457f6c676d48369308f5672b6d5dc54d41745ad6496b89b897b366e3f6b9106c1c83b50fbead5aa9272b1e0a3ce84d8e82d897f6eef5073a1acfc0dc89a80623b263e58a081ef305c4c5042ab1a4465920c3aaf59644128205cf2799194c273829ace429f4493a019ae0901aac606794ef2f818848bced3ce24368c8f674346ee64c6c5f46c4e0183998c6759b1ac25229b6294769163351a0dc73011284f0b313f37b67fec5ec96b4166ddca385d6498e3f8498e14929f328c0db47d20f4096db5ac5677c684c77b5d131ee9a191b3f70ddac3518ea65f55013b85d0c317586714f5a08f924b0b7d5579e2b4bbe3bf99c15d7cef08e5522df3ac76f22a227adc02ca11e3de80b918103cba7c6806be06a6a80ea4aa1f0f51ebb188916e3cf27973baaffcc0a529a46b6d7239b4040f988826bfd842cbe2796db737a905a073a6475d55ea65adaed120502dc6128b3d44a75954ae28330b8a1a720695c098198fe3e7d902566b01f45b4e4db0d502135241c1e94b8f7d69c13aae6f9849de6ec9ec45f53d13c6564bd5ff73492bef1c8aac408359400c2e67b305a266761c652e817cb3720b9ec3616060f22458c5eab0eb628249c3d3980a5a7bd7decaba6a30fc2660ebf5e22fb69b9f1a752b8d8b5542f4375f6e994bf63998d575737008059f81d013307710a625e9cca9c55067631053c05840e49336bcb85506b906797e4bb87e2753e988a07a61db70bab0eedd9a48239e5d3120c3364931162c54ae9ec5b56765aab76a1a3897d6a5e18888acee7b0876bf5a2ec5b583fc48e2b29be160fc4884d2a56f87c93f27afb3aa0e79660c0760171e9f125187ffc2496329fa517391b12c72b70e48be45a9737bfda09d6aaa76a6eb1f5f092f7ed9d36bb1e8d9ec5d12ad878dbd20e86aeeeaaa9fd56ece9c4eb3ffe1497a1451c6b4315b64a991f6689f10ceed546f6e3ca7ef07744e3a29fc934de054bd1b31d8bc4c0e31cf86eca57d57bb50153e1e19538c4537284336cf87a8ecdf1f5c577ed1573fbc081e026b829071f43fafb5840398849fea46ee6d123f51b0a28149f70f84d739c84dec61ae26645cb6dc249da1849e94f5994bb833154f49029893ef22d267fc01d526b65ba56fa6193d7f1ba8ac0cef299cbf8ca26474f778832f1e742c2754fcfc76fe5f116ef3d6917151ca8e75af00a5fc878004d169a90126559c3bbd8159a08f3f0d1e6fd4ce56936ad940f4fc4dd69dc02321026960e04e5938323b3ba1629776b42e08cb15143597a3169554b356df243c093cfbf3682b1eb73a69c2fed3c2199ab3ae4934225b329121b41c7dbb191eabd99fbe3f37e3893ffc3c8efb61471b868dfb18f7de28893e21c8964fa7152bdcd0cd15866c420df4c00c3712dd8a642f0cf7849b5d92048b60f3ec29656fc9a63668bc16e36bb86d1a6fb32c89cbd0581aa38c55ae215ce1e9d93fc8f1c9fb3afc81af83bcbb39caab22e686c9384c02f6be1af951391fddc07fc2c1d5b6f73f3d61231b7415a2a59b8ccb9ac98df2b06db3875e47152905cea1403d44c7bf085f6b6d1b2dac1f6bdf8cfd0c905f2f2e44abcc5ec37f67a9a5ba9215547b8b69854eb3eefc6caebc448115fdd68f8b806a32a62ac3f68b4eb69419bca1f402fb4824e31d8b07f82622f6a7d1c3b288ef5834f3c8ce25f8345265df1e8ecfc93173992cd9689a10e6fa136badc2a3d2c055262474ed5dd3959164659e7cc89fea1ffe309e0ff91cffd01c2dfa4d8bf8161a3a2b7c2518266799a1c4091709616476aadc142d0146c6be12828896d9a85ba2372e1a40da3a8aad027f315e4b493af034c68d9c8c07147b6ad8e132aee897188855b727c8f8cb6b60808df24c52318a587121f65cbeb4c9b9cc73f9d088d46b45de0dac563b235fe6661030c37e375525fa10a1680b7db54d04753322813e6f4e23d1c839083e758b93ffb46f85ef7665ba5174af5d27ad545f83faab833172b631d07589c0595075e173dcdd44c6cc8d6aa2db87911ad8bb441623c96bdf342dd21df876d32d5e125e814a79f054ce2db0a6ea58794fef8b738e14f161e1390d4d12fc6716c90a768003d723fc5c61e00864b9c0871949de6a7f997ac8789f3cbbb589ce22aa0e6f01d37049a43cc63be559997af5307c3c9cc655cdd614cf56308a0083cc29b910b8702585bc95b17a2b97cb5b5883fa634d08cf9111508210e92cb9bb950a71722a0cc06d8d2741e8a0ec8f6b7249835081d442020ff262f15838dede00f891e5963f446229f9b2cc10cb768e223503639daa59f13620b96370ad2c1d227c744856b946b3be234b5d78b6c63d0a4c5f6664e579b7d54c02453aeef161eebf356304a0454190cba531aa3b09be2d66945cab8c51782418623d3af52af205319e47009a4a52b19d52a99edd3dbbff1bc3c4e5c36663d1d49b7539387acc4fa625a892aa3a76e0d674e1e54f1108cfea5a12c5ddf571e3ab11d8d909694e5ba3ac83dc2b583e75feab5c7e81977ab9c0a77b2648db4bd60db831cd28564552e669522fb9ce59e60a1d161f968d5e2ce446860751779c46ae6c700278c157f5c373c97f39b186ae72e6c248b411ee8a0b69df323cf958e59bf45e71c45b2516cf7cff077cf8e4b10e613398b70ebcf7bb978d086bcd67a56f16e803afabc536ff48b85","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
