<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6dacdf14cfd103d208205db9fb5b5f8b71073c5294570080577f98be2123a4eda84e3b13fe926d7aa43aff431d617fad640e501520a82bd9c6d68538ea06c35b289b16f80ec1cb3707f919b67e74adcc051c4a1cc967c80f06ada5a734d9eced07f891d9c3dd63d42e0965ca417af4d0d0be74e65e9537ff13c5dde86275bf70605f0da55a387f9c8b511b491bced9a5010bb4207b3ef2be4e0f930e0de9abf57b2e6bdedae90463f140bf0229d5519a5f074a8cab474696c689e02a4930de507942c75932eab7f9c98773079ceb445c48c2b32d7d5acbf7647e990934da8a807436d0e367d1eb85e838a7608f8f544453bede56ed82e664aaaf80c551af28d882fafbd09ec54c5ab1e68f9b3d807faded07f571d7783f5b67671e61c45c983fb7d884840ce65e4c623ad09c27ac4c13be021884c710042860cecca57f6d9e11147c362dfc420c22f847a0adf04bff327f014f93501d34ff1fbf61e38a04ca57e800a98156724fc15757e1c5c1d7a82e9db22ac7182599c4f1a7e267b228e437cf5aed1f8da8e14f1c4e1084a72d1859e57e0899f2ccfc4dfe3b03f6e3e96371c71bbf3c72df2433ccc88c30d13c4c193db70d029ea2c723a5bdba423ef6f69be3571a00201fe07c91c0b1fb5bc02bd17376a947728d843dfaa4af00be0347609426a11a36186e32032cdf341c5bf6abf1fe152ac295069b8bf48bc21dce1c8dcdf51921dda70ffe04f8134b584d97bc06202b0ea4dac4582efe08a1e2f44c9bc4f7c926bee4fcb6992201a5da5a725a5196352884b656f6e86837e01053adbebd593d3719411ee4fdcf8bbf9404a133dcf219806df4b7958b492547a7b2693a3853f60efa6ba06f1910f49c7446059f4b78968bbd8913af3f2aac8ab0cd80c6826fe7a57eafe95c39429c20104f2647fd0c5f09b1e6c10843affac14cc9588cd827264217a981cb671a6ad986545fda9819ce031af763497fd744d5ea23ad32f8cfdaee40d6108957eef75aa9b4c6d7a93a167a07129e9b04731df26c84913ba24b356f11d484bb234fa5658fc565856c13ea5e24da9e0d2e2b965a2dc3ae748bd2e1f22742b74f0839a86e8923a52e284088e9ddd5b084bac52ddc5ed44926db798ad38505b62852ee9dc91d95988be9e287de7469ae32ef65e025ec07cc8e89ad6a321d2dede5db2b8c2590e807730fcdc5041d924ed7efc8ae15ae896585d2b0c60a125a4ed7407e0725c675a7f1142589bb74a1701ac3d1d9903c8d1786d8b4000aeee8368d6cef9170ca6856836d53ea1aab7c8a13c638e4dc613d7f33a22bd3c07ee3e709e2129d27166872e09c1770637dc2ca8083b6a2a1bec8ea8e2a5ac86a40142510288b41cd4e1d67d4c2760ff672508415aae4c638705ad2b81085dd0dcaec62102bcf14f7cc34789e4939126c8cde4624ce193a4e7914a615d6e17cd7a0806389addb4ef4e8290db94ebdef501dd4ae0bde8e48b2a5083a90449af2d12643b8eead53d419d416afd608a09f6e741ef785f9b6db8db78ebca4c44c821663f91d032c6046fe6d5c0eda9dbe30d58b79024c2f9b096b5155ba3ad152a5e2915fbedf22453c68e1d7e5c25b75cad94fe8bec9a704084b200d295f46a4c2424f397c4f3a13e0e82cd98c0e38668d5464353c8a7ce1993e0685e00f48095b5f015be967b1404255bac446f68f3bbb05d11b268ebdd3500a57343a8e92070c81050838fcd9000df6850c9a6798a88a8f8744f93d5d5a39f1942d752f44861e8ed97d953a9e7f110dc90540c00d8c0aef313dc99117244746b2965f300007c3db0f8ec8b36d97d51734a251b1b265d4b99f77e3de28470d277344d154f8baa505440c0aa0ba1a6430e41fa49e6a83ea9c12f829502a152a968d820fb28da95aedeb78f0384bc42ede0b68698fa64b860a639012c829a3ba007c5f478022567e4f73d8b655e567305fce485d02d81656c0caef98aa0f3d9db7f98817d6fe80bffa6d0773195341a2b59a0e7e08e00ce7057be275513a99e463ed9af1a4b50deb21f48c0646ed1a917ea4fbe6ca3719e753a9f231c9add1f1cb341c2b8341a3f2486bcdc547a9c06aeabd82c95483c1ab86d1aa08b31fe2e38c9f5c1984ffd828055bc95ca3dfc14ed583382862d57dc3d89e719999c4e30027242cdd026e1fdf4f9ec22390af410c64afdd5b25d646cd9ed4f2a4880f2a68808a8eef63125e02fd08d7f4607ecc5c4578130dd3fdc0de51edc13dceac66da98a36c059d21c02fedb741651a9442ff0ba007dcedeadc783df8a5c9157d3d1f5c99b04736525e3d15cf78f7ea252be4e5673089d62e7239f5c25c9429f9b729de0d54c850dc6f62c1773c9c6371a6c992fa3ab9391518ff20e0dc08f0b3e5471dbb77e5f72a8813e9756d827d5ff27682cc2f00fc8faf030c9de46023380aa55bf3775ef8f4419092f55e9f14734cc0a551bb83efc3b5780b02a5b939b90d6cc7fa6e86366ef8ad124a1c6e5d8d3499fc9bc69140c29efac99f36eb20fde604ca8fc84a58a35d4874bf0ac8a14519be0fae5807fc52b2d70d417aeacbe82bc13a079bb5d08e9997f1d912e40d54967f1ff3f8fe8bd0b033c51ced144354a23272d084a7f72d7fa703c148b3c25706d069167d5b30f2435355d211b8796396969d4196c1d1b7f72651491ebfd6f2cac60b9857dcae2a3083d80404d945c07588da742a2a1755649cbcaa601b7444ae479287c7bc0c6b6866eec28d0ec418e8f9864a478a62509b8e19f26362041b24258762a2c924f3fc4c421f6600fca93dc1182a89f8b3ce28f753635bf2306d02eca5aaa9990c8d69db62ca1e7ffe1b9a473ec828393c1fc567e3481b089f4dd4e901fdac872d912bf77d850d40120e302617a17bfacc537ddf442afde51961a5dcbe2cdff7aa3b7aa3ec7aa444431047c791e808d24090601c2454beb2182a77f2f3e518b9d84e8b5ec472f4496463a783b18472cb8aba1128c33eabaad31699fd0fe34df232b1cadaac0fab854c3a4d4206a8f5ef61b8628f417f7823638393090ea200a51c5222b7bc0a5f0ce46105a190bdc27f87b40e861ec748f3ad28eb75fe2fc7882e6c45d76f94776b9d963177a7c41285498232c13907a6149140e110e446714456fb4bb35de5fee26191cb07f2d6d14ba78647ca70dc04fc01ffb6e45202e2f98167a295ed14acd167cec769e0c5f0f42b8a2ae0d8b9a1ca5cbc7e6df627d638093518e8bbd07b0b8c089c77dcbeb5a38f916b40dc516d3dee39830d22eb2f25cdaeaa57b421a0d644419f26d262d6e72254b0a0ad77a832b2aecb04f0b2f15f9d0bf95df3bbb3fd0dd0b76a2d1b374b2c8a788d23588ec4c0fb150b138cae03bf6977e5d8227cf3c93da39472128406e6bee7233af558e2cfb67676747b28484baed7be7154f590b20a8cdf4b8edecc23a4f696989cf8c692f93f84b6ad01aec782bb2b849e354711c219e22283fe7ccd8ed1a832e83fe078b16a73e01e07c6a27d30cd896dc67a6cb68951ab782cc0456b5626ab9c0db80480d18381daa2c097ae73d6bc966373c5df21bc3d6b3bf3f7c7da0750badba6384843ef4985da209c8d5576cbe1eb41e72cd89774018f91f0ec177a10ada80d7c2ba5f155798f0d2921dd47cebdf951cf5fe49fe7fe93b3c49c90f9766d7de1e3f3eb087bb8647744dbf21b40de09f7f97bdc6f20c997a1ec756ff2784cb11fe4a2a1d0eeb2489d530d8e64f98fb08c7dd4d1a17cb130c72e4700708af90810c750fe0dbcae3bb26529fb3a7fee96e819f88bc0deeb2e3413c951be035c6b6f6f1bb2538b820899d573fe49aa0fc0607bd30f077bb3dae21accacc20afd2d3d4f6fecdf68d1c3ffab2e723f627935f339d62af96e4227e2315c20968652b86c0db4a42550cc6f9029bfd05e317f663997089eeb796bab13e82b3f95fba7ec3f38bd32ae8cf839ce02424e9d004835b3bbf89349069c2d951f915995dad92eae7d5f3b7356f68105301a2810e74acb8eb3ec86c532d977003a97933f72c72ed89244008f1aa0330839b62d4b7d5ec852a71f16b5a377cf1160d6af2f1e3aa517917220e202caecd318883d19434a46dc3cd7ac09e2d515cfa7034b315858be30ea22666fc82a1415e139474ead12238248369c247cae043f4f741a6c205ba854e3d76c73c8ff08285ac8f9af1208a05fc7a195c3199141556adf6c80699a07d823f4f70e497e1f7200c152539cde42af8209fd4cd89c1fdfb7467f7e45481827055def1c47e5931dc02946936aaf3bdb6d3ecc7f29047fc6738c82eba60f4db588668c997a07122dc673df76707806327ee5d07d53d24e2ede3908a0df0c36e182a9085c5517a291d2a68b88b0a73f44f0742565ccfac8a0c1175f910acc5c8c530784e9c08eec0fe36bdd1856c8b1f673f722e68f97d68e03e0a6e0f2e6e8b5452b28466a91fc81abf678aa69e211fa0266bd907018d4f74eda995102990e46a6cb5a1339a5bd727ddcd2eefb73a031be064cf9778220768d17832937ff6a587e3337160109d349503b8215c446fa3cc9dd2091f95867c817e786ec9363f5468a4de4dfc148c29b58079abf461987bc46c8daa340ea8b75a2e6e0ea4723bcfaa891b37b9fc815cc98e9abef52e3a97678830c34126686e9e5d20a13f5207b7a5f8349010d6d7f255fa236032fac829cbed5876ed2f510b230b73f408e44775d3efef35351511a98cdaeeaf547ab19c5a37d3608171d16456701779bc8e88565b946708437f72a348b0f6e5181e2a0c38def763f3893c69e1a426f77fedc18daf920addd87ec20c5d45272ef01cdea51c1afd6a4fe8588abac0c8762f00c807a31977cd9339540944bff197a412bfe3b3a45142127f76a44aff518cc007f7ced3aa67dfe441d2f7426550462ffa8bcad5d7dd30ff445da9d0d1b8ce7b8053c1b4b815b02d1dc014e107f7dbb1e1bfa6b3d7e3def3683704aa247e525f8d7ed50306613ce460eb0e621d5b39aa2501abfd33ebf5bf3dfc76a8dc84878bd52330ee974eb0cffcd572211b05413e08f9c48a7b82715987cacc7768c99e628a46bb4116003782709ebf8b7b2ac86649d0f7a89d5528889def73501338e7ea05b8ec49023398dd167f7ca491d4ece93b26bbe191d00f02d66737844dc98627c68ce9549cfd3769105ef0925581a27309575563d612cd74ca6675a2b0660bcdb21f74a9343588a6c0457c6ffd3b66b56c1a83dab078469dd977bd4c30cb33658e1479f9ff76b2076fd75c6192310cc9520094d8d57173d698cf11ed9961379275ebdd9ca3b9869d77e21505e71822c648997cc6e1379ce39d0e6a56b66904a4db35f9b4804b13fbd1333c57354e2f9058030f4256edd9f40cccc44e8f38d034984a09e21ccf2a361d0dafe792492bc132904c31390ac7de5d6de3897324faec3d33aa4e885a9d37e79b7ed54e41aed6b6a6a52183ba61c9b525ecb3615cfcc491fc8a04e0c052ae296161c2b709f4895e1aee2325143937569e163dc1333f8d7d326b752ba90abf6d716a9452773394ccce71ffa3709e39abe9908891735156254ab912e59b2dd7420a136a384cf1ac499fa11a165a4064cce8260ab65481c1598317ea00cc7d07dcfe0b05a3dcf20d01f2f9bda25f3f382f4b9bb3541c32bca1bde100002bfa1fd6ee130826eb1cd544e672864411ac871e315bafe1825574cf9a6154bdfd09e1ac0ce4c8d7643e1376f5e72cb2c509b5f9b738799d3d0d5b5855a7dd22eb47e3e86c6dcf27eb1c6a627db552c29246f8ebcb59d16a924028f86c406251c79a0ba20f538a2ae8118bfa09c5e3caea9fbeb557b35861067be9d5fd2913e39b97252070b7c1499c8a1076da4859c2b33a163ebd6e9c731648aaa854aaa0dcdf3aa827ef02fd88660fe501db7a4d418cf5f026fc63477e37040d4ac9e6dc22b40fdee696f633aa9066a2502ad2ad5742bcd3f70d887d06eaf4940b262fffb58072a7a661c6801507a12a6fe11df2599555b4f4a3d79708dfb9ca295b344222ea628a4e3f6c50340c2fbad9c96c7f181293eb7b33274291bbb824c5ebab050e1aec16225d72051e698901283e77f416db0436282cd2c818dd65e76bf11bf0cdb9b37cc76c2bf95a4167815fa113e8fa04931568b9e0e72466d1e401c9a9422913b1f7ca86a3b5b025fa4a4b22f544f5d614a37c7e473f6f2275b758364f1cae312a4fe1daefa41da07536f9b2eebde6e203652f5342ac1fb14ed82f2effc75130eb7a31be920f3afcfa452a3b254d3542f2ac5848a0e1111a5afd7b0ab547e16805a443898b016417350892f5d71e24c6c5cb1e3ac3d1fa3cf4c47293bc49c06b80c18f0fffd31eff56a43635f43857aa3e02e3556ac36efe614ccf165a08a2570020a8b37e4de9c5992f92eb0be959b40975a984df64e09b7d4bb7ddb97242deefbd1d54b2f75ed84f7df77d49bf2799c6286b268fd92025585b46e8bd2acfd7461b2fdcb7e29b071605d42206d93231dd39f9dbeb4e6d63ebc7d696e8d1998a827d6138d52b90dc0f4aedc4f515b9df6c8bd8730ccbbc9e6a37dd89a5da26ad795f5aca9d4dd10207d3f33eea9e4db75e7234ce09812e59803d7f90df5f6c29875b5cf1cc3c709b9553c24b9a34f5d286cdc1d188a1d591eb105d4543b1a589b0ec51de821701b7e333d3a80a11cfc21537adadf2831e11efeb1b156917ee4cff9326cff46014d195953e15828cf5677f562421d7b5a36fc351e5a804440bdc26a3d036f46e8982d6c6a5b425dc0d57bf4e0a7c27c3ff44ce00284f843aeb3a8b43237617e4e56c512b7fe3b3bc834a4d7ba3181cbd1b017c3bbd3691283154f12a4ede579b8608d2c2312ced6a4d5da5e41032fa670d5e60acc47df4028e2dec892754fcfb0ef422473718ea4d071a617492fe8ce3cc7e61a1cd75fb3b39a257ba3cbe6483f2d46bc0745c61c5e1f4e50f754dd0e64f690d90574ed9cd0160f8fce5f830ec6f9a4df5f9ff2f735a21bb29501af5b7b4852bd61ce744f41581706f41f4b83164eb1ccbee545b20b61143edf4ca7626083a698961564bb55f3457b7c3236b9ca810b1ea3929e1fd829db42bce4019ca8e509d50416b3cc0b3c173a8439e063c2381442f507f090a8f3569e4a6bc9827def75de72d5067668ec2d4f2b1d8dacce4b16cb5d55f81bd08c4a52f4b66196573f1714f87f6bc6f080bb07016dd8e62f1de829cba0972d4e4689e71e458e521131088c9518c95491f17d17ca4c46643d89c05753a0d1676d4c73c3ad944995b986c987ab6f87a1fdcb1b9d48e1204d69f68547a1e98f0aa98c28f731f99a36cd3d5fedbaadf93ceaa341a278010d845d1824e075f94de23a0e4deb415366d1a28280e1209b28f5a6f6b59a5e39f276f0be2b0b4fb1c8c2f4bbc4fe93157b130d6c0653b99f92c2fd2d11e9408052c56c30b6c7a0f99ac3d4cb895187206b7f04be38d6268f5e8c8c29575e876d96a59543df4262e1539008f389ae08e820316bed9274b69d861ad310747de39302689055ee78a588f3d2c98454ac165f26aaa0a7c2227fae02b7a63c9eebd14ec7404d5cdf0c6c84908ff52761afce72b7614639388e03f94f6cb60c10593d28a38a28e539d352988917ad983239c53e51d87a50e3c0d2fe475d57df94a18ceb1077bb5346661b1600417034a3bd05f407bca2e0561e9a9e057f8c2602bb51d03cd24fdac303d5b75508888743bc1beb461ef99e4ae2ac0d38b58bf3cdc45388a51927dd794ac8a3f827a07675e107c1ff4bd87cd7ae012dcba8c49fd86a874cde6befd63e3fb2a4f2962aea3f02dd736611ce77eaf569abd95354f68ba575645f62aa9852afe8c03d4f84f1163e80158f4a208ee303c5bd30c49027b0d7511036607b2e686fc698cdf140b597cb07517ca71fe4a97dd6ad5b73ac08375bc0012b95ec14a85109e3514317f497d0a5d347003485fbee9b40481b3f1d5438e873cb450aeeac2529b8e4496acf0e7cb07d661e77673fbc173d0f747acc4a68c9b900b78a73117159730c77443aeec2ba4f61d32d12a9e7f3f0ce6e19389f09a70f6d52a701eff5b535bd03e4a0967a56503945ebcfe96274dfd0474c8e893c7c1b1ca866c9933c0cd6fe76c0721463c9a9d34156bdb0715bb0287336dc0123a9cf7d157b70a97ac22a8812690116c26583d4661e5abd8de9c9d16d1da1a6fb443fdc3d77decc654f179454dd2264ae8c9274ae256ef006435339615ac92f3be996d4ed107d17be29d70ce7db89d64dac90b508012bc4f711ef731e3b576ebbe814814e410734d59ce0e6412abacab33727b1b60a9e973c8be5634efb5c77f892ac3aad9813057cbc4f24ff196a36c64abc15a11fd5c98d8baa4e3d78ccb8802b149a8738ebc456d9dc9dd9b09d398c4fccc25bfca95e2a4b71db6450552995fc580f3b71bce400d5bb075df810ad2ecd5821ea4cccf7f04ba247df2763b951f2fdf66121724ca150c59ccd0f869ed4fb5598f198428521b24ba5b57662cf8b8440da58d74779780f352d0f3aac94f423e2a754a3cb3bfa15d3f11b79f2a8d670007b966b98fda2d393bf97516f854b85677899c7155a5204cf451e14e1d69cfaf4b1c89bf881bfcb1b279a9f66cb4d65c501d3e9d16741fe360d144ee81ba43c55a3d04e7938efb37fc1de8ebdb59421ee523cea7b7c0bfe239ddd70cda35a0fc75cc08236fffd71ded2704269ace9b66d2692598cd67c58470dc6be9653d8bfdb1b339c197ff11328d050a2ad0724473687733f593f6413691d976c67bdc6dab0395519c9498baf3df527b217c3711b8bb33e1e96c74777697e4e79d91da82c5e738291d2a12916a94a2be6e4d1fb3000ff0368ee0d64e8d787330fe59a08fed25ca9368b86641d0e5a9ead4e2a24abd0e0086538ce48431ebbbbc6e0a06e2801263e1a514025ced1a5f116e0c85419b0cb4562d3b5bf8276979770068585ee4734906c842555264badba25b13d3b6eddf2cab2ba016868331a1781716962f82435eb631b59e8febe66656a44436aad8675c0ca2b2eb63d0df0802af150255b76e9f68e4d8cd7ed32275f96e813613e875b9f8e01faef6e0b450266fae13b4ec85108ddc6434088da23dbc6af3b228ce8a160af0f707e081a75437a00a5c3d15b224c02646d313fefb973ef1f73f2e97e174cf8cc584fb3313d3b2757aafb5c7b46decf205682f71cb702e6c9d02810bc8a0fb87a19ca94fd53f138955ae28e75bea5c2102a70ea1dae06ed1cd95c7352ade0e45038c3b1f1962301b704729d57b4ed47cfa860d40815935941a5fc404ca4ddac7f90428926d0dd427afcf2b57bbc3ba1138320f7fde55c132a9d51a552d193438879b31b4d57c2afc2bf62353d252e4bfdb59a1200a5eb3a2db2360a75ceeee7b6a983ce39a71a5f03366a1c140dc552ea286744d1ecec09ff401a2c0f83c33bfd3f8f027494e10e33fd8e87ec06f8ccce435233d8fe5fa28e76512df9f2cdee8577e557f41e44ee4d25f551b65f80227531b28dd99c0919f555250816267695b924c9afbf723eeaeab1b0daa9fc721bd806635e9407150bec72941a13d3cc134fa27281d67e967b4f8ebdaa230d078f9b5a54c7b3fd9b9cf4de61dc6ac6d7eabe245106b44c7e0373733d0a3d36938d4ebb55d4d144b9ad9ead30171ddc2ae9cdc0bb0949ab88b39d6e9a395c0d7c3dde81d9d4c7713bae0961c26418650aa2c4104a6f105b7b582660b1e5422742f96f5853c68b21ac9ae0d2d8c62e79b48b1404e53341c15bac97ae25ba602b727600f77b1a9d9f7912b1ffa3d741c74e07ea9cdc610bad4319ab9032a5f0690543b91a8af5d2044ea929c667c4fe3f01673b3e56d09684ea51435e662190184ee99ed10cd5c0d716064d196f920ac237cb9651362fd0d74041aabea503a2f3f4c257f10f7323e413957869978cb9506b2eb5d0e034d4740042035bffc60e0123f92b830aeb00567f102eacd7267d44121ccc558f1cba2e5e8645c5d6105446427867215d82787aae73fb3e50cd40fd03edbde8036f709a9797e6a6cb501b57b9c1eadde3505cb6f8c4faeff559e786f80b3f690c8bb07baf4afb5a82e8c8f6ba56838a59352aed8cf134cae230e0ea6a4667a783dc86ca576095d4843a349c84a88b200ca4edb5e95779558471e75294f19047781c0697173e104e96b3a9eb8f9354e8760e3a8e6f4da4d464bd54d0c8132763f2bcd3b20131f6850ee81a3880af33bb15ca792354ca61de22d50ddd44c577bb7bd41110f8851fd449b200bd0319635f0b8a0778a3caa25f3a519d815c92c2bac180ce79485fca87bdf5de2eb48cf24d269e6e5fd7025ae8ffa8d24a444dab2310d8ac56623674507f6cd3a24149b9b51187bac94b1f57ddb4904dcaf6c9f6768c886f5971616460d5b3610fe1a49cd391401f4a9468f6d07e96bac8670d16a3670f4cd4f7e924b7d81ea6aa1434f3d49d08927705ce4a48f4051fdf3d2ed0a4d109678142c80c1f18d70a52723ed8a0f0d562d7616210af50ea1d04775dc2be1a58bda7bc94752d6ef015c7d1f2abff8fdc4e81ca90e57ed91d0f1c18a18908f75d6617475bd7aa6cd87cb1e35f5888a526a499496325fe992f6ab02cbe28146a81fe50f2b07c9ceaddf56676dd5d44eaa851e12e0904334187374729efccb768248f6d76c9224203769dce9a2a13f4d302cdb1b460eba37f51d69897959a2ec4a94057ff106dce25662eaf34773bb4fb1dd76b7ffe131f136ef13cc53a696a7a81a0bf787948daa492b6f365f7608b0a8a97b084d424bb6a797e5971747cc388d23de18bb99258ba5413bc370bb1c9592be51e0c660805fdfce31f50fea246bd1acbd7b5235a951052065cc452dd0bcab783a9ddccb8d591d77b1ffadd3bda8a37bc11c5cc21f47493e005f12673419b82615cff24d2cc3367d8e11c28c7cf8a3cca61bb652c5cf5042a4e16f8e56e83119e3c986be24c62f9bd0198ade2a8e32de629763d819c53986abacc7ff4d17db7ef1469d505059bfff668ae19eeff4ce8d406b5fab5cabe96fffb7b4b2f638d717657823b35b55c1e1a62a73bad66bc74f878deba8f437dc4b5d9384acb4d7632a5a3830f4f20017d5a8a7ff0eabe571065608df3a6bd2c3fa9598b3155e4fa4007775feee9a729ab0f6aafc207f9cddf2142ef0686a47953651c971b29d62c89de8f2d50261fc539dae968d3303d03ab0233231417f3199d396add740c2ab80dd43297fb34eabab4de2ff1e8ccf093a7ee380f4894826cdbbf4305c7614652caac13d036d732f89c9875a1aea219dc562294479b9f769a8ce98b4afc7c80e02b4838a47083d2b86018d0afe1f56b0d6900e788ec4b6f55f82b8cdbb129d4bae70dd2f7dfa28fd42a38fe5bc278f6b25a9448d4951b0f2897e80a203d78c2dc3135df2055cd39e0e64b5f1f653fdca0c8e0fea2252051431202b542ac5bda14f4a0a6d2e6bec49f6757ddc77a87dbf3e7509f69ff137114c3b64449ec056817e34c853029ed66f30af43aa58626254d62a44dbceb270fc6d975ae90b1d523931d14577bba992dc921db485baef2dc6df046eda1d7a2adf8bbc1bade79dbb9c1254e40579e7d7634981e4521f8ff347f20a40bda2948924f27fe4e1aa2acc68fe60814989cce28b72d3115ea5168ea3ea4b4cee2016a091a2523a21ec8587409b4ed6aef3c4b0acc374e8ec51cce9fec31d58456736da86cadaafbc483b57f8ecb2827b37f5a0166f76a9d8ca31202608799c23b14e8daebc0e90c2fd9a2364f84591c3d6cb917ea8305fb6e08294a571eefbb417cf9b7ce8090ee201f2f4df78dbf7396fcadceb43d552961bf8d97b17331b36821d7b4b35eb01e7e54b0034c7cdc5317c10bc3e0b9095996195357585e7119afd6346cb3b7e0c63880e8fbf7ee50aaf2d1ad9a865ed61ff7954a898d2a92fe7a4df3f2dd06ca80f7b319539a5ccd1a2e688630b08758a8a2c172493cadb246d907c6e3e919717e65ecf2a7da38807b1e39579bcdeacf582bcad99a940e1325b8ff7d32e8ac60af78ea0b1ea7ba267c1e63c87df4038f36f12e3a6543c5f55726bb01e633b9fed65f176e609008fadda22cdf5c107ae45f5333939babf4d061bdba8007c93c29cd09675703b9c68af3e2ab1c90cb8c17afdecd192069162e476b2463a40ab90297b3cc0fd5c1e42039a5b5be0abf65d4ed5ad3727c768e091a3b4cac7e7e1e6d06003b594624f7fee4c9267efed8c092b3eb8181bab3ae5a2f8fce76185f4d1419ee34451c7aebffb2eb236a7f9b04fe03064f55fa8fb90041b83a84495bfab386c720b34b1e786d8afa7e37fbc813d3226669085cdb8df82c333d55f22265263195250c9d8208e80133dcd23d0dcaf776f7d16c0277a3e6189fb363ae37996020996c1a676e07e46415335dd4667e13fe1f97ad03575a4ce17210682031c39b0221eab92fef862787f7b21b2e77cf60a646f6ec08ee35e28b90c959dc068c0214f355ac95cb82fac386d4be423a6dca29f93d81c99b4b306746d09b70562a739cc779d1394b86f6495b5a115ab93473b325307c851c78b94395d6e2696992b12148c95e2aad74cb6f7a587dff8f4d22dfe8353628f1affadfbda0b7b66fee33d54cf16a7488e61eb1c768d61cf8a6ff0a86226da12305f72ae2f666f2ebc151b394030eff3a6f8dec1f5bd3a35671cd05e6a9514ba0fff82e099e90fa7cca6439a99473fda2378a495b511a8d738afab4ba26e488f0ed860ed2ee8f67f7fd80d5efa2ff60a3f1e7aae1801fed9d6d109c37232e351f5bbe00c874de2612657ab7510c5a9146d1e980046f86d5a77219ca5e613c6e2872d5744abe6ba0369bbfde434ef5355d2ff6d086682a9ef1fc111cadfa3c137d57dc6595ed2df9aabf25457f54c6dec4ad8b972bddc63ec19f2d635f4a50d753ee21968ec18b5761c56b62404c59825a800889f542f0cb850049d0af8b528721657e84fe00d1303fffe1e1a37ed54400ee3692d57227538fa87bb169cadc7f77d3ac1bf803f021305b48ae36d50b65e4c7affea95fb0cf80cb4575e40dfedcc0d7d0bf9c45acb7c534e97fefd3ad104358ccb126d9f46a8bc37f9a5807f333eba84e9b1584bf9bac0b2b0065efb71958888f82cfd8dd35e4c620f758682047042abfdad53cbd6649587f37c6972257f33c644259fcf843baae02163a5a998369f360758e2b1a3bc397ed15ec69ed784d42c6a81b2b67cfef9731cd0d6da40fab03b59e82328edc0dc200775e53514025db9ccd4d44e93a3c8b71eb168af302acf82b7f58f5eeeccfbdee9b50eeeede713c1fc8e28bd99a90df61a1827bfcdfa8b0eb102be8c182f6d71f5e1a4795920181a3bc0aa98b317bf37658d7f81cb54aea84aa76fcd1dfba6b16d5fe525b2740f7c71a0b6a409194b656afc080c5717fc43d275d56c07e073e56b34b0cd837ea849fec9ac4b31374d273bffcaa50eb58ecdbf786f491270c8fb2e6c7ec9aaf3f6be9823762124c7e6bf6ab9223a1f69047fba11df0e956de185bc91040dcf384c985a3dca8babbf767f97de8e7328c5757ec34da2b9b2532e1257a4ccfbb0c40b94fe7266b1066d6ae452ff0c887e417aa62277b172e771ed3fff97a91958ca4442815cbb7e052acb8e589fc20e1738c23013d28a10a0ca963fabf7fb4068c0a22d085a88f44886de17f17b61eddfe905cb8c5c9ba856df59451ef89f68d6a2af643620f8e2d752113a6e9dbb7fcc740f92527344e48e1fda85585d132d1a676ac330a6698394bf6ef2c5dc5090e8bef141c7bc2e290545269c36cd69e4b6209dece9f3631a1502762ddba3d6e9b7832d594441a570bdcf8a8f5ed1b2a1193229806078ed5e939321d3b196f779d7f5a462cb6bcc1656aedc3d06b905bbfd60df5dcd9b63c87cf2a435faf011101de864721c406c2f8cc505035c90b2c626c6b416d80b4ec3f201d000aa82dab8d5075ee570857ec45a4df9fcd7e81c4d91b2da1936397d409dbad3e01737c555a859fa57e2e8a8d4f5c97bb3fa8c05479e010adbb0309b4e7c2ee18d65209630334da8eec4f09547eca81a7a19fe07c1fddaf28f44e8906a858edbc6f148a0be55acece6b37707d9117eef2aa8c7e0b92093b4af8d72a4e193f425579aa83970d67421e0ceee1c42281b5d6e529589ea4651976f077c3c2468d545bcd250e4ec5d7a8c136143640d0da6a1faa59f88d8013865a5eb22e25d484aa0da1742686769869880738a0a753f075e6ff95139acbd38be003068653ebcc9f9d493611031fe619a4533cee7ed4870cd062d59a13051c0d95bbfccda5f0d6107193042e8527ce3d2a9cee01aec0342e6661680c9694852f7397b1120f1f2ca740cb267bfae087c1ed371aaa17861b90e0b2517aa1349920d8a7e0c8636d8566f545dd1a9da33ae5228edd14415bc70cb7a862d34f06c186ef99a47ebf1075491be61cc18b70f232a680e45130ca86059cf570a8d16e83e96d9930610235839990d7bdc7d3d3f736908fbd0ee18fbf15fd6e32fab72b64649a641397bed92bdc911f3f29cc5f462b872eaa1969d02867a46405e5ef7d483c8f5ebcc1f41ce76e7d59caaf6c6537a9974085fa5fd362f326a7d7e1761747616728c542d16c7c7041df5db1e31369abb9c76847fea4fc2706b989a668e075e1ea7676b2562c72dba23692f6268811a0bed6f69854bbaa52c3093bf8ff0ca36ec44101712d6111343e28a2064e2a0c5e7f0b3ba7b66f42836b4f6fcb315db786e9cdcd6d3a3fd5b1bf2f3b71f01afde6c9ab1be73617ed5d487c785104000d24901c7b24f771c884e5c266259bd687c05781e734442827566eb8ffbb69dc636fed5cc1359fb9eab95c6543863da06ab08391b63920a44b06a115e8ff82cb216949c6f98524cf7f48c1a9539a7b93d0590993a176868f24c36729e51bf8ac472c3590adf24b63052ae583559b92c9939ade9d0a80fa9fe7b7cbafb999a2e291e648a32f09d2d482df4a5ff59077fc3901f8fb0f99351d95b6f0ff656b49260263ea2bb9a5769efad486fb4b79364e60df64105234da07931ac52013a696c56ce6063805e7a6f5d2bf2fe22528a28f4f3eca86f147420fafd66097865dd9e5a5125c1ea4345b865378b000263c900654369e04cf3ab57fa6b81da1cb74a7c7673264d3872caca099adfd608ef2cbddf94b8971a6c65e3e327853d89e140813ce5c19b466d531b3d23dee52c2a123c7eeb37b9bb10aaecaf4b5298e6ab3694f90442bf68fa8ea6f224fea23ce8ac3766760acc59f9198518c100e06ddbeab499fd972f2d3e9b74e11fbe4b35ed3c5c2dc1f59958cddcaae9c74ce6b371ef22d6b5f4cf89f230a7d3878172975778f79b58cadaedd4454703c00ce4e1296b2c80d03df16420422cb6d04f60a1288bff6d5f8fec2af1baf3137b7bc186992d9bc9875f0c504ddf96435d830666105b032adf246594ba94ff4d20ce3557e70bb71794046b627caf30543ada63926d64fa62981dc6a25ac9dfae17f65f81fa5643a297e04a9061d9e6e1edb8814bd7a50398b5184bda81e28dd12c519d965f512efc3deca541151eca60a38bb00593df255cc87e8d55625ff224f68c1837d9992ac05546551f5e1b44de152fe1b592c840c3a4b6861bd286734ffb76c66ffd3035712e532e5848999dac7d23e2e62864c2757ef9189c4226d3d5147babe05ccd0c326a16b091f0e9188c4639b93f26ab956105f4ae9429700712640d912c5dbadb6a5c3e285be3f6749823455ef6e658d649acc15d423cdce10e35b9216f1dee188e2d9f5bf6c732f279bbed93048da24ad07d0a10c2200a277a35a28fd66b23f6a392e5cf2a16affddb845ab01961936fad19d0495078562a8339b24836aadb49192ae21d69b73a2bf266b66f786065597fa9c7bf8927115cb249cc3dbee41f8e57a3e8754e02e37f0b0c845da43496382be63591857305a2eb869e49eab9f8806da319abb13bae3460a6932e619c010b56357ee552e2b09af701af7b842cadd1a7fd8f19ffd590dba5adacc25765f14b0fcaf47e097e88143f2e3010edc10f52e77d527f2adacf5cdfef91c4e780c156c75253cafad2ed02dc3142bb864b0d9c9221859b366962cc5261cca1f5d6cbd5e466ad657552ebf38a3772c48056f51e830de48a84176e599b8327af32c49f963592b970af39bccc662dc3402ee0d319faddb0af548a68c7f93ab1d8bfba2f2eb55d6ae30b2590097291594c3206acabb68171b8a4ee97d2f6a11a31b8b6d262daf353e07bd299c2235ac5103afe42765cd9dc51d6296cd65e340d0091ea1e73eb91152d5fbdfd3c186080e277308f42ca9525579f5d9fbe0a4ad6e9565abb52e671be7401de22e927abf34cf2625b31b59c20f5ccb52c7c6406ca00632c863651082895d2a4d89ec7a396c8d26c884e16aa74ff3d9c78738518e0b3f8b7905f7aa6751dc756926162c340f0929532508c8a0917e3899d941d6fa45d605d8aa436b82931821d7cd2b5a3a38e3d71c667e32f424c253cd93fae5d94c2f9e2bc5e72aa6725e984e4fae4149e17c7d977a08cf5ad9397b7b53b369435270678cf335313d27d412caedaa13f1c4a0eaec710edcde951b6356e47764871a9ca557b5c602145b3307dc52b2a775e5582d4a4d36e6a4c1fe190ff853684e2205655535669646f8f1adc069a6cdbb521cca1064126530074e4be59318c7ae5f6937f507f75344e8d8e7dce0e2427a53f693112f9c8e830693ab4afe72342bcd49011b1a20da2e7eb15e9d5dea3d21cf3d7cf80e4694e6dae3fe778f03323f0c5369f115033129f585b46342a8145cc2c2286fee7ffd11741ccf0749d30df56be2bb57f50fae985f2b2b08dc9604d7865e43ae2161f7b9f1e0bc0a4fc9eaf38d9064ea9ee69eb3ba99fcae77e7a0ddcc71eccec8e9acd89d00d22c2a8587ce19f7bc16eafb8b6e308096991c233afc4a537777ae1fdf903c76177da30e9f3c83bb26ab0edbbb8cadd2b626ec17ce18d44d2a2b1ab0cfbaf95735002e2d9b07d1033b566b8c5683759e890eef6ba89f82c97d0bc709e713a2a4f9a232bd1ee18c007ddd9363a1878582bbb985e2f3df9abd007f318c20e7cb5d5a1446ef17d2dbeecb1c34844d2d3464f39a6e767cba5153df22d90bad6745941e7b0b8fa691a8b6c890d310e44d4e53b140e6d4c995ee8145fc455c7dcc0304274bb9e37b242e93d402c7865f05db07617132ed224870fc930062f94001e1fa5c9c8919c194d3dac739e571494d98ba73402d0e9a3e90a17b48b876734c9a4252143e8f65e4b51a7ec0b7a8cde4da1e13d8dc8d195ac020be38e4fe00f5ae213a1189de8df3e1495bbef35186ef32312e3d9530fe4f623ada50a28ee26f5b6dd34afe8b2dee6b6ec70b36e5f80a864c836c45b085805919ec0094956ba4f160f83e1605559343338a199b8cbca0ca6a7fec59a995b481fe00867997e4e0f054d7e7065fc0d44d77eb51ca9853907378626922d66dfadedb0d5e3eb2fe303e979bb1b289d98ae004c3a19174e7f5651de6b4ef97f3fa832133f155c55503d20fbf5629ecf8d53ac8f6811ac681671e478e044c8333394ad944d40a1ceafa8cc283f75764fef6f325a6a8fe5cb3887bce40627ba7b5e5c900238145eb522c83bd57e94b04f1ad97e096b93c19b51ab49ffbc8e8fd7a45383951f174829de711e0b048c1981ea5b3e727c90c6994a6fcd2faf19ffa0bf0d2c4a8ef9766c6a0850cf9d8defbc32cf5b8d7668baa758be0e5195fdae9ecfa555c372fb561c0ef3e14920de874f189b9c4f7d01892da06d6c3042fd02cce6a4146826faf52b678e2b6e5d82632ddea62f3498186b084e95e9afb274643710514ab739906020a8bef1fad2c24252e3c498d6d8ea168ffc052847d791db0b1101fad907bd7868be4e6b84cb9af21f9cb273c6df9784f5f4182673477afb4894b295ebb87b60eac7f3960010fa9d80a9cd17530981e9afb502145f0f8a1f866e73c387ce6f436abd8bb4fd90a4f571ce0df0f0cf960e4af89c24ef78322dc4decc6fc187e3009bec661d5baaa26b78a75640709574a784671634070d57f62da8187c1f24dc8792452c834ac31c4de7ba030da39bf6aaf72902b6933a1047dbbf75fc711bae5baa644654a8ff5d2905c7f7f435fe170fc1be0925ef95e9a106d5fba9df6a493c891a749ba9016246848aca29bfea8dc5e8114858ac72b5ae367cf65b6943b4b003186b2c70c0a5ab92e4f1ee341138336f07ef37fca4d8259e5036342a4e5143a00ea96fc78dc5a83fc8a11adc67b9f535f5676320977e3e1305478483a6c7510aa139a7caa567991fd454fa5c1461291dad1391cd74c67137589d0e7fd1e05","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
