<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af949f5dd32e29c4d55f06d98589ed2d165aa20a988a695af1e9010df8a91aefa4f8b03feee929c21e58f747015bbe171f92e64f3982691036c77cc3ca584813c7b7e9cf140e99659bac4cf1f15328c1bf8e36f57b3bf1438e79f0fbaaa05ed227855383012763856155ef1f114c19a3e526b0d801d8a52d810b1f3c908640946cb287fc9c0f39543b81d480d48ef37d08770d9b49b4e49cddc49b7874336e663f4baeb665ac41ddfef5f17b502ddb6e22d09cbf4bada9958e846a57c5ce46872d0549472dcbd92d9888313f8d68da1b9d7fb784dd03e272ba27edea51673d482d8db7260e43be378a39bac5e7f835f02a030591641451df95c7ab127f70be2adb0cbd07977e276d9f4089b055e39359e27a3ea1538df5ce076a35f98e071a048a8514c507f306b1cf3528c43e6a3b810a59f1a6a2352dae3474a469922242477324c0f80501f4ba0322d54539aa5fe6b8df49025685c935949ffd9f2cb1f276e82d9462b9e6625094656926a5192ebeb83085890e4d4ae58b0762a2a5526c639192f0f3b0c923fe751e4c8789b596f6d35cbfb680050ce8b8bc5fd183232187861c3b92d49bbb567e309dfd922c72c51d654407c214575316d6c01260f052d1a64d271dba88897b64c867336779774a629e430db6976a482fc4dd68b875b353369bf5e6ff841fe6e9079d2037eab5f1b713e59e6b8a1f5588d93b571e5686afae4a86138f2291106469b202b1384ec0a0f5474700d7ec8a2ab4955a0e32bd9b71d32f4551cbf32739d2cfb7a3164200c600862ad6f2941236220c07bd1aecf12d400215e669e1a7708b9d5be3809e454fd781794d1911b606c409f975d2cea85ea229534b3d92c5fb1c91d13fd698e19f84d8ff106b63058fedb5cf0be89797b806aac06ba3b51fb7278e921510d753f9615fb2d322566e96e470ea4863ea2bcb0efec33780b3d7201b407ff885eca95e8a02b7e308fc90322b6057e281ce075332d27be1617595a85560e7d52a2869d2c060613ee376bc15505227c24582a780d84a9eb608476dd5e5a14bdccd5e41e445f5f2ac2b01d397f58121e55f88d089164cab06a82829c65b5401475e50115e6d7c268d48aabbbe5aec2c505ec3fbc78b50345fd316720637e5bded2e3be06ebc2bb49addbb7af812b0b1c619792d33f2dc638d4be921825cfdc289992aeb54e1876f4d563892c03a95c4d7282deda5bb36e14169c2ef4634f440f992a634cd61af33fbafde6e5450cc138c34584853d9c22e7e427cbe17bb2e42774512285e1eb683907b7ec14251954261153f3a2593345aef877029bbf9d32141c54db1bc59766ac602c88f85511cdd267c996518e61fc6dcb0bb4e208d5b28cdf7fddeb8c2d1f3f3caf72768b6f52056b61ac89bdfe58e3162983ef956e393311a7901d4cb4922d1558f50efcbdf1a76ccf82e5088f13858214d0aedd4b65aa012646bf721446b751116e40eda029a8ab1b0a219ecc853c93ce0c030b813298596adfc39411677ba87b9e44ec7f2b8e9c9eff72334e15123e507cca96c1a812e0545bbb8e4c91c7447f246174bfa0e8cbd180d4fadc55cff51197f29c8b235eb635ee5e80b94bee8e0e13474248ae4a368b7d658ad1f062b3cfd16247377abde7bd76545cd889495b64b2281007b3790a0ca224dcf9dbb00643ef0ad33f246d5e1733a869a676a50c121bc9069c07632480f3ccc81841c11d44d43e88a291d33584737206d14dcb112d561e4cec48d46c609a3265e81c5d4ea8e6c834c08ae88260c9812d765a76368f282233576e7ee3695a051fec858492e41e1a0dc7b8622c6f6fc389023a6dfd74c811dd79847cce731a1126672732a1caea80b9a863545188a3f05daa4e4f61abc2eb1ab27f508715698527238e5f2ee9edd9d14f06419a57d9131005c991a8eb4f44f189244e3b1e5d78996a63ad73b628a0a39544c5ad7be8ee8f32cb969f9bb850262cf54682be0ee3968cc4d72d52ca2e21ca93ade57dbbf3899c02026f361d4bd717322d8bcfb30170ed9da8a1fc211a1d6402ec01f89ba885d63f782dae5530b1cf2d5f0f9116a18c0fa369ba0edbb9d5da965342b6ee95c0dcb6b9741a8291cbaa45ee74762045705aaddd4e7e9084972d375d6b7f10719ac23b53b4103cf449e4ac2e3d15b987bd8e7f8c4837aa80bc2f82d34ed7adbd132b491dac798aa18dcf5d31f9a22b32bf3399ea4bc2d6fa9f8562e8ba1a701e01de6977ff74b9eb548c1e295c92c21839c7576bb45d3dae62fbaa7dbd56e2dd701226de2956831a750d926f9820e0ad0ff0913c607ded0f4678e893a6fd2d323378ddda83cd1496ea4cceb2ec4fb8e1a70b5f9a19592d215ed9618a33f8769152005b6731d0f958c7387fb1d1375bf39deef44675e6b4ca510b8730bf7b52ad2973014f1cc818744060a44a8a06d010789901ea2df382d6fe5b6873d3777745cd411dd43593cdc7e0ad81b59fc2f61528a9f2db8b0e2df819cef09db2280a945183725c103ca12321c33d478834945b3a93aeb4727b7977ffd6545740f528a683bd1e77432c07c3e84cd57fd7c1960bb452b1e746602830785c66a564ad441f492a5d483f4570a97683388c4ade52b46b0b77b15dfd8e6fd0b0ea41c2bd3637cb621b7de91cd45b250f67dd766baa0dcd3a10347cfddf9c717fc4de048e69a1eccb10e79f9f9e148fbea07962533bc66a7b6b6b59631ad0032edd38595ed4e65f304401115699a3883ab4b3b2dfa1646ec70c052894ad30fe239bcacd4827c6c716a7b7578e2dd20c5c0c43ed91f8d00b57e637c22c964b5f894ab14bf042ce2fca62dd720b20321f11602964876e9b0d1192deb1ddb054b4052166943f9d5997cb406dbe652af65bf396241ff965d794acafee72a795c23ac60e1bff8b38971844df2cb3208be2bdaa7f743ebd01bd24c7bbfdc5c26aa28bf65c3189252c5ee407c447bde64121add5dc365e301dcaf40bfc47f93a5234aafc8442cab8587fd1ea6010ab298389b0910814168a6be86fc88e900edcd479e3f658cc5a94024c196a78e8d9c22e9eeccea1db77dd420718466ed76225e2a0a375df7c0ae7e3d7e0352bb721c49c26b49ece2c40ae6811afb670ff904ab09ebd450a68b451aeb6a2d161e091616a1923ec78e8e1fec995374685fe515c22ea9839e7c7d7a03079f32c1f1266558015eae4118cae54b4400c3bee9fa15177e5755e6bc7b73e414598d68931d2b1b475fabf9c8ae3f46657fc949f8d0febb6952c4e6d7850951e99b80e6dd23f26a1566b6f0430493f2e1c0085ef2a98c1854f5b5cdf7a75df18ed5684441c3b221141379387d5f335d198c950002d9d6958a33b0ec356558fa9f8afd6b365a9c412b8f0acc4f70f452d68d802561e5e7648974c90a330afd1f4a2d748ed0fe53cd1631b9cc789e2edfe47da772281bfbffaa1ca79b61634340960f1f9420d6991108014529c88392a4acc551a373b1598fceb19fdb5b9aafa6e135b700bace9151c039f5ff1c05d27d1e5fccc1191a9c0a051356478d70a0c70419af312fcc800d121d3cd5785c76164529c602fbd370a944ef5a44601ca10561b764275390d6537390848c573e857b4cbc0df16398e94caca3e5c5ce2c1429fdccc60f71dcf096d858496e29b23b11081f3d7b9db8afcc2e982772492af8d1464b85285a938e47b5963098ea7501ae264ca0be4ab98f79ebc7d3929b042b3c0c1e9333960d990edfdc68aae62c4ea63dc8a9a322ec023d6ec94f312148cf929bedf87f6723915b10f73d354acb65a3c4ec83e91299eb674965748e278286e66dcf2dd30163075adf53284f3c8d3d801b8fbdc26205113c6c8c932143c698b4d0b7564a804bd43082231313082a88d56123cccd7683da2797fb42fd74b1da07634591192df9f61c4ee72a6d8b91e1d4d4129a526ef6d654da06ac936321bf4176512a3c25da47c7f0cf691bbdff78a6949b3fabb06a0078fb6d3afdf8474278e8239f1a57ab31d078742dc6e8d029060682be3da4b06390d9e027a7f1595b7614f5a176f6b0dbd0e63a6b299c1efebe7899bfaf7dfae7bfb47f44240500ce1f2197240b23e30c0bea3de4365349784576b7a649f9623b4fe616ba861fd19cae4bad00fd832889bd270b8a77804fec9cbafc5167700da4440c43732711db344b635cb8cd1b5ae0cb7fa93901cc4ba605eeaccae434bd9de66b52b9da675380a9ab371b0de8d5df50ccc2d4a1d5968b439b9d06d9ad8a10f8a2f8bd0b020c74bdec8ba02f2e2d4a36541c235ea2caeff97c201db0867d439ccb0e1093dbf35ec06cb2b40cd267069da6c2b76d41dc7846e448d63664853dcafc762bb2c7a13a4d6626d3255fcaa69db254cc9c0cec0fd62bf851630d2f951968a99dc85ced00dd71c81bf87a1bb81d1b8018e877158e0aef750e0c3febb62af9408ba42fbef4ea530cddb922220e9d3197ba8dcd21bdb3c4637bbd268a5c87d6e3bac0cf406cdc16563129be4c99eff183b0a22dc27af051c14878afd8cc1597f71ab58854b6680143fcf7483cc6400585f27976615a053aae078b70c5bd9654368ee2a2bbb69b13f7c2928086c966d2e67733a0346482ce7bd972662c0f5908dd5519498c23d4f1827c6575788ae8457e4ea4ff0cbe18cf57f8669c8b2622d3af8bc71a05f0bbf92407a4926ee93b75015da9d91a217983a057614e52e17dfe0b4315c1371f333979e134c9a8ecb74e16612e5bd34d1f5add2ef8ba8e853167c523bd9b4b6daaf2e652f22a47d4bb8913d04f15bead9921e64662d4d2bba389b4df9b61c3dbc493eedeeb9174e845756adf784b8423e7909198502d1bbf84fccc6efbe41882639aa94af88dbd51610714b272e38d38e8c32871c206d0e23538d92cc7eb86667c9c49b84a686dfd6fb0a5a328fb289203fa162b9c93d2bb7d820389b39244471133ac93df58296537030903317a8f855b550311e3dea0f361adb0c2715a19d37f3e6e834189efb6b3ef747eb6d03886c0e693e62598cde7e2e1a07a9984a00ad231eab070e462ba972171235720b3c85520398bcf1ed1f42664e0503afbeb0940394d21bfbf1bf520f7de016337561082a33d78d03a73fe0e24a73c8359204f19d654c3f7903b37bebf8e89e5bb79efe5eb990458da20ca3fc8db90c6a5d32718b3fa02ec4b096d06ce5f387ee5f5a91b7d408d32080f99367faf9f8297fc1ccf183a881aa7bd80d1ba831faa2440ecf527e44e4fd6c05465243890091ff587ed07654784dbe047e1da7b69230ff3e545a1a8df21eb092729ba1e44fe3532317c80407d1dd5890b5d18c4244f7c038d488b5c571bcb0a5b9e2e7254a7efe97e16efe886abfcf2d5fe411bfda369155f5211d9ae9c4ea94d1aa3f077847bb724b55f0f6e42d98cb95f684ac68fec0a27fb37a770af6200c31f10727ca36d4da7b0774fa0403d48a3473e2a9e6f75b8c1432a5c9a6887689bb7c72d282de1097fefaba6ded352d4308ee32b71c2c75d75cd494d03ccb6dc9b2538f757c55ac9bea08ae0cab231e4c3507413102e694939c3b0c9fcac2b93ee5a15409241e328b78dac056c3435d8cf2364c8c8fb2244d283152b2ea10e7434e54e8e1d60fb5f51fee1dd33c4a8ad9feae60f02ed6473070d851e11dee3b11f7f68220948382b2c7b6190ee838705ed0448b2f54f3c92e1c35f545e29da81aeb56a78976c3af904a025a76bd047a8a120785f7917f079d520f59412f7a66550eb3a2c94c74241287c3af66fbbf0568b502c5f7d6bedc3a9405eb72ca7bc0146b5aec1b0fc0e356407221e1bb2b588b851221107e77fb98821bad3614b0192da69fa41df8121f02a37140fd4d2fe874268dd97e8f0677f76bfa04185b12ac72f6296ed3dbe1ae962b33540d4ede321c9b2e2a46b8f4dad660675fff7b90b3335d5437450d017d3f5608ed9ee47890687e47b9fa178a48b535eabbf632c46b9e7a775edb5d6625670fa364bebdb80e324f5ef983192795bd8412dc79031b8d7ce2467f8adf89b133e7b7fed7ee8450f73a4893f8785a89d63a35252c4ee04db4caa1fc4d0395f8c7af37ffe417b2ce501e670e46223e3925a6f51924036fb7834312517b9eccbd5388f806721f54c4a9bc6a540f022ce6896cdb9fa3aa2e471722b63123d48c5b7dc768db5324a58b60e6c65818191f5e40a49165ab134cde1b58c3df8062cbae26e87e90a642359e8c26735fc1394b52e273bf1470288e834ab012a2ee6b9d6025f6353320873836b26567eb9abb17adc81652655d64bdd9d7a31253de741b265057e459188930ef2393e576f80573f94cf5f33133e694872f1b53d01c126e64abf9e66af783fd10dccc4237740853a1490a4325b2460a9b10fe1df05a53357d54ce1a6b21a2efa7d8443ddb0a2797a6b4a0d5538d300738886b8ac3845398e3d76ab62bdfa0a54788c536c0f5f1b9fa094ddeab583c84d98ac148fa7aec3fce72dd648c81687f01237cd1a647271d53d6b3c57b8ee3fc522ad4d39f73e007af5b5e92b40fdfca0a71ad90ae2ca1935af56f329bf73e25bc9fd806b4903ae2c5df53666f4e053e7d940f58df464ba9de031e81b04f51817a1b434762a26c8c5aee386e8c913c83f7f2ee103d535f5d3dfae6bbf9573f304953e975d0b6fd19eda59ff586e886d48e718b4bef04c4109684dbc9566fe57984851d7a82ed475a4fb689f62ab6719a8a452c9fd8f205aa407d9a85285b66c273c99fb56e151eb3dfea458b09a044121c38eaf2ee64d8f5510b49340bc0497da4314b01b68cea2444fc36837d77372d63bac27cf58895afd84d0c17aea35f4e011e7447d4405ee497b1514e5169898d72e70bf31d3a3577bfe173ba70c9a92d7a2acf5c119571c3e505c0b4aab11b15d7c2529447cb5097c67a1d274b562ebb485e12041dace05ff25dca7eeb00aaf9cc809c8bf9fc84500a73a57b4143d482f6fa559592bfd080bd2a72a11f7c78c9c10fd61b661c8c6e1e8651906ce0eab4bdc326d50de58990a4b4b1b5410665d6647e97d4c99bcd047f55e6138feb1ad8486ca68cb3849f1bc9c8c4b6f07bf57793c0e55e324ce5516b075179a9a574805ee31cbf1c8bc599202059d4356e086f058f81c82b5f73a68298a47c0980d100d29d9d37344c1c9cbf5e7d5a257fce298d75f3bb0232325d5f34aba5e358de3dc306d532b812d34897aca583ce31641973951979c9bb4aa726b4a3956abf4e84c0d1b1d043d5d5091301171826bf0d26a7491c40474a67277a54a01ce7245982a9b283397f485fa369d13f61ba9cea30df0e114971523616da47265b1fe52602b39f1649c0c44d1b08dd8d55e0b60578409686e6b1649107e94ae144bc08c6e6bc404edee325928d05ca2d57ab0893e3715853cf2db8e39ba7113cba69e330a5247ff03e08eae8d202544c8ab76f4a495d5e18fcd444e3c897ded268b6e8703c4cd8eeded77732bc277e7066c37ac735fe03f384189d10c715d1bc3f3ee4064ea5a3169368acf76c284ba9069e00f4cf4c3bdcd54014f2c643befab68c0316db799c1d74c55dfd5a9902656f978e99ae571d4a9297f58b32f794c6f24d2d7ccaf1566f1ae43648a0e027d17c957bea500b3b012f89c03b8c6dd0435f1edcff19602e63eb420c31b6e03ee51df246328837cb3ab8bf7a605a9a28a700aa3751b6583a0302ab1d59c30e11e20b38c52f4e60b865fd397c0b11247c3fcca5cfc3284eb5122c769c2f035309103bb53a2c122608c572d34dbd3939d9a92e4b622cddb4d7e3747dbd595014e51522d85bdfb172c09936f718ea673a09acaaaadcfa7406be48bdf215dcf9086dd5084793b099429830454efb386324b21a6065cbf1b9f7fd2d7002f604c71c5bbb0033e467ba2a750d3d451b4ebb2a18de65748d91ad4a1a8f7732780ee48442f8118c4a30823dbbf88ff6dedaad3ef5d4c8b991ad4b4ca0d6f975771b52db1b843c9721530ce13337cb5910a1bec76011d91c8474025df4b52cb8a454a24b1abc67572d5a2a7d909f8d0f87b274333fadab12c19dcb8932070b816d52983f39f2681a6b1517efa39b29744770e311791c9bdb2b7979c518374fd672c72ba56052d2f262851f463d73fe521d09f3ebabe346d9680ea949e425da84d58d612facd1534b3ef9ec060cf7fc8a3429edd3ed43ee043464952435b9b1022fb636facbd5ec1b390c4ab4df751f825cc6fc1a9c8a15dcd05ae5794148af5c9765d8a1ab87381d384724691667cd27aee925312c06a8347787dfb8933210e89cfa691631cdd229057c80c800f7f31de1c82d1b8e4e5583d22b724470adcd06e656c382e85f6923d8ec6513836718e365ef68ad72fc7d1b67b8d76d64e85a914245fa4af8c71464f3d163ea25d091cb95eb916f79e571ecdeaf6e2ae13452a55e998cae7ce2a9cb5568a3cd135c3f71833285b170d6703665391090788fdbd251ea3a0d91ee293b28ea636bbc3ffd199a889f03bb2755f1bc320a19870ed85e24081f678313254f5a8e42287288ba1537e7dfb8e280bec42f785e2c2e4a44dc440ff60d60cae8220abd9c77bd93c562619c5cff704eb5e804b219a6d8a716f28befff58a8912329e16663183e57ea4597f168faec71a4ede6580c507f4d8ae2a0ed15a67ef88119cb42cd7e84a66c0fdd29d78ad90402e937331909af134fbb9b695ba90620896420632a559707535cd242ffcab0e497490f44ce181ecc987bb9c89a0dbe76d3542beb8290cc62456a74ac9c6c852e1317dabf18fadc859c346ce187dfa262c5d436079243f7b06ed7ee53eb0c1c0ebc163ce644c31d9b76cb5617e3ac254e877babb4b17db42d20799036a89c1a9d58c39e5ab48c1ed9dc836a3c9ab467b48709a13b1eb010a556dd2a83466e2ec35202bb0fc161de6c8bc6f1b19faa307a164b144dfb032b41d9d776feb3170357db67a74d7431bbb5dc175bdc6b368c27b0cdbeab52c1f06fbd1e6bfe4f9e8bdcb8aac07f1b44f7d50a4dc99092610c2c71732c76c14bcf064b8ec4b70528c135a5105cfd08452439ea46709150e83d7082550045c1c0d34e2cbc8f816883a02a5c3d2a499cf9f898a177cda0bfe1d740f7efbd51160ee63579487b6e5693a5ce89b032efad480c9dc3734914d0ccb86c458129395165312aab1a8988ba0423774001b3b568102ac9f8335583b876678b13bb0fd341e69df7dfd8ee048028fa743e568d65dcb46edd36319d1ba1955befb302eb9827767864c7c8deebde384d63978a0f1e8b9db184406a9adba9bff316935cd2dea9bfdd2c510bc8c655041b9954140f420de3ac1bc8366c5e2a13de2922119f5fe32ade605489e556c850d63d53122a3f3db596b8e132d87484b4b7a0c042fc5ac12c033a1ba35175176e3bd86de626e9cc0add3dcfd48bb7cce1f2e276f631b47daa8ddead2fda6f8eb1370b8d2eb7346acd6f5d6efa6046929e6dc6e2d588ee32caecece54c647ecd068ed5b920e17a283e942c301e1672c8755c8a9e064fa283eb0b5e85a2804a4d1c8cdd81da0a063a6e74022d0dbad52cec0068320c469b54b8c7ed6bb2332c8cc4d880b3cd7b7aa5be3a52e2e5e20221075fe31c63812b7ee1156423ebb9414440fc3ae8f0717eddbb3c5043f69b9e6bcee305cba7cd9d22b4ea2ca0b27515e72303febb7001f60db77ab519fb0ba6f01910cdd972c52c93cbdc82da81ffba205174110c5a23c2749de4d1e2eb2ea1a89ff5d8bc9560367cb57d5308afd9a724919657abc7b37ea362ef3efdfb2b8bf5bb5108f2c1b17aaa4db6fee67c0e30ba8bdc3c88ed7cca493ec1faf4d9d8372f2d77303a4a1e8ad74a574d0d26a0e1197573034d3cc9c292c68a828fb860ad8f95e6a318ec2b43c3888d25ebe5562ce8fd0ff92cbe8046d8cd5296c030ab9f679621548a69cf4ad7f2395b737e0d95b81fec3cfbb583539f9de23be98d5dc2f7c61a3f7c457f0404b94293ed7752e07c74e87fab3f95dd9a43d4348a0998719426f97ab25f7ae6febe5459f8c36448b17b1a0933d99f57433c13d6142662bf67fbe8c3f2db33b69343ad0f669863db0a52d3ea10e2ad72245f676485056101801f4a1c57b60f68bf5f7813585c10507543693e131573c712b69c8c1f784dbb3806426b52e9af22ddb467b91e8860c116cedd7e2eca4ff704139adae45b9a8bc1bec749ea550aa9ddf7bad884f48aa432d81f43b26dcd62a90a8b6c6ed94e976b1c1b6672ee158fabf108e6ce557ca235b46c9cf583f20cbad4f0c2ec2f478030ce8fb5dbc19c4f132cc64cdecd584cded3e2b2f8b2045834e793c463e778ff7de16368e2736a11d4283765a242493bcc4d45d31c7c32cb24aa3fefed3790c2dc981b3cea010ff7024af9d0c6efe703cc19c7329d5e0ad56e03762cd5c9c3d3d6f3c2a99240508484ff380b2429cbdd1a71cf1b2a8e860d421c1dfa622954b9bc39af175dc7ee5600c18918fbc6a0dfd74a561f1bbd140c458699beab22fd908fd0a7db18fcefb5c1f36bd248db020d4114c2e67320d671263c7c5f5b65d0b452ce418794d48cd7ecbb5c68a622cd37936476098fc821201c1a3a36bd9ca28b4983dd548a6446876e4cf5578bf507a1ed9a410b5ddba2a53ca0f6289ff8d020994a62c98d140fc317e18b7e97fb5fa23c3572e63dbde593ab6afae3d77a00a8a12a8e06cbfff8f92e60b2b1d54ce7a545eb9d0f3420b49247a534fa535e18784cb57019026a37fbcdfc6ca07a3537cb2210384f287042cf658d06695571bd23ca57e0b4ddedb91ce242d4a4ecd75041a2526c98c2e0686352266941ab20d1bda99a235b98c42e0fcd0099342ddd611a1e0e6da5243756b24404e370924804a4f61f9c2a5407525572d407f6f7e826b978d4e4b2396d1ed285c0af178beb5163660664c9e74387707c4c905684f31f25a3dc10a391788b031b3395e6f6789a209b58dd6a801578f965b463454b7967cb751c219a31111439503ab44e69b2a05370de13d0c17a151f782017086d8705dc99e2ae23d66f088045d1d09c2efa197451852c87c6746d10d9a146a6b2539d67ab38c4f28357b761c6689a004d97fbf692dfb80ae7a61409624b022025ded36dad1b98e32aed4c04e6e4d1961701f7827211b7632e5e455a8d870f038f2ca56668b59691c6357be072aa5bd03f41543b40685bc6e3f10698f72770ded03bbaac740eb9457e84d1efddabfca17a0f5fdd10863108c1d1324d29f18bbfe2899b1328fad233f63a0b1422499d5c509bd40ac259754f599af911517a8f31589fcae5cb16f071ac50a23c30c9a56addd5dbaf020726fbda6449711211f9d1017ea115d8456b31b17a00b43770ab5faf74919a3928c960deecf31c2655800a570713e270a2f6fdeed747a8662b20aead9aa4e347dc790507a91c4e41c4ac06059c3013db355fcda137ac08de6df1fa7a10662634caedcd3509f352077f1f58dbf3e087a43d59acddb39f18eaac063d5f72f66a68424c2a20682fc940f8b92a79c10e217e689e3170cb72c637da16450f5fc1d7aab285fd33d2c720ca70af3c2f95fb96994b5def136b76020450c83d4c8fc662ab076528f2c4f89e1ac88f8a092a2c8f396378680dc282e7816dc18da2509a75235bce1fe7b5463a14db67b41d8b8b5869b416556714542b33f00d3a1bd99e612f63354a6ac31494cdd6ea93e8c977311472d4b322a463c77841b8d02d3bf4ae346986a24500ea3d08a9c11161f1a148b3e3ba14995c7d4855f7afc02b0c20b34d50496f15bb9abf88e3b0cf41b213c654119deccb68d3152aeb8c49dca50db01e16c6410ac668fb30e467d597cd385e462ec1040b8212bac4fe2e4f477c8c997aeb5e567c156e9018ebb285bc7f601dd6949a939778934455318a42f724bd7b4c6e6f043ba311c96b73e952e90454e81d084078b25f2591d8d00c35a01fc2c041dae4867959dd61ed0b4fa01c01e91549c4dcfdcbbf32d276ff9830f42179f30e1e281a6b00d48065ff044b2d984e7e4ece29f36f388a8a1541564e3be25b69f4b6b4f2d3e407be3070ee5585cfbcc5862ed1c8779ed04daf3cb36740536f06dc1012aee74201bb3f8c456962d4b3846af4ae45c870d8cfa7a0a1b56fabe0e189999bd67b4dfba423e2e18b52dd4ea81b08db0ef0750a0dbcf27f1cdaefb7fba751df4d12eabb5b459793554daa759dca499e5d31a57cfa181d0c345e2e2dd6d43d2d057d5af52b6ca8c019f517888105336b67403e4db93f14a51e665015c7384a09d581d2b51102df39ff2792ba91281983b4d1f6d53c89740e380fbbf1b97cdc7d8f4b3f56dbe3c14e59a1b0be55bda007664be78fde25f8653ab3cbe155efb227829e5eda0a5b7c86c5b9ea7259ce8cb890a0b0c1dc9a9045262f60b11c3660a1e1b9e197ba97bd1d0a47d47511c4f902e0baea4c19ff5df21d11b63e03424fc10a480ab1eacf30e000ce997133448d2864bbc7740cd804bca84adb44c298a418bb464af23c2f822a41ce47555f88be480bce51b08f643e5615e72f418442096ad288044ed8d3292e18b0505f5ed9006b73695fb86507d003402003f77991bc71d1483ab5df7d6dd66a01beebb842faa1ed8338ae38b0c3a56ce146dd32e3292aeae0047d050475404567b4164ff47354e552ef9119a2e18ed87d97ad31a2e9bd846c58bb295f1329011c4353cf27f9a20f0756dcc245f5d9ec0b8d7c4e26c3cdecbd6b44bc2340b8044616c068e2920c1a034e7ca25037fe15c6366c1c130d7e455b61d81305ce73e3a7781c6e2be9baefca17cc4668dcfb60dac19b61b0d24cdb26f1ec84d6848ea032ddb67c253c303f486e4378aa42b1e64b40205aa652b08319cc2844c9550e53ec88a5c117d817b861a54fb46b369e078291d717dc79869c81aa694351c745b773e51c214245e3b401662a6f20114eb840557cf411d0140bd2a550aa17fda1a848307ba36f48f0cd982ea322e1ea227da837ae3e328846d060cfb3b333f15aca8c01811c07ee860331e78f95761776a3213ccfbdbbc3c6426a84b83861e08c35b049c426e67e2ea460c54c63ecbd804f3618316f4f23d59ca7fdd0ae6fafc254513240459928091f32883be735a108a35fd6de410ed9bf2a9a5a35f38d78f9482d441f6691cc9c234289ff389d3adfe15cccabd5ab7bb745bf7c5e47370c5aafaca77fb5aa7f15a868e7e816240d33de464845e951688c9c7c9bc70e5f833cb55b53bb1f928a2a531d3ea311fde2694ce3e67c88939a3e79da35ff80c4a7dec891151ec0579e3f34b4fced56b9d0cb4cbc62460130a5e2c812dc4ca36cfc9468616168ba84bca31b7351cb5748c91388ee1172cf09bb70d79f884de0da72547056cd8797b93aa434325644f025a7ce1cdb21a71acedc99203e82e7894ab58e94155404fbacef55d5e18e5aca2adaf363c5197ddcfe7d699103209bb0038e69aabbc0e3bbd7065258ddeef310dc77037cbaabea6c9e745e3b3e5d2b5cf87bf7776dc0b352a08509b906c873e40d958cbb4c81d6ed54ca7f004fd1c1dc1758a128176e115105c3af3b47dc46a70cd946de326c945dbb969ba5a333df806f82988e818459b6e0611a20368beeb9b5c535032ad6ecc1041aeaf96e81c6a147892bd82e528ccebf458e3a82c17727ffc12d66679aa4e8540dee307ff27421dcb766866d6c1005548d23fc2f13e5c7bc31bbdf68ca85c1b842489e5750764dfab256c151090b454c0eef541e6b88647f18f848b61ed7714f6bf125ce48667a18f83533128ff9d1cc24ef90f7d637b6ef4b820dd8cb361892a9c02b4a2098d0b42baae7685c0a8e5c7c3ce28d78b4e7a13128c849700629b5da7b8be640fb59abe9a89e1383b6b00e31b63ca37d31abf941ffc776a2c117ace0ff1e573944f4c4b313f5d9531220eb7fa07e4a66bcdc29c731d98f46ebba1d4b347cc127a46fc209e1c133864b8409b45c51d7233df720e69fc3a1b6fcccee93a873aef7bf6f7751a0562aa2041b0973eba0ee9bf3b3a791e5653d7985b6d6565821364c3d5a8d2e6a0812fdcefefde6f25a1d51fc3e58dbb11e2b1ff4dcbe99bca628942e7f4b60c7baf3170de652875de382917c8e9f07ae81f13588c0df2906d38b420745444ba06fa848a455cb28d143b66804068f5f53e48bee1a5b5184b841a0ac4273ab1daeb0098078a9e99ac5a95144bc727d8d211a7356a2ef2b804ef65784fcbebb1a83ab6488a47ddfde84e30ee1d39e5680d0762362dfde61f656f68aedfcc9169457716c52f6a229e8928b576bbf5a976f5f03ae1d5db99110df648e4231c0820e444da2a76ea3e9e64d1f38b26b95e723370d4645f07ca9af29d95bfedfc855ff7da0b8a53b9c1f2f1146f91a8795af1d5df444441f3fc2e0eb0fd7976c3f2c3fba45012dc401e3c748733933752a58d9dd534bccd263299d2e112582843c3312e2838ac7b07196fa08be79da3cfd3b18207d22e1e4d143425ae98fd41822c26c23b9024884985c1bd7e1e20abdcf5fc4d9b299722903e8175c6891339c98fb7f47ccb284f619021d98ff389ca19247443716affe7e6966094b9111737e4dd7408af1ce0b6028a2feab970db2b112d59e5da00b697cedf9343c6fcc08265f5243dd8404a962eabd7c2be1adcec3436ec4bc5a9b5d734770557ca7c68388403eee72775ddc3c7aa99e3ebf3d9b9ea0f8ec93778813b2874855bcab51d28ca231ba26f45fb0b524de71e20d7e0f963a61c8462a906610d71adbb14f72b79cf82d98afe776870b9ce4c0d3c5e540578ee4994c3db26d3df973541f8cc0c8ce717e4b1411fa3e58fa7c978c23c2cd5c1803c45c1fc45f1778e406ee0517f6bb5e83180f58cf5f0feaee6d085921a4eb3ef28796990db8164fb120e8621213113e37f42421077ab40d4f9571c401fc2cecf98dc7aaf94884661864e52dbc3712689aacfdc041e748d7fb91356c5f02f00206b17628896711f6f12178af5ab9b3fa303eb624c949d27cbc5b003415685b9015916f1af8325ce945e3fcd45e67a26f77af4e9d11be6b00a0f32350c759d8ca654aba30687d152c49f9c4c4684677de2ad78a2c30104d46d0f91a09dfbbc3934f6cf2312784a6d769b220ff2efce84f442a1887d39bc542058ee8addf1ca44c62e382d2b7fcf02522e8b53f46e6ea2eb57c87be4efb0f21437a37b568a4c27eb15734616b9d33234e1c7d02c8dd5d489e3447c42e28c5d2a77fff86ac4089314193d824f8233a1313f363a0508db1ea98a0faf72d5a4dbbbf8f53f11e6573cc253ff526aee6026592acecfeaa7c69c11d2347805a12fc354e5a4e1a704df1ffff3ad529c1840444875cd9d57a02d66799f5a060331e80845c600d80367ebec107a208ce06ee17cec9e68aa50cf534f46680c62963870b9ad90a06ea1766a0bfb931eff72cdd47a4965ca69b855c798f1d4afd80a3b098e6bce20f6fe82aa4ee4e86e00351a10b39093da7183e27868c730220b3b624277a94dbf83df5da7a4197f685e12a9685bcbf2286b88b5f870d36d634e8a74e04b69bfd645d3003975e33f7acfb4312b3405fa69b580b5216c9210718d479fdea43153233d2cc21f2388da189a1e55f3280a8dc69d54596dbfdc110ff9c299566b04568152975aba66b69c8f4813208cc8893b7221b818df655023ced98a4801b15b8ef13c3a6ca4cebf4856fd4fe01769a1064b1063c704fb3d8189c9732efbd7fd0c8fb7fbeefaff4de253e195acd63b3cc00c3c6810354a036fbb7a329a242b63774d966f32c03cd09ddca2f3a06cd219ab81239d331a18aae40cbe1ac57da7304524f0c093cbbe0ea563d1514f8016b187777056c93f95e971c4f202305b992a246587348380f6ab34d8ad57316bfb507f9afe4131e54cb161567a95e57db2217799915672b189f9eb67a647fb0ac520931ae8def85b4dd5b58d909fa03ffa36822f7733d40d29d3e5f09480354376969bc74822a2e1959bab5e727c8c9ff2768c4bb4d45321cd5abf9052c77dee27ce70b3a665256e017c89e7fcd52e3426c2c84c03feaae94bac300f87d2b1f68f5cb7af5f8c7364302e80c94da182f4fe8ae2a5d23e189b665a2da85f04e00296936b6d5541cb258f470989ba0834f7e6e74f19fc38d5b851a424392279a4600ed449db3a50d2bab9ca0298e1b9b7196b4f0b00264da46ee61b710c45bd36f055719e8a530a9d28e8a61720bf5eef1d4fc32942001df7682162bacdbb96d5b160c3314a08e074c291e903dab45f6f334e54ad3a72e426ebd31c51346c1d1a75bac6b6d744abc34c3ca3718cb1fef292fedf5ceaded45b22997a0b4417a598ff9d1c5bfa3b1c39a84f2466ab5caa199ce7e45b730ceec28436d74b3edd93bd17b2b040c051bbf74e869d163189fa4f88bd875b6c8465835a4d5455cef33c65910b583330ccfcec578ca2a07d1519692af0f1a149a2da7d4501c74aba3df92558165a3d71005640bb3b067c238354b54c34d94405cc9ec8df109c031c8dc76c865b33b96fb4325e6cf92c669600ba9a80f74e2af373c9730e582ff5823ee0dd30b7f1c7134433372847b2ea2c4e47b44a3b3213784b382b526a23ff49134c8ab64f65c806f6602b5962cd0811a2b08d92407b4f4a155ddf385bcae6cc941852e75f108744b5bd5d008c3d89f9e96f6d1a29912a6b46f905d3b3cfaecfbecdac74dd2aae209f32bf0ee9a1abe08c2767b4a86a2076033f9fed28e5f49c222d280b86547c42602fa1e0370cb534cb07ae230ca051f358a3f19ad906b8434e40586a904158f5a579618531cfbf01417b4bcc207f17ed3531a197435e88c5fc70a9a232f4032c912e78dfd501f585cc5cfd1739a4d205bbdd49db2f84b6056434d027b225a1e63ea8f8836f2c3120deaceb83a64adee7b5590685d941c946360d5eef969fcb7aa277f8e6560dfa7f02e495891dd295b9402c67d65916faad0c1d92c4f75b1158e97cbefdb3b7f9cb274fa119ffd3a2ac5e31ec3615c72d1604637b926737cdc034a451322c69eab8ffe118deb84894ef14f4f3e08c0e4f30485a396620585ee2f6c3f12ae16f2ade924b3517520198836178d9f4dea35d98645bf136d0b83d1e172c3ecd54b6062ffda414f337952f13e2e0dc3522f0ee3fa4e4e2f81286c050e5133e6cb7b753edf4d06dded93a76acfc8245c7bbe4529b5edf2e97a7a8dcc47cddd380de91647f19802e58c506671a3a1e7ffbadd341b645f3456a642816b2bfd99f6f8f134ccaaf95d5ddf62b5de8fe50d8be30b7d843de3a1f7ff9058ac1571daa8f0961d17bb6403fd7e25b24def8fcbf967e96e075d2961aff7490d21f6e73a52db786d39508dc0c6da670d955298e14917659dae65fa220f91b7cf388a109fc8b3803e578e6359ca1ab3ab85e30f0eb6c4cffd641e39fab6469f5ef0a6e4da5ba89e7d678fdfa37700c5e48855f87351accf92ce3a5bc41a274253ef3d41415bee7ca10a9bedd9ecc29842aafd3966a697cb6f39834696f7909b8f3170125e33b4e03fcbb0b0c5220876ad359e4a655f6e57f3fc4b1e4fc31c40fd4e2076dee439fb0c26de0797c87af21803f5a0a258517bc04a2243fd60012fb1d13db61e273a76cd15f61a445217077bd7d87f5496c2786a7758397fbe398ffe6bb5a13da93ca8091be1c34fc1a837218cc44b2e3f8f353552486578a90def819e083e4b0bc5f2a14479f4733c10def2bb1e14a4c62030ddc0faa0c700f04b720df57d4d1a9fb82233c9e05bbf6696fe000a3b3198af347ef209df75726c19fa562093ca76b255a247937edf151ec0f818ebb6a86bcecebcb5023ee693c324753c4f3874b01000cea0fbc7c382426db5a8dcae373b21a4e799cb55d8e0c997ff6fa33ee540ff07876602c7c961b985e206cd691caac81772b5fcacf2069bb8c44dc82fdd44221379d496fe963422c6f47f9f7bad83d97e7fabb7ba459c48c1bc1d673c55d51895e6c24b75ce46bf37dcb1e7ce7d5f58b36fdf2403640ab0cc3ab6bbe848dcd8aad16c30a99c2b3760cfc3e9ae2e124336f2be9ea7057c3514ff90a4306d9edddead4bb686b1f762c6b77c62131764ec7cb956fdfb306a195e3739e3a15d9cde7ccd619a0296e6837c63828837d869b0d008bd0700ea1492994370a23a6c1d10168f2c26576150030f05365d761f12cbd364ff072419eab7eedc5296a881088c01195423b1defc70f64023af683117d90051a017372854dd9a1027383715d329124f1625696c036a6d66d69743f0700c5668c592206f17960c571c4b6b990ba3aa3dcd2eb9feabe4109ce4a5b19ba0525cd22f696d6393bf94414462598124ef553e6f82e61b2a2b564c8b9509c82e5a6dc4009e264bcf19d5612d6c42e26e030348454640097d9d48255edc28d10df858b115c9462206660e047040acde74ed87520d553f0c2804cb847de70317e7845d415a04db815209d9dd35d5daa34f4cec793df5e65440af5985aa1af6c1c0670343c16311d568d8e692f7b1fd28615a61cc069052347c4c63e094cc80ba0fca460ededc45bef564b3af987b497dd1f6f62fef86716eaa5bcfb7ad27bc772125424a67d09457576f90a184601cd6e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
