<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93b4fc926396eb5958a35843da523e4e284bcea78cb67cd1ab0a023440378e88708171246703ddd27a2006695d23e204a19060d4a2b422a7057f896c95daf64ed7149701ea7f0aa6477d2432e70cdb45b97fe82e2da79a9e3bdb8af4e6c8deb6bc125565bea6ebf5e6962568ec23d0b4007f376e8ee9a9990dac5710243e0ecf5e9b16530e872c22d70e24f4cdbbe30838097fe3b20388b4289b5087a5eb87072b4de9333f2451ca80bcd03edb26757036cec03438e88d1dadff6cfb26ad218dbf5cab4fefb6977981277c52984d8c1ab67811dd7dc379adbbb8f7a6902782b583484b0d219a22879551bdd7af72b9e72ef5a71b63ca2ba7aa0bfd7949f171dc94191d3705ca3cdb64f5d457e6016afc39f916e0371fdef3025c55f036ebc531e9b6242fbc7bbd28b53687a5d7f92dc3963ae70e37ac5809a81153b2d737b1bf5bc389729ba3378bd4dc09f9e73e60d61619f6063525b765af4ea6baf7e6f7d1f0e9c3bbac1b3ebdffeb6b7f8c1d4f37b3f12d00fa2d7a191746ba3faf328d0dac11a1f3ff4be6bf391c18a26859e42aec53b146e0930e5231d247dc8652e518cdca3ee813a5652e398a498ee3bc2dbcb7961ba863e8ea231e596cc599a2d058039ebd2a8f58abed713263e1ba08833dbf38708329f343050c787e29be5c3a840a33599cc7cf58e5d67424b7651216df898d9be5313c1fb97e1007d2107fd29940e7aea26ebfc0191894ee828e0023011ec5b6e7c466ad867252e5a143831b2d76b74c98ffd414639963eea6452ae8475501fe123ee95b918d1e1c1ca16fa8770007f47aafe73b58b616b8fb95d3653bea9e458220b029fed1c55eb8d589751fb840be2d7a12a453f88197f8d64ec0be3aa2a9b14bd65f4a5811daba8da2f5bc457a8ee4ace2194bd39c94e559a3cf19e5b7b350af2563822c33b41dba6d9f4b6d00deda1741d303f8993b9247e217a826ab16891e273ef20204d9d798bc45c02842ac262f989d66afeedafd1372c3f6017f92d7b339cfda6f0ce501dcd9c1cad80ad1112af70600a833400ce7e2545761c5b84c6aa276c091e83b72a168f64f146a74345137ef770999608e413826e1a54d061c21ef0ccceefd17635565c01dc87c7b35908be3fea071e8e4595c50ebc3a4031ef699ccea981bdc8b8a69b2fb5881864af8f0c2b65fd61af04220acdab4040234936e9288fad7ee5317336e7d77188727a0c3a12fd29987af644d8f28aa45659c97e846e5c9bf1b50a2460f7bbbc670ed4659f1dca83bc3c766468ff98bf6523faea1b6c30347eacabca0ac7aa73c80c591fa0df4989e85c42617d3afad0996977b9199f1def856b66f88d852b23193eb75318ea86d0999d36ed12bc2212ed1274b1d7e21089c08fc31593228c407968949d5397b813ee07a6fe69e3061bb1a7fc87b713fb92b692c13a4ddf8122f4e2fb7dabea91015c71974b2f60ee696264964c98ebc2b70471a68072448e875850a550fbd67fc836e0f57d2b750d27f0b3f95f5e49723e6c5211d66ed082388d5b1a417fd05523c8aa359d80c2744c9b4b9d8cd72f04c23b455e8e73fac4950b276b0be34c86b12b79819b192edd78348d909f040e26650e466a47c0317987a02f097b2389ec03562fc7cde151e87e0db98467ea821b1e9fb3004daaa68105fef2bbd259cfdd42d93a4e8b8ff0961fd7de943b07f78f544e8001d65a6bb6a23840b02bae53770bf7e8badde8417b2e6bc08c2df32a9f90afba9f996cc846e6ae1f0b9acfcc7ba0cc6302a60c1dfb02c41d9d9458ed02770fd26bf4498d07eb91b65eb8307031ba74bf1d65019163c992bafa0168a729bd67bc3e05700d4bdab8cae98862232da85fd507beb43aa91d868d1f6c63b1edb032f917ce5932e641cbe348bb29b53cb83c33987502aaa6d278b152f147a59a33f259d3c75b64db8893361d9a01d68e681813ce0b377b2e9d73c3b8e1f00e90adde19504174f07e7011a1912e7fabaf16c26902a57bd180d1593694beefb114edcaafa49e2bcef82fc66217414745a4768a5781aeabb33c747736627c161c32f87382204d398a27a566a7eee495f5841cabe98f12906ff6b8bbcff2fd7b4ed8ea9661265036fbc057d05976e11faafda74d8d99d6e419646a04f23d87b623f8050ecc439cb382d16a8dec906efc70a3998d0ed7d2e51f35501cdd49c8f893dfd741b575ed6ab5a649999f10acf513d9f1302c936c2eaa07f888b92a35ec005168a34e0f09a42a5c519a5dd250a6f0c07dd9f96e048f05baa5a800e27c1a50c9b89c6f6974d3b95a8e843c563d827ce3d47f8d462b04c891e1acc9bfda2f701f1cd3a7457e56e59782e2a2e7da22604febd9c9fa127a4c6a14ec234e19590ab6a490c55a724afafd89c0f7852a2dd6d8f1e221933c604d8bf6cdd966c6cceed898a7b951b17477360935ccb4878ea44eea0b2e84a568ff454281ba0166f961ca850de24c201569f79fdf8738e6be412bf8afd7a8b2aff141013019b7adf1f5134dd20c86c8d82177a135c0cf1dd593912882132918143410f5e098a24e6f83f7a92ce5c489bdca5885fbda687663987df712042cfc4370b367ebec209301acfb8e58bc3bd5b8692358bcd7d0115689b87b3dbb3ce08667c6a56b6ff3583080ee910696a7cd6f604998aea9821a137366441f1293bdd4ccf6f39c029a4e56bcc45bce2e39765132da599fc428db845d64b5a49961fbe333162730ba66e85c1f873a7e83698c7a886d2ba5f3a233c6c4633c9866556343cbe7734809597ef39f742a5b9d18cfb95b0d86b0513865e8177c78894c38fa7e39cc03de2f8e913a23a626bc6139f6e042344c39c83298c78a31e854dbbd7ce4b9883ced1dbcb254ec4af766a7c64d8cbfe06246b16c49765c83bc2cf0b7f4d5648d3e4fe75024ad68a7f1c01e1c695a0a1825bcabac2ed3d1c4164458e3e563a73752123d50b8f1ce4eaf91cc3ca73e35629c47afa9abb8d95976aa534ff55224d5605fd897cbb2a06d08de22af4214c76ae5e8bd05578af63bc74324ca1ce8ec137655df54a00bc3f405874fc0626edb088f65647396760428f545e88b7c44058fc60b42dcc09ea14c07776d5c8fea3554381b8ff5e4dcbedfce09f631718daca92d30f633a9d38a63ae1bf9e93d27710e54a2bd5d45dcde80c7d10c366afcb135aa5b98c8ac96142921b88fb811ce4da8393fd0f16804128cae738fa794b97217760aadd1b3e064e0c70262efc0381b1b7bfa91611e2ca2a11b5bccb8147c2dd51b8799a4e3f7313a750881fe311734f75be7f42037b422e44a3db46cb8d3a51e046291af5b932f035e086ff841584aa2969d4badb918ca6e7e64f487128e573722621d2d7246be0fed85f89a673a4bd9cf19e08e8c2a24887a1658f22949e1e13a4c14d69b99f1f85b7eda162cf462f43f0b15671279e5f6e1e780eade7ab49a6fbc2637d60f5aed966f15d934db6097111fcd1db473a58dabff34c4c5be4133da8df47e76bf86ff7cc4553b71b712a862f54d153a37c25596f539744e038704ca177d1a0c7f99eac5aaaf053ff86fe0b3c61605d9b0d01076759d49e0838807af6fd593e1d3c67f2e04a3cdaa0e3b2cc1f02af14f447173c02a00795a91204bf44d10cf72501c56257f2b6732df0c0c88157b195c8ec1ee4125bd7195563bca59fdfbb6247f27a2bf92b51439447f1c4b405369f7016ccf76091ae80731024277f80c6bfde5169d77fd190f0ed94de791114475fc1f5d0f248ea48e0fd9d24315b9f9f0e83e19b49ac6db8470abbcc63361a93706d563dad7d3353cb37f61db7924006182955c9f42da31207f7612e68b66442938f11dd4dda3872bd937cb8bff9729489fd63d2f18786bf34d4da31d740a5cf2e8b0001c7de85c65e24f9d93bb5ed1c60b4e60c6a1490cba6b6c7b1aa7e82905d55750629c9c2d52aff7c75736ccf5f70b420d2f12f5558b9bed125bf14c045468e51b3ce340840fc639b8476070078092691c9fea776017049b7a28c45e88dc8b0118c46ba0689f5dc1d5c8c39886fde32943085608a2816c8cbb9de1d6a3c9851778decd714f70e9433a0572696b1b4628fa31f8f6d3a6ace993a6c63c1744eb174a6d76eb8985af50fe796838a4d648c02a138dff6c775df191ee8f5ba1aa61b03aa9fa2c85afaaaba0ee42dd94ad1a5571e1fea5b28d927b83af83919bc7ed2bd9296138bab640524c80dc01e3edb4774a95bc108861b57376c743bee32c433b8f03072be274e5c8984321cbbb220c55ab4c8be33e29a3a75f97d0f69846f7fe243786c997e9326eb3d461bf963133c6c7e09526a8a357ef47f18ea4268dd3b341839c96956525c339f8361c6258900e09d0a2d172288a754e66e63c6c6411fa2d6ba2842b7c7905b671291904f10fbecb27e0f4472450c22c8ab0c41d4d8a0fcc135fd40967bb05f81d4f0f62ae36a5d75a0cb1a3fd42a814a08261e42673f49e8a8d0f4a04051d3adcaff381f165d3ee3d166bd39a8a5a81bd19f74de6dbe574c838c56445872710106aea783038bd3a8638325625373a78b436a32023a45364a890f2984562ea3fb9dec359f801a28b93dcc5b9d332d64521299a854dd73bb7ae67dd91d33614d5a941e31877848f78fd63ee1204bbaacaf1f7468acbce84cb280dd01815076f73d99ad05233eeed0061196a9d243de4deab0f99e7d3bdd2977cfbb6892d12326d4e159c8621a6540ee30a02f46346cc256b9bbe070ec0aba30cc8469781099e83e8bd5c0576e8506667b9152860c0c961392485503fb51ff35acb50e11ae77c86c71db861518334007b798289e3ba1bd2e63c6c3e9f0c62fc277c99dbb303df709abd34bd6813763687c94d7b14159604a775347b7692757554617a863ef6697302f5f1a5cd4ad87813d3f1f6d0c86c05789ddacfea12ffce70ca47caa6f83453cbc022bea27e8619026690ac224b4880196fea968249d82c629764d56d2a4b3d6b2442f563f9d58023f6c2fa1955e0f42e890917c2d8298cba16cf41077b45faf67ff4ccf8cf7de3eced2d044e5d3506d0e738cf943815c94f33f7c53e0004af78f9025c27724f45c610c81d5b9defe6136f432df179b3e8ada704e2a7733607fd8f0ac9c2553d100045d9c31e5aa015579b904f2f0594448bf8458aa32588452af87838e5a290349a671f3ef307baa8a056568f7ca1ac65a30cf0cc38b607705f26915126579bc629093fa6a0d28a9eb64efb4da040fb6ff496e4f2fbcb06bbb998922a792ec4d26e0635075f4ed00a0b77b17c5f806ee85b41ab2882b7f13a0e795242ed0fcee57ab026e3874b18738a8bc3af1246a029cf2168fcc9e8378f3583fa9f24ba8400604af0d66117ae7b4d94f5c299b7d648b5ce6c7241a22d4187d88dff6f8d3379399cd8950e8e382b14d51c29c297eb471e8a3b2dc49d409b7fa27e778249243fc10457c2c74c7088113d5b56fc54a1115b354c2ab242a333953ef2a1f747dd801de6a92486f8cc77fef596819a6b46fac6c5ff29f73bb556bd7f77bf06c3902c54915d8aaa43d3f5a5ad80b11d310e9b93447d19a4131aecc70a69ee01270821d62b7eaff46017a87bf39610b29a93864dda94f870f5e005a79628b4db4114cd494fc24d203522c452f7f39de1e64785bce6c869cbe8f00ebc04da7f1e6a4cae3f37e7ab676290cc871b96e657e1e97429103af6d1142572a0bf395ce467828292784e825a6b6804471180ad4c5adf802c0156c6f8cb8c00078ef143ba69d4079003f3f2ff8d070a0bdae463aaade37af441726697bbd6ece3aae111a7ece48e00fc09219a6170c540c2bbd7a9f84401b833e435e1e452668a87ce38966a1f3d39c7317da85cad3104ccc48ec5e4c2579086dd4f1df91bc9a1397a73f5367979266536ee129e4c05a77e4a99fa87f859f11e589261716b8d8c0ac721399b02dca8241bff2f125693eb091abef37fbbf6ef62b7fcd7de65f5ac628736dc96ca3b729822256e7ee15449ffa76b21480dc4b63f581538940208173b71f18a7f7eaa0c020b859ba37302a16214417f30509f09bdb6cd4e597c1f6650de62159e91c709042dc71163c4dd909ac68b59e2c1d96d661d4b301474197aba1cd63c532d11cf9b89fe74e825c471a88a9b75ff58197cbff4c209be4e35e5b406489d5f6fd8b415aea0dc20e20a76d6c3b67791b38b1146b5d8e04343eeafb62c697157703b5fef4171508af38f3b0b00f33b7bac4285024ae3f008e9db6878ba127bf77ac2e4b3b4abb60ae5122a720848d398fdbb92592cc4e6201527a0dacac67e807e25a7e97af32cf0b9ada273adf994ad1a2272bf265a64045b0a38ee9d5595a579666e3b2028210f909bf00bc4b91577295eea0bca2a2cd5a0ea30eb29ba0de45a896073b786a86bc27d2f65609cf776e08372ba8a0913e9ae40fb3dfca19792d02cbf5148bbec07781d32233acc210b467036de8b07d278595751880a03bc78de9ac9e28fc614d74a632d639226523e2a9b59cf0371600cb51b4d6e0be17b81272dfec0bc3ab5cc1c5878d14f8b8cf2afc7a7f8f4c41cc40482e51c4cd4d136d0745806fce49b57ba4fb37febc7e96a1ec0d9b97a69d8d27f65509161616e2587019e0b4e0a0ad6e502eef6ce373f1ba97e558bb8436736325049ca73074b668dfd7ef7deea6bc7bd129a51e2cc7737e02546557d7ae91da80d3c032779546b93600efeb68c8e2b99ddd34d761398a5269cbdf2dd4d8e33a8d5295b2cb1e42e3861233b2e38d6e22be69b5b323f1cdff3d6420993a1307993ce2e31f3d99a8fbd5eadd36310785934b22905bca956bab5f6c1d2d163fa222f02d49770d051c51e6606d8091fab2f9412e663f29bd791d9941d330a4981e990d5fbf695941254e293298994316a532ce78a958a970a210925054d1b4872fd7b1d0a192d9d0d015ce41c32f5963788b5c2229a1d8449320e58e7775ed716d1ca746215ca946c2f4c3f05d4edbdd499a94e5c88930e50d61f37b18228c515b379c26109820a1551e75bbd41789b13a019643b7386a867476b7133e57e0f30a7d57c81fec201efd48278bbaae37c6a864df8f9dc8d0cadf7bdbd9537ca4556ea5eaf0a549a77382cd83f0e0c50c7349f973d1e22a54f6c9f3e0a29d98bc351cbfd8a071ca87138a6731420ce30c34502492743309c9dd0d94c8497fb72d3f6b6df548013ebffd7e6d7b951cfa45f11d6ec90a35929a7a598536267c9dbae502c44fb14ddce393d4878ca04b29fe41bec4dd58984d52792732bde67cc76bf0d14128599deb2c1a4bf1e6de5c3b90551b69d4277cadeefc76bb468206e884aa1076f0ecc8d9adcf40f0c22d92d9af330045fa60624226ce6cb54b91dd1431a62b63331741f1c960587b12a2ce1f5232dcc155be1efadb21878cebb3e1da6f36121c56652931fcec072e8446c8e4e23f6479fb9e5f57b3047d18757c535e1358edd0f2ef9676445503e042c3c929421e9690d0e40c4a804508f7293d677f026d6b66ce2de0f8a5ae77123c62568c84a040b11d34d0c22e37e569054a2e7d82489eba520b7255dc5621924966af93f0e92dc72b16dc88bd8d91c26fc74230dacb524889ecd85fcd25b5ffa879066f18718c642acf7a39b737c63501ea25ebf11afa83662385ca35537410692e5f58319061bcb5fae8bce77b494dd337cbbf9eb7bc3ff1e4635cfb4953aa5a055758ebcbc8727d881bf5b5003832e6f138e5d1fce0faeccab99bde0d7afcf39b6983f39b64300fc2a10a34c503be41840a9a149f1f93cb622a669278d16df103a00f134ba6d749c760c2a033973078fc141f5e166f1006fff0ac93434a9169fe7e61779649b74a9b45e26ce04ecc9b2a700d1f521b23ac3a81022ede6d42bf7b0fe31948ea4ade03ea613b30633f2273f1955344420b5754eeeb4e779174de37a43db2fd351838c350387340c9ae0ee78954d0bd6fa11b94fb4a2ba46ca6490c753cb8437dc992fb4b1c5c0512bb3d97b8684e598f0d0311fa73ddac01e44c23e415fa9635cf8303bf74b3bbd8584da1bfc0e4fba45f1c56890dc4ac601899d798f34039075434200177e67591493fd978c3afd795e386bba2e234293af2ee16b6a60f00ccfc80682c2a04b6c4dfdf24ac12e939c5973b310f2810961c2616a75463ff80c2d1e35282c61c2da9ae814ed5cb8d9651c347fc33d166c01559d2d0ef0960e1d4385e17c8d2347f4e0600081d97429af46ce179f0195ebdabcac83f657c65b24364215d6c243e3bf96568c50a0e6900e477f2ad333d802183ba37268f5c7e0cfe7c265ef7eb37391794d8337ff5a3879f2f4a725c7f12120222cc23ac92ac2c6d920951b6301deac011dc159fc8a3893f69bdb549057b21b15040788bc42d231a683e056a32f1f40e2f09ce7c2787c40f48457adfa9beab4cdd59bfd6e6d30043e79b6c925c2c83894f9100a29b89478de170d161a78f5c3200c96935986e5d5a9c2c20418e8dec4480527632861ddeb3e9ce27740240ea6c46e55368a57662742fe99b7b09eae840ce7844bca69f1735a3d0e2de18e8a2f126ef97e3e70bab16dfc565fae707cd2ed8b6cb76a9bed240f429a92ff4c0eb153da97971debd4b3d8b75426ab8536f0a2ddb2d9d8fda3f574bb4a23a58b18634ddc61059470acfcf1af2372b79d166c6323759c66c9fa7350dbea4ea712a73b3d48158459e720035f0c1ae8a64a8cb0064f0a4f045016906e578714ccaaa1eddd45475a6e2900b93515a057bb6ea76b684f0ec83a3bf9df6d2efe6b3344ea1ae1fbdb9de77bd1d0ee9aecaf0502b4ddde9687646e421c60c41c9d6cdc2a17b52f569ec0aeb973749f8952bf015ae66d17822af3f30eba88b4611913d999bffc330724a4865cc6219fddae049a038e4674f88e574ac65b8b8ad1a987477602a725bc0e7571eb3e16a53d7ffb64f70f5f4fa700ef3a3d03970879c5bad5b84c789e0698171b539148acac96f809cd0da6b801c01e3b06fb5b7525b4566813bd4aa79839a92adbfb987d17a5dd8c2693770f3e15b4ab1acbc855194301b6af3ffa2cdbf959ec53de81ee13284306319cbc2ea745d67c0075952736bd7f6d512d63a4f729652f17a989f27231eeafbddc7fcb07c44d3920ca75cdf141642731ecf9d3d219eed18a1298121ff0e352e51a1c0a626de94c890f6b34a9097257ab752149c7806802e90ec2ef48f823532b31d5600bd3d761ccc47d2bd44c3789839eea8c37a2547f7adcdc85387d87e3378d80da3816a15b04893e72ed40ef67445b6d1fa1e2722ac6d4a66b77cc08482f4884cb4ec0a8674da7257077ca3d933d7ebf1132e533a6a2af242a524c30dbe10712bef02775741c60d8b789e190b8e530da71f6d3f45c973b3b0a9eb03b155d1547211fd48f9ade8fa95ed84af5a387b582c2cc92ad7ba59b13ec46946e2003d0bb569a5e12d3ef76436d69709242394dd3c22c81b0d57d730ed143b2781941936874ad93643a25896f0f84d9375a1c4e332927108739a78c6d218474525eadff774d6d01791ebff94d080a00055b4c111531e9751a5d4ee49af4b21977e25bfeff235825d4eb0eb544ac8cae11804a2a052ada64624d7d5f92eead2f94714226e8f144c3aeeb1d93b20731d2c39b33d33d2d33eb46a7b44ecbcff472592cab2d3bc81bae81131cb8ce76e8d0fdf24cb72dd325eb8399a5c1dddbdb63a3b1307c50976bb5f769992e370935e4b85c722381dd092d1a4757598d9c05379a2e8e48ba513a40a850d784d091e2e5e17853de569d7c5f92383304b7eb490f859843f1ce84eaf7af69496a49a8d1de2cf22b386e9b79b642898e020433b606c4ecf84fd882a422cefa3bed2b04afc5b0cf498f7ad5e9cb6bbb62d53ee1461ad12e7e5c698e9ab4d206b8a9a1c1e2e1659e3f31adbafe20186365d155694291dd9d1887598f360c647c8648d49e4da1d34a6c98de5b002345fcdd124d17f274ab552282f7923fa618f78ecf39b8256d61d1b8b758e1d04e61eeefb68cf45a7ccc84c7cdf366f67b5c1e84586ea685fd34df0fa2b600fca59499d3961417837b84dfc1f1d128cda6a8aae5fb116587a73e229444b0992fcaf7f58676cba0b0bfc50821b718dd53a8396e02e01eb7b7493e2594fa64c20dbb0b8d3fa9c24ab03329a273c1b53b75fed02e889176d776aa12dc455e902534441f7686be17ec6cb53dc1c9b034b25ca7f0c54bf010e768f9fd6841b3e026760cecbf4255a688e3f47958a67635ba27256a6e5499c110a33bc1dafa840f7c4e040c51f41862d58024f2a16778d6a1c0721c0446304ec29555f8c0b81b436974a8e4d72e7e63fda83efc3fc8808ad6e2832328f67c05ac728f2008dbfa40e969b4c2317118f4b8e86ebff2ef8fd1f5462748dc2208f9ea9b596e81cdd283b67bc5b7dec2f5863ae741d11f990022a1fa634bff506d0825f1143d08a94c1e43b3c4b6fcbe49b21b3c715dafd1262043a67ceed67940990cf8f85caae9d14ade3de21fe86e4c79f36a7fd499571d41a8f5fc19d2ab2789739e4835e0d2bf774610ae9ed1a419f101bfe9bd049d7667870c77146ad394f0551f1cb7b63d56d074f5f14edc9efdb37c302b4975f6728052eeb32dfa20e49c152c2909a818b50a4fe67030ade3e17f38e22e048b53c175fcf28fc1f638c3234645b0705f7c3a030173cf2f5fae23dbe7f799f2e2c0bd4ecf1f0da57b73e07fbaca855905e6a18a95958984b86774ee4ae4b118d1053896c079dc84116263cc94519c5cec03ff1219f9b1d6d08165f2c194bc2ebf0698a36debb0104b92452c45439f1ffa93180f9c6a1bed32076e4d417be9f1552c96ec350cf4dbbaae327e8fd9595683987a4b4fa07a4e7ba5cc27060b378562f1c494571f36367e0bbe100d3e00775600f8d14a7264df084e52e2d9b2ff1c5c3cd384d582a95823ddd25712f7f1ddfc110622ce7964549532e6226089e8ef5c55c2aba1fb4fa9e35bbdd7591ff95b78414014c79b5ccd67969722a5f40ca8d2cfc80c71a0ebeaf032dd9ddaf418bb11d4bdc07b9f486c2d1369e6b5c0f33fd33033bdbcad32da6cc4c97dce6e2fa6ee32e7e1c90f787874aa98bcd8c2d8d8eed3d7436bb8ab890823763d4fe7d29077841a390e097ffd3788aa7b1324ec6310a730400bbb56a36dd1bace7903f10cb33522612f54c546a896bb7a71b3d4332a49195ecb38840f907ed57d2d5be978ab98ba8a8f02d78414225a4c7276b366647997bdf0427f788433868adb623d98cc898b83bfb1dc3358085f74e9909e1ba27f19d9f7b90914122c5ffd43a50e76f3b73666301ff6e2fdc9c22c582a883caa759f9a9f714f77ead7e4d219170b61630068484f2f3eede978808cace187f3b4a76b428002b54db3551ecf6b162e1eba4a2fcb78cbcd38b571710bfdcac835648b5c1a6c78670d90347b0505940cabcd3486c74cf0d194214d976573305483d5b9b5e24506d0e45bcff06ce5e6cce7bbea2fc576da213e18f26330071de35710469afb55c099292de050c9f5909478c8bc68f7d09cc3b1bbda860a973f73c3f1860a6914d80445b18447ecead693bfef3fe37654380e40b982be1ea2ba208f36359b2f40616e9866992546cc12068afb667bc26f1d3c8a82ff2e0638289e6f2225f899b07bb6b5571d4f93ec6e934de59433e1477e97052f36c5146617097841e5a37bfb6a8e87222aef3baa755b1dd86055157256e1cfdc81692a8276577c75b0d88c47c6a3e21af388bc6d90af5935985d13b235ac9fc346db5282690d7202f7885b397423f38907dc3f96a94efb2ef0882955ef3b509967970c499d2a0425443a41a0311de464a6412ee77c6504f7a828a72a289b5d14191df68bb97fd5cdbaf49607819d9f44048b41f830e88c4ed07397114c3a5d54e61d016195a7541bb73b2927acb5467ae3f802d80e3c460236b8d068ecfdd179cb09ed22b94f8348de63abfc2a3ec40d698b2bf391f06196fa62c164cd95859386d8f92ad9923808f42f9330b951427176bfb93e81b5e13e110c64d7d79a676780df7568d409dcf6cc4a62721b24af758decd3d3b1fe800ef02cd2ed6ab434542bd9c72cca570c0cada3c929eaf76c3de8bd4423f9ef42e8e233184378502bafcf52a47d7ece644c2f5924f33ee96ee2618c100ac21ac1768fa800bb369697aa0e8911f180ec697850f1934b23f0fc73725cec5e76d824e572cca6ca3b2cbd728ccdd3abbccb60eb3a8a25a455c008ab9724a65988bf56024974bffdc446057140ded366f09d045ab3437c498e08b3f3eec41cd66a02a2058b4ac9cda1477762d2c27de92172e52aa604c779d4c7e30fdf8e8f301e821a0e60faf4e3f46887aaa8b25e4989ebfeed5fcefdb7ca127d7fdc892c23f103e6563a6b6f618610bf9d73a4694d3b7ae8b331efde1462865a0428731394d5facd4322a4ab0c9012cf222a05b888a2497e29391ebb0f2fa4d85d893cb53b01a3a3f01af44f89ec53374ea71de543e9f41470a9600a7c083af8fd8b79fea1eb4078052ee98c50db4012ca776ea4c17e8752d414bb42761ae38b8745f59153edcc3b7e46b54ae4c687f3fcaacbde865b5cffaf522bf0150af970fa30c7b3a724c5635eaa40a45cc05b676a6a8a976c5dd722d5b01fe1f9ae69d2781d33ec8fedad3787d0fead8abe54ece5955a32429e00f04dd27799d079074aeaef8b5923bd5044a5e43a9cf74b4777c40210545ab3308c0d145852a976dfec8b91fb7d98450b0649a8bb58bf312e427981135c568d24dbc087dfad45bf523242b4fb1c0ef34b34f96dcba4c1891848162e376dffdbc59c067cd7a55b73d00b3da1999f37109e45d6b71fbb28e2ebd569d282fe7292bc7357b14fa9f0f659d8628d7e7993e7529ec5b4dab9add1f0e497a121020b0957f762505192643447a0aba52315a2675c5e0661228836ee4cbaabdc67259dfdf9f8efee8fee3adc367038a2bacfc99b567223d759b5b47d4d31f08daab14c5a1d18eed1bde36701c80ac0fe2acc5c7071a81c8e5fd52ef27fc12dfeacd897f43cb71b117e4713ee73d71a2c6e29919710695a633ba0050f636a3baaaeaee15a6192bdd44dc000d50ca68d932eac74e57ff4ad14623dd6b18ea464fdca7499a1f477ff6e4f84faba7fa668877aee819599adefd84dc8751723dca8a5ac849c77fe44e5171855ec0d0c0cf3a0a2406b04844b104e01ed443ca0eccd1b40d5283bfb24d1075736f644560f2b02b11e23a6f94bfe916a532fc60f9d9ed71162f42041c55ce644da26d445851e73c26fd8c0d663a4e118b2c716a0fa1609aca4d5bc76422f89287919218bcdef2e6ae81009f51ecd4c1c57fbecc66098996b35032b4c4ffb698c2f4df17881fdf63c597d1bb41c18824d4a672b14b2069e527ad847792751f2c3351d605fc611d50a8dca63ba629b97cdc366b1d2b1fd5e2652edcf3ee187ed7fda03fe40254f446f0599c9adf4edfd422013c1af07107809554a9ba5a2e24093342665df91e248847aa9d16cf52be1a137bdea7c10b6d04037c58a0fdc4ec069d83978cef5b8b8c2f954c54bca4c4fe15e4274df3e9f797dd011a36a14d542cdf74d0b9f125044f0a4bea6305e08720f767bace65c34b18fc03b2b953feb7fcc30af861f25dacffa5692b1baa5d920e599a11c62ffa3b1cb81dca0538a6dc16eb2b86c23307c893ac568312b8a15d87c0cd0a8452b63e7ad2f29daee5d794b6045789d8e67af5d5d7a28b752be7ec1d53b86fb5c6d55669aaee97e0f8783a66ebc21d2f7398dfc4308a4464c1c95b2b499480cd3ff0ca468fe0dbcf89bb8c5c58a5f72dffdd4e14cc1ffaec873d27ecfe3376aeb4b1017a18a64a57970c35c6a723184fb5e0be1c1789efdad32958a86c57486d2816ffe03b8d14d3eef9e9f0e86c44371d173e8fcb67663a8dd1f6d61dad8ff80ed8433a814e81aac75f1f594d03b3b1b37933bfee47aaae2df05a98417a2593de8a17713498f038819ab66ad93f9ddc8e05cf9fd39a11b8b1282b7e909e66b37c6edebe9441b699dfb460d6fd2203d8d84f2e870e9ecd61104e478d928fabc97d79feef7c617d428caf990d09c0854b880d13602dce85804daec5ac1f45a394df6a16e33613db349c1db3acbc072460e85cc8c179cf93644e45fb85e2d54fb8b618367fca2a122f37967c5474559887e53edc4c9516f9c1d25d30fbb13ffec51e4f04767a179ba9766a40257b7db56a695ec1a109afefcf732f08887acc5aeaa1960b68c2e69c041a53aec9caa25000029a95c6610fa5cc6b284a215d7bc52bd2499cbcca4c891b0eb1039b0f46b01643990a684e21cb5a2e60702e7672ae4f11b129a1c70d80864cb0b7f08a7a6efd04b842e81f30737b73cb64f051bbc99d3c72eabf73b2f184e66e4e79927d6960ad6c922c525c957a531c87699ff4b1b5f51ffa1e1f7b0efd487a9fb30fd06466af5de32f152d18d7245819098a6ae8a04a0161cf1c38d3b3deda1a4a1a91d84c66ae456cafccf4b1c1a1424e2f96de0e4fdf4b0ed8d48f60c747d33705fb2062cbfe8f3b98663cd6dc2c0b3d9aae65267f58451f4353bb234087620491e66410009d2b4f17593cc1622961cb6abdd7e162ff5dbd791bcda4f39f1dda3c655e0a665bd9a56849600b6a7fe72a0dc96b4e60c83b7b82c1f2eba0bcf59727358ed525f00a5096fac3c91abb6e9ec78fa9d34d14b6f7b38aa0c72ae972820b3ae7c7247c5979fc6bc6031132e33e46caa7da95bbb1ee9b109858d11d0bbfa282bb1eeb1f0e9f7b566c49fc5ce39ea1b0956a2fc27795248f5a945d6934b78e73f505482647e6f11ec4a74084c16c6f3b63f45a2b2dc97b3eec757396c2af909ffd48359fec756d8597ad4fdc619135953f6744cb89b2fd0730d90b8a7eae659b0879d67200f9a296f0290bf57ae419483ca0f78a2fd813727c61bd61c0bdc9f2a6a046a0cf6dcdc162688da5d7ad7b4209216c72ee1e7a4caa7c3afe12b514ecd45c905498904c14d0c739cb7e899694d61f4a6e484bdab264c23f422976cc0224dbf0f1ef81e0a8aa64dbc5f5694a27325d7d2958288709cf6ee3a38c972378b70a1f2593b7e7bfbc74250ec3041021bacd61bb34bc5b7100b140c138a2b207a171a7978f4a6a92ea40314019a29b7b9fd07619f2a5977ec6c694972991c000be3d3d6e4cc594005a84039aa36c27d54f7fab5cf7576f37f9dcf77510dac42bd1689fa77127bd34d000c099ef2e5a53f31b5e6c300d9c876165625fb49ea1542a0cea0a67e130150e4f2c5c9fefe366d0b52be2915263cbd675ba1d1651b65e50ed729d7c13ec5d288cc0e3500025911733d845367e31a632171fd198ca274f33a9ec1347f2261b9e4e66a118b58eba495b127e19b02e2a8f1b712e1930ed3c5b578fa24d98144669a36b018be76ff1efb35105339da245be44e8b82a565aab46eb79c102c8c12ad331e44339f6ae962c721aa502a1d5882c286a9c47e61add0d44a1f199d6ab068dad3bbf98a3f4084cd8e2960a3279415a6f9018feedc9344b9fb96848cb0824e92e3dbc58fffc61f454b6c4a373427bca9d74f7785459862a15d2ff8bd1d5bc0c73d19234ee99a350232ed81491c5d03d17b4679f684e76c675b234453005902dd3fd9c76ec3a40ccecf3fda1c2c403034d2920b33661aeef2a9326f005e926921bfc6f58729e6da95b71c31f62fc60e627efc8e3a5e32520266dbd20ae09d4c0d4ef15b1fd84d8f6da30ba511172c0a2e48712b26909fa0cd45825d4d96485611623f6eb58a6782ef80cfda3176adb1f004517da5736972f18436d09159f0b26cae86b67c67a1347926da7bc702ba75e47609f72fb2b4f467cd17a457f3a46e1385d38cdbb6606349c3dcd32ff33597e582a9078a7f7ca01bb5389b64c7f16a86e8decc8e99fd3c04f1a83fa6bcc3f1a512000e9dd94193bb950a88f54770a78ce6463bf826d20fa58bcc04be31989f95ee8048f667fd3dddc67977e7503728c7c3c4a4d5cb34d0d24487fcb23fab950f241cf7239c9f8420b323c44e2b9822e83f554f7432b28aec2a6a41c55af9afefcc935eed6826cc426f81bdb5b77c46bd2ae7e63bd5ee5a3a21d93ba7c9618f7297a3739a5cf06d586153fb0a937d8b7b5dce592dc35ede1be9be5cd045c50c9438dd765d3173e3c11a73fd904760738687e792ba16bdb58165d8b5a048ae60d8054dc7dd3041188692e179a573bb3cc14e85d482d17339631e226fd455a0cc0d84ecf96a8da189b4a593c8147301b48f2f03acd3067da9b42a1afad8397df9a0d5ebfb88c2c5f1fc14eec90cb4b25020b483ae4267acbe9f46bd3b395ac9962ccec50e8f0b7e572c436290e9ebe3923c11ed945b8eb9a1fad4a45b5b6248db3fa48c48ad49b8ae867cab95054cc05340032ef1a961d4d8c2723f007fef9dc08b2333361b400847a484235519774a396b50ccacac5ed66241fe546c541c3a14e2f5c32d62ecad7eff3b11df2ee3285e236bf7dabab6ebc74551a9fdbfe33b008c5f3f97d6ad0df16d68ae715347b859739af99e23a083a23f85d6234f649940bf098ade06ac010fcae0f06703ef22bc147b7e03c01dde3bb76ce7a00e5b4eb9188581784aaf9d0d251cb715be7bc38ec9552d9774c8e8a474acdc8e7577ef038ac38e8b53fc6d2fd729e247ac9d06d4e31d1131c029126d93764b05d27795a8d11afc3f78cbf075be20686a27277ed019a063ece1e68b588e1758b2a4d2475eb3cf43cb6f6b312a2c73f8e43283d6636a871e11aa60c09b804a59796341ad88e9f866ff45bc35761f9ad8b86fcb68ea6bd4be03af576ef014328ff688bfac65c9e8f88095b3781495d5c857f8af46bf6ba41eee217a0490911bc05c7ac8b9367d0a05d925bbf4c813c3cf9a6fadb36304e0236b2e03c968d8b248a642ebc3bd1e2dbef4990e11d90b1388e6bf36212409aa5349542ee776a21a7ef7286f06cb4af622aa682e533af141593e571d8ba18f94ff96b2352e07d6f4d8c001ee45c9a3105715e56eef3d9fdfe26f3705b60273f549979d5cbc282efb84a8649b80e15291dd91b7a9bcd695f298a6bff3be2718cdc2a397891148b6aa150281e6135a3998343bf8b1edcd08d1b8d5de574384bbaf552afd2dddb945bf49173265c0e867dabd8d45c53a8cf98c03608df842a6cab7b56c7e250f03bc602eefd5df998288f3aec7dd44f94d1b273b01ef6ef36cab2df7481fb1d5f054cbc8c6179c4c3a84f2e51644ef528a39111dc5d74fc68129a90c8a12ef1fd66f1ed425e8504a9ba24b8505256e570ff088a416326022218590c6a239d0b55e6c2b06d1e3d764192b11f2c61d087589c52f92c69a7d29aba375a2bfcbd3018a326581079f674340901e75ab7611edec1de158674b08b53bd43dbcbfde95dcef9d81c09921b394bc28f707fd0ec91819f2ba1db68ff1212ed53d6ed1705c9c8a9666c48faed07d39f39143bd9b5b3724f118454b035a8a68f06816e8300573cff68cc252e2578e60e0938981f6f355fa0c01e9358ff356ae0b0f6e2f581988b6e54bd4606c1bc20f942a7448d1492b37e087fb43d057f3ddae973cb61f8a6806657514800eca01021216d374049afde5c209506ec40a96978560b93c405ce5a682497e39eb004301e1f2c84bd88e32a7885d99278d2552e2380c7419547e9030dbb0639b657a9b76c971997ff1605f7a64921b717dbb49aa966cc87fddca7319e5d380897e317724dff5a88d02638046f3c0a4a7e3e1ef9fdfa285df5af272689257f23e580dc681dbec3b67a594b202defc2389d4e46b4cf5da64963c45021d151247bae8248bceab977b0642fd658f3860944ea2498ac3350a89dac2f02c2abb3ce01eebdf462f0aa72f169d446aefe8bd4a20013c914c131c340e49ef30b05e4e528cd13f828c1bfb8e0200a42cf66a8648bf620b7e482d4e84c5d584d902c1108ccd35603667dec91854796cdd656ac8b9ebcb5862f090b8ec679d650997b264f07f9fbf034f306342db4588100c333a31f64ac741379b82a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
