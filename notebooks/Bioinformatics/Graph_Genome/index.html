<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fac0467ef3eda4360ba0a82784213abb81bf8b951535af190e8405a7517b3baafb3d7e8e2e729e9264d028acd5d859641fdd818ac8a062962e97364a7d0fad86f296caadaf2375a07717425e02264ffc54e0769e81a0dea7d61dcce44a3826d85d4bbde31da88c844bb703a803077c68cc4b6b3a196242c595951d15dfdb8daecd7da960bd376e63de299e867840a0d8391701bd13eb9e2ae6feb0c9face0dce1232fb84f02876872160b36a7a1c3fb9ffca86d7f557b35f8daa3802bcaf35be80b9a6f4dfdb38ac52cd32e1a75b368706fa5befc533cc5f35c92722b5e4dcf57708e91f5715be68bad83f21e7492b48f004c7eb6d802023e05ec78a2d3321ae5f3aae5087b9c86e40a45ea1a73c1e3299efcfde78ee5008c4def8edd648b9da10ad9a6cd8cdf34e5a3ded7a7bce992a416096214843bc6b4198971b4a0b8024eea24650288b76577b7a962c3ea50ef191165a8f0126a6423e8d64eb3d20006720fab833273b337c73f84e28b426306ae31bc3c44b341dd6b48cf1578a8589ada31b4e27a126c4fac05e1f84ac4558c089d8a4a29a4a6585bb949b7f336339dca01d8485f940fb8cf837ab2c8370d800bdb2695a1a2d67f7c3ab4ed9dda3ffebe9abc049522581c3cf0b0e83ec5a2225339df51a5d774b6b0457f3d2f276ba967dc4cca5525023b5e751600ec6cf5d0d71b94f17534f8eff0d6faf3fe93b54f0e7836c5bdc1afcd92420e9fe44b7aa14275cefa95e7c80dacf0f50b7fddd4348787b6a58b3b6a31aa2c0b4c28fffbd7d311196f1864cae3c0828f7041b89edec71568c580fdd8f9bd9425f3922a3fd2298dc0cc6a5ad14426cc3731f465aedbbb752a1a078dfd19695502bcb556cd3d83f93dfe26b493fe7868340b7dbe9cb10a6b8a5201da89b3241151ac38af8743f090671ea2cbbf28e370ea9272e26c2531c64cc5174cc5e859c18c7729ee9c812a0505f6718ec9937916ec127c1f4a23a673babd30194b349228662288c4d9120f1da09101eb3134cf437318f667dac5ccfa71be8ca82e3454e7ca361f7b5808ca3dcd8d5da6ff404d39df632173cd1580a94be40c88ac7a1205b83baa79f8274017fb11821c2c9cb9257854cb31ad61cc2273597809b7096500cf86bed168129bec3aefe5297d864be6d877652e22f4a11e303d09fa35ccb0abec07527a47fe7800758a5c98903bbe5ce1d071758aebf72567709fa90eab0274e0ce002f7f794148fb3ae97501b36a5019d940f93b0b54cac0af4d1ed3e4b78069ded07aad9728f1abf55b0238ffee0444f8b269fb64e59f3a62798177d77db6001c57a5a0e60d2c6571121680911580f462747a12329538cf1a4fd2a21fe6d9e2a81ad9c221e6c77b12169a23cad33b560e4afcaac75caeeb87ff2ec99f6fca29f53c60fef3a9ae74747e6d7c36511117595be36ad2d65a8e7a7b004bb17366d028621506f2f133cfaff5e67c929b4ee8dd3415c792495cd1d393a264139f34e230473dd7822131bb67594cc515454d74d3335c33b2d2a9a949100f65e344e6b77a28883032110cc60328a17c6834849867d2fb743e80b2e81a954299f150600178953417ad81e31fa5c8a47f8d85b57ec6c162eafaa48f60ee7ace5179ac9ed562782f35717ded9fd15024c40c434b4cd6d8555ae9bd9f8a2a65adc5d48264f88b54f480f563ec0f5c1334ccda6d7fcc0466d616a5617b0fda0384d1d6d96f0177a287146b8e73db40d5868f5967c6160181fa13b815117257be8bdbb78516515b56bffde1861bf8dbcfbf2b74617b9327f4a15f271c1404fead2b8cabc9c6786db8f4744bafd8afb26039852dab9bf890a652e1b74423e1e3cbba9d23937afcfbc3a2670d8388f6dadbb50cbcac1348122f7513cf880fc9b0bb0b9e04d7875f686011d2c89b7c6b3066a1fc0e2e5f70f4640faa6bb2de22b85b0be8713b6d1ea68e98299d0e1d6c9c93e3fdb26c508d2dd763033c898f0c60e00182080289763f0f2d26500f07e1b9773af373ff9c54cf1eefe8ded3e6a088040c25f2b8b7a3e92f5b884a675c1db5013f2fa7680c5fa7619a97fb785f03a683ab86f310b4586787b24dca14a05bb7a7ff0075fe0fa8488ac87e6f38ce187c3ad85331f93ef06067d94160ea997b3404cd53b469f002524a59f9c9bb2418c44ef0cfc8aa20d049f71d763eb082cbbca7285bf8d1d65260cfd453b565fe65ced9afd34b7dbf8d0797bf5a271cb953156c9a9f622e4331df263421bb83cb724ad6df71d2b8240e2dba5fc512665e9ade7cc76688f77d2d058ac6173320aa624af77a6b95d6b2ebb19237cc814f5a85b514293540dbcbb12fe76e9efce415df5b3fb78e070acc3a6470e094c1e82e8716ce3cf9f7834e16e9b5fcf25346f4ff292abed6d35993a5df1a2d2e13bd2876e7450dfaaedd7502612acd27ada8dfaacfadab7df98df07f8d1cdf087f54d2d68fed1b508e77bb78678ea6b42e7692f57fba94fc36fde9c78f11ead9617148a0eb9db8345a405c61ea42f904b859012593045f55f2c270444f8a4a8172cd2c4451110336e50bdf638594ffb5a883deea3202f426732dce019c83ae9c977ea2956caab0de2cf508d99cc43c8271c96d7c80290bbbe4ef574b16c50ff62dff879a6d5d6f0dd86005d3e54f9f7da8a91042644e8f246b774c1d747e8d68e5ab92ac9fbd4cb7563cc3577f773ba2d1ca67c17b53216cefeb5f2877a4dffde343cd11c9a7adbadc43cf9b18f96b89093c78105148afa0580c7e405ab5fccbbf138c48bb89f16a00a65de48a27f67e74f6f3a622c9a9e7c2f8588a51ec42442085d9f23dacd29b971a93aa79caf2c4acaaa9dc40810df59bb763e67a0e3e552cb154f02da34aae690ccfbe3923c9e9b2956b43c83d5ccba3913089f2b8a94b652fc42aa542a577be7a54d9d703bd5a178cbec7849669b1deb332f1f420fd6240fc103031dd7457bfdbae799815c395daac8bf21557ba34b981ae32040fd7d44efd202bde8d2baf9891076d04934710d866e78fccde45b1ce20d0eae0bfcc27855d20c9ede707bca77493e60550fdafae66d1eba8b7a06379de33844b0e4608abff0ffa549d1ddd9f215c47876251b9da34eca94028b2c1176452351024b15bf78393c7fe34ee5d5bb023a48c621561f4606188d2bcc8de9abf1b1e7360939ef88aa81e61bad54e3a292cdcbb7d98de59b7999b45fb1a19e192805ea2b2516e63a43b65374c13ccc3427200f41ee5e6aa8a9919623e4729f91ae9080f9db5dc5569826b1ded9ec99ae41fac27e19ef7a65167566613bb21020d46eb4305352d8bfe65554630fc08be160d5f2a0d0a22e3fe52102527141977b951660be56aff6fd4e72485d52ae020bc6d1c763c450865868882e1ff5b020fb1717225711e2d01b1bdcea5bf850db73f119dced670b123bd84d3ab53aed545b5af96a6c427f8d598b2c0be247f640764d08ea1daa9246e6fad8a1b58749c251374aca01cb0a09708dd38d0938df8cf7a8de175d12c8d43f01015603db6148e056d3e88be710a201fdcd1593b50f9733fd2d04a2ee6e6c28bcb8b95f9ede041922b2d60ad515c61d5bd3aad954fd76737dda53a8f5d59d4f1511c36f29d4449f909abc9f53749158b612c8d1ee0ecd433f53cef59cb5dea707b50b425874193732332e5ed481f2588707a656de0cb29360f9f95add87d0b145ef96e4f6170784026c653a59610d3034bac79e12a03ce95410b8fff3a15f5472729b3e88e6e094ce2aa644559dae370437d5d3dcba28e06e927b36c6571e87b2568f3d9833941ff61dc1d4077cbe19dbbd48f6031fb286fdc2357b05580e9a14fb78804fca5ffc00bb52249542439bc726f025d01fe6c58300914df4753b5d1a49af3ad44458e325ccc14c03489e91cfae6deb520c563746fc4292774c71f6c906a7612bc36b2a9ee13dc5c90585070e0317d30fd8180fcd9da957c6ae1affd8bd3535e380e5a1bbd5e2bf7d0b814914f1d163b1e75efb54eb35d7996e170195ffac991e47f691bd616122b61b8e42d7fce32c6a7059d3b2fc33821db60efa085b0c435ccc615284b9f7fbe7ae5d67fcf2ffa34e64496c3c0755df8eff233c9217b049f25374cdaa34409a7c11e76b70111a82374db2d5a6d0a26e0b28d021a9ac26c98f12d26573ad4d8e96aed414f3e875d9b4a0f9fb1228d08ef230dffd0afe39cef9ec4b9ff419503cafbb32e02e9908a77223a4fa9eb5d8509a146b020ac38b9841d760522bfef8fcab810d6b8b321ccb4585e9cca37403518027f9817c26742aba3a9cba7b1bcfecc2e33a6b382c7ed6cbb4ffdaadd475f7fd491b11c4fb90ee16da005e75712eac8f3cb34a70d33ed323f0381174dc2dea7f5733529fbe8414a31e92ced67c8cf89c19be4fcdf0cd8709d4cebfe4a8d0097a0edcbdaf735e2b209d44fdc568ee0aed0178ac9202d5e89f459c06e254f8c7f7c672506a9afa84e55c12b5d8f86341b30dfaeb211538e3b749fd152843b56140cd6daffc321caa63dee4a9e37f8ce9053c74bd5a79d7f35abfd8176c9e5364422750697ccc36b90158036677aebc41cd1f305a2d8f72a0877ea1a8a58dec75bc95b9480ffed41b2ffa070c662687a9737c554689b8067edf1fb4d5af4002ed5bd9504214fd97044630e742f16ef0d141a7f41dce2ef967e73d2a816fa246001a046addec2e4eb21067a71b90b5fcedd0d34d33e9f37c031bf48fa990a948e86539cadb791601bad88dc654068a5c974c6b7f3dcc60cd3c327e99b8aead9ba44f13dffe6ea8a346b747dac00bd0996c89ed8244a58b1a220c45e558386b4c30f5861fcce063898a91a6c9dfae5a95911334016b6e0973d233c281b6f84daddd4345bbe1706993c4febc7ad88a88693f05c68a63f9a37081499f32b993deeadcb6f260210b1cde46704abf3cb7c778230a944989506529fb60f2b3f8aa91995eefcafa3e939384e52a8c22e7f18a2c4f34142b0f62dc0e321d2073d9e739be02e359844cf80e62ba0ed7d9a30dfa9b060aa560953d5f1bce69ea54afac95ab134a14b70b29d6a1b247d8a3544ef544e5fcd67de85836729c001be5addf102f2d36f8662f2785dc317985b2b5390c17788cacbeb338f0e2b4b2fa7e13a257303e82f889d9d96080b3c00b266a96112c7b880420d8fea547ef49950361c4e14a65febb65557e9a853752b88a7d15fd8eecc26f68c30113f0cf1947c774d711120e7351b50adb5953ab56bcf6a21fe6fde7edea1c7ffbdbe160c20fa5d520c3f4a3864ff14a2908fc259be418d736f603233405e3ec257d2b4120678099ac507f50057226372841d99d7a62abc1f2194ae0c3c9bde7b722ff950bf703cefdb2a0414ea268334b0557f38e5370104b1a4d6616003e82dd492c1ef8296f09e95577e7b4b412287fac9ee210d4d219af20818a49ce87a450a52a1fa24f7acd9db94b2343efba379e74d93f4e8596e389daef09a7d9ceb745a524bd1f9f12d5f9e9603164c40775b2d8919c4889f06d1e1bcae0c0cc927ffea2be0779739243f674438e62c6a9141171a199baf5454c336111e8d765d7081fade4c1ef59dd4d3d22ddf03cc878c645afc44b47f796ae38d7bffa06a7c5de1e6704c3686c2f85bdfe88571c22af0faaf657d69b5d547b4e55c161ff2c0e30e8e039066b84c6808ee7359a63a49cb0c1c9b93c4f9a1b3d65911e96271b641f8de3f5c649f0d64f591abb91dbcb92e0474de0ebfefe11085c098d6fa6e901e6ec220507a28a55649476bb31e4f846b9cc270fa8d4fac438fe8b8c4ae5135cbb9d16e80e4ab72c69f407da47a1af0af4e074659a5d5c869382fe28293fb019d816e390e1b1c34198a47d68ae9ef335a53276f905943a1c6e6a1210f9de9f9c7228a05f1578b395f78519c322fb2a5fb392a6d0efe4ab75fd44c9e124fc773eb7b32f1ae8955115ec2bc36c46296f665d7180e2bdbcc849b50515b982b20c2e9932b186aa225a7b7d89183f8e89f6d4cc18a9b048ea9696ee38f18704e1dcbec8d0d4b6f1a2ce509fe552f00fcfe3632d8708816039520d91775fd6a657faea4c713ee38e1bf90be79d46109c0ec517fdb702d1699b17d6dabb243cd8a8548d0af06bef848addc1a89b5f8e41c06cdd238cc6afe7e1f7bcfb0c850c5f6a036e0a5239b2388ea9e992b416a12c86fbd627b7564d501343c8d2e0e784e85337825a9493d182b7fecd0ee2c1362876e36e87a3335571c4cefded496cb442bed590300bc3df2c7a2357f66b195502bcc3b46a07577d1c15ffdac181053e0e150bb9e4dcb7a7abb64dce0c8f2089c0175f71d42c7e28eba54793f40a4febc28308a772a5853e18ff5a0f857978b81bc4c17ef2fc479dd57ce85377c2fce608284ec224d73b46545f566a0e99093432abe668b67e6718d99d757573c3b6fa3959dfbd83d1dc0eaa57df4089e969ba6fd91ee808804a8868d04fa9f128f87d2cff1cd2926cb0ffe7917108ba2b8fa23767711182c704d5fc21ffc8f0f68bb6d692776ef0c18de4519eca2afadc46eccb6e8cad8d256cd40c21f794540dd64f6d040e46841f6d4d5d8b52cd3c8e7f221b5d13f4c2e5ba93c930b0d49308c8bd41ad63ca86d410e518243fa7feb978fe7d31ff6f1bb9b9b848e0662f2d8d9e1142391a37444481a6241e3a6db9e9c4c058566c59cb6c965593b8276228d15c9194460c13d698ec9261c407851e462d0bf4b97aebf74a72f81e996aa532568a1849d6a12624fe6155e1e10241b3ebe1697c94903e8e8c1502921af75b03f709caa47d87396e152e56738a927d70eb3f0931a67515db37f14a015c01cf8f57e1b5a3d7350f0ee645a98f272e02281e423f649614443fb81dad29efa9eaab10331407227a54a4988cf905d7360b802347697f2d308ae8a5ca7cd04cf5e7ed779a5cef05a77448138fd86cdba3eaf1e757411106802ccd1cd60dceca75e442903f12949a815a666528adcdee25a8e4039c45b5e594cc6497c94666cee0245fe5d4dfd9b1f89216386e42da9f3d9fe3a06f3279cee2266b5a5f7f3aa2e87c59bbb3a4b268f766f5cc0b6b8cd22419b06e60746b884814b793efbace8acd3d1025e4397079297f510dca607b71552a7bf0e54c6f9d0ef9810d6ca20a35c932433484ee57e42e3d3d087d10890b82005b4e36772da49b55c1ad9909dc8e4a20446cf795df62f79b1b04bfbd18cb23778a27a1c4179ffe9581a5b654d0007136aa7e24cc648f9673447a66ba61a8a97d53ef7f557df97c7902b5992e805abbfefb953aef9f643781567a06cdb86dc6d082d4c48c032f9403304660abaf5990a778a96819daf88355a6df7d5cfa4877a0758ae36f752133361d9f459c1b1cf1bcf4c02ee9671983c73fc78f332fecc446f679618d13560ee4de9f2caa8b40f2dc90229788aebb56eb8da4157e49c5d896515f25162881be6d0a387214bdf455cfc328c94baa8a8f8d8d7b5a4c0dbc035eb8b79926fa1fdf8b6eb090ca55ab6c37088f079766acd73fc060bd3555ac046368a28cd7a32fb57e3139874188c4b97214605cb4a07220391cb06cce77875314676549c778904fe452a490d531c19a12b8433e20a4c4938b8501bc653fdc7e88c9071980f3e4ea08c743bed3fa691e363c99b71dc9a22c899ca8e1f882865ef505b58c3c5f62f45454aefe7739da701457add060ee3071844e00f3b1250f4b0a90525009c6fa6b5652cf2bd765ee78e241704a8329b24352c5fc4be6ae9fad91f0b7093aa7b2e7086a367515408040dbfef7384ba5e209814129ef3d85c4fa4990c7da5024302ba8b7d4161dfc3ec4c0d5ba1df5c5bab109ce3038b16ab0846be41a440996ab03d5c1a5a1eba9e86bdad2a80645c88150e057696cc3ef14f5886e06f128b9e33af1c731883dac2f5bc446ca8bdfbf968af1cef28e9c8d9c4d867409f44e9dcf999b09bce13fcb36df1e75fecf897fde3ea4fb6675f8ffdda6bab281515709fbd92823272465659e09dc17ad39181b47ae3267be668a7ba2784b07c3f30fb54c78c256bfcc4ad0b34aaf6902c1031b287582fae01ac6ae3b229af5ce832fd004dc88f303d52ac6683d4c7efde3bfae2138edc8ed7faf18b5b08da7100d92655c0e74f251beb93a64b235b94d374cb61c9b0d8009fcca4dc567cf6829dec0cd01542ff1275d4b4e336986c2e034f0fb8801c07fe82d13345ca88ac7c804e697a11a26e4d85afa61470e7b6c57c581e77643caf71118ddbdfb6a6074faabf786396ea094d159fdff802778269c23a8772e7b5e68290cdd5bba702be300964c557c4fab44432319276e90f6242f3853d3cdcd9642d9bdca76565ac21e38d8c3082d12b8e4cf46d1a159f01495a43f50096b57f90a015488909eb761760972d7884f022cff2a79f45602f7957f620b6c7bc5c6372cfe5a1d0a8eef3b6cc7145900a51aab2e925382dbb7689d8fff1dc861118f4daa0e84c828a1f03656f4b5097a39cd50055d06eb5bd2860415c881db58f9bc5b3e1719884a647ba12f3937cd62e01153880b76b1eb06179eb0623bdecd1f49d8e8e5105c2b84680ba3dfada55b4367a0791ad69074140ba95c004863ca336d22d7c7aecb4b39e736bffe7e9186d68366d1018168b4fb9f2ba5ae39c45fb79d9f00badc76eb8e6ad8ae53afe1d5b90dcec133514c598c8b50e38ce219da4d99ea6632e8173a4eb97a3624954953845f0c9a21579f231601e0e246aee91131a8fa3809dbb8ea7690e24bb90f2774df00ab83a502a003c6ed2869fbda3ceba369c0bc04d22a8f1bcc0ad3507cc35657a55059b13a8a215ee18743fb5c90b9e9412bff9c5a1b10c1823a1314ed66ba12b751b0968b3012b3d087343ed6fab08b69092b634f5b69d488e6b9da0324c01e946b2b443bd272156f7179bf5f5ff5e3528580eb4a17f946ba399d4dac449f630171d06ca2d2fe1023093953b373b672639d97c9885663a95478a16e5e0b8c87a2d1ee3af98cbef26a18dea3f55e3a7c236318dac106e511183a853c638becafee0a05bb693c621a93192ad779c988c71ab15293473b3c1623e619286e75a26afb4d69d189d08463f523af30b752f77e2f63e5c4940721e1d794685aeb2a51e03edc628f4f524d4d076fc6e01ebbe24403dfe6a13f1baaf5ff151027533937db15839cd9ff60d4b0821ef1b2b90dde1accbfcc7fb42516c33fee171018cf4848dbd4ada44bdd6882348a177ebb733868a05e08fffe1760c35a911ac1b70c8f2db2e56535ad2b0516e46b1f773b95311b6870926d4884f1a8c9cad62fa9b7b5431e28f2dff09deace6fa769654cd26ce6c7c51537713c70e022120e4c1f317129ef828a7f5b0e88019963dd103215a6f1761bf1731747964a580fe94c693545314c0031dedcb0116e1d510cf958b068754871764bbf3b77382e375420136f59fd39330dd9049b4448963126922eb9f8305df943a48d8b6e51a8044efeafbea0225b280506bd51bb0a35a0244524b5d6bb54631f8291a2459988890bc61965f643a74018514ff6302d6d52d655ad609c1f70259a7fad86ae9a5df09943818a654bae1d244a2029793909c50d27f4eb327b758a9da0bfd9151cd7af43c3ada465abfd16963c4d1fd360a9aaa9cd3573bea732697d2bda3bcf9811c1e0f488701c3e361f91854855edba5f54f259abd9d170f03acc5032150246dbeef5ca629a3806c7c1cd77b55d4722665d00a2e6c355d17adf09680c89abe95e8f0b233ebdd9c5da1791da627d6d6d9abe1e7ce73302cd35209c814cd9c4d1d7081061033343a30d401773eb88d16f4123f50669b808aa69fe8c12d035e9c82b3b11067f77f9aca2057c616536f3979fd7d877c3c6c23faae3f275ef0db40162b078b6159261d132ef786089c3a2c1ea39767ca4ef42b237aca2b4c8e721aa1651a12abcb429527ed789370e16da435cc25de1a4035a13a48dbb96f74447de2873d4a01bb3b6af791a18bef310314412372d5e1ff25d88d62694fcf06687d136a26aa1942130070035064431e00539dae4de4d0716a9af5e16c1b9d535e4a9aa5047e133fbec89e077a2673788cd9e88d5df24b0945e4b2f3020b094e48095035bc49d76e20c9340c1d1abfeb7a78c9329da14f614abb102e151b119b706243c31fdbd4b33956a5a7f232d8edf86f39079a0ea15c4a2fa3d68193432354ae71c6c56a1efa7e0ed345e59590085305e258a5a9181e6a00c1a052fd430f6dbbf0305ae6f00162311df09eb81132d98a6c611825f8774b11f813560d342212ecb78a0cff9d10e81e5df5e8a36a7b6b4b954404232789c9d9e6ee591ba12679741e19189301d8d04696e25f028efda083b623f4b9f304d8832b974cb6317822ee3350325d43118c8f7ddc01c82d187763475da1c7e22664fb42def647d740c5932ee59f74f39c0002022dc0deccde3b1840b2f29cbb5895da723e69977e383f33ecc85e58e59187cee3ba041952dec682641863b92eaff80f692f2b64dfc3e9966017d1391692ea00b3e6e422ca49b0a08720a818c7c7b1b4e186f5cc61f0681f2c58df65018391035ac7f0d66a71a3affd20c6da0f36d7a272e09e37596154ddf7b69d85069768b8891f5a5096dcd898711479d712b5c70e8e0dd0324b8a6dd5134694876aefa81a4e0356203da039731dbe4c1d0b9dc7fb6f5e0990a2d2a8bfd293e50ed417f40c51a999414540da86e18b113a70ad7e751482322d1748f54a512d98bc60203b977a43c8076237d16876084507fd7111ebad85ae56fc0bb897a18f8b8daed22b9a7c4c97cb80e1d3d7fbe502b8ef2012901d41c36079d7ad1e76fb5dd001ecb5086f73c5f8970b278cdbbe848e0175e18c913815aa3de88b88fc60740f73c390c110042ec7c039296a9d2c760f912ed089695c94a96eee01b3dd775763eb1af6da72e367198e83f3e6b909e731e54931dec8d049bf0794a91cc94721060fed62128a8ae8c8205258d845e460bd4083211fb52242eb55d0b69722d1797e2a9771c3ae7bcb654c8e6812ced3050a78b69524e4cad1cf36bfda8f644fc52cb131b4b20b4d6555307f25cc073cf9a82f82b0eec256c2ce53860599d4920f434239b84e072bda745db4a2f923ff75d75501db491db9766456361a070f3f6420e9e2bc8f04d41e2fb07cddb97fc03c1a1569aa7e0b89a19bbc3d4fd78e7f4c86560974da5cce85b816e0a0fc9c92cfdc570b9d015e1167172d49c68c483fb6de9068b56de2e2ac3a48fefdf750db15babc01b71c7709920849e74567996cad40a52cfe321707ab3781a367526dee0cd463ac2d0cbfd22263a9bfde051efab738c34303f3163513a82f073e0fed280f6cecc0a990fe22574eb299b8ccec3466bb7db239f216065e81baf8b1de961d20aaee070be545798b7018486dcb847612b4d1b986724e6e4a70bbaa7f9848364ecaadf169808c29c3bb5071a72067e34d984deaef804643c9aafc217c980428b76c05f221e736f08decfa5ad331b1b1d8f3cf5d7351a7fa8f2da1faa48d4b1ed73a6545494903fecae35614f6fe91d36e162cfc64619f891fce225410e3a89ffa9a0d95a2bc7756d5a163ac84fc32fe0eeba7c134d871115205a6537ff417b94ffb7269e87dba7ead165364c321ac63d549836c961f033f9b6050eec3fea7a69033bce27b430ccbfe811b498ad5c38dd366328931fdac0ae72916897eaca1d40cc546058b566f5131e85cd624f5eb52afafb265ae5da3967aa7d27fbaa563008814b9c45e2af30aa7459a75a0a5024dcece4370136c56a94fd409b30f1755484063a8024b4d350d79e843547d4adc41e2ae2cce62a7b8d8e32367d6efd394aed07d747394e8fc4d3343d3ae17b78817b8133d662e3a5e2bc2e57e70ac9adc78a3f63476dbb9dd7766bef0d432bf3778a9751dd2b174d7f4826b44e2a061c41876bf056ec72e2299fe4293fbc168438ab1cecefd6e8c713a078d661b5cbfc81139e73ffe4fa3b682544a21e52c12caff913157ca6ecb185b5b61c3bf35555449c2651a7b16aaaa02bb07d9c63c23080f3dabf5edff0d2315e5898a7396504e1cd5c24303f4316e2def8ea8b2ee978d2236bfd83f92355a0d4c83cb9cab526a58399ba8e7728f14b827d49c43b027c67ca0fbb6544f1a62eda30195902afff1182422ef22cdfd2665ca5f21b767318bff8a7d596df4c2a72a55f1dedc5c182c5b3516ff4e04009a9d084d97b533d81e34e17833528357a8682a5a6660d2acc5fb26b5c2f16da1c05e544d92a1279eca439ce57d0697e9d0e307120face5da3b8a45a0a85099e9f751efa909936d42b7c6e25210c28dcc858c17d1c18ee3ce7068a0f081fada8878aa4d1ede89cd4e0224c2726a4120c302b0f04e6156d616e9bf765e7d68d83ea4103ed0484a6edbe76abea60c01e617e2ffa57269df73759d324eff7f11394fa478c17884114a17b53540961cba12dfe8cb3a7b347cf68957b849b8f93793592fedaec1668874931b18b5c4831e810086fc5f2c7e9c420c2f39018266a7899a5c0dbfed0260c8ecb2b4fa12fea18b095e55cc87f3bfde8516eb63ce082c669f757fe5a7d5438ee0cca492420a917f6aafb9095e1f1d55266f482ca2740a94de8a3052868a03f8d36423195dc927f7b3a40b5c8307fd52be6c9b32b3922cb62026433ac53415ec1ede45b225be8660eb00f5d41499a5139e41f0b1102d214a567f42dca48908c4b09639b5b69ba9a86b6a6e9ea41e5c9c710cc9cc671046b0834bdb1d19ce9123a68e3065636b7abcf9e86baabd18a79d37e49e04f6ca58c9311e00b83197b23a522486b7a49ce3fca2810c9290d20b66848cec128441265d9e5f82ed9e8ea8d8ff5cfa19667e407170c86860c270a295232ccd08d252a7923a91d8eab8113bcbb474a980cbc24f51f42c997718c5dfe6ba5d7c182434b92416558c79669eee0bdc7b187a1594e03ea55c1e944092a7653c257a343be28ffb1417ce3fa824313df77397c50499d03295c7cac526c5fe3c527735489aaf661dccc0c39d609758a0be5695dcabb84b49d171970d318f9929d28daad111e00b916b565ae2ff02ca4baeee92cc613a6bde871c4e6ca9f08c305bddb4b4982b83edde9518ed82559a8e775ccc348bb6cf717388c710191b672312398fc28503ae4fd3aeeb2ce61ecb8db4b09708d84be8d7ab7ca6957670cbd8f29796282db4b55c567508aac5b0f4a02bf6b6890e61b9d7ad2fc3894b1b7b665553324c367ad4952f090a4f382a8171cb4511416e1e505bd48b1e8a9d2f0678d13f07e56d9b526e4c02d6bb6fe9069a19a4da2374e777adbbad95ba3c92e625a76ff2c18b7819bd5c2e935211236c8f95accc2aa5ab55393c8bcfc7d50525614377e4c6719d146d78f00d58d3d793131378649f62ec00832b0635daa21029a62161b14f8ba20060a0f06ba4a5712f468fa0f3e7087b136c9c1f8157e61e07a154c0d101e2ac509495394b8ee1cadaabdda77db9a6f9e971bb974fd65a5636968522ab8e82d8ca470dad091458d439b7d6cdd208dbe0b83cd2c4178834aa96b54d6e0b7cfd5e4adaf74246322db3e2df23ce3c173ff802be239f0c70d33783643ed1827a8f65b438bdfd5e98a2aa29e07df38e9eb1acda7b09adf6b2a9bb2c48d61e779507be213b853cad7a32ec9965c66963db3d831584315a28296c72393e5a6600b8ae0ebd3a54122d711837e0e5ff072e4caf168778129d7fd43c7fa5195844d8e798e7ce163a07ab0efb856824952f98eae042f885893c95fcf277a3388851f5d35e95caed7b08f653b3ac9899e8cb9f030d682d249a4d314752a8d4cefef03830774bfad5529b26f33ac372ff77f7d7dd199ad0409d18eb559f4a13edd759390c882997b0c84aaa9f0064cc9d95db65955cf1813e8fbd939c59c0b1053c636e1b85062f0a21d00244752a35390052d1d3f2f8f4794b2813cbba0a426a15d772b1413c15cbe307bd0c4b440bbbc4f5fbc9aa792e54fec685f77a401e2e1e2e90f5b33756221c77dbf56a324cc98f48628efd644862e7a174eba840a6d774a647e3ff399c6b3a5c709642e5c492efb9c47d1df3283e1203eb291ab200ecb07db81e96ca405cd4bbddddcddc1eac5b216905011740ba20bd6609678e7f0f0de85cf80f4971ae9899c703c23460c78c763ac39305a4ffcf85418417d40c7441486f7ac60b02b117073aa333756f0c0e8987dbaa5a23ea4108e8910ecda4f7d8882e463882292d7978856f56bfa601abdeabd71d923268d3b4c5e56c9162a47ef5bd545c77b53ead40145119acc4d85dad1038073916dce1a5db531d9a0b02b76bb67c3ae189b5f8e01c33f74a06c4f29e31a0972b9ef6d3edd1a92156cc27cac1369710ef62ae10b3dcc3cbc5f280b52c94ffd7873e37c7d1fa6af8d90422362fbb92774bfff526e8da9f9838fea04c5a167a8ad7bb974e21fd41053d2e0d043dbb9b174aefac4cd2539cd4541b93dbab0efba8c21c8278216aeb158cb4a83c16a77de35d54cb4e324a0e6ad1a50677cfce92b11913299d7f9e527d31dfb6b27751f5744c3d91e197783d0016da502966f4162b276a7eda863bdbd4f9f06da404f5e2432058b174f92c5d8017228c42f5b946a761c9e5a02b30d1ea51e0e7dd8af49536446f7310f5147026b38a338a9a5e9f3abdf6a2916e8229f1bd48764248f60f13b934a6d199278e0251e3ddb908ef58f9485af3538a7a3f8e5a86fa728e1ae6378ef61154d01e5d8d647f87e5607aa325f5f4c2b947e6bdeb9271c4e23e086b79e7d6ebe4a89ac3cbf43db06127a74683ac1ec2d0f2eb1708b1e236cb8f6d93a3324a538e25227c62c0eeb719895fa4e1ecd89a3ab5bd02fe3c4131a4215175ff2a2d02885d0b3e6fbf5fd1139af1081676f4e8c7418c2e899e63955d0e6b4a217ce61af750c0bf055d9e196a510e23df096580bf4712799caf24309809c162574ba96400365c0ea5104a9dd153358cb40675711707ef06754ea19e0914c01f64b76f4b804c79e4bd8cb6f77a32b39477ac16047537023c2286121da2e84c470d96c525aaeff11a6b4d12d64f0f9a2f2bc63031cde0262389aac6761c28733397bc060d44a29503373c581942bb23716b2b409b56104e889342c969249df3d0e5ef3e901e789b07e4a251e5650f5237f8e5185bb941ce047eeabdfba37b4c586cd183a9f7797488cd8e2cfeab9fc7fdeb05e4375f300c9bbba041f4f035bc2e29e6207fddbd3697d5de4d1a8440a4a21a12236a32f9367e6911e4658c6393364f2f37d1eea6d144e24cb26d44677e336234a5094ca5f356f70446b240bb6f0d123051e64f89332f44727919c5fbd27c7d930d12cd31b91eea2f9a0686e4d93a5e94c8d6595d8e066812f8c194b869f5b88e647f7a58648c6c8e92ffec65b4c45c7a73d0541c882d9619a8d83d3e0f3f5185b88b9dda26821ddbd09e3144d371eaa885c43fe476b6ae30866742414b3e582032d3a0ebb689bf2744705ecb87ea011f9bea48fda0d563f5274dae184b65af9030572c28a7408b52533ac3e00b131b390647fc71b7099306553c4068d22bd07e2ecef5b6ccc2327a344d045054c1f65a88f880ca7933f4c2b1c5a28e2e1cdb360234fe031304aee7266c16a0fc5b239e2077086f3a7d312cf72f216a0ca935198e24c95825520f6e092cd6caba52c6c7f53172de6066cf2fb428b9cdcd5fb589c8574f3928ea90789d0820d32b4ae5f57b8466cadf3ae7071f92200904f84056942ecbb13c43b574f772c5b4b4c4f3597d3aa9cf760aa656fa7cccd280376453928bcfed4e96264edf42bdbbc85a2eaaec2a79b8fec39e14db29cb2ae77d315bed916cc4c495df019495be40ca2e444dd7cd1b000f3b2dd86a395f80bb04b64a32ddba28d887c6917864bbd940779eca55ec232d37f952a4cbd89c66caf58c30f1de49d2e8902a8cc454066929cd16a9fc65f162e8680a1b03c73e8f19a21e3b514b2df0bfefc3df0c374e198ff7e39c595b22f83d23f9a8a7098fd3bdc10db2eed3267d64491a3a7ee4aaefd7247d0477a1761bd28842892b0d389781bc878ad1fbe20972c946afb06413018821f437c2bc5706465e5fe5300e55c7a51a1359a72e1bb219c44089692c0c5fc8602e8bdfdb067eb86a06f206cd0987e91bfcafdd4b856fb070598dd26db74053eb7c0c141fa3bf5cff97c5af040e123b030aae541ddbbc34b04176e1c2676ea9a20927578eeab11b6cc532476598a8b36a81d6f1fba132c512d03e214cdd0e9b7e521e1ea4f93b403ae8eba2e593861a36fac16002d475ba2b013e3adfab3f77d228ab6c58053301380310fb7b00904683c1551ac7b6546ee5b44a570afa85a596a3950418ffc249ba443acf7fa878789d196feec43316b6808234d239754342a315057da7a55ae6df55b5387ebd78e9a0f56055242b925001478b4ec3bc6fd2ae5f17d30a297f59121edcc279bf7012cdc17253ec9cfc239a45ef7c5202a10298b05aea6bb7432eec59b34120192ed5f0bc3f60945a8bc9d565bb25da5d03b1906a6be500b18f13fe989b884c65e85cf5462ac252a9aaec21bb0a8fc5a96515dc84ee3ca5e42c772cb55a520d664c0d85ba4956cfae0c733840be1cdf161de2aae792dec05d97265c2662e07d67fcf505a0fef223110790bdde9a17726d80300efd63c9913c96719e888e2bfb44a1d6868c191d856517c540cf7d215349f778fea199e5f7800c26295472bc9492f1adfaafa96d9b74a713791f8ca0763b3d7bf1dde6350a83748c0b5f1f0fe987b25c5ad5bf6e007f53531b824796289fd3735e4ed434418ee59e226a1cdb7af3801163dd4b137f280620ee11ee2b20feaf6969d07b10ba04af765698b8a98940a5d42091875a647c1344768923de5fafa2fba1e58498a08f4f6252304d6b00696df60daeac92a7880d249857e1b42f57f3c761b4fe0a9e19e86d08a735e63c712811cafc008f13c7e23f42e81bac325b11d5ee48faa3dcd83564e71526745c6c9f262420b1236888ada5c9f32ef75bde1b3bc5a79cc4d98d2035cc7d4cb97b71fa4c0524375d90f73d08708c25c05125f6143832108ca5b6c3d795733da97bde128b1948a412c6592430d9235b2af0d5d7af1c89b5291927e7282c039eda726c8033fe0c05736757c683940cd3ed3feb5dfbd83119b73b0be7c814c1242a43ca57c51743bdc09c6bae05f01cef96ab935b0be7defd0dc5d53bfae0ea2ad280e3923c54f1a16d4b148884bdd92db0ccac527cc7a00b7a1ff3d137ccd5b71544bf8e42cea90b9fbba57767ff31cb47115fa73dce3829fcfe8adf284886f2db1562cc70cbb0123fef8948d7f5100ecfe81df4b85588cfe88da061889a20e67dc04a3acbc21ef30606fb1a5275662438973499067d6874c53c952c095b5360f58cc6bdf045e23ae98247a7f42bef83cfc3515b5493c1f2c2a46d3ad93a673e130942e9e43f0f12d0897838489d89b0a275c3bec70fb344274636a6218cec374e8e07c73cf02de7e364ce429634188e549859e8d73d69bb69bcca1255af09564ced5ba8aeff58cf7f853492fd76395ec1f55dc9393e0dec05646cc310eafa1cbe0a6c891858a0dcf26edb56221506363cc89561b876e6d8859f51f3ec3d2c1ca512ab4c5676658fcfb3d59193354a0059d36a057299d23ac2908f33f98deaa03e997e6bdbe64570ddbbd529a8f529a755aa423c295697babc310e630f9939e33849208c10e97e19ae8d7ebf4767c7d74cfec8fe4bd188f51c6fab7e0e6744f04402dc202041f2bf0af0072d579b5632e48685726477d79634cbfa33322cbef0777ec22cc778be8a21931be8965382402f4fd9ff25e6ee0cee0ad31b4d87fa7593b16351f34a13d057ba17b09b7149f2563c1336c1f09ac486109fb3b8e8e9c23e7ec764e864cf0e0cd1abe206de00c9ac6a5ef1f90123e936c025be5a8137543d97327854d686f40958a45d1d794824ad9f6d36ce4842daf3e5bf441086ad7b49c43caafbb28178ab4dc9827b9a0512966ae36c8b5d65f44faa2ef6ae474f7376209a438c730cfe0d22481a69871f2f9480310f2d84ce1b769cdaad05e0d63abf5122a88ffc11b9c45fa5d8e6db7fecf8a450f7fc154b01e14807627b64fa5a08251a62e6dedefc4f2a329836ac2a0e9661b97af476d780d413870ac43c833b41cddffe525ec1d6e334a0bbfd1080dc387e81b9ff37bea5fff03834abc6671dbb0c25bac212515a506924c83bffc57cc17c2568a7813c6da804274c274eb3477d1cc46a54d5f2179140de1709d0bb23739872362232ecb52762d026e8737e30f5f45e7babfa0d75951db085eb7885797559b98e20f4ae363340c60e5a369","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
