<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ada7fb22de1f24e1e620d4606d542b5760e748ee7c13b9a9233269075bc0e06100afe5c358221c172c411049f45267dbe758a7e246d4ee6548f25199db5b67afcc97dbb58c36d135203a37d49c3789f64f1c61d6c330717ee07e7a99904709f47b8827f250e5079b10611f653a41f6a1d2ae0103783af44b572535f16fcaed6e073d129e2959cded2e9a97ad24fb5b2385c84497d5a416c77fa982b41ed6dd1ba58e2a069880f8f2d79ea91fac17dc4f53c070b5777a8ab9ef3ddcf12464fd2d030eae0396c457453af4a0a241da1b931f5db97bd5236c7eec2c8759255c5be423127d68e2a3267824fbc0d603a7e3270eeb8f792987eb9be1351e61b750ed1d079c8197220932542fb9cc12f27d9fe22a5c8df55b94ec6eab330cf7a96fa431957a50313605099c111765602eea7c0aaf1d6d928cae4d4a1374689f9b8339c2b82ad1db6ea253ce5be89129a86e615f6db1a3ce473d9a4a30cc0832d7f0374131df22707f8349e44b14701e81af18aabdb5ff33a23eaa2629e8b3409e984f79b00da5284c228b2c7a2d0ac25535e08d326f180c343ed455f4548f4e21b327944bcebdcd0a129a645850f06f7b72c156af38122ca99a736381a2577179199ed4f7a8d71f1c0d35cd7cdd9026349e809fd10df485aa9aad95481cdf1bcb38c2e413b5862e22928a6cc1982aac45a6cffbca6ca32f53016221e0b98ed323f9c41d7966929f33da3fa487ff395a532551919ac79664d5805709848c07132e83a616919eed5954bae0bc828816e46adb95c0e9eeef751a89bd747ba25efdc28b315a37c3ccf16a07a41090925538c41aeae7094b930b8def75b0cd51c9fe08f6c6a9e385a3d3d024a1af4be015160d69ab1cf6b20a5a5f0f5f5da010f4ce5b7d901609313a335e09622129e94ace7044630cf2a846a82a43b2a2867ca221713cb6f1f36b6a77b26adbd406cd7ee17667fede3ad882eb5744e07f79de3867df425bef981153d666dc98c8ff4fa1810361f3f4b01951dd16bc63c55ea795fa0a4a6bf21adffecaeb3657268ada5f93555e8ec920e623ed4732b24640e0417987ea7737014e03a858eb68b3768e3a1b886b2e8224af976c1b6f53555d49162222cd735cfea47fbec6b904017b4c67969af5b6f4d094e87a9581e7d6cbc05d8097b3d8cede5c19abcc687734fa2bdee4902c5d13ef7dec7129fca5e7b4ecf7a847be6b311be2e4cb7742cf5432d0d34e7ae9672ed099d7795627172f232b3e78fe342c9b1774d68747b831ae575f3cfff5bc144e0927219ab880165800dc9937cd42f302f869d7497691b5cde30fcbf20537a370d2caa655a1a6e5c3ac1d6738f7a44e0e38eeb4fc00b51890a204624a7344bfe402825dabb28c52f5e1c944f52cb7c35ac07aeb3c9e67fb2515c3da28b1533fe61272246fec1a22dd0f3508ff0c42515f5e1ca025d15617d35b79a7b311d7dbae760ae5729d50ebaa54fad3c4e261ed0b905c764019da26fb7ed385317305316d01ea47087de88ec4033fa8593caf247e0c0518f514515b2925bb5142097e906c2c5438077efae80e8ea81e1c04aa8fca3fae019a4f7281df43cf74737f6aacbc6b2e95d2fa6536c389bec416a88c56ae4b1f58e8e1577b1672e7d95080e7c9ddafbe2a3284ccd70ca0234216296a457682986b3236cc80c4ced08dcac43461963a7c153023a26ca8880bbfaf0ef6e74bc2f00b2b867cd58935c7e00cf4852f9d656f6b08bfa4297700533ee8862e16c35475fd8a313f6672e27d649977a24115c0defe00ecdf633bd556297499d526f6128e6b21000f8125ec5a76371d095866d6f3530f984d31bd99a2ea769470b48a60444f08183faba40d7d312ea1ea79f1d546f28cc278aa5810e6467b0db55d47dee13e9c3c9959c41956fe812f76559fabb0bd539da3d7aeb0beebb3d104f82a915e62f021346ae660c14cd8aa7c51971496bf80a0ea3d5889111f0a3695089d4dc3c14efc0ff0371870c8429d50f98beb8c6b48315eb5c0ce35ba7d9f4a6edc29bf08db2237490c4ab9e1090e44d2869491e9aeb28d47d53d96b3ea4b235f2c8fa3f6420507831111d5146a3564b830a8746a703751bcfcf94fda6d225c52959985d07d7cfe816907a85cc27c02a22d40bbcf0a474765adb452da47d34fd314c4d5e0dc48fc6686c48048b9cf4c1e520534961273d225ba089d2c5be31491017aa656fce9bd4800a1e8007a01ed1b7c807561a7b54194b20ed0e44b269b6b9a743ac3eb3810f86b60d5115afce08f43335377d6efe563e138bb0fb660ef954ad13c6ca5e5004381b20cb66aa991ecd6f4c8115e66fc789f97a2da84b8c9b8afe34a8ea4833ed98ef10b06e341f0d7367e97b5ccfab5b8e511cec71b67538d5d5b712a49e773ceb7cab2f7d8ef195c4c56a7d7c208bb1e3bef56cbf33bc642c6c7a89982d47cae1b21f4f15c7731e6d05a36c5a2f95316951ce85f38c773e729dcda839d1b4dcc694a4f4e9b3ce284bc377968846d948d328a01d0156a157291a47a46524455f9b6e11b79b415d2259fbb23b379bf568260533690234badbc4b209f41f012d59041c3c2fd1af70154291754b3ff5b686ede451d419fd3cbdad72299bb577d124875828cd4b03ddd94b0b7f1deb571dc259c2f57dba86a5d9143e00ef2cdd13c1d427d10790d62596ddc19cbdaae896d2182c0aa6f5d0521b86463fa685b56ffde0ef927f497877f7bdab92ed19a3560ced9fbbe361f48aeea8ad4d926b87e4055dab9bb5cf83c3cb4f01069a290c69dfa889bef7aa5d3b2fc19e31ee0bc3db640396830422972a93442c96e7081b31c5b4679622950a41c809cfa8f69902f5bc0a6084e6e01d3ba084da1458b9edd60a113355824dace1a9d841237cd1921dbf18e89d2f35a027ecbc201d4b39542e759f5a634f7f2a326c50768ee49b97325771ed49dc146e29c41da9b0a7a4f71c692881dd29d954ac38f7efdd75fbabddabb029a7fb20020bba107ab5fe6c94485338ca71e8ba1388dfee4435f3a5d49808bcaf802bc11f91b55f75399f292594c846f0724c188dee6e439c40ecbc49e44ab32aa529b09e2f5586cd5f403e365e2ebb3e9fc9f0604c22beffe9062e0fce724a869dbe3d90c10fd5f5ee3bf1f72aac18045eac1f203a98420aa37fe886e70248ef275e22ebf81e63ffd8de81499530cdce9455e0ac65a0bbf46fbe33d78f51d2ccc2468dcddbbf9aaad7d8ac16830f29ff563e7892d3fd49c020ecfbaba6524b7faa5beef60837ea878e03a70af2e148d9fb64dc7e026d5acbe9987388942f7d52105f2a55c862bb644f5a81269516299fda904f0ef86b8db252a931d96df733b1c21cee77dea28bea45aea2d1e90212508422edf2752ecf31c9ceb7f4dadb39b80d2c06e113d4c89f7118bbb95423954159dcd58480fa95c81a909bd05142ecceca246e31dafd645342fd2140319155008ec3f3e2d564a570740d8b13d19e80a8695ce0e305ecdf962afb3615865ce1883998862ee42c122becf94ba247ebe2e1b3fe58fc8a78cfb6feb25a300761da32efa68944a0c36d37001e4373bdd956cd840f0e784e0169045b76bbc0a7bf4a2701ba4479baca21302441496bc017f49bf87ae7497472d41c60fdef7bf81e28509fc102c1d6a12d43259eb9cf7efaaf4e3751df4768ec5a1c10d3811eab6931b0e96f54f71dc7be860e2f88a5c461e33e0983b1c89e91109b967e9b823684070506fb552774be081aec034c17e63dcfda04614fae3c31480c5e8eeea4bc5ed2ba96f09de6fb30ac1cd80a063f6a7f54fb551cfb774d1747f4b292840e99d718d0d02851682dccef4ebb8ee58d9b2251fdf4e1a40742fdfecb6f04b2ca5773259905d24e6688fb57e5b690ee507e4ef5c5a3cf27f5f2ffede3938c40074fbb5eed55b56ca531a81b7e03a525fffc13ed51cc2a80b5a56f88048abb9e95ab746e42b3a82a9f73fb7bf160ab2681d00450550d74b1242a87e6b1b13db8212b5afef302a76f0cf87491eaa09f58490a186e30d171693b3dbe32be43e52a29a68162883604e18c87f97411fd45407125402418d22a38b8def73aa20e1cf717d5b6503ca3152d921ce690530972ccc9d5de4a8440cd4bd5e9e7333440e57d00cbb46d268dc7ec88e3f4d138cc6f185abf5cab3684780d1a7689a0f14177767d83f08135db4d139ab849e8b6b26e63761c34d51fa48a3b038bd0a59c809e66680e88db1698ec34f86294b52a46e575219d3aa773a73970798f55e22a20cff9503e0cb7ce94fe8122937935497d3764567888a46f2620b5d69fe5d901b0a948f70dc2afcf5e768b54537e8f6deabf2816d174863b21a50d1bdff7c181d2ef428cd0402877b2b4241bd3f9602de17d63b09d203e66569dca28e8a62acb7cecf7a1c382c60434e273464d5855e36b90f8d8897f82f95ca896c3bfb3a57f6cb624c08e55a4797e68692eac2c8377fd8997de6124ac6dadf2bdeb4a734394a2c256fd73dac3d5b04fc3a1ddf3a6ac14ff494eff6ed1c2602020eb6693441aa3c09f8cd1a862f327ae029380e3c14aba8b0a894da40740f12f32c9098dc4e877e680c33429d3a3641e3847e27a9ef2ab4ca5f6bc0bfde1f6efc52d80b3f20a17069166699d89c64585bd170383a3906a7ea7814d6a775f523030a96181ba1bd7123effcc497600cd40bf94c31779cc6e9e672025e02aa6585459dfb689efc388e51f670428163f6284516de6451bf76d5148c431be3920169b554773b3991024d789a3773b62b198ff98e7a13db9046d35b146263fc1eebc1c4879189bf5ed0490a553770b5abd6bd10e1167c0bd5d7bef6c19db34b873dba017e327f0ad1df84d2bfbe60c413c683e9bade5ddbc6f2a1dbedf10954d525b64054899c0a7ec37cf81b98c3db9d88dc77fd5bd900b8f732646b124d41e6c3402988ce5407866cce2665fb8d118296c0491609dfefa87c27ff75ceb41a08252ecd8c794c0de5bee5049f6156a38c52b51cc1234dd94fd9acf156123335cc1446d401197bd75e5e8120aa29b45e36c816c256521e2343e331e6ab2fb0162b0360a20ed5efd5640283f201deb1502d47211dcd759bab8cec7f444abb4f8b100b59bdec14fd4a33655e162245abe3bc3747971f910388b40b1cabf2b8ad5c37a8df0cf0383ffe7af565f660caa81c449bd6a7a3af566dbb14061d7511ab85a666d8a42497c74faaee25ec46ddee152b32177d43a1618a14751ef654286e6b3dd6eba30feb8a089903542ff0016df16c12c93db89ddd811d4d035361bfad3b51fc0d115e82051e4f0a8b198669278ba06da025e70beedcd2e5009c3d75504773979d83e4b2d059df496b757601dcb7281da3bdab211fe8494e2323d7988948ea0ef7570a410b18c9f00ed7b34ac76e829ccd745a9c7caf86cd517e90f061981af7fa1d5d3035d961e3566ca32cf8144bc081ca0e1d0be4f787c6cd31b7da88077dcbdbf6fe89d54133e2004167354ab5989a44accf8202997efc27fc5ae12725cc38c72300f509cffd5ed9c102d337a6bf9eb6b2f3ed93dd03c8220af28b7c3c6661c8e87edb8cf22028d19dac518a6488ad0f2f8128f8a94cd71f571ddbcff29ad80c59896d2d16dea39102abcb9aeb7e7422bbd1e8c6172a3c20f7c88bf886cd62a63b64dbfb426af168080d80f8bb48a6b8a7d9b889622c60b898d512b7350165a86b1d776ba5fe517b5c51174725989e987683ed55de123ff7f6852ae1b118b0e851b74c890f76e1c47c84284c134754b9d44c0eff2e0f6d4647716ffa9b2b9b6048507a8d8f54394b6b54cd5215c5a93390a9135d0df7a85127e3ba02bd689f6b759a463443f7e7253a26b70087b9425089cac9a3e3a037af5fe2e91d55c554f264513985df256d54cd4ea4f5e0b9bb38631ae29fa3ce1b33570ddb0d0a53a79cc64ca663dec01ea685922747de5319ef44217231dc52f8bb553eac6d5cba9f0f1e9e069cccdc6d875a2e0b808739f78c00895dc6a04500c93ea321e9c6d99faefcd88e619a1b6b5d8e8268f873f0e4f62a3dabb7601213b996c70f4885006a165a8ba5259d110640d0b4cf29f424f0cfb62154f850cd77428b76a58bc7773fba3b5871e4aeb0dbbbc3606c18ba0dcee773909935ec7525c9e7b34e02f3bcb298d93edb935e45d1c9d311a2e7a1dfacd531142ea301be23701e829d42c28b99230239486c474f309fcaac5c5919da8a027ce92aca71c710ed6cde4574f8ce319fbd7584de7a6c8aa40d3cbf0213cd5fd9985a225df8ec751b3515fcc884ff77be28fa14322b1f4eb7773dcba2c85a0083010e4ffd7c6da287e51c754d544d9375c3ba2c04c38815d3fd41631c546cdd912afc7357b48884817f2a0979521fe9d8e736e420594e444bbb03c08ad1193c3de2efeb7d9f206a34cdb7d893bacf218c4ca45fded82e60e7f332cfc348cf3c1b568857c2db110f1c6e6261e9a311ddb27ee2e2bbb79ddf78d7e9a45cbe5024e79651e8350e6450ab9062d804f9d79a7d45df45c122186a41b290d6ed1f6611c3fca13e95847d884cca5b362320828638de36a28f39fdc1ae750f8e92f8730ee2847dd23eb651c7fe82584e01d0d9fd1a6510e390f9a6721d68c9852fa67c2e9fcc4eb0eb4bc1f64a2652cd418b8796ddaee6db4db5de55eec1a80921ac98cade973e1a02e6a2cda0e3051ef09a079c17a9e4e38406ad5dddce567463012f2011aeeee4032d899e5d42a2cc702e8f9862459d8ced558f47273f2b5d7bd14a9b5a211c66cd3d2cdad828f5f478c7d219d51a2ea870f70a4163c2bd5a0a2a52ec49644d340c171f2ec5bbad80e2ebf652eac309dfa91db33391d9b7c7bb739abe671641706d10610edbb22a26302caf1735146e67fcda5e38d764b3f43e64372e8da13db5e65ceea66d287a539e2179d00867a7e6a2a0a0fa5c3182b7c566e6daf6bb921ac725773c7d9903b83051b08da1410ed8c144611d43f1e97dc261b86c195c64e3e2fcaa1db45cc976afc7f58d72c4611c13606e8ec3f56955cf258bfbca2bb961a45f564f71e621239492fd434e8fc1c262ca1bf05b8698f0a3357741ff48a170c8f5a8a5a449ffad276d4e174a05e03571f27241d8288c9e0f3c18ed3a7b6f7e691bd7a40967a2b3586d8de5cb99cc01f153ca7f4c66120185cd8f4b433ac46da8175c0f0e13e61eca594efd28f3204c8912459ce55deb7a440fc5c5a955242044c0ba0c30a0e5685d2c683516ec3d92f639ede65704b77e4d29bd770d3a58b9d8a1073b771aa3c064c81a1bdcb73642ef92c9097ca9bf564e6842814be805857a65e70ba429c06bb0bb89f0284c738fc59e72237712b961f1d038785a473e91abeb527661336f3e65702acbf1acfdee327655a86ac2114e89348c05eab3e1a1f09a1776e539715341c7c32dad70dff6a29f9e9a194d62845d605d5f787a045a6a3bec4d20e44674103a85cf0593e609a7016c722d6a990a70ac804a4f7f75d028b0691c336a47e1bd0dd16affbc5f314682c645d29c8825919ca2c48bf0d95b56c260efdfb83faf08474477b1c822e355330a93780d93d1865e8ba31a8d79dea64a015579aa992d5f5ae5519d8fde26766f9418148a6919bd7ae0a426e786511292e95f73ce7e7bb0acf64de4c678ba98ce20f8357db1be9571a131b99bd730816960765f060882ea919e08981632223bf665b547c721f570699d0304be8cc4d7ac2b9b7017e470b91442f010a827222d3f968c8acf6bcea6c4f9ab043aae9d7ebab6a571ec38e730b5c2ce3e00ff7f8a970a0425e70b060b1c130fefe5a74773228962ac7edca844f8eb3940fd6fc46357188a2e5ee438dd86db218db5bdeb3ffc3eb0729d35ab452dc5da9184228bb2ae00e6e18c48952efda6d33d1284470a4b2d44179433cacaca8fe038934f31c17eb640c22f3521000f59d91e44993dd9d73296c3717d9da5d3fa3e1a67c428df63e0b6ea3b13bb3922308eae5380cb081d3a2f5091ec8d799f3ba602dbb4837b31a98e40fee7b68936e03486702e1540ea68a0c64ee3189deef861744a3ee6b162a9bf83cf317efed2fd665fb2a74c2da4664d843e1ddb495cf09944c957e3ecb90571b704d4fa6156e6d2e3efb9eedfb6aa62a294541d7cf5ab3a152067cf8cfd86571b1385c733c0d287e52a051e0caf1932a690b5bc71b977959e04c3f0c94a6ffca2ba78bc3b24ef721ccc1770e286d253c014e339d13d60704de4239e269c96b740bb818938931dc6aebedfa64d7c35653af4addf1d0aa1095a88986ff236199920420f89053411942162cf81edadd495233557d90048b25c0e18d084dfa6b802e75d7de6a10ed058a27f98df7814d62617c7c5c1dcd84396dbc0daa3959bca80163c6d4e4fdae8ed787721ca73fc14b1edb2a3800c422ba8f7838e6a2382373277c04a88d45490b09484731a296fd96ed829c047f22f4f52fd532dd55593c7f061848e47568e74b1bd6a2a835fe7ee9acac1194a74f15990ffb90f92eaec9ecb1d73e9eba4f99dffcbbbd820fd5d1d1867c6d6d7abee49651576a598d382bd0bb6cd032caf24f1d6fa76577ffefd4bed244eef275f6bd51b7ee66f6a9dc2d6e1afd3b9ab995a533cb107363adcc3fce717f99bb5cf154f2c023dcfd76e438cde01ddddcc216e87dc32df3000b287a229d1f2a518feaf10dcb86c88f7b78fc3e7b31fb8fb43afb8ec54f73162a32253bf3b26a6c62b3990c2d37047ff7e16e705b006eff18ffb6821b1d2cd1be4ef0a9c8b9a3e01eda927c325d57ddb0e7e417c9343375fd1522d512f19e847da0c284c88afd2e160ccaad9635db81ff68cd4bea2bc77305c515d56a171ae26d512b4c525989af95a957cdcc4ad1749a23bc0e15ce6f94a031333577da6431c771131a8cdab402e12328c095b75d5bfb88ceb56769f6913770794ba5164fba3ccc1dbfd78dcd688db2861da2cfd7bdbcb043fd1377609968a699fd27bd529601eabe096f4de468c04ce5b467dde2c1c9a01af0c125488273de4a80540a9e126425fb7451a90d4a466fc64f40b39e24dac72a1cb2916ad44ef0f183ad55a5b3b8fba794d48450b95f840de314e43d3c1ba1cf0c867508859a76eaa520f89825b1207b5cbbddd01f9791d60daa846db4343c256e46227d068f4678d92b8583dc48f2e913031ca11ce72b73dc677b45104791aa1243143f6e0321447c337b4fa3aced7844ba1122b21526e35522e6b995c05aa0b37814a2da7e57e5f12417a6b8d9f23ea3643e503326c793de4a6c540ece61ca1b42314f0fbd5b65af778d0576c0c7b273e5965ff9cc87fbd046a78d3b93efeafcbd486c484527d1009fdbdc4855e0cd7d24193addf555449b6c6be29e84e61dfc86c0b770b63983dbd66dab0d0c083e15af46074f1ff64b36f7ed2c0459c8d051d58dfcb9bac7e7a961bc004bddb2637b6ce553316ccdd118877ae35ca9597a696e1be459224e72a6075377fbcdb096be8aba63a9d9e7b2d84d941feb44c4f0a948328fc558afed22407eb95c8956bebed8d5ab4ad95c3b8004076ba0017fa82f03132c089e78882bbbd3a7ec094d61a711a5032cfe35b0c103dba5b1fe054947fd229e337035dce175c44d97f788208918c875dd5e5d2ceebd2558eb1ef6c4e598584438bac599ecf5dffc6e05562d1212d6c5b0d894fff85e25468e9539c8d9bbbc74d2f402b2848dc6e08544b5bfe4f5c08d46e526f647d7d40ccfa47323c08694a48af66f7d0c673e8cd82913f0d28ce6247c3bb62b6b3306decebb8ccfbdf7ba73002ab87d9673b62f3a1bbb8fd49385135487fcb467b4339db68b01f4be45b232ee4a63db200650c6818569a6233c7f785f525d0541af3af8bdadf4a1db61cc96a6b6f78504d4b56f99f559ef174a5f9707dc09ba22cb5c83ea1cde1180b7072a7bfe298a094bea5ee75d18d671032b3787008e33006a18b037dffbe8b1580c29337e7eb93a807f32e4f11b4e25e6f89b680623ef74dd13af6bf21389561197720a442fd4ea5a9c8a01d6e4a0e86fac88da06516d71393bbc7b81c6792d79da46cbf876da3ae007981fc26c61dc534b3f93661ffb001f4bf3eb77c5cd08189d54e1d5dbee7a820e48db2712ca2cf9637cb849b8446dcbc1bebb861610d55ea8edfee04614b68d45e7d49e22965e60094ccac7df09418ed2180f5cb60e363139e7733a565fbe97dc6ef52011cf1185faedc5ad81b0d1428804355f2c8ab2fef3da43079127debe8bde8c67f48ba6ccfa52778421079102a83f972a3b8eaea41dc01f2dfe3868250d7b67eada624671a4548dc435fd8e5ce315add2d6f1340fb1c363857e9de535c775b66ced57a4baeae68ea5c2d06e35e61c6fb6206683a724f5b36963676d20c124af6927c9317bc2f4713ca43db1c77c24d8fe6f24f679a8178b1055df73462b6c105d8fd56a11f911304f770d5be0145a09ca63d131abcec454a3b31526ae84f8945aba4601a4d283bc85974573304a649e3f2f6fd43508f5d3a2c65949e4c7a0f3fec26aae706616cd94f33f68218b8d09b961884077eab7bada9c539d8ba1ba2fee0e222f9cea362c054583e284ad183fbee6132d185b5b060f2f33d4fd3e7e9cc8a47403d62c8471a5c4fed2c2aafacce687a62b3d3d980ad2217708598198bd9beb8d04e56ec5abca7ea103cf1c1ec3a0c5f01a6f0ac836599f85816d141d067fa671fd26fcfe6f8c2962818d67bd40e8822cda4ce7298a2e57f6d8c70a4ed63a7e472a2eeb692290e991a74c0dcb6fb5d84a7f5f689c1777a2e77a53787261855438a2a47fa25763345d0196f126aab7e9cbf77de707c9246e77e7e0952fb124604e98073909957691524edea554b3b41eec61744953c7349128b98f307a1fed35777f81a90f23e6b8686b064b2437a3449c37a0920504f687c70c36e798ba9d8c0d4b2a68c82e769d25543c04ffff859c30c97396ef05b0d41967affa63f33b6b2d3367359450aabd96022d1bb2cdbfce2075ecd5ad42557c450ce52503b64c00a943400e0966a95883d9ee63cfea25e2837f7514833ec26ce5b5c72b1f7864e291d9b5d7690f6daaf757329fc0bd9670f3d84819b49a7578dd71b2c6aa1e596c43174c52dd10031ed6d83416f46edea7bea64a851810113da4cb34ef57b405fc0f788c7821f8e612dad5f621d820b0d22d391816648c7ebb2d71a59a5b061c253eb3f00394453f728c172da895943bc29c1ef4205eb0a09092fab840b6a52d524e75e91db9d96e1ce07059b9399091753ca3d294b5d02d8d0022c41f74fbdb4c5988949b57528b933a09f1c13754f558b7914df2d47b3c4fb0e3bb5f24e1415fea2b9fb9b23a34751bb52d6d43c91724b87012dbcb1d0ebba69bd3f48f8158e87f638913144e333aa02c66922bdddf56f094d927c842f5d18096eda72c957110381f686968d9bb23a2ffed7d98cfe895cf7aa166a7aacf6640d170ee6ac0bcea2c4fc3cf47939232392cd2059e2f14b7927d17071a72bc37225b0e0ac2bebed59500f2c781938002dea58a697a05d611463ab837e1157956acc8ba489d90bc4c8a62cd6dfe7584802d946c32ab0bf4f20c87b984daef1ecfdfcf5bc59418effb9722a98effb29eb74f9cb10c8e774becc4d332f8fd727e4be397130237e270dd4ae05953c4c83f92bbd35d26de199a164ec9c523eea8a6352b043adbed70085bc0999efb3a80f9b8862ec7562b4ff9f7b67d7a2f6931d9ca6252ba9badf01cac9c4c87eac7f5899e9ef556907a7ee1532b053bffee3744043fa86dec09b802c8a1e85b75e3d47ff0aac98213b64c43352d1afc30d2c2d122204b386d2b7bc97210a58c42feeb22c2c5afc08472ade90c0bd299c978b4c31679baa2ee4ed58cd6808ed09919432d83fd9ff60efbdc813b118661a423354b7641b604d81e49f04bce16832f0a421421c57f0daaeab3178a9d8d95dc9c2c26d8f38a64330b94edc6338b45116440588ef2457ca2152e8b1ef39357dfb2e7ab62f9670126fcea9f45fe338af6c6075190ecf2a80bea2d815cd48277c810c392eca475de5963d67acdc47995b6f552da3abf9813465dd33112ea673ef9d49c031fe90360a0a992f695f78609fda23c40455d1b23fcf34f7bd050b59d6f0e7abbda1e2fe762242a9c3e1f881c23dbd3aa1cb9d594ab0e7ac34e0c4b1a48406dee3afc037c7f2e72a228f5390a674e410af9a168f73d8d10a1fde2983673c6d55ae45f9ea59618c2509e1738dfee689a19fd190fb82997d97390bfa9e4dcda29859e7e1afea285947b2a0080c381d93c4c586eb54998d64e8a8abb65d878e4d6f797b0f8cf9ead5b1c9fb627eb842ae54d733f3d10a219481fd1fe76192e0f464ff5833584da3a045f8b40a4d766ba2f2ec12316e55b2a733ed3877dc382860467948d15d1fff2cc51fda6ee6d87d9f2b1cb9992737745f4ca7bd34cce9f696332b0ca06f3d9daafe563682142933f578ede6ee252c44861f05450475612fc2703d8d6fc2c8166097d579642943de4e8d0ffbe65bbfc111c8c77fbb26e45fc65f60ad1b5d31b3126042123f4914bd78e0985a6b98409703a1e181ae8a9acd8baea60ca5707fe9c6d02e5df04be951f40f30524ef5405950f309b9b390b235a8b1a5f4dcdf09359ed5d71e6a24f2f643521ae5fed0517ed6641716da3e61590330a52c26a95b1c7521ab813af5146e4f36c461734016c9e6303d3fa5606802bf521788499ba4af618f7f29f5d816f480e99ff11710b2e9e0854899c594ffc2c1ef022386a833c27fb68f0e70fbd1cfcd51b0ba97b63c0f76b9424a87f114f2de598b35325a987fd11dddc377d0c857d24de2467266549ab189875da89e38712040a6c52b86e3cce4efe30a6f83d34214dbb46dcdcd1ab617c315359dd1abca77a93e3b477f6256ade3f603dea7ac6cd986211410c2c87756176e776d4d41a28932ed7e8b88930c16f2c1fbbf5a612edb978ce5f7f3a46ff0938768d794fad939f720ec359b61ff473ad0dab1565fba9e124f869d0abdd5bb57832c43f8c8b96930d02362f5c147586de657b02e08be6f17acf72530f0b02b66ba62b95052bbc7e7083e4802747134babb216add4afc9e594ddd6a971735f45098e2380977324f46cc06aef3e5e8d2fb1c5609f114a7c08130303d3179267a07cc37dfdd3434289a4fba605c9786ab8bc02660bb5925b14e300320e1e3ba32f603f163bf47a98a6e71208fba62a85d4c87799344ecee8e524e91e14c9f13f40d21a68847dc3a074e6d29dcf2868d3541ec755fa8dade1bc325733eaaf567dd31ecaa35e4d2fe43e13ae91ce990e5d259890b9a81a4eef0d1be590616d054922603ee0a586e3bde41ad5f0c451646a8fe9eb3e5b960b5bb27114b800bd8ce2c4abde27080c004271163fde6678d01105b84cfbe7c1239c13e15561ce5af98f939fb919ddcd90d6bc55b6e35c9a4e6e52cee7219441801df865c689d24f3c31adcbf90372b086b211f91a12f066041d4c734235f645f99bb7890024b55566387267c89b00a33a7b3edb3e7e75b92cab3d62ce642e0eb626644692c1078253029bd7aa057d7e1cf6360102c51b7dbb756e25960914b3d114cab27f4e7d5090cbb6c715552df6ae13a39295843a7f29c31a266d85696a5f5ac2d978aa3fee10cf188116fc96cfeb67c517c1c7ea169e0dda6f31879fb647a9e3a317f27d540aa5f14a7f67c20eee5469929977cc470a5a6f2f0fbe45b7a7c85241e8c1d5ed71414169d908ddf4cfbfcaffac74be06cb5c0f53885f8053254dd6a1aedf2aab7a08b5511490bf282379730499d33c4b3145d61ec62bbb263942a7d43499badb244f9afb603c91d15650c129a859c3c3b73ab272ddb3956a7670566ff40bb488dee97500fdcfd46edd89ea2579460c37be794c60440f19524dae03202a55d33db9a0d00db1049ce3b655a8e28b4a63e4f02b81ba47bd416a229f17f7124c916ef8ba7c8662f321246906178142ec8b3cd03676ad61304333dfc3ac96487ddc641b1aff1364ec9137e86bce0fa98c031f20fbb4d423a59259cda8c2143bb8e210a603b46550e185e8e50f915e233234b41d873b131f1c5734bfb87086c6656f339916ad1b10c313aa136067f81901dce0f95ab61230ce7cd5bc8013cc5020dfc7a0cedc37d7e677c79ecb4c8da097ec56cd59e0c238fef50d7f85447b66a6c46e30f1cc025ebae47c5d40991a7487b46674fa7c66520ae574631403373ae556d8a792fa0f67f80635b78edfe66aca46334521dec5c449c5415ac1d785d6276cd8cf7b3986c6f40f850bcdc5bafc6db5b8ac5954232f83afbd243ab4ccdf67e9605d1f01e62d8b67b7c3737b7ea00f7264bf58aa8c140eba1e08129353a80923f16a7bf63e66e7d2b89b781a732f4e7c57bc96fbaae812a9b0787fec007a59b38a5ac8f4642ef82a6e90916fd7a04105d8486a84c9483504c30fef1878574559686bbab329b7aae7204fe8cfa27b884b82ef1be754bedc58a4d60a3e8374a3c002a9038c7807fc4feda41b2af89b181eae9d0f95d9b0df317f462ab4012f2f5cb82bec72534bd1f2d45bd27a266ae16c4090950e7dabf8cd241fb30f7db0e0a135f54081da8f6b0c05283d1244c4aafc04c4fb4a1c434e6d998279a2f5a95a23f3266f0f12c49be46c84b751c1a3b99cfa9c7431d7e2f9152f775d1c92250ff6eed66df168b1345db7b01be9e42391188f6fce288605cefb4681df4dec7aae2e2397e6ae8bcc7c003531407fb685f8ee54bec8f612114755a0f832ba65730921e309c264d9f165710dd4d8bc249f61fa8b52c32af38abbd4608bf5eda291bf46c22924900e5e929db2a3ba886b614818d91126266d210918eb4011156bfe12729de0772bac86b747e86b5aea852b2ab62b5d1b88eb6c612c85caa1cc408bd90057619d233fa9e83cdf9c7285d656a9159cda74bf90418b4ae1a20251dbb8fba0cdb7662d0fec225453fb12dbe9fe97b6353ed8c0598831e4e922d7044dcbe320860ba10444352c8f8a3976a5d3fc59e8e7f310e2595841bc7ca58aa3da6df0a49d8165f0d412ed46392e12aae925a98bb6968407003094fdd1441532ef0e9ae85a03648ffd27623d27f2e9b60346ddc808a0a75ae78461d0dd15f261a1e6b0b67ed76702b4fd23de2a34980151814a84a23b472b7e69653da43861b96c33fc52c0dca375f8b936b9c7f06b37ab36c86d05e6746662f0d27da2f5eb8a9801739be3e79a7dc4bf6e1a8ace1fcb00db13264742ba2ebe8e218f3c5622b5efc91916883341f167057fada9e88d5cca2cf507ba24499d69ff7705a6ab9c72e2bddb41a4d99e316538d6953716a47d836f86700e381e08f2fe9da0102b5bf74bab93dc8f006f17f88022a4ebccaf9dc809ba8fa36143963c4f6163fb3dc774d8e0a3971a572ae986f7010d543bd992cbe52751d05b0d0eba9b226f106f89cdfeb6aec323352c1b114510d11acbf619f91f4400b3c12b2790ab0a8255e48f49f5d5b7eb33519dbfff8ded14cb3a10f8d73902eaf7b855ae655cb724a2f3bbcf6f069b512840bb2cf9026f92c4820e5acd05780e0d849ae41828d3452133419597c11264b2e1c4329e0a25b76ef2d4bbc5713cf18be5794c872a8198e5bd65844435319e9d1cff9170cf92c195372cb3a78d3a1f71ac93bf2a2c2d19e39dc742ca48785dbc08ce58b91b9b445b9fed7a8de607e8945ba6178aaf721d00ef35a4a5efe9a4df8e65f4bf4cb31c9bcd5f4e17808ba6e24e97b5596ed7122aa745190d5479c94b60492beedc4cdb7b09e35a5b56a56eb21ac76fe450af0ba9a899a8b036ffd24ce6b80277cafb0c36ddea1e49f1af832c01c0d80e518130e3c3dd77b302115cc932d560362fde81c093a98d204aecfc9423ed70337ce710548553b31f3998f8d18d02fa75ecf4149bf8481a09cc1e0e288bd60e8d34125d38903f8c7d1eee299a1bd2b1515c2bb277b5848cb659909e76d12a4d2c436074869dffb1da7f6eadb8a925e1438b027ab4b9475e0e4fd4658d0c34fd5be33b2d542662cd49bf0151b2e5a808f1606948d30ba1c3f8f9f0b08f21aa8a4286e0d422896ce082c6fd814815e86dc35b490db3423e1ec41885e38edd6ec6cd03cae2e08c9d32f0398beb3c06a305c5b758be6cec9355c2b3a1591671cc8a2529c4f04bc8c07f81c5128cf91395f9f554a3b205960cb38c9880ae1ef80b51fe0de9ddac67ffe4c7bfc3cb63d1bf3789b99c3ad8ea102197404561790df95dbbd841a97e7d8d1f46aa54108e2784dd4e0e29ab3cbf894e737918b40d254289754605113afa73edadb055115572a371af95522b9e2a7e90ae6e8f70dc6182332ac9369751a296b4ed2b9296b713dea5945ae078525c3a0a62569c973c12ffb365618ea0745f471c479576fcbda27a4e1f5f9c5efc5c567b07539ba9058cdd9fd3da570298df5369ca45341ddccffa1e0951e29633e2bf555e0cfa7e2bb27d70e6f4f56a8ff2216cd329f663f069d29d03c6d3f9c4f3a098f2d485e44900d33bab327487db5303d233c796620cb3480a51d814e3056f1ffe77858cbfe50e6c36481c5e5f8ce3620544e73336c1cb15d0996fa90352759cf5f29d73689afd898b6f5a898053781bb474d506f165080b283308c4a9f184dc8d66784fb4af06bf1822ad7f936405cfb89bc3e26bac41debee497a113842503ae03887ef5f898f25de0541a0f9983fee01424b6e8a742ee610d05a6c53a133c812bdbc2574886bacc4e13e3639c25cd0aaf32c043c00b94216aed9472ddaf172295a7e35a8dda17db76ab6765055ff8b3898f357feb5a4310ade4d0852efe7b26c6a8d387d45e532c5b6a9a973728fe480246c9c19a8b7a5db8a1910baf4cfb0e16e659222d8fa5467555f0dd3880b7c66a1c42eb90e91856b53ce6fab593f6d358c32885066ea07a9bde62ac98aab44a7a0c27d8ecaa640a9237acbc843c358ab4a43e3d7a153d488c5706f5e129bc7ca8c0dc26fb430f631bee3daf1a19bce151418ce64ef3412662f62b6307598d3844c030f32ae4b4aa6918b870903e035ecb26e1393bb5bb0fa503122c225e2a7e6f59b7ffc91a38e6718a1c29be19556afddd772c24b088b1f293afe63dee75665ea596d08596fa49d927a15b82aa4e6ec47756d36f3c343eeaa940624d0198f44a477e00f0d183e791630af1b3e5948592b3d9f9c3788bd3155bc0ef312e18facf7ea39d450ca856fdceb76d79e32d01d44a06fa6edd125261e50a29c55658cc8a4282b3a74c7731857c106a1ec9636c0d69f94e1e115a594a957cfdd877a24da2349ecdb7e1e75eec10bbaa0951d1ce1d89896ef5576a0499f2bac2ef364c42f6c45779942738a35764e2da1d59f4291ff69020c6847e6f6082f2c41c40f3c592264147b64467cfbeb0ba25f4beb1ac2e204a9766281460111e5e6d60ac2e0386763ac5912c7facb7ef03ec14c5cbf57a0b884063b83765037cf6fa7b66fbeb1d75fefd6892c03a0e601deae59baed9a66946d8a3b768246e855a9b5408787fe32d542f0a5c232d53c3d9c0c9846a6a3f68dedd9127d11ac922d4691a3f4752b13fe55778091bd2fc21fe9bb2214497948e0fe591e8c0578d60826a03069728156099db6a3833746163cc09ef56bb170de0424e982b23bcca20b3458d3e134a9f3e14acff8e040b5d03b53ef411c8eca685474f7906f8559b4d8c9b87706d571378fa134a076bbedd2cfb8a08b12b71ab65494dd2e219255f1c360c5a11bdaa3c0ba10f800d75b61b3749b3401e013b9ad17f5fb2761211c2a68a0db5ee0276c1c3f8b388e08d73d98d5717d0a0717e18fa96d4319e2946362774c6ebaa688af6ab934a9b6fac9a20cfb95a1cb260b5ceca08e06936b956c3e4f0d961527ed4395c4829d7319a2a2fd09e536f92b33e3604f9b61c96b67f01cfe964b0a06a5814e706a45779c30137d36b98727aa809491f34241387151f01b646af7aade0cf96801e8037d895099cb77f3a4a449343c3c1c92b163f2d2a2d0eb83c5a427b827babd23782a82f32c132ce91421ebdd1ca34eea4c116aa6b9f8dd6c724f00949dea8faff86b76610fa2fdfb3ec6a65d23ad383d697b90e6d93f0b91739f7aeff7917c8f47fc0a5df9ed5e71917987ae7aee97cd3de37d8cff88721170c4dd243edbddee9c0d0346f2e501e3f059a4333c2b3f8d7bc7a6a43624cfde6deff9e939940708202a1cc80cdc8a90c464c23fca52312a5b6f2f23af929e4878ca8f465a6f19cd2803e10f5b436345fb77d98abbdaecd790d8b72f4a6e9a1bea75a2de698fab310f89c12b9555086b586535fd3525387512f8346825dd3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
