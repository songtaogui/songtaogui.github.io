<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51523a4a054c8ff2923bb79aae4111c81ba993df02ed02ec0e9a16f8b9c6ded7d8a6414d31d887479913ce65f8767392b42bde466c0414dc3e8d25906580bbb70a485459d974b2cedde3a85c72cde962df3bb12dbdb42217957a27dfc8782f12415a89d996f1f59f66d1e682bde147eecb2e698bbcb5027765822894cfde6f7aef8ae73924e7a62990bdcd46037b84629b2fb0d8962ed73c33a3895822ee31c4fee6c1b6bf4681adb0fedd722e819a7f0dab191c68c65b4be2f2814b490bde035ffb8adeaa3bb193160df984498cd4e8f94ae3c3d9d11093eee8e92b5e49f8c419300062a801c9f78c52e4290ace9cd6d80630dd7e8735b4d4269dd66ddc68cef88d270061cda837325a9d0c026b7d21f93c0e3a75c8451c7a867cb83ec431b257d640b4c52e5751943e4022618bf5b4e72ea7c7328f058c290b2cd4fef82311700206e285bdea97c1139953dd5be04584147c2b3848e07d351c4151152683abe8871bc383cc646eda1a9c2ee3e8f0ff08d6063f07516aa7173cc2198f61938e2f1a7ada2c80c1e7649eb474963a2c9698fb930e6ccea989b9fc8f5b5af45b33e0088b4cc6c49caef3d495491da935b1e807e98552ce521705bdee95c7d99b006a13a5ec1f7c8f74449efa7c9a65c5ef4732f16a345315cfd68f14deeca1e8aa0d7b0d5ffb3e2b0bf8031a01d619495777032af2ccf39db7472b2c80287b93632cc0dec434c05e9398e43a966c8023ecc95562cc3c390eae603d6e77481af3fd666d47e544d85178533e234d416f2df517eb0918dae9cca1c509b77097dc1739a77a9ab64e5bf50ea7b84e1df09222fa9d8313aa6a3c6004ba40ae6ee122603c8e0180694191af0ce83fb1b0b7149239cf5fdeddad22904703c3b5831752bfbf6abca3e91f2a5fe8e51d013c19035b06a7395d142d0afd669082f21d9df39e78448b69d26b51294c27b279a2d6f0407f6bf32faaacbd097ac4cb9b8c9900f2a342d5dec6b8fe173482ceb58bf5696d5bc0cb2cdd9050c162f10a0403090120ec1d42a25dee49520b2d1c40dec73652b859593790aab4124aedac0d335c5b31df1c32e07b0dc294a5ccfa070b8f01de54cb3d341f13f83f88950d16d4222200a408b45d0e9acc791412ce6ef6bd8e133aa300856d23c28106ddb0ed202745b077c268d2d0ce0e20988851a2743f12d60f6b3b57476c7f6f4b018ec775cdbf40607802ccf75b282adf92e2090637604f218aea997718ae538bff6911b54c95cd4a4c390eb2eb8ef3c36dcea69846e4d950cdc94e5b9d6e8284bf21b19abfd8e722727a7f518a7d683656ed92006ca095824d26e6553fafafd2fcba066ad337e3d9e06d10a1a0750a781f8596a3334c40b5a8c9f62d0a62d2d7db67f61589e9fc53a63ebf67d2e48c130ba5d2f268c1fbe5952dc0623e28613dae3dc78ff3887b35c27e5ae1049ed820d0b15cb5ad153d1faa6b6a27e21a617129e75fb7f2f4addb9f485d18b0dcb090eca11b738cdffc3cc88a8a59b739de7bc82e8e1f4bfaf68b002d5f8de38d63a838b7a75ba5d44dbfa6426d9ca640856893a77a887693dd0b31d9b35b4184883ea31275548e23c6a034496b78337e51de7989bf5e186bee3c354ddce30792b20b1c0547ba3692d96d72de5d457f079675b7c7f1d662e01d381988e61cb32f11013ea884b133396db3e859edcad14e139c9661db0900c4df4feea195b9fa0f4f3e0bab518ac3b38c933a7eef4d4fc7fb6b8accf87caa579594d68e92e7a74240f81985e368360da09c3eace64d369b12481e50ce1e704404ad745660437d5f440024cbcd9afae70f76412e3c739e337a05ea51277cf17c57f6d44bd8772f4aa55d5ac4365ed39487f64792183813ac801e14fbe3e283a3fcb32960f157412d67a65f33f81831d74e848fb0a53d78de8593133e444fc7c5f33c7170d52d8488bf817ad211c6d519ac9a7fdbea06b0ab3df12cc373b1a352a79d7a510f954e026eccd0a2b7134b9b54128b2e28473daf48a2c10548379a2c2f52014143cb1392f80281d9691e00c39bfe2498c8e836f17145cb9fc43af9e503daa5db533896ab3dddc355972b5f67578f9b510b8e34a5536b70f25ef974b4af1fed02aa76a507712b803be32af2cc02f9c6907705f86841be7a60116b3fcd0a2ab0eea81eafd8fa5281ec0c915471715d0b21e302b7d10f634c99f02fbbc1bceed40cb03b82889d6c59d4d24ae2ae0f1bd2f429e13a4fb7016055a22be6a5224b16c08024055300162842391b6cffc7e85a5df840ed4d72d4af3c5ad09238956ec004abcf4d804dacfb89e266982b5a359cf31915fa496aa44be1cafde5fdb61e3ef8468ad193608d6404ab025d22a383f5cad65850e7703f1f51347235b088d65fdc7b5735fb2b7c0fad9ccaeede452c7958e5a7e83443211c8d03233504a8ea0886c34733ba0299a4c84421128e3e89104cf48f31eafb143bec3d840b00b6cc6544c86d9c213105ea07a2d01bda2318b0d4fcb3f744f931fd0b74735748506fff8595d8ad5ef20305f954472dd4692f88d8b42658b9c7a55591297cf554adf1817a5129c43f52b8d879cf9b2f0e708323a77ab7dade7700ceddadc926f5a50056ed7c671144f7c842d61e8dc5eb646cdd00e8e14c648034ecfa4bae49c21a9cad81e0a1de115ed1f974ccf63e672f4f57ef138c6aaab49626a75eb31c18935af980a52be0e857bfd2f3df3da4574a3d12abace3877c8cf39c8b950ada5ce74d701896554d7f311fac62265c7eb17a424880dcae5ffd0de64b2fcfb455cc527ba1fd932261c124c30892ed604d962094d5eaa1012bf35bb16ca68060d51c5fcd40607328e14c0936b064571d0e134993ff3d2b4a5e468ef996128e4ad3c45c13e6411f2a7ed3ee1108bc58e456e2ce14fde32b1fdddc8b9357819e77b142a25b940b814c2237fb803f4545e205d8eff011409efd3c6595710abc3322f45235d2d62ee793c39a9f0f8f0a422bcd1422f531db61d346cb6fe5b2077f61fd3e8af9a5b18889899d8e7ddb2a32de53bb9bed0453ff8a4ee22af5913416626e7f844c88c4ebf965e26d5c787a869a9cb3b8ec6279a912064119d3c7732257efaef319d0631acc0135a78bc00b8c9f7e01a577db74e5b772e2c6e77c07e7891738c02471b578755723211ae7e5d30006af1ad9e35034ee64b51054417e0d0cde694d7e6539828c526a87f4e5fbf90f9de7d65a1aa66715809925c0b893d4b4c79105d18d456f1367333c1949e561b1b0335250bc279c9e190e8f2782d4817293c81c5b77ee39db9399337ef382366d8eec0b57880909adaa0be6766f9f5851baf846c53e323c4de7963c1331ec61ad7b4e2d39e0f58f78a1d3390f182ddf1ab98daf0497abc63f797cc38c9390756cbbdba34c088388b75ae81b740390e306580849cd7ce296f8dc2c943866cddc032a242c27f6dea4b07b866fffa69a591e0a64fb933ce9e9e8ccb6a24aa1f265370b376c29abd61a68354376397cceccbb66fde22914ab1229dd60070934ad683ad227f4c61c44b7ca2e7d98d72cf203cf0acdbf7f223a8fdecb314efdf1e7be6e351dde1a5a7edb0bb67ea576757d30f2d812d2540935e88b5eb8de8c2bf26a7f161c50e6677f739cd78fce8a5cc9ce6cac549520c820550e3df27b2f6944acc9f65360abb5585ce9fba2dcf826e038f0c7e3477a81b04f62a717dfc99411b86130c0ba4a868decd2f2a00dede1bb8c871df8104f1491bf89e1fe607b6d6707b55ba198f8a7bc3426dfdc9229f9b0ddd86dfa04f050703f04f15264f541a7c73ad452dee3f0cd933876d27cedae5b38f1feeeaf382f29119c193af46dcbf88aa1580c197db895f1367c2540a524ceb89d4ccf74fa5440abecefe44581ba13937badccd74a722655652f13ac1ca12a0b9c42a015e330baf380e1d1ca5ad0f93c24360751e469adeb746304faa5febe3f964791afb0500ceda8b0d8589dda0a8cd0cf0a990a498af0cc8f6dcfea87a719b4d64286fdba477391fd34e1808e801574f7e30c682120de72521ad32b53d92d089747f9ba66edc11e1bad3df770621aa2fcbff56fc053a82752ff1d5ae83a17070d61ffb41e786c5ba6a171b3556af1673c3a54580f60ba9270636116b910d98c7c1ef059a3f82076289e9a2a561633977229d309631d3bdeb949ffb82c69fb1be10312a0cf6dbf690b16b2ee58526b020ac657be5d116a4983c8403134fe4ddca26cf657a6ea8563786a5399de2348965926d162c92d2be879c6ad4f41c8638d609868ca32f01c108ae51af0f51beefdd704a73f50c5e6972bd3a0d90d7ec875205f6d4d95881500bd663fa8bb3c94f7f74465f4fd040583d7f07eaca5853580c2dba3a6313c598b6e2bf4db081102fcb914a359e4a9ddc411e1e0ae30c726fa31a1c944af0e6a7b00cf904279af9b3132d1924f32d32bce84dc52cc6c0f97f52aa9d6f1b07359d861780218db88bc1bfa771750216f2912d48a883640ec5ff266314b526867622383ee8f16bba0c966d0dcc17eea9f3fd8fc939aad8d151f597ec5f7d07fa70de8c14eea978f84197d2abeb464ac75eac76f13563a7d6f4f3e71406b4dc614b7cf794ed7c87c0627a6c35055df4674c2ec0fb215265863bc78fbfc9122c8072e8d4efa804bff0bc2e4ff926af0814cb9001f7b10b74c3f050cf57d04a190b99f8d2fdff954fcf24c9730b6c24a3bf4dd4e514c49053d537c18728b61d5c87c3191984af4e732e36b4ac82f2efcfaeac6a27179455fe82bce433b725ada4c43e85b4a4dbaf29ce580c2ad8d6b915174f3d69d3bf2a1b7d0c92983e2e1b3972290d24f6fd267ed7ee51911ba5e348e881340ce1747aab3d798a027034f029ac3f0dd7b9ebba717e97d1dd4109bf60f83cf6e94b8eccbdffd7834785203aa98f912c1d23fa3ddc515fed8d7b789bbda69d79434f8e10cd4aa625149c9a0bfa227f69148ee4009a194939427842086ec10e8d258ff69e227ed270ea33e2258090dc4a2983871ec45a790898a36105683f4f0cc449794b9dd2befcb42950fb70f2af1c4cea6196e422c9afeefa908d5d872f4b55e928f0674ace685a586eb4e9269f93ba178f0af7464731123b42911a3d79d5ba66fee7f3eb531cb2c476ea572979f11a5de4ab33e48d7574f7c343e9614f4fc0babf96e727c627b228437b54a788fb1c1de12b7d10c10c565a574b848875c93dcd92ac6bf101d9525f2621ed3602c7552fd339ddea6436a1cb1b7c818f40f5737aff330cc653d2d13372c3984577e3b7a2398199d2b33c4b314ea1b9b293c2d3fd947a19ca846a7a324ba232dc80878c59f7b7effb877434decd594612e371d437f0a933083ada3903668e57866092521baeaced87db90ff465c8cde82bf157e425386af85d46934431c220c93026907b5b06984766fe66176c0f2a000e84fc3cfae92763b756444bdff0471321dd8838ca4256901cd3940b821110a3009b4b017cd04ce81be829422afd39b916d58cdf9e44db9b73db898a092413d77e5cb40994a322eaa90206155ab7ee6344558cf48f2a94adab1263b8130ff7ea4324fd709c5bbdbcab30366e8360f30e86c5076be023ff86ae003df0d8ecbf6c2a7b68d98a9975b0da14934029dc2db744871f133754b69459600787a87ef9edd3fe66382306e933ce213a2a49ba6755755e531cd88563db5ff4a683d1400373246acc39d2cc85a9e782c8931a363d14f0a37fb3f085a13cb52f5a690228a05b359cf04a7eedeb06f2eb7e21e794658fd65ef2874bf51b5b07a6cfa44913e7c22da074d06061446a8332d7d82d8b34e32747537788f9e76b40cfdc89e8397e0af80568ac8680510bd0d0208323de0d1f18976eebed0fd00c934848e6dc6e6d430c0219399ea54e14c04ce2f8b24236eb627683bcbf1a410a8c7c1e8d3d7ee16a8b91473de0b8332590bb5eea96767a45e77491b6c6db6f3e7e0a1a4ed16a106a9b3942c224618c0da1016d50a0c8c8ac491dbb23c71464323ba1b452882913128dc86bf2de88945da2e12b983d1fbe91c929202fd2164c507bde8d382ac2d98bf77b774691357b8945123d8641ee13dcdbcc2d254f29fb277565329cc1c9b220dacbc4f29ef2a26d161b6a22a0135e6ce8b5673f06f1142316d3acfe057e670b614ca6bd4707fbe1adc43a02f4bbec2d2a06dd98fdc5c36ff13bf286f00210eaac92172bf257c9e5e1ecc7fbba902fe34525ca587172439f502ebe3535c2392be4b9349e6141ebdcd2ce412c1cb4e136b5a31c29cdc3ad2781cf46f7e933fe3922b7cfa4c039c5bd87b1e01cf407c0f5ee296ca6009541120e46ee6ab2e9c51b2c603cb30aa53cd9f0b33677028cb98966d5df915ac567b56ae3fbb37a197a41563f3d76071d86f3649f6a5402a0b1e3fe01fff156d182cb7c46b7ed2542d118e1f7c828c7058ad53362ec2a4367cd5018f15ff3073f8e4cc7b044b15679f6ba70fbd88c2b17e769c721655f6a11cf262880ae1a862994cf63c31a24a765068d27b14adf153e1345b41e8d0606315f1dd5daafd19b6c53c31445ae08018cd145b1eaa93c97ff3354a45f2468673c126f2b3619e4cc25c427ce61d76a81972a9d03faa081b0f1f5be416e66b7e6f1e637fa236dd6814a3fb2a0a88e3b77d40e007d2d9ec37efca2c028a8659380cbc302f240e9e3e3e053a968ef1a7467b52559aa195f9b562ef5eaef8090231e26f42a926d2878fb823bd37752822f3acece12944e7859c76ca110ecbee2d14e4ed3ac72af9adc016cedbd3715f61838db1464ed5ccaf76c866331054e3cd4e84ce7c8c6d031090309f6bab96b8a9e649dcee1844bc1d4fec9fd5499e6edbaf7be1b0c858e8f51ea017ff64888b9842b9edbcdad4cce5abe1994248bc985d10e748c5d508533662a93329bd5f7ab6a069f0417736c3b34915e378e6c35f584a41fdb794123398cd0e7c8e486a90bf64e801ee482748989f47dab1acdeb9dbc91dcd92b7cf4ec77ce9ba443da29b90450c63a1920f7b3b7c7d55269a8a0d83a914a4ea3683aa960477e66f7e8e109a0878cec4136c84dde54f9f59df8ef2997aaa36ddf9142bb98f92fae3968b4a803306e8d7157714c35bf82b26a1731026864146025b3966f719afcbff934db0c023783d7dbbd071d52bc67e72458a11afa09a1374900c964829f7a0f14f7cd62447b610839d65f3f17f213c00b9b2a0f79bc0c8bace9b662504b7e6640b0eaf25c43f8e9ff334c6d89f2c0d180a6b4b256bdd3849bf9b0d3f39033be7f8782fb7f97db7f54573f292124ece06bd04ec499c39c0cb2ddb83b6e179e9d35f9e62a9107f5cdf3350bda84769ad7113fe93affbc89724921901c02b5d0f66f8f3a189b888cc1eb93a95c222fcd50c6cc44012bbfb90afbefd19f1e719c068fb3558ae37596fe540f241113bf799a4adf818bf9964a06b0cbb00c6c1507be3959e62c2118eddfe43eab0bf903910102c6b34650526e746a5bd8d11d7695263c50432f8fc352851a869a19e6cfddf556d7517e89a81dac10d12c75db9cdb8e67c53fe04522c1a26bad23c4d3c6a0216a4498c09ee53c31ff98bdbe0a753fb06f6108883d9a46b417dc4881ac668e2a3ff771ae015c54ed0bf094cf7b31f9300bace03917c55234030e10b6897348f93095aef391708d178096bc24989677a1b1b4d4753695df24115b1baa2e929d438d0ddcd4e7601473136bdff1b6b97f2db77d146e544e18fdd38cf555e3ee51261ed40bc36e86ceecbde7a13070d858c43579884cd71837f57181e39f6ff3b45eef0da448af6d8bfdf29f451b53dd36165ece35d427ebe933662a47f7a4ea961606862ff50d8a17febdff9cfba8c6aef9fd7f5ea8dd34e8e0ef21038807f68be0628e23859f15cd503de3003f019f2e8a9912edb2b49b821c6c528287478f8f215c9e2926e594ae9cba2240581d26a39b66c8578969a927a70a53c797d0b164506c827c9996c4397567ba58147f6cac221f921d765cd3add16f033efd2a0b93d254ec1b03ada5822b0273accef7afe2ba999562c6ef278c4904741d9eb4d2fb23c13164d0a5d44240ce43ddc1d4c44fdb19af2e3a5273c6f6da3feb4950be0b268e027e28c54528b045d17a99f5218ef898f59765750242d83e048fbed6fa6e98d275b09e0dc4c7db3019efce432a91ad22fee02f9b80269a29ca3b1d6bde92b0b65a65c66ec8a7a94ab55e285ed9f045245ee91729950bf3c36b618720caafc46022804276c29c2da449f1e5ddf9170bd6c9ec26eddf990f845c7bab8893b29948331f2fb6da5a34803547fd08a7154f221d440989536d261be159489b0b093eed27157055a92eeb7ea5727af57a9f93013c2e88f66f4bd097126e79158478c3907bab4695d92ee9adc498fd43efd9a82307a63f43e44f25c709c16efb849d160fdcf9dfa7e290431048e1d8b575f662f27b737e48bd832a1816191b565b623d0a01a531de4ebd069b535ab31503fe5481bab11411c8cb8d2f86afcc069dcf2d5de8730bcdd4e2fe32c1785339d5b25e72437735ca2eaaefa7758dc140ba036105bcdd1a5de11f3742e20348b2b3f54ffe3f1a3fe48f4d496eec349e1ab199e8d1cd1fc9844ff39dc186dae6082d9cf3d3bd18fa3edcff6147c28dc8cc1d9beaf938b6d4122e21cf5cd2175fd6683145205a63cc5f4014a5c7415976520a881d841b198ca3f4169d33c8505ff20e04f37b18cd494924c2e2125e989fdfb1410203b587554385a323d586dda688b6ba8b28ee8282a67301fd8076270411e37e32ced83f0c76a8094a85253e7c8c16d71a5a20d41ed5144ee71065a036962370f77679a29e4fa18838f99a9ae96e5d38470c164a28ff8dcde6c1ebdf4c968f8ecbb09e8699965d123cccdf5b3a47338ecfb243c70d6557eabf078278726148c4e7f417f9d3e06919bd476d2539736648d70df756e88a00b417e6da6d477a4ee8e0d3e5e5589dc8e7cb9795c8f94d0dba90a8403074ded6b3e6cc0212451dd35415370a49aac3a3568185cbeda97d450178e2a52ba0fc997b090c50e9f7b2f77069962f2b69b4384685f22b38b468d85fba795190a8d1cf54faab3ad5f2c4a58f08e9bd66ae0961fee30566a0d789b7880039206c6d9eb98d566b040bea39c9150bc07baa24cef24c8ea59555dde7e336c4fad51bb012c0035a96b38f313ba88df685bb891e5e0f2becda0cb97757d16678e0133540c8fb27e66a4d73bf2ed50806a3b354e86d6677ba18d72c15f8cf43a0127aef00f0b712d4de6fd0e256eccab8b522f5639540124a7c27d50eb3fb0a70f5a8cf6ef27fe9ac290c42babc389c989d3317156d82b15a5148c7292da555594d4b2185f2cd2ee67e7c6ad9bc8c645f68fb3b743ca3b29536a7f9f9d28f3fb87bb86e157c61aa3f1470f7194a81484a50d770623be9d81f1e0c315856eaa6f149db5b3ecbf76f5eccd7a666eef3c838b743bc6842d39675a5bcb7da3f163e1a6cf2336bd9d87f1dc4d0d17c54e8d478ff3ff972c75c850736b5146cada1e8d9ece1710ede6bfe33f6866aadf4581adcf950984e2e82da7c1cd7c001e908d651c29849f9920028eee6b995e6bd4ec651a980b9e6c73ec1881fd9256eda6343b6a4218aa213e1b6c5ac2a34e6910b105976608712a8dd0a3be0ea40528a262e435dbc8e25763c57914985b03f28e101816573e6c415dc012835e39aaf80f0ed7e2a9c9937540cecb1d7b908cc50d8d255f15b5b40a17d27a152066783c725ac96daa6b18770f94df75cce8628572b3ba8c21eda796154813ceb8ddff74f015d19be27b7c005fa9569fd5e755f300ee21f91adb9a459515104f5c54d1c5c3c4632e04be1d23b1e476865ddf9dd4340c2ac048541aacec8c6ef24f399b274886745271389a491fd0eb84fe474429191f86f5b9602bb70f2e73e2d9b99f3ef898b1ec83e540a799960c7152a261e1a98ef8d887343d755367092117fb1917a38a7e5ca32e0fffd18eafaa83d7f4c887e8536344b58d50f1042d944bf7ad518758d3fdaa27d85a1f3aa5676fbee37d79741567ad282a8a4e24bf36f3c7886940afdab96359dccb282ab538b020f7f88c9facbc0912f9c1ed3a2791b74682319ddfebbd4d8d32d7d25b00f6e5bbf12dbf75b49ba33f93a26b7d3a1ab86d27bebae464e6a96764b76fcfcb21c1ff26697ba1363857af0da6f579d975fe4865b01d64a72f3bd22acf4a82d6296e00cb80b485ca4d9c1c3d9f4e219a40d33127e802fbbb1cb2d5a065caa28103f9bcf682aedc847aab0d55a565850f3bbc30ce16a64eb6b926ba78cdcfe74ff3665ff2f5e30cd1444db304b5802c0369c8055f882c96592b5f85c0babf20134c20a137441e21038eec196b3823ffd23b4a02d05cccea374a96b9c997ac853f4bdd88a7d4b7544be0477578b814114937b45123cc2380f3fb35488946e60c5f03c81f1810b103e2dca3fb5d4fcbb74443c4a5fd186673213fd52cd2e1eb41a90834b1cbda830b5bf5c7829576c1792bb867210ea9fc8b7f015a0e08c71da1cf170e4b0b8ce1a82b9a99db8b180f20b23f689c4c4c1e627d196ee79de18fba872cc1f198671f948fcefb64082ada5c32fc4ab68487a5833bd672519d1a733ce889539573571636ce173be3930f9bfb1707574a4fd5f790be09656037bee0cfd5233aed3a4b1d741ece65c389c9647f52e0a0675f9216a7fbd64f7883219c4c5ef19ee4418f1acd11919c6384bf333b5db1e92966fb3c6bdbd838ae23d599e89542586dab7e68d6dc67adebd178ddc588976d78487379eee44ebcdeeba1994cf88eb69448973315b3d66f9b9419138542aa18430ebece1838942dd77679a6fbd58c25649d252bd76156308ed80283f326904eb4b5b8d248a7f8e60a363bbb5afa0dea7af94128eb517531e5a96e772c2af8870ce17bdb5876f338685bca02d2416268156d3853186564636c0adfd9e106b6476425f7fef1aa0d2669da7cb61e653024b5b38e573487afb349b201ecf91fab2551e9daeea523c6aee96eb16859b4a8848c50c4c8b45c2754725af16c9051f0c08101fb89465006ec37be7afaf996532a1fcee663d3b07454978b3e4e76900aa643a130055367e4c8b6bbd5187809759ae86af1304954496661e78ef8a406bbd35f4d08dcf2f0036c9ad23d50cab5d1384b869165ac9ea2f7abfade66b7a8493631fac91e2c0a7551d61f97f4a2c70a4e3956f2a9ef66146792682ff27f775c3a1817cb7f4e72ae7667c68f7d7665fb64f59e57587179a5a15b9aea6b4a2dceb22e9e7ebac6f174b49459bb962197133b0c95438bb14bcf49fe272fe47df3d13a93c371b7dad95644c16c848e1075b5ada83017a2c5f400449fd8c4efa0acec948365b2cf37d788663d98f4c00b7330d726b485d158ceb2ca6d7c232e6307efb42bb558996dc8faae4e76b227f78aba6492b0c163a6ccf56a72e01dbf054fff6603e13d4c13ed6e3e394e2cd1df588ab2a3a56a1940aa72368d890760a69bee4c706e3747cde64166fffdeb6d401f0421feef3bd43cb5dacf0579434ba4a8c8baed5f29c028ec2d569463f10fdb85f0d0a00bf97e759cc994c9a22b338cd439a93e05d0bd87eb2cc5b0260f1cd5994008d47acbd190e67b0131858312618282bcaa88106727929ac4792ce2f529f21bca0f728cbc412f654b2ef6a9d7eec6a16ea88a50b2764e203f7b0a50f2c627f8bf3c5857d4f58c43c28ec5b47e02ffdc9154d783d1c28c540d1d49192bcff81ee5ab7154dfc1515c3ba7d7f330c00d1e287b3e946c6ca0ad674230eb1cbbf2c165494fa67f0b3d9d832bd1a77208f25f4863b1e0668a023eec48ca7fabee39a2f48e2afa915a9ed37a4235d12258e6c629ae2ed19520ab255e24c9aab0c39da91090e73eeb988a7a48fa54a0e8f94ffae906b12397a5dcefd33a538605aceb7992952f1835a2be91da73349d1b6b232b092e56cc4abf86b6c65d7aa33c95c19f4e1b59419feebb9a85b336e9914157db510b3fd4ba66e5b66ee2088ea89db9c84d4f1d39e57cb3d237e048033f84afbe8e85a66d4cf5daef4d740abc2cad4b1c1fb4632ec8b95ea9d6260153dadd71075d7057efde031624b703fac7549cca286058afc76429dfad203564d62f4f1ee258e8651734e18f9e7fd80ec32693b780fc7a4ede6f050eca2651fa30ee7521c23458b57110804e9bd9eaa84f83950c1c8a0495a2506aec1b9114d10c134b9998d783baebb2fd5b636af55f56e189634db44e0d970357efaed941cf1fb8e9b91472b5234705a224107239cc61963d7950c1ebe6dc3ee2e11861d6ba8646759eb61d70d9b1f7717bfe6e521e4fc22b1fc1e989b2b0ee8f79e91a81832ede3071577920afa69300e58904637a30e646d3bec53a872b43805172a7f2d4efef5e35a59fa79ee0b62e845a6b72006f27362742062ea9b9c78c8ed890bb9e54f67c319aab10ce2115569ec6a4e61c49538714665b6d89b0f02f33d6cea06eb2b98a1afc2b1e71b920b0327e16a486b52bce77dbc6194e44b4c73ce9e011a7dfae3f8c92b83e16c781e55561f7fd2316eb9ce432b69436095aea8fe0b2b994f8c3dee35208ca057ab9493154d989f0e6cae721393fd679ec088c95761912936880c1fd5b835d0c168c8b194b65507b9cb8353eed43bba181ec0f21fc094e7a76c2d4832f7894e8fc553846b3cdbbf0295dc61c1892553d75bdea638551b2b2fe165a267ae3b4a19651e8b6dacf263947a670fe00f2728dbb59a4d132bd176d3a51926d6e215a69ded2559b22a129ccf0d345c4b363d684e000110fd94ecd2a88b4eb404fd43dac9948d5ccb142e55d208e77536f5ffbc0a5ad95056bd7b934625369309ae3f33202e39a616bed203276e390dea59369e00d75f3e653d67a3e2a96dd2c33b6e2c8b4a82c58010f983564ce601e3900acbf56947919b99d943038f81a01975fef252d67a62661f5ad0b77ea864e52f1e6d1bc8df80f09478472b559df9bd09bab9b898a17ccd991ed9bd5f2189b3b02f7492d8f340172bdd3631a14254e4437ba42203986a8f8d638ae4f0b97e70ccab20f553f1bc6c08a1683de5b43288e08d307bbed6d302b78ad6cb5624d3ae3bad370fe3844f8f9564d38aee33ed7235b5516b408a9e621c1fd95a36adf80fb0193c335873e7aba8cde29d2633ce9fee4ae2c905f22870410025d8a883bc8e68f273e2ab514c827f3f85f5bf59336157bfd835cde3c22c1dea2ab194bcb744d05bcf16b28f8fdcc5f5fb063187522012b29f3f041441bf8f3d45adce647614287fed4054d5d8d9cdf40a7a098eca60486d71821a229ca23aea9887f0a386f7395a6c22ab46052cedf6d3a44e714871017c22473b4aca5d3c489efee554e16ee7689ec872a45621cb0f90f0060375dd723e1bd2337a365e8d08569dd41c69c38bf6f5df9ca644df4ac7829c0af754161c12c97f82268bde02eacdc172ca51ce5599b233242b1a6f38763059ee109f8eb8ad753ae42afdfe422af3db66fbee30c15fe2450f3a53094d1d4b44c1b95b3077f30bbb2a5d3844b171696301dd512a287e053f3bed2618215a774b25fd1df4593af0a8e14215eee766c80969a931f1d2722df27895228d8ed5389a457ba777ccff55e03d67c1f7465c898672e54554d522bec895cd5cd73ba12049075f881ad69b8ba356d7c08ae50686db273cbdad650bef75307f7431e72298a5a81cac4953db1346be1826689caf19991b2c7acd3639e3884691845403a771c30359ac11aa0afe903941f8f8d3f19a64188b37c6be5b9cbbb6c80bb6c60f7f2146e98892d063f03bd7e186bac19712dc673a3418319c99ae2e73bf547ea23cc07f2c490ba9732c603a8810885539c5347ec3b6edc305195ada49f377aac2a0633097dac21ca27e5e28056b42d96b08feec3d007d9a407f94fffd1126bfc45081314e7f7e7dfd67903944265f8336e9ef78df8325a88a8f19ae08d7f1e1548f6902cd29ff7112dc8fdcbe85ec5416de514c94ee9a703349ffceb8c5ec33ac3036d2d03010d6039158c773251850fced8d7f39fb00ba5826b1eb45f51c165032f4e61c1faf92c46ffbc701445d7abccbff18bb53afbfc8eee2bbf5cfba40e4848eb23e8f32d64e25eeadcd329d261736e31979b45164aae2d77a4bb78c30a316b008197f9c81c0125f91f4c13bca05d62dd5bc5e82d9ebd8faa68a93d45a87748bf4f4aff155d3e04bd4e8570baf392ca6974565d83eb6f2196042d6315e6ffdd86b5aa3584aecca63854aba67b008508f91c3f12f2464e149c3bafae50772ca0fb83b24217b58bf7c72480135520533b3828ee62bcf81f98db4e06f042844cd809d7301d271ea85d461ae7959e2755f982d0203dd90763be599716686f91236a474e94e327e7b0df5644184075f6289a2d87399baf155020c759811ba21f99b97eefd0632e8e1768a735f7ec9f5daa8c09f064d707ad62937940d447dbf945a9aba4786fd0b57683a5d3e11de5e18ca472d830a7e6420d6b65c10e559e4802b11a0d9c39ee03a97bc5ce2c3269a23a4d18c06298c6e55e346baed0c3e46d4e9d3da99f0b7550df2e5b3cf32be8a03433c249a445478fc6511add88ecfdcdb994d3758605878d5231baf73adbd6e353e3b298fe98fbd17cc310dc5f0a80ebcd96a81f44d2fa663a6e8ee34f39a0c351e03395caaf69774770b797b4b902ed87558a68af8219ad909df43176cbd0d3433f51f4c175b71941345059c5aa072d3f4b1af6cb2583f81152aa0b245f957b6499187a681470e914a83cb3249cfdd6b60525f78feabcfb646d6e07ae4e460fd1ed938cd6440655520173a91ead4071e5c60d069f597d578b4e7f5d4a7df424fdaf81815595bcfb862165a84cd1ca61a2ad0c9f653fece6619dd51eb88febf50bc0d988eca4eba57184e4569c878faf8fcfcd136e05e66a07b825bd5dafdd004f70d9bd80652d88f96915d7bc6aaa2444f50a8fffac8fcb57aa425fc95897e27b744b8d6afa96ac4352d6c970c95e74b9282441c296ee1ad0ccb3997a6d781f1fbff6fbc3dc84b7a09cf5cb3036dfd5164ad3693da989e3f8517f10eef333cc8237236ae9c1b3b29db3c42e340ba824e5cf7f6432250f0b3379062689feed54620350b7e483342e936f74bebd4ab627849c7abbbef20313d26cd028c5e3d29425dec76d1d700325dd571b00a19e3315521e8f9a6a5a092166aba65ed574e9a858a8a4434ef39340bbd46b774d9bbb74974ed50116e9a6928e0ea3acdf47eddbaeed8d58acbcaa1a947ff682249a1562e4ea472788e9ed3bdf6bff1f1a45998df67e9e43122b6010a5f1f4e950bdb0f62c5e8bb0359224829a03eb4d9f14a93f17ddb1e435952c8822a02b0929b20bdb569d35ed7c55339f512a73242ac5db5f1b88d9050cf18da1d6225fb942389f90eaf05a08b58c6862bf47ced3295f31751320c85712885186cb4350d5d1bd80b5a92505a9e2cc32aab6651dd8ad5d2bb64320ef913a85e481f53cc14ed67273926a0091ab1a08a40e8b4651f71338e0cada3dc05ffb7417e485d3f29340e5dfa301f3a5b182968f74e64ae2c4c5247164dbfd8287953c50ecbf80e6bffefbed2b2228de037174e48d40362d9758bfb05e73abbf42b63dc39935d92c3b69513f6fefcfa119309d02220a870966ef3bc958b7b13922d262be5f2b4917ca56c8c89d763b10aac970abc1f7215519c12918bf4954620902e864b44a99305dbb3a0bfe3060736dd77104803b159b5b8498e5a25e5a44da7ffeca835b2dd52a078e24f4d6024ccc2a9291dd1ff50d6cd509d7bc4c7803eb58ee8097883c29afc49f4494d3896099dc3a9ecae0df289dbd38606b03a42d27db11260da0e225e73c2f509a3dc4944d084c8ef51902bc8a5c41c1adbaefe0aaaa4973e5dd86bdcbd4d90c8420eb0a2201935eec2f0f91042633ce443da744d02e65cb3fe35321ae22be146c73158262b822a46fb22da5ec7a207b7cfbd6f3eb14c46b671e5b41c9b746f250ac0462608de7f0b97141657a87d4fe4079a0aece58adad835bb86334dee2a6b0588633de9c8c9c5543a9533b9cb7db22471ebf12faf5ce99eb0c36f837580b4b7da0db127cbe6574d08780a6206ff8f5d97810e6e6aa389d94091dcdb0e5bc9eb19b7af3d64893cef587e468df94b9ee58918b4c5c93d1ae9a2bf227cbd440c8295462c777ad743d06be57f9a3db8a4707721cb8629e93969b3adc6884cbc4199696f7b72545785417592ab5e384fd84e1213d7ca7da4bd595bc028b1f9439a9f461efba17ac1bcdb56e42942d069a0c4f5713e82062bd0cc90c5c5a6ccb26d9fee8e307d46f4c269030491396aa5ee17e67a3cc406fa3f6e88d0d0757a092f9e1f42c64fcc5360475415e68648123aac99659193c3e58083b6b437408db603f930eb040cdd4298cfe8c06d4c4f581a3b21040c653ed6a071f85841428049ffaef1622979119227d382d23147e9310e7896f86cb87fbc0a665bec7f6ca06d2053a25872fdc1fad596c4e45f356de4c35194d622ebf0dda3e5a6c67f7ca0b98c8ac7c717cef021e16a4eab5077789d6c42126ba0386d2858deaabd720c2694426deee9c67f6931d602b3d1b57ac43a10bf403d686bdbe10f205873d339ae24555d9547be0638c598c18db70079ee8ba09b977201679fea41e7fe01bde60b1098c8092021e8bb678ac1a3bc427bd989ab0558147276bd2a74c869692c3d019aec4758f4a9d46d929a087389fcd5bf3063e61ef3136643c1ba768ca9f01be0f594f3302b755a8478cd18c5ff37f0ac9cb70f75aa9ad5dd2e020ed202ce469ad1fb8c0d5a4326bf9ffc4c946c03295683ed7b239d44259790388995feb0a32c5f55e2ba4db0334b7bff300779f3ff5ca53388733e97a1b10b0eda3534c4fdeeaac339504756949cb84ba0a2054bf68fb21e6dcc28700f72a28b8f1ce011b0e75205af6e832763c1dd50ab6103ec5bdba26aeef95c292f832574eb10fe53cc34aac1726a0388862894e5c8548e58f94e5f9ba2514aeff456f2b0ecf05709c64b2a2029a3376afde6e4ce5f46c71fcf05d9170fa7ace10cea52b0719a755a9e1a6b6f06e21dc10cc843f05b27a5176ceb1c639bcdce4dcbf6e832bd772712b4a3587229081300733a9bfe6c17c57a752873f3f7da41afc72b07c10e5595b1b0c9e0bfd2a239d7f38a06669078aaf0841a36f6e0dfd470a0ed6b96dbd6023e0fecd7b1420a1c13efd2a432a6ed14eef66a83521cb6dde5a2963583ecef65230837824a3539fd9b525431ec5a02f9ab4bbdb6c0f837361b8eb874875561a5211d5f8a1bccbb6179e73b8d82974b698f85e35331593f724f68ca6ba0e3a5d21a7053a35c3f80caf310fb6e94cf08b60177b43b6474f8bc299229bee5b53f583228769d0ea86e7e5ae401a989434d8e5ac8bba5b785da964af427d5bf11a51b192727d6a7e28a2c68b7405e7100a9c9137d3078caf96d9d8beda9414b9b84f4f348ef8c5b48e95a92fe4aa6485e99a3a3db290febfbe5d88db8ce9e504836cb18220a96b98df8786b8daf3f97a7a16fdc8cc96794f2f7fc96fe72e46e4de71af3051feafe6987d746aaf6a644e9b05f034764e3561c56d37bf04c96e5b8c6cf6109b3c8659022739b53b50f7cf6cc58224f852295bb4a9f309553df7700b11e18b2959c026af94a0dca4caa221de1751e1e80a81999b183d20581e231ec4ed0d2486dd77185dcbf0cd9ab6a5b16dbe72ae3d29212490b90f490c6e688778a4a44f8d49b306e61d64be43c3b8b7c08f6bd014302ca85a43071b67a6ae16b3c38f2d4263bdb3f35cafb8fbf3341b9ebbe2156c64dab102b515817fda5a1a048e4cd2b745a8b954fe9c74054b7233f9eced0add0cb8fd3ccc744ac1c0f4e916d147a258d26d099baa23e46959e0fb2aa751d626cb97cc12c3d00156521cb888715b4e10da9175c3f978f5e365638acf8a89ab3b302a522b97d3f8e2de9c93420c21e84ec76ad9c1a8bb555767bdebd878476b0e7ac4380536144b8e5da05adedaf11845b6683c0423b1330271642dabc25ecd89bfadd369e816cd291888496dda771466f4f2a37d987078386383df5c99bebabddfd91cabd3c0778140edac6a832ca3716b933c534e35e0875f35a9617becb1c020c22e68369216b684d320635586fe1ee3b341454df1614f1bd61155fcc752c9bb363663958d9318de6045a190876bb3deed91da7e57600b73b36bfa6ce626625ed75ca04a1dee940f2b83c3d746dc6dbc73de07e1110fb4905bfdcfb0ac1f50214e4e93a0ea1faeab81f7c940554392df6d2d8ff5052cb927e10f4436e3193f4d2b6feef4e2571afc9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
