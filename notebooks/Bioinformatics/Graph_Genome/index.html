<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"819a2e0bba0f11f2f5101f408ac52747a152acbf4c12cdaa2fe0bfa9d718e8d9c7c9344131a32e36e84e0d2fad750b89ed40ff9f3d20798a691a234005a14609ddb8e61e96591a37b08c0e1c3847c506b0e2cc91b1e5fb01e79c4b7d111be5e5822d967725be2d9647da39086fa480f7aa13812faac49d5e5275734853e0a06e7503190fe348cddca030ed6655d55c446d5b43eb46306cef3a36454f7379c5438bca3df91c7ddeffeb32fe42aa7a5984d65159fe635ee91ad40485df4931ce4c00805cd81c29147eb0b4439bf5f9c6e77775061c8e1252d4c13412da9594c878a2df7a0c9e0be52a15b2df48bfdd4e58ba31d7963f307801b57045bf92abc37b9fee64b6319055f04b1a4598c9680eae8ff8f5fc8edf91db1a3deba39083548599d3b8ec500cd55abe2b77ed0c213de21ae53f6ba5bf67d9dd928be1198ee5ff4f85f05facfe276b2da9af226eabcb862d4a97e12a5b4e73220dd59f670b97735dbe79107c44e4704576866c940cf549eba2de20b56933b7998b076517f2dbf6c83c134bbbeafe9e32a517a068327a0294917760321d60c74dcef324bb92866a4eceea3cf75c51d2ef6af80dfedc0c27ee52e7181cf39c7de3718e2ecac8b8538e50a23e485c3fc340be79f6e1567c3f3a4b1aa3711b0ecfe6d74a1997cfe439793c97aaccdc918e06092946cbda32ac981680965518a274ad0ed7cc568986d83109132240770d66e678dc4e509154ea45901002dd4d21be9c8171b820fc5d6a6dc5d484520f345e055048ed0f967d9a0fc990a2edae6318a66e6a49d9f700affc35bd4e59176272c0ade3ffa868291b571d5a39ceff326a96fc517e9c6ac6bbdce7542641d04a32f92979f4ff29b4263bb590d3ebabe661a9ff1adeaa2c9dcf7caa2885126ffab509d92f2dd47a07b5675a3259af619fc7d54d5b6df76daee8cb510c41ee07a1b4cd659fb93c78dd39d0abee081a51a93fac6efdbc86d069d5b5424a3f1b27836bdb06d2d155baf540645bde422949aec9705a78ce62d0692af7dde4840a922e07ad55ea95ba32c22ae1d3384209355cea3ea76182a4ea9d9095b554727c7f95b65e01eeaafc5d7d0375664252c246d3ce472cee7f0b9027c63fd877460d14b3ac35dfac399ee9a0898318332e213f36426f0e021cc1627f7c9942ec5872de2cd5276a4f4f960446223db3ce6e3ceff9f206c229503f6ece04d513d4f69c6cedb31043c0c321e71f39771df9b58b7316fe7368c09b34ea6bdb71b2d3df532729b5c6b7a6cbecff2636743161686e88cf9696d0fe3ae61212e95e780b2a99426f5f07c7a223fb892cd93d88d32d8dfba26c27758b280982cce2ea895de0ac9aae180a7b3ccbc003e67fbdf439d620688d0c840146d273f9d873980f9784d74af9493e330eaf961c30602de49d6cd7408c499d48253c07cfc810c12438aa0d23f7c35ce152e6ec26ef36dab70eab55840067222e3833fe158dce6e69b1599e219e7cd1ab30f3c6d6192b6b263f2d1627aabc178b1723d251f9322895be377aae9bde90e2f0c08da374a8e31f8e4add6619843ea08ef0672f1fc924b3c786ac73babba37dfa33de02b4ac1e045a7bc7d8c202b71c5c07df567803fb63882ee1b97d1b74c7ea242f03de8d08dd5dad2841bd692b9efa21dc6e25157a18582e79816a826daf62828568027d405c42960e1c4b5e054a0cf349d1a09129df01c5dd957662e4a0ddc750bcbba1895e47caced930eeac846fec2dd9c9179d1590589d5b8960aa6a6c681144a5671c7f435d8d9dec9fe8f1523f09ef5ab0d2fc53a6a0d7a6ff07587aa84d830ffe6f8b130342885ba3398d8aeebbcbbe6103d9c43331ff73e7957944132254dd5df99b4101af4b8572d567ee0d4e4867a9a0e6fe6b1e84e7bfe8931d4f4e59187a331ab0ccb3e2832a11bb857db1518027cf5896873d8777a1742430fd8347db28ccec89b2371c1210fd5ee7e4d21f0c0b878f4d15b01f5fa92aa35a042a2842e2888a88a2583645fed61ba4e69228027fd7d3e2811dee4929d3786ec132b7dd88995ffa50cafe577f368b254bdf22fafea06b823a4fb8d87e28e4458efa1e1603288a27ed8cfac400789b50c6870e8f58fb6a444fc5c3c8a3fb1068bd381d9718fe6514aa743d31a3b92d91ba898fde06339fada44e6680e6358452e5f03f4e9eeecf49186b48c7c471f2466caa7001c29c5e0cf0b19d080660798e339a08a5655e6b1c3aed50e8157e62a7802dd1fd71e7f0212cddd760f4b38c7eb6b64088d0bd1fb05c0cfb4d709689eb240376439126e8dad7fb1323477101c9e339c0a5775df057aa9b353d2d0a72d13558b9bc7c54d6ec719316486d13bd4722b6cf81f7c4f40d06e79b12826197a19f7e03fc6170e057035660b53aab3a158401c2aeb5931d009194474483be2405ecb7fbbc5cf59710352a85739777651d1c48de248b2909c164508428042bf686b699375b068bca2db099b943538c11dd0450c19f60637c5806e735ac85e38ded3a2e3cb4f3efd538c2902c2c32fd34e1bf51a2776243e0e8a9baa9af2ba9aab976ef0cf85b5af41e51036edf06a20f59e0d9304c325db2d631b4c7024e7a0fe111f178f1eec654fee658b69a0f6f30c2a004bb72008451fe47ffa682955b840cb4f650be787a0a3212cd22a1ebeb7fdad327626a2881cfded62ad380983c745add08bde430f620983b1e22737a9f510922e7789a577d103186f0aab6abe8608ed9403eccdcfa1b4ef8712cd83c7a44170253df9ab85ba982fbde0c8c536fd5db5a321c01ccba174b22558040ed4078c6bff3dd20ec14e78d5108e6ae390f90676fdcc8fdbd2b36b7b9536b19e68d8901991b67cd2b0634e203e36227a6c9e42464fdf4f2d567bdd7073ee08f98ee7d04a4f07a12b51545199a3943e8c4df4ccf36f725e7bd49e3dbf54cb55c00dccf2bedb80d29f455451d0fb557656d6c1e3e61ad63efd5fba57e6509d64a3e9496486d87671afb99d48443dbda35a79d0497910fccd44dcbc13d89c9280abdf886b2e83aa6d6983e813674624864a26f81fccb80a40ecb2f4b27ccd7e8b6fdd4a451d6f6f40fae7bc72be948717d1fc45a38287fc6f86e0a73390708c820b0327c3bbdb06892aa3e7fb29bdcdb7ed3bef42ffc8388620f98fd3d05de61ed4104c83a7bbed6a5407175acdf1d23a3babeb8f200d892a4d33e4b970ae43e27034168a9d26464dbd7f891b643b75205abb926fdf1770def5d72ed819ed25934552fd5d9deb17fad28238ed36389551d895ace3c49485c679a48aa764c88422582d71c6391974523f21347e53546fd995e0388e05f3c911096c4653edf35ec4166a256f758e38fadb0bed64454e526c813e24d83897d3cdf29588c124812d841e2694c453e97587cbd33657b4afd1f4f34a5fc64c4ad31966f3b68cadafcb2199697bfa396bddd4b30642a5393f5bca70811253d1f5309040915ab3924c2371eb55bf477d89725eb466df17166bd2c3005ed491b10fe6848215aafc83401dc0926eaa1f731c10f4490c160febac2b68c33b93d84cd26c5f99a180dc33a6fb336af4c8b5060a0ea02a7b3699e50d8b5b7941200af1466a05861dc7ab8e876c69cd4848d634bd08c55b188737a8d2357b2ddb763288b32a999f35fd8533fdcd7d5e470932af7b6f925d9fb7fabd9feb6cb9bc442e9e13c4bc8e9e8f5bd4c98c152944c5d06ce9522fea3545660df55d2eeaa3b5c2cd4e85b4cc8c8567cd446c0add97e13efa5af7e1843a2bcb28b998a406e65402418e4021d03ffe0fcd2b8525674632cba52cb79e0771a407529d2380ac658fc05c80eed21112a24cc7dfa3b17a3396297f46cd533aa58ca1e24f01d5936c5cfac43632a8fc81f6a89906dd7904825d6bd01df59eaf9ef4d7f214c193279b05fa124b88d50a17b7e7e1526f238de248b21440af3a884ac087d83f04b825563c2cc510e04bb4fca5b94123595cd62417631b5ca0f5dd78a516595f07f4aae2ebac22ff911eb2e55cd7de27fbf823afc9b661ac71a7d257a36eb3013471ecbb337d002db86d35327a05545f6033cc641e9d50609c4f47f63b4286bc32770513e3051047f7e46f770fc1799ff5cb4c443b4727aadfc9610505113d24925912b99454e7796fb4c857560e0118dbb98138c280d75648579ede7cae64d52e5198c38d0e90da018206024f3ffb3dafa40ab3537175805f1c76cfa0bf8432a4bbca82fca71096b48555e9865485f00a9692ff452aedac938a5838d55843d436cc36ad1512e81fbb1253a2963d60ad35552bd21f52fce510811c72f68eb6134bc699a7591b1e0829fedaa8ad7051ed860e5c5f02034de60ce762ef2de3b8d464dfb0dd3c71f2010f9968de48a34aa8b6609531b74c898e89d94aaf6e86895a7756c91a60273b92e8fab82d6f6557ce922d0e3bb206140e7aaba9842cea0331f5ac9e1ece631b899e9b61d6f420f36bb4e29405cf892856aece52590142ff91d303f575edf4c49c89d83bdafa9f2e96b8dd4a93d8194256e579a6e1bb401ea659b70535a1be749fc16a5ef392586a972811cb7a3579b15d8556e378dda9ce2bd640311ff082da6c21f9390f91239c60795830784bafb0d2a4c35df0fdd955a1a0b99c6fa8995db7c362dd67b42b54ac15b888d0ff76475365c75bac8b9c039f15f6ca82e69cb8d6bd15fe4558b7b58c6de900df35462be5903ca08f1805ce735a2bf934a70959f25f6eb54449b14b24830dc17496aa78491012c056149279d71fbd577ac8ac9d33bfa2eba8d38d7a44cde800cdfcc341244c5398e661137baf04f5bcbbc9bc1c920ae9846e09f49b67796f88735caa021e820ebdcde0a8d2f38c14e62a52c8b92c65223ff3f609c07dad4115886484ecb566c2cf0528ddb59f40262e534d78b39f5af45e5778c6d9b8736161ee328db7f792a6f355a8ac396c44ca3224e3ec16e506c3a5da365b07c20e31476f12082c4cf1c0e8935f8d6449c8938e1d81a75ab97d703456b159981f1e64d8b77644189e7563bb41f18a69a49761e1f46d52858a930e5761e016e00a66002a98a97712347664d7f501321a20947be9ad3d41c2d631c5df316479ba2ce6613ad76e076d30c0c0f2aad954cd57865ce0dd0889d73d5b7cd8b22f060e013aef760dabc5f639e6b6bd9df2d7878c6aa2a4b33756f0b129ce02a74617c3886a52f9db7ed4ed85caa98f1a10143292a1c99f6b9654b1098948df7c08f2d26dd0885e94e4efd8128c47c42bd62eb514328b69fb41ef8100f0a8c7f2b1efcb047034028399477e02393d22e4b9b4b65f29167efbd265d40eae15e54206ae5aa0d60666060d390eff071c1c51f9c3e171f0159eeffa2f60921c5f87bccd49d26c242c92f8a65b9a1bb0166ae1d31a1602a6028af6a2540002c206ecf8f20146325140cd7c1d7528328964de78a83eb7c9c11db2fcff51cd4b4713041d55f3b77511788016499dab8c57256804606c8460847b40b58b21deaa49d3a3e5c9cf4bc4eb025bc668c588d8a8eb9b0b2bae1eaca8a72e37ae7ec9710e1e7c268e5a93a87ae3655431a90469c0c89d3fde2d996b0eb619465ef1d0e085b9b28ead4a6d7cb628f870c69b039752733798e2ebce37605bc32c191a0c9508bdbb0f2298d7cd3f7a60705bed95d674e77f217b91359d927c90b2ff6cf5873e9cbf50b9deba9d2eff8ba5af8df22f1311f6cc031a7f9adc205daa3ad9a35c69416cb28196d52546ec28a04abb34475606ab12f878234e58ecfe09c2439209d89b2fd2357341e2ac2b97cc6fdf624a0efcc8a3edda54ddfb9eb07b6737ecfacf152d499dce57746f86fd06d63e25cdbf7baef362f66699c9e3f1a983c33bde9aae2211754a69b478cd849eec2a707655c5e6630f8e6a72f7556b2056e016377ce9b1bb5cbe6be91c0be5883f1531fcf8a56f700e48f23f76b6885da2263054c13171c9fa3692365ea29eb7f13a8516c1afa3e1b050166d35ed2a1b2706b0ce1e9ad98a6732d65a9d4a10bba5c00443181f21a7ebbcff9222789c17c66ee74009db712950e030e0169a0eaa9a9c19c9d34ec930531ffd218ccc24fe1db225067d2c249a89b59c240f93bdc1f11d98b418dfa1524b40eba27ccb621bf7ed5d1966fe053221f283287cdf74df7661222c576e1e137d4149529edad72b4691d66857d19a124a976b38695a788c3f7ae6e99b5995f746355dc9f31d4f952f5d41cfdc4fb08ff0512ed2af7cbf94ab3ca4a38282578d1dcb4fde71145e0f51be0220024332fa073ad1d86c99277299338ec666006e5ee92f97c416dd5fcc8660ccfdef0b495701d5b2f95d5bab98f081f64095c64aba9d31af2d1e0e480b16b815d7e7d841c794b4160c15fe16f1300d72c6e3db72ebcf76372e863041ff4efd480770fbd5bc5aff350fa64ab0bfe146c8819b6db32234cdc8f4fb464ddc251d86b352f681f13b9a1df2294a0b92f973afdaf3be600989be50cba50d8cb92cecb5faf7d4877d4fec4beee7ea318052333ee8b65d262ca7e3980e7cfc34f44da82f462891b0795beef93330023c5d7ea0f1b4a06eb65ac3395df3b066653e691eeb385e1b1670cfd6a2ba0330fec9fa096856c65c1dc32796489df1fac628338069748097943ab0f91c282632cf20c22d60bb19611e76ef9c423bc25b41c52bc9eabae22ef9455f547b53396db448530307b36cbaac9995cb8472585340713c7e95e6a41d1fec0a9df6d87c78f415cb95ca0046b721d9f92b3ba1aa054b28f26fb5b5510ae04886c9b9a13745026de74e82fceff22057727c75f6239e07d374378d8c427b1aecb0115bb0c5c2e6a1e07414751b7dc92727415b9818d94b76e88d734839dbd0a28f24363bf1695bec839ed7ad3fb85a22be153ac1743191419041e3e0c710507c4ffe6e9ca6aa6829dafb4d243da9dd7162b7254a9aacf0cdfcecb4e7179888cb426e4a125efbaaedfccb69f25a654bd78d51dee6b4af43b4255c2f6c997838941539b66263e706be3142d69b02d4ae2085d5973d0798b37a88a6dcae650efc06b932406daedf9ae7c83de39b54c51817792fe37e5ca3d33e1e9ef73560ce51206b4b77bffcb70f43d38cb0174c70422e98d185cfd6b7caca0217241b0c4e4d165daee7a768ee4ce7c13910267ef41d6b5c6672a58baeb9522322b682b5c7e2266e2ae5a11cd463656eaedbdcb7c7777e6d18679b3aae3b6a4aae03708e28fd6240c8507b1c3604e7d2d1fca884a5e4d178b2eff4e644c12d4a35427bd6cf06b2f1f44dd7bb410a0478231b588862d5d0733f140a6f5a1d7479937a42f16ad85ef8e6a1161087bb740828554c82791511583d318e54a640c0e65af81b4f8453bdf812f34d4a600f29669db420461506645d510e27752fe8c2d1d5011a11412c47ed6b1c2a6345878a346861c3be9bc021feb24fc61d9d38082434cbd92b39023cb8a5b1f7ba7f76210264b4dbce956b4630e7dfe9b55bd8e60c008953b5b1de1ba5e690c3b68711789f06a095d47d50a1a3800822ca523ed5fff8a68eecdebbaecbb5df6abb332ad2e2e3a0a5ae6d21e38ed100477c362557a18cda673f54b96f83cf3d0f71dc691fa671907e035620dac280ee88d28a0f2f0e8432a55ff499afe3f429212b9566d33fa8c3285a71191fc08c5d2e0986b09e39ca249eeef84539fc5d9c9746c0a7cf9a14846400fe84a16af62b46c2a6774b80760a2e44742552355d4f4a1f8fe1818273deb2f5fa68f927cfd736bc459a8fb332da5b348ea28529774ac597d6c53dddb2621fbe34362442e9bf3197a5536afaf21eeab8844dd7b2d4adffb7103785350e0e148a5a6112f3727dd685b8d0d473cf21ecfc1738f5c7d72c331e980b6a6b3f72ccd234f9d8dbf408464566dbd3cc863e548c3f617a6527ff6d34ce4b4e5b99fc006d35533ee14b37e3dedec4d7cf41108729ffa8884921074b581156bb7abf7f14ab9a4b5242482c7986f5922f9b9d14fd7da7c1df64b3fdfbca38d67fbfb0e9b943c40d272eadcf70238dd1405e31290a5ee10cac3269b80edcb7f7480493954a9e71f51f99598517c4927c4882dc6074a71d7ade1608fc21ebbf48d1a166a1e6077a320c65375901c14fa93d64fefa09fa69ae344c0f65d620f4f0fceda992e50fd8b38c9afba0d49fde15403e372138cd90522dd44f03ba5c8c69cee69be8f31c16845c7922bb6e8b0c4db55bcd585c332b09d73d30ac0c847447c17a7e447012085c6ba2e4733b1c8dd74ea1b6ee1bc3b4543906591a750ee0d52f4bedfcee3bcafcf67dd6d33d5e63d63aafb2b058608b0302359a9aa7be868824843ad531ac3bc24f6f92b1eff1855f3827bfc957b464b444b9b8c1a2877606bec0cb4ce49a20d7aa716d3a09d716d7d5e5a592454ae23c073ffc15820ba6e5dfeeaf0c55e925a8c86943e49bad5325dd2a383a79f4cfbc10a5c99cda34ae9a603a164fa16a1b8b37917a665bc47540e1751bcfe49c378cff7cb73103b01dac3a56aa86ab658b64c1a46f200e88d8cc140f2a2321885af7449bcf1443744605df03001f96503c69705870c4f5fe5a253f4517d1248cb129c158d93cb7935a0546fe4999f66a2d5920dc5ccb0cd1177379f95f4244dc5cbb65db26415fd5c53890625d40fec210cbb88f4e0a38601a9cda5c780ae3e4301376c0b0a3c910a2d60fcad0df3e9b0d6645b21f94793b4c30bf9f455d85302ff198022de6b874084e0a43ea9e0af0bef3f3ff0475857cb2e27b694faa1df0d4d87a50a61fa2c65bdd0e38b3b065279c86a1e98069e1679d934c9c4a1ee1f241b2381e300382c1000a281193b18191ac79b69cc9ff09084c2a90d4f58eea586c4203f7474f3aa3d3656ee88eee6db6c373497f5a7bbfdd5c80bd78efd73537f697927b721fa85fc7f8af05ede42d7d53822ca295a36656f246c7d627db69403e767d737a6948e357944ed4bfce37d2382d3ec84964be6325ed5c985f0ae574d1ef4d3e08ab52c4cbd19793bfde7e1aa52182d8aed96c5bf721cbd8f76baf28c75f6ab7060d98c0aca9fed899bec8899a86579459a9485aa899b3a1b71754140567d15001c4c38f481f940a9960e115154069242b5bb8d8796f2d391ecebbb1d4e068e5cf97da14a3d1cb658ff80a81beca16c30ffdbb3e43c28cf9c63b4bf36c9ece0ba0e2938895177a284c98f222b0f7363272c5678634cec0866ae1fd3b32bd0f950a2f1b3598d940e970f339ad31ba39d56ad6bb6290747ac6906141d8c027097fd3c15c91898de29962cd7fd0e411063b4bb5b0b6a034b958068f1ef443690f1d2b6d97a2a538059d9fa61f1039bc2ae60149191faf2092f1a2ea8611a9e747e6cbc47c4c04a47e732c8fa00e9d573b7f878c336b0dcba9fd8622fcdb1c05eddcc6dda3f3764421122636fccf046081e00a898ce0fce520d4efaea31ff2ec335b153be514a4b9e2d587c6ddfe71455b9bc5eb034597d2b7f63e553ed801909ddf297e7b9fd941072ead0c3d7c6842117b70ed7abfc07702e988904d56223f849bf7cd440fdbdcc6223fe4e1402bc5aa26008f8e373a67769c6add1499f98f7cb170e56882f8fce49a5d1f4b3790f8ba39d077fee49475abccc6068de2a995d31de678bcf6433bc9d1ca6916ce41ba1200dc0cac166aa4518e6b04e44c47d97405a2a2c3b672c48c484e179fe076a7452ed4a73ea8e441aecf03c09e989d018fba61acbe7a119a950579515d4fcff16f8f12689a7346352feb58bb777355dcae78508be1940242730c8e792c389feef4ed192ab4d86b219ea0da2609c165fffdfe459d8b2b96e780442fb3a276fb170d420a5c03f637488b6f9e99b8079b7faa8de291088f1e5794b86937d8da582087346f8c2c041f8262818e954e7ff2d270b2c64b7144501c4463314e37009016deada043a42c2bdfa219f7093bd4ca2c43c214b887cd24ab65aaf096cef28a47de1032c4dee81ebf02247e85f571171b0e1c3434790efdc218349cc1104e11fbdb95ebdecaa38724721b90251a29dbbb230c76a9c619a6c5dee4883c0f32f04ba7e7f1907659b36b05f411fab5611a6e84b6fee942285e5480d9752195803386fbce5e3e6ed2a638796199f7117f5965d8fe80f477c8c7577812491f40aa0ceb76245bd2960d16ba8f8230d832f840a1b778e695da6f3b0975e5e8f7d52117af65095d748ed56b7b10105a4d7fe2a7cb7765f29526b74e58a024455d071aa9400fc4c6b57b227e39ea99be6d92725fd22d31661642d16b6be2b524e5c17c231279c2e930f0b7239632571f98a3585504a0b1840162aedfef8b85d80d88e058e1b7d35c21e1b57579e5fc5489d50aaa3b2586c4db1b95105ad649a84ddea53585ff6e8734ea19c5c2c571f239cc6e878855e220cb1516145b4dfa03812d8da1f50818b18c5c322b2c808964e75404b7313f9aa2569c424e80ab3828fe3809bc81337473ce9f870d419e5e0acb0f5192f934489a0164dc37ed3576ba4098336fc05f39a0ca6bcc90757b506e7cc1c47c2c781de246ddd8b7e422e4e933aacdfa14be37e7e528d29d517cb7cc9e1e43559c544944ca2c166524f035040ff6e6b2619e6f47b4e528231fe1af30d55aaa70cc547d8d289b5189949a23a7e8bc3b915af9081dcffe136ed273cb24fa894ca2475df60ab4685790f234addbbf2692efc59e1e161ee1a1ab76a898bbc0addf8db7d4825166a634227ae40cb57aa150d981037f1dcd545cfc759eb4b9df63c84ca042fd52e351a45421ca8d2ff893c0b1bf76ee5ab89a876eed650dd45330c4080252ee8a8b4d7e485e7ede560017776094b4b6148a8c7e355a56f7fed52cad7e67f8599200293eecb0234b33214e52c932bf605f2ffcf382204d73a965c02a8961ff1c4277a0a5689a6a839fee31286bb2f9be2af361e80697053f41243195e93a3b221eff73f3c0039d7c670196a6a183de2907f44476e9959210673a245f88ee80e2c8b10356b0276d4fa6627d4350554114af8728403d190fc21b2e5455c3608e0537170658a055f5aeb2a299dc44d537bbe37535604461759dbb68a436362a6e6cc8c293d9110fe2b12daa44c2f0fd552823f5134d473d0693bbbfbc4bf2955f5fc3665eb8a349f0e956111b687b9b8096aeb08275b0ca2d8e8619937d24a169f7d2db471fac28c7b9ec900c6502e6e7b10c0b6b968097ffd6184aac0b254dcae17557dab226a1a40e0beb6a64bb5c3450aef2b6606d63bfe2bfa76d1c554644849fd9d46c50a7d3aa931a81721835d6ca3f57617b4623b286c05cfeeb7c0cf87b592789159d2a265056f2c11d7691781c5df7cea430340ad901ef608d2e9947008a45bb45800884941916e105782e3b28a17c24ed7bffd4e5f5c1f2747efd21a1bb9a4707499a431c64b2cba26215e7f1a76f9d5764a16121eb8041e2450ddfe8c9481abe60dcbca91a852d23ce5f7f89b7343a6e57b85abcef3c96f98f4d0210425c08ae54ed69e9375b5df5f7dd95c0d5e30410665507b969dfb0ef1353af752c5e492010bc68a2a712f2ea7f37f1594eaf50a127a07a98dfdece805029a816a164ee42306ad4faed9aad7eff7537be705f5937c5a282582dbd6c813c8ce5a1f1c72cf7665e2ad322fe698a3d5be381d022d6981e3a3e255e726fd760ff068a890dc175766af1877548a9080f669b139c31a19cc4f31435c6a8e325730ce391e41c3c1e39e34d278db8f39888f7c60b4cafc102f37ba2880551cd658449899b872a4dd77750281b176cc8f88e1b1374ffd73cc80a1bd309ef64a3ad882993c7ced67ee472e662686ad8a6e0260be7ae1831720934459ccf24c99450d25509e5c9ec99bdeb6f756eebbeff4876ff901014ea2f2d9526061dbbff0174e72c005508ff94006939527b96f0c1be2344349462ea84fa963b02fcad9cac666f557b078c4dcae5b570d34e8d8cbce100960661f6e07b36692af6b58bf4c10c016ff9eb85a5871156aa6f6154233f9bfaba8de3efb7235289a6c6c2447d33a1b64e3343eaaef38aa4eb933ed2121e649ba8ef5d22bf3f071de0d722d8000afd2b20c3e161b8c429c6d506d87d0a06f9cf99f701df407a4f04fcc8bf0310544437b4c568ff340ec6f01fb55bf5da32139a61f45e1c0bc08e70978e8c217aa5be2625daa1eab9f3d57b2fcc5d8a890482a635d49e45aeea745a1169c2b78eee8e1aff0fc53f0afdb68ac223ea46a5b844591ae895da8f88668893945e5d503959e048863bea4b5bb366f9e12abac91e470231dd5fbb47cd6802657a96434f713af9d9301725a6bf65921381d9deaf9df9b679143363a906f5eeafb6f81f32ad4bfcb8990ea0d5aa0becb98759dd7d620e666e5d8e4449c48e01e74f715c1c243f8c551eadc4f4acf52e79805585e867c442514e3f5b7828cf0e38b05a203f09691ab3ce6a15f96f5633fc7c84cbd21a58080ada69146be3cd468b0b73dc33f99412d955a644a5b422e09679ac15cc8d4b17fc3db6f0f6d29dfe6b393c5e65f0b2abc2875fe609a6f611fb30752b53f7127ca33a1eb4d76a07e47be80188060f0174813787f13b3a887b49ccab812389cf94dbbbb3a383bc7e5c21f3288cc0bb4fb7f124545db49f786b647dd4bb73ebd5cd469a1d13512ff4fed7507c518a9b45e9bf453c4a8d622fffc77c48d0942a2d7a941226474909829ca6a9988f186a9732542edcc1da0a136b5c0edf38160f88b648af04ebd37ad77a8e027e31e15663e1b2052bc0b18c8bd667f6bd87212f25feb24ccd38169ac49d95bafcfbf90ccce24db008a1e22b852136f1828795a084955eb4a40765b1a517209056548845879e4fb0c417b97e5e0dc36fb0107908106efdaa58f23c5c1fb43c4d161be939a9ee5b23a016f2af996aceb55f0b2f703c2c2f2803f9b612d0dcb1123990ea815467ffb9b5abee2093f28e7c2332316bdede5931c3776a9fe9f7ca203ec1bdb92426a8fb09ec3860e82104279364c2066558e3e99b85d57cf34b9f1893e403abe0607ad1bfa735870c5963a42c5ed5ac72060ceb63df54c70c6afd5d317c2e0dd39d7eb571213a569883fe1207b9abd987456a5cd60c29eb8fd44ce312080979379787ee2c9d6537abf7739f57dcf9bdb8ce7bba8e9828c03b40d868d890d5f87e1c487d40a1b2522e0ec0838362f18d062317acc6006d21758bea8828836bd36b2db6bb692e5e56d4791b077757c042a7cccbd848898085fb5dcf7aa789f0d3dff0fc49ad78663c6c2ebfa035e37b4fc6a077295672645620d3e7426373af12034e92ae5f9a93042f888d1532f0423f6c7c505e89ebed38ec3a1f54cdc6b38062e58cfcd77273dad249f94ea92aedb0cf33e0c483297dce11b8e50087461eed8105bee6a77ee598e999bb637b17c5bf0deb4299379c643272b6bd497ab064264c37ea2e882ad267ebd73f0322a19a8f419b8ca8298d2a2bbd0121dee9824b907301c41afc6fdbf474e713a68f85f44e6bdca1b281cab2ba5a38468145ea7275bdbbbcf7d1b20bc7930b1b0cdc50bc879b94de0dc7551487259d7ab09e7c3457eb28a5607b1e3d9c53ebe77e196fc00017f632adef179c294a1606b2f1a8dd0a5fc7a552f3122ae444fd7b1741c84fefde077783c7adf8a505378b77826a0c1f3d6a81e8f942a257f5cff714ea8b029e6221c6fd686a2e6a3d13563e888a35e7262f50df0ae192196ff3d7b619bfed26ca432657bdc5ac68a56c23bd54df78798112f75e4c6b89f25a6ad5f3bc1909170c0d625918520bd2e777afd564b2c3a78fbe2106046666da16d78a4f69c346081b94443b1a8d39a3d883a8fd41e7b5a13f7f05a576c55029853c4809ceafe25acc1d26eb2ae025ed5209bbce1da41fa597f402470103eea415f64e4434ef7ca88ea1e2f9548d2f4108478528b9ac9cdadc872931264f332eb0a986f8ca6ad6c3f0178f4102e0d7266158e1bea56f6debab77d322b7d529761f1422a2b8afcc24e1812c8492e1d571e804bf3713430b988eed69a644243dda15ae96d36a4596994e0b7fc2a499714d58da0f0de7af2390499dd6eaf3c02feaf15c9fe5f40faed37dba4e1dfd4218d92250b030e5c9649e5cbb39fc1ff4017459876c259737b1f074b07ce7f8210fa618d930f4813a1d464b63c8248bbe83a08b97c22bceabeefc7cc8656812fb5399796fa18e5b0d7eb863cc82f0b616cc965f0be79b365d6d8dc289ee94dc6ef659adfda3e6c2d3b980c14fa47b2e2dde944cd4048b17a6483032da3cfb044d407e0348e881fee47a05c709daa07a917f36ecdd780ca7b3b81016c86e79d737e974ec422872179df1f9f99400fccf11ee9421885a5e10b65eac2d2b63d4d23667a1ecd455238787ef46869a71b3d7b555087169f93c0a800e60037269e5bd3194ffe151391420e03ba9f96e4ea39f7dc1e1799a84cbe557a5f03ddd8116dd600c19a60a7058b9e11ddea4f3844e974b9a480c1bc7ce98eaa16c8174d9adfd18f444dd9f79d71de22c31521306cb1b3b03028e99f4e69ee8f8ede578e18db4303e7a33ab8c22eeaa607f1e6609ac55aca909d695647bde788bcb38be2d425ea2e2fcddebc7bea8a0c068cdc5537e7eebbaa5ada5cd6ee6257cbf95d31007ed0b371911a3015a241b33c62cc56decb622a293a3d50ffb7fd2e8e25eec8d707129d040248248a125f7d1164b0a2d2f6456a3bc69b3d19028f23c89b38cf64b81293118214e224a1b5f8eea4ad738713cdb5b9471ea40ece7d3840e509094238476efdce98307e238ea447d4a0e93e868786085356b5f6d3b10e666f7121e48d6b1878b79bcdf343473fada0cbdb93b2a32f1487bb453d9c365c730bdc7e211ac1513760488aa4d278948c2be0620e7fd45e24c4a5dfbd3b8b97c182e49b1da5772e86655c50ef536caea112b4745d0baabf404b5b7b044a9698f996728b8b492b39d3fc0c130cc912a80d5ba512db3f33d9f16ba5561154ebe48b4f8a3d63ecdf1624fdf2cd0a6a9b6eff1ad33171666ed2463a8253497b44ac2fae3b8d75148b19e4a14c91b1111b6949e83942cce4b649f049a443555560c2cd25b8a5d458e70075f426fa911eaba6c86e9a961dd44c50cfe57045491255ad5aeffac39a2d11bb8b8d88f8a14e3020b8f7ac7fdd8d477db960f47a61f7aae0abdcb58bf21659f0c5567b5caf1f327acaaf7cd16b6eefd318842da8548dd9cd617ceb4fda7df0763f79707dc9dc7c88063cc45a295bb1140b8ce74528f050dbbd9e83d2202b21020b0ac79106305f3dca85acc1a060ee74c866127a8236f45726b328b2d61410ccd591add04643d210a4fd473129e9c478484994d70d6c5f36dcc33caed1c87b91663f4b7de3913df4a05bd5817e10577f75bdfc835ee675321992a1806532fd8536b9c57501469e9379d17c25b635dc83ba615d07b4f7b102be84daff9e923b27339ce4df85d8d287491e5485258c6332a8ef2f550d45f64c56cef9f2ab85d2bb4a6626b03db407d6cdf4b3c218d7fe6de7dffac555ed216de20442ce3501543d74eaaba1efad2278ed102a77091c7c4c597c6f92749921cbf796232f13d844975a988401e205479ead88185259adf81c84f3b61ace2d738410489faca42d57f6ffca31706afd13087207447918b2361db28215bb3ab4cc41d0ed9e54a51e686c0706080cd1d05d14aed4c4782ac6e6edab21d37787da7807a46740800240f6c903339dfc3e186516e8833a695bdf0c7a7256d17a9b1eb05de3cb2f7c171d7536a49cdf829f6be4788aa10332bd8acf18de184ed6cac5a49e5f6abb5b51c5eaa3392f4020c20846372f746466288e380b2424e7a285f108ea55e9d7bfc1ae0800d0209933d05c249236aeab78d53758963a726041c8b7674c099f7a12cfb18172f77f5013c9aea44917a9ea8671abe4521dc7e75a789e1790115af2763583eca4bc662de556fb0ad1e08fd5db21c1a1f513e9ad9f1e28c138986c1223320ea99e576e0799925d98411ac94e2d47e42d79a2a01b47a896e827cbea93a946600c35da01a14d80d9e35e574983301c09e6a6c70703c3db8ece472a4280f9c756aab419e3adc630d3d76ad0d87b71ea1e95b9ec5c242b91b6bb414fc6110eb5321947c29fee6e0f27339a250ac28a6a2be969237877ed742b2ef43d73ec10d53438e0a1e30e6e2d53181865167f253cd6d3a997dbd5aa66077584858b1d433623143a0842046fca4652f6b905a7e6d0438f8f18e42ea921196898a5fd4d01042dba3b42bf606c8c79dd72f7284f085c5e531d8c84a60b23044aa9de0e26ff5af1125aa3eb3f09cb978c10bb70471eedcff0a3316412ab3d26b8c591b7ccf8a6c8f3b488fa9e11ca027511f1ce48a867270e7731afc466addfddc38215dd9ccce56df927a35d46b86425beafddfa4eac5f77f04a0c01072c02a8de6ad7d6782085ba4125f8478ea8afe2ba4e24f6941926b25ce3247529eb39ddb5052b676a27b4412576c7fa345ce44b7119c7efebbaed3bc23b916b78c33836fbd7181e17c9d95017891dc4bc334d1a7c08f221b428fcb4626a16df06d6060f763122410216033dbf886fbc74925b9d3cc9bc557c1fd77f46264382ad05eb8091b458d2d8b7b2c509df5ee607d77ae013a6e0540a348d7077aea29ab4bd6cdda35657a64be4f7b5d454b4ab2666859cec75f90f6567b2a27bead6126a07dfb71843662d2446d5e96ac060d2b069c51ff53db1d0b2078259b0155db5b08ad815630fd5e3edd69d902284c18fb3e2dc3d4270175b105e6a4c761c220f7257f5b9631ea91662027954e5fc22a7eb4064ad01c4906aa6b37e6f85cb5cf8ae809692c7cd6b9822392750ad66742d668f5c4d9f535b1cafc830b0120e2a8b2346b588cd400f45b1a414d3f07f3229fa19382b9a4d4420f469a6a03f01758a11cc1cf19f84b5cbe11c4daccd80ccc83a010e667db44119f992e5b8e9f27cb1d099bdd6e3ee04bc4b09f3e421a08cd8ff26ac6faccaedfc5689d3b15cdca11e1eedf45569ba01c6502525d132c488d4daa3d88ff828096042bc48f8973e22d3576b3923472ebe09a1b4bfb109237ef428493956206b239faa1de2803f0ba0cc6c110d7709d784c949f75db22057788d126b9619395222b8b9b77ae45be192b22c8e2f26d68fb703b71ba74fa7977cddfc608b584c542b656d7f7be999e494b620b801d386d60f3a4fc7c853fa21a7f062c0e81deb8cb278bac21a0fe84a45000d2e61f0c29b9d62423977658f101aa91188165ce5229b720964db6c9571e46443b109378b8991d5e584ca96252d31fffba1e94fc9f8f684f5a8f5f65f5c24826f6cdba79e63f81c31ce9f01797909991a7618eab5b1d069fcc8f3410b99edcb8e28359e85070839f9f451588b9f23cab221d46de469a3e89aa2087701933cfef22d08f37c8e10e3dd4fce0977a6f6f5b3f2022910ba06fd762132162a9947eeda999996633a2a425bd108868af339a80c1ad49d67ea26e574486475eb39aa882a811a695f301aea2f20004dd6b4097e6591ad31ed5095531b93ba99fc3696b8afbe7f8cc20bd9adfd3488fdd12f8b9044f61805ecb54ff9af8a22d975ddc4ef259219399e2f5bc6a2dd9b93847c5acdd5fc646e51d21d3ea1a6d7e03a064d2b4311e913f126dae65a78813e7a26412e647e3ad8fbcd24b52294452c0ddfcf5868fa1a9b9bb2282d664772ebcf4e9e1cf507c0fa9976608ce81817ffa39539cbdf6aa5203c4b8278186a04d73015ad2b7e7e6647121d29d656a37be876953fe140a63afceb88c382961d481bf768255ace495e7dd30e8b68082358ef4aa73bf268eb99c1439adb99c5799a90eba97d2fce8008f302064bd4f520d0af01c41127714a932cf4d2737087b6bd7f3ecbc034e47e6b71a444c10a5dcef708f60ef280d12d20c7dbcaddb6f01030506a94ebd1ba9a5a9d2b7835ab5ed6f1150cee5a795c15c723cffe76f3fce29cc347ba5933fca5dc756a9c4a992ef79d1590d4f1ca3e8b9b4c9543d40fefb3fc83f37a55df57fe9dcd8a7fbe9ae49f590166f438fe6fd1327219e4fc9141ff8465858edeb2c00d4c1465f875b4508666d377bb508e94894c6ddaf0c838542376ca209087ec796425a18593f95593deb58b17ff2bb8612f13700b9b8b48f70a81398552d755c6ac8a15187abf9b575b37b2c4eb60342bfe361b5c986697126179956c17e5d7122222484dcdb5d6e813444d240d5e7e55e79b4c3ff1bba7c991d9f3da73718756313ea2bffb02a07129d51daf55f807521604b3b96c450f2230d94e5b57e3bbf733d544ce7a76c5c5f21ef2413f243975da69eae1fe6446500781c972caea1935e9726990a05134aa1709f99709a8c9f2cb7234f9afddd932b360ef554e69faadeef4c38b6a6a304f627402759543a0db1d45579e97484ae6433433876f76ce31bc7bc5df0fb9d2131330a3a122650a59f4421ed7e8014fe772423d9f8fc55c20fadd8eca1de53e2f2dd925541d2193facece6a57d5c0ff13d2dd6041ef45775420a9132e722e787f7496e574a2fc2ae2f2fa305b478939d08d03cec17bc9cec39afd974e68596cbb67affb5ba77b5309623f591d44f12851f1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
