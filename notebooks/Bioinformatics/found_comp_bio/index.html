<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d812ababeff0fb487a7218f69b2f761532bfce61626a94a415eb8f46c707b4eec5f7c54e42ea0cb7224775a85460c151ca79849f812fa5338706d4861e62b2613135cc427ec7bb19bf7ae18a86cd0ff36c37841fe09ad7a45ebbbf6d23c0ebc9ac5c6ff29eaaa146e49120041d2e176e037072173d1a42284dc8fbc1b685cc70c8aa5677af8ada8aa0f51e14d23fb7fa2c842b43f025bb72fb068b2930c87f6f83a5a9c82a8e5229fe4012a3858e38882c1dafc5c097b3ea4af77136ecea30d98a265d724fbc4bb52a3ce96fa20b66a73fd544ed487400540549aa62df74dc7beb0fd0dc8d37dd70a4f6f23e6a91f9a2dd0b92d185ab322abc52d517e64a36112655678c53bc2c1b30b87bc7a0d88d5a0fc17d72db64310b078d3818167d8d767a84e71233c93e3a11fa806c9c099ce6ab55e12237ae2bd12466430af021f9bc9dfc06286701014233c3da64d7e70b40e8c22af00502144629fcbdf01c170bcacee77e70e9135d99161a24d722d55447be8553586f5a701277e49c9d187e3f336d873954f26560021c4a1226487ff9fc2fc4b47385a3419e8157fb284ddfe58f3e5882a2cbc0cceecef400c571d5eda82a815863b71920164914057e2b49eabecfd37c4be72de28ba0f650b98bb57507d18364fc4dd7a64433ffb7b3a0da2cda2ceda8ed643124c13a31c7c84ddeef4c028595e23ecb49b90303eff57dd03e7abcc14c7f78a4a9c8a3edf0e8dfdfa8bcf64f352e251f5be933d8149c0083558ce707ae406b6679b801340bdef9b08bf4961ae984d8ce1680f3ca734e9681bf48ada17ea64ef2420cbe8de6f0b4f638a1986eaef9ed0c9bc39bed0a9d095de0c441aa3435a75a58054436ca82e2fe3effce627a3edc93f9112882818ebee88454c4b15c98fa5a763c76e27723b0cd5208092939e152ee30fb7a5d1fb9c3306c556e867042ca74e81bfc6d78de7907dc7d59c386a97fd0f0e84ef26bf7d35e61ccb79c75aa70b5db0fbca451f55caa91e9bf7f42a375062e356136843489fdcf5aa4ad93b18bfb3685b41650d5bba960d739e1aa1465dd2f5981218e319bd56f103a7f81f01977a2bf89859a2ac32bf4e3b51f473515fb74d1f0adc6d94726a9f56e38e300e9ec080fbdb84627e21ee6959638b27eff63cabf26d02d1c4698e37c117d9adb750bed7effe97c294237e3ae20e7aebe0538d2a357c63d9208ab764bca94b5ffc867f0b6d42e64a220e41b5d49907118bdb0acabe0e2f272d2b09b5470fa6ca69273b23a9a6df43be6995903d18c306d9c87cd18ffe25ffd74775763b88f52205384a57297cca946e294269f4207c43b9f0f442393cbc7277f73fb8ba029a33f925b6c3521c3913db0c0fab5f263587734ffc9e386ac2ed0146b3160b211d82069815ebd742c23fb5c67b5fa2f328a71087d6e658a128874fb0821032744c8195e5c7105d3cbf0b21e9e9b68935fd05c219a6cd2b59682c4a6618021594e45226125c0e60abe9afb8a62ac6307c9e5f65748860cdd39c2dfe05d70d7a8c8d35aeb2eab55fdc529240173ecb12f955f1ea7af6c074f0df6af4544e941eaa1f9cb73ce4991ec4d4668bcd02b2a2468b6334203c95d0cdbbde800ae2c541debe31680ec6e4dcc612310893d9ef0d38e25c666b6e8f3b16109d941f53c57686095ed857363a8dd69eec426f815d9c035f3a28c093183fa825888436de6c65ee716735f98f2437f7e24c65d17914444bfbbca6cbc8b1936a728965d8ac539af832f0b9a4f7dbf125a5fe3b36241be3b4394eea91b141834544da9bf702cbef797e5e10aa08045640d9d7a692d469139570d396e594935173f7cc1b39e153409884865a198663e41c36e591249a4b4f4aed74dfdd6df212e8f4b8da9bcf7fd23cbcf63dd3f29ea4f11c533a52c330724242a14b3c6e633ee051764a09b9d15da0d13900a2c681949303020d6cae983e3ae0a35f6c5b6ce96e1ece3c68d190589fb92cfd8e49f95a4c20b0342b6e51b0b0383eedd6d5a5f7bb6913d4f3900bfb1a9d1930a91b8f6ea76c0dc91fd88a1ab5bc742be2425cc71db6159bac4aaeacfde7d39e4d95ca19064ba719e9a1703a638386ddb5ddcee8e5d971b38e2af280cb4812de9ae779df283fcfaf31f406db24946788d8f165fa7c25a0f17163fe4cd40cad4a8af82d6839972a4ace3398b33a7d9f39d995a017423492606ec95527b9fc597d19661d3eb91bf1d0126afbabc6059cc00bc8fc33f3e825ad9ac5f7f1346bfe0ecc460222bca2d4a3da0aa0632e7fe62ace9f66eecf8efd12db57895b75b2c25b9f6ec9bb8940ee83c6cbc49d2e790395fc7bcb356a5a096ca1a6bccf944c936d09d6692a4101960c4313b2cbb79d83a005b8bf62630f4064961946e342181feff6fec43123827c163ccf0e8332ebc59121e19c859b5e24cf5aa444d7a5d39ba890d26dad8005eb79eddebadc4d0ad9204de68dc4fab4477dae4484811bc44ce481b58970f1d9f882dcbc52b47fccad096bb3959392619d8176745790259f0c7049ac72e68b053c725912a2b48ad506742aa1a90614e7a40c76b3f204c01e76f3105aabd17dea5c8ce240df6fb31a1582834df3bf5c64a7fe19c05dba6e32884c6c9e528f15bf0deb998387f12ac9835fb124cc02b4b9501ac7f0cb2689acddd1d6fcccc8a90b23facf0353c9cea873eae23559d9f943ad670e7a29dc70a3b27c97669e5d7954028a2d45f9d4a1202363a85ddba780434de64048610a7b6d21aba3668f5b5e1bd101552560114d86e2a46867f090b9a78173a9cb1586b8fee9f56077fcd45b40174630cdb783614edf41fea9b53886a0c9b6933873e8913854403704b78e92fd86e436436dde3c886eea3041e2033707024f2892df10449079f75cd003528859cf180d33d13ce2feded80956d48517499bfa7174bea8a83f4d514942207ccf21a60d8c9ff84a3c605bbd5701c15cc89b0c1335af290faa89c53a9d1bd91c6f3a73a0bb92cbef8ad014d17219d7708935c3d927dcf269362853f105169988bbdc3c9d94d3a39ce3ac40e4cbc69213564a4c30c48074f823f43e25bd52aa8abbd03302f00b7a4ad6e3c366fd06438516b7f4a4f0c260077a7697d0c5a99b2148607bf170b7cf350500d85d0997548fce72a390be5925d97741429b6ba885d28094e9d41aa52a83c56aefc4ace8ceb6e60303171b6bd03659148259a035f844a794ba3c6e395216d610d2438117aa9903ac027f7b59fcde6233345700d4340245fb07eb2f39009387673e003aa24fa36d900216908f71066f7f90e0ab0b6514cdac590b0a37c52d3342eba9ea95e8d9fd7577feead9ce32815cb0b86c853abf9d35191077c6ca17393cf230e1adccefbd22b5af3d2976df11ebb81efc9c780dc41cd9e7aaf7d20c896ec72e993d14e939124c85a6be0a982232a2c29ac68d5db2a21e31bd3732753e79d6abfb90cf00d62ae49828073cf5b21ab90403fc6db9068a8fe50c046d87d00cc8ee56604a2bd0355b4a30d3ea5529e8f49c4c4cfa174e6c4a94c256eadb7814b4281ea18185a13aa2018080d17109507fccbf85b63a711d3d6ee91625cebcb708a150ee6443e0a02fd75669fac6cb48892a0d87c42eedd83e81d24d71e6dbbfade07d9393bd541e3d3a34f02dc9138f31d2c1035bda621c07784f3f5b1cbac00362a8ee3b31aeca1e009b5f23627d93a48cfcf9223d1e7db6bd48ef7e0ee6889e8dacc5c81130a5c4b3ff895e7b85bb76926060754ca5945bb2394becd8a3f3f7cdd416b4e3bce637b2afc29c8f1b5e85aedc959d0a1318919d524ca0064e3f31090caf985690911bb7b44da20a1a35a4f0e1f2779e5385d2fa41aaf665c0831053d63b3f4819874971de6c2aae13b4e7fa97a1563c34ce8e19a8af9fd949e834b147e84558ab4be3bb2d3036379f6abca22d042f7ed73c57c8f93d742be4c44a5edb4fdbf731457c915261cd3efbda17c70257266c527663802bea7831950e1df3516a3a1168b110cd068d1d33de989206c3000aea277d88f2987a7e56f6456b51d504c11497cf641889d99d10d6e74bf9d9235d5d1c5fc8bb0ab75c4703169305318bdc1142b501699bda7e274a0b2a27fda45db7e233b79395279685c446b36e83fa50bd0f15125f36920be929e9aae1a53dc0804e317beb870e7f918b7e83a0e9f1abded9b64ab584df1742bf2e187ce41501790b3f458ef98b301b5e4da8398ab7133994e80f5240b30ec288dfde4189b55cf955b812be6297211531de7ff701c35afcbf433561e4a87dffedffe0ac8a5e9e20765e7be86680b3cdd801aa972d53e214b4015d17b932c278113a5e792355ee36add4e37b193e4edfd30d89bd382806ba05761808edc9d7c6adf57b57293fc4e7b17ee6f770f3ef3d1a3d437a3d695ea4f195e4871230251f0f6be861cf75b58df8f1189893779ee9c9e5a56ab6c194826f0f62ff6ebbb88aba19fee2373d9b7617b080f3aeb6b09af0f2f824248de9c775536b43f047b9ba662f3c861895f7af8426d052dd38d208528a2b185c75593369680283311c0c00f0be96784a02436720497ec367126e8dfb7c7b11aebf9219af32d3ee76e8b47cd2dcf27203ef116a67a065c6693f19ce3f680b4720e87203459b5e15b69ddcddc60abae6c31e4ad36f7adbb5ef36315a1e591377403195e86d2070cf8eae54910c83c1af54aad766ab4c3d14cbf72e2f2449832609e06482018151377f9eb96817f304361fc39defb1a9cfc6346d7945b687c39b0162f65c7e46e6284a087a55d8cfc8602b78103fa8bcb00a26c8519e73630fea0b98841ce51d08cc3f1b4901ff41db6c549d4fd480be64632aefbd0f174de9943c9df5a6155d7409df28c59c163934577a2a4e5d24d0a6d5cdca75a8e59a8255927433c6269651d7f06fb0641bd61ec47391e1073618c0d55d1f1e5043141f589cdff84019f0c1bc634db5ce555627cd2e3dc712974f387922a5538ef897de0f3ea9832b2ab95a9eb1d705f1fb80230d77f182cc305db2ce18ca685d536a42efa381ffdb7624900a7e8e12dd524c2c6d22366a0f195967d66c8462b9da745f4d805a27399cbb39e260589acdd0fee0bf5fe0e2279cf47193a549ac1fe91e53f8e1ea8a93501cb29f7e581a672e3960da2b6c4538d286dedae2bcc674a1ea3efad6255c54fa7b9fd3a84b468924005385fa2d87ba8c11545ebe6c36de85d9385ce0f7ecd360855e744780b2ec7cf8430e37597d0f63fd1d84dad6bdc8a1e2cb5bf18a87b1ac743ae4dbf369a735e7c9bef6795be0e00d9a0675875e71d99b18039721222eb0c4595374560ad4bf4045705af2b9f92af2235e4def33c37ed168d594186beff789a3e85515f9dd35b32f723235526bbd8b7c8ddc3d41d61951b3d56e687ffe88470d65af6c2536126135dd00a557656837822d2b3f67add27ef6fafee9ee75ad69721ef309ead9df75a3f20c0fcd2db3864b85ea09752f5674d696dc05d104b6b34d1da381c70197247cee938a4984795abc92de9c4ef65423a6911702e89262b58f73192544097293ec40b401928bfd3c5e47514eae2d4de56edfcd63298ee9063d2fdb733677fbc0ac1d3e81286790e7978df27acb99cd1b67e68a78da6e224d3f2438f4841fd53bb4f719a8d46ef237fc59b5197ecf9f6250f0549ada77ed18923bed1688f16ad4ed9c1e527982b754d1ff0fb0d26c9917bdb96d80a960e2c8566e44851b1b419b80ca6049d73b79d76d7799cb400311bb1fbf2332903391367cca5cc9a875bc210c177e5a4a4e91be4aa2f7c04460cb6cf4307ee85ca0b88902cc9da34858e65eef15e96ca9163b666661f9c6fc4bbb87d5d16966ebb42686c5c80e9bdbe2a28a742b2296a5902d58681face7e51192e9510e6f4fc767178c728830ad8d43534faa7288ae427b77fb57c7b36b52bd7ec326243101111eaa5e0ec2619ffa0bb45e655b86e0173711d71cb7207a2437faa250c30e2280d664a8a1c8a8d14929129fd09c28e63f230b1c0762ff135ab6f779e9d90b5f2129c72d130aa2be4ca3890a2db1c6589b39364252100c8d5b972fd8fa0081125c71f4a04fa3ad263ecb03389b02c9199db702fb8a4005929f3be5be932d6673eb00a37166615f05f32f406a086ec089e97107bafd3468d3aaf16abb8386a9791557a32cad7cf98ef8ccf4a9ba495b6e87307cfc2ac714be011af6a7b1c7fadb41a71f135fe45ffce8c8e83d23a0d7700421ac691322343690ff9c7e08c9a61f28dae6b23d871eed515993c5bc481945deeb4b0f11ff8676de35ea6cbd4ddf3efba2fd98b66cc1340c44f2cabdc3841030fb9488c33ae8fd5f3c4ee7a2aaa1578579925c9303c7aed1913cf07a3d87ea2c39feb0895cf33c90c5cfc7ad24f172bdc8fb45b72bfa5ed31351cd33fc2c9a91baee60b8c7abad171f218cb5a13cd0220ae3b10ee754e99fdcdb67e0f6c6ace21127180ec99a1aeb017f300acbbd8650aee6d522d0dc4979a6715026a831ee3b439756ea747023f484e13fded29e5925a7847fdb5b47f4fb5116343a6d239ba9456a3f01f4bcf18131b5c8ef063220836bea5eab11412ff8504d34dce149c66e4ee1a57b2372762632ad34c2d9a844e5ef2cb2228994e56dae475ee5ece67fd3c0596cd0a92244e5faccd4f687a0bf0d1dc78ecfeff24e2d7676ed9357309548b2740a4f4c8a2d79eec44aca6fa40e9697aa1969184190544bde7b4637d15a9cc83cdaf7a17c8a7bd8e4b6baeb8524507161261930abe66a72150bab33b52b88dc03b97382d8e7436f4cace6cce7b3091cfdeac10976c595a646861c3fe396fbfb84321237c0a2c9cc2ed41ccc179275fc4f996b1c8ffb4c2a84dc7506e83b12eb582977ad1a9c4c4e8ebfe2352c3de9dd91be632dd1d90081f644872b5c0a97aee5fd7babcfd0de6b9544055f231b494442f7465addaf815e138cd4bfb09b49d6444babc2c55dde7a2dc5f07ba5d5b922c16a248907ce3d4a215b415901a421611aceee317c2b8b3924d266c4abd707a32bcfd21760e78cf3705e56c83ee0fac59c4d41cbb1f36cd5a1bf35d810e00a64d490c7500e172f77e9db6c19387682cb622c3e3deabb79c58fe86abc7c396f7c685e46fd9f9c5263c1bc75965cc1943d0a901f718b19723208373dd09bade33f7d2d9dfad7b484f5604168245b21b04f2bd5f3a3472fcbd764c8f04ead05a9fd0ba1825a06b39ec862677488d656b76017cba9aba7b68b2c80265e74aa75d848257cffdf93095673144780b046380e9ccdcebdd20c617a67890f9faeba34d8bbf7a9c7133db22cfac758c1c40ad1c8a88a6ea0ec5bfd2a7f21249b8bea51c6ea67f5b95a466754803d07e9aeb88628a93d817dd9ac65f38b952d44bd601f1c813b98991e21c1aeccdd8efdf329e6d20f643d5b63e8cb6c688e6f5576e51140b9fc18a4b659f7b82e4f6fb4090c62bf32fa5ac46bb9335606c2bd5e1fa8998947bf12ef16af650f8d417e27b6371a764c13eec7e0b7498cd7cc536306d15fabe0b135e06f2868e953e45e668f6b1e39ad82555fbdaa81d4b2bf446366c840bd573f0af35f0383061c17cb22402c52da1550fd0a258e290389d61fd89bcc0cd1a77305509e0d1f47268e1d20c63bb15ac1c6c9f2bd04936ccf039a244cdc2e4371946734986e8f752171d37ebadbbe831c3e08c6a71f2494a2554c5ca1b38d04b772ac64aeb6b768a148697c3daa366da1b5860b2f3cdbaa044ff5da6606d7d773a3b44bd08935a49ebf0b6f7ef5cca509edcb6a0489b54ca39a9283453beb8dff54b5d6659b4e49b5c0b287fad128d47c5aaeb3aaa26f7f2a7760934e16490ed7a7d80a3eca0bf0cde8b95fc9f4a98bac4c312a43f7c6fdbc762351b85de380e29f60c05730c24e340fdf7e17c43c5dd5361a80f013a013ef84f0aa6d801ee7d464568bb7b58a6574432fb80937515bfbbc2084b1a8d03c292dd22f95d6e9fc1f24b9ee9c841f914000d2be75b276df4fa1afcfe16bf9a935d146f657a4f5d5e5cc58dd20ec45fd650c1233b5224ec4180d402fa5d19c7f3938103ffe8111403cd522a898a2808cf3a03b1cad4584c495cc3ddc75045a25ee5b5b6c4c570bfa992e10d8eefd0b70c13cf91ed831c033b75d0b270ad3c1b1de33e49b09a6de59d68718b548903fb765513e4d90ef82efde7c51440f8a601b1a6673bb34fb874f115e7720bcdba8a29e4746799de4ca292208cae5cb7323b0fcae89119f2a56dccf9d0cc5317bbc235bf05e0abcc0e68353d0ff70674f0bbf36f99fbbddbff8ffbc7ef97e193b73822a4ce15136bee67f9bfd8f9be9a8b73d96a2a9fda3aa96178d7c82600ee462a720f6cfca5eae4f3c2fa1735083ccac4f972a420928603546b5013e313e5ba05950a5118b98632f759b1f7c0dc1b4c42dd31e9188e9afc074a8be5f327e19a68112d58ffd80d0ed6b56b097e66f0e696225ac63c73b572337c02da41e39d53ef062be84a2aad7857c3e0db056a6acd4c7a7f43e9cd51f43a637040055d72c57e26ac4004bcb37a73865042069e75dfa0749ae2caa5b57800b2d6266544e05ae0867a51466283fe99da9ebeac30561641ad90b4ae8bb25ecfac4884c27236f03dc8b44d08ed8d8dc5f152f165e5073669654715fae43fe0b63a0047e622f86fd18f8dab9dd3b6b6094e37a5311b30cecc94118ae08ab6ed1bf264746d223ff2de4eeaac329fd05ab3fc1b96b0e67eb2ce5d96864dea05f118cf49612c4eabf8a30c27ce725bb85b2ead6d5fd9b1747b44e8cc24d7c7aeb68bd5cd7f46792ec96d3e73fce096aaafaad6d648fd87c88d824fde3b9e592f6bbf2fe9f109a1788c8523af7a9dbf7161467235d74cf2f355f8f455b5a1c534b55cbbf04fda3905b82c1e79153720f56e3bad2868452f5e3a86c256781618fea8caf5c6bd4a485a45737ae113dc30f08fd0d9d5b152feff8be417c7b5e95e67d8d88e6091de7b3ea198d5a0c75e3b0ad671c15b6d2ac7e869cec9611654cb4f15f56b2d357807b41ee05870cc89854aa5bdb289e3c54d0e3e2c9d28cf4319d7b4ec5cad6f59ef77ba2b239c471a227f81acaf7e14fd72540a7d0bc0f44549b3bfddcecbbeef45f18735eb187e55f587385438668f0547c801826d0bb18fbb1e150765a98ec2a483992facc7d7762eb26ce0fa9fd6e03c89ca6c22eb49070f2d38ff178ec2507ecb41489d3eea0a0a1ae3384d966d98878377c79fdf7bc85e931bff244524d2615a4e5be5e6bd0af648cc7a36652637cb8424a4e522473fc069b61f9ee3d2b0d4a9288566fe8cf39030b68edf8c5cb488911dbfd29d30ea760f92d32ae5cc7d91856f9e807210414e915f2923b04e2e0988aedf061f4b007e391491a388ccaa7e6b359a6824f918bb405e8d79701c0ade980479e210ffeaf5d325fdc3fce2887056f6c8e9fd5c388ae938a2f5f43bdb392abf7bcf10c14876fc2d7eca6ff7a78d41017e9fcaf8a1796665d7cbfcf7ff3f41160874d50ec3d7c014b4351f64e514b772bf4b96e339746c9bd6d2da73813ab9e988ec022ec76f25dabc434c5919243fff9a6fcaefffb5a1eda0f16449dafd204ac66da30d3dc55fe06953353af127fa5be9cfcd7844482a588be2bb42be8e36d0fd9e21d97b11bd04d0659ad5a681b1b2961c688bf72b99242c17a7311a43b1705638a64942d3d3b1258a562bb70ef4ef12ae06b0700867c39da2620d6a5d5561e76bd2fa9d6611bfffe64e97f983362d6f695eebbb17c1d68731313d7335af9f8d0259f21dd16b7896a7f715ead665bc8ff3a7b55918b396b9db75415eece70a2c348be090ae7d601bba8e0ae3ff5af9bbaf1c0f95754a78469fbd062e483f7022902c09e12907cbfeda046358b9dd0f2323c3951602fae76646b36dd33c04a5eb7260e1db60dc79d0a34b64baab51c733ae73949c0b1fe0395e74026e97a4b3c037f1019c74774b399bcc3e3a4b7fc24a0a202c28278d3a5029ea7b0a7d20443de34cb4e6025821febbbe19dc99029b7245e899f65435c3110cbb08005da485168822b1891e4d45753a9cd7cc9b2d9c12bf037d953b5f223400bcd45fd11bf33c87611960553e1f414b1780558ee3397df0cda523e051f4c0c24ee33c875e8ba972966eb15049c1ea9d17ea1d9ec2674b204b32beae466a3312f0005c0a65380b96425891b0a76c68342f3e374422b5dc661d413d480d27cb2b8ea88f0df1a16c430fda7c40662b370ee7a1e4ff6594761dd45b1119a79ab28d076356eb3af98e6a67c0a17442bde4ad5355e79cc79bda541744588dca5f6e1fc11624cce9e792f270c00ed9e4a985b0ebef7a7e46bd58bb957b7b8527949230a7e1a4ed879fca7b3f1326c601ea0ac594276ab710707c17383f61d5dce3cc765fb1e1e956490e3f0bd487581fff8338d8f62657f530bd588b122266acb3a5a612fd3d650fda3c513169419d6a042b2120b66fd7686c15f15912bf6e2e0af92c8a45ade5b0d328af99ba14e7bc43db197d3e89ed046f84e9a19b32d7adbe3495ae246dcd5e2887e50ac1ea05acd8013de7c1cacfa9830315256094b2844976ff140fc29348646c007b494a2b4cd1da4c1c6022f46f2fab8e69a00ba1202f2e4fcb39e1f1c07822e9732430afcf7f046e92a7b8ab70e1854e1dba860eeb45e09633dcf1d03308099bfee7bbdfbb37e448eb385fcec553ceebf983a2d83dd597c2f45272b972dcca0cba3ff447fdfa28a434792ef40ad44a5360e39378cf8e083926868cf15733cd029c39d35b261be0309f9ba4fa7cdb7ed5c21166e815acc26c68b024cea5ef3e35772f7a0c03d8b1ee3c9992ca5bebd26c456b1f77dfaa12857440cecd91b3abdd3e5172db0ce750516328d0817ab063060068ba513baee4a8e1be9bc91939aba807d6f06766881996436b011b07778152be388467309f30b119b5a638a20ac7f0d3ef78c8722e391e93be2ec373d1ae02c96abf720888380b55f45e2292e3ab9762c7faf5367310cfe42d79e99e27c157bfe5c931c182446ab7c38641159180cd125dc09a8089b9b27c7fae0b5bb9eec146b4e8d683daa633d639139fbae1528c91b26f4505390e513ae2c00e397f6fdd6464aa20dcf208b238dbd6c4aac24a8ad35ae00dd84dd037e12c0dd21f1525c1ee9eb4501342121deb8e3f0c9db08118db0c9207baef26bda5bb433b901fc985958f9361230d84e93ae6ba56fd4aabd16f6d9b23d388da2cb184676680912c2bfb5c3b7260d18b20e68e910122ef5fc4f6ae52407d3c50a70aee77c7ffef3c7ba1f78e8544a68049707108f165347eb1711747c9034e39c32c0834915ef50825fa96d888aa359e17b5be96bdf2917fe7ed132c9b00a2641b36290d502b4e7e8329dfe3de66b336227ab61e294a95d9bda29083df7cffb57a8996ae927da796591a3897d29fcfd608013ee8ce496545b0fbe74255d716c05d91db0c257427a6fe034778ba45449c4fcd800da6f5d24de34446c7a4599350c22ffc34c47c00b5107adf149e1ff0c623edf49c36b115e995363bbfb28e9eb0c84de2956f58f1c8b8ee4ea309941b79a3ae868ebd8804162a305add49d9c2d0dca4a66f57a511ac2f9dbc40edaa6f2adf8514ea1fd3aefa1c4adf27acae8a9856b79d6b392953ab05d9583e4aa3725f2d08105135ed02808cd9fb5a65911aab7c11f09be25dc960ca06f5fb14f7e28848073d34678a1613714ae2dd1bff428a77118d0b832e79d319107038a454a9289f20e0ec504ea9da19d8612c1b7a00e1ec5378ce4096e3547950ea47bd73ee839c1a06f9e1066084b16e4b4da488ef57ad841d52e62ebd9b27cf8dc4a3debaedf6dbb454ca5df7f74e12d5ac858ad0e84328372fd6618f86a160830f2a7995c5826cd72ac38b5a7847b27b8116821a39768b44ca5210890eb44d1f48e58a43ee525e9169fe6e87ad0bd59bd8733fa413c588da28c215e4d3d4631be70d97f80f1311272471d72fb92b0eebf5a81c256c54d4216883bdf35a994d051826ff3a8c17bd4bec01687b64853ca434b1c874f3f29e1d8d4ae574f9fe8cf7d88151ea8a4b50c2ec0ebc0049637c33b048c524945e6003f79fe1029610447e4a33d242a549cff0f4e362baf3891abde2585afe5735d46887b702e55b3358e3525e10b6be839cc909d0bda28f3eb745b91f21fa4c3686a94e1151e5bcd28de26f0988f31ab183cc6643226330f056c714282ffed43f30c6456df7a797e01a614e95a65f4f98e86190432a4d17992fdce9b36170bae09b48606ad30c6cdd7bea70fd025d3a61104c48760ac4632880571b15577c06c69cc9f59f1e8f2a98d41d496f925b8fafb6dee30721c06db2e628f3285554b63fe2dc30f7666077f15adfab9e64ed24499f8bd6f029a94834377bd9a2f5b3fffde2eacc5a035dd2b5af8ef4e2e23bc768d656c960511bebbe1681ec777d43fcfe8cb2a97d6d6c023d068dcfd7c59b2d480755fab984ca4d6aa973e0050aa6b31c7eb69c4215f8a9112aec9019a2ca179515f0f418228931756a7a927356e53ee9217c541aeae4267e1e0b17ccb5dfa0967f189f5188173fa7a79275392e168d30780aecb10dd627792977e9d9acbf6d7deaf0e878ffaa5ce9f622c98a81d7a16e1ad69ca6a78a19c2bd7fe16dd6aca5a4f4926249c60538a519b08ca30ed7673459d1090522605ec2661fd24fac1e45629b7d85c2cde46ef96ad9b63a34becf5a7f3451b36db520f93ee13e9cb77e68eecbba4fe707659ff06d6faecab372a1d571b8c02e527ccb8130d652453857a3d68e274b5387f24ea720a01dbe302a47fccb3024fbd37ca955a40468fe81bdb92a8a7f661296d0c1dafa0613429c54b9a022e185b9373b64cfd77cf465d9578bf7c84a4847a111c6c9aa5c516c106622e9e112c257002fd32ff31aca09ac4aa4718192543446f4c3e505ea941eab198b37cec7663c4103e3ce2ab092237c751ab03f675f40cac5ad814449a8952598069462b5c26437aef6e949577188ef24e666d2f3a1cc8a083dfe65949b0c5bebdfc72567f287c97ba5cf5e5a7cad8d44b8d49313b59eb5c60f6c4eee05e351c6093c4e2e1257afd45183f0ba59549226d8f58f97502b72f26bf26070acfd9652808a6f1c1fa8290ad8e021ed78106bb1eee30b36d74545ad2b4a0e78a24082e405d9fd58f7fc49cab8cb354ee6b5758b90ddab2faad65fcb11be2e7166ff0715180cfe369c157a850bd9127f5a7387dee55729d8a7a2b13bc313c705b2c024004d4b4a775b1ebbdd86754f8b6ad344ef7c27e56fb9fb66189f589ba4834f36fa41ff3a0588a02240ff00761b037131732ce86e872e5650ff00d3450c7f35a50c923f2557144d1d21a5d6679e039ca423399853192ebfb95a358050611f58f03015f82c25787b368474f1378b9ba446921f13ab086650b2e052ef88e39bf7f446cb9266044418a84cb6d41d187dad9f7e0434fa09422505286dea2a033a68b9dbe6b012a7f240a398cbfd15a0ec7e9d7ce7965d11e12e4c05062e474c98d011cc166724fa00e956c26333bd686dcd4b7ef21707c49726a08fc9204237ab9880be2254ef7723597a755c48bae1221ccd1521488fb4db789d9532d6e3b608049a764eee1a4ab4afa0ecd8928631035818067e8a2b709dd395bbe66a68ceb30ecfcfd8e15f0302b2956d29d25d5247340f578c43c236df32bb5e0e242904de419bfe7c807cb9d2875c1584773edeb2775610357356b26a325b1ece19df036823b83c93885e091f7cc385e02dc39c64dbebca6ee820ae3dd793e770d09095b284cb46b8eec96ce44f4e8ffaedb88bf0e23b767cc892bcf0468206f3e92a9f7ed4b24c388a4e997df799b67bffda08807488f72b0ccf094d56effb1d33f6aa3094a623a8e548c9abe8a8b96fb845cefbb9b799a6af2e1af51225f0b607ca7ac1c035a38942a402fffd1e816910201a25f10b66a33d843b16dece823eca837038b0fde0251bee4390cde4389bd2dd5e4d8771da41ce51a725eb6fd927c1d456aeb2cf1076be46c90a88373f434ce28ab21707596a6ee9acea83fd763c6ef117182e00b19bbac4599eb736648fa41c69cc8c3d9d16175e78ab3320e4e3632e50ee97d399562b7a0887b837ce146cc4b58970404dc15bad4fd6caeba45e86248f4cfaee32ab48a8ae3255e9cc64e90cc7b2d9dc16009326155eea5ddec0a83e823c93433a40c259668f87e13e896aa54a18265dabb3a1198d4ddd87eb3b1c0473f0104d2f62f37769b1198d97d88a44c6856e669142ce8ab2077acf18d2fd77eaaedbb8d381c2d8ad9cbb52921e731c5716fc94212558900b781c06752266e171554d7c37104e668c95863c3bbdb7cb995163786ae6b8f05c0536163763748d69cd291c339422060b86725e03a6b9d9502ae630e60c1d470e50c07c4bdc7fc970cfded45ca814d818339785b6305f3a197ccf8c8527b173ce2511d08ab68d5e2a6aefcc5e264189495ac00f19a77733a36b48515219cd38e7e96191974e44f4974b4f36f7a0f115a2dfba14c22ac6325df6cee24c4c9b34d4689fae55fe0a6af6d3bf96ebc3418a995cb8ead60ff657a839d230c0a820deab96bc3138d3009b8b82df4ef7acd65ced65c2c61a3eace9db3e5ed24990399ec5d113107d145e0bcdb9d85977dd06ca9536c2554637da4562d9c07b6b7754ea1174faf87f737f34feaca3578405307b542654a55d3165e8242d3537da9b054a7cc6b01216424347d303f508e44bea47833b505b7c72a2ccae05749925c8deec1760e10df953c34a99270823de53025e536f3b32a72c4898bdc41206e47272716f880f093f9192fcfeccb88d30e21e7acededdf7942b8dcc6d0d59e0da814d671767f4be820e63f9a5bad261c3ae19b841b1412e993a9483d74e00cb523a42b4e1fa1d93d3007a350fdad231c96300229f25ba6f9d2183b8f0bb7d809db33256448969b1c6a89dba20aba4a66594e3cc5acbb981a0b7d258663ca64f3299eda932a854b0050bbe6af56f89598d6957db70628f720d3f0fe93946e021c2da89383c8c7dea6ac04853b11c8ca99a62f227642a56fb0af0aef252e12691429b2e7bcc1ed2e2d8146dd34135dc65d569cd851e56123f7d67fe2dbadffde3691905bc2b2aeb54704a9a2276eeea5288d8c2de15928ae54a0b224f24ef0e16bb19185e94aa48527b212d7d0f7f8c18d827e862ef841a7a97c1954b7cbd7014a387f6086331fcd42e4b4405444372882ffad8c3940eaf712accdfd5fefb09e8d25cce9a5aa145ca8ac77fa2df2e50d7b6ea5cb5f1169199b4551017825034f92ffd583bc213a467b21e8eda498a684d754334f5d0fcc633095446b50cce0778cbe1449e42bd7d85af07781c3fe1c56fb6d4d6be876b063085bc1fb841d1f3d1388bddabc9a47904539bc4406a4f3e419685df6b7035d8104e0e4709bcb1ded8535de1d5e56b750100c5747c005adac57798752ac80f789ca64fc88b7a61f38be543b27c47862e94a3a94ed5c00ad9c52080e61e1eb277b6020b9665a59d0717caa4d1ece3da18aaf728f5a78f3e0b6c8a188424c21e22b5b83f221b5366a477f61045b3ec41dd83a976765d98dcb910f5f7ed096a713b1c24d7d7ae63e8a5dc9b367c59e5d9ad48705a475c09641bf6fbb1a72cb6ed43d10a219b2f5cf28865254a4a894fa12baa30476cd5b30a838a40ef3ae098aa673ccd236e01603e51ba2bf5a135117379b8ba06ddb1e307182724537253c4c02318508f7f528b26e009dde7b9b22630460e1dad84e08519d9b8a1e873f0a241b6d52a01a2578ba4b6f6142f05665791ee34ac849d5b879550d0234b179cacd2492df01238df82d5ca348ba9c50a2824dcf0df3009db9298ccccd92a1628c84f7a73981754eeff5c922bc1e062d02c9f4f0fae90d0c9d36e063fb5ba4c39344bdae83a1c573eeb2dd4d9cc3a3267b4f628b13fb8fe46bb5e42f5d6878f9200a0f01b8843e15bf5244c1a0e794af5450726b26fd82ba2a04f31a272b9c092bf33856b2522425874cfdafb0fb90896dfd4b12c0b7456025092511334b1a80a78d6e129322f599584ee8c4072992f3dda64ab573d54dfe02d3144323adbf1a305c4144c314f8aea076b25d661829bc9fe6d7b479edf8d5da4429e30c373c55a9c403067038adb7648bb8b26fdae4d87eca89d269359006fd3ae1c0326b2f1e56d81122092c0068f0758014c4cc360a044d9c376396854fcd99b87bd69d41ad266073b7400634588fd0df5c5665ad13376800cb79ce956e22ca979e8e41a14cc276749ae1d37a662f1dca8a2a9a999c15f4cdf6974bf0fa7029a8b357df3e974c071d0b8f714af3127359bbf2753ce0fb64c1cbfea6b4e29ddc09348c547792d8c239c635a603403031716546361e0a4b15a495da3f4f8973eecdb521ff9703813dc83a896edb4ca6f25c3176b0050bd04b8045ddccbc60deecf03dd86fa36710589f5e0657c922d4446724d87af62d7958c62b617af0babaee14fa32585aa5f6b8c68ee9794103d1d6e1615351845b8ea58eee97b577141ab36262ffe426f40ee6d45d93c3714c1d155a61146ec4a9fe724973f19d5219c6da9ffba813d72be87cb22c4442ad49cad64144e2497441f892e5b343ec285e7731f8a099e522b8ac7a0ac80e2b90977c418b2cd25f42600457a4bbe8ae9dad4e181568837cdf6e188d1793e16914754b3359b9ba8fb20a5bb216a78f2ad44be352412372c08c7a951df86a3961368d14c90912069afedce4b583bd401752e8b5c0e141075a9d39e25d4d74c0650c356921128c456d3f4288552aaa4f4da604d994086ef1c95df137c15264322dcad90234f820495706b246769ed4731f154a854f0c085638c91c98793f1d4b7a39d8bf16d26f84cad53a76a71e9bdd131af8e1ccf32c5cbb4ba457d39ecb6227ce9ea63438ee906cd2a1ae55e1853ccc4b7a37211ad656c086be711ceddd4c46956a26eb5d373ae9557c00574e446de0101bad80bf71e42488c849f2e036a13ab8d755aaae6e04d6243c280aaaedfd5e83f414d52f3db18e630f1c6a2fc20afad29829bb63700009f7f43bc308f401b309d9dc80e584d7de615083b8b22891e9b03449be1efcaaf688778475c2a4f1bbc55162edd31cdf2021b7dca2ba7911e384cc958e388bc4427abc2426447cb6062f9a17a37b5f3aa829268a6ddc877ecfb640fc91072d42bf447c9f8e04f1dff5d048ffd42ba2b38da5304418ba1307509439f66791dd505e5da90ae2b889430d22e8aa687ef13c0238f466968233b69bd451828e9096036aa13944cb3e4276b6968032af1b0d2bcb642471861ffd38d7257fdae00350ecb1376438b250e16c478c74d754d11480439817338730aaa399336c26fc45563a22eaeae3ed8b1bc5cb14e5448109b342d86abaa5f082002abd7be2d67c15feef9a526ad306882d8315bce7a88bef502a5f02e5827a464e1635d8fc8ffcc454373bb480e78952dcf937186955a3cfd702d32453c7e022f3b2638b9af00a5fe465a0efe1b4180600a6c202f69bb757a639f13113c32ea5accec1b47b4b15e8af9729e3a14e74b5b4ea2ef28b78b72b0db99736e0d376006e66061e6a6c12d3ca1739ee3bced158c98af5d52e725ffb50067fce479becd2b5609ec42020442a2e918812803c4cd5cac2f364add31236d3d2f90cee77e471ac5771f9718eaa3f7b4ae47771405a1a1aefd17a8d6750aa78e0387334d4d3234a6f34304cb564ee062b09d21448b0348a3728521781ffb64d9085e18f7236fce4ccb41259178c176cc828bdcc71b4da6a994216e1fc03ee6e493d9889d6f5124bb01c5bd623e225aecc38884fc01e7afe9849301fe55ccde9ceb52ad87409253cc6be4884d88dec51d6dc7ff70492e1dab679a46f301d56ebf3efbb0146a7f36d01abe5acda875336e9b6d3f39a597ce89e84047d41a37d5a420de69285f86e3b33ad25b26f4969702cdcbdbc15253656ab468f1ef8e6211e19bc5447b4699473f40fed300419a5c39cb035f50a50f450bfb60408b3c096ec5cc52b53faf43e64abf0470604a1c7a780bf6ba0eea47de03255726a188fc0dfddb0c408230bfb3544b41192bac4ac89d5fdd9d13ef55441baef2783270db81099f002ed21f1d6990cd9944124e8e64d474b219adbaa74bd838e915dda260c4afc656cb47880dd17ef2c0d52bb3c0fdc6c2082ba04c5dabaa3f082be3ed0df732368dabaafd847c4f2347c9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
