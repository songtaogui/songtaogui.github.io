<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d29ea49d2e96997ce93952c145f4807b288a8b21f605a5feb6aaf2b67bd870c9943545075c763090f3b385c6435c101b865bbf616152e823ecb6e34b83814e10fe3571d14d8a3ebecca5ad1aafeb36658ad4d49ca6f9f8b3caaf7923d66f16c9301834c7803ff219d290a9f815dfef84bba006f53abec819f99c1ba0397de92823f010f90face44298a96f7c781148426fcd9505beafbdcc08d13d8358f517fb57811f4c8c970f9524b9be697d2df525ac41ca8b23fb4987004b2d0e82142545d4cf2f5f4442395678fa141d5709c785fb733f1dd7f086ff437c74be5a88126301bd833a9c4171680d9babe747160a2e692c4e9918684ccdf335f5dc64850cd740d0d7257a094d938d87c8a4f2fa1f78be88a5dc70a41bc8ec2479cdd05dcb506e4bbedc846647536f0a81304ebe429736029f4f42c165afa80d52eb1823017b5062725ee757e632f929e7acb8de9e3c5382887ffdd8ca984bc40500e722087de7b4f0ab830ef15724a6fe639a2d1b717c76edc83999b0ccb50fe90895b1ec9fc8ca67f43c4211dc0c864b280770f2a566484c5db6e8071e6edc782b9b3d7adbd2f8c6c1c4e636c5805f4b5ac392bd6799f6e3a79faa06f2e2358b8d86301a64312271be05ece37b3e4933057db9310fdca1a37157c4e7aabec85ad22b0c6b73d15c2226dc1837e9f3cd3eba00a714c52e824637be7fd7ec4b1c136cf4890058b8b08a2d28cc5048ff9bc77312a00ab01c7407f026acb8ed6740d29b15043ab9c1e9ea3c9203cdf0f7ea2c63deba48a5eec2b2833d6958960e1076c6d7ec45e2081b4e529a0d116d7dd444e722d66cf1e9d27055902544a4c1630086efb89ae99bf5f3c7dfe62df38eebaa8116c8c91f055306e912b486790a1fc3da792d7420b05e86e8a694f7a647794d9cedd036de1dbd6d16a6d6150c1fdb1aa4d83849b41da24dbd2d7d3ce736b51b98427777fca9f850b87d30e5819a475ade9ac5c009246dbfb8478adfaa8f4590516342dfbc4430d45c98c2a66c2d412d4ca76a60810285f1e47a77a9ccc3b9d0a299d18dec6317817e467c4c1bbcde3bb264a79a8c2f764ab627504b53950ad2755b99c0cd3c33d2b958ff4bb5db09491f2ccf0b6b0a3bc40d6f0fa28c552594b5b06ee58f5b821b7bbbbaa42a3b37209220b4669180700f0bb69187037d7601b5524306e9954cca8a107aca401b8628673d4dce80332d51240daf4b7e86b1033ef736f52c2eb633f05fe112ee8e1f667b5cc44aa206e356997fec667a482a4681e8db652107448b9a553d244bc716cd8fd9892ade88e3a01dc1af70cee6414e7647d44ed3440cfaee23f5d105e38c2525a0fe830197d69e83fb5e1b35f2e859b52eed16d5b4404248d50cedd3baf9d8e07e6b41eb41699997cfc025fc86c13513f7a0628813a295fb86af94a19b4e6218248c8d60583f20ceaf46502ddd872649975c4d5492665965028d3b9333bc71ca55c43df5de5dedcbb6da30b5377563c13ec315e57eb8fb0c16c7e508a4bb05d9ca6506ac1264dfda1a487461c790e2adc46323020c3e6d6878567f448bcdd8b23ce7865d3a32ed06f9ce5aeb73f9b472b15272cadd70216a86d027bc8049ae86d18ee3895b5154b1ffa3c616fabab61d8b7af5f1e9b13de1d507f5be34e21371c564f5392db1b54fdd834ae376f25c4233b3007f5d62f5a5af9c22f16ba711ef2f33bd971eb99150c3789d394970575cfbf613d559fae31cb352832c1f32d5a321bec08dd4d048691cb7d023dbdf7684a1f80ad50a41b9f44efaeb8160c048638d240ad61086d1ce163c8f07dd85701ca77c1f01fc4e0c19e5f6416850ea43c958c794fc55115a39cb7c4cc4980441a0d9d460afb36e2a951c3d35256bbc9a5b8063b3c2facd36c3a40b675cd1e843be7b1fd47b1b92d2e6644ad9084ddc262e1570a6d7bfbe3f8c0d56343ea65b052c3fa6b2b333ff0ecddd978d0839ed9ffb8df3d4c60bd2c1e3faf5a22032d24e378373b4a09f8f24609bfd6806bbc3fde2e5788583ff6adaaed801e42f2f901a6b3e4a9d5d13b8637cd17c0bf601e947cc3395c8e4712a65161cdfa13b13e923488cbf27b723a209e3c92a843321e4827e669aa20d1ba19ecc6c16f9fc4b92908ac3af79519f5e91a4e59a3b816e6b6b072d66ced1c2b235d6fee710d96e0b734a96d52a0565fb88555b04b74eeba0da3b331d363b573a66ef558f2a8c13f4284ee0441bdf4c0e9ccc76bcc51f51729b29ef590bf413f15e7828600e3080e06d9ec378abfe63986f7340ba1dea0ecf407b27b507276fb5002d6d6ba2b39826c981e901c31d99479a250eba1d158e68d5f0755341f522d21f76396f0a001dcfee31be33014436467990dfcfe6ef540e31f9fb942b1c9b64407b236c3f2c63528117235733ca0fb390da535bddc44bbeb97c1a249e7d6b0269a016f6fcb189f830bfa7efe6ca04d4f3f4712d155156d823e1c08ea6acbdc8fa09b9dc8acf048f7d579ca5336f1f0b9420840f999a7092099295345e699170e5ec4468efb749febb2e839da9065bdefc3319ed9d7b958946467e6997d96096ad044646bb800d0c512a884c42f01abaa84a2f4c29bfd5cf296b8e0bbc3edc661ccc719e1c8dc8e0a93fd3a52b8eef092f7e226829c31278a4a1e39608e8d72e5e2a52afed9924118ed880d218ec365ee8ba6fd9a885620ebacee70fbe232718de50e8cb9bf2e39da84231a49316261a7ca5b74890b2d15af2397138e5496ed2ab990bb5d35579e9e7bdeec4712b9ec8beac58a8ae5f9d79db107a5e4569c90bd00acd16d60a3e943595a0314a9fa258b97c89b8b5ed0ffdb05d86d944340072acb36ebcf26131513478a97d90329d0bed12d9187b38b41c9ab92896d887e9098dbe7fa403d7fe58d271167397252d207d5fbad6f3665adc1453b4bf9b52a1994367876592c863b93f5044867e89028fddb036e641d65816caec72a861c038204aff7cfcc2030b1343a70ed630cde58634289dacd7d97b42bb08b953ac6f24d35914ec9f7ba1a7aff4377bd36b62da1d0819a63296e9c5ecf258fad5d7861b6d75af57e090c238d616717bd517f8fbc86949dcabee0471d9b67412f7ab888feb5d1672688a62491fda4de3ad135897fc2ac9152fc071a8055cdda040185f024bdba6bf79af94550fd81163a262aa126404452f72b41a1c8e6be69cad1ffe6cd8ec1572b765c11fcba1a1a48f0a75ae39384e4dd2efbfdb3bfe2e0ca3e38a8169a2bf76c864ff1b0e53a9975fadb01522b426e7b328707d674628dab5d20bc8033b0c1c142bc26a5bcbf8ec675a6d9f288a6e13d3cd039da70b5b3776f368ed042620b4ea669e52e6df00e753c1ba1b9feb393f4971d7f79f690775ecb77f975514b38b1a094ea80e44f72c0fcf161e42821f9d928b1d3acbd138237f45f49d7108417759725ca545ff342b9f181198f829f9b04014b83513fdc0a623626864d83af3a99374c8f93b9698bcb875d8c968be53afaa3fbecf0443df8cca30573d14cd527745e395ee7f6cdf1688428cf3e12433d62bff88716c1dd6a464eec512e18922ccef65b42abb5b26a8b464a1034224492a1ff4d342182813c10044a4a4438a1b39143173c0fe82a9504a99de7e03c2fd5902deb6fdc5c12f89a6a145d8a6c73d4cee9c2853af952a822b56fc23682da9670330506b94b6ed30af35b5c0b780e10ab5bfec08d96ad533251af14f6d3604ebfe4cf20c2f9dddf4ebfbca5fadc3889ba8d727ab7f28d1e7586c9c3415f92d919032f0a63e1d05f5a7f56fde597f22346b6eef577237e2ea6a7ed87c6a560391fc2c4bd89186c6365cb06d9cdfc712c634496fda8aa8323fe1995df1fbf834d894ed2352f94492c3904f1b2fadfc89c8e1d00fd0bcfdb59eca1cbc97027f133e147b5df1049bcf20ec950e3383cf793ed2aeacd98b0d120f8d1dc27c7231f80caeff9c95c393ed84d2882e5650ff4b05aab8e5406af2734ac132ccd68fd3b47441d141e544dbe3aa87a57a578492a659bb806a9bc641dbc0f28be43aea81d34c993df545c54c50bb76eefa1f5201e39b988e209131d7a8141ce52356e2a4693278d299c31fe95c301010dfc00f59c8266c2ad631bef6e8eaa2ac65653b261ecb0db977bad1c1cb036c1735d7cb329620915d8c5745ff0ee0a780fe10e1b909a362016837145e882193b41e98f5d1057ddc91d38add55a98bb1487fdfda302f9047a0043e6dd59153057c652570eefa22eaa389fa5e7516e2ebe2162bf9a8ce2d314eb6fd8aa4b6e8bcac4acb9f02d7bd8e301933c32c20b0339fec615378179216ea273a267215052bf2aa236f36dc0172171da582dd91e86a94d311e51b6bd1906c4911a129f5c4fcf20b7fc919f52c8176a2484c12309efdb287f8e2b1e8d7434926ad136035af4a6476d6e0f257a7ae51beb6c3cd7bd68777297deb03f6ac781e7250d18fb3398a20cad2c3ff5c7f1a002e054f67a3ce936200b7de1efa61fbf68ec587ce2f4f99573ee3029772d8d74bc2b0d156b2d1b55084ab9c6ec42a5300c2c895edb1c34b98ccb4432ae882e366449526bcbd4c0d774049cfb08aecdf7254c97cb7cef993a60c7b419a858643d64ed71ca2c971bf38304f0fa33c122933bd4928a9fe013601b75c4c699629cbd6f6f7afdfdd043aea423a945f1ab9a56c95a28260880f0014badb20f626bfe71325c770c4a4c55c5e1cc515d19c684bf30b522901eec2bfc000ae6c72d6098c7fabe211c8f004c1a9158d67b0d181aba4cf26d071d2eb2e5c5df611623065849cde0b5df194ad6c90ae15169cb40b77ca8811aaca14ab0d1638189e348bb984c1276ba65ee2c214564da942a1d649be57398e1a395a391317ed080cc50da6a9ffa726e28cbccc399b5d85e89b359b34a0d3d44137e90ba9817e8f775ff732d05eebb963af8633ed38b8d58d26c640fa71f89affdeaf7620a0c4ea4c107739f80caef2b7ad9512204a4568731a5d3177809861a33c688ef0ef8c65926c3895bbb51c435a5517ad0431b40fe16834d8850fb598eb2939fc5b43733f9887409d9f5cc65b4450df8f9dd96a4aa892b2b5e54dfa7b8995bdae1b2aa6147b3dc2a6aee958162d90355b10d6b987f9792a7efe07806bd1e25d3161905b7bc221e2208f831667be8b1d1f913dd4421f8d5decea5d50b19efad15714a1ce85fcfa8799edef88f2375196415f9edb87f9a09783b3a59e8dd8b5dd7b253a768a7050bc63c773df43c7cee568affbf3ab67a06ac69f5e3ae79cd26fa81d5cb99d564ddb051a042fbb5063d03eaa1fb83012d8e6f6aa2cc5569ba22d54579fb3a82ff1d63dfcbfcaad5b75fea4f56694ed022880f003d25d41ef91bd8ab2e310ef28f52de2d0c6257cbcd38c165bab8edd76d65920f86eeb62aac5c8bdd705d9c25775458ecefd7f00216be173781cfed0d1096d61a21b4b57c378ae0813547223b84fe0d4583540fd0dd93dcf84e641ebe7a308dfa61fdece3670cddb6a5e80e35428814d399a2ea4adfdfa7e3adbb5ba963494e4384a0bd6ccae89f64396f0dbc5a860b670bb96dd9794ff9bc54e5e3378b026e88344f044985fb94b8ce02c0ccfefa754b105cb9187d382e8e8fc9b5f9c5c2c078e8b09090b2b5f73b63a9a78c31d019c8b4406293477f17ddbee2ff785560b23a0ece69dcd6fb970c4a1740f66dbdeaccd220b50dde2f0cf18dd143d804c9d5ea47a772e07d4417a8850c9e75276fb346a9f4465b3c5601af8454a165ced9babf3520fcf0d5ce973ed5efd3f644e7b2df4d3a2d7c28bf4a4050f098d4db357c460c19925e376e0b20ee178ada6309bb86c67c9a0adffe722b6f2cad90dd33f41fc2f43d365777a8a02ed87787da665159ab2dc314fdd3ca6830a6f92d9aa142190846198a7adaec3e779908e283e343db302ff74156437684233e84e8d918ff9685ca9569c1a48544084dec224a322aac4db77ad7dedfe45b95c8e60f282e854b573a8bad08e824d5062f2cd186537fc0f9401fd7d70b21d0641ebaa66d0a695b32071984f15b8799c7531fc39c881c245b0b5d83506dcf210319d332712092779a220e991b3403edfcbe97a4f6bf0d87730bd3e1f3c02db28eaf22c0fa33ac35f7579aaaae75fa0e00cb609dbcb71280d3c49919a6b8869e5d62323432e4289f768757f145ca524ee6401d79ebe90cb3b2477e6231f087c4ef5d654d2a1e9c06fe0cc0099ef6040b131e474475c759d23c6cac7af9035e72649c3e8ce219d5c9fed83b59c4891414513b1b5f7a4d4a0ab60c5e7bf897c014149b8d079fa6d8044e96823d726790aa76d15727e3f00a436ad7ff47477997014f8201f15f19352e8d4a1a6286954ef1a16edfd601174d99c8ad9f62d00b5ef804bca91ecb08227e072153a83dc2daaf14ce428fe58e2d6144de39d080fbf152f6977ee70d93fa148c75089f0c9185768adff87a3ce758fae7e7a0187478a8a3134a88216fc236f6c8db4ed8336288d1511e4b15c73d71c1eb2873c585977dfaf88943adec74fafbb92db550c42c7df3d5fd1c2d3c5ef321df6f2a26b563ca21af9262750efbd333c081222c0b59b73a58a92030542f4d88713e973d0858ee00d025daa31953fb9aa9ff981db8a141dd63d1b187760fb232e31fbdae8f5ff66a7d97f609eaeb1d41a9fa76dd4345528d54aac27d14b6646366040ec6262f2a1fb83abf2a8ca4a0b6fcdd7dda2b6da65e0796a94be9e9986896808fd8083c2bfd17abf47255509a706aed919f67cd1c5f05e5418b522889720599b59e391aa52a1af7d86de9d463e3eb91a3748bb728eb05ccca2da3cd204859e860e3a68df8219b6f30ed4ad958688cc23d7f7e3314c46145cc6e5207fdf55570c44ef5d2126c80b06d9dcdfeef7bee7f285edb833498a4223d3888349bacbe1fa017a63d4143eb21bbaf1b7938c62e48ee083e682ad2e5d844035dcf333f2f01464f062c0edda9c896284b54e32575628ce79ef315ae7b897c1598703dde4bfabe8d1e75a493cfdb99ad90755eca56330a7686b8afe2ed9d7e0767285d9e3482dd587aabdbde2a5b8a57ae97e2adb8b422cf2b866c5cf264469e28166a9719c812dc53963f37a64378d39ac769a1406dd6581e5ebfbf5c62d4627e04c7d51cb9154371cc5906734536344cf44b9537f3ce88d97b790d9432612e57ff32951836881d2dbbdaa00b7fe23ee5372c674bc6ba2ec25dde376f2b4061b419d558e7243d2b70dfbb412d436834293e32cc3d178f2fa6bf72141dada889b0da2aab2cdfb59056581a0a49bc9f1061b9e63683e1659ef0fdb1c895d74e0cd90ee0dd335e6d1ce62b410230bf7ed28cac79a3b45650b1da513c568a910dd7b206edf96dc8711688f7f9c75afed2657b9fc323661022e8d8949ab8f6adcd150772e6742c16537d614a4fd420d1aec35b192c9572a7904164469a278d5d45fa0b5f5e04631496e8435d4bd6cb6059e806df0fb7d18f385c0175dfc5ccce32c4bfcea815710434fd600e8e2808a2d03a3cc91d205d2581767900e961339bb6bbc3fc3fa129bd818606f437a068276e815f20152f16402f2637aea8ed0a43d5053ed6225288073355add05b37e4f1ccfec995c89d2439cea44acf77fcac1002ee47c924e1d58b4e77a4d8678f4b96c3ac6544de8132de744d6689be360e00dd477d87bde8a712dc995cd6ce56536aeff13cd8c1941ab1b25217c9f958ac71c79873949f2263129b9702173dab2da513b246861992f8f9328bd327685d5527a97df004febfcce2a7008200e14be187d4c1d3821251f4a1efc6ce3e69b0b4825d3c5b488fa11bff3b243a307956904b9df746c8d900562c5f3587e90a17635019c8d693b71aa60a40e38ba4bc7dac7e46c71745269ef4397baa296564cf266ea2b3b80995148614ebedb6f05bca2b6a81e8eaff1d903f773652990787ee11f607c82111667b6b6a22518c03068e315ae5d04d0880c078c8ff90854f138c1ff7ab28444333e1d528afbed165b578a38913cf28c717b16355827afd41acbbf2c56deae366b6aeede1dacb2bd2fbc5e01aabc40ef3e5f1c9e9faa2e9604a22069ac8267ac276170991b40c58e9c2b3cfaafed7f918540319f735e1b8a40567a4dd77791c37e1116e597e7d977c56d3ec95c34b31f4530f89588502beb91cc8a69d370b16a1a225b61dc5673d4e31d2b17dfea880151ebe44859325920a3a0c71a22db49e85b97f250e4eedf43d742a5460f41e11cbb55ab6151257cacc92ce472b4487a7d3bc95282c9c68a550cbee2317701e99996dfc5fee6b70d6079c1ea0c42292b91d1cf984cdc5aef83ef840eee142deaaf8394f25d3fe76eb59c64aa3d2bd1e6d41e76ad60e644823c3dd9a5f16e2c172b7db701773d5125c327a5bc769ba1f8266e33873ce5047395f9b3d5b096f6d50cd23a621254e1c09abc8437d951b59732209f35d215c5844058ad2a6df3c965070d0ebd61deedc6a9cf0cd4efd3b24a916005941d61e81a2336a1e091a5e38006167f416742122a84f1ef352b026921c240861b16cf61da72f7ed361f06243e25e41c5ab8e91b46a1e74806f28f3e727e699f125c9e421a082b7a40343de09fcf1c528fff167810cd0562237d65754cec50697546756c859be232c9b69847466c79d27830d887329a449d9068bd1e8920226612ab200f865ae934e599b52d20d8003c73bc78c0cbd9a2f51b382b891d719ae694bcb484923514f650d5d240df0096abd1ff320e13886775595d0eab930bd65df9acc51df40f5f2116919fb19450e01973a5da7797d4a1157f277f675831d396f8a80af989f8502250183e920d94204865b4cf45dd4aed2aa39719f03057f9c4e541c618f9b2e60611dbba07dd0a950279f0df0377b8863c886d867894a9bc850e25710317a82acb7d23a09f3f99b24014ab228ba4f946aaeb7f493ebad8d53b41dd27c4d44d06eed9165a44b4d70a78e211f20b43265713fd291db5cf76d16b7fc6d9c65b1963ed87f44a1b6735d053c8978a1fcff3d16ed2d37be0ceba6e75e1174570f0e456c2254e7b4c408dbe7bc379a4a0d357488639f37e1e7f50931574ae94ffb8689dabd8e9451c3ecb52b7aecd27564724b5a00c114dc113c6186e54d9fda790d291905e4d30f685d423b820dc6982b84315bac12092ee207e19281c557994cb914b99031affc268dbbd5ca273c48cf1fbd1fa80f115d250c0328d3434d31cfd80fddae4ea5ff23a557e81a36079082a8e6bef421d83bf190964299723ec8f9ff628eabadf4a8f6a87941bcb97a079af1cb6a76ed0c9634866647b399cdcc8e597c0c0cd7e28e4c48d16a1564924dcfd9281f7a57a5753dee1b2521ca9b3355456bf0d76a5da1ff1790892da5e9a4e6178d350e4e416eac7ff16ff3f24b2f767c6313793070e9c30e94ad97aef95ba6e74b22df1c8eef4ee5b2ef1df7484b6d0fc02044bb55ad80aa69790d00049c76dd93ce8862757b04bce256a75cf2482975cbbc6a3535a78c0d00dcd984a91bf3bb6e4e53b96ba90712944ae207b885e4a6e14ffeded62fd3926d32529b273946b94f0334cf80d655a2634ba05b2265f931f5a6e1d047efc4ededa56f622c76f22dffe5999ea0e76761a73feccfac12c90ac5ed4b2035479c3e0d9745d13f5b0fad13222866ee7d762eda9a0c4eef6978d5b9d0eeb1f10153753ac92496fdeefed0c1c31db32f11f11e3d1f65fd4ef7fd5d39143a6799e6e134218f316db586cd03eb45bf756d896bb3e6bca6ef2f5da3f38730be5c2baf718f1ed3c9459d30858a068a5bea9f7825e18b23e5bc08d41acb86ce5ea9d3b3a832b5e373e29558a17db6a774cceda911a1b6d476ad1bf2cfd86c8185ee33adde3c1b9f5339b6ba7df7ea787fac38aa2b9896abc106b4eadadd72aefabe54d4e8f0b235769abfe1f53e13a6ec020ffbe665ac09a25372db41fc037bf9c10675320785b430f7dc015b7518fcb135c4f18cf8e9185e90da6b09422d506315ca7ced5f6b08696be474483d4d080c7a72463c7330abf10707b963b97ab850a6ea61d0b43b8eceb25d6601a0e14a83a25ffee11328ff5d529dc9d22d5add424645bd869f42d90466df52a6192b260db4c151ada0d30954b9fc6de9e52a4dd309324c6b90eb52a25d546439afae58a94508820037967ca4e7ff49abf6325c28559e38b8b383c997bd16c50e175b731ca2ee390d16a504be0f5ce4cafc5e7663d070b7b5d1d2e7683f4e5d7954e1d08a2e2bb9ef481b4dfcc9ec2f97f0b44b4bf6d5c9896bf85c3b119f350c8d8d33178e5e394e0f483ac476913380b0cfbceede98dcc9099e1faa90d1e3bcccd350af372cd4dc6e59bab45c7b535712406941d8de242a1e41abebfc1765a8b607bcdf9b086d839ef73e671a03e7278d3c4923d16ffec52f2557e027e02198e815a4b348edb477357375af051ce20051be2c981810ee0868602ec604073312e5d6183bc119b118942685e09cf620994aaeed05374a0b92eaa906b352565864e088211d527b1db7c549287f9ad95b3080e4a772752c1c7b09380a83778cbf11096414ea6584af2a05d2fcff48f0b2f37b7550d1da49ffea29ee0b5614aa0b19df4b5963e942e6943da373d82b210714b9f5eb811cec9559a8bac470bdd5f57fc5a5e6282e1368bd0c8c0b3a3c13aca322bbb13cc4684d1f9cdeebf2f75e3ce83d93794356f58e5a275ceff208bf09b806ac133c03948632b0a9af240feacd09f85a72db1152741eaf1f8f0f98278e4bfa27c9a16adf071594b2704550c26c71d5f80971d45812d5b0fed903f9dd60e6a3da414018776560e4d4c85fb7bc7fb804ecda75f769743f86ce3465974f52b77224fff71d26b04b0d88126fd778b439aafd3876774a7c7e00108d8002b6585cb79c5926402df0e18b669de26cfd5413230e57264078071ec73d752b0240649284937d63fb1da13abda76e24f1cf60f50402a6a3ef9679e53da13dc1cbfa2dff15df8c099ae1c4b5ceb7863e45c4f7da8d4a476df6aaa01b78ab64c8969ea5459b63587c3acb525bb5e66e0f1ec40eee698de9b717e2828404c827b26c593b1d8be164d5a17c162e81fcc4f84bad6f8c72c0e73d97e517be1159b025a2a2d85e5d9d0cf862f7610de49ddd13f77699ba349c50d4cd39470f7e18ac4281c2f79cb16f26747812d330cacf3031e38f0cea1fdd8d3681d4c00d5b72eea13d530c9e1138ad194bdeba53ac1e746d0ea2335e4d20ca4e3566ed86ce1693a790df42fb51436974a7e06cfeb7501cd672b0e2b0cadfa2da2731d4fa29deff4a674b52bd1644ee1e4dbfac64dda72c6d11f9fd501b6489f632978ae80f4bee1aecca40a142f84b5b46ec5ef6971bfa0087557b54d2fc81018f82f6c0f8ea21b2208d0644407c3af5d9974d9fb047ecc57cc584f8527a2b46e4e3141c3d131beeb10c5986849104772d5ae0edb66d195648829129a0a3c456fbff3da00fc4d3577efe2bb1610def5a606d9a2e9488b64256150346fbb024103e3fdbd59a51ed0822ff9f9d8b0e1737a060472e9b6f6d8acf5ae60d2f294bacf2bfaa2aa85921775e9dd99747414dfd7edf5f2128138b916ea04dea54e68dd1d4c1208d9e4cab463b069caa2abd4f10aa759b635a440806c2bbf3dbb24baf5e3073590191c77f9f00d9f1a99f9d7f3744461dc8219aec242ab9ad616cb7a79050666c6090dd6f8b79cf8bfb26ba3922a677c4bf715b1dd627defa56a014ebfa115a35dbb3a5818030e4d907b5aa8c2ba1b57b566ace6867d16659cb0a469346cd1cecfcac8324aa4456cd46a68157039d634d4fd02c11fa5f763551e32c0d2b4ecb43def9520914863d63b5cc0eae3ffc99a4bddaba45b2daa895152b11a0010f9bb98aab18069a449c681a1014e6f2d168048ba13439ee3012be27e6c9edb6220a4718856ba4751b8d242cd0465a3bf785e96b70783a6b033f51b447cfe1958c187eba5144a906ee34ef990188c06411865254629f72197344fedf80d142e9c629a9aace1363e4c2f08b7884003c549f7c30f3f8630ae3128141c85f57930fa75f8f98eb0fd2c06436dec706d59a1daa68153eb6e6d6ce21ba6c6ac57f3193ea839c17afd8f5346d449ed7fb3c9c96549dbf76c8ec1f6d4598ff89e63c8b08ec34a7ab45b92e644c669ed2c4cf224131636c9a1d1743cf2b0f1ce4c15dc24ddc9a17375b6897a1fbfb25e3d9dbc6610d6b4ba42109538352036e99d7cb0769dc2319ace99fb833f4eba08632e8460f9052918215722392401f2b867566d9224a665ed35ca6f3373e13fd15ecbdb32b53c941446260e59a0b6df44f94f94188c43b5ffae698247ecae4ad27b9993a29677d27c75df7dbb5438a8b2dc76ee27079ec1074e93de4a2ea25678cf899fed25645e1a944cfe9d3089f1e83c1b3e93ab942378b2db43b485549c07e5e812714c2905507f473a136565790b099b4d9d140ce4e5b0938f22419a124b52febb8f9a2bf22a70f21a867302d6306fbca12120832c379300859acc3650b8f041ab99fdc64f883340db5efd5a3901cba4af87205ba3855e6df25906614959f8e8e87081ca1f6f39825190ba0198019a496873d29d3d41cafc5d930607ee9e32021b4549d13f0434f7717b33ecce351dfdce26299a8c6d7ead429697fc959887c10774c0e638e053c92159cd87a62a6df9d0983c05378186c89ba7c318f8a5a8fbc87d8b4623b55b1931ecc5390a67d8ecb6c89b5d7e0af70d70413e65474a3aa8e05f764b02ad948f26046202e22452229fb7f072c4e83c000319163333d96df0babc550d3870837e5822625bb1f20abea49da9bf637c1396d787182a9718e3c168cdd784bf3d2b589f2e6d42e98f8723d7f1b75ddb45d10773a783cb7003c25dfe726b9ea0a268b5572ce7ef62e7760b71bd72bbae459c299d259d79490a70ed48cd5f9886df5907dd842dae4638adca7391ac3034f799a8011f2b008e40146f3b8818466cf7dd5ea587f103f5cd6c82d4d938efe13e5e78fe62119a047632af9310f4740e2f78d5c4bf1c03655a70f02dd7564dac2fc37c2c5c16fc2a6d689b9b28c4be8c78d1c8cca0f04c4d27b0ab1938a4104bb5cb4d2398a10c7c739072629d632abc5f4955ffceb24af060a6fac7e378848c7a5c5bef1acab21ff83aa09d9861c1757060e38e3471578c0cd08318a979f22b6af4b8bb1593ff5db3e4e7605582856a027aa3d9f45184cd5b59624b2ccabff711e8ed816f52290a1afa46fa07711cee12404938ffb7f06fe73cddb6814429fce162b1be9ad6b8f942931621c5baf0b121f19cdb05088c8add0a735b12c65317cb2def53cc6f0052b054e9f23e53c25566f95c25b02b1f82af827498518e18f8944f8b95359c04076f87130a5a4f7597cce50bcefaec765d7c77690746c7b0c050e778308866836eff8f4fe386f5d18ff0aac2203e09ad898d772587711bbaa0fd12b471fd28ad93b67e80837f42aaaf04faa6cf2cc11299dbc6ad642420da0a4dcbc870138936f485e3cd82ad3583d393893c5575eddbcefcb8a87236b647e4c6cfcc921a00e34d9192c02449051b9c812ecc3e981c14cb68a7489c208aff545ff8e2b32a809640fa8eb3a07a33ffdac0eb61a8d67809499e1268b4f5410b6185c1eba7197aa41283ab02963245762d321f271f5dd209611e259b1cfc6fd6df9937b124c6def621d1de567b0ed8606dc184f5eb865052086fdd97a19977df2d7544342fe8ff964a6b14d61463efc7fa8265a98f6c1befa0007c8a18c55c1b1d3b37634cdc1363fc110b898993caaa7fa064cf26eea7c5f264ac7dca842fbcdb8b738635e8d12673bfea7eed16707b18f88badc15309e248aba80c47984c580123def04b17db846b5e4888d3643c334b7e281fbd2b8936cde9e5815d43027f1f458b5d6df1a82c299b0dff480808cf052bf2bc80832c89e83f5b272243d647f9649546ced1e83b9851f72284236733c1d243e4e292d4db379ce8eb0cf4fd1ebe3873478b2e2b923551f8085eee6fcbf8cb0ac0da3c4d4961ecea7b99ce9a9ef460e7b0d0992ab0aa0dfcae781eb52c6fd93b4c1b79cf21ebdc7eb4f6bd203cc9c4116ea8313f8192e1b2adace10cf75eb5eac7700ada3cc9e64a791a0f8ca5770e63d38c4d12173dd4d4bbb2ede59236a4ce74ee56b5675795a84a56c162c1b51e637c243b5eb93b462a38b925575cea47f264e137f170f0872dbc78a2dd77dc898bd7fe4de23333a794c34a38039ebe1b77caa79e35bf5f83f5204deca51f45e4b5b842a17beb98cd4b21bf2fd539362bcd99997bc9af1a5d5cd661f5fa86c829c318d7f14ddb589ff0869cb7809bb8419229d9722ba4969d90c9389860abf117b29616cf6c300a1c1a212425da61018ec57bdaea2303c20dfa4047250287edc2e4594d3362588706b8000ba6707e9e685de80e3dbc40566febe450953d854daab27568ff4052445a0f8f7f2edc80f3dad757bc7aebafc6e02aa10e805ef20e19bcd608ca3e95484e6e16ac56739dc10638cfd890cb988a8ffc40aa7c8fcd22f907bbbb6c72a63d5f80513b839acbe35388477be4930f323730c722b198683a4e575a6db29c2bcfa57b5d8259a76c2d7a79806908f49cd78fff6c0507041aeee6eb14ff1b8de3b9fec08f0046634626c4f545cc0d032214548bdd8b150b0bf48df39ad23ac6a1a675b7f4570dabba8855295d856ca2652f110970d1f00eb8a277fb12163821d0e365476b665f78fe5417375e474a65a6d2ee1bcef85c434ae26af0d1ae31bbc3a192093c87fedffbda069fff8598e34989486e8aa8c123c38deb684e7b85c19014b363f899467028ae8f1ad743d598bf4a1d84ef9c7a83fe74621d414887023da7032310d8a02fe6637d10a6e400aabf96e69b696e2e98717f5359c324c3f30cf2124c25f2853aa9cb4bf53c877a7082810e752aafc0de594288ce8fe44994e44bdeede63ce15977506f38f90fbd1a0d18b605dd2e3a04176a041a50ce42d8bd796540f5f4016f476587d79320727b90d923a12d532da9e5dea1c28e2a393b0f6aad61fa4a80500ad3f816f2b7519b73c11b2aae0d2df87f73a31e2368f1384c3ad494a1ca122c6a1f1f9a88ba03ee6bbebf4745847b0ffe8acf8eda74dbb0b28cf64470472aa16b35a981338efd8d3598bec3452c3b1d4b1aee9c1191c2ec36aa9f1a526285805fec8b87cc369d9614dfc0b90bfbbb7ad0c6bea279da261f064c0df19bd02f20adae641b3de88ebf2ac96769a7f95d06494c40e8343f50ddb9613f09f9771fd4697da1f5fd9f7e3adc29fc12f57dd9ffae0be1f356a8fe5b19d1af394db325dcae1292e5bfceb157a62be6ae549e60eedbb113c26fbd3d4b5675492c6883f339a3acca8a04b01e79bd856e32cc8c66c0783e74aa349b41d87cd4bb7d2b06019a7ad5165c3c34967fe5a154743aef0890509533331d498c3c7c2fa1a1543dbd858a3a10a7096a28700ae18524d8ede4c94ca99791999eeafdbdf52a7454664c696db0079d06eed601c3016daf35983792c6fa63c8f402aea72f5fd8d88f4fbc420f3359ab68f911a2ed6786083f7c7e433e02074d4505c9d070598e5c805adaf17c79951cbe18da159ed6a4f1315151cc68f61a4e97f0572eba763ddde29a3ed57325c5b608b23d57d002886234c26d2ce1c0f6a723f4e2b687ec68504960c601277d31e2f77842f6207cd186cf453984ebdf43518d7b970edd0774dd0ca0b25b08fe0662ebfa5850d2b7698aaad645bebdc5d25d1f9593df22e01a74596dfdf5aa5d800376635ba734947f3de89f9201b31b3061f87e0f4083dc07b09d8034d42ca5800812a594ed653e37b862053c03a2bf070343720c1768bcf4211c2c084dd998a07c5a6240cf9d41529b691517012931272ddcc57f3f92662b57b799f87157ce36fcdb263ccb6127d350904356c1c908ad15e1aa06022f191d54109870a55e6ac7cd76d784567e932645d2b63e5db0cb31da9318e03eaa6e6192f0aa40543f802953b1bc3b8644cfb6244bf80fd9b7921895a094cff35a82cab0e931453a9b69ba92f5e67dd7a0323d6e24c2fd5c176e9e6ff35993b797de544f0948057febf9191a6df77e12eecc40868b9c3d45898add9ec3b45f33251f9cf3f47f01983d444cfcb8096a25f05a3ebec24dd497b289ec9a80174250f6ef82e3bbf542353728b58190ec2687c6674c8595ece9b5292fc51a541c6bfa051982decf22d556a17e89d0562eeeb73cb4a57cadfaaaf1d304243960432a8183184ac0b4e4803e83c726474efa4c0676926b17c31b745ff6ba673ccca35170e1fc969e4a3b0a0abff6d76c72fb0c45330cc2c9d47045c1f2e661d372c84dd03d0eb7dcce52f162d2556ef4a6ce19e1a38034f7a9b3bbd0fd1c49640d2168d4c0deb35bdc243d225ff424db5785a5869c369e8edb880b8753eddd783b2416ab086f22d0736a27b4802ac2519c171a4927e3a5e32c225def0aa08822ee8f716820e96a20827b75ec3063def2ef1e681029f7d39229e4f4274f653978d7a4bf245acde05ade59c8dc36d4d6cf15054964a37d73f26f1e7644e1e9dff02f2f47c5c50fc8a54d04fa7dedd13ee557c61decf890ef6862f24b03d672726fd7717223b66d502aa804d9459ab749458c02dfee0780c214bfb1cfd1989de84dc30997d6ab440b4a64003281b3eb00791bf16875593e3c17ce9bfdfa30dcaef6b32e32de0745fb5d4c7738a2eea37b3d111d75be4ce6c901396faf9c1fe0aca74c5d30fbb2813d8d5634f7f804860e2fb2a35eceabfce806b34848b72127a94016f8376893bab18ad58c9c8b2362c1e05a51ea199b7d104c033fc3a5a6629b3db24d7b1492eebf5361bc94cd6271c8cbe7ce5447a601833bb1c4aaa83355bdb868c70bd2015744b2a59c70dc15c0f103c836a45a4050bea953e25fea83c5aaa5248d6da90e831c8ba435ce87f48fb33d0896ade1ecee85832971eee08578f9b9216cbc7f73576d58032cf45e6aa9907ea73214efdc30d49de86a982704ac8ca5e2aad7d3f1196f224c25ab1aa5d918d7c4ca815be5909b36193b03ffe8414f74e2902be49b3aeaf391db6d5f0889a6495905a26b9b7787b39ec1fa4f7268e6c62bdf24453af2a4c0783db319c4248947656d3928e1bd3828987c1011c15581d1217aabc273889813fdf4a39a103b3fa014904ef50c4b5c497238033fda4bd880b3da4386f072de0158baa7a76039c989d43b9a4b4ab396bd56d0cf467cf81cb28ddb486b17c2f5f567e6e5710e3ce7935183c4a705da5e68bd1db41758de4d27bc6f274b2b73b8df4737e81193517068fb152f590159ebd29b32688ec88aa199b8da1f7b18893f93aa140780b614eb5bf9b8aed49dea2f84b3981f58e74f210d820b742ea38101a3a021555c4787a26be0950212c21d6b681db7172a4b86ff192e3f230128d1f942a00d396f297d1d495efb08f1528482fc81e71423371976932ede2ca46677cd7afd144809dd9d5020d5c07d86b697d5958ea108c243d11c2c24e3f31e0346f5050a0984f8ffd96f9e46595cbddc3792398f1944928ec29be6388ac308640bd98449df44e8261411452fc8df16edb7acbeb8b94277b591f820f6775e339a0219be1c83a13f07bc84665c0f1d8acb44082aa46a20de0d5105be2441ceaac80aa80de0e68518c404ccb98ac8b472695f7f9bc86817e36e9bba0c1ae9703ecb5846e38e6ecc8df969143ad696dc5b6a3c6a651141f7658e5726326f4babb24e7202c7fee99609725b4dabcd76f96333405c18047d561eb40bd923eb03769501ca540edf4f662dace61a11552d03c8975780debdfcc5f91c82a3ce20602f2df990ec1e71bd21fc5f8c9993c0b4c7fcd84f54340431dfaa213cf2d3499def261741c400e5c0f294509a5f1ddf7ebf135b547ed6dff765757c1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
