<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26a35904f3cf3c9a1dfa2c7509ecaed43969802d099bddb69128da3b97752ce765006c24d20c9c8cc3d683312b20819b6d8522e1f8dd6bef5187bbedc5ea64a3e1bf5b6e4ed92fb7a63ba3f4c4e546fe723fa6acc2d967c6bfb5e93f3e9db093e9875bdb7f188442687daa026bf977658e448963797a5eb890cf8931693f48fa5a71dd302e51e379db7ae67f705ecaa28d88006bfe7138deecf9c0a697876423016dc7bdabb561b3dd2ba9ef0650b16df31c92bc0e5aea3ac176def7b9721483277bb836eeb10fbef2db1e0a8cbefc313b2ff0b820f614c53724220d7178392683132e5e37482c29bfc05600985750c4a8653ea07c666e5044e6fb37695588d43818bdbc6dd3547cfcbc7b8909de98f35876c92035733d8b4017d6df70e4d8d61cce44747eeba2bfbfed9c5e4b267251b315dbf504e1e1251bd7ea1e4c07e408501608081280ace24a3d12b0508e22a22ea7f2bf7f5c6804b2e3988b0f0114e25857c34e843f922fe806a83ea4b777bd21e823fc47bf0ad255d36fa48492907e66e30e6bfeeb049c741154155dca345c6d6947bac5aa58d1b7fa96549993e3e0a8ca012f17cb5fa8755d26dfd6b0213b179b7f038d93ecf8c786f42107c4121a61cf47901bf271800ae68dc4cb2b11d822539b8de0aeaeb45047a4b28064f261a6d11e94e50283286081db53148f5f83648943363e099cbef56557e38be16c774a553fd65ee7d000ea298972c32dc73420f6015ec575ca751d5b4a7dfd2012d8ba08158d577f9cea84af71c0a132ed78f5c6de4e366a01f0065dd9501552bbfc42be9f6800eb388878a30585c079f4b5419152c19a59a2229924267af86db9141445ee14231ad992d63f63d6bbfda360e3a082c009cfa5b031e7502ebecc0e3854ab26ad90b6d0b21a2e45e92d3866f14b7c2de9e3b44842db4496d02abfbc7c6c1b7ceecbe83413ed9b7c327a151130ff761a9e3937fa0714ec8cb67ed6054da8f25890b0ee234507140064acf958fc266d8035910b3b5c60aa24b5caf9491f27169efeb6940d704980b478dca7f03eb37b9b14e09cd506d62f4dfa4a18c1acdebbd1e08bdeb4a5932a8702492c41ae9d8dac0148e67b654413295c22e87bd31f752dcf12bb3d3ef00251228ff7a242fe8332da4fb6fccf50aab8d89a614ffda09c270dc56c9107ef90c5d5353ea48b2ec058bd31d9f87fb0a00f8b4a6908676d3d5bc6542ade88fd962670c6625055b942f0e2674d4411ed76752aa3b6efaf33246cb50a7f7aa553b72902995b179f86bc45a09151ca16ab653d80cfc829b03321be6ac3cbe0eb64f074678da59e5295a97f5ca27616073853dad983c4208b592354e05977b184fefdd7dd86e77905cec39e36e2d830681c12831396216f926ef7b4638a7a9651686620f7f60d63b46a7b339fae0a18856ca07e62a395758fe25ed4690783eb2d82ecee6cb9cf4b837bef3736efc58d3e15625645ee591c7c73223b6fe673e82c50abde5884dc6b7e895e453bcdbb00ae31793537edb01813502db954950cbd99940e783ddd8bb89a338d265c97fa6a846cee1bfe2e7ba5d7c3970a36b72399d5ede24fe8f1d8275944deb97e32b0f1215bd2395d47b49a595e11d99405c27146297f916935d3fa59a727d93346f928a1fa80eaa956cb0a5fde163d78d0eff2d54ca070842ffe497989856182270af22ae90c090de470311613d77e073f966b03e772c232faf1e8d2ed4d9d3b3b569dc689729844f38e6bed83c77f3305056983d0dd4e245c69f28a969107d616411a5d9f431a40934513abd39b50b6da0344a82ced0b0e63a7bcb62d6ce8a0bc05ee3f235e2f3895e252c240c1015a4aa155a888cff98e38ad2002b3b315725a0b39fd62c847389fa75960b08e448aa839d11a9eff20bb3b6382222633327ddb7690970bd8832a0ea79e6a41e0ee87e62043ff445a0e72429d5e502760279baff8fdac215fbdf24787d91f6dec2d2faafaea7bcebe1ecb80f883e59a6f1e067106c57c21136663cee2a8f98ec25e4f987859430a156d9c7d915d875cb45dad616234b7620b9ab180b25bf3f804806e85ff15b299ee7217028d2e761e021950bfa813237989c7857c3d56d695db212c355c6650cd5c0b09720f6492f016e29743fe37287d49c75830a55de573fa259ba9f771b8f6769eae6f9544ddd47f864174fc27ebdcf59d9c8d8a9084f423e79c10cd7bee465e880f78b1bf300ec8593f2c6df9612dde6b226be7c4f23f661b91060feffe4fe6808c5cd2291e3673600f57c27a9e2ed5ec4a891fcbf0210cbf1675517f221d0a41d4eef7998fe3ffd5bf3997d10bd24dbab9c7f2bb79d2bc98543bfb229d8aeca77285b4788b16fc7833fbd5dd6445bae12ebe0581aae984d7fe21032108cd7816770dae95b47a3c9100b949dc8a5a185a2648f068096000075ab08cf08bba9bb83a9fa10d44a0e4f0d720f08966c1408cddd6410435df64ea404bea4b1dc0b2f39031bf5c37685676b6e81a0bbfb773266813d9287a6750a10ed771bbed4d78f25d0d6f7e971fa342e5d6151ab943f17c39d7550a1ee6506cf23aeea05f79944eaf1d873682e1d333929340d50c8f2111cbc4cc32147b9d08701378d1cc6462a4336307a73b6f377168960e587311bc6f0ee072a2de50ed84df3a348631d05018d944974b1647597c5a5da46ea4f5ddb3707ea8a7a5c011d9c99166ece88e6a9f26fcaa24212d0d98fc062e1a00559507982ba12f59ad658c52049babdffb9b8e684c79ea53c7a15a74b6e6155188fc44792272285dec3a7519ae470d3b8be7659ce30c2b99e0a2dc501b479ac7e58865e02b566513064f0704669123372528ccf87a1a06512b59a8866a81dfb9ef10917601f337332b9df78ccc2506dde62b5840ac4c39a2bf5ecc663c37ff6d72e25ca31ba8331896eed43f7453efc92a8ff80475b0dc5b6d56f798807536314f3a430521cc1641e705bf094f2f2de6d153290db21b3db192df4e9796b9e60339b688e15bf42179fc595882a4c9a74ebd802c9e5666a8418bce49af7d198b30f7787f8775171bbd07df21e6c432060daa4699a2284c639b0e45829796d59748e32e56cb4b70204e0b57583c6858af4167fa0837431a3d90d0de579c9c5de23459045bfaa4db4daee5a2167f488c4ee7a85ffed6651d536afaea8d57e8be75d72c3bdb5fa900e22872cce859d8f5422a76e5fafab9c4fc38592152e1dfdccae46873a9a1abfe40f1ca4a4002baaf7dccac9fc89837cadcc6776c9652e807443a8cbddd6fbcacf48ac945d31051c283bd94db960756b38f9c7be9e03723bc60cae2001bbed88d2c268be2fbffb00c6ce9ff2a02d28b5b04ecd3cd4bb32fab7a859932ff55bd4012e084be1fb1ed49f25f7e736735138ab1255797bdddb4a76b9eabf8c7377718755c70f69f0cc3dc60e06e730cb5a5948a5602f1b98397de79b0b61232f4e37c78a2065e60e25dc7dcf0b5da1ee439db7b905ea4a53fc2f49b88685b715dce017b140831d0ed8c62f396182534a00ed50a9433bb7d81546529976b2486e82f3e2e9f0775aced4d6b2d7b2d313ae41dfe2b2b22f5340cedb9e1ea7175e79d4ca5a4085e5d89fd69c0713fb51419ff5af25a7c19b7db23fccae86cc43255eda57185868d7425446484e1542bb97695a8e590a6fab71238702e278ebcb0d8cc5e6eb15d82ac496ef452eb2b1202a6de02762118e9828e77deea0f39111fdc9b59784466e272f9c14a36848bcd42ce7b84d8348bf9d95b4fb042576f805a8b0f8152be50dd8be421756b667aa3405a715714b6d529f190fcae145de487069eef788d01066b63ae9cbb18f5393b01ccf8b9576ebc636928fe3dcb84280eda94e503d34c8939832f3ad5bfc2ce01ac6012612569da1e421353cf7cf4c902ec6d07462c261936b99bd9b9cdd996b39fe2167965898dc43246775a8fd9980c50e29304b5c4839145fff032d776bf46b44767f761df47c6cdc48c0bd65abb7f1beefb78e004910ec6612a207c9ccba5f0258b39d3fb06008a04ba9a2290b3d09303f6b934c294d92e6d9dcf38dc16a512befe078874a2343bd65f611f895ebdad25f288574b122da346d7d0a1e145db1b5c30a4f3852aaf6bc896c2534ccd7d1607c6c5f9c24666ffb953a342276aff484d7aab1b1cfef6143787a6c1ca4a177c01b8f12f138f617378425d06cee48bb0a7ca36b04930b5f1b4b3e57c9d7cd97b82c6c7921d6ff07bb498e275bcf9437fabadc8eaf69fbdf4c153e633e83f10103fd96ac41601e0a139934276c4eea7895b503aa7d81210d579ce2ecfd962dc7421a65505d3481f4adaf40fafc30ea5b7a9fffa0387a6e7a84adf8b9d0802b77af498837d8a115cdcfe72a843e613b9dbb201c7380f4d105f100cb19d3342f58e35019e2950f92a16e7e8d47de2bdc6a13781cb475f4a7907bbf500ec3ab16acd903d8759da033e115b1beb32ab99499d49190f1e3d8af5b89ab16b591bf22d74227c0c3671edce8980b66d910f65fa86df461001fd04ce9e855d90989820aa7baf2aefe387d445975b02878f852d8ef64a0e423f9319d10d4303bc10bbb345c0b2c3366170ca31b93780d9e75f782d918ad418539ffa14da5b5a2be97ce4b666bde92290c1899648bf13a1a8046efd5e2e3b1a13f62ecaf58c9b7b95b8089bd1fb9531e5ee57d0b96a514c00d8fecd54c82c02226070e1537905e1c15b6ad2b73f0abbb72b78082f84669b9e56c9f8959b47d1c3b19461de7fc962d6568481d1c610d88809a4e8ccb128ed400e62b0ded071fda945d98e69351300d388e713da6f7be1267a92f97c2772fa8b4de187a40a13093fd55d02b15328046a43dd09adf32d5f90ecea8b40cd8fd759c3c653f6e8cbc2a54b7681f158262459e288361b621e2ddb0c1b2bf51258f09a367f2070ed8019428722714832a7026430eda016567da01de1031f8fbd033e1c1136ba856547f1519caa5140874fc0fcfbf2cb5cd45024c42e6b5c6fde61dd18bfe007f00c19a9cf4d2ec0da3545b25db60b9918addd8370dff58d89a6971c539b08d7ee217b12748d7eae7195a7e19d6ce89ac116ecf701331e665eb37127014df78dea83083a3c3fc935ed30d6ac0996a49a974908f92d0d1af477ca3ad767e86d81c83aaaff452b1b4a126534eaadc922dbfb3fb707ca0571b17e8034c76d12c8c348933dab005a1c66880c7233ab011a702176ce51a483dbc7c9f1fe066332523a41733013122dc6933073a7fe78c6907089c3d41ec758f88b3f9a819982c3d6971f508b78df71c9691763f7f4dcc0543e90d1d9020ce9fa5e2cbfcc18dcff2e8aa4ebe61e822ff292bd3ba0b9307e96e9fab092883c1020b0d2e4534ac57b8f09a205c7bd24e5371b04bb09319bd53f3e8b959a3486cf8e10ac0e6b91e6dfbaa9f2160d6cd6c3da4556b01fe98bd195e32b217d4005ac8d15770d894b8ed6805938de9a87195c3ae3ab39e297c1a07f132e609b1b359aeb5e65d0ba94a2c0c523d95429a8454c02cfa84caf9ebf71032ae65981835be74da6a7517d9db569c6b31ed705aa2a4844b9a4f0ab1cdcfa83e8c10480a151f523db65e502deba44cece407baeb4fec69fd0135797ba9ae8c24760490b2e6f7eaf29d76ac2f065ce6c000d2058775795a41a24b2a4a9716799434d5a776a45d40380b721705724e47a7c92449fd0722db90f83690db8915cb0bc093fe47310b4e0fa32de2a6bc3ce4f7d7137b22ad7be53d381009e0dea837bbe0d2a44abba7467ff584af0945ef244353fdd2cf767166f18b834fbce3cfbffed6a038ed4d422dc39ee5a9ee321123ca0bf0124afed32990273a206aeef21eb536cfc3ca1593fe4a57dacf4662d781da816e859c2ef52d03d1b59307cd6c11941d042cbc4fa0d068c37c0ba893b2db2197bd09655b6268a51ec71bd24935cadbb0602f347f2676a4f67cade90a0009167750aeba6a87427a3aeecd754cc96f008be9e59ff035619c07bb971189c60fc1eca3c177ec0c093982c3593c3f5bad07bcfa45c9c8c4054e184752cd34534728e8e74a951740adfebd3aba76119a0f5394f0bfebbe6c7d6b54203ff533efe2a0025428e745dac93a2f0d99ffe8e2a94641de6e9b3f098b395b4d29bb7a3fe32878263f5c25826742ee3deafccf8776e892e553ceac7acc41bda9d9c7932a06d04bb94d2286567393eeeb66b7827e59e5c79e630430d2ffe3fd2385ad545e395a2fa3a846764660d30b3db2726ea1b8e6f549cebed09899a231dc3375760c3d81113bd3bb32a0e23ebae5d0685991ce416e274926f87531ddc7b02f711bacd7f90db44b483a106406772fd4928124b5882a0f066e85dfad49bc7a3ae6978b51a08d070b177577ea31b78109f1c0ba751da41fde04774262c19316333d220223ef06595e65b9adf4c39a24b684004f45e9b3438796cbd167a17f3a2e3d771b80c8d525f9eb5206f1bc1a3152da6ec4656e913da6adc49da21d2c1de0f7b4c867b909027eee412289ada9ae8dd9f86b170300b8668a6280cecdd6ac0312ced352c9837b7109ddf44a940c2c740919ffb8b2d952f528f6c06a3e8f80570d52a727334c06e071f26e660a18d85263726d6bf638906ea9b88cc3c7e44340850fe7b7ec86496aa6a5f0069bf09c34c6fbeaa0886a8c5499143ca32fec27e2a1f951daa2f51befb5e476870b424d116a44e2c71383858aaa1593204fe22856ed74c621f9f3942408a5d380c8beff48240d29402447bd34c27b6aa29ff618144227773835ba56cf79191cf093d72f717b9ec06687c4bc2f2b0de66d3a80357b230e7ef4144abab409ab09ce40917c3da5def8bbe538b2ad415e086931d4a7b43bdd9629558e1b9094146d479541a619b5546484ce5d51f1bed24d2722d9e43e1ea89d2733a03e384676a753abe45fca11b30fa6aa5ab6948a70f66dac2f9ec125e2923a823294f028af3a62666339aadc737745613e6c1ccccf02ae2f8d34a1547ae66cedc147e34a391751ae0dca66ee5e5c076542ad632b8025f2420813df5107432ab93e64af8f238f0b96aab5840ddc21c47cbe4c85481c70220dff9c205d4b6188dd2c99d563df43d13df823fb528d88234b5d1c0060c37497c4419adbfa8b2ea85b1a885d2c0d3c1a3eb7f1281aad473da6ce7c889ea146d34db473b5682de7f21739185dd4c83bbe8c621e195c5f7a47cc1e27c1be09011e6e1513f82e09fc18e238e579de8c1965b5915cb8b869945af16045259d068d423f70687acea7b21f11a6344fcc9de23ac737784352bd0d561c9f43820adc5e63a516711381a7130da1f2515886d24a334a20cb8e626f730be2bdf03f18a3f82afea696671056f9e232e0754b42dd709b4e2242bbc118a5ea0478d7aca2a5f08e334edf97a4e620b10379fa8179b50c1c9337560f5f2cebe3d5ff8b4ea06ef5ea0280ddd730cefa63ac28cc43f85d5957c12f6fb3c14a8cd04bead9c64d2efe5bf237bc75c816aaba6c0f569e1ad9b48fa1cba2e3c091c3cb051a2ea5dff23d6abb9dabe1a68aea9081ba612ddc6ee0780dc671fe01fd5b31d95a34d560a12c818d20565d0dc4496e3b5f930cb76cad38f61a99335fd028f61d077a46a2bb84f9becd0e0b2ee9790172c5e48e0711e9663114ff3ca68e7209619cd0410ffb1eccfd994839a6ca54ca1e23462ae8869e73f244ebad679ca173aaf2787cdfd3e0d818ac43ee77d7175e7a5bfa9504736f96a3c2ffbf5ca24dc3f66af10024dbb80dcd0a2dd9935a77f0cd01fab99532d9b8ac12ef64b0c4fbef6903f2d33fb8153e92fba2330df854aec3a27d46632a6b3a4d3be51f6877450dcdfb5bbe61f0248006ff59caf2b72f1c007f58e3c3186bbb455d33d7b15a11def42659aa3477a1a3ad6bba8f1e9fee56d99b1250de36793939ab0b8ed5db83da10a0fad0384b6d71c438a3529d107c2eb1635e3cebf0cc57638ab5631a173bb8b0ce792cd007fd58f86f9d18a10c4672329b81c40a65e736966eaf03fe807d6e5bf08f12eb93f0165aa97fa745afb47c5543a8ff0008a4331136ed5a5d446161c72b9fe624db94e11e49a682c37b94f06d3057205adee1ed027741c5903beb660f2bdb66c6512fff24c7d8386fb33b57a491e9c625bd7c79f16a1b1566672e42e9e6f521076e10016390e55d2f4a3b4c9496d73ea26c6439d74e5327058de323f47718f459a4a90de2ca881f376bc2333354f9ebb72bc662a3afa6413cffb58ae7ba9c1b4d6bc2a08195a641a5c3d2a0c16ccb70e4e6afcd5953c85e137abdc2b92c5e0c696e8929070f5081ae7a705c24301ba41878f24698d6410091460c62567d26a266cd75727ac7f0e5b4863011ec23eb3c6b0f2d36032b9967007e27146be0d980dc04ffa105bb2798302ca300efe866d3d27491f88e06b234ca15f8afdb92981de15632a0e6069a3a3abdd3be5fcd71369bacd6428974967989a5611b31b2f365b4e291200f2aaa7b336115cc9cff70b33a23f4fce9c6d09448a9d09d60e3b4d8c52c4934a46bb634367e25aa534fa7aac86e0e224f5e6f57771bd147e58f43dd2a4721e9583cfd45acb3666bbe337c30219a3ce50498cea96e25cf4e36f9a60383472a7fe8ea670b844c586a3ac5afc520302cc943f96154371787a6f5ca2288de45e5e59f801830707152729b6c15088b3af31fac18cff01283573110807d564a2b79a6955c81cd95aeb76fba88dcf773c5f5268e33036147735455faf938ae70374b546616b71b59386d6e46388f6ae6cf78e682b4a3325e749cf1a482d47ea17ae3cb5c8e32508539918224d0ccae24d15329bf5e98efe08070ef9db2a0d578a41c0a4ce0e48ecd2f75ed819b301fe31da88d8c322be489402d94ef3a967864fc79ef0e69a5742bbef319bc288c57c605a92444d034e2da3fe4b8fe6036ba52c40a11034ccab12002fedf4b7961371db4d796a3dd0ddb99daee1a2d46981005c6b8be48c92142ec968a8f92fd3945d6a5508f83107f92c8aa016343622a362158b06c40259ee67c4d3a1be0ec4453e3ea7502d203f107aa9a91f6a77da6f2df28221db4f07a167f5969f48c507a5b0a92042ae457af1c28b8039a4ce1f1cbef83316f5c9dd246742cc5b72ac48f0676249c8c130a5ecfebb023a9fb2b9f0babadfb056ca53fec33c252dc3d31fc05c35856a23a8c3a946ab0c61a8c8f6e2bfa0ae3b9a602a6192300c1abfb3519f832e410f60cb728015c745203dc51b77ec5ac63b515f02cf4bdee8e686a7c8649955e0f46126c431c6c5767bab1ad1cb2fa1b67680ea58e8a56bf54014de5fe5d7f90bd6d02490e02b25fc68f6a1b4d190c4c36019179623ca5ab6aba8147a1428298bd9fee37e566927006d35e2eb53f5e40c1a483fd166854878bd40ea0efed745607f9771d1ccc43bd4c272490f426bf9a82d93f1477100fb9417b1811e517ea6312462d765e9ceab4133b5f20007570f234564ce4b234798b2e5861accb3b56269ebdd0d5c52c8c3a8c27354aabff14fc24411d91a3a341f578a5444dcc0243e5ed471dbd68bba00f28445d050cc5fcb88e934c697e3edf124026f3fc9946d795fea973cdc3fd7ba017f6a9f0794c6ec8d683e769ab3c4e469dd924a38d0925abbc986e9db556961678801924467985c76cb432cce20b3c6ef31bb7c8e129e3cbe08a34de15551c611515f974a80953554c5f484255485754d0e2915c662b0cff43379e3e21328e91b725f0833620e50bb1b4f425307e8092931c702543c4bcd6ad08745b2b2721ad9e4a141c49b1e7968bcbedbcceab4d91d2449fb89ca3a94b4216270d5c48dd3c1b59af29936c46aa05d6d60a85f73e546c1d2ac3f6ad6e2b34c881a320a7182cdf8ad8ec7584a51d97b5df59e5bcbd099800ff6f374753c28cefe6342bd12605aa93f5df9f1053ccd1cbb387f69d6f0c19c67f9349275e3982ccd62eb05e434ba779fae4e4dc4886a8a49fe61f7296da2e0a77780e5f937134c030353e7ca8bd19310ec6e3b93d8d1e0e9d3a6d95ec4234d2f1dfb540c21c0ef6296c634f6151f02a704e000af894f31d0b4285020b7ff21a96a99be91fd70965607467a45af1a477f819dba2d681d3f8f39d233cf956301f2da40dd6660bb421f43921e0577759345272daf1773e3ccb48f5a49866cb63e42ab1e823ba57210e802b9af27e972396f34c11c5712c884a40b33f629121c35dbcc41d1f9e1df83c6877a3ca7992fbed02cf72e05c5650d630cc4aa1cc92215290ce162fe60f4cb22be8d38056382f750fea94f6da0ff702f2018882da00e712baed099ca950af3ecb0811ea7a0bc41d73b5ed685d18e9cb3c87b9fc743dc69e40038e995b89e39ac4029a12f7ef8c4f859c81572e8360d889acd0cf9673ccd9f1276502f8822339f327981eaedbc52db7d4ffe46f01191c42731683d202d0109c991f3ee3ac36de6d4e2cfa36cf7e91809b04006de73098a17c5aae085c188e2e6c626f2962bf2f17355424558e19ae3d19b7a75860cb1ac43b2fc32d09d343d77a94cf08fe8d6728027ad91d2ca14263ffef839834969ba1dd4f8bb227dfb74e66fb4bdc735dd43195112e74ee431692bf10255c4322d049fa804efd692c8c8e8442f0bc60ee6286de14833134cca17982cde0420facdc7249ae28c4630603c132becc21aa2fdab404f7910c7e13e94d182bb58aa4ff86d4bd35c21d31325251301cf954e9167b8d89dc5859532892067cefd5d27c721d750316e00b59d9126dfcf0883118d3bc6de6a63affc55479c94b660859f4d21947583ea88d37f619f6ce264bca3b12f91ae681a31d7508943b768a026fc90d0e7762152b6e7afe34cc2ce3750c7bf3f90e19713d4bfdb16400dd61bb95a6e6dc9d1b1ea92741ea0e03bf7442a7a6756d2f617b2cde990a50d037793ab0952f5601b65726334a9f7164c24e81b6bc089b93e9e8b14a8059d8104828ca7ec35a5548214aa01044f937389e5516bcd751b27215d23147cdc6a65b22033e17943bca8f497846d3d057a554b76e085f693ba9cd0f835ce05d096484004ba3aeb442b76dd1a8f8685cf9575c03fa28a99e5a8202413564c3425b243d754f5a12a8ef6e99248150dde8fbe316c23cf68fb2f9e5afa20e45f6aa625d816d9320a238b664ec2c86fa1887d402bd764b6ef84152a99cb213e7586ede06c0b24cd564682ae18a0b54d0fcee06c2900383c0b6d8d412bb0b94edb142f0ef5849496e89a43f6c44962cece4b374aa19c2f2f8b317b91ee2d226419735fd573e63ebb56b5530cd135f0b0939ad94cc8251c4907823ca81ee7b88d0577d8ac65c173052dc8b5d7608cd1feff38cd15ac496e7b829235a43b4e03bc66aaca5a3c434a13fa5515d6c61fb3af44029c46fa060e85e6d5e5cd489e38d0eb8170328d375eb6f3fae22c35505495709a43550133eb582b90e9f8dbe803a0ee94fca1fa23a48b8c5e40fb31b4e01e132c3e014339ae06f3fd33d76e85145ec30ddd92ac064fe4282455897ed5dc4ed8c0cb04f218c7ffd6ae531e562eb3a02fa47c8adca1bc589136757f82a798feb19512370f72a4099461ae6c1664ad8b46ae309c2fd758434a1f08ba6a8d364167f0a076c0719e4c5619a379396e772766d7bde4ab641c53033956601a4e995c906e529206f56277de5f9ae3a8d097839d8cf69bea249177376e4180a3ead6efc0aab18d32514aaefdda4230888896070a406541545838fb21ac3101dacdc71eee4bc0983cff10fd710dcd8ec5784d09f6e3026991b60d111a7ae14665e2b0f546be797656633297e8dca52d2466973e1de614bba39268e375c6197924324764f5b2622d55ff64a3ec91ec7c0ed165109af07512ff3840b92631dbbcd649e018241b22e716b5cecf293fba96fc5d2029592b80b39fa7b80202f75031261df41cb35bedd39e83e4d18426caf36a15275c18159a1b0d26b7a395ba6e417a0e288a41df920346689fba370cef404d78f7c4e337838af81529de8c46a676c3132fbcd15ebd584d9d573ed5683337a3eeb91c1ee6cb2f6f83d1e1aeccddf2caa1b0bcbf47aca1241c609dfb3045308cb1666bf094e603073b2c2451cf60058e0ce15c046d7ffcc3f1567516b5a5b695b43a958781fcd95393c2748139c3611749d86478e7e2c1a7b31c6874fdf484336622f87e818dc16dbd57e13839d51adbbed7d9c8f959450880c75a22b1d60e1157906a784a40da9f314787eeea31c8588e74a51a7f45e5bdc7fdf74c6c34a5d1c79d23ca92b6d2fc7a74424654a6d0fbf55b1356ecf2a8ab475fbbb10dc8d22d7f61c09e728f904faba86a18343d89bf6b2435d6a62bd951817c4161187d5c1db37496db2a647fba011df85dd202851c88b21810766f5ad1385094ca3266f0f2e957854e9f7019727d57649407de2c66bf9c557966b4e7c682a0693f03a1947d85227cc4b86d2c93dd79f5acd805ef0e22a7bce15dfdc677663023bbfa1de64499be0eeb68341c273118b141e478db07ab8c883b9db0c841c2137ef2c657d26a00649ca3e8b323b84e07381a0f0110ff8274a385ebee763748c5086e1fc7c49c922bbe4b14f30e9ea53648e977c249a679b182645b499d06f483e8a4d1884e42dcd46a7dd58c4580dd5a2a69cb253280dbe1e788972062a6f61c0493b39993042e6974bac592e225076041958378f335d19483f10d217152012912b2bc15955e8d88cdd5a1f2b0e0f3184041c3f5932a849cb2877abb1279d1645e7106eb61029bba6f7d96e0ee0ea65f2304c6c4d0ef7cdcd9c623eb04999a69978f897bac1f39e9a9f8554eb7f2e881d7a1471aa34e0fb165f2e233cb8f273430ca4bb8e021751d9f1b24149292f3c1e91c41985246b9d82deba3ae88ae3d2290d3ba7a803494f3d83e62003caac7b9a56a3af9e1b62d1853cc249f1656630f4ff22f495f79e1d77def7747e288bbdc0cd388545374b902589371259ab36f9e4734a78e969a5ac3fdbdc76033154f3a4ebedb12cd1f4a4af38e2ff4da61622a6fafddc408d33cb75b73d73e5adca406e607da4a8aee5c6a08d0a3dfd0dae7a13c46abba7efea659d0813a1ef40eea57b4d86ce6fd4f48583aea6911ca31681bc69beb7cbd505143a81969066d847516117303c10fda6df0b1c7a359dd78b61006d8d31b98ad9a83c92b9d4cb14b933a156d7c5031cce02a6e087597561450fddebec76b55c45be3d47d97940b80667dfed895fa019777ac9780f9dd5b3203da60cccd6417fac143f255f76aaabc0d51cf3de3ee8c574e85edf230f55fcfaef675e29d1302890f5e9c9d548e605ad78aca5692a4de7f0080c027cdc6d93ca5813e78776b62627f46e58e97b6340977c12631896f0303541a536ec081d740b7310bf793790ba202378abb457228dc193ac1a1efd0fc69345ce4d82d02a48129f84c48ee0b382c3390969db08bf3bccb9ecc49e46301cc9294ddf3b0858235ce0a8ed34191660c4de939878da182a7a05f147c6a49ca5be16470f6709e1016c2be8c5c8d0a7b59807265992661421d73a48f477fba0d9e811070b4fc6cbd7ca79b913174a3521314e47a6ac15bcb0b099539a1fae302bfc744da728297d784327fd4e20f5bf09a330515d01ecaae1a2f004499baf72509989ded21c9ec7a2750acb0678f37a951097c0a8d8f5041541d3ccc1577e97f3b8e8980bfa73f5233180649e0441258da8ef11cec8df89f0a50365d00b716cfa831da7882e2f62ac89f7c562c4a2e1aad4131a8b53fb6fc60b066a6c1542d9824fa7b86b0a9b7a1a63e23dd7377fa20821cdebe9e02c7b752a881d2c5c131beb14900937c148682ac81713b0291d10115a079c668a61327764cd56995d3cf989662cf7dd4b6998376c12e5435afc3b41423f54380f8994120581128cd8feeaed711a613d664f94ea49853d468c925e9fef60e34a4e944e0723be7ed370797a9d8d455c78e0500610b1b377497f415c5b17c42e4e8fa565cf1930105c0f089fec28c8b72254f61edc4176834c0583fd69469af87a9a947cb16477eef7f325565b8879a2b593a87019a0a142649c42ec725db624c63590274ad163fb79591e74768702ce6a586f55ab17e72b47c7f77d5f68cea3c10a642030d724985de2c015541394830f0689d2ad770041a74f2e20cd2366c40678dc284b2b526b77592e16fcfc0d3b3b0dae806f08dd8d1011905b5a99bde117ef4165b8005e34919ec8b6ce16ef27325f78061bcfa76749ba0b139aac3d22b945d9db7d80d209fcde1a8df734bbfeb0a8e0e243688071fdf0806a7631961c9caba50e168aaba000dfb4ad3dcba1eac1d2095fe1e0c8ac9ddb919488c8c3b3dfe0331686b7a522a310fe623c491ae9da76a6ef722641277d7f9cfbe9c20d4cfb6a0eca10178eaac5bb8267e93e6239508caf42662589e263f077c8510c43680f71e9ab2fad071d94449d1aac12569194c111c85941d417ce9a382ff6df8d5679f82fe2ab62ecb8536ca051dab5454db74135d3649e3d5da2d784c75c3ae9d849aebf3644121bfce5eeb6070526e7f9ed4832e5db824aa5adc8dcdaf7a4f1bc20662b31619a52bfa506cb376c39c553a5e58242413c2baf3c9cd9805c98b9ec97d7c785d9a76e3aa102f10b9ce2d76d9962f60c8cd50d0c35633b8d70ffe6e73c1f5f35ce6426a4e740797310b87a36ccdd1191e83ff10473373e43c33b6face6519dd28195d2d68d117a65296f8f4b5b4318a0ec36f2b47eb8e8642d08a53f02026cf06d5eb6f2d16e1afe19c41510b97a5698ba3e308441fdade6b85b66f92136cfa5279b370f75e381aee5300c16fbe21294fe95277b9a5b1a995c7dc60dd90982fbb32aed3e1b5789400c0836d5fbf3e14d37d09cd9c346d6a0a30fc5d57437b6044b2fc74ee39cbf3b15e2c2cdc77d288105a49b3382fa915c2165037b449b3704c4cbd75fc4893102afc3cd5e0ac49567d704b598d651e83b2cdb84d8a62833b43b1fbe0299fdb8ec37cb6059fa509cce51e5a55c8f651035197e141d26391f91e0ac0ae09580b3df457a75de155bb46a18cc3ec90046a4f5513629d69dd531c6b6c52f04118c57ee87d620981f5012d669f73f62c113396729946a2f770bb4803dc78fc2a914076c982b5ddabb79ab4fb1622e8dbbe74d1821aa92b01599a6698c72328dc954ed88723380e65a9c04345e95babb1eceb9de04bd7e3c7e02138e3078c1f4009f2bcf12b7a1e44269b676e73e4c6d7014c7876812fefe0c8d4faba79c345b84fe0b91baaa96ee1c548c9009524dba6074bddd03a7b20b1578ab4692eaff62d6b2492e95cba130954acd79220d8a53925c2997fea0669ade992780096033dc5d3304a3440834c166ffd88ab2714c077165d12da2e0d50fc581c0c6cfe2f63ba62742343eb0993c2c29a810b0f40a271755b54ceb8ecb6bffb192a7fcd8e46144092c60f105a92c9d00a177dc9e790cbee1319aa3313e736531ee7b38bb0baedfc62c4dc845ca6bef7affa8b4b1b252e02a57986bf9a90e5892313a5903337a90b996e256329dbf5228580eaa67a7c3049d6c03819c884edb2914581405fa96f474db0ddfd92eecd6b919343edd2601f4a53135c36017a24c567957304dff043ce9ba728742452c37eb93d03331832ca7ad673315bcd2873aae19868208ab614a02f621b37e2ee803205bf7837335fb0d7d2ed04a6ad130e0cfdfef16b82fb371b26c76db1a4d77c95dcabb89ca47a1e4d17fe6d64aae74bd034a9c71218e60833feec44c5aa6bcc33cf98237499c6b0aa360955a43f8f2a1c3f902fa952b85adeea8fc930f3f58e5de0c09f027b6bba638a53b7f8829db7f1b6217e7ead5d054ce38f19af216add4f4a13b24b4038620f5fcd515f3d4328f078ca8e9ff962dc9f95e14f49bf1bbb1dcea6a28de1d2463cd6b0ed25284da07c5db3c4790ad8df00ae5eec0ae6035956da2f9750874f2ab1f60a4d1b0e6ecc7a9024dc460596bf0a0bc74b9daa87bf56506973afd46e88831988c82a3c6444aa0fc1f46c29283c5e178228108f1d112981fdf4800e085115c2bdab16ef3857ad3c0fa556063933c3b287dc6c703128bf9fd0b5aa8da80fabccb933ca14de45c1709e22a066b771226f4754cb9d079426577793ef505a594b1acca53d34a47eee0f01d3433aec17d4b266bd99effef5df516df35b01bf7914037d19fa6a8cd5ec353bd9e6ae61edcb1a38134da645c8bd413e69af06b0f30a835bc37c214c85b3ffe05ad96c8239d7ae79c91c234503cfc7f65951cc67244a23e931586bc8a2dd99ce16398ac92b489454ed463f1d8ea893a8ec076843b60843cd04cb6e3a245be5ed7a9e8d6f8b83e412e9ade8a633701fcf223e25652895c28faf5b255c29ad304aa7702f356675ec9c469cb7c49bf2c181794610af06c26a8850fcba925698a3100ca5884327fc25008ccdcc472dc365fb88f70d0b319abe740184e27e1c9ed306aafe7146abcbc8f6192ed5b045c6ba1716527ea3907c1dc0b6f5ec6af150b0f9d99c1f1f79d0d07a528e78988a4dcd9c735b04f893904e1d371680a64b4c51d081dbbb2a4b96935bcb5fc0c401be8423f25914694496548a846718dfad04f523c848ed7b39cc6a70ec41f24cc291a2d2f385452bdef56cbecb8a3ec9840b0686838605faf0b396539bc29664adaad37e5ea70e72f993a39486abb783385e5a27f5bd467f6ddb77913c219c58ff240489262f9d0227bea71fad568c2fd4f4807e20c50f1c25c13dc7adbf81904ecb320c5e556c5e44f6a068212495eaffa92284bd4124954c4594c5d875d9f74fb139e81d208e05b01d5c049ba87d790c9f5ba1f83d6203091a1dd795a9dbfb94cc422aa7a686b4b37cca409d469cc7fd653ec76394fd0470a27736c7dc1cde8dd48618a9fb9d66ced1fbb731fc096a831cc482dd8d5a998320b9ec9985902780aa431b6a3d478a4c4e71e1ff89f6cc07e738e93f8824177055bb70d474627b25d6da196504e2a9a3e453e0e7a4661daecd8d48bbf43d15b33519162a1ffccc2bf737974af8446392ff30288de17e7b5f8a6669df171d0f9d18f16729666092ed727b9622252329c82819392d2e983ae9aa802d392be405d30ddd1f72220547fcf2e6b931d4c2fb5103e36fd6169a7ca4f6d9d46416059dcdf30c7691bb274a8a6fb90876aaef1c86e70eb03c7946e68898041f5bfee69928b503831d81c2d2267793fbb66ac514a08cc83767dc4186874b576ee7a24a2073aa796f3fb3e1dba7018cd672e724c32c55fa4ddf805ca58d5556c9d0e09d5d0bf19b50c7fa96bcb4f6bbee291b227a95122caf872105f1d6bb2f904da10616552b4bb44af2128f61fae30f40612480dcbcbb8b0d33c95a5b4a9e122a967d54573023ce0f2679da48ca473f265e320b5f8c21486a9d80a4bb130403dbe745206dd324edd6f28e6e84489d4ec4cbc4f552b2688ea296ec7f76667ef20b4044d6104c7711da9b86d34466f96e977282dacc49d524253e142d4afd7e7501e3d9bf79c8508c5300f1adf620ed2eb91f9f019ceefe781f1d537eb3bf78e4081eac560c35126fc085b498ee98789e68cf411e7154b7ec42ba1c6225ec31e6c0c1d1be478381b2188b0d51685d3c11018b1965f72a608e569903a4a365b2d91c5a50f43f6de0eac66b38fe6e2b3c0881ba33d6adc2b9cd6ec6ddf3b8b370af6ec0fb00c082721547a2bc6d35d10eba64c66a939e9f4633c832fb45bb5d8fb6784d9e162d4e1e40f3ab6c882dfca8cd3430cb8d325cc4b4f26ab2b4f9047b2f9a0beb5f189b5fbb3e574fdd7213e131a465f3ea28e17e3e069cc3fdb30908cb4c3d529adf2a323fc4377125c897bd275a4c01a8e9972a4f819a894a7870e50d70d22b1ae89c69d7d29c698c66533a811561adaf733685bc88598242cbe9f980497bf588acfaad31f8026db49190f0f526377790a279dc7e55cc305a703b5ea9ef6b1addd81995acaa25b54b7d4a4e12e3fb2bc31af6ebefabc28a7977ab9f888d8e19e76234de9acc80cef953a924ae978da1d075710daedf30","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
