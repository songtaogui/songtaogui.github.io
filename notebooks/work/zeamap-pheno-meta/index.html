<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16e4721fef58af42f219d492725148f6b190b1f48a233f926b32b4145bfdd2c5b9c443ce89fd8c7a6321f9ef0e6669ce2894bd2a79207569c3f2831a373767413fc8a9e2d1d7ee3ef7a58cf7d07014bce419cea119e1683707b0cb37fc0761b812c5cc8a91dd533f109d5e4f72b583cef9e6c680c509629621d3ca85c58f502ba560afad9d5d3bc79af14c8fc4f939f4e28a24f7bd632f79308faad75cefea7e02a16ca88c8e3c30ad7516c9de0a0f94bbce7f29e9d3a5ad42f5a6580ce5565ab78598bf7461f7f9f8b951b3b76a4f7c81a07d5c36cc53c743484f2b3b6c64caf9ee4c4c93f20f77e3b8cdb0be75e4f36e684ed53df625bd8f6ae1c3551b72396ed514f487a5c456059cfa9e380d68d5cc173c5beefce03dd8c027e0f80df44e81afe7f4d2d1833ab775fd2e92817aa66f1edd7b1216ce26b45a5138921e5a79a639fc210e4efd22f48c211258aec5184bb208a013b935a2407701eb1911a182fec61f06587996b25c1dadb66048805fbf9f6ddd71542a7a2f1a83b235d1f68a5ce98848655bad4a01dcc2ed209abdf1a1c7ee1de047647028777b919c7167fe2d107a8fbc89fe34e26b4aa78e03b3bc4410e4d49390ba04c738906e177d0949039b1f78e2a5f8b3d2666c2d3862b12d80c0b7adcff5113f75e72c85f012984667107e89f92b0dcd77ff40e512198880a1da51671c26a0513eba7f3fddc261965f11bce8225a5752875f0f6850b6ba078a44fd98cc65f04a86ed399d28e00f7c12d10126dd71059d44b7ccca37588fed0130dc47c8a0b913be49ab9cb673dad96e6836b1367ee14ca93cb136351d24bffa67e0f16091bfe51ca19358190ac05b36d94220f0a0c7001ad2c459015f8652c789ca7252cf9f5d9c5b1765214b6846cca4cca9c966730b46d472037ea1e6a4ff2c65d40006c255ba6b3e33e53c85052d3f3219727f0328f4be59e8b2342ea718f343e5a3d3de6bdad1777b38a96c19cf6d93fabcb1e4432386471fa243dae4fddae28a5568583b8989e20258b2dfe2459c70d0c7febac47c5f6d27e079071ec327fa0c9d8ee3d7e4e764c32d024342ba7305efcbeaf20f50cc5e22981fe1b6b41a1d6da75e9988ccbacbb5a3de708ef00e8fb30d3eefaf768fd9c15cd95886f256fb28e0021c9ba0be36c5772f9fcad1eb9218f40b5bf0c3e8f6213ca164ba422790fc31a9149ca286d1e46443364bf946e9c71ea4c0219397f3ca80b2c2f2cd760edbdc810b5e3352394aa1a6f6ec1077e5f21d01917f7516ede6173eb6dafc7c2a5e364fb05ba23b83110bef04cc94a8aa29c027d896d3b1e64fcafea4c3f537636fdc6e4d9dd5e21c246b47474bfc524f5eaabc719a60c4466676f920e3996d6b2832dae241328acc7f2238c8a1479265e69365cc410b57297e2696d364d983912fcf4551137430939163c09b51d364fedc9b2f8857f872559f5f1833c09488ab97f88c228c44706e6da2619b0c0427ccb0688888526c8bd6ea70d6bf2efe63c33c7f062c951a39c94c6d37af163e129afa6fce0f777c750033be91ad80f93f4b69c906f4a4c95bccd24ef4b380f5e4b61b4ea09f3a9539b95778e89de31225c0c4e1f536782be53a59c71984a056304db7aaa4f89939dad18a91a9df536e45b9d790de9f720c69cecbca500e61d6661683557ac55a3b82cdece6d9c2828fa9f9eb03181dfa82f991c6fa1ca91ba602a88ed0c600dfc3f8f66d49e2d72aec95cab2ed6a8120de575687b13e3f6fdfcecd169df7ed43beff78e4339ebf1f7598a3d53c8e73ec77676b63cf9904627c13014a1db94d3b22abcb5203f58a304f535a2370dfbe0f21a983c817719dffb27abdd7e9414f5adf8ac33b1e58e30c13b4efe0c4a4c91682e54954159384c1def18c7e1e9c75d5b290646e897008574432c2fb95b80b04f1045118b44cf6e854b6232f703d5c318ac3b4a9bb5aa4b9d20988750fc3a46f20b441b70855a293f193b9742234b7673310d1d04bb0237f0f4d54ba297d0a149c5e67ad981a2d4be93e85c99202604dc73622a234c5b992fdb0f5b8533436e1049af8b260e5dc733cf54e82905e20352992688a0fb775766369031d489e85fbc871e05df05f37d94d65c6e9d3ebbed3b73914e6036c1235186771d3a6f2a12560729435f773fe4128015978ca0c46ad427c95a81f9c5721b13a5c88362ec841ba41aec490f4eefb6f8047f68bd146e477e247dcf67e5a07de4e7a7ac3f33b4068af5b8131a7574a2b7324aaa64d4a2a024cf5f762bb7f4b0d47b8994c605116599cd3f7a3e3f21313dedabcdab853bd8a0c7593e7a68f5f9024bf69a05b7a27d941c7f188de3628b0e914d1e4329f08b802b3bd8f2da78c5a38a2ec1ea15b4facf0357a231cfc1f86dfdf2e2fefad4e09b54f549e267c7474200ad3c2536f6d0a9769e047d27e65dc419881fc318c23148193c70cf2faf261f99975404ab6bd4cd95c9c042311075b01683a0de0317999bbd811524bcc3a3f7a4328e814b4e37eabed931f6f64293c81a15f32644879933892654a436a896be74229d0ec160d8f188c086f5b41bdc6a1faeeddecb113220b9907f3050182eebdce4c5e04643b680c9496fdb63a486de1deca8923b70ae3772aab1adae6187119f3b0946f40bcda2b382337dc50ee0a5baa55db25659a64b466f5e18e177364a131562c95cb673500ae58100dddf6b32faf397768cb58a76d37190f6c2ce351caeb98e14faf80aba70771b5f0d075e1507a0f57fd99f4c965bd08b2e19b4b6feb356fd0d40c43eeb2bfa65aba284531d44e92577b435cb91ecdd417f70428bb02a36b7646a681987c6c5f989001f57b32c439a55345ed0a3abd8218999aeb6abf75a5e1d5e1b5d62ff7b8f7c8539dbde0dec8e4956e3f403d4db4f1182ef2ce724c2d70f0baa84f6495a7cf76267fb9f247e5d60d688655cacf95b847d13fbfc0a66ec4390ef5e2284038365d0ccf72003b53e17f9c2146ff71ce1892c83df22dd91e68e17bdd591f193a09f4999ac54fbed41cf75e43c0a89edac82214c45465df88ebcef7242ae9af1f99c3391615e2c03ccd8ad2c2c8fa1a1f4c77fc55be3ee5e5b58a1b91ef964e9de7238eb24989cb0ebe77ad39611abd4e3e639d250a08fa2f8732da35b74a931993b6ff1ece839135ccff161c3f42bedf08a0e5cfcdaedb9cbd4d01b2a56b1161459ecc9ac13410ebe9cde0927528c3cfaf54c1b3deb88a373ef4ebeb15c2af47f9a0e058ab0b9aaf4ccf8e266833a9c3b4fa44a3907a5e00f7fa87c046c842dd4df39e5101c0a12f6f016a1baac1c2d6cc069a60657dec5a86a28f963c4adb82fe437dff132d859497c333481d403978fcd99d6b704a49c732de9fe0b81f1f5a6a42bb4e0e946bb7333037f56a72a3a735822b3995f669c7c00e9ce75273f58bdcaef12fd12d138f370e680aeeaeae6c67c9c64a77cdd812e55d107dcb53e7d0ff155aedf7691f6a549b80e9ce027076c9da8899a5eaaac732c38842ba84c4121587dd067dda7d4de10099802680c7f030d1c3f8e22f99c06c1d08a5516d7c00499253253c126a499c181d665bded464b6d0f73f1704522bc3b848c04671492cd57d224890ec746ff73580a726a9f1411e163131067e94b7aa8241c929567ce7f85b802384eff5b2434bca763ee88ce5987f4841047315f06dec0a6a6e37e64367049fdab90134161dc83fd404703501f9f225732d426b8188721a4456221c84959a24e725c65e8b97ada30833e645aaf34b55a85ef9147cc9ffcd6af9f4814e439cbdb5fd0aa343ecc0f5cb2883276d1a048ebac4bdd2d5a1b2c76f21e6dbaaa517682ae1fd969d8d0a08f240209f517e98291a7dc437f5c086d63489d006d7f6e3b841426428e9d1b6553a2322fd1b8643b60cd546e1f9310139a70976f940c0324249d3c32f67ac90d1a51081597bb400e489b9a5764ff64fded229baa10adf4a582ced47ee8648da6a24d002956794ab9cf5f1b48b6012f4f12c510f511e62dc51e90e8fa2bda408634fab8a8ae5d2398315a2fd45c9da494c7ff5f9a33e785ee19f093b47a6f40c76bdfebb0b4ef9dc5f87e88dfdf4217a3280c162aeafe5eb30237a1ccf0df67ca971408deab13bb6e44c55c9db4be57f27b899cf983c4894b59e7558c4d3b79cb91ea08387ae86b7de1fdd708ccf7208828894234c9ec6a585810ea91780f59253b82a757e9b57f11f88758282e2c5dd81a97bb0cd1a3938e781697d54b3b881951e2283ef4488c7a81019413c1317fc84c7219e16acd46fec54128fc39c9193c86b0901b82abe9fb0ab0f647bc95ef818fdd2a820f7be457c94fc4b647e869ec391571f6fc121c4e33ce6ef4d60f3c7d25d8025dddef3ddb163c6afda74189dda13adcc351f22e80b30fda4d14aa69accce1f811ef63a6442418b465d170542ebe7da45cec4aedb745adb07cd0c0a5d9a74c9940182fb3f23298cc8c8632129c9d9557c97c628a048c59f555ec9edf6a48799f8caeb2bf3c8fc0991d0063c988a881715217784719c36b34a6915f9a64198b7b118d3f55851cb0da24d293bc62db42c2ef0be5bd76c67bfaeb38f724bb21d9a7b6c7fd120d3849953c52134c4c7d4a5c038087755dbe986ce04f1d082594cdd1f7c27c0213c237a4a5b9da986c1996cdd732f882d15ddbe53df5d46927c818bef02e6aa2d1f46bdcd998ba35ca7081c3931363ae4f1fcf248d7c4ce07b71d1b4232aa87ec151aea1111f7465e043157d15a7fd0548073c9e0077f55135b221a8efe3adfd91a384e66732840e1f0af2e21c596235eccfc53aef457159a69397ba13c425d2f88086bd7647cf331d7c22ec693f4793a1de55af118d63d8bc659e4b7a9ac546950f9f2fdbde1aaca1684f47885b99239efc37b6291cea9c6f58dc1414905024fe3e0b9c5c66a7747f0c283dde09b4755d675a4de8ace0c7a1b924676e965a845dd29f9dfa206b4da7ca5479fbf81d864f7bfa879a72f8b8edfa837bffd15b7d1a08f99cac02e22e5dba1b70dc1a5569b9b591c4a721fe2acf5b97100c8c3c0af2e0121afcbcc266f1490854abb96a5d362cdd33d7e78f0de8a2821125d044d8aa8734266274ba4c746dcd0fe9b84cdfb2e65a5f6948c1b56770c52addb81ee3c5dc12a55cc94ffbb63b278459cbdd7433cb3d7936d0ac174d1e845b0e6063a8da5c7ee41dd80dffa6132de60f83b412fced7b225fe583ab94663b3951c548f0f40c0bd3a7b6d78e67a00f3a55bbc981fc17c3187de4a662845f5a58f53a1b385db3669a3441ece7ae2d9b94a81d616c124e3b1e40f17a99a96aec5e48284cfca98ebf3dca6db5196251dc7f858728e3fed0f7ac4b2724c047af3a4b233591aeeaed8f960799dbc94e85e5215766b9fca67b0dad2c86f7441a345704323e24c6e2e85a4bd737f812229b6431ce99fea317758afc9caa86eef13eb3302cbc078d6b2510b1ca3d68e63a3176fc134565fb78b1b140bdeeed1920e9ae74c86033487f9574258d4e4d159a0b9fef4a44f6f3ecf66ee506fc3c375740e98193dea1a5571e187b4b42f8d70239504f9395773db12812182d1660dd5490ca9e6bdf05cc27a17b2615b7f18003473c96dc7eee9b62b3e76dd8ebd4304a30764e8a56c14b814086c485953cbc37b5e66502f7383ad986b4a69e5822763b5f7e7676cd68816b475da7311691d0ece2332f49a8e7c78c13ef7a4b6602e2a92f492b8210b44328f8abeb80fca4b7cf13038f7e4b0f0d60123963e58a467ea78eba68647473e769a6d8ff723db567a442aa0d6884f4947c3312f2a1fb86643e75e04674e64e5d0e9a23f2bf4dee90e3f83be9e36c92d74868e79bcc18930331209dd860bb9527afb18e31c5f8c2f3e0f9168c879a032543d69313c33b12b4cbf8d3409599e300359cdfcc63a81ce267950e2c739fb1613c694d8bcbb57bf14800ca12128054935e256567dad8e44e139893cb1bf12a29ec562381b90f67fc831ad5a4e868cdbf8daa2d08e619cf438f76281177faed20f355c1a9455d478ac2ab2cc86a05bcb513d31f6c354cef568420f638fe29d725a3bfeeed326f1fb83911e4be1a8579714d81ded394d66faa15b9412f076f423932f7f5b2895e40e4baa5190f7474ede02078ebc7dba657da90cf16eb2fc8290589cad55a66a7a8ab4112940ce2102d5029d1cdb83ad5b0a73d126799b73478d675f67db88691f938fc91e80a47f3d2f11e930cb650d1b6169d10d715247858cd88ef0223c0d336fb88bdec6ef29cf4a20c11f1ac7547d8391fde306753443ea288b337231aa6f1538d5e160caf919996383210de006e523015a2cfb6c2ad85296539ff4abf4ded83e6374fe1901adc19d4dee68890e633c52be1698f440aa305351833337c763a5aef34c5849ba805b01f6eae9e769925117b9ebc281dc02b9358558c174686c2e1068e50e1a6e2c59817604e5458ca1569a4000817fca864010e9827ba2bf68fa0e3ef98f79eb5123bf817ae341f294a29e7d7908a348899c3102047341eeea3638b995365b7b6ffc287919df80ea424865e5210a6ba352354dbc8031000ed730064bead25b7e4f74d0071649031bea51a0c29e38858bdadc10e2e05317612e05e68ac0063d79913d2f77b9290f079ef4354b2b0b9806f562ab95af8341a0584edff9656a66d822a85944d09db90820065c7095807ae3788213114f0f48c1195c679f3eff3cf87bf58c93f60abd5a8065fa427b038c57f7d80eb18af12a4c7b7c89fb04deba9f0f03641b9542ef44b5f61210f5b51eea8269dc425d8751371f910cafdbc787f47f47fed117c86b9677d51c9103bb9d85a8bde0172109df099cab142c782b7566b3840da0e740969558f229054e5a6be439c71c19cf2955dc6f3008119deaa6ac15681a1294336f75a30cb87fb49fdc1e7b16356ab4f1a33def1147622b102965e83dcd5d0754e646b17217ce86d6792aea9dce13022ed37cc18ad44d878d9268c4a0ca6a4f9c838777bb26f271fcb68df5ec365bf461d0a1aad064b61de8879b62db66ea6782be593246e2240f0312de62581f19d97b048eb72ebc4878140d5e9a866b17ef306205da42b7c17943017f1a9dbcd524b20e0919b4f6201cf66c20f9e53f9e7bba5d217701070983019af6ed131ec64a3494aaf8a3fc11a260bbf053caf91475e03a057965fb9e1159b3549b9401350b94ebe72b0240c7d645149b7640497091116c5a316edbe614b7696e2f69a48961c5cb90bc57d9446374e289897259af7a1aaa527a407a86732a2298e23cbf9ba5665a931aa6469858435abba06af63acd85cc5ecec09ce854107d204c757f1655d6598d91551126b5034f22f334457f26a4e16286038f02aeb6e1bd87388768dee1ad5baedccad5ab40ef682d71e871e7dcf987365d28bf596e6e0fa3ad2f18387dee550b59f8ffab7c466c5e489256c8da7b2845e22739df10e4473b515e05c973e8c492a5a79f807b4ff939c070046b26ba8e6af5d423f893c1258643c0863cbeb7ac26450133a3364a99f8d9d1878b86fb10da4e7f62f47894c12bd0014efb3fac2f14c6f2c3c3050e79bdabf155de4bff32fc775cd4385ed210ba207a871d7b9393469d30b56966ee72c4bb7f26b8cfa6b795cbcec33f566a6f7ee2fd0285643788f8bfb94b31bc986d84c83d9c83485881da73f42f820effd53abdb3b0f5c6892161286879407ff893740974ba353b5550616686005b12239b59dfc8d962fc2bd228c176cd46a1d852323d5128dc108a13263d8c0133650530ed38227ccf03ac8a9ed9bb5e2936ccb87b3827ed7b2c04d9e106d54740ce5cccc776d298f9f3d7e8a1dfa0e75219df1f41841581b6b5c4942987fcd9961b527e594129adaa508df76d1f919118e8f6f62278d5ccec27072a173b93b18ef76ea180b0831962aab14eda1ae0d2781ee6e78595c09d9575846f7d28ca76d290f856d4150421460f5b6d57043d5fdd3754dc6699aebab901c42d30a9cf9716b6c8ee78b4733d1b2bc01ec250e7b5592d729a56d5b80b291635ad4442632b0f6c0c10a32b43be17676481a8066780d4f1bf6ed71a106736aeeeea53170d8a866b5c18f6479663d9e49d95357de55cc2d8c3cdf52dea8926926a128a123d28e7de5d01f4e4e42dbf6fed4f8feab86e5a4f2c70d3d5aab4461759e30465bd7e2457ce5800154c2b45d782160028fd1f7d9bffacc3bac19b0a231df83e70c124b2ea832e8970f0f3a499ee2044ebd91da49e5b392e5ed5d5fba08ac3d39bbbb6ac8451e858d15502342f8b501eab9343d78b5fb5f1c5146ff55dc6a59dde55e494595823d54a9c7c4c18f46995f041e42139aeb3240766480dd7d018cc14800d9a6e4917d3cc55486c32caa0c961fced064ecc9219cc6a685a275300a60b743efa8fad152f0af1e6facb5680d76170a9badac4f1641fae401d9e0c990b4263df75c6936eb4fee3cd61e97dd961e66d2b07c9d6b0533d84bcd73abd002826e7c3ed75f3bccd5635b23b2bd48958acf963700afda3576003cb2b206bb23ebb25ad3dee4c994aa829c85fe41b50e882f8fd30ec4abcb2303e0b3d7f20bcb32c4464eb04eba2412d31c0415c19e75245182c5a68298d8417da4c006c7a617d451654cc3c8fdab7a9a5d0d98264b547a027c5ce2c60d6daed6239f9c0514d777bc5747c6d6dc4d98633d83048cba306afd1c074d52741fc53bcff24199be2c1c30b14ca0c8ac49432d6ebff4419971dd276328bd84ff597d1d095591ae449418e95295d0d3e42f480fd21da03402cbd8db8aab3b0949a27e249ee49983ff797712099f73757b9612244422ddce1e2d713d2ccc200a41a0b0510a9aa4108e892de12944fa79ebeb61352dd736cd64d7277662aa9aea973104cda144f8c323d99ff66f09ee2cf785f07d692c7ab81dfda4c42f7b50e7a3767782acbc0e42be6e74187534817f201566264590e98e4f7bba7676c4204d939659b3992c6653b53b89eda83701a2ca340c73636e379201bdb93ece5d045491bbb6c0e39795c1eafa560252a1145a7b64a331aabd939c5cc5a595e3b1d8398d74534f870db3d366b62b3d14f6db2e577c6c7d31413e34173d8fd0588d760fcd8e9412262e6a91f4341f643f8a283549c8eb421387de11908169c828143ac8330621064d8f559dea31fcff50703188baefce704da552131b04d78f42ed7627c20a9fcadee5555a19ccf379f39919eb045627b57f333cd9fc115c1704f88893c1927c5e9c0169fde1f5387760096aa220ae46ee4ed0189e92f1a4ac70cadf19891d5540a8d39510443c16887cd82ccf0feae17844dc11e30c17d579abaa1317f70083446bb0230052a148e7ee19639069333f88a095d70b4f736f6d3519eb1ff1176fd62f4076d97ea45e05e91cf8dcad5ca35a5916dc6052ea60d23ac3a4e192cf7d66fd5de6929138a6958e24820da92cff6806f8125299a5657d5a64b320d741f0ad86acbd18b015a93d87613b142c1537031e1b9b8bb38fbb8843492e2eeb6eafc1bb1fe573763fd22cfeb7a798f8bd3e3af318cb90155663739fe9755c0a6de7fb50604eeddcbcb300c1779bb952b26e8281ab65f340cc564e4ea00d73956cc352c062d2a427a119f1fd8eb63a141eea505762c3e588493581998afa054c866d0ff2d95e3a2aa5fb5d6d9ce6c167ddfcbf30914d3efe7d2021f2dd516e75c5e86ec49ce5e16356740de77622587b81cd3fa1d6d90135005e1f0eb1f411604e963a9bbd6ce935d4997a658e5f0a25fb169e2b616af11e240a928b45550841206cadc562bf70ba2dc29ffbcc4cbbd3f5a95f59f0eb3172ee28b5be79088f9342cb2faf5ba9176db43faef4d8f2b83b9d85cc18f301eef761eabf05633818128f3ec7b33e5c73bc2fee8dbe3b2019bc69cc2f14db4f7391e4b27d5e12520d3d8d179586f684fe5cdfbd21204a440b0bbce892c801083030f7bf0da4d8114b1f3d9a7c3cea7c75e75efe72da978b6e139dc6477445d397469e754ff0390adba987a9223f1c7644895d89a5b79717e128132012bf5b7eb9dd99156c2c13ffe4056801747b48b367e9f738589bfa3f7d173f0b22f4910d3b4b19252919ac0dff141673319cd735fdc1ab3d6e20366c08bcd51e150e73d51bbff49c73d133cd0d687f21c9d747bed1730d60014111b7357d8e297218eb15062f60a1cb5c68c5637af251b47c86a0afc65fcacbad8fee8e3312bfede1a3efcd6edcf07e0a33cf5bf49dbb18bed490cf2a919cb719e26d9bd073c55cd94f9eb01f170193eac58b445aa1aa5002224ab58cb21567b1d790c355146c05ff7e1dced6c2bbc4a1387e9ada279168c445c9ddc1508525e96da7564c7283ad7e6a34a550052618066e3e7d9815f14e2a8c6c936c9f2ecaf0c5b25714d60c61d43c39c7f64a6be0f2cfc0736f55cfd97f338b3d3d3dbdf8f07bc79e83216244bf3759d5fdf858c2af4bd0507f58ad24e5d80e14ff8098f181de27d2e44b0e9fe8d64c20f166e1375e3d0697a5df453b0a8171e267c7d5a2ef6ad38389b5f790e36043b795019664f92d59e696a99cce0161d6a8974f2edeae8ce12a4556b67cd9ce0dd1726228e8b071228793f6fb52e11be7ac588729910abdf94af283565567cc055cc034d86ee90883cd4b24cb19e1a9d7123a8b2fd443593e7b823f52bd6d75f01fb73567b985861c8e7328ce509eb57efee8333ad91c094bf1b9281bedd8ce6f4904fb648a14812d4e5108ae32b0f5c706fecaf61bdce7da1b7e5e683d63e03d883231dbb98a1258a7ccbb6ecbaabea772eb14571a65e06655f0628b727db5cb6736a8b9450bfdf2089c260531dc4cd089d9c8c9f212b171903bf1eaa7169c95baecb7ed352c10afbf0931752b5b899af630c5ce00137d0b7dc74348e17db578675f093b528413c74fca078f41b448940a2be8b9e64fef2980d81bdd3dcc8287bd6e10119c479424e3493387ed0df65bd566548555a94379264f6a3a97b8992de0e8681b0ced732a87d73c342dae522174d9414f286c95466ef36a4894ec57ee684a8efba1fcdb2685f79e157e7f567a14d648f44b20fdab048723916d246ebd6d30ff8dce529bc6df6384ca1c37da49c4f2b6292f3816bc9d6b906cc47005565fc8250efd2f3d3a84ef673ca8f57036242f79a83615f253459eb03e2acf654e2d2088fa734fbac8ff511a70531029de50adcfd909b23678eab4e8cf41f73eb417bce177bf66959a6fb67f018c5b2662c37097ad40d296e1e1c7d0594b6b30f9aaf11e3e90c3d94d7318d8151b2ee3261843f8fac85fd162696b30ddf51a5ad10325373904c8724b932d624242be947053ae4990b8af4a46ee050feaa540bb9f44f796312a7aa055e898ce4ef9290f8c3859de73c673c6247d65240355203a188f34e8224f7b8a2746f153cb954517b3dd7dc636498a3011ab881b8bdbb098f77f060e9cb5a1aa6771a5fbb9f321f2873c23128c3e6dd15cc5ae8028c16a48dd7bd7767c70a53f8980adedc67e892f8576c5fc892a6e022022cec93f57cf69b61ccc65ea8c37cdf87b6e2036dee82ec270f68c47da720a4c60b73b2537cc27e111da4d90caceb8a08b2fc9cf55691ebc999a0eed1a29bdbb8ce1ed9ae5011b839b24c75773ac2b7aafcccd3608596684226ced1607e2131cb9af675bd90ac6782caa1c492b9eedaff4c51dfd30b430002fb4694b3f6ba53bf88806e626915424f35a670513153c30820da0f5666cdab4e75ed87930603e9a27dff66ba1cc195c73870c7ea7411c1d9d637cfb7b510189d2571ff52216fd4d28edf1a9bf81db1a46ecc8b43a633957fbe84528ecce3700f7a74842778548216252026a18a1a872b5209c4ae2b61b106d87e51dc083d4e85683dec2298c9f19507656463011257d4cc3d79f121b822e1a6f1dc3828368d74cd29879df979b0a756a7856557739f15685fb2222aa15c6944c054df823a81dbe319ffe1adf6d65111db9a8e9558b76568f5080515efb430c975415bbf6639596f5d27e6e11a5a5d0b99996a2a3749a0a6ca26b1106669bc2ea6fa8a91e736ee563f51b875d56b974d1d3a166d0165425d7f81b12ac7665d2e319a5a52bf53fd7a1ee32b4c227dcebc3f5936052dac829fdf81817cb14c4d5a82e6ec23bd395cc46a80775ead8fdcbf86c03a2b7b471e8f57c8484a4fceb12b5556578fcbbfd905bd096f00790bb23015a6016fad4c166fb19d6fe0a5814ef3e7b33af6119bbfb97eabb9ff08874c71bc004287a0911c454c832e5e56604a3b5b5890ed19e7457e21e9a2201945be8ee267c5680666d191920ed93759a121fd88831efb4daa39ae0b5f69108a0d7c089e6e2529ee6df8366c3d8e97d417d266d838223fb2faa9e4bd5a3552eab20d4b605fc17da9442a217f1140efb93093442b4a2c4576e2ef259951e345d43922bb9c3d08ce03a25dce8c622dccb0254ea41251880f50641f374f6339bc72b511b99d5d67dc5fcbe5831367033f51ab57aaa2e3a94f3c36396068555a8bfdda7d6f922071f04012d3f85b483b94c85ad175c79f4add5e440f0a4e2f4c4f9a74e6e9abb059bc1915f1f44d87440274ea1cc7ebe2aae4c0f1d744ccaa0902c0fc82a8b01bcd5a865156da4dea841982bb3ea2a70c318fb8af967a6cda465047cfd5dc477ee2b2055f5ba516dc491d5664eebab14b5e2c47a7b7d5273e5d9ae3d071cedf3aa3f9240e76e65c69e4f1248972aeb729ec0dc2989fcd715a12e2accca5fa9d7c76758b82a15a8342e457295ef7eeb0f31ebeee16f9732f74c32c05f0cc47d6051bc1052a62c81bb877f7dbfcae779dc8b8f5583491c4e06fe45645d4ca622092e59f2453edc2d7bb9b5f43b572b9b8fd4260c3b6ddeab1ddfe22ac0c14578b667cdb2565c71a9f43b8c341f5decd419c234fef44069de8dcedb8c446ab82ad36a14bce63331b0b2a57a5699d6164e9e53a60eee4411fbe0c961714a4047800da25d36d62453cf7b2fb53cc78ce3617dfb9d691f901726f35968ccccf79de51d9cebadb4bd235de9ebed967dae19843638cbec44592722ffe1c3f15c5c58c702714d470fb37cbc86fdbd37aefbfb9fce8511d95db3c609defaedf009ed0f8230c80fec4ea1229366176c55adcf58d385ca865e6210c1e1f0dc4bcf40ac9738d57e0c6b62bb26047ab1a522b91c2528679bb173b01646385cc6d2a6f9ccc362881a0762076410c5b17b39817ea2ac7fdecbced495dbdcc8b72a2af52cf6d54d4b673b1c0c3911432dd642a3dea4934587e8006e96a1dd1b16efaf36d24c4676b190a0cb2a9fbb00bb6f41b2666b64e3f7aa18904d84ed712113ac2834830be414f55842a189ee8dd0e8726d3362da0d264b5e68883c60eb6b029996b979bc830bb3cbae9100ded1d4604dcb661540421c0e9a88d0c062c9e2eb71418677d4cc5a95d04ee9cecad0710258d7b596d67798f7003cc040d894e6db789437b40f5a083d32ffc3fec93def402de9cb3f0e75672573b0cf8100d7bfc64fe72bab9ae9b3759f497451d9a167216bce8f8bd6c8f0929fbed85b7a3c1b23f53750d8127fdb21c7952812e5f3c7196fc8c94a8e81f2a7fd73355705d7353cc678b22081f3fb50b143b932244e27c744f13a5d0d0fd5359d85d36b74a7d13be20f8615370b54ec91c9ff285e46a3fc49d37b6f5d968d085e942f82d3223c606ef47f560b0332d2cd91d390253e7c6adae4951666dc6ee18c3c555914791cf22f55d7a31e380092a29304db87fef05135fed481ec2a96003ee4c3fa97afab5f585aff4c4870bdc20bb931435417cc3c63c79bf72e709d0b5b3e175102da5fcfad8e2db015b7403ba987f36963983f0adfedc79db88fe86c464115b954d39b9dff2be32054f984abe1d2f741964d0a43e262aa3f56df1815b97b557f690c113b59b0388749cf175ff341363ed834c541c68397af606863a31bace31015be99742298ce04cc6981f7c617cf80f16a9d0562749c6a2bf4f15b75627f464c00d0b9f205ca9f3e3da486f65bf08178b2ea269e9e642685e67f54392478eeb0fb5dd15c090688c3e3d75abf5095bec158c2ca54dfaf943497049978f6062bf3e5882844d15092a38a634761f5edcef08b854dbc642aab0e962b09bf8373f084f20af2c3a1409ef6013b4e348704e376acb23f940b0e904cafec6a9d0552048ca0b7ffa867075ad8627650346bc049151380984758b3a1ef3ec2df49af3f234d8c7a3501251451477b299e81b5b7a94e9e6ce7a09dda25d0e42b5245ee5900dcba96a32dbb1e36b7a3851f56b699ef8f9c9e275eb30dcd28f9bc4cc646376734efbb1c4b6d9aac53d61051744456909d3a4fd925e2747a7e09f24f9725fa2e077275ab4dccb28a213deefe2bb18e03654d217e62d09a887cd85dd28c695b460c33a58cc65b0fc227c41fc6aa7666496d02e72f989ed467ebc007a0376a89195f78fd0ceabab01a0a87657b18268f9fb7956bccb6b12718eae7404ef56d6522d8a7ab6ecaada9234d4b00e729ab3196c68f2e561e3159c1c4124bf29c11e16c4b287f85f9eb187d6b82c014c2dc9dd72efef608e69ee9f4df74452067e4baacb28977783739778cf31e3e2e25dde49db05fa1b1a1743941e511fcfabb6badf6ac5144a336b69d7c62d5b7b05bf69b1e1809f2baed9de88a085aed56cb23c1819ec4d2d4f30fc65753685bf2919bb3261522c489cf27f0c6d0fd9402ebfd58c03d19540d7dad0e79458041497fe56c1063669ae79562b39531dbe0948347e5cabc236dec4fac9ae95ffeecfda25625162d6e110b3eb78386fe1e705b76215580f542955136027d59e9915140c3b5da63536b109598e8220a81ddcda6e6a722846d564f9534aad806b5652359417ff502b9c92aab27eb617d07c454b186804b600f1f718f75f56a5f1656cafe86f98817894a434b7c7b5501f6b3bb078bd447fcca716b0347e269cb1a08b2074b9c075d5d4951cf35bd2ed80197bd003a316eef57953b2160aa3003bb08147b79736ce30ba93dc35ab8065001a28b6c0863b582b733a5ae901aa63b13d66b252fe055895256ef62a5641dc20d2ba7ffbc62a9940aa9efe3e75138fa2b7dcc48fb7f33ceccc71093916308f82dfabe63d6f9c5d4b42c05816f428c3e6a8c97be197a77318380b7cdee50b4b306e1bb51ba78d8eafa50733929150f45e38a873f83ea9e9f03c01634992d861d48431ee77726d77455550fcbc763b62022223f51e998f0114a1d4bebafc1070d44bcdc4e2d0fcb27f91e1eee2d9596572679be76167c8cf158205e57477134ae70626099d7e408f7b7598e2dbd49f4b7191851856e68c956c54fc6d94f21fa3e915370acc3874d74afd9d58563a75bdd01ddb56cb94f85e4ccaaa0e3018f578f53c6d5bfe7cc880ab8e41ec3a599aa47bc9f88d086e747ae497e5184558b4b1032ffa2255328a80896254595bf2a62894cbf8575cf70010f0bad28e0c8ca481488370d34c41eac0e40913f012d87821eb542694b51806574befdb43f7f959359d94ca993be927e320cf4b0155de7e8efdc008e467d6fbfcbe7f0cf3f78cadd86a53357e650123e69ef75a81918aeed111ffd9abd778097eaf384aefef592f2e67a7e5e7aec537f48fbada0c50d15320a430ce884cbc21659c78387464ca74502fb2540bffe794b559df0dcbaafec31a0de8c3d0ea2821b325506905b03f8c84a7b3945fcd01a40e3615d7bb94d62e117fe83aa9b84ca90510d3f4854ecb41c19b82b6ce69cd86349409e2c2a6a68da39c1b6c628dda29ed49c5cf4dedc9b49066c4b386978f792eb500c168a1a633ec43d6615da21e0509dfe2db6f6a095dcd01d5d976627857b3d9d7ce6756ab54244e2ab7301c9f946dffe849cbdcf5adf5ab03e6ecc598cb13f27cf016b8d7195f31c1165bcb7ac997b4405be13392becabe0229f323ce485988a5a11f1a80b78f5264687fa942e88fe36eb5cd0f49208f7aeec92b980815f13b61d0e7fa5ecead88f55e8602cdb830bdf06213f9b5a4a992e0cdab6869df7494acd582ac4c17eda14eb53426534211d745d9e26aa8e98d4ff8e56ecbea40ccc92b1a3a67e0a67fe2753cbd149a5ca2ba281bce1f25344db1dd3b71d60ac46a55af111e56bf2eb22a4ecfbdd332918f4ea4c76c3b919ff27bba80579b92cbd06b896751b35054fe622ac7a6d4b89847ca2f8ecd8a3fbbe5d25faeaa46d98a293a2ad71e30066984d0a3f82986ed2fb5cd12845e60b2b8ba6e4bc279af1dba4a1c40536e5cfd719ddff961ef41985c22d9942a9978a9d7544a25fad301dc4d449dd1d113ac36540c203bc7cd0f4c0061c2293a8700a4cf7e628102afcf91bca82610a9ea2225ae273581adb0ea88841d936e7059a7422ac9ae4cbfd4ff458cf1647cdddd7361b4a6710b1f25a34ce90e748a5d3dbddc57d46184585d6a749e9c38465d20f517e2e76f09f4c89e3009c3adf8bdaa1023f1688fe4fa1f9fc33147641dc8217665215207364c57cc747f1c9f4e7174986b2b02285a92cc10f564f4098ee5a3376b60f5658ddfc22887b5bf19337ca55c07f7983e00b2166f88c9a5a9fb4c7f418c08530d2e73cd0a82e6fddf79c7d2fe2d1fb4d2b75c639a8159638ff7cadbfc6d182aa8ff77ef3dbeeb76b4cb8f0e1567e3bb5f27d78dbe8866a5e9dcdba1a7e1a7013d58f052015502ea50c9f1040b91b764a1afd446a422f74896d1ced00cfa9414eb5f72a744eeed9ff3f193edded1937c01178653c4de81874f83fa30224bad3c14065b901763d32c7bab089eae788192f1f15f0092ff82c5b868e3d6477e4e14f0b07a823d3547bb08eb7ef56431001d5763df3c5502abcf49668adedd28e0df9199dac76ac32948a16d4adcafb951ff826148247d0d2797327b82d66d2c0438dc5c4eb9892f7236f89682a903a7a268eb0694029e52ef15ca96e3eb66092b680fc046dd17b2c3239c7f8187d61124eec42eed390fa64dddc01e7ad4fad10e0e2a923e6ec6bb0a985b2408f8cad56f06a9b4cb3c897899ea7cd8e4dccea4fe5da331311e53f46f2773eb8cf0e181204604e0aeb51fe20ddd9803d43527e986d1a992e119808018ce947469d7846f0affcce7c34ef4c2964d8e3e5132a867e7307c1e9141a9f4912b083fb5a24499809c9d360155dc584d993ecb67269ab4327f63e2014ee9996c6c33f3e14c97db9dfb2a25938ec40ddce3dadb41acc0ea63aa1732185535dc86ad209c17a24003ffe548e51e9c4fb40242ac237819c923823c6ad0640e6c1c858f1bbc16bb4f5bccc12c97aafa449de180b39ff0a5ff8d9f9c5957a8cf01f8363d04f35770cedee60d8374b00cb4ab3c963d60fdfd60a69358ed47f351343eae4dbad7f17747d015351e71b2b482187b1a836f4c4cd0d66306b304cb0f7c6c90a6fa8486b57c6126ceaf322e4d33be3a0fbee80cfc8189f08c2593569028c252b9a7337c2a2c2e8820e8e332adaa1a5d91f6d55e2d2e7426e9f5c1a967e1667cc08aa42f6a0926a8176343f0351850de4300aee710dc2d75f5231621278693528301bdfda9d732edc265aca4fcfa8895177e644628afb81ba58926b00f3dd2a0350c3e45a58953375013a78c3f1d717074f4c1d76bcb280a0c7d9e9d23faacc4502ed12760dc01f1c47017b22427febf373403b30055324d62f2ef738075d5431ded6f87b96fadb41df69462b3de2f61751f40156190e26c4546cf355d9c2a1d5a4f5d0c94fab73929d0e0c99114cbc90d69201c9ac3e89206d7ce7c67f6549fed0e923469a38c40697b12f2a0d2b99f9d7bee6a1a69f131e52967e212a1aa7ae1627e5b75bd581a7e68dda294f3cbf4f2964d941e051e7761d4aaf699a01d1712f42f56d70c6c928e2b14ab76b29ffc863b07fbbaf34bad064bcb04f2e46da7234918e7b8f03bb64ed095431e88abe49d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
