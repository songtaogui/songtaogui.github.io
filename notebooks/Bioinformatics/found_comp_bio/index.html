<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a12983a25fedaca1f90237c661d0587361f2535c4dbab8ba9b650020039e214b3ff522db83d9161fc28bf489bd9dedf36e259f4c56bc209db316e6975d3834cab165eefbe143707b7155b300f564f25127ad25f6eb164586eee6343ab9bbdebd38646f2d8ce83bc8d5997119f5237b13ce0fe5c35e308063b5fde09bfdedd1507f9ff654296c515d17c43a5cc1b7d0bfcd9d964073ecbfdacbde348b5aa0f5ef83bc4850079a76aa715a01cf0a1fa7f306328079a22b31f086c70940043f472a699fd28faf9b79822c1a7b7c1f7a549467e301c36bb875780e172c9cedab8431a2fe312e9618c6547ec6223eb039b65a351b40b3c6950320d71d6802f04ea2badcfbed86df0a6fcd1dc5352926233678d93fdd2a7bc5465d9c7b53119632252d558b36e4e50b9eeaa08f89443375b80da15c6b1f4ca83e2cd70904607769c3f89e490a57a803a8e9afc12277923bb6f82b979c11abff962094c5dfb74570ddfbad2d0c053bdf98bc2573f7db81b97f246042c4be489cbd89c2251dcaa3fe539fbf3f8b9db38405c1760777b8181b73dabaf24f3a98e323de1c6e6555153007e8639e8cb0627352dffca9a1265cc759fdb5fff2b49336a644d266684ff01809a7c4f358adf2c0a708f572da76f0bffa677839023b3a0d7e36a17fe262549a428a797f89c5960db44e16c3ff6c2f513339db9d11daf9e90899eead6bc40c4c0f4ff2d2f14d615e5fa01ebb2b4a045b35d33b0972c9739c6493c0af68d02de619058c679e9d522e16c4ee2d549cfebb228663caa4011d528d45ae6d647f54d0208fe2515cecd1646255c4111cc2e03dfcb865356705ac1cae60473bde0e3d0c4d8ef14075c4131b2fa3357686cf666ad85e4b26f88375cd607fe55dcca49be4b134b13de86ca929cb16bde8211f00690b721f1ac327b67d4b573b9a64b8f888df0482c7cdf2619a23a1ae7710d67eb459ad7306de7cf05fdbb759dc305cdfa215e5a2dc2dec993788a73d08fd5702a76715adc24b0672edfbcfbf5705890376726b9ad93190d4562d1d2f5c081db46c40e8fb3a69bc102c31aa95840823c4aa4421ff0fccc965408be256bde80e239b14d32a144d93d9862a32a91c85593f9933fa7917033acdcd7e8a30a80afc4e48ff5901903e27676a6578611d1a49b47faa08354da96892fa39ee747ad714f70a2621c9306aa0ca6b4d457f70ea9f54856b37d60fe1c015039651bc8048ca3a428228f0b2eacf77034e04d47d570d1984979b267436bfce5230e3ce0b04dbf17bc5397792b635378599f96d8a9d4741a667e284bca0ca4c29cd732f804fb236d14e85ddabb533d8733b00ede65b995d1c1ced29f5c99603aee6504e048b08691421cc387328adb6dac98f885aecd1e1beb5b6ef531f0d7bcf6311201e20551a5ad80d27b763d79a3df7aead2993f8728c2330aedad1ecb8b2fa532abd9f7356888c6c16e2f4ceb80f54fffd6f08855a4a0a22c0203cf8b876309ea064ecc9598417688b923b6f4605b5d6c927eb4d3966a4c2ce00ba29cec32d2acc18d1a148b880a4b5b95fc4b962cd7da5060f9f73e1f58fdbb2bf032421b0b16caf469a1b72ea524382125a8deae0067518a4ac64cbc815d4ba1e3bdecd1f6aab6e940d8abb7a8b3f377e3c70dd12336c352204601aa8bdd2253d1c9079d1b9c57c7189206b3ff201d537b3013f5ce837c00158b93ecda34ce8d3887123d2e48aa2bfc378e7faf2b8ecf9fabb7078a02fe174bd910be761bbbd69595729d35175fefb3e70acdc9a2b1bd49663d39d24b36b0f238f2f8bd31062774bb2ee20d80b68930af0b2c032d492c5c78221111926da98305036604b6067d3f8e908dc6ba287c1c0ebb5d43509c743f58f3e24491c59f0cdc36660f7c2915b93a84d59d01e157340646efcab05ef5e07e67be4c41b204183e6dcc3fd9e1a4fb35fd400177589433ba371716059e8ba7ea9c4929be380197f122fb3abf36db096b65e722a35e8d9e8e22d8e9f09a11538f66753401b2b4638378b675494f223d8a52156442fa600c1551cae294e86539d785b83cf7a441db1b39b8c690874ca8c80b516fcc2dd8e036a1b330c4fb280d683d2e0c87e2ee020e8d03e8f07b2b0cf70faedffddaff070a56187b75219f4640f6ede2800c0cfc272aa1e6b8f40573522b951e2a00ac002de1318036db56bd62dacb666f2b0056459f511ee54bd46d1ec4fed330f90f2bf17ed4cd554fc888375a6eadcff4cce05ca651ecb04280798784f44a4799581ad1d77ad06881718e96c3cd00ddd71d04a1e17abb1109a2510f75e10fd3806a02655cbdc1037a4beac1d90eab317960577412944d09a4a04189aff3960028ce7c96e1ed74d0a5892907aabbc1f935f042125f272ed9ef5343c9929b5bff8ee4b1dd952aaeb5faa6e01a869182b34ebdd3a894529d991be3d3c8496c8e9de75ddcfa8b570bdc8a234764a23e7fe97a2565591306f42be48c3ecd39f6175cedc64a121b1a030a48f063f5b9a61fc13cc6a9e7948577837b8fb72026ea862d4439c6a50836cfc2cf9054a5e5384cf4bffdcf67b7ff9b685186b7b47787a478198cbdbded2a916533b395d8dbbd50135b9dd052ebbeeaad6f4636d6fb0437d16ee10e0489e7e2185e42b8735c327dfdb5ef379d81db6f58372369afbddfa80974f3746672593ccb15fc74c1d0dd87e763ea4fe79bda5604b3a73e16c36eefeff91131eabf5f4c5736e652282ba76cb85bb2c26c2193fbdf93d328e49a5ebd2e6f7f341369546b30cbbc36890ab24da22db32bc022a3d18744d44b1bc715fb5340ca52bb948a3b08680ed14d02c1236c2294cde2a93c0a300f337df27cd4fff572a24939ebc741e6c8b84cd7a6a3d0b431ab30d7f8e4661cfc34e38bab4f2a49875879614d5d177dcd3b2162f74add308c11323879b033263fe0dd4eb97eb90d31eaddd575da67808d7d1813b7f432db58d65086b31db022cefbe23ebc7890228a34bd828d379fd3e3681e0e931da70a043e47f7e5b1ded65625f072076cbb99af0cc166ec7a3c9d571810bccac6eda8e1a5af4766808fb35414b337f8f822d9f2ba74294fd8f7c63f39a0ece9ddd424deae69db2bdeaae13e4ca443ebda7de81053cdcf4dbe378d569aa9f294e63bc383c87b355d56cbe3376f599738536c56f8af30be05991c291e624d10cc484077a7842fc9ea38c3cff8fd365167cf101cbabeca0a1e76cb7069d2dd5f30e3e7b92938c6ad2c8ef5cc8d783b187b1934f724f6b18d5876304d0fde38c4aa4f6062d9328e09df7b1cf8fb8bfa02ca871361a308d8f21a20bb4f1983b67b5ff4f2ea84a9cec19dd02656f2461dc51778f2cf182faacf0bd421aa1aa363f460d025760e00b0b3d68f1145c4beeb31025b5a6414766ea7e4f89fe46c7a6d67e2547c713fd211f609b4f006e19ea1fe35e435699c8f1e4522c39b86897cd6fdc3d7f6f0832b57d6cdd40f554528e4e0eecb8ab979fb578cb81f92e9dfbbd4ee40387cacb377d7a26ab3d8fabd13ca407e083f3aa7ef1b5b481113d0f9f05ed758a533a9413067b7f1f9d96e88e683478a6e10b67b488c3b62ff001365440ac4dac640b266a93004518527623b96fef38f8213488e8702c8990a4ee0b08505648db0d5ebb89ab1b5cabf2ffa7b8fb8720d6792b7ede8456ee99d1e5432a3ab5c03744ee7b265cf141fdcb98dc39f2fd3cc3aa8245066e69ab7f19fad2428f910f0b85acd4c43ebfa810f731cbdc527bd51128ffac08735f9ab09663bef18c2ca85df32e0d23dde96a4726d8ac67b93ccba10c64b7bd3903b01751f5e47866bba7391cb7d01450e1ca530219bd8488c92ce4053721282d9be18d515f28b487c4a2a80a36f3ccb867e1941c1a26c73f0f61300dd202746979e3e9d7010f890a55107d546ffd0da6966ae54b6a2fe5b6bd3c50dbe186279e257e896aa11091ec7ec1c1548d0ec65751f98837dbb98f3b5ace3bcb5edc887669f0a6eab2989e0c66987bdea51abd974e294c4aa3601974254b1817f0fb736181868dda8885e1254434ab0fbbd7c4b8c8db75045d31e8ea93677d3774024face766cee4abdd5f1900e85183eda674d25db6ecc20b6d9a954c0b22ea20a8b817d393caa1507cd101542d0c395465f3881d64186544c121cd3415724b630c83992e6e16511664a937ec971fdeb7d9532fbf87cf7691cce5e973d5f224e65ab6842eaa84655e8ae750ec532097cdfe7ee4f4c8d73aac4fd52e1bf841b74e7309516cc5e47b7f417c1e3aa1b120d0aefb47a433d0ac1b7b7695112b44644361241240a87a2076b20479f9555818309cd949d3f1151ef9a89f22c71f24c3315fccc4ae8c1c4cd84de2ca5b03ffe44d0e463cecb041e9ef28ce66023110ba3afa6ab21219fa98b38f1e300695c3deb6db37a146f0bba4450687d20b757d7b8bc85603181b38fa2c0937ddcc9d59bcef3162a2bb55d732188f34631bc1f705d94553b31963d9c4b63186e91c0a956259c7bad48058d77f2f40bdf6a66412f9635162334ada087d73432439a364a9fc9b59f6a38dd42af8a8af0a9aa2460e9f9a605ad85b2eb20185f1b0b295d710d44945ad4b5bcd286382cb120455156ef506d43fb121a6a721b47406d90be5b9cd55feba0e24358d36b118b28106818e1456f1feb3a844e5c6c929ee584e185182803a7b21fb56e546178245067f0b734af86a229802efdfb2987d4e8dce4767354ccdbc4ac5a834c500bc0f1fe81c69e72f0a1f38adbaad25039850697ba6125668942d4a602003c94f1888887f7c10289d5738a9716cb09564c5413211db6411fe48262c0c390b0b677912f84f7e682b8ce1dd11d1191152af1de179901a1661300873d5ae8edc12252c724ace68ef2d2415f26f866b18651d8a40cd67d30ec7e83cc156ba4df7aabc0b727b03f5aca9544070eac8b755068a7c2c055d13d8daa2b672a74d323ac7d9cfbe0f902f3c4b53cdf3fd1f1cd08698e978b3eb330e6cffe88c1106de3beb8dbb4f10b4f884f48d36d07916fab989c173a74fce8d1943f82ed86a414520af508f73481516624a0967c2e6578cf7a7a05957c3d4dfbfaa1977c37804bfd3a271dd390194641d9d95de807e17446f543c9891729387995e9de9f7da41592d8116ef397d885b3d561acd007e06bcaa8bdc7b983442db5194fcd9bbb9b7103bdac7546285be3dfabbe671d1ca459a78ec885611edf03ae319b9246a14e72085e526e462500ae44c8f332bd66ee51e56dc813f281220d95e0909b04ea00fb12f86c32a7f522dca45f1e17020e7ac93903e14b6f8c5f7e79e5bac1ff05353b991e7a7536acd9ec0bfe769e9d45db4066e1ac34f5fa59817586a1e21fd53e151e8a35a910877ec5e915a072b0ecdc4c71cb3be8e602aaacf23b67f8178ad98b73a6ce8c9a57d153c1460835ba31f3a5620a476a0e940cf49049a9fa21f7a50ba345744cdb2eb540b190a66dca7c8f4f131eacacd534b36b71fb4be3451f2959ddf2e3bbd12089fb9714b6c12dfdeebb28248574200b728c0f5e7d30be0b002656879b8a9223777a8248d88cda0e3e34388771a2740fa439dd0111cfca464222b70a4de626c8957bcd6a8d18a6fad74847a286ea3070f02729309ba43f58be0529be83a6c20a814efcacc1d2cca71e7bcbec82e4979e19c6006a171bb0d8a85261d9d9f487984681075f6f2f2692dc34fc92d4a8bfe5dc612441eea2a04b68151ea24ba310909ce985c95a6df9b522bdf7c751701a4696a55e8706f7f4a77fdb77d43a9a48424372f8ab87bcae795881683c1b2bf0c91700d5cb907de106c9fbf58d8b4acf5991d0641cdbd8933c8dcdeec83b48d3c53aeb18433a80cbd4d2cb631aef6aa46daebcc85825eb1f677c4b713a58e6b66aa6242d89a7f794966f1c3cdec76047659d5e890e6e9c23dbfaa119ba9ac1896aca170f3dc6617ed72e055dc69ebb87de05ad5803dc07dcc7c43bffa306cf6eec6abe4c0fb3baf4a85b0b43735a438f6a678b8a0b2c2b7ad02493d496e6a142687a082ed6a8de9d8c95a5474ffc3eec7bce5665fbd9b953c37f33b07a3ece11bf25a8afa96c562a471a3a030a6db34d390a01f4738cf7bac5ff6f5ff16a8232fc0383f06514646f5c9bca55ee47b7d6c24cb4049345daeb3a86e136ccc51a0dfd83559e2f955d11f91d3041ab61cfc0ab990dd775cfec5499c64965aaf177cd36ec606a774a3fcd1b57f667d7ece8da03aa7c95f2e46a8b59180a3cc08af11cbd6791c45a36c4948b42594856edcc275d8fd4ea8cd9aff99d40db501ffacc4eaa77f2ff90479f198de99b23301974a70fdfc529fe5eac43e44491ae0abc6d722e34eaf25cd2fb516e39ff02c0552e65ac0682e464b6d193cdb65398295d07ad8280b16f3fca7cbb711b6c074bc4c83dd3ba259efd52774a309b1ecdd2802a5fac3953e82f66d9bbf6b3a77a9f4bf746c219e0e75c23d3b8df75086538033835b985192723195b1be628562038faeeec42f948b6df5e927a5bd9ed2c67138541a73aa63c39877d9c7cc460447bcaa5acf9185d2bbd35683482824ee5c1a13036e6484f88c2bc84e9bf0dec1b211027b82f978848b344c443cced101758cf1bbe5da60ae00a95caf234afdd627743c16687e1c87091c8ae7da1d3d367152e4a7147afa2a153754c2f3cf9cebd213a30878bce72b32a66a970ae8616c71b86209cbb481fe967fa6c36310c8c9f0003a6ed4ea9aa682c597c59318520527f18326b28a1f76e08f41924b161175c0655d59475c6d277c8f724fada295405398c5a511b8f3d9b0241da830d29863ed1b8e7576e04e31afb0cbcbba42b8c1349e5d42d17f4bed855079bcfcbba0fd6507fd68f44fad5c503fbc4dbe9a7399f212f5705d52bd3807f1146bb605733cd09176c0538d27380c4d7366d1c999d6895467fbb07bb8dd928b1f745b52f8e185dd0923331782a909ecb1617046f4e5e0a323feb7b3b185401161ddb923dc1248d42ed1316c513cc235c58455bae630249dec0f248d55bd591a374725d25a1f65221d517597a3fa0f3a048705a0e6f8a3842f2a32aa8b65ec11cde482aadaf0230133d8307a81bf4746de6d99ed9bb00102f6cbaef510762d6d6e053ead98a51d6c8c2840e30e218b5305d079e63cfe5c221c25bd7cfffe9e8373a734ef80d95d0afe0308ac58784cec497dca302139481951487b8714a5a0f66301a28e6e45d15bd8e94dccb4513d78ff20bea4963aabb620b2b5f85f0f5b44d580c1f81c2b02bac198dedf764f5eb256d7df5e690301b0d68bfd83395735cf7007b8df87f81c5ddd905d08c5c4f16f300d495c6ba9bc42045cf8bf3340d6c3faed43146c479c2f5b04385e8a4955061ec2831a0c87836865240d7739fe410043a278d4585663bf2178d97805ddd3c3cef094f290a278a133be911893a8e73bd6e63b4d84dacff2b47856aad2679c7d582d7ec640b8a66dd1aac32668a6d2bb9008b1352f03366a6ada39844f088a90ac89df286c0438feb175c21ac964928effbca7d8afc692fbd4516fa60336974e2d76abfb534bc99821b7833177876394ac9f01922d613c2f133d1fea6e3dfedf2611547fb3af5f94a2a5a4fa66a29e50b0c672587221bc6ba1621e9caf5d50e779ebc52a63aaaabbe2e1f8a0aee60042a89fa517a5a876c18165bbd6c294d76be2e34f90646981b42b7d58b4c3fa25d02d3a13d70fef8ece668aa6333de593cc3fa06133f991afc274a5b3aa4c4d3b2c82154e57d411f69ae7e734ed7ba8614d18c1b5ce7102d31ce82a7bffbc24f061548dec6cdd1704d667f259767c52f3b3340b0950139461fcf27b102e9e4835f04bf36f8484d5d44c48430d55c417ad9fbeef93e0a0aa7b2ec75fc559d14a1f628d6f3c5856073d8bfe56ac1afab8cb7298dbcd7c8493a8af32dadea5b2d29c114ed87b99b2964a6b746476a37c3e7e16d04c86429e49f1ff23c56f7b7c3597cba13df76136e2a58627f3cec8420535c883cbc29dd6b1c8e641f1b054ddefba458c11d0b639d66a3e486747262f16d75bd99bd360c7b9ea58e8b683b193735610b49186a07c463d2c5780ca59b7a91560fd40d596b7ec84d123d52ac6fad6ffac37451042fcf48c0479cecafca4c8fa4d306d498a9620f312fed2d6067260ca720570b0eb6238dcb2760a43b9d120dd0f48d9d41c1f5598e14a9b17897e58358ae1f6be2c837e01963f9056d180ee532b64f7c15f820d4b44ce8e330940c05f1fcc9a951eb1cd6fc724c713138ab1c15f07d541650bec9e41abcee2f584db3e2ffe7a06ad0e8b3e3cbc4bb2c3e4723ceceffd04dc48f0eb225f3168e2e778a96782c922de0cc26abf1ee3ff9cea09dda0048b502a3a92c55cdb0c826bd2c9bca497e5d6701937a39d59293f283b1127f150cac72833e6b99a6bcdcbae1268814c5563ba67aa728d6df61c6bf56177e061dcb4f14f3ce56c7fa57202e962e59460ae53a827327078b23a5e7848e7c54c03e99367d498121001b20efb2b510828044ffbe7f7c99433e41eb283ffdfc4db4af18e9075b6d6d0ba6e8141ba0fb5e75025f448102b6e1ebe98b5e7e5d13ed4ebc0cd269ff503e34ab1feb8a90f1aca15303e4e24cb8d3293bfe4afcfad56637248ca7fe19cccbc7f30f9cdc8c6899bf76e3a646db94bb26156cbb456c335a079baa30bd08bf015b0e76f48bed61756c60d608af5b57d4f4c4706669a3d6fddf5697e54a8bd29c7b1a8bc9d19da23e740510bc6416331943b2088fc1ba61b45708b692eb79fa0576a84daa6516f0665768bfa13e372c192f9ea4de2c731a81afbcaf081d94d835b1153b66813e860406c7180d387af0ffcbfd21748e3e34322e1eeb59b139afc4b0df5ae09e0aa1a9fc4cc1f9960f84ba0a1e368e971d70ce8dcd61804ab905c78d55b2b2ff0e22141754adbeb0818c9f6843a8459f017a489e121570fbdfac8e360ac7e7349c13143113a258af233d4dbc92d502948dc9ff07ff5d02270f6edd4462c5b7d6a804d78b045a9f04a91215878e3dff15bbe604939e59072c7247b23c98a85c2efe9c141a6d80c86e301b9001dab3d4017516e8b28526467bd55df511057fddbde480e02bc627015663b64b4f0af9bf90ba10ce75da28e3e4362a3323e16230ddccf4511310261b15b0cf3ed7b205e20a99ab6b0e223e97324415897857393ad11058ca9b89dd0579443d4c98a8642a33a216e0686189e0446db68f4a4fff04f1ee821f9d599d4fb2fd364608b39d2c30fffebe4b4f697f4147483d21d1b76e02c5ea41fd1bdd7529b7f788e4fdb051db00e3d0268b5b386a7c79bb6afd08a0f854fbb0153e7c0d3a28cb1781a6852c50b69554ad203573eaa8a5f0f1aa7d8c52a49be056285a380dbcf7ffca316198103353ca6f2ac30ba6428a4a25e285d4937e9a89d97ff5211f37af5cb9f8316ba9d3e968ed0954b008d8e16b742e4c381d5e57f9d72b026b5fb690513bcd310686a5678130a1e9af32035a21475ad26222d55f232da4b9b3d7b8f228851495f3fd5068e85cf18b46b0521bf94ed729dbeff74b92d50abe5ae6c4ee75a90d3241632602dce2b92c03509180f3e74c9986d16f15f188393faefabc3b892918c6cb873875219452b1984554a1908978f23397da4224a872beeb3f8d1dabb8dbdab4188fb43d406bd4091b9088e4e1ed24a778778ea5729a5f12925810bf47d79150239b361727129298d72c2ca66d238743c6eb62d2cf031ffbc2d5e8c74c88132d28885d9cc3b7bd48b6334699499ad5f1585427b6b82306a55c321feb7017dc2114735f7a35afc8685e90c7f9a92567933a03e9fb1c0eab4b38dd387b9c6e0ee2cb49f53beefd2bd96fe02091af99a2a0660f7dd6f80bed23460bb104fdfbfe01336513ac067f2ac115c51dbf9d4839e02681de94ff34faf6a5088d3952749a0acf941ab031548d2db8e3f3aeb3e6ee7b4da9428136c48dd29a5daaaf26b4753751934273c3b2d53f2d7684cf6a07bf1ccde6e1bd39d2e517930ee7d551df46a510c322a4b8dde2aa5b079ffab7a26fdbe5e02a6c4a2a0d4ee0d6c1786b2d34588d0534126954174cf95dc69898cc53d1c66595705bd9b972b2c6dc375e77e61edeec1713947c332e0f1a87236f6d27094b206c8106ed9da02433406e3f380bb39f3882cfadde71daf185f6caf82cd2f60844af0a26b0c7622f2879f4ccc679fcc42c0390fd322966bdfae9056b9ab292ee9a65c3c4dce13baab53fdb7bf889bd39a492492cbdaa24cc71b79a3f30dc2666ae4ef30038ba5bd3c30911621c6f270a90a3338501affd9bbf72587eef08116eb824170713f80c5402982ba89a0f6d068600e3731a191094508a47aacc54b47e0f847c400f276c47acabe6069b978c3584fe2c050de52df99aefe7b8ae8248c6dcd94080188f4f8529346edf9794622e765d07694b4c98084908c8d6dc0584628382686b06510f10277d432ba25b9d2d51721a62290fc99b253d9d0df98c7ba72959f318be8b7eb992ef4f43bb8d5e3274ea30d9fd1c2432529f1100f050061b987cb5c10b06bcc3db8b645204d3c598d3ed12dcb74f884259b954043e6fb615cf8d9e4960ebb1f6787d2245406a504dd7d6f2b6263d3378c8a2ec0ffdda3cf86c00035c8864ad5656aa45f83ed753f6f4c6aa78b30f98c64bb3f5293d80c51529562b86b930576d7894581dfba818eb7175ebb075e16743955b16a3c3f38abc08a99e1043d803fe34f61f325f66244f1ee69825279ce2177bc36a1ed07b80babc25a6f022b4b8084177d3aab7bb027e6b33a01225b24b7abb99892e477e2e721313d0589c3b1b9e238866286c372612fe0deaeedd1e3c78760b79b4ddae7796767999583d30791a6872509ee68ae526a13b04a7d3b2b5e31a5d317981690959a539fb2a3f77bbb9487b0896b5fa31ad565f0a5f4dd5f651e94d2f1fb88011e86701155759f524af40c529c0097907bb5d6c013b488f537411edbcb528bd4159658392b864ce4ca8fa2aa7bdf44e870785218094b3512f05a8abee953ed52dac5669d9204347e0bae091ddd84a51360e399a9a6c1f824e17aa689498bc9314d7fa68ac8d72f06bf2c64bf47f90eed6d14321e05dc37b15f49c2389c88a7ed2da6c5a96e286be81e28667e02dd1841e6851c9cc11699b4d10a6007c74cb0704105bc7a465c7c2235ce100ad94eb7f3290cf91b3f3ffbbdd25208325e726900ac85482ccaeab3d117a24d6051ad0a2d9f864ab61914ef16895ac0a1ba7c16463412e84fda9534c3492e3cc144392776e1acf6bb3aa00dc7c77d96ec2712185304e6f2831555ca78ba23684d0d89b04e0d4aa620d6cc1548aa5130a2c2d74a5cc41f315a88a58a1d9d4bdbe97526c855df3ed104910f56200fbe820bb96b8d835aa9f53b950f6c23ae66842842da3a44a4e036def168fbf540c2e6566fcb24ea0fc11df5383ff54c39a0be3348e3f70810629ad73a2952762dd521f460cb61f952ab00f864fe2d8eacc3924c9a3d01b440437eafbc4cae313002cebc7e215f44969e7ddeb79ce081486bfcb5f7f6a64fc1450c059f7d94f6d2fd219b1339d62aabc9648430de11f6884bc813e324b8d58e90379044826011bf984802775459c75635b334f34e222730675aba2e57fccbd873eacbf52f63c478d99333ffec27bc7f158f08aa274f22006a74448b3988e28392d62e800557d4fc08b6dbaa606ab670cbbced4bb2f66b1572c58ab7c579c30803e41e4c921553434ad9b3f27215a43d8c3af7cd414fb65031936e72a4fc134902f767ea01bc4d99ca925f5d26b7c159f9341f3fc6e102f4ebcb79c1ff7115050db4f99e8e7bc5647337af3ca3f8ba6da70eea651d8531a4159bc95061d1f707d65a7a1f12619f5e177ac380676fa63125908ada062c2e973f307253c7029a851fd4098ca36b69baba9240bf045d0911729fbf8dee5ef542295debf8e5bf433b1c7232ccd301d9783d74206dc906487e2185df6003d73b134cb62fb1520bc8c7dc017ae6d3b132f43e8b840561daec9e957bcf2c06e2a096ef321007b798d8216870e436921d35021601f08f8fba8fb26dd5911950f4459aa604c122ef6a7b5d2158af669fa815b070d84724c535c38e33c2b094a07a647317a1da40f0a6b24db94ea008014afd2c9341c7a5f698b0298d34614088f953417c9168671ac94f02a5d07cb7aeefdf8527be115eb5917b539e7ef7196244b326cf56437020a4e65b810ee093b6627219de5317282f5223b37542dd553cb8201ea2267a55205cb1ade08161fa9f7a8bbdc1a02fa7be6d17ffc6dfe7fd493dd806867c26f65fa797dd8b90b8ecb730d41d06ee38d51e818172592cd9610bd30c24edacc0a8f4c11d2b2a46d4dd32d9dd44c305f463ee33514ea1b755a56cc3da87c79f1325fcb82155406279701da634e5b8c5f6a92f31d3a9a8f75ce6b7b540af8aef16f73633e5e9adcf4dc0b9d0d5d0ad6785b96a0934780bef92d4e0fdbf112f647132b9a39f8029005cbaa116b671adc81845abf162d0f566a9ea1544c12feb300b34029574a350158adb9c21d167b95600badd7fa1aa37e1db1cf4cdee4c0c453ce088c51718ef11765995c5053734d47446c9c59848ebd42c5080b539a41ce289df2718f754095820a49027d5bfeb4eabc9c28e33b8b29acabc5ab8dc56946651328f92c8c253612bbcd3e89dda8feded2697577feaa6457f88c95e64ed061a20da8119652115e9b4bb328e6aa4315eb0859fa19b6d73cf063ae6fc965a90714d27e1ba241e3f50083b8c4d9b763f9d03c6cd8234dc5b98e6e0850a7823ebe0a2b5d89f159315a4ad6799102dfc02b6b81c2a4cb28790d129084c13c91ceaee2ec4d497b2716eb4c55544e765523e6112a5d5c1445fe4085b55ca15c756dea35067109ca3c155c57188a770081c148c81b88baee26c47091d8e1551a8c2231253db0a1a0cc569ae064f0c50d565f7f1aaf9dee40e82035e9cafefdbd5ab81e7b386976524e3e5071042ce4a5dcbba60b8fbe741326271e587377eb34d7e2faea94aa3205178cc6f3e9440c13fead970275b7df53068958b742c23e92ede1d240a10b5618dfe09202767998ae37ad0f9157f61ae08afd36a323776ec39b427b263d09ca9411b1c9371ab58f6c8520c28ca71b8c941937fbad606dff908302fd3ebd2f370b6209747e0f805071fb8314efed917bc40e32dcedd6724dedeaab6c167ce6c1b9a9b3144e73ad7a41171d6efe6544bf2bd1ce5772890f67756661c65f084892635ac494396735b4e7b2b2af3c1428d54223f21c2ae94809b40eb6ccd67bfe08e3a43c9ce965c520f53a8abbc394f99d0a8f4f97a51fc9fde03658ef35dc6abae131094d98a0811c89efb6b6c5a1c146029682dacd1a08b55be055fbe4fa57f34532188d97ae8c7fce1582e85dd28cb15f9b5c12f670eae048adf5ad0805cb0fb148813095fa65b8e2f8511ee3cfcd8ccc46fcf188e4c62a719447595a8f4cf497ba11d4c8ee7660f739125708ca46e4fd21e2fb74302d1b333923d9b5cf8611a03dec75b25d96d5c3c22950387cb639a34a68da36cc54ff70c1c5b3f300d0e5ecbcb4b739a661b9819398b8d34628d9020a27eb8b224ab50b5b576656cba0503260d8acd4a6fc4dbf5bc1bdfba92668c30d87781a8a1b5080821a0e5f4c4f8a418a919d08ac3ee8ffa3c8d4a259a931742aab8a2abdb5d76598702ffb32e5ea1fb67f10323de2cc90a1d6e2470f9184e3ce0d82fd6d03f4896fefa92a9b24fecf08de3d4fe2c4f3a35aeed149580953693def652e47a19f4419dc0899993ef6e1cd5e8344efdcc453933f6d34867a93240a05cc89dbf71ca8351b32f4b192565da0a28d3f8a6c849fb456a4b805b222f6c6df28496639cf7663ef7192db3649149e9c364ee3f43f6c40e9d03b6e7d4a72d8a5209b7857867b7becdbf7a85c49d0e7adc0eba9092a2824137eae06510f14480231b9f7e0e899ba62bb7b14e9a527287137a60d7f62173ddea975b48097f4c92b39e9b7a4a94a29698985803e203d97793ec574f4002c71f12bfa1b7de367f6cb343c1695320917194b0cc8e4dca47ceb3a0d2b1f742201822a28f7574278f5cc3449cd6d03ac1f8d4b192892c7a846631044b78cbce2221706d25add3cf2be842e079248832441f3b126296696f029f1e68e0099c977c092cdc2068365663997d59fe89453130f3791a0a4353baecd3207018a6d23d0aa3c35cb8d6cb8fc4996c5ecea64c91e3ad3f55ff9ef5c0b33ea8b9c3121baddc21dc658ae2b64ad54af389a5e2d35ac1b89e945d891769e3d486e7c2d0f3e6a60cc93a0c669330344a1333588c2afad2bbb99caf172f394104261f39d5883099a3cb3909b62bd39b945b4222dd3afd5a29b03a5a4b695abaaf8e86df69304a1b1daa3263c8ec155a9ab6acef75a5d74f636fe74d5bc5f3c57c956d9d8ed02c2d4d7426389fc8351ce8b703344a73259f8d09c84121f19b97751f97d1f6f7d804be1df2c0059f93bc3b27672a131150d95999df91d34e57ddaf1806c2b075222921284f29d2b1c144fd7b8c839a1460d42598452a52dce3cd5a50ba7324128ae6c31f9178bd2e4c0e0c35c7f3f27556459a3d440e4c478a4d2beacae24e0001f482f50649a7f561c9e81bb330de96d3d894519a12049f2c34256145a4180eb1b987718ac64a6e974c676c2aeb28233ffdfd24b32f637c88d8240a4fcedbcc08179a09bc3985af6a3a9a1739494e308e185dc7871feb8e916fed995c25fd76d1f33dd28c97ea599d925a29e433bdcbb9e7ec63cf1b4d40594a9cf737dc04c526ea93eade8816b1e0eb0f5c4bb6b539200ab0b4a963e893b6b2ce736e9ec82da34250d12fb6bbb10c276fe8109d92f85b2ba73bd60189eec1173391f1d69316e471691592a3954422ab9a040ad4fb1cb723e40311bfa78169dce75e807e68d7f92d340df45ce45ab64975158832e58503e595974c6a28cf7e6d84459d2d0b17fd80f2ed680b40cac479c8348031a5c2ec0f4a0c25f4bbf76f3cc3443971209b8871af14fa121ed944669deadb43c4372f45a332d5f7d191e18be42f6ac0c1bbbf75a7197a63c18e3a8219f25a0d3be8bdabdf162320a91c0c8ee082bf41264b0e866bfdb67a2855b6bd4e5345d4c2c74fb0c22028aeb2ba387a10f8ce607f40bed0ab9523680d89c2c7ee39de5eed4520a7369c463fd17546831daac44d604fec1367569829a6d143868158fe9c2488331dc562532a0f65143dc019a1de785803073c287ff0f1da8eca82c18955818b2d01a85fdc1f248833c970a7b7f7b01d2899925b3fc32eaeace70639982b0d1bc00d49f6905d6958020d01230bed5278d59b5438e9b58df6c707b1a7333aef4df3af8eaaa8380c7e0be07f20ab1028fcad52677f06272c94add159f93c8daf71deb35407e8badfb0a7ecec8569bea48744a4ee9aa6d5a885c574f670b473c35aa72fc04c4d16fbd49f5b682609144b87cd0e2ffefc748814ac5e89fe9b5e96dc16dbd74d9c8fb33516975c9d2e4c181214003c6b8300daf336c825462f36227d0da64d9d94c3141f1fd86298304f8fe88ed8fa41660ffb903a62ef3a3197dec17d8e57323b5c4757b70646d74ebf4ac6340d15c087b62591c7402f012d49416883d30193067834cf88f157090c2a0e03eabebc6ae523583778cbdda489f5d8002d218d568e61c6de1b8534aad22372007154f5bfd361799128a0fd62fe8a657451bc6e6561f3169024947740ada8de0dc0477a62885ce53118d7dd03c4babc5a134d3eb25b55c969d273f5e032834259fcd8afe236689dd5e6ac7fe1adb9ec89d8283ec31bf8589c8db6825cd9173936db5799f244bd2bdc7fd481eca333adb8b920e52352ff094925fd6310d5fe6bdfe75802ac9c4271531041c0351ee65d4d354f1e92a62e168961df27c0a14bdb55e3f794619332956055ed5c2478587429a0290f702dcbc66fc09eba7260ba0c79df38fff7d3600c32ee78550f96edbd2142dbef5065787d8b4d885835f7ddf827002d460443f5839e2bc79ae3e66e802ca86eee150b6039d28832571799df30b364608ae2a4bf947c7884f5299d89bd20f949e16c5a7b5a31c6b9a3faff3bae6a119ce5ab3030ce33a8a4cd83b6cd38fc936be619598aade94c50f5a2ca4e4dc054c895971a409bc307798b27bb62f33d85208733b09870afe4d4db19ccb54ea6ebf0c89305e305dc0fae7429c77cf792fbfcde8747f7bb3ecf1cc738b0f981ca301d05d2c055bcf4a3300ff5563fb4501949b0fad1be8ce256665a63b5c132d1cfbec529d31891fa1c97ea02968f6d62142c79a080c27bc33cb810bca50b74d917049b4f92c311ad50deef72eababda3dd26cc56725b65ee1866d93126fdae6a46a2291bd84a0a1f646b06cf9982dcb42d1cc2b24263298df2502caa21eed356cccc9fe116217b9a74157904a3f2166081002cc9c6ef98e9c37d60389b6e46d0b088a42cc1c56316f27a6555ddde29d30ae6e76ebd370778a45cb112713271fff3e3619cf85f4fc50c7f806ae75fd9d8c3878f68a7486441a80e4ebd0c3009f9b65a5631369a3f0a538477d79acc7248900a4b2fc98711c0e25f9d6aac11db8c24bb119e8fab24ab905c2435f19c47848993be268851312ab2febbf27b6baa8c35268aeccee3931496321d5626c12eb263a4dc8cfc569bc59c5fe7c95ab2bd0fdfaffc070c65cfe0caed7425689370a0dc9d6437a4126ce3fa37d1f099aa2ca76a7fa71799f160feeae7574be939c32710678d2cee74ba6e72109dc958017770bedebb9ee0a875aee6ea452555cb81b3e9d3a6ee8b2cdfad3b855a530b93c1ecc752b72b27891871bd568e77dc991afdc5211692505f0b502cd97530853fd7a61525a813d2007fae2d9340a88270d1300fd24b54640c3b2bc210e825f7e162ef4012ba1386fb8782d422136546ae3674a9f380b80aa1f451d5b2b73fafbe3af3db3d762707c25c856570ec5a0544fdc03b8a2d08c3c7f945e9cc883b3e5456a9719d6830517be902539f9302bc4903c840046162027ba9247aec4183910ac3bcfc9f19322cda633c20031d2fc535a1294a25644310faf8968061250d0698e9efd4e1f430a15d0feea400e056cbcd5c40580e1e5fe6f4d71ca4acbf7e4007531c3e35c555547e9181e31af93d21798a5ea5183751d54f3619183a7d7f0e5c3176320f3c362a6ea219f18bc36a60e85cb81ac80bbdac66456747f25c7fdb9a74390f165fd63329bffe06ccb0cf49cc34667eb71dd14e6298ccfa8d0d71c1043cdbe3ea0ab053307d2e498a1de77ea54a07d039981e2ebe8af423693c2c33522a082d92c4acc783b6a80899538e95a5e92482baa64475ad194022583deb297c1d5fa90585585ea050977168333a4b6cf5ecd9894d6e0e032bdecf422ae094a7b67faab83016f378fb4dc396d1025cb813ae72446aaa00e049dbe1ab699298a101e5e3fb118470f45e5e37d247563f1be461f48b28b66c888ffbed181f6c8fdcf73fcaeacf51474c898b8a77553b6f683d886cdc1d9c82b05f40410ac44caff242048a5eb717dcb70bc0b27057cd93bc9f591b3725fc342a4ac46f81ed605abb37741950ce50f13f9e90e9854ba76af46090d6eef72daeedcaf74b91a60c17b17bdcd79a567634fddac6efef37c7d285c1bd6911d014c38141e36603a4c30955a3a505c59d0f96f6a32ad2a83069983ca73290f59ad3e675d8e6e54948b68e9ef7f76b46974c7f476b0b219e23071fc143bf771ab6684351fe3875967fd29c9d21201b61373c971e127841a0535e7453b2c01c199829a62d9f9934b37c7a8df2ae2acf21c795691904fb42c17e62efa2fa764b52ac413cb42e180cc20e81e294d3851e3c4d18b13b18fb4a31dd3f93f10a8825cc3ba84b3de0f0fce5cab6b56bfe094cb6d906b77676313f651e4f9e1dd0554a9e03b6b2842c30d4e652ec64d9935f43348d57817b9d885080a04e2f824a64c3ac8a825503785f12df3e23ac1958cbac772042480b347d5c8684703b21d2616c87258ed18cdcdb46e04787460c63a0a381a145b113f1d5947f479b275db1afca0ad359605c01f401c5297308844cae308d6f634caa38601b68a5aa319e45287a20745fef9d2cdaf7a8a5be761e31778fbd7e42f94f83fdbf0dba7cee59207448b618e5a21800ff032b0da328fd533e925962fe8d6961a159670d686808bd1bdee182a62cef14eb7f75e1f71c106de42fb7935fea641b2524","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
