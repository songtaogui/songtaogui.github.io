<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42aaccd6f5d2d3f3e6ca35d7a301a68185aede8adc8fd282f1384728bdbc9d2d4a2beb47b8634c478f6e6536ff6e49a1840e759da89052c79de6c340bca057057a3b7b2aae9a9a36e6070ff85a406047f6d3c9994fe1d12b171a6e4cf797910a3b345f9e0e15331fd8c6442a4adf46ba98c96c3feefa34755016845841f3628899eaaddb86f8db2744f3f91f49c268ae7ba1a5184189ec40fa345280858decec4a262af0cbe6c877f8996938698ade9283fd87542569970afa1cb9b3b1aee566128aa60904c988d61285c1f9d44fa28b5832c4e668827a966ad70f68d6e11175a1dc8035734bd43b7553466a2ffef4c6a8ca2018e0934c1706989609df22c14cf86fd6b8b780cb2f9260358c0450a60ff8fc431df195d7bc58d39ebc57b2ef97d68aadcead5b2b7693be204cc1708df176a12746a40fd4b7e2eff1ab130afe1418aa81900aa638c55b1e32a734a0818f3e405b94dc0bb38e41ed84889d7c5aae7d1a3ba9afb1b512d62f9c504d786e2651a3c0304e4f5bbc7aca6a9a5418819df3d97fe7b2c0dc5ea83e2d7086eaeec45441435e000ee4eee93857b2552b3a3b6efdfc71285a8b488de9987c85e724f8ce54989990c7ed9dd74d6e88d7465bb1d9489dbdafae45a9e039428d9295ff652b6c9a4257303dad0efc62bef721b589009f409e194ae40196b2fab9496dc30354ca228ddffe43718c4b192b87e7c6e3577101c48a8894d7ef82987f879fcc462941aaf4b58f02b3f0282f63f16680485cdc6aed1bc62c2d4be6b707bce9b9353c3670b67d63113b56cf162d07854ecd9f8cfd15655d42c5ffdea9df94f755c7bf0a7783f2ebd093fe8df082c69d0967b7b29f41fac531a047d11afc53983025625bff1ba6b24da36db60f42fbce4477a8158dacd831501e3052cdb7413895ccf8ddbef8e318eabcc73f89c60e056ebc4cd4f7a9d50502001cea44b85ef91c2dc00b5d36a8463c593f9a208b4eb3b51f7854601d833acc6f903e0f2904cf1df0c0622615b664f97e46296906ab105c63f452e4bc3cd83bbcb56113088bed68d07bc6382b9866736d1a1b8ebf910ff7ae8fa3621b695cad3d28761f0c030f5dc11702eba604b4304b2c1e9f237b89f6abd435d84e9cd2a42b24a3a6b7c7b43902e77ff2b268e4dbdd3fbc13d4127614f25845a3324a154ff7f7549ce59e15c48d6cce057a6d9297fc44e0b6316b7535d7dec9f01766310004d69f2ec6a13d69aae7469e445b174fcbc69f8e24bbfb59168f9e84bea728f1163e76d05a4a56f4b413087c2501d68945eb8e215fe3288083dfc6fd9d8b61d2818a184ee95bd747b8f9b2938a97ab562a56c5c3c65ffb8a54bec936a404dce3c83eedc4f58c099ee802f736505785e41edbe64d0534a661991a0bd5c05ac8490f994c1e8803bcaeb2a9f52db7386c05c722ee4d40b8404c98618568c04abd39d99f8edd81e73a58bfab36cdcc6a8427848ffc8156128be6576916891aa7beceb7831db2207dd4868640e59fc631b53f3d677b3d33cccc1e3752aba27d436875cb3d8ca7735a5e4cf5e450e9a0ab388cdcd4c8495832c3547b6340a82df2890e9cb2567ff80266d90b6fce36605c8df81b3104e232cb2a1945bce301e5356f8349f101a5f8614ca22917c33ff30774d8a44899ca5cb2ee980421dbb8cf3836cb89ce809f5b869f2f21c661f6fe40f91838090dafe48af7a39b212569b5ff3754e2cb001e6ad2772464d5fbfe7dfdb5bcb748a61703fdf4f24aac618cd0b6dbaa24d82ccab1c3ce5dc9e02acfb96cea745d9a3b44fff5dddb37d083de1f10005f51769508fdd65e9eaa5b5969a4dcdadbc8216b35bbe2a05a1e747d8860a94923bfa15d36371c7489cc3b18396f6413220aa539438ca2d8242e73612c05556e1b1e30bbe8c6ea2ff76b4d9fe11e32d151145d562e4707a7042b2909cd6ec622697e66cf6f809a40bc896a09364a2b47e4c120869aef31dc1468246302eccc48f30ec381929d17be5552695e93ca02c5612116f3e8b66b5aedefa5d01d5360f99262cf94badced53aa9618b5ff79a6ffe6b21bf74ae0a9b667819da9177ab8238cedfb8d14da246476c835be99b2cbf616ff806a751d4ab95df3e3f78cc7fc088be2710cfc4cb1be1a1f2dd12ef637408a98c476fa18d305aa0b5512f15a60ebef1dd1749ffc0eb9794a7e1ca48f2228c46473c438411a5e1496d5c657766d5c5454eb8abc819ee93e584d2fb35aaf2394163995d3de1eef6728e413ddee6363216051b41ec1361784f4921270276c624b50c0513a6b57f91a3d445445a5e962290ab995eaa0b61c258067c80d540f64a33a4c9cc4c2e83ae53aa3044ff6f9762a66a17d27669f832a4f726aa14b27413501648e1b5c93b34a9a1ecb087206c5cd310671547f245f806affa40c26318896fc7cbaa5004c249af5ff7b320b262ed3452a2529d738240266550fd02d20e0e95bb8292ee84b516d39d1d6a608165ec94c98c159a3db4482a562a1e3886d308bc9f03c96f0e3acce66b0fb05859712485cd25b66e748c90661e3f01b6b19c0da9b3f852b7babf7612ad3b0b4ba7df6b36bccb491b303ab84072ffdbb6a519e7efea761c28e2efb0db0a93605dd3a8b6053231447590a257321274cd854a79f073380198c3c4390b9e34b1c9e096d3b4ab1ea831b6b08eb3924809f0c6b572b2fa3f78b1a4e58a7b79ddda47a5da01149ca4837865bc6b39d370a1836c7d17a2a6bb2834638b8613a2f8d44c6a37c4f18c960ca382f18b6d29a51017155ff1918f9901a8821857442151088618f09088c272298b1a6d5e0dde98e5fed9c6f6f5ef228b4974e559638eb94592296090ed8fbb4c116ab19f46389d4b108a17d11dc4815870f3c1e1ee1f27ae3bd8ec3a10e7308f3d569e37cbaeb8ff38ed1202b6d9f1e573215254a933f005bbd9b373c817fb9e5c5026a32fc523cf26a59170f4bcc38d53a2bfb4894459e0c0e8248932893b55f14e60bf60c50b8bb89d39ce424223f6dd5000cf2e6c99bbcbb06168b5344e889cbd865c9fb218fe1ad22f05e5e2a49553cc38a0c0b058b42eee559826a4a8bc552c270161367d9dce32380c53fc30316f9a29e499edadc7bb49df4d8a0e61d25e916d870c231f610f78b801c2311670db0f9ce213ab86fa5ad1499476d868fbdd23fa66131b1e7c71d5d9acc59a7887d3b5541760b81bf400fefdd4d9d5b3cb184332d918f2dd057f858ff1af0afc7f5637024a341fadcef6da74f5020047819580d3cb940251fa006df96d282c098a5908b622830f50c37dbf05af227ee68e8c9137a2f52c45f187b09a92253e5f01997a557817a284a921d5cba4b67b2e7cd5942c0e173e9a669a33d63807d84153fac16baaa5e2d7283976354e8831ccb897f306a2dd68b91b974e0a2ab2eb24062b50a7d55011f8ad3fdda60d98771b2c86a2f81c6becc45c8db91df5e4f764e73267734b759fb4703545c6becc73e174ac92edf6cec3462d6de87d45e553197cf8be2233af1fb557af807270244999cca6b5d72e84ffe4ef85841d293c5d61e92bffbe7196d4ebf948d78d318450b52ca8690925cec189060cde9e9136da7c447cb92e743c988353cf8f71833fcf2773e57a1c712bfa20b80cf0af41c630061b2a69b7865b4ebbf936333baa2c8d25926ff839df0be0f045205601c4060ba4c1235bbb7df67236540afec657400625e8739c0c122e805562979706f03c6e1f28a19be2efd6436cc40b901532dc72806774489f0cddffe34a1a83fcc53a07c43730348364caa2cffdcc93add82997876c19cf2e9acd30aa4e4b36c00d2f28af62102c1f5d9a003eb41041da63f8402d63b66f6753c0e8e8bfc6176b3de7f4ad98d7faf3d3ae37a93749b9c942f310a151c3d5b443deb9d906cf451ba1accdfbe32c6048742eeb8940aee63df894a06da7c22f06a3732deec9de85b071934a56de689817c1c4422252b49dd620b3320b0b842a571a92775b002656b4ca3dbf877d35d65f9dd25fe986eadc0a4d1d7ec64377c83e3b6fd8ef7fc3f93433fb558f5f8b0d97e0e3cf08f057cbcdd5de12ff97d23975fefc5598a3ed7ee2d2a288135358592ed3871667e779ff289c005d59886bda9b477d08fde76591e38c1aed5d3153743c03d671677ba6ce439d3bf8243bde552165cb1b607d131615bf5e53500789f0822f547582520fd5d6167b4a7579bacc976cbb523e6304e6bad4981766130897b934b5092961f9b3144d11abaefc3b94d8aeab2a957ddce410c98fd38b1df4796d3abd31b5cad672d9a62d807a593157b975fb30d88dd1c93563177dc48ddbbe6fd537ebe77627592d9f7d53574eb52ee38d2306fe46c2f3bbaa4030268bf1d88c58b0750a2424aa44376a9c61945055348b64a662a1577adb8a76c8098e78335ae9436d477a9975dfe7f16f25f3147a3e7f364c9f0c8daeeb4c418d18fcabacaf6a299199baabb7425d2212de6f724d1b9d5d2c5792f974f137830c2f6532053afe6f76b3aaa1b6d6da5d4abd121283343d67249d93e45f54680566d5d1e9c12d26cb948a9ba2f58f090ac2b849d425ac158e9b6cee59ae7e55ecf8c8e6ed87ed959aa9e7470dd890755562bcdd0cdbefb4847d2ce05a6449ecaa4d0b3d5bafeb9478d0f858bc290269ae482877e7d773af8f2d96d85afb6cb4088aaedf7abe9f0c9fe9133560cd724bdc0515dd0b8cb6334c33280ea64c9d0fdd8104f73d641c8c319b876931f70639e9f0edbd0adcbacd4f5f86e2f052aa48cd2dc94d245790acdd5062143baccd16a17c4ab3b8759280acb29f3e9ee609533543345be1dae96436f0c4c846dd1d70a2f23cf333fa2df3c0d12aca134bf38dc1649795baa606e3b332a34e2488f6683449cb32014eb6397ae6caa5ff0600169b2669c04ef706b28e9bf9c4eeaa0f3c149fe5095332abeec9a2798fcccd852a6e8cc427b2e4c109d548751f1571db269b93fbbfcad90c862519185a42562eb0212084bea9eee3934304977ee68522795ca2406e2c218e1bd91830da69ac91d4183eca2e0faad41ee1241bb58386b46de26bbdd9a52f2f35a35249aab4571b4011378e939cd9d29f4084c440613345eee666e7f953b0845f5722f9466b6ed965bf096b48b58eaaddb2b72e3cf442bf60f58c7ce884283259a452d54d3bbb44b2ebfef89ac2848903679304cb7143ab8e461f2b65136800664baf2b54536fff64d0fca0b05c0b97bfb0c356d27ed0d651b09ac293a5695176bc4651502f27deef0a3af2b7ea34a1fca26424cbb94d3a692067af3dd1ee22f61e13d2285a3448186a3ebc717c6f3706f0de23f7e87483b2985d73f59d3fd40a6aa354bce9f4b363d181f2b2a9b691ce5a3f9a0ec5e576362e0aee756266c24e950027e84a558ac24fd625c40934955718d5f7170d9c11436e72e354057fe14b4a472fa0bacf6c39dc192331500a437ff727897761654a57658ad37dd4cadaee77737433281ccfaceecf2ce39f454a47ca844d128dd8d235d0ab4902cf77420777296d2242a074e8ce157a4be060492796c88f1b30a62f1b278edac695231843edd3e540ef805f1f204e4deab159f1efa95431a3fcaa3a736a775461dcbaf4ab642785bc88785105ff90ca2ab8e2aabd017a3ca13226166d7417350b5800bbc567a989c68803eb9771ba784f9ee75ad1fb4442c08fef0ca227d4e504233477bcbb042b080b7aa21d9d6f6b018ea0b53077a04f4bce1365b9e8197b08a85d0af53811fbe4d3930b0cbbd8a907bf84b527ef6ea70acf6113652825c639471bc2b008703bf28014af27eb9b48445a6c998be71be5694764fc05ebd3aad68e21eb7985b0b2645f0ad3113fa3906699c3152c3d8f5f32d7490b3ab52518592dee5792c976ea1daed7406014725a17234043e2b5df765a66217f9a56f511a3b8d4c0463fae0fb44d0846d62b5b59d71a57fb3a00b059c281a0cf91c5d5d662b4289e15986de21941e270afa646c30078fb1badc2438383dda9277b5d6041587f8ee6ad100e6c76c6b1f339b6e432d0642eb32d45d2b893ea320336f940e5335e2c3dafea1b3ed0461e57d2be55749d0b8c0fa561ffee2d67ef38596c60cb5902cd6dd8482ee754d39ade2f2bb2476de0ba9a78dfc37a24a74ef0739221176072430ada519ae1ec643427ed02d4bbf9d5fa02a55a104bd306cae0f99ab114ba0c0ba66ffd0d6eb8835832ee8cc29bba964a8e8777c7a47c1cfd576c6f6aa034f9ffdc16475f3c307e9cc45c963e2a5aa064b982b5ed81862ef6ebfe3304b43ce232ca3a791984a53efa2527f0c1f85383ff186810f891d78117676c14d4a88f8dd249312f375ce8515f48138989aaab3af36bf654baa2a664dd8fe0193c9bffdf27f980a59a83795112d5231dbbb0683ba6232728d012fa00b78fa470677542f05280e324c83ed8a2c67df0c7442b66c3a1c7c0e831997f033247210760363470d64344e357ec6f0aedaaa63fb11da84d82a2fca6f72dae2b26f8a7bc647409fbb729eb995a1f0412fbc6045daeceb0a8fd033863f252c0e8e027dd0b778f6f515d8033439424889053876e77029374d0fb99a74e4abced7ca12b5e2dd5644334f1628867c34c7f1f05fc30f7f6e0bb0ce1f7b2414da64a54ab2d68768517a8026c37f91fa6d6bcf38904b0d40c3815f1b8a3112a94e77ac2d4688a9b2d9937fbc076d4afd46674250a2b17e4c2100826ba8e3797334da92b882eee44f351e3a52b8c2f22b4871e6a233271f3660e9fc9d7aed7a45764fb2f1bc8c69c6ea5a87c574ddbf2d4370c4f2d804b8bf8f1a22b699d89b8650b38bb43ff4259fb921482dd2d9a3611dadc389d67a9feff4767e5e88ee6eb50d38f6ab16e278f2f0d4285a0ddd74a9558df7411735c51284afbe94333d5024a7c3bf0d97df46f268fb4f904f52161ff47fcc388fa6658103916d294ac18ba4aaa05cd87b3ca3866f9a6ea2eb416e9bddd7564621feb77ecc525adcadbe3b10d9cac2cee738d8d70ce90de27b188d6505853ba0f80dc868a3493b7dd8647c5b784e18e99c023995200c92daa04b8c7a07f17c6df72536211655a8b42a0c09a83354bbdd9f6018aa48bfa98e6d76d25241e902a878a1cd19fe015da46e5dcf2a9ffd474c32e994eb48a666a0f088d8acadb56bdd4a2210a427699558f46503b20626579bb6000a8c259ff19d312e0f9fe2ad89d022d05e7d27a4f05e5428084a76b0e11374dee1f41110c824211d9666b738ddca029d48b41b6054d676e59c551da8d82cb238b70f2b646ea6ad17c566ab5bce6de4efd6908ae8d91379209deb7840e367e0798c42f447534c144ccf47bac7cbc9ad3ed2fa6288dda9436fda00160687d4d87cda28369782db9883a7b908143796eb6a76d062b4423ac0299a6cdff40b204d9f2a60746746ca144f765a8589e0e5a90cbb6404adce2f6b955d66c96a87d69082d004fc30157f4766edec70ab63e43d39015d8429d63c468691670c45e164f7eb4d12d60c2f71c37d82d59dfeb6760b80de2d086e2ffbfb6d42fb4a98a12ab3e764a1bda55fea0b5c9a3e21e7be5765ef6f9e3b06d121756c69b2efe08c3c05b9c1bfb19fade5edbd686d5b8687f2e4596c5fe662f41b88c0dd9e807700d9fbae7879141ad58a6b2659571a1b2a0b79e83961f4c20be711659c991473ca94d0277d1b60a919b33968b017db69c58e0ee0bb4a1a10bc1f95d7d705aaa652389cb7d21525a7ff2a41da922cf6a1f0867e325813f8f1eac79b4588ab90ab8dbb9cff0c65126db8a84fbc6683c421863d94dfbfc5e7301ef43d76cc619b75243a8457d19b5431b3665dd0d94584d44a304aca733c2966ee3de7c416c40d3b353e33a47cb6cd373387eedca0357e6cf690be4c3aeba4ff95e48589a49631246c52a2f4ba24f7883ad7b95c7f1fdf5627ada4ea8f4e07a66393033c1a9737783bf1bdb754dad9809c3814a0e00fdacbfa0349f714c7d1450326a71f93057af4bd644d5cf8a0b72664dcbaad010837f8ddf0f205c14d0dfb97882723ac76641b7aae4387e06b7ac3c82c07942803f4d0c98be30fae5bb22e71af4b98f538f0927357eff58ef156cbe3fa03a272b34888cf12111e8ba7e8d95e0204e7734f437aedf7b372bfb71a6846fb90b58e7ac3373b63e6975a60ac7a8d6ebadc9194ee00c99413d9a53a185ad47ea1b1cd1115bc265b0837355da2250df42e32062e45bc025532c26f44cd4eee44909da2412aa9418408f4dcee4d55cab7d63a22762e22695c9a0f68d0d7cf0a4139f624fed295bb9b5344c4480dc968c699fde98489c5d2d83581b6e8c544ab1d346b6be9eb7ce48b8009a3b276806f60d9ad032b1117c2ec3e6022a1019b1f73952a37865eda99a9510806b838a87afff286763c5dc202d1a36cfc5cfb7ee208c8773d2fc9af6362d3804976b91d576e04b17d02f0340270f44f5ac93dffd820ea84e82c6ee3620566d8fcadc828fdc87a073f6a0691402e2a5023c954fad125f40d7e1c0537dfd2c90cea018538852d26e64b0a29b2df19748ef2c422c3d5ae771b123f18755502b62ea845b723c662389498a437792e6be5ee69bece015712f9454026e71d4fa769b424e677c0541b72a91daccf593d32c57603e12bb0e52bc8e1a1fe921a1479d007bef75853936beaced332155ca1a9d17fd9eafba546c15ee62a234e82a0dda658c7cbca63bd409401bccbf908d4d05a5cdee20429e3dccd25fa7cb5037d2a5d77e39c299944564e397c9c607e5ae16476e5f3498e173aa1d131225655abab7757b545c30c25f1cd8e98db4535d4ce98d7d9b155a4123ed875bdca9e451766700020f53190db1118d58bfb74cbb6963a98275782b8b0b04ec2c7dd75991f3dc462d36a23bedfc89db38b8bf2a72cd3cacf354495b815073da888f1191e998d36ed490a17c2e02340b6b9396e5a0e969664fcff63bb79f367cbe041dd1ccbced29757262bd9b945c53edab866bd4993146fc3e3c66c03f3b2ab51be81cefe1b53f8246b8887d780be2f4b92dabdfc31d253ebf0586dc25250c75df275b0dc76d1f6e4f5ddac09dee50308c715c98446e0e4803c7a4825f8bba5aa7d274be43e8df6870c2d6b2a2b9772a86e2bebeab38265a940fb19d98c23a7c8c0c3a3c585f36523cf22b1afb3e58eabc862cafe21e76ce3756956fa0c649144588feb1408768f1491a6510f22a0a90ac95d0d1646bd7631d110ccdd59c7355bfe4f2e55581885a868550aa347c10f1a6687b41b662470ab0f87755201fdbf15fa2d7dc2dcc8dc1a2ceae22d38427ec4e414287c11a0b413fc698c7e50631fc235a519bf62f9a6bb56dfd6fc00aaf34c0caaa1fd0d4fc2de2b4c7e24006a598e97f37b0f80333b7e56fe821a05a4fe07878288632cb52ed879f0674edfda31028e370f82e0869fc0c4925c667c5d4b0a54ecc592ccbf8fecc6b3f4e7ea812fde4b5c280588571cc6943307d3c47dffe8408c628316e1a363de5258eb7934c68b179b7b85615608d7231265fef8b60605e502df181472993948cb66ebd4095084e3f56bfa23ad107972dee5332ec9581f53bae23cb8e25c987f6f17fcd79779191e3fc4114632d4eb146c7c9c7fb42128f4e0f4d3bbd7699b1dd2af572e4db161d07b8ae538907cd7bd1f39efab5561416a681daf04fd0b083d247bd90c1d5cc09585b056b53f3b07c6a45a82ee12f857e0cfa422f6a3c5e13115fe2fa5d0649f753f3c159c84ecf384276e01d1b30e392197ff66a5ad7a74eec5cd58666d2124342587e54376b822ad99a5160fadae0e7f441f5bfbc38804703b4fef7ff659a806a68d317f6bca2e99e5cbb2f6729a2670b43659b09d115bf212a1221aba256cef5cf8b8e019fef0e3b5d101fa1a9505a16c460cdb8d9da6989e808f4bae1fdc9c5f75feaaba1b1682d808459c89ed7fb195513dd15c470028e79e30b0e65adc00304e445e9283f9951561e731594416cf29d4083619976bff5b65871f691e7f05fec07329ae7ccf0ac6eb97f826ef208dede6a247a035ac2f6dfd348b8223982413a23413a150b965dab8594b671078fb121e7073f5e855859bb92c995becc1ed33e306461cf36013288cc5f813a4e3ba13e8d88ab925c5897f80d0b1ccb446bc018117f5bbf5bae1e4afd14fe0eddeae70cfb6c9e640c1429333f4007c2a5406bfb4923836104a7a5c619c3a70af7f33ab8cefc1c948d0e9db3a595c19d8f0e8721ea2b2ff832be14674dff17feb4e86984af82a025cc3d10ec67f1505215c53ab6ca1f8d3dec89600abe0f45ef9ca5c49ec308187ec3c0037cdca09eef3c87796ebcd801b10975d786b72870f434ab9fcc199d77ea98f2984b645567fcdcfed955aec35476a9968548a43be067ffdfbbd5a72e3dcf0ca7bb382cc2e9dabfb8404f4577163555321a4d3cf3e7aab91262b9ccd408f9640e7d96d24b6f470de8791e3fe380de1507ece353c716660c5bcd21283696e3c8f4efd3f9d657d0752dbb9729d575e86af53f946b8dcb3a23d6be94f83a7e9c2b50051eade5f55c0e865a5db9f0176ef5339c77abfef2497c1ef6b58cd8d02ea32301e4e7c0951a05c1c0c3b8b711638c235b2a3ca4d5da4540dd52887e726c12b3e3bc83580059ead35ff66ba304ab07370b156a6994f8b30543cddc2d65273d1ed83a26f4b9b6c70791e4257bdec64bf528f67e767a2ff10f6a3e591d9827bed2f83abb0a23fb6b6e4ba426004b6a45c052280930d30ec93a7f453e81dc0630391c3ac00c30613cb2c5b36cd5ce0beb3ced19ec544c89953215b4d63e4a2b9ea221ecf696fd38300fd53892bd106cf314ec49cd5730068566aa242092c7ef07adfeddd7bf12d24c2d8d0b6f51f7974afb9f77f5fba968d13e734ce20863f698a86ea134d2ab4cf9d97b34579c2f8ae31a4c74a0b62cc4061924eca7de7a7313e1ce1b06f92faac1ead1d6d4d06285e707b15a2a10c118399c4c6131c3b608f94b1c4af3a86d4f9ede6248b5c0394b9122fcac115b23e3aab621e9c72f261a9bfb83ab5a0ea8e3885d9bda63d0281fb7c6e88533e92f025be41353971a887aa76460835f0d95d6907d1c7818e1442311900bab21e946089ff6ae80b8e60a00beb47699e02084cb969cb8edc6cda645c4a6f478dcf9ca1bedcf889cbe5076875cfa5cf72c21eddf9c6c3cbf41f766d421bfd4a3948ea37998fcc9a3a638ecf0371a1ab665e2e16ec9ca3d61a17ca1edaab62af0433ab12e48dde6c80146953f35dde1d5887a21b3b459626c9dbc16bfbf49410e06d135501c8ab669b373b4c73fcb6d587a6a52ceb663800ad7c3d5eb9be9626675997c60b2d8fc906f5d7df0cc8cdc93f354363b07dd128a34847ac1b2e67a63356141fc36a2172c0ac91265ff2995c19c149050531da27fa6928a87c4c60c63d47b4cdc0f07a92863d3b7c5c336198afb5d6d8f4946c0ae2895f072e2c08bcf0a6639443424d3f2a8ba67489ee53f6a54791c7687dd3bd710bba1f1b6994ababd81f41939675d81ec4a935499a20c8131805659b7b48abc7522faa6a02702e9b64224995ead2b60b7eebf8aa22b788f74e4c478f31ffeab88afd1af2b38708ab8294a326eacd0ae549a8719fa48745d0f87886a096dea2e2255d2ce740fd6540bab592e3d606334cd15a3ac785234e60bbafef7b4160f5ccdae8fcda8149561a047eb11078b9351e62b3376fe024b16688a204aa4284a9a53f5e373c2c0935d78bcaae71a8ab71505e967ed0cc274949a6c42787a952fcf5eb30ad7dca03f1a357e12393686323f3b034247eb61ed5d6223a52b0256cbd23ca71c91e79ca540146753e111e3117371c0306728b7f749b4d65d51cef67673822c41d6ee1ab5728a334890bd08f7e98858ed80ce5b9bd466efeeec9ed84ed79ca6f148f179195e975c9d151aca21a9243dfaf3bdbb7499098563b1dc3e64c050e12d604edfd70578e3483752769e374306cda9c0a5b9cc8189b94fbcb99bc9ee4909f4ef1accd4e6bdbf9052bcefa393b14fca14452c8be35e8cb7d9646da09ba7952a8d04d5296d1c452612265aa2905364c7525e4679f098b029c3a47ee7f9672c5b9567107d80bcb3cb0b8875ad73edf7271828a3d6b13a00858158be0218026bffcdf91058217e70bc5e36940829b038a4da657388522691103d181eeccc16d219c6f20f842656a0ce586bcb77269cf8ca2fbdecf25d24a9adb5bcda348275266d049a484f2d714bbbecb08c427ca1d2b94ebab8de2fa9fd5215cd03901a7768ce30083183b3437eeb4c6ff9207dc4392e2885e3d26780867826e522ff601ff08a0c3c59d168ebf2652a06417823ffb053287b3247dcc32febcc97c198ea02154f0daeca98ef2dc2351a1ccf3627b06da5f3b01ce547800cb7417057cb8f36ff4ecf774c0096ddfe24e9724cfdb1f63bd8934668f3ba6254a8da703a08ad2b7dacc34b73a892d5b641d2d3b116700fb614fcf063b8d1a53b6d94cf93149d6138e565982705e21b39ab574d1d6aee09e2bf9b968c356a6c977f17c0537e7e5c211eb74d7c7af46962b5b58903d1ecc26ae24d8b060fc645349f9d007cc49271a00c3eb8f8ca0148df9c2f5431f7d3059f408d1f9b8800bbe9eb4b716ae05c632bcd755f1b38c7fe22280632bdf0f7073e4343977305d966f8ddcf960ca78cf0353f7a0bc846e01904aa565fc4222a45e561d2540d613e4ddfbc3d516e8c5bb15b6c16ca6f00123172df1d66bd2f90bc2eeecc9024a3a7927dfe9edf36373009e3500fc578e3185cd083d1c085803e968f38efc5ce202199d210fbfc082a6d4a3a942e681140c320801dc23726907ddd99f9839bd91d45db7aca2208cc23d6fe33b26e0aa37491d4f5b5174b0062a38695c402217ef6152b60758b81bb0b29173cc6f44de642d7c85403d3d280a856def3738b4f73ec5cf1e1bf1734637b69a3dfb32ec6aa91f97edd07670e9bdf055038b745e7627141a7825183d9ae13711602e7a5fe8f6672c76b442c5db588bc9be0c873be3cfa46434daf3d4a66d5c1f2e7d7d7e6daffa760496ed6eef1b09bf8c953d90052c38329536fb960c5c8cdeaf32b953c9480b30e5021a38eb75e3397c4a24cc9b58855749c4ecfdcb9dc19c341c862a83601a681ce419db7d245ce31b03705debf48227c941955a29da7cc440755928fe8f7ba23a94c5a40ac0f4bc03338806e889d5fc06af9ad9ef590cf7160856597fe74e043891b9f50c5af63e4f14d2caed29afb1652346cb0db3879458f59be0fc4692a22a672414abad3ff723b3fb3833bbff9388740366f8e6e58970b1bdeee6e30958d509954e62a6453baf653f0ec4aba0af02a94f7640f2dbc101453881b93762175868a8aae6c1edec495e2d7c0a83502b070dcded49a2910d96374a6c22cdd9f4ad0f30d31ddae1df7729535cd359ffd5a06ba76ceb559f4357ffa8733b9005f3088e6f387c2979269e8b11b0584efe72d3e77ab8c90cec3eb5b506229d1b5318581952731dfb795ea70c8662f8d8d6bc1a26323dec006a19eac48627eb4bda3ea3b10edc249daceb909383328cf7c952a05aef496e7ef03cce8dc218a15edef5c26e7b13e3595da9dca2d43c1f32add90a7391b1e32339355bbec8626597642de5abad2445992c6afa2140bb14a176ab0d5b1a65e2e75a04d8bb86d9b949a409ba5973c1f50e3d7fe89ef57392d90613859ef240124eab71a5abf5bb8c0e63768d94fce4dea876e6788fdfe4c89cd2ac8017d0f5af9547df35bbf58426a2072b0d60c7b895f19d1d8a5a4f111191903302994d353f70f47767ee52e89e928758a06be2855190a11e22699ea533f1d2af89165ce0857d56752aadbb6ba797397e68086cf44830eb1bfe37c240bce6c6e10bab6aa496517ac6f484bc06448fb60aae8fa33dbfd5c58c39a30f4e11867dd476cd11e550b8775ce782509819c19fc3427d61167574e5fbe6b2baf7bf75d623b5f111db435d1a275c58d0578221e842ec72f509fd1de9951ce24e80333e93c46934b1106e240b4958899590c64c52e3307d313900317273599d99894b6ef23fc7142eeacb4cc8367f5a80cec2b5a9873601582904f537fed60273573d30cf5187a9f586bd44dca1950042dfbacfb8c9b2a2453551481a6fb848c9bb160de725a5c08eafa9ebd4edc40e2a43459427336b9c761637a1ca7fa96d3a9246c4245f2f7043341d41e2e73476f13ad66d3de8874bdfaefd3018b6c1f52d8898de1841aea1a896eb181b80c748f5ebafcb0accfc7b64e4c1a1df6b5245a4257181d6ccb3835d61ac8a5701453facc8fed768825dba1568bf2301285167e2b3f9c7ed5d9a0e37f463735bbce2e27ddfb08cbf6d8683874e9b9578b7dfd78ec4ef1f8363e0ed90cbbf8bb00373bc9d276677ec6a88422bffcb4b2917c2684363b18b7731546a88e0a2f9fb4b32297e4f4cdcbbef9c6194f10eafa0e40506407426ceca491f07ec218d80e3fcfe9f828b7b6415776ade4172d1e61208a5a74b9d66031468d5dd7dd3c6d317d2765565bda150d292abc1227cd18edb8138fa2c6eb9719a9716f82fb25e289427f6342b59793964ef9f0ad368e0c3697e852da9ed65353a30a1affcd6cc43ca417794dbd5c21985f8a350a4dd85e4b2ddd4d2edf23154ae1eb490529f6c7826f40040857cb34c40130f6700b7610e23ab9962dfd5433a8c37940bf9845779d715dc21b235b6fdd6a789e92ed0e4277c638bd73958a5dce0c5460c1ff32ba1e33a6f570f3e5452e2012f3e612dcfa10aa1d02cbf9a1720a81496aed2e7426c20d001e16973b5c991fb13f340b1b0a0f60b3eef98b94dfd6e19397a752be297d889371551c9d674c9fac637a1dfae61eb7af9b332dcf71e23c9dcd706e683dec2045422aa7c040c666e9c7a71ba40c85e7079f1de26f6f793efe54696fb5a8bab926e67d7399a19669c3425e854c208e70494a6f94eb4f38ad995c908dcf2c782f00809119fd3b348d7e749d80f34f5096d593fdadefbb718ce0886b67597a9b9fb4efc842c7e442b189661a79e559a04a7a9c88cbcfef1e9fdc93a9371c51e859097e1f9d2852963bc50a3e36904534ed116331c6899776a90aec4a63c3e899fef54156bc16aa4179a75e93d4f3663cce26083046b90c04c01fefd2b9d4eb1bec16b8ac5fa99e3c99939218c2027193803e6b5a285183677e190c34b85bc35f19457bb32e7d40f5f515037d7a8a9844f36748a3f3d25b0d859192d18d52f7bdd4660c2038b06d9a2f61f073ff10cea1c903ef709281692fbc8bcd4481be82ed6ea82af91ee27d4c1ec9f4babe78f4cbbf65b377c3b089ec3bfe2f2f616f8b6f308234c005913c97338af53bd0cf8dc05e851317e31851f84e9bd6503dbde1da3b7ab6c70e190e8284ced64ca8fcb2ac9735e36a5af8ebf52dc8adb86272223a6c730de5186d42c268a78e8d16b48cd7bf219bfb659aaa7b312d8b9ce1f752f49aac4af827aa5e7932474399c987d85087513f86c1f9205b27c7bf19d2ea1eaf64bd486349c2d1ae745a30a6b5bb3b71acd1e3992b7579824292e76d2f56a3be294a90b31bd69ebb9472404b609858cdfd9945666541d8053681d6a493b6d30d0ee18ddb6b1b1d9662037d5b8bd81c8c8dd1631663d8e644a9741c7591f5ec2ec25dccbcbed0df247c23e76470e47cf350e47d49dc91b54402ef10ae1a401e0f43b0d9a53dfd65f2797daf382e8f966f8e67353a91b377623024692d3aef1e772c46bea9e18c3efe9302a966c35887c39cce046f5bc5daac239d5cde4ecb54f4ef60c06a1685f7f6af545d7d526b59fdd7bf62ba01c80f8495d568352da8fb5cd007d08ce185cb4b06280c18d403fac418dab2de3e46f9a39dd85a9598ac80d9929cb12c70faad06f8acebccd3d4c4c0a8540bac79809fdbc72260612762a8cea83bf958a87e74498aa4002d52053e3828febbe24a0dd9c5a6d892959cb64ce2b6b5fb3cf784aedcc748d87d99d091a37c38ce0c02e9eb6874ae1e4f5d05c1cad43f9b11e2bcffe67851163937469b870124071160e7d05ac466da7a775c66e143910a721e80f1bc7f07f389f1bd91ea53dfff4ff4947fc81a5dbfaed773b94e4580485366555fa63de68d92e831a35c916c2b79ba7c9acd57198087519ebfef206f9fc080ae6b85090f2284dfdf948332daaa8a4e4e7e37ea38a270c6a2973b480160e6efc4b9bbd7a164900152ab199f0fcb57949f79be20663ec92485dd2aa415e8b4695971aaef02cdda02070e7380a2f7f23f7698062a80b5f1e5e8e14582ff5b3e3f0945409bb1550150b3bab20e07b9edfd8a35321c532ae3f76b2901049ad2bfa9829a86fade2b0e82f60fd2191a58a2b2f4ecc7c377e595de7a0a3d5cd873fd6ed7498be6813f80ab596d4f1eb874e346a761cf9b036c6959be963734185ccf63a24efbabfcc9d26945234699f8d8278777f3808563dd0de9dee777bd3e07b558444a3643e8a012aa173225984c8b89f1294f126ce37c7353f1c7aa2a222d516d88fc5d80ed15d74138802c2c966e882e9d1770ae09ac5b7ec5c015fb781c120cf1a28af43839ba0aa4b666930b2bbc7320fac9acd9018071272be2c16cf2771f06f53724f8f5a45030beee1bf470d5c2247f3d09d1861ab19af55397a0dd6f1bcb5d688e7e1db0ea4991ea18d103a61bbaae047f6346b034960a56b05097d87424515c5c59e84961104657f8f5b8c3e62adcc2ac2e0f1b36a4a5e43df4992c8bfd2b7ef99678824badca863d36c4e5af05fc4c0feda505a0cd09b98aa439d37221916913deb3f7f0e2c7ed0e7a50757219230036ab3bff457dd89a7c03a31cc7935edc7321935f8889846ad5d5fb0641e507fa9dc1ad6ddf13f6dd554cd7121b67e155ee4fcee3613f75f96c5e35e6a6db3541427efddc964818b22509f212a2eada7dd87a7f07bb367a8f185b67913f200ff6536619848f05ea2bd24669d8bcbb362173337145695abd956e8d61a95e2d049cca0475868c10654b956a71cb283f9c0cfe74bf20b79f9e832f65dcbb63d103755dbb624280f79198639102f726ada7164b03054ab728a7acc0eff722bc1a6b5f9824ec789ecc4575bb87b870719ff4678c8cf47d2fc520690c7cdbbdabd479e43a325e7cc0a42a88aceb0916c620f1f8b73031128b745d6b4991ac61272ad27c4f6bf7fe988c723adfc510f98b4917937ba93553a329a0a2e9936b33e7b6defb2a9114d1cea171448ad56e9ffe00799d35bb7c03ac6eda13cbfacb3d0b45a00825a86272f44fc75eb77520191450f102bd507611e506c7318696593b588dcbf30f57c6272e784c544177e0d00170feaf5d8a66c972df624936e8d24cd6e19279866c2532d669286d04262dc7e73687a87fa44dd75171e041442fc6514d250d002db4440169626f6fd4838adced31df71d9073a508506f3aa1e4fc1ee230daf17d9eda03209bed0b6f18ed5fcab67e90e9959048660bbb8503d743d9b6158b6259979a680c7f9c549a6dd7cf6fe8fafac7fe4ffaa2ef66c05575a44d53fa6d3031504c8ab6ed3c8c847a28831bd8cfade76d21162aeec5e3677a25975d6d74f1043eb15d6c09756fa9f476cda63e2b7940e3b0eb10032e7618215d54a3c931644ac062fb027c08951848a8f97e0c4f3aeeaf64af22727a75080ff8ca47c428526b4ed7037903bbb2c38da11cc8026e53c2f123f0a3f033ee8aedfef4564a9215cb236af34efea15c36c503ff083fa16161d3c43e3759d851fc612be0d883c98acd700badf6ef428ecd7fa4e10de3ccbe1bf9fd008cc1688eb1251e7f45d0d12c07b73b9fe08b98b2eb8f97b7ff51e871051dfae00ec5d1a58ddde1747c54c914efcd50be2b943a54bc6c7c2e85882be1cbe544ff9547e78cbcc7c57ac95f62662bc3038cdbb27054","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
