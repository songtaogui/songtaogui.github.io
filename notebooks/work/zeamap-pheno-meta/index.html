<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1653f1e5a039d86f421468181982288f778f46ac40504c4d69d0009796254a5248905dd52e6da658fa49a3ca7478cc426b50495f95d0570d659ee17666bc410a6beb067f6c5ee8cb1aab9b4eaa03f7a37caf2eb426205f320f575042bd5f7dcefd4bfc4adf70b3a49c10474eb1487d2f1ae9b18342aeaabdf7ccc47827033770954e18eb517c7aaf8f8e086347f0ec10fef56017b0f39ef4232e1fe1be012644ff00c2cc2e2c929cd4fa1ff934c1d71ad9fab77491ffcf37681a19c5a0649ec7d8bf42fc0e7158889ab95a5f94b5afd03ec8c7a499d3493f7663d925c335550945bf5fb0294f2c4b12d6d922ddde814e580b57ec0b1bfff69819619fe0a3bff19f217ffeb3e45bc4e153acfed4c81325de60a02affd07bf1db0de752c0354c9e2a7bb9de730061af8b70b3ad1a51fc5c1a63b8f9c811fc80d681b6e4fceaad512067c35ae26a26c34fc39981ddabc643375f2f09f704fddde6c7c243ab890ffc794aa5893d56c4b99dabe8fb62f7c467820fa271d7870494b1132576d287e5d5f13442edd8d44d370438f3514c0006f14da5cb5ae459406385a554a7c79282b011c9b4e1bc4bfdd1d2680fd04ca342f64cb4b73eb121d382995fe856a02f24f81bc15800ca5a08dfd2d0b555dda58030180f699d5be2d0fab7286b6360ade57779709c684c1f75de97c28205b9191eea5e9712087781fcf2640b9030babbaa7f7a4ed4d755d30f264054a9be86f416f9091f12ca53096e62e852f30996602102dafebf0ba29735fce0e45aa2e3bfa610eb3e7b846899d893a198d315339790a37ecfd4fb7745aec501862cd21cfbb594bbc5dc194b28814d0aa8520d84d4aaf6747237b037ae0fc3cf58d27bfda82656b0c28b6da6e4da05124335e2dcfba4a0022c04b67a69833a4581c20b5255e7e2f774154065ff2808ff5ccfca6ef5fb4cc1d77054944dad5d0bb1b89c7482e54b64d3088725a29ff58569c53cdc52fa754781dcac16e0a454104ed63f79f5866a3758ac1b0942db34e596c6069e72ef1d78dc3f35b57143aa21d8d7c245ee904d149b4edb91f6d98f0aca0cf118ba71f4af60771bf29d07e4cb9756c6c7d7dc483331665755460344cdf570b6669ca413670e9cdc148efe3f40a1cbeb79da28cc1dac444e3dd782c35fc85191f9b28676443cf0c914976f4208cd141107074da8a960b6b8ea5fd867129c8e69f5d0929503be1d60a708015068bdb83789c95b3d4095acdbfbfc15e8ce047607832d9c6d21f021b060eb2e7f255abe567f293d910adb2f0f62c774226ffdb06bdb13e0f55d043a669664ff2aa47e66449b2d4cdb1ae7f0f20f92bf6a1630f8a5bef5cc866a893feef8846bae3d3f004dcfaa1c615f0679f8dba965cfbdd33e5df967bdc317f7a3f6473b71ab1813c089b6c6dce508a15673be75f814c4bf168f6974887daf6f84f12673f8633928334d5a97f9cd4547bf9b7bf8394df3d7410a76acb4b2ed5a19caa7b2fafb1641f6bb3250413fcafdb84fc90efd934206c51df723d3479f596f49e9f74adb282d03782484c895a6058be365aaf7cffbc18a76e005b866d2ce682eb51b5b6e2de0e876615e4bc5a390d4a76bb0a20d8546aeafeffdebdad781de0ddcdde197d753bfb2ac31bbb013912cc299ae66ab5f91d5914c07c58bfe0dc17afb822fea094168da1f07f45e1235e785aed7415b2f256e6171688a5c6e42ad26eafb2237df14feee257a861276ba110f09ce2b5cba69919e0998489a10a6f350c46934c0f4c87c6fdebe0d764a6e52b804f5435398dcdff50345b9d0883d4977cc5ea7dd681cb1ecd92637c38851914a906d2627008deda9db8ac65b251f5f60a3af74ae186fe3b994dfbd67de3519ac263e4296999d58dfaf9057c2406c64b9b78a7cae77944dfd177d3439246a8759dce15b8ca7e883fa7b9637b5caa287085c730b747e051eaf0b7352a2d2d9195d9a7d416961ff5ca68801601f7946a15ab0dea93d059797417d31409c3ec627b8266750da22f9844389aae6f1ea1dbc7d97cf89351573a5dfab62dacbf435bce4e592630382c6e60b7e76de3ac4b4ad6e9d39d5400573623f171797e01df84fde95fe86d81638dbd4c6c03d4043f65f1203a62d9c10172709e4c14cdd48569bdf505dc8f266f7e7e7a5741dee02e6273889a451fd24cca8334882abc0ec09add3d3e23996a06a29dc10946546b93bfe0f3c7b4befac2b69a96f88585a9a5b68272c82a2d9d4a2ad3b5d15d0596ba3dea607fbb5ae1928b19f58bc2e5aaee83688ffa2cfdc6db2c08b9316a93fa274f54fce878deed44e2332d4f8de17284804ecb5a398de43ba9a95ecfd9acf8d773e3d584feac7a326d2dde433cbd11bcc6231354d5f14c9161d561a86dde79b06659c86e8acc649b8183c2215633386e385c3ceb7d70c19386d913398aa4d9dac55c1681e542bfa05e812aa8a0c9e86b8cee582b4544147209e2280071535a4f13ed5be327aec5e62f8d1f35a08e5e0760d852deaf6ba775655fe558d09e79aa8e1f1a4c6091982451af3d0f6688d1cc8b479c099b757f381278974da159441821ad5eb7762bf9688a1132d89466fc3abb7774b10f5bf33381698feb10cf0ba6e60461462ed70ed57c267fd6372ea0defdcd4b7c934fb44e253bc7d8006e6a3db995a01489ee2a4dfa90b6cc61d1ac08b3a693256840c31f47df5e162d60ba69c0aaf5a944b512896d2ec76f53866cd985af73c7dc38308c42037b2e3679a1473962c84a67c654aaf371942a24d32bd7c9c9d09d32c2d7d3bed5ad4f84c6aa7881e72683dc63f2ae5ad83a3a52caa7d75236b386a9bded5d5ff048ed2d9023291e1cd39fe2aa520ea3873243ede35252cdb65e388a9b085c677cddec3b4a22c35a061a692bcfa7470111d60ae870267c7ebc622e886be06834772e4eeea1df0a5fe3d397c9191cba29e1c3f1d99e38fedf21c6a1e912fa065c160e37fa8b2f4b4a25d4495a27a5741673d7222343bdfbdf3ae870df3459fbaf37236fc48c7e8163ab6ce9c44d92b163be9a498dc9dcd7b43909b8bd166e862f26e79aee337d60edf2507acc55a0faac563bdc79a06aa45d5b5b8b9af09785f9a440066de51a4982638bb712e65433d45a6007ecbca6f1caa93863199dddbf67bddd9138845db58e8addd64d35de1935236eaba4acf6ea6d7dd6a92be2dce90201bba73e2f910df979a1c623bbae70a2a946f18712eae761a12e828ff3b88d10426a453d2e2028bf3a263c6af404c4ec58d8d25bb1b3f75d51bff8cf1c6557b8ae6bcb32e83d2d7da4a6ad44156f4d8aa15c267d59a684cb2b1bbb49a7208717194e6071f454874924839d8bb3d86a86cac73615d26b1be9c51aad457e52431d9035bc19e37a9a0a035b96b1c8e22bfa230f776c447b64846d810ffb2802bacef1f9d8cee9b755b0f5d002fa24fea53f713092f14886db50f8c002605f768b34f3c1f4e3358b3ce9af567957da3685a997e6b47266275e20311be869bf622baa864bb76afc78e86e79e4e33538007902d290e4edff452befc34c0e1ff8709db1fca0400d14e665ec34fe14aa429de78174f535222c495781cca9c3011dfc634ffa90cd63ccd6f4dabd67481b3a1261c12ecaa27c717c5e03466fbc52764dcad275903d96a4e8ddd0030d3bcd1d06aea7c44a842dac8520f9f442a0f727bc978461eb09a79281529f04eb8ba41db7b0d6c35d8bc87f9c54f601a0288160ee8954187e8c3bc62029e46d56e5d10fc063f5b0a6b9738beee1f4cd07c47b697cdd44433e3c28ea5143a9938395278eea467c35833605a91ad3fc8ba08b5d144c259ce78f7386764c5510394aa97db615400406929e218d7856336791f3bf114026a4ae83a096b18e3e2d65436a9ef6cd4df3a8712b273f7571c4181f715dfa72ab105c3a48754c8681ac507dc5f7cbf46e563268f3db949be5be7e742782f139f5bb6b8a4dbe3b6118cd9fee2e7859e623e740806dc4ba09b26a2ce609a17b910bd392d6d71dde87a5c45a3445303dd77355194be88796688b25f96602da80266a7f8e3be27a093e6db438a5aaea01d49ee851c4ab05a944a5712138203b9cc236f44c0b39175e84e0ddec0f65b114c16f078cd648b61eeb0fc732a0dbc1653fce3902ce3f607df50f7d631cbe4e9f53478caffc88f916075cb8a59c9405c7b27a06499680dfbdf698ee2fd2fd28be5e59a3d9b08d40ca87d38688f16fbc612c33d67bda0430317c01c1804fa4aa666428d8bcc483f9949917813d4bcaee5e2d29039505af6d1188f415eac6746fb897e3274298a861eff6f0a9f53b9030497115900793d2d39cf1696144fcb5dd4dd0ffa6c86b209cb121b5f3263ee52f1b58f15a1f933d16ea706a5a3fd8527158e06a0da508fb494ea7b9c667946c003c0f881e7c943f320b80be635280c9afaf7a9c52b69c7a674623ffc92f19997cbb4b9f2e9ed720987840d84a0620e7f020b6035736be0c5ea5b1a485ff620c934fd8ae185a28f332131308de5218c7029eb79582e90fafad02e26d518691969d8df3a654d6d243e26143969ee61c4fbc7c3b4f0ab4f7f146cfc2f6f802e7996cf423753d5d4e8f3d82414574f3a974b95802fe5d84e3c7178f0aa1a0c3b3e8523daf38f01bc549247fcb65a3b5f5406e2d1bbdf44166c1f40ac9e9b373eb49dd4570bbece44ac3bd77e52cd8f9231416f0fd46d31b39d347f73c6d36649cdf69b64ee39dd25ad761e751776ae616a114736bdcc1a2ea2e387977950d7a291556e9ca22e9a2086b9d29c02dda1b50b0bfd48b0067ab45000eeefd5661a7f720a7c7065025c99e577ca267ed99201207a32962352494600f7ffd0de9caf5197bb4e9c394f537a307b206e60dc20477d765685704247cffed351c4f04087b9598e52ba54302be438488e5086cfde7ab31ca6becc44430a7346174a93bbd1b7794e5aa7e3d84959a506f460a78ff25687ce6a43f2b320e3fe45becf934e725d28e9d6902de176b540e10a66d4d5ae66b90f23416d5b00b187b26fe14260388b3b47d780346205b00a72893db18a0e4fdfc3879cf106df32c506d6d9b369e9bc74f0c0d5ce10f77187f1987a5870bd8e5914db32b9cf8cdc5095ee75e5a8a04d6656bf1cdbcb5f45015832f8b93fbfe6d55e71eac0255e7d5cfa31c2214c0545e5f4051b3395e32450c0c93505373bb762d00a7d539e3201cdf4fbd0883e407f57cf9adb4c02c98d24d40951d3aedc54251b005aeea7c2abb734dae6da6f726374f0358442b42d9c9fafb41739e9da02385b722d646849797e31c64cd6033db063c96420b6c02801c247b1d13787751f7760b6e28def7001de4edae50b4b4c2d08b44bb11d98732e518ec33dd8ce60056be91de5268cf08f9c4192980b9cfc75229fb7d0859323b222e56f5277b42515bf80262e4c80ea3bf7ca9a2089443d44658f2693a7f9b13e2a25fc771eb9e74931cf5813561b9ebf7d0f334d6b6fb01902a076df98ce159918b97836a99cb85ebeb0c1a8ed71bc66af910eeacb6dcdc91336e7a78477f23a6e496c3a829d96e3e3fc0b767d84d5203399fbb299bb144a5bb6299aef6402ad474f3b145881396bdc3374c6a16e6d72d9d7925a54a162f58e30a06c9fdb8364404f8e89d8e9a065af9564cbed9cdb8fb7382d5e0852e501b1e9665a5d94580932c22bcfb835aa72068e661317c42d5ad6c227ef0789f8728933cb0699ff830d8c0aa033a3a6929cb1b983a763a59c65e257b8c9f30c6834cd9a5702fbb643c717fbe1869be7b6046770bce4dba4b09c97d2ff5355e9747d6a46eaf3bd09653446739109f1998b1301b567c0d94aabde8277fd9024111079bebcac51420ef910473cf15034b7c7804182926cdaaf0e3ef4aa67cd2b87881dd66ac7fdce8a30ef4f2ea72dd485b888ff3c47a74c70189150daad7db299189ca8a2aba72921a0f97eae8e2ad20af284a2dc5fc09800e06a37818f3692a46dc6d01c6557c9fb6d713874c8aa3878e3d8b01e57c6cd6df508239bea14bb96982a1d2cf2471054b945a209e1769c21b74679cd1a713a14d75256bcea478a24bad02bbbb7acf097f2fdf5e8ebf85a1c748afcea714b3c2187147e4e0274786efec87a6a55ce9971f992f16adbadc29fd38d7f85ca07520e13adb3ea64ab791c3ffa2d47114fe3f623ad8ea10ee98f576022a23b9c755d651bf8ab837a97954777f3c2cf0300a1db42bf70439cc1822d7879a2ca23c76a7ecc314a597ff34665405bba38e087ceaf2ef842dfcebd4919f7468e6e8e0f4b4f455caac24a1a888d2b7eaed3560b450f28569ffb27c4e88f540bd2ec1fb9bcb80d972a817d3be2e3c70959b8ddf0ec1621df1cc8e6e299248f8d590e75cb39033b98257785bd2d780a1a27b26408ff920863f971fe4e9aa103eda6e2b952d20cf907400d92d9666e6a5b2ad7c813154707c854429f881305e22f7420444602e437438164b43505ec73b776e65cb5076f3852055bc87e9cbbb7a29c14fd8592b3d0f08ef39325e9328c3fa7e7f3d92adada6a23c05efd764ffd2ace88e3a85c88776336804a741ad14896edf5113797e9f91e601dbef533995d3f3d86254ea5b7b9f0e6a72dc0c157214f57594a1582fe736b549dd9a36954fa06bdc7a856b6091cc485259ce394e8be4e82a2b5e2a27575812278a4d719f14a413c89b1ffb3f796ada283db5911dc18684abac4e896d877cb001bb0dd4509b4d23ff3e2fa08b6439ca1808be229178bcda6a8f476e6ebb62917ed8da19fb37be3648f5f995909b1b8341cd6f433264241fcaed7205e7d7d5269be0a91e4f262f74a69f06dfa588ddd9972024852a0fc4c20c65186a07da3bd44488128711a12dea741f7fcea6c5160e6c9f10e962322f109aaba914038396ad3422a966781a291863772477da5fe936946736a1ed41c474ad6eb3dd2a8daedebdd45147524113da6976d4f1b39c0e280337cfd4f94a061436739deaa7ec55438586cec960231c5971804017ac24381d9ec64c8acb2ea70523b23771cbd18b4c52d23234fb4105275827067772671949b66f5e2c49363d35b86fa84f796dc59891866e9d2ae724cd4d1af115ac813fc94eee29a7ca10c87a216473427a9c5d767f549ff8ea267eaa79a1c9ca39b39e9f25af10377780528e8f1d061cd821cf1aa66ec78e1b81146c112b3309265b315f20a9ea5f1803be1c4e2a93d008dcb3cfdf774f53e57f121179e1afebab2e96ebeea631b75bee099a14980cdda842917a8037e11ccdb19f67248e6fcff550fcd03c907c379941ced8379b5591d5ee7c395a94430b5c226958af4d6f55148e1374bcb6f73578d35df1a9c9f0176ec3aabefcd1b3fbf48ca4f562ada103b86629abfa9ae678f9d3d86f71bc51e7f6051330348cbc168c3018dd51e18a4e3ccd400c0509f7a5e31e3b58a030d3ae001764fc6fbcc8598e19c617db11f2db172031f17f75a64899e8f9b22872d856dd1384232a9c3a2053054044d67bfab1de9b21ed6a0be084186e0ad00439e2bf6de551306489412b3a0c896705105ae4f85bf8f6e5215696d0f91ae8000dfb66dd888a951ad3a56340e547f2a7ec68a97fc64e5cb379f1a915f46d61d5c98287eacd244474d613e887853499666970167b0e1998d21add85e5e71b65ea43026c54f71378a5b3c4216e1dbe5e954c3e54d1a6df42c44f05396edb0f609b710d7200f8a4062a1ee1f149fedac05cb303befd8de6889c2a20267bbaa5161f55b02f965588a391ca76a99b9e8c3a649fcff719be3ab44d062cda017bcfd4a7ece895c7298b10ead60890f13da9985fb7c060fc767221df844affe83d9b4dcdd5c7b5dc56cf0c39ce8aa0f489a948b7490d5375a7db76876adc877acac25a63531ea02fc2216901fdaf2aded283ec30d1f92ba738b26b6b283b83432eb984cfe9a6f1f9ee5f9483d5cc42f62e1aa2ee27a1d03d6c826764d0336fd8ad290ba8c370a1da7a1c1c3da7f0bd6819b0c0a460f9dfcb636e599130e2473ef3d5ae887e73e33a4ddb7a7ea7fa5b6128d878e1bc2df701b2fa0444cd684721a47c8185285e8d4ce19d966ce011ff5c0dcede69a1425ab0ecb29f477ab2b0acb768a6ae0bbf29980a745f5e3b1ebce3d210f9d2b82a620bae9c682033901364eb27a5a9cb4d37d875d829aea6379f97a107400c748451f96bc5d0f7635c8fba39bf5ce8abb89b5acb2aa5dbac3eb9c09131ce23b31c2dbf15fadc80cc71d25f18ea1f61b3c40aed1fd41bfee527bee79ae6f47f172d81249b9e640a9907b209a89fba13f1804c3ad66786eec15005645397a5ef624910eec390208159aa06da115396a8c9d34cb4e68597a5bd5ccfe40e72a31c6c47afb262fe030a5b73006e7a4266a4e29332f14fe0dac6b02c7745a6dcdae9d7cec2ff1eee88e69bc71b0e15fede28a71bc10e5f72ccf0239ededd8a0d4efc17e374e3b447b46d83ee1785ae44a0ce9ea79b601c58c66cd5db3590457e3357baf07ed3eee357d8e8bf01463f3f5a8f4ebe38a16874c45b382ce5ed2edfdfe71abee1efbdb9351b0f8fccaa06755aa4ea9eaeef4b2eeee93b069078d0e20dacf8286dc1eb2dc7c4b25f0733ed2c9a24ce90e5243c902bcaa2808c42f9bf93045f38477956a012bcce73f73a66ce235787744eba6e857d589be3d0e14bd20f496da4c87f144ba49174081bb949a62b567b29cd115b2b160e875ac0deec186ee47b69c5bedc66265dd5c7b04f9bdd14d27363bfe5a4d0233a802ccdf3ad5274650e6c85617c87e1847add1faab36a3babf07f09e4689bb00f694d715c4aeebeac33cc4e9e1788ffad0a42182db0637a303a4f195575b5b6f855fc23a9ae3c4dbf950e84673b5796173a65c67c8d6eb02c600d6678dfe737d77115669a8dd8e819e3efa51e87cdab1cc0053bb8cb7ac7fa4eb673a6b2892ddfa959ed92d1c4ca07e3631f6b2622de1c3e50e2207a93c346d47cef7f663b24d2a8a07b81519780a374c22ba492a754150dc7fb61fa6976990c9ecbaff818a8b3343eca87e38e2e202c634ceb7f0345e6ee3dfdff99264d1d3d9553f045b312196acf45159e47f854cad9667b4147837ef8ccea21068e89024b90c547989137d8bb90f7625a981d27d4a4f845c2d0ec1072780d30fcf959c2788c223397ffdd97b669f15352af4ed2e877ca9e3ddce87f7e282f0c6d8a0c87c46a9d46de29f52bf140547eddde65d4608de859afe08401808fb89a3535098e59983dd693c5eb7622275ace41c36371f70f9282031b7d595205bac916a1c8ee6a470acf2b10fb9cb09848c7afa56a97245dab31764d5862b6046cc6e31f77570ec57979d043244327ab4c175231d38184ba4baae81f647568fd3030f144beb3059837c29fe3f0c4fe09ecc31620ab37a123e059dcb94a44c31b34225a734d611a164ef9f89c66cfe4109a5c65ab541dc1eedaabdd7e4c85298816523bd489e2f8fd2010cf644e2659940edbbe89dd0476116bd6c68ab687166111d45007951d0cf149f1140483a63093c5bcd5814f77c5345657ccc9b90b63007091ed5cab822a54e153f8f093f473a98919f405fadbebb9063e5458d33c726481425ed7361ff8c3a70be2d45dce56885cfd7fb3f1f4038eeac1135d1c588c2fa09a8f1c4c97e3e0e240f3e8a310420d3b9e660e2bb7d0806d57b9287c3f2fde06ce7f99ae21052cad11cbd88fe3225a7d128bf557cfec7a955e97a942cdc10c2949ec0a015b6b0b2b0c50f98346d62fee602957a55adc240dc48a52d82003780009b750903739c594a65b1e335661925cda20a06e386cadfe93723ae05c353a1f449d7c73f4625c842f680c27f4893d0a079ff7c2689803c491ebf499a9fbacb86f105cc4592ce7eec5a62a987793eeb8547f0a41fa4fd507ec489e773518a955f4e3b55ef3dcac972919f9b33b06294c7df0d6139b1c798a350b64ba6b26fb45a8648b5bd7e7de16d82b03e19648673c56b2fac968e531875040910381b922e6ad947ee5616cd504b0cfecf11c48fa4bac29b04cdad6307d3b07c45e226f91b934a90d90c2bfd2678a93d6014cac220868a2a9843e88933822de5d97e7cc6b7811cc47fad354ca8bd9983b0ad3e069df2ccb94878e70cac7555cac1189f21d99244b310792a30c8cffd2604561639f458ffb05180023226eb9e9f3754ae3b38e9b63d50f874a6e7ec10f87aaadb8d5f7413c2eb61fa2d76e692316dadc952908bb0fb0ac5471093da85419eb8a2f91f90c498613aba7d3c6c6e1a33d9b5b578d4df87113bc58b9dee8ec767ba8cccf02ce832c90a18c0ae3e62798fb6de3e02a3f892b3c8e5deb8859b4dc05a2f2ae16d01f53facb33f4c5e73d6cdf688d7c41994af0eea0b9eed983e135f37e498f433a05af28f8ca1a4f1679cf554332e1842276c13e7558f09bc4372f82ff97c1ecbb68af0e5a56f3c38417b597745dff7d52e6b7002aaa4e18685fb7c24b56bf686d1909dba75fabbea510766f9279f740f63bb102e9386eb659eb23c02598d30dea905d995585072761568725dfff3ac06ea2d911727452d32bd90fad3ab3e8c2e47e00f10f555580f57274536af1a9be3cada6d795df0e600b6fc789bcfdadf05ecc19bf21b14666071967c596b5a15ad3d4e8980712276fa02aa57910b9ddb1b52ee38c7bfb21bd28396cbd5438fe5c668c5ea4bab13f7e79b1c8d820f3f830c0e60e8152042e3e0bcba3f6b8092f1722aae93b0d5b60f845d70ce8038c421b12ebaa2f6bcb9e8dff5af73518f1b2d22a8dbfbfbd12a9a377970a297b9184c1e445d734e800bd53140be95a40be427579557499f6cf6c57e96c591c853727ca84100ada33fa5a399ed90de7821d73032b3bf467e365be3007f4e9d156a2aa2ada895938cb05bad4d7ec06c10217a6e8e138d44dffbf0a68b40aa16ed5be6fcbb1d597484f8427165f8dea2e6c9e86f122398a8a99b9544b9347e69d6c7f3b76ab4211977575c7326015cc969c5a2d578c81eeec0b2ba4a3f1296b4cfe4ef19ba4fb2932d683f8f006856682d24114699495167cd919a5eb8bc7180f314d33f55da8d804791151342f6e5878713b5562b46505bde019e7c68b11f791f36f110d44d1d38212d0d0bd7d01dc663f3bee349e1a9c652d3d6c0163fdf1baea91441a37f479f3c72f13e27a91adeaca078ec127cf60d95b2ce517931fe4ae2e9d1a4fa1bca4c865ceead2c555c9385e98811abaaf2607868f491b78ddc9fb5686f9d133969cdb208ef2a41c0cbaea77afd0f597b2251bd462ffd73dc1a6b7ed24321d7556b7508f7f908c8aa516943ed01cd7038c1c26b3334a1584b1f8562c4d2b2614d5a1a517592eab5daeff4ae0dd8be9b23b53714ca49cbfdc4f6aed03ea04c547bd28ffdaa2776959cfa898505d08202f70fe767d2ec02e22b450dc28c1e127e306a70da4c3bbe5f02bb0ca627e127814f717f4b7b309d9b115252af12975bce90612fa56abdbf3383392abb5f21dbd3d298d4c23f7c60cfa6a4fddb33ee25d774ad2f4bc38861a54011abf5c4d2e26680c27c15683d1e194b2f888d34ed61847fd127c38683b2279e6c9f215df428e959b0eab0c66979e1643d32e511dbeb1a9567f1163fde5834b116fbf712467f0fbe4a24035fb9a150b44306445dc663a25e7766664116d41501e22dc01e487b585cd7731678d2f80a73b25e6988861782e5a0c0c6819c3886240a97a74d8b5a374cc2f0004f41d6ef64d7f6d1c7b907696c781f7892253cd0fcbb8f298f02e4d475888da6fcd9e72db694831ee7ea66cc04a5318e9a305e85f5d75cf6ad2d0210c71b499796359eef6453524c6494bc9ff90f4c5de8ac96e07b84a3819e09bce28f6d288b8c17855d1bf1d7b008c275ae8caeb3b3faba0d03bf5e1a64664274732c7a3701b0655ecee11114c010cd402d404c749a17f776f4d5d6e42125c16ebbbf5e897166dcfb03bc12114d4047a9b544772dfcbd65fef0ad1c2e320d7451999c9622611a71ca821e5d852b94f0414a0db302b47a7d4ffca7f9d48d9e83c75d3edd9f29a450ad965f7a9260a38f5a85e12b3d570c30190b020b14e5647fd4489be61c6b678436a0c822b247c26d4781a127c9a3a0c272a20594457a29cb2230503ad7200b98d40b6f7bc9f2ff538d2cea5a00073a16b0d799a5f4be83dc0b4fdb665c1f299c2f93220b97074b1efde86eaa88aead9a3f89f6d9c7f50aa4a12bc7b91d864025a9d5aef76f60292c8102b9dd2d5ddb98e8dce99f2e8ac8c0385ece9fdb3bd1d0ea4cde4ef1a68140def5fac7e317b972a1cca2d8e2ef86ab3da3de71e20bc955eb1581b7e25610fc175c0c67d85e1548935500d2798d7c69e8643e1b03e88671d37ed43e1f82d14acf6bcdae9c7fe63780e3f5a5c5bfc66832e27ec5ef999f9e8efcc3cd39b78c89bd49c692b59c9a031c2fb76d9d0cd2bf88ffe5e733f766805a1cb91a10e8f5dc1dd615515eb09f419f3c69be0bd03ba8c4998b9dc6ca07b8870c1b8cfb4fb55d5a6c3eebfe88e616eabbab5089905b85b8058d2e6e23c7030cf3616c85c3a1d59b24b88e08d28fc70e1c5e85f438aa158acdc334c32de0088b89caa4eaddc3b428ad86d1d65c1143149a71224c12a28209c33e9b94062b2790cf43d48c62b27a3f3cecafe05a72db24d7a81c65eb237c6d9d20328a1dda669011ded762466d0e9dd325d7f8e85f8057368a4f4ec7dadd3ca32fa8a92eadcf79dfbd57786716677e831bae644e3054b1fb795802b2f726ae23007a6d70172750631555d8dcc867d8eda5089b00c056998e4b4abdea211d5ec35f3ac313faced6f3ce8fbc4291a71bf068057cc450039f20a7407a9b09b403fd9ea2abd94f604e845a3f01021173006d62edb2c5f5528e9729131c60387dceeca4c4992eb9892e1d41ae358116c79c8e51e81a43407a888035cf8c8ceeddc9c89a4d2ff4fa0e90a05a43eedaf8a964db65b940b9706996521f4a7d5fe50fa9b000bf4b2ec0378d55cd62efbc651696d6c4d7f7578f999f637b175a05515a4598d1960b4641d3fe3f1dc5b78bf53a35add2a2b5be1eea3e2c47f0844caaffb6bf6a0369bf506ba05d331c077436d556ccea0d29933a6f59d53a185045a8f57d66b4933adf5080fd13ed181832b5269caf0fece73405eb0a755f6313df8b95d47aa9bd531247f1206fc40934102e95314722da839bbd1f64597911cc154a977422b230a613abc697639439c66a28266ae8d5cf8eba7e5943fb978e46beee36ffdbe7e0ab056793192f5a3d3572a2dc6000182061009d2131568fd49fc8d3da43ef002a214f532049db21c3c560ec46f9b4f6fd7bd1621ec5a5e2020d6955085c64f838ec01f8a352bdefd89ba449f0b8803e99da1428d24b694cc4a199b909d10fc7dd4a1256be8a3b82231a66cab871b6648137d6c4cbe69b489a854f5a1e86175aa4b3fd544e75b7c3f086887746dfeb35df41d4318ab044aac8aee1a0d8dbac7e7609f6add37f03f5bd84128472e79f0f09ab9f539d0f53076bbcae571bf9f3ea0fb50ee365ef15e2a91e01328a037b9ed55a5f0af1f1eb5ead01aace36a21a5e7ca815a9ccd01aa768e572f52850dfcebec9f2d51977f6c9ed4ffd1dd72fc341e84205a82c63048dfb2f88abd372ae9c50267a3ce0a6c5538c1ee69876d8a864d2a530f0a49362a7636787aa1143b64e575be2a86016352fae030dc3f969578c0bd55f6f82d683a2f274d996d0103904de5ba38e9d7c88a35e574ca77c774c1d14503e8f4ca48fbe5295a73ac6a5290d099e22ef88607ec31683e1bab37179121d9cfbe157d22b16c1c47d4a809a0588f8e3983097685ce08de007cdb6afc44b5c0fb78b7f8a4f25ca3d48b707d6d4abf36b61002d8345b30ece4b38d750d9e3c91d72a1bc03da5a3bcc9ee3eb02b6a9f7e48ca07fe59f6c409ddb1d44fe4d9024269a8962e14d6efe04b33251e40707d0fd953865fb72756e121c3600f97ab102ff0069c94dfa78834d62e4f4b2d016b281c954f3be6f7295a8e4774418888103818363326a77526f6588d0bd6832ec36a5f36dd6dc5a07b353c870454a5842228b34b1a2884869bb9d4ac5dbb2ada82e9dbcd562a9bfbc79e068a270f2c254285dbd504a59aabb35beb9f482465a338afa69bbed9ea252ae41cad4152a2736c970f64e45a59493c730f494b43748d7ac7f3822260f51d3799e2c2be005a0ea150024a20926ef82af14978c8d7d59b6ab72f60b29fe9cbf1bc944041c3147798d7cf818684c6bf3d08c407b13eaf83195739753736e15ac8bcce948d323de01960d5317e8737061c6b45a43cceef1ad040a942c62bc220523dd7b93b5189f51364362613d6e2ff875368df49885d719b6bb1b2b73f2d570ab893dd77c4c77d0c607b2557f502a29943073b307be53a70dde1214eb58e8c748518cc0fc6f8eae3250519d31a8e5ccc0f83b0ead039b85a974bfee8620e4f56658bfd116aac392a91b0023dbb0d4a1e565fa8275d53a723676c5ed4ae6ffd45acc884b7f7b56a8377f4a9f16f29706f69da6fc1e384a02498e730fba2d592f5e2625c80a02ca3dfbf670a7ca33d365cbc911f3d4094cb2b270449d3d979c9592015f0b4abde3152dbdc902da6bd1ccd3be3c83e3a62c8f08f59bd1d69f5e9aaa9b04d5f99a34c5173fa7c11e463c8bc501b826f59c9f18ea40ff39b192f7c323025973242801e604a2d583e9c706fc548a0671205b0bce4ef9e2f62bf90163bab68da43f9b5cf9df082ec19771054fe704e84ab8f0e7ac309a0ce647621ef5912c056a37a22b4753659060742336842e2f3c983c13655cb740eccb2e214cc9d4f94b9782dce9638745ff2500690d914109d182b28eb74614d3b5f833e747c194d823330e707ee44e0801832fdfec8ed64a52834b0a823fdd330d2c27b62b1ef37e7ea02315f044bb943c3b6bd098cae492731f63c6525cccb08d74ba62a8b541689a1bea8c24502ba67a2080ea6087a8dfa61eea0deb8c3aeeb1b27720e918d5536ee6599846dcb7ae873275324ef2312d252e5c3d398514dd3b8238c730b663080eeebfcd2e06fed36668c3a8c5a72c7178bcc53cbdd13e4b91b16fe6972921e91ac3e46db7a1d3bdc7806d541540d08689a0a74db1e013998859c0db73ae9ded6895e481d22f73b84eba0aaddbdfaaf92741efe6f9799840ee9c902fca4d90a22e12764e8204111a56208b455f90661be67bbcf02d5c1d9cb131975fe373302289a91d679bb682bf4d7ae9853b0a9dd8c605265ba4e7e4d1e2315b9493515d179fbeb4b352c074417c01745bfa654c974cdbb8fb47d1d548ef151683ce3601b0ab661f903eadeb48bb4bae6ae7bd4f99d191a983c5220a4d5ce78c0faf082a097698af5cfa0f50332418c0f5680df75677ee5e4bd2c9089da5231a875dadc7d2cfce46240a39013385077a986c4a3565cb809b46b287f7cc73ac402ce8f855b12437440d6d7d8ad9688c3fb34676af28368a3ec5e6d0d225c037bba14da05be0e0580c300022629f51d3de74e2eb756fa91f9d031cf44d21a14bc8840a2108f004bef26403aecf002b683bc871393d7e7e0a272464622eb07c539543203e7e9247d8a80ace2923095ddfd3dcd5e14993e393a5b28d5c619b793141bf39ca6edeb0119d3f10c003b62f1dd63e83be3d9f8a98ea1c54b2295830e5476ee3bede02e2ca2d09d5adfc4772329208659fcee4c5ef4bdf07c1f290ee55175078d071f89d8cb4174773af9465aaec376002eac13963dc4b253c182dfee4e2ce608dcac74d76d2e7bfa9c666bd78b6c34a156371db8025752cc7e71b2c83baaf5ec84544d1fa5d98d614dfd18d66098abf719a9100c2936486f522b64ad74022d7b95f795da1a481cceabf08806c2be6a35bb7495d85dda9fc5bd7ff45895daa391a98c12a129c2d2fd303dc140fae453709415e7727f98e9df7fbdc8cb18862d4c2e0fbdd6208bac255f5759d4b799f4ecd724770850d1cecfc7a1727ca8543466958470f2c037bb71ba419d1815c1350d03626565c7be30957aa9b50e942c8228de63aecd9b816d87904f56df0d65b84afe6fabc6515537996f607a3696a55733d09a28af9dee0b685a50091270a3d383a6ae8f4f8f588b232abb5a62155f2a2819329c68575e21dc100ba284494432140581fe79f5d2a59f26080039a87ef30fa2f8433e2e1fff49fbc4b20c46590dec2113b3a000080c6c6215fbf9efc12ea6e12f9565192a681f38f960c5e97ce8b0c41d9e25d2ef8d8afb6547a57523afee72b5a9f9e43b7f854d6c67167952c0751ba58e27b6f99b80e938e2770088a5b8683f3fd78a6028f44ffea07d7eeffe0e73e1dc1221b0b46eeb4f4ee7ba0fe0cd9d3f427b640c04e3ea30e0d9609a30049d4cad681665648c7c7edf61804dcc5a61ac4333e4cb7c363c80feaecd15df6c63477b1916b8e30ca162919c45752c589a93d22567426cd1d2e503dda4fb25249a27de554057283309b601ce9cea23d6e8c2d9dff2c8497a4f262e4f260f4f42bb499e4cbf36c3bae80f282eb459c1b80a99aa31ec37356b13e08d09491e8705d704d19575d375a126b40ffd2cc9f57457386999bf08a53760db02f3f904cc639e0b2dd7aae2da039773218b29cd66ed6d2bff875cd04214eda0752828a02822a95d2eea25895c54e9fe6957be02b93a6cbb969e6a3fb1d1bf4c77d7a03e9a49f87f39253754df7bba5d99bb35b6c70d1ea0ee3b41db7d3ae31cf1fde0f36ef783e67f6389333d2a3e6e0c4e1c28be71a6513f050f4618027e1392cefb1ec36e17642f1c643cdf47926e5b08d6301a31f810f35b65443f3a7f4ffaafdd1e72b858dce87834003e3d0b8c90a28c9cc856db4ce4e820aa8395c8f202cd7259bdaa19544080bce8658053cde112001cce3e1f183a60c9355a99747dbbcd414fef5ad9d4d38ef320513d1d9832cc07fc8e148bdc3e795b4e07cb1bf478535e7f3dee4736b8ff8bbca06a47a3c36d1be71dc38ec91bc41ee5ffa1392114956e8418e7acd1b75394d0e9eab80e45a8c37cdb21d32a30ec0d0f3158bb31f142c0d96b00b7854321fc3010cc3d6b229322fd843623fd25c5f452051e22f5b85d713b602018556605bbb077b41418f9aae551a7fdeaffabcc172ba5f0ee82d0a16bab6f2261605c98da5e7a3632ced4608ecf0f461800d0d160e190d25dfde315abca96bee20756513247a7be0f5ec21663fcfc3a2d2d42e9ea1f363fcf43212c5300af2cd0d5df8009bb83fc0883d7aa72eb2d3299a1c3703bf1cf0d390fdef146db7728bd3386b938a65edd578a3080b805d27a7035ef7737e489f47a15d168472890b8453e19c47e1b7240dea310077c2b359f183341f8d0f6a35603c56678aae97b706ad23c75b632544c828209db121d38c0770da73b8c7ab03d701f55486e73f1b50406a74cca132b7bc1cef24336822aaad00a3114324f7f6e886b2dd34c564109810559178e649c67345225c5249eff12c519b89bf55c3de931e91ccaa273855116c06403786344c99edabc49ac90209700c0ea2dd65cd80dd4fcdbad44f5ade71dd663147f367b43b2b3aa8d1075c1fbd1d45e6df8c5ce55045911f85767d89051e14329b540f732c19f3a585b22fe4efd502c310c7b2eb6cbb7653c19f759098d0365fdd2071425bc89ac4b0891a70263ab71991247aaba4d6b3f4069d4e84dc3ec6c4ac5d6dff9a2487b891dadf73ecf60731d4dd612899e1deac26a4384e82475a22b37137087dadc61f3f52fd9fe51e2d89a28a78e1cb39dafaff592dfeb2db9ed41906278f16fdc5d09273492017a0c7ddc8451e32357e52541601b1112b13af738fc6a7a69ab1a20e1408143d2d6f90481dac9ce788c8bc42f82e1b089f275f13706960276a71ef6ed804cccb7fb9bf6411814","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
