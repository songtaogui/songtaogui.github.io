<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c31b7fc5565a459e661e14b86f049e96974efeb14f696817de86a3e2c37e93e71a896e486f1e0e83503b6ba9e05cf6cd5a58c83c99ec0507fe724edea85d4948f5432afd0a23edb179845befdca45ca650cb95200e42f7ad366313ee3934ed9daf9f9be2f6975426cfe7e8cb35b5e357f5211fced0b822212f28e400e80ea404dacc587bd6103406934f54578e673152969c663f2c1f145cca8741fb275e486a78f1a9e0508335190051355f5690a9c22abcf256b2009dcffe9156b5870f890ffe459a4473300bac2166921955a44ec6ec8acc68ed24d110b1622bf9b9d4611be140311a7240807cf86a129ac0944a7197a1fda01001710e9a93a78bb6185b7b87317cb5f2ebe5aed6f9b17150fc288c5970f65d664f948ec5095ed638f4461e250017a61d829add4e42dd3032bbaa52668a45d6d6673c769912dba6ebe181e26db414defc5d74062f43830533489fe8d94007f165ae4bf9e81e88eae7217ede1e7b66c7a345607cd69d6d8621491dd5ff6835ce8a52f1d62d749ba0a593880ecb5289c72ef752d785bad13cc3e5918c3fb15e67866377f7d2451fe99e14dc8e7896e3e884b4ade049b898a1a98f7fdc010fa83f13b2a3f4de171ee919b6fbe8295ef3d1906f6c5c601248684e367e5af843752fe1956570d0efb002aa8fff2f8853995cb6bb37ee4d52dc8fba34f1e4a4d4f09402c08f2f3fa148aced15dec71ed342cb6f99fb7965aa1783f30e1884f17f5571942133f40327b77becc99612f9cb0d27a2d448f07fe2d1df13bb095555cd542dd4c9800b0fed3b32ec779601d5d242ee234915f16e5f703c4d2efb2d451767fafb88dfa0111373b0ef70cc2dcce5a1599b27601dd5800206cafaa11ac0411475e5819174b49bdc4651c10d5dee8f69d05a6efe0d3990b9f6075cdaad1ddf0935412780ce0173862d609322115974aac6acb0f4b51f2dd09ecf7128142aef669f9a332cac9265fba494fa155a001623dc1a813d8b5657f07aa8aae5c442cbe0c5c97eaf91f75d014b01f212bf2795fb8d0d2264f2840f360de395f48c468f1b4086168d16be255f6edf31f94b009308aa18912d57a66ed145260a3a2311511d8f6a2673fe5a9d6b3881b710958f19e61ece592ddbbc57d770c0ac836d328780312e4725165293e8cf5eb60bd5e73a5d6530f1f01780f1d5218c18135e276cfb25203757159182a6cb60fe4de10df01452a0a56cd990011e42f2e8ec7d26b9b6c8f8f9f533fff104918f65f4292913bb2073b3ddbd5a7a43169470eb8faba6c0fbb53b1658e4a4427476d14e8b489562fbdb285861233a8b93b83acf785a874c317da68767132c8c0c211f08ed36605d8996b0141db20955e26fd2ee63238f7b27157de561ceddb879ea141794c39a7f31adf955503b8b2cff745383814de17b1276769eb7a04e5b1487bde8ee65eaa7bbd636fe8cc3cf58a0cebef0e52d8bfde83076ae08c9211f4f79f3f7e071ac2d560bbf57d0a91cb3f680669c8d6a0e8fc33788851806875bad5dad9f592b54d163edc17feaaa7786e5f4254f12f7f20263f41d9844c20256a36082760042be6a3dd9ee9877c9b340ad45a71e851ecfc8e6f0cfb51b9d8d8c14d7a2e75c49fb44ba9830239b8274e2ebc53d4bfbcf8559c50446035cd0b1f529723e0a83e0fcb285c7fd08f2fc78774c47296c3abe20ad667788bc7ef21b5fc91cfeb88220f52da4a9b95867377e2cabcc1e0cb96f4877aef7262ea85113229e425199e5497530ba7dacb515ce5bf86117b9c36ac10dc8f764126433a86b1635f0629559f4b08960f1794818a5418ecb51502a8580ea5208d512b62054e860a982eff5df277c9bd82eca7d36a4b1436b730b614dbdf6da4aad47885832efce45577d322535610655145bbd89e5a0253f0c3259ce89b20fbf6808a0cbe33e84c914ff2bab73f3d58626d0dbfd9cb9ea6f11461548a99c4232dc75f9fe85541fa7c1bf197f19d3eeb5d4482561a6fcba08e3df50adbe06758e6862043b88e16ec741dd39a45e289fe1d99180998064a2905d60fc8df10cf9ab5c19bb1e6f6f6cbae4b0484a41aa0ec4b08ea8dfac65f79321a4c27e13486888b13f531c95ff793855e3ae560df0c9f7e3e3f9f101ca64a1f73e830179e85e66d23f4c48a24aa1629563a6e7a9ddd334b5b518e1345502bba2feb9d7836bcdd51d1942a5778d92c66c535ec4d163a22346a33199c09f2d5209f9a0fc4df8bf5c63a00afb41a00227f64c5429c5c6a72650eb49d3d7ad374115500b476165c32ffb3819aaba18b1918ab8fd62ac4a7d6800bcc10e1cae1769ed39c8442de356a35a30514b51ff7ff19d45552d413780def61e9d4c9cd82c940c7433a0c7b4d6b0eea31f62fc301d4ca72731cf33df47caa44b001f20406e3264dcdbf4b7677ff34deb4abae85731145f0d2ff5f10d714917b84e8a44adf9eec258bd8aefa4eeb528a78ca24e955aec1eb1a9297e635a69ade3e1320fd56d631046a2e91998e7956a46456395120ff61b6669d54e77c38c5d4c9525465178357c48811c9ff8e13b5e04a3bc28b66c86ba539e0dc267fc2bc265284b89622dc23d2bab7d70350e95ab2d84883d04658b0c26de737cb9f4121f565dda2758bcb0495b04029f5ee3b26da274e9e0ac098eec0dc91a8ac70f05923be242ad74524c53e4906b85317477241c488066ceb47d68ba8ba46504fcda14f11c1fd6d66a1792fff9ee9939b8d4b66de34209faa00ab4fb541252b9b1c1e86f2bc455fc2d38b557c8be4fd1cc719def6306544a034eb616279b428583bcce07e178337f31867d24c66299195a8c5ff9336fd4b7696678ff980959d4a9eaa8351c3743ba6dacaa76c8a517c8f48834cb505b2d7d8f6a5b9c262b6761858910886e1062beec134da728d0eeefb79e2d9953673c43cff2d9d8849f9bfc6ec3f45e0f287c311f33b95d0da324d5719192de9e3cd9572fc0abbaf86c21507eb5e291471382549e56d68c3ccfe349f49d62a0cff161fe4d7b8d7de72a79f12c5621e52b47bc3720d883b064ad2f6aa9dfb0da462ed6966bc5abc1efc6de826a7e30ecbfbf9420ce23f3379a8bb5c55481eba25b0cc600053d87ddcbec2f9cb5f4f53cf9658cc062730090b5861931ae70d1431b92bffeb16f6b23f464e3002d36cf8482814ad57b9db927e459bd3b10f70cec3d3c30abbc022b42f108ef3340313e5785e4aeb717b88633d1ec0cd4ad22c694e1c0474b20f9519d2986d9aac0e24c7b822db52a5d5e72f772df12405918da3ec3bce7dbebee035ee39caf0a21a2675ae17c3d294e5a316a892feaa4d79ec6d5e6abff1329f55fe943a278d1bbee2f294dd8f54306438f357e269863f560c108cf205133a95ae40a457eb8aa14fba68bd28f7ec69085f689cb901e01cf026b074cd185d94121547e2075637b4fcf19ebbe4b4b307fbec8d43c065f4b6a062ac0437b9c35296f2bf8817e0ab02c204b8d2eff2274ce71191dd58da3255947b2ea1542e1930f07aaf3e75ae58826b19582991a5128036cc27b5c376ab0a1aff2f40e1c8138b08efcf9a1105417bb6a5161f8796cb05fde34f9e8bc19235c1ed6ea9cbd1e8b615fbe947f7e7ec1aa1238702d70acda5df6c04775df93e990b4894d6c3978e16f7d49d72916a5414a1c07da15542154f909b0487d1c8731497c161f0339fb8bf610621483ec10dd31ec7c8d2d06c7def4f2f3e74375a3a8b312f86d66a7c4457b000933de276d0bc4f6baafe3e4589c64539df33fb2d4475f41f55bf8d6f625f6043f42d3739e90c070c3511872ab52684ab23cc96afcf2a29222c3b7c3eeee934687b5a0ecd33967919295791b14d370c3698a4ae9fee2690e8633245593133948e0fda74b90b463e9cc12931dc712c0e89a967e5e814a0289d44bf39340f3db760d494a60ca3a91bd766655fce910d1a806179af160fd93b3e4613ba3c69babed45f3eae344a7be4bc1337d7ed39a84cc93205b31797ff11881606ca490b4bf155a807a0bcc4ddfa0028134f19390789a53f2547dae38c32cebc8d491155e3724cd78f7979e341dc959978a91ac8d3136a25436736981a03b78653e95bbdc5da308b38157029a54767558d992da62e8e9b0f9d3eacfae48e0280fad47822323311d20f8ebbc81cb1529a221a1e571e04cac52f68ace7d75b00d4f52ed307ad71338a6e130570a59184e12167d14d4138d7c025a89bf25ceea42b24773f0705b52ec5e31c6ade727b92b892a3e19fd033f89de84352d56a4ee5277efb0afa778916c0026d2776dc1de5f8f0aa0d8242bae3656089ec60222a273b7e32aba1d3f090236309e112f6b26980fab3d73875f1a45bbdce446c18ff86d4f767f19556ec5f0e142592cb5670e270a43bbf09ef7baa973a8e698dffd61881d4a257706af538664da475d8d1320db5dd1eaa84bc7c85a900ac58df43c38c9c4138d1ab2a29a6539a8925c7f47e2f7f51faa54cefdfe9abc6403d46ea0cd58fbf2717a6ca2b9ea3e2945d5cd57ce1652b2b10f9ac2ea48c68e672ee2b0dbf2703f06515e6257340534977f3c6c274555550ab5879f4b0882c21e594c79247a83d96187a4ced766b10a15e2d8fa9b9b5a3630c75822cada2f80f20fb75bd71a97b6d4c7d4f2dbeccda1d996ffc7ff9ad49e18eb8b295b0cd54332ebddd19f708be809f94c1238993e3103f04b7a9acbf163087d7abc18b53e9143b850d9915db9fc1ba729e9c89345b5528ca3547536955d8a6c1bfb79c3811f423a22e4b7d8ffd09a5fd58e2e3ac389d5b6ffe04da58be033454419f7804f83badfeac97bf8581c85c203d9814c7485cd1845e467ffcd78950b2c71393b149c0cbdb5e6e671c3e20e0e188cf1d513ce88313873fe6a912d5eae81288dea43bb6efe65e6c862e3829c153a71c140912e90f68cec72c1589ceab9fe2f47bdef3b1e6c153ea10877930f2de84421cecd61bb6c5fe93aba37112a0cc4186db687abbe50175c8d26092031b1a42f87f736c5434dd3a2d6bf212b6a26ef86c59c3c950c30ebd4963c14559e809d28694ad0a4070176fd50ac0a92309238cde68cbb555b2512d964eaf12ccec7682aee6fd6f499f7cdae5abb63a8c6ee2a6573f71d94d69e046a5a02149510e9beb67943ca5523badaa38e4aa7609729ea182088b637f1582c78a7d6069362d39d65797263621b48adc6948d2c5777bce81e2e2013e6a7bd3ebd2d30a942f75960b012cd561f9761d11f578eb80bf57ca75c8099821f901fadf50c4ae44c65010c0fb7acf1088e010261b176e38a0e14cc2322c3c7ea4887b0f27954016c4f5ddaed19516cf585ac1dfe48e871d3d372a9ce294496ebd60150c08ac96d9dc5a8dd6b43e97976c131faa90c5273cc7b1524297e0473db7dda5a937c002c821a02db7c8d1a64cfe89263756a514d518c8ff6d93116bb26eac3f7d3627f5e74269d9b870bf95eed82d2bc653aad79c76192b754c8089a91e7cbee61b9d3811ff9b3544c93bee560689561f0015ffbefe901d7ee3b5f1ec21b771e4205b8727d8865edc4bde9af90eae1b6aad6a33c4ca15ee3da8d3f8b65d4907c58cde102716b0593cfed1772e726b8bf2118129d75875c5a1da1a5bbbb9fa8945b7d188f1e52550fdf04aa40e6223d703ef0c02bb1629ff8c539eb7bd26ab6a0ea34dd0da1975d995ad178d2bd460a739da516428f715e11ae133543ad91462241f145e871bbacbd7ee71e82683d8c48791fd15068230c756ae4fa954b4e9a650b50083a884d36ef48bb8b881a52ac8c6f3d9064d10b3679ca3c9f1d60d4cec0f3892ecff971feff821f674ca31ace0963d2888c2ce9c78a471c80a191853d916fd67bf9d1f89aa8d2f47d3ccba5efc5f5358455ef88d0b0e3c09f942552c9b5dff98e62807506aa670fa8fe593b5e3cbc963658011fe4cb1d219cc088f24a109ffa3dc01c0f5681b39015f2499bb34b4f6a8c80a5c5f0867ae1779660b118a11cd7fac93ae22a8b330c4cabc954f412efe416fe510a597e14a6b10ec1a874be56d0bf1fb5fa1dc3fe691bfb15e1b4a9a0fb42af42139390cd7e5f0b559b309a216e197b361e5121ee0550516b5dc46db7fa492d9a7922292a67995ce60f367cd220cbf46bd1befda300271adee27bd6ddb2092c54666044cc0dced0e7d0c3175621ec511bccc599a2b5780495dd0b28725f5c18dc7d1577e7ad17ac441032f08c183d8b58dfc1b1594e0247ddf82584a84eb4d712900c0377a24eeaa9d8cda9b4e09e12e05f80bffdc680c2b6796a35f1fa76fc80c1c88f4c534655cf507ec8851b34dcffe0461ec5cc9a518bdd3afab047c467a97cf750b2bf4a7fbebf83e85db90f5ef6789072524f1583e7c3c66072563618b12ff2b201cff0e31dca136c35f60f6b9eaf0a98286721b120a4fe28528f5139d0ed31f1d63cc53a3348eba5b0071769abf1040891926934f47032171fa00ccf5499c20f77c7315fee3fedee54d2956ab048aa8d88e61661d8b0f9d7dd4e25f754070c38f717cedde6393ae3d67373079bc1da3e2d06a30af02a667e5204d65af5c7c07d5f8d3401035361dd01a1e419f7b60dcf58b391b7cd46f1b53f25ae764d2080d8f98ca610cdbc51a77c71ef87e8b9879f9c8604454adce54d0d5f12eb2f371ec8c73987c5ebd84d613d5a229b623f2b08394dfcbc23d335a77ce90f190767613889b637d70fc7ad35444f67e974e85176789fe7d8b76cae411bf027e2a4f49bb37d0a72ac68ee939d4f227385be6a1872398461a132152311bda8c400e4edf2db448ac5784df272b77be724815a68daff4f4ead567dab29ebf0a7ec6c5a72188c97f7eb003e6857374377742868fb5949aad70b9e3e94933651dfc1692fa9b1d8640b8a779103c602192fe7b28ae0c6a6ad6815670009872fbbd58729c15c2a0f77151c441fa35b3a17f8f9d74b61ed40167761aabc5dac162ce98fe48ae7449785b5601c54fbac44aca8a3c142872f76933d2bb7e5de93abf6bd9ef0390aed5690d2473176d719191dc1b099c2a2987e05d1e947223128dc26343d198431d9b9efbe61cae8a98e9ba269b283f0c913cb98007979c850a6a1aa9c11d22d21a4156ffbc4fd349b44ff8ffd188cde294b78ed9ea05fd60cca255f131d771b20050aba8838a469e48a01788d1d7c11f7105c55da0b32243ea29244beba9eadc32589cad16aaab6189a2fdb481eb3f918f9ffb4de77aec61b1b70b9ccc43249601e9fa2dc5baab543a2d76df2c68fd465ac1399ab1485f19caaf1f6f4cce61d348ca329efede7529cff63028e756fc51e91676644c49220d08981b229f1e03b6ca745b45568d69e94ba7d2b36bd220a2a08d8cc11461b5849aa014064721fe7ae5f78941b6bec280f5b8c6bef0d3946b456208ca4778fcc0cf7e5a2cd9e4bcf5c9df5b17e936d58ff2a94954c69a569a1af687f13668e0ac1e2bd1c349082f592374899f2de198cc5ced575fc16296c9a2a838f0c8a37092abe60e032e551c341ebe7c4f9dbe0183b64aa3e3daedb0ab58c6ae25b92481e57125e3aef5405dcc13b92a3f9db9776db275088f8d601d80b444958251696d6b55212a91f52ebb667807766ff8881bee64129b98171070e02795f278519a52f3383476a0a46ca6171dacebf932a61e858c0d49738ae04997e93d556646989b10ef5889b37aaf3fac7001138138b1024010592a3c4bb24b146628efe2d160c237f2391df8a7009bac8d0a090653c77982967e96f1b7ec6198b47d7edcff9c54d395c9900feef35beb3023c31b6209f81e8d5c0b24b1fee45b327bd0f259b8a4fc3e169750da9038e72a6c5c2e4435a0656483d615bbc1fee02078c6185c4ae965cb9c503a91db9a9bcccc14fbbc34a21ffe6b3ee786c65bbccb22b00f812b23336cc7dd9777e092383b71449e77e27cc7935ea3b38ccd1217b31762fcc8643d56fac7afe48758f56f2867f96377761a63d522f836ccd489a1a384cc3731cddc06c3862150840d15470cd0a94804fdb428c3232e7e98b419aa0cd598acf3cb7ce72244f7eb2b611615ae5956fa2c25a9c183a4989043f3e1c9d685a489516ec8f3e2698f5fd6a90fa05dba2e31e2863c01db8c269bb03b81fc9d6f6acab121a326af4d3d50cbab500cba5a2f791d57f14cfe60c904f03198d404d3314bee70642ec2697a4326a8afafd4fcd5b1a941cc511e7daec0b67217fb93bc97dc47041231fb09425426ba92c354468048e1e005ec24552a4b0b02a9b668b0e5a7953b824f3ffac916e7dd625b6703018b391538f1ee2b024a9beedcd50ef581f0f930ef87b787b82b2130fe1640007f2272523822cc9a989c2cfddaddb3d274bc66228f74775ee7be8db332fe6f9aeaac28a0d36932d1f6dc66b5333e85858cfc19228c59bc66c4eec957b7a147fb66b640c320e4ea1dde37d4150b69bc3691452357ff0d7f6c0444eda7bb914559ccf2120496cf357ac7715d3695e95e43dadf758c3274ff53db4eb1a978971e2ddece18d680f43997385faa57fa0bda616f65abfcb6b3f7129f129a2274244746f6c7fcf487ade3c5b769039be0fd69a05f65ba43b3da4d95a253eca74f79339cb08e4ae23d99c5b0ec4f9c189e5d205dce0a3b7a052ab972af5bfab4c6717e5604785195a813d24c3d50821df1b80bc8bb48028adadf5d4ddb7fd07a843d3816e12d8cc4876fc7d4f0416d8b2eeb1e42eea46278de56307cac1a49dda13aba28884b665734ac3bbbcf36bcb151fbe48c4e3b4f7c11bc3bc854292116a278cb66f012aa21125059789f170101d71115ff2905c22ffe009cc967d2fe764bcd2c12f7e5346838a2211794452384c72965072521d838f4f41dce47ee98462252a0f51088b93c764627153aff343f187ef174d8f8b0b2af3ba214cabbd7fe2c13935b8324444af90ec91d949eefa35d2d1f6907ce496f9844377e68d2e415ae953329cbadfe9a36c6fbc08e99367eda31ccc2a91c9cc1232eb30a220b30fb74ba5dd8bcdf093d6c48a181ba3042fbfdb9a9a49601dcf3e66776a0c2ee0502f6e1968937b76dae187429d1e6498bb9477b2ef1d6ca1092db1ccc6955b590f991639c86ba3476a08141019fe3157efd8d494b3fb5a2b192040216b0c87910bb7aafc143ff3f82f864a93f10fba3b65bfb4fffd1c38408c81c1c783300234f2b4772bde6179e436cc67fc9c50db1978ea1e343f061e315b66dbd6b52ec9661573bcb0c2a9d22e319e392f824a4f3af2c9bfd1be969afb150f021d134d6667c2950cd7224347d1c8725bc268aab1337c8ed702407b7b0a35b079d2e554b575a5743c70c696fbf892b9a7cd29079a714e8492a496d31f5d8e60cf054ecddc8045d0612cc65a6c222e28d375e1a54437cbe4450b5003b98993a7808899b141cacbdf8d672ca157156526da85fe1aaa733b327f64384f7398bf8254a9328056e2dca27ccb4297b2d55e4d1d9c624832e866c856019ca5ee072c3c33da6b89f8b3617c449991772e2f90fa2a41c4e40dbcdce37237efb9322481557db02aa917b9a5eac3e57319e9675a164fa9bbb044776a787fbfeb228e66fd7efac5d8df25deaff831f16053c3962a4dc4aee3c5f3bf59665d0da68d560907109aca7abd4f2db3215139e50d5e821abd4e99d6d918b72f5798f45737c50358f6636599f83ca4865069082c8ac0399642af999fa8f09cd9dba95e8fcbf88a7c6230f0c8899f0f96512e626c624a433ebc32689dfd064ae7dd2fced2dc3764dd41e21a72b398a6c0eea453d04507c8d25ae836884d2fea215c000542cf1cb05807885575e62ebdfe34df3b0abff63d9bc3759343df2e36142788448dcec9acef9c80ede2a0e7d127bd7421d7000a0b52e63e88033dd8c3d64a280bbae838d3790f2b80b6d3097606563835c66b351db4426d92b3a3671ce030131d0f833ec2962122f2225891e68e00edbedb8278e11458d19971d7877a50ac4673b1c246f29ad4bea3bacf52a9b5074f6eb156768b58871babe3fdc6d601d78a82da6ca9849420630a31447cbae53bceb9080c2dd4632697ab1057235476e60bc6743751d2e2e81f1a368a40b6a40537f74f73f4ed45ca6ec1dd6d9078156bb354d45151de4225930b32ec3d76f4e364f1accdc7c46330d23b8a1ddcf32c640310b690116485cba534618cbbcc73fc8a2775d86c198a6b353e274d3e4cc21b7068f76e0bc2d6dce670b0e1efdcaec46fafd890d07f5eb4ee44f534bd80a5ed2bf609f7ceef553cd6405625e5f7e1e2902720792247cb482da63c67eae0dbd96c26adbb55d8e45a2ccc77c0758cce273f1e8d084d6c7b2f45a607b8e6f9949df168565349440bd0f1831b7a8c4ee78b4a79a563fc9818ee3d477a84342a21a41b9f594221bbd2415b71b2d005638463dd7a19d946742b79dfa5e694626044b2a9a92f7a7ed78172b55aec5444f3e227ad6b9f5c4f43c4b614fc6ab161e0b069e6721b619356cae7c43295ebfd67765fb28f62af9c0943900b4d3d5d617737de122357aee0970743e41069e42592ec55d33b44712175b11721a00665777d077ef67d891ef1aab0cc224270ab4df6acbb8ccb54a67d96aa9351e653df9163aad1c275467b72b8591ae230ad76dd0414f622857b3d030573fa6325479d03eac547faaacfbae38e1e813d71201558c244ecd78290d49595c4273065e17100dc8c7f4765d2804226f25ca746fa63e150899f4628aae8dd0b74068e9e5a3bad8fe0baa8092ee21742ef88f708365e7fe562c6c404e4b031d7722bc2000afbf7cb4d4fcce6f9865bc0380bd646f5c1dd6de542ab92c1e4aceb5fbaa8d8f678b416a23d27668bd978588fad50a27e9d3333efe9e4ffba4b49af3ef4f261f4a5b62ffa0219e91d66e5165c327e832de86d6fd76c69be810c4971819bf1b143af07a8a65bade09171b17ff9cd8fa961d22ad2d04cec20e47f6f76f722015c3891672987a3c6ff11503f880b7d16fc871bd88f9b4a93505b20e85b2e3eeeba382712d49b969b8c233cbe494ffb8a378790c610873db3557e4c0fbf7b95ff8e07451525943d7d7e1e8ec9b1e25d79a72accf90ee8a5aab1c677b10bf3ed4d8a7c18fd01edd506d4169ca6e41ac5db79879b76bcbdf25b085b05cede0dc1721463aaa4d9f76e7c7cd348e9530c8a897fefe4db47e8f2fb03e1008977de923285afce72e1ae07f1326682ae411b3dd381d7b913a003f5a071c70f27a78f874077bd1c52993bcd88af52bb5d4c218191fb801c2381417a4ce0bab03659b1653d473dbb9b78d3b002a13dc47c65d786efcf67c81e7fadc500dba5e397385fd5538115f429995289789e1b03d1a323d26fda7690aaf4397cf8ba6c80ca3f6ccbe2a605de0b1bcfd7c7d5770bcb47342b777c0b2d5f78dfcc989e9ab52bbeab12b66c55a6c4b30eda24a23d1b7cba42cceaab5a8e77a0c2b59aa5b95bbf31a6e7584d4bdac1597ab722c46099ec3d46fec19e5c3f010e7c2a5a43262de69e9bdc18f5c6170791c370fcbe39a1456de00e8f215eb518a1b4260f0295b0492c88be8903053ef7b04cf719606af804fe1bd43b835c62aa961379d4fded99cda4af5b9d6f2b6314ba2a4d273f1106dae7c6cc16b200143040c13d42385b8a9344817b714b4d66a5ec20e2965eb539a7a47111e88b2c19853b4e75c2b2a0a1d057f17f5e682e6bdb1207ee295c8c99dcfb4cdd6f205c5b343a501df836ab4b2cf9c0d329dacc50b98ca2c196f5891d4dc03542508c34885c35e297555081e68712f74551b37ead3d2a85258828801e1eb06d057d0aa173963483051512a8e548017907c2b8b3ab39efc03130fdebec3567c436f303995857f7de52afbf574cf3327f291e4f4f7213b6112d4d7307ecda65ccb0ff2da130d05b0747c1a27b8871253344734a24c8f32cdb52f3521f109f155c73ea107da800cb36cdad7355221f49f7ad9b81dd8698a130db729d12ff462c542e32f68215d18c6864e8bdada5a8a6c9b627524f2dfe0845d5adc255d15cb8a91afea9be6cb5378b6d7fb4c68ca4c865f6271d10eea72197e95dfdead085e4deadae476280d1c4cada23a42797f52c6a0d4870ee6a68db136711ac8282d1abfd15b611cbf0b4651a15f4cde85b1485ebc9b08dc93f278dd99ff1dad6d667234a90cad5506e8eb6d02210b0cc6ad97b849434be8baa7df4303438fdb623747942be32bff38f3a3f0d73eb05a7a8c516b2235733f099c81a1629b7503146f59057ded4bdb5cc386edd72d4b9a425fbf4447e98b5dd1d0c94d28a23df9db834fc25ded404264e15a71bc9e9048d49bf11cf45fd865e55ce4010f49b20e748bcadc57a34925fd538ca4ebfaccdc3976079f32d6eb9dc55f5a39f8460ba8fa65e0d17e593dc5bb28920a4142c605131821660b7c63a71d489f432d179567613c66b2938014eeac35ec1d78432a9cf951bc112ed46b3c0824b94979e63f20176769d88b750a93425544f775c56f394b859f971b8770a7f19a7174c8f88c948b9da7255b2db6ab136a1e316795175c6e1dc456879c334e4faf0b1031e6643ae5bf80009ff24badc18e3512e2508edd8e361af6cb45cce1952f0a09f0e48ea7faf9ff0c610b43870fc32a8ef5723ffc11188c7d59a193ba5eb985390cd9d0ad85463af5467010b1078536cbb0686ddd5814b01730804985a29394980c6c970cb9446af0e0833aeb6e10316152d099cbe1aef206a948ec6625bba2d9acd59c02f02090e7472152bb9b37a0c26bed1d7b2688e38d5bf0f63d12f051109dccf34ce78f11b834bbc70c933773b90ab4fb364e3f4220834d1dc4dab83a6e19a256753b00cefd89b80196e894bb53999463b78f0f326a58e1e339eb59e565674c9e6ae6c25795823c5c4879e291b870c7cb01fc055149d411e763c77ebf9fe7bb49353208aae07b9a183501d3d12a34f622f72262f95921252cd18b12a774747e4731a3268e1ca37855c4628cbe2689a8b6f58adb4147f0e9123a053768484ad42b645ea1c5dc5515f0dfdb731be2fedd5aadbf5ea51d7356e3d9b8119209cdd8245af260f2a39a5105d0df50f7310c316c3e55cacb9b29cc91155e0ebaf99005ada83149c517660a1b58dbe368d3b5f4f215fb794efb45a1fbd512511505f31acd6aa644bcf2b5b7b857cef289ff0e48b9c12064a696bca6e4e4257fc7415ccdbe87fcacf8d3396efe2f856319ce80bbdaa1e32ea6eb349067b6f2edcfe9c8ce1f9b8377b03b2095fa450ea527c4d6bb2c3b5a2d440ac6839d738fd8da00f6f8e51dbea4a851621b9b6a3e0399ab3b9620bce65c4a08be52c3d92bfeb62c09dd5bf8a6a36769d473fc73618ba4bc01d6ac59e974fbee4b4d6c72bbebdb95a1ae4b2df1eaaacbc93970ab44006b4771b064a3439a6fab9b9010c3378e6bfd70b8d07d6cd6afa04f6a3ba862c6966a713372c12f50086435e2c874937ba045ddab6c165171904c99a5205d2e209df44ea8f5732bc0f43a0d8596e94092966793c594021782d2dcdcd4f64101189a4939b4c38a3c4050b132e2ffecbc4379fbcda37ac0662cf392d3a9780b98c50e57fb05fb78e888ddbf35f60d1e0b8596f6c8e5fa6daa18d63f6f21d65b8992d138eda0f27ff32cf57c915751bca3c926d6457b2567d2a397180d0d7728fc34805b5553ea7e51acca280c49cf98fc6de87a0aa66a594756c36225017332e06012e506555035abbfc421bd81876422868f45271d43217f0ce88fe12e71809ab4389f92eac1f73f509cf8c261623eecbee2c908affaaaa632ea8ad7648b1e673da3053b6aa87300c9466ef7c21586209794c1e8b6f385d48abeb0b30620f0204b7f979e8ba2e7e938b53236ed3f3b0e7238dcef79c6531d4564f2353e350cd8b0e18a1f41a70d05e140b3b5b43620eae6606a39e749768f2797608d8905b583ff9d40d0a7db444138584d80c1d1c86a4c66229ffb9256b5ff5cc7f2d411fa5de1a0958bd5e4c4858a4ef45c73d45844415ea84b1de0a5033677d9d6129e0b6d1df3e8602f4773512fac6286d6c7eeb7b0c4f5e25533d7ec340f3d5d8b52b3583e778462500380142d9564b61319cef00509575428ba045e81fa0b5f89f62a4ceea930c68eb7aa44f5134b4fc6b07a20d88774aef1c7fa90f438fea7cc715930e94953de50796327a488cd5fc57b90780858c68119706ff36f4606986febf0d4b04a5ab9c98ec1b9e9210c8460284cec04ecd851e0da3b30067371cda311275e2fe72ed27695dfd3d52ddb3d45bd7832dcd2ce06ac388cc586ee5499e100eda6edeb69f25d6284e7e2bf04ada232bd3bf7e5aecd550207ff404a0d3f693cc1c358cc067eb8f7988f2160eb10ac6bb3488b14232225508d40f597416a2c1508898dc13c63d058d42bead663a9616cd611e9e668ca63b0db82ae1948f66007d30e0d1f64ce828d8d2b1254d21235a3561cef8fb2e2f7eb697b8bb534481ac878caaf3445f6844ce11e92675297089b52877da778d7bcad191a6c338a6a27081eabc467024cf79837d278de61601ff6dcb93f96fe6d1d5a4e187f0a28dd4b93108ff7279a9446c06a25761a12f65eb7c0a31f831c39c36819cd8e98462332a4d8709d6dfaff61ff1f9645cf8db6cbd5a7feaee52b98960c4fd855bfedd4d2c33c705f2d75867c5366e64f3fbe314a5ac922f767ad954431f0c3d4299a009c566b4467abf95ac1d324d098e0007f447fbbf2bfb5d3242d442cda7fa12eefd464cdc7c72e05522bef72b7600e0b45ec76a5a65ddf99fb5845d976faecd9b03423bbd64a2feecac9659409926f7eec8dc4f1181bf80587ec78b64b8c24236b6f76f152bc66efd5eb4f6c47ceba70a07d6b18a900407a3a5e90d5fc46e3f91a0e0a37a575aa47d34dfd2ecea5e9828149c5982f1bacb9443bf822add7047f9aef26c865b54b53d2583f7fb1783e91e1d320f0431d2870a316f5bfae9ec908c713b7a2ebff67327b0952fbec76b93c6a49b0a4db1e04d5c886af13bc24beac289fcaad58192e87f951711049ef72f730a564cee2ebb667d4a2256c9ddf5d4a535a46977bbbb687c4182d2c40c2ed946c159fe2b471f3b24b939b23c148723acc105731f342cb68575004c59a99a66a07b7b69ac6ec08f0a6f24003b52584e8c9a3b2c17ad9f4da770cbfff8e5d5350e3fd7bf77153fe9393f6541641f626e0953409449784b5e83538063bb9af6f9a872c8ec2331f1b12b9f2bd35ef07f9412e88289abaa0390050027a808d6917101f19fffc034705c0296f9cb3020d5314fc27c56ec1ebfbdebdbda6ed1b6278daa76811de96f39ba36d0a1cd59bfd01fa0f648316d644134908f1c4f82168b48743c86cbffef4a6e2e32e2e4c30277e9fce3555f0214bf8e068c5fcebfdd47a5e0d8fea025d4d956a01b128cfce347a8c96871ae320d2433c44fa1e5ad2c479630308841d8d262e65484b675907bb79acae27b620daa16d741cf3071dba0dfcb3e1946c9b00330e5ec9fc1662f4cdf35f334d129042fb5c5404e7cd7110e463ebd779aee2845735ec0c840e14dbe0406af65ed331e5150f05f484a223cfeca64e0ad8f9b8afb4de790dae8d26483e63b349e116c5895274ae092dd7c684fa1bd48b43ca01af098ec4ccd1ee233fa396d205a75bd20aeb869b7c17961e8696d14abb9d1393e938ed20e7137609a6c7e2981ec9aae1c1556369e33f332eda3b8a6dd0ec074fbda4cc0f3449985356db8d7271483bc5385b4ed220a68800ccb151674a4a225f8070908dbebe98ec093d2f9c30d9b2615819c7ad6e46afb57b1af059ac852c81c3452fd0da23311364d55e8c5ea03c4d82312a4db2162cf89940d886dc7ae08c89764b3efffa68e700cd530c2a1504f70c880c61a7afeca25f8c0d3f3e989db58dc7c950eead37eb1e4e6db6f7af16b2e11d475df2159b435d1ca2a8e830e518c765fe5428cfcdd3d69e92dd52271adabbabc7381abeffcffe867cdd7db19b73838b3e6e983f8883beecfe7a717f6fc1f4836dce2c82d18d8930fecadee67896d061f903f4c57688006fa9d3c6ebe5652473a69e9fe73cacaa2540e1b0b3505aed21d05e11aaebcb825492f7ba96309541c99a57b06f316f1c2c37908e88e167f1ec138fd959ad89120ee0308ccf21b3da2e4b792e43731327ed65598771161ca475bee6b49e6f72865bed9c343b877bf7533b7db542a42c9708f9b24a48ebebc57cadb81421ce85c5c3c6faa7b89d9b5a7bc2e7bb242e821f979fc65fb142fbb23a9bc0ba441102af2e2e5b93cdc37b92b051ed6d33eca3916ea6ce2ab37a7c298e46500914c025387a8b31763d905341b691c448713459a2e1d75af907b11315f65b69e55378f25d97ee28cbbee212e3ac9c9716d1cbff753520ed79656fa32730360a008db4737b72484051913aca6727351a8a2907589ffa29a67e52379caf50cd201a08ce50c6105f1756ca2a7dbcbcc4405430931e42a294104c3186e7b2f2d21f10cc8b31396932893a57d5c108a408b1568d292cf905a95f65ad319831a5f016728443b00e92073077deed6dacbd6516bafdf564b143a2e001d8a0fd597bcac02d4d951b071379f25b2785f196f635e11096965e6be27007b281a74e14f9493b8d4f39a8fde5ef16bec91d64fd39183ff498f4da044d976886b345fa3d7530e02b94c1780b60b2ec3878e26790d204fb737a11cf905e28b5524f518e5e3edfff8c71fe335ccbda5ce5b69c7e2a29145595169d9809372a50e94c2e46c956e00c552c6fc46947b6e92288dd67e3253fbde4d7175b01c56e58fb701d81fdb861e2acf434cb7aadef1d0cf10181313cfb8d4082f2c75046cdb36335f3f6a2a7cd679a1b547d1e6434254be734386623d465a01ef1f0d8fa145375fa1b4f788ec9b6bce7c19e4f35a65774750d6c45e980a2fdf674ed806819e3544ae2f3a3e415cdba77d453dda7c88d31e7f4eafebf5356730e84699b7fc7e6cbd6bf1d78237780fc57cbac186b241206b471b6f396d14e27ad434a856087042133400296433ed5a4faddad27b87b542d04b561437c4a3a89937f42a27aa4d223759082067c2b94b5f50aea230218643cea726c9a47613ec60eaaecdfd19fa04769dd93e511e37a2443991b439c52ea13102e450df0b245df54c2d0044efe12630ca5d0ea727c4b58865bb0ad59c1449aff7eec8d929e164d927149748c5edce881a86d7d9ca14cd598a6950f567fdb1cc7bdb8a839ee72b26afe235fc8542c88f9696360b6cdc17989f50a2f30510a19f6d62da0b2b7545fd96ad1d8bb315f02a90eac366ed5265a224b1804f3c472aecd243f28a7a990f025cea40a1f71ad373b67d54d97c9a02f00f935085e95899f0accc488f23b46b96ffa256e1e03e66eef393fea0c0fc129780ad08528d5f9752950b8c5f12e3267d01f423f7511b2486901eb467d8fea1b8b7f76e75ea6c522a9e678ad6486125a5200bad2c81e65848ef54bb02b7981a5a7c91357a542f8a7c8040e2b1c3b77aa5a38f54efa4cc33552946e7c4aebb39e06062ae0b94f3eb51e4d07e97d1986f864e03366bad221cd7accee7442c74dc0d46f11cceb99eab75b5593f3ccf568a431e28a203ff83e5a3d49db80f495f44d5b1eaa8495b8980ccfe80a6eee127b90616c9b5e540a5c3ec620ab8dbcaf6197dad74b2162b23fafea3f555f43ea45723580d08dc255fcdc29a6994aa98f7463842424407e3d5f38f5c3fbb45a210f2225bd0b708901731cc9cc4a708638936dbf383d7345e07234bbf798e9b0f75cc1f260008ea99e21c68089547a2179d7e8fcbcbbd1e3ca7cf4e6bc7c2125c7aaf2a150b9cb3fd4f7e908e1fbb45643b8e494d9e23805177bb2b4e76e9b9f1142ad0ed3e9399d24cfd1938ad279ba44038fdca18080da02cf7fb9f5f6d12c824b8e7bce77b3c7fc8afc8940","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
