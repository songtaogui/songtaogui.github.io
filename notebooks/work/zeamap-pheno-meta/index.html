<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bf52570180a91e5fcd966b34e902e6806278fbab1aa3397a5f683151e1b2c67bcc8e878566c5725e9585f49e1a55d41a3533efe441a6f460f90c36b625da25830a0ac12547f3b78d23cc0c8df82f32dd714b846c9f7035da17bd41d3c97f14097b25a3c3d26b96a619c76c3849de7e3f6a29c4d24e58dd35acc16a2e6c2b74f4927530f44fb7ef194e26013c273c5130ee5bee8dd00203b62adb901fff08a4783d3531c3bc2acf26cb472cc34e135376aa84032fe0eb985a287546e56deb5dc84b0206c6e57c5515eac8ca864d9071699a08e65afa160f88ebe149759d0b8dd21482d39cb1be2e4fc752029259a3d8ff14a1e8d43f72b6bbfff75c4d59649b997d9a71b42fbc5197d4e5bbf63be80d0e3847f2df44621c9d0e846151c7e0b24cf14bab53de740ba919454b3d7ae74e9e4e606a09d19785e9a1b4c32ed1ff475e7fe1b6292c1969c6cb6f8b956d314af7ebfb2660add975a784e3aeb3cb081bb5d3cacf0a54548eef92b6d77d3a983098a13cc31bf7c05eb023cbc0c00ea15fddd29ea8572d0eb2e8fb3d66ca1b6c14d142bc94da5e5051b63d7afdb8a17d63b2b4b761c98313756cfcd1178a268d7f090bf834a9aaafc7a9d8c9fbe01a58d15596d4c04a92978a717a2ff4b0087fa555dd58e8a16ad0b00bc93fba3e680c8e1063bdc80f64ed94fd93366afb8d5d4917f31481ade3b63cf4b0a4a40095b7e0145ee9b5b15a86f5f3eaf2dae3e23923fbbc4a3bd8c7d0c42572d0d096bf5204fdbd1e3cd89e0eb13e6a50836469c557bcc25cd587ccf8c7af67a01b40d8260c3ef1f2bd195862bf780be6112da3f040af7c49b56fa7b2573f81ac6e36ac3cd2ff1bf4b89c1423794589befba9d33df8c09fd594116edee4026c51ee90781de874dc3c02541eaab2b8e64baa1a328bde15ce2c68569b006878922cfc9cb4bc9fc60e5c5351fb73522688ac43a734da3b715596a6e67b07d851e7296069d46e29172ce6b98d7caf27d3e1125dee03274f0dfa22f4900898591778b16635708c62770b731ddac2791a799d065a2a3d015fc01132feb1bea1ea2838817519f1c7bebc0b81e028ed71fd5e952f338da4e7e073b926b88d2832a4c093bdde504d8258890a341cdf96cbee4a9027a801e6e8ff12c8f2d30889f43416148e36e1f2a7264e20352813e4d39987abe13802c12ad4b83cb3641b3ec0490b2eee20a7e2b5faf0985192efd9a148d8826c15f2491ff386d3aa7edddf3cce79c59e4ceeabd68dd4beb6de5418c6b2e5f474e8d7db7e99fcb0dcb55e40952ecd778630c3bca228a84b13397c098dfb83e081d35420284f0f2f8871322474469448cdfad55e35fbd524031d4f054112a10fad83c6d590e07214b686b25c7edc7078ba3e3c5e32534a97b6dc982debc48ee22ed776b672cc7ab8b8811a4932e80a179768f0dd97d25001b7859f842c4e9c70f80854c5f129c1ba6a0c4bf3277ce7303d424707d00cd1a2735c0e21cfbd730194bb4f391c1f1bb0daacd71ea10d1b41f82bbe39c51d0d4139879399d45da7f0ac681177f98f865d14c569e3aec3dae2471e321a91239921b5e757b473bb46be28e0a461568828754c6d73924a62b391b0edaea235f7735664b6fa18744e07f3e9f4963d79a515582680453f79568dd0f270fec4894b2ffcfbbfcb12bee4ff3cb5c4acb6e0d8cdf1da8ca2b9d2ecf46632c6109b0c8f4f03b30deeb8d6e60da1c38cf043b987feede8e1d19265db650e3d6682477f0d4cce02ea7abbfed2fb9802765321588fae3a7d8eb8a8a6172fc095b4855ede81fc4dc2b7da8f46e15c6bda360ab56851f233d5d4a7198b08a80560c2e6f0d4862854b3e68a5137db6507694aaae5ecfe8d13dc4f85e513f77fad6e97cfc3e1b5db397156bd96e528eb175697cf41f8ca81ca5ab1e5fc330712616d1afd7fa7676826f89b30996b8e44767f0d4ef2e0f8061179d7dd7cc293d3ed33c88bbbf8780ded255ee7d9c643852af4b8ffc25dd1acd9bba15e15f4a07890ac2e8af5ba432df1cb75d3a87f5cab1c15e223c62cf2c4b43acf45ade007e5a2aa1f239316009131be90ef05ed839610b2ba5396f5041c6d1b400b89a4e4f772cd9c99c752e219c04dc3c6d749cc6a24a993d0598eb71079cc9519b4cb79d121c2a1ae068c73b8a3eda5cefa164173780680d39650720b6084c9969739718f55ad6dd92deee3b9c98335cc9fd31c440b0ad5d16d43c741e3d5201379a954e3f0ef5435a084106f7bdf2537d3321231aceeb671199d5df9c5a883ded285bc5de45aabc623807019b54116a5aa2fd99aed140fbd776a6fb64b28e38ac2d02a8cbaada519fa928fafaba112b5956eb655091711cfd866f6f1977d87bf901abe6f1cc96981a0bf3a6720354b0479b808d91aecba5b638a0272e5b119e5c1485b59d144c3c89fffb96eb34313eb343afdb2fe47f14967f99ae30422c74a9a9dc29d8546234d38c85d40287ea8d48da65ef4abcda4b527cc12452b5b24c3ab3dcd1aa42c98fb7c7bc8b09e22f4d83e0dcef3d70e8b90b48a381eb185d95f08fdd1bdb07bb33f2f13d5d35a8d9f0ed58f4c3cac283d6c7f19e57510dd44f2de1f91fe4edf7baf1f5735af7ba449a70ab2fc7547162f62cd19165ffbb319fc0500a889556f1e99598ecadc287d95762347bc6fd82fdb0658ed1fce5a0f791376c9907978f51d69a7baee9e31b93de5c52aefb9e678f7570c96558611bd7fcdcc3a00e8d913cfa124b7ae1bfce1b8a524d15af2676b757f644821a96e3d9d276805f9eea4f3846b96b4f4401e3c39954752eddc24c27a2b2742cd6c577e947e3aac064b746316d9059c1bbdf8f01a42a22308ee8ec843e9cf5194faae84234ce453f5e581e78d46a00c0b103dfef0ed52a29e50a5c170b58677a77e5f20d483cf65d0b7312358700b63e0001839238dbf9c5f8fbe7bfd83b532a4d2fc867973e6baaad5fb82a96f3669f7329fcfae38008bdcc258e52258ab345907a621fd406d98eb8da8699e996f80ad2a792e04f6014c84243ed7434eb12c29d0d1220280528aadc5c658fc070772fbfa248644eab91cfb7f95879560af301ae0694c18fac75cbc579f64ec0a29208638876ef45066b580e76c095122e8ee92b10059d08fd48594d497b499ce894dd8a97ee640e2ea314945dfa9016c13bf82952b000aa0a283f21c0db1cea59241bc4e253934f1ffb263b9e8fc67fd94ae613df30083d769986654c67939c0701ba5ea288b3c138e875f52a094ee817d78e5b240bc8013da425ae55a82bd7f60b2add8622d711cb911db10bb7dfc15cb0ba5dfd17884fe50d9316866589f89389462fe2261d40018811385fa9518a7afe2c9a7dcef75588b10d5f6a7c7a4c880aefea43ec0b573ec6dfcc65b93bd002d237dcb65ba40c186d9959db866c5999008c280684c32189fc487f53070d69b8dbc821b184a7fc813ebfe585d498f23e133d983004e4376acd2b5811e673b81d0e6bd86d33c9a05184cb7c130b9430901d0ba4931290a8a58abef214a8362ab3bf07958d9362b10d7e99804a158bdf6e0dd7602294704765ae5d41fbc5831ab7e4b4a6d66c92a22a17a706a33e66461ca27ebe78ee904dc943932f519aa7eb356f962fdd1b7b57af01c06fc2dcadd53ad3df7d0bfd3fb0de5b0df6c5e2b3f6c24c5e9c9003d510b659911f37f972dcd74e5edc8e86758e8b71be7b04126be8a91820644d699b7cc8d591f325c4efcf404874721df33ef05893a1068f85f8f1c343e0045dd3c3b644c7c5c901c5b66fdc5c3ef9a3b56f2628de2089fa2ea4caefdda689d25a8563c1b28fdc6743505a2b5090b09de3d1cc71fd5faeebc86af29f43a955a9e3694b1ff93ec5e18eb52d84f1ace64e0016fafd6d494fb7ebcc9ad0500ab86d96fd9942e5b45bd8f0ffe48fbb10f66f86233150c0a585b74128641c399b22cdeac20deb76623f3bac0de14a45ad5c409a6331bab06b4ef805959b24ce04a5e5c83bec481e8588a1a3e52786a6b9d536570a306825258385786972fb4115bbdb1e53c14f657b20f4792fd70eec2e1099a1395d16843dc65bdb35df170e7e9eb607d11a01e413d6c06a200607114dcab9ee262773044503bd7ac0f603d208835893ebe302f6da86b34b21d3b6b9b7745b787e6e15521d8f85cf7be37c03c7c9f6904716beedd6977843c3884e3a0392c3461b71a05560367015b8453f400f32d4db99462094f45d7a450f75a15b2df639b089a7828607825d9b3df7740f1945abae279402e76dd492e5562df8e636b5628ebad984895707cde0e86457abeb7242889f2b3dfecb5d40c5c549742aea0e1ff3f1999ae5bf3e864d24ec24040286e6d3b9c97a81746cb2e1e83ce9b18be50f04ecc65b1de71a78f2867e5eb68d5a592786f2e4eea705b0362fe3173b750dfd7a4cc92a717443b01e114aa5e2339ff73c4ab7056513930229ed769be3f7ec4e27791aa86b95d95c2618acc97f70f4c8f70ead95104768c914b2a3fa485b1ee6eab170bfddc59a8739d79c39bcc7ff904aa54fd4f6d0ee09f6d0fc1caa1d12aef52bfd5ecddda9a7f20248b58f1fa8f73e4d5b11c8c2134d4ea8289a7b51a7c20ba480da242af7188759cd91d12a1f3e4e53bb987d14626146a336ef3b4e98aa9cac120bcc2fda2d725e6e73419b178965a2d822c449fe12a036411ee62b774a3eaa19f8f15526c5ddf4cb56c374d1cfdcc919b6d8dd0e1ff7abf94b88d7d3196dec108137610d8fdd49b516ee792d21362d23f82ccf7f97890c5823d8c41a7f6a1218941df2dcdd527930dff3cdfd3244a332a54f28756148bae68d209071621457e17da79a2c68f0f0aca2d58ea7ff92bc7b832dd060c64955e87dcb5f910001f7699f08a176b78e79e4ba4454864c93c196c4b44e05c74272d10ac763e6aa4a6a221442dc01723f87ec911ced6709673fba52adc57371884402053cac768eca2fc5ffeefcb36efbe785e431476c64454ec57d5d791bde12c961837580d7aa1cd8ceb494779740602b14d0f96dae0a8d52b016e2216c2367aea5f18f0c5799d9507486a211fea3206034c635adc65fce22004b2f93deae9bb3b656f690e10f6c200e34312e2a136c0f46a665e31c592f832f9c3dc20a698e863f61ceae4a754a3ab9556354f5e86ea19633e7407783073059bc87f5198f065143c4dc62e13c17a23fda9ea18a706a62a8f61f58f438d99431e9609d36176201b2508469143be31e72209a975c0f3b7c5d890b4a8567f26da6ed2b2a8d9fa30de485e116db13d91ea6d51488e44874545f427a140561d8c6799bd871c2aa3b203006de54980e7bc0db009526392a805d6cb12111c326f5bf64a070ca0040a157a4644859c7a66f0914f417580bcadc40b50b3778a5a081d7caaa99b1dddb207db1ffeeb939db4dda06075fca4a9fa2c4bbd183508a9dae49199f3f632a856a411b13336c66fc068bda0bf69a0d6ee203fedc1258b910b3ec64bf3c2d8c997d4a70c3adeb6a5f682b1c93ddbee7dcc184248f98440f2abb4e05c9c31f0fb6251c2aad9e9414df08db46264834cd585531e219b326f4d22fbdd2ce68bfab58af7f5e4eacb807f6a65cf1e59cc30cf6e36dc0561cc971bf6c34cdfcf37037d722aa1326d7956e657a360bad4d84593634cca1ceb8f79601060c4e71c71ac04e58b705a58c1a8938c42794b4bee7524054c964ff36a4877804494a38f48f03dc49db9d745ec0a938d440f4c6da98a08cb2e85a6ad4132729a308c37e42a11eedf2da309f47231145030d98da91cb3eebb50693568ab68629ffc4b399132f496ede11fc34517951707e66ea10fad05632ddc4129ca2d30123b8bd6bc711755a1dfe13e3e49da89d96bcad50ac91af51aaed6f6b3ace9239e8432d2e58b7714f66ca6fc66c5de95b3cf5a04415700fb8d1e2ebb0c76048f6fdac60f4e7a0e9721aedaa18be0d87c4d9f8775a54309290e9ac4383ba7bd6b384d3bbff0113212610035c5517fe0249708dd1ffdb9136062d9de67f3de5ce59a7655e14fe48edf712b62640be2488e7f00e05fe2f205476703fb976602cacc17b84f8085ee53b90775831d13162621fbb88414b66ab1c4c721d6d361bf270b4df88d8b83ea1f139ba268d4289472ca916eb752ca4245f5666031bf62a21bab674e845b531c19be7029950cbd4eb51b1e5e32f4892742d56147bb74d7ddef7bd24b0d8bba23cf0534d169f828a9496ff9a9d1e9a281fe94f52040f25e48c5743b4aa6482fcd601c73efff793637bcadb022a39cf24272bfa0c243e76c5708dd215f51b769a21b504a27bdc0f9e9eb70acf02ed1a5fa91a157a55062693dd820264aeb5e9151edc48c8332fae88ceed0c4e8d64013e3592d5aeb65ab663a1d485928d576144c8e60052f526c921547fc34579d7ddf6335b3ed71a761413efddad5a41038e92fcfae8bd852f50281920edc3061237ed083459f2f623733e966d026d314abb4c61417d64f0d3ffc7836e7c7d4911d5f0596f3d147ba5fc84683c31e5d0eb98e2197dd011fff724a056332ea7e2b1a9b7f5d6cbd44be9afa19988b4cea3f994c8038fffd7039a2d7043de3310840c986731ba63334fac17a319734e3b72352ee13c666d69ae9593aa7f01a3d3a7f5c69d047d8055ae6165d33f5e673e2f1d9065c427c53339958ce161ec8a5ed3fd9aa9557d39aa77853ef38e5768a9ab9ff9daaa0283cfcbf7b0bed679283760d9fb9618cc763c17f0d92b7e6bc276b3b93345389ad03c4a0ffab648e20133a770b2d683b693432ba1b1f05092f2561503102ff029c9a14beca41d7b87c92968f9a62e9bedbe01e26a6c8ceb7cf251dfb183e5e516443f4c858fa0c492a6ff86d90f73d63192b5994e10f8b82bb0c95d0f062a7bd2aa322bee1ff337522e58014b1b9c3c8de20f73241901d1866fcbd2017820b22e406c01bd02994cb299e3029e6695144760d9f33e847cf7451ca0a396ab2599ce82adf4bee652abc4c31186963e813976706ab36965f8282d39ac3a459f81207e1fb261fbf6f18c17aecb039348330a5d284c4610869d52254bc2182c9ad1b9cb6493a41659ef5544eede5649fc0f4c815ee52e5f7036ac69f94c755f32252673810e5f002aa39770884edbd14607eb2a24226f68dbdcec404d1785fc7b0f4480efaa230ffa4d1982fa28b95d555ae03ed3deca0295c1bd6fa49aff377c84054f7e0b111dc00cdabbfd5d0cba237d06fb8b8ac2a9d3c13befc8761067cdaf8e8d9fc1b8fedfadef8fe8af8f3eb46323325e1b7260768186d5e150b9a9bbdc1676c664380fdd449a6d7a8757dd5e1cdac48a01563545e9486eb86da73eebb4747da2394ed1e5925803f2384a316405c0f4f6046b610872f0f39c6520768470e72b9f73a933e1ef5b3e6e47994d062d9eeb688d603a317f3cb06b74bc18477928f2d830ae933e99a27c8603c44d95af4c3420d6987d4dd4bb6f1da9b93942718633386e92b799e71b059ded7bb484c3e5792ba177b86db0938cfb07106f83b22f1744134b719237436f8123eb46c135bc9a039bc67c63d7344d20e3c9160fd5c9c184fc2c1844dfa789dd0c8b847bf04951df2a92edfe5c10c18ae9aef40e949bc65402ebd95075510dacd0f82a9ad41a26ffe605c882d7180df613594e666473f7197d0f9b9af74a770f9860ce5770b5b2d25e4e5cab6d462fd6306fe00038e2c5419e741dd4d55be2d4e295d0da2e2ed14f28d530c3467430e6b60b8e071d577a3b65664cd12b373aed4ebae08e11b2adfabf35029ede3f4c71577e1fd442feabf605e58ab21f98cea6e0396c1aec4ff4291597d760c43cd8e750a8468b0f90a5cc1afc77329a9197f80674a94abef153cd272edba26bff1661575b852585ff64d43834e1f8fda5571334010836725f277c9fc8b56f22690ddb19642a2806b1433309a518ce7663b24ea706232c9a17e4da22da24420b0b63e2751913bc36ee4101c2424273b5cf2faab0ec43eaff366a122c0429079576b9c6674dd8ca0ca0ef7dfe84cd9b1a9c8e66dbe64cb85fddc6eda24b0b17df5ed070cffa90681ab73865426b26373dd7a47e70613814be391485a7575d9c124ce5f9854eb7335168b501698761f7c60ab50768665707072f4f3dfd848b54bdea98a1e37adc62022e4b1ec806fdcf90a3bc598474fdac96acd3755b8230c2eba7c6d66af4ddcd9a0fb0b6adf2b1576fc2ececcf4d9e923694b32199e16fc4da09eb906ea2b40b7895132f28bcef721191728124fb3f4f48bda8678707e07bab5aa4dba4c7ef270f55811c70f7d89e75f8691ef76d560f558364456eede815d1a316e97cdce2659146538a96f22c4c2ad268dbc4f751d90269a1234be7db25d2052008334edafe9d7d1b0de16da84f0b70d9542f9cbdeb5056a960febcedab9c3f5cc790e00ea8a4ae8ed2f893edc0560bf3a4f0a587bca288054f856909ad599dc1c87ada7e26a1dab0c87e7ad3392ff6fc22399407dd161e4211daaaa62994c56953f5950fbec678f79b652e35cef1f747ca6f498a0688d921a76027980c7bbc4c82ba2e7dc8cce02eb40beb9bdeb2f8a39a478741d6f5b81b79a6d0d0377d19b36400991f0a2819763bd975eb91ca1df2e4b584e530571f0ae4ad16ca7d4ada6597af10cd7479dfd07683705887e7647a703e3dfedeb161de8cbc688f14b8112b5efe0606d6d9e9a207cbf506a0b77d288719dc87d1073ddc713634246497d1f6330b10bcbe45b0270252fa156828f3480fb7c917475205d4368c1a36652188f6ae3f6f48ec2354ba3e90e613fd8be03f810f66504090b84b31dc5e43034e1b10616bf042e4c3730ebd2fef1d167c6b73293f29ad54e375c35a369dd4562666a8497ec09b8de14fbec1d6c2b03e14d184ce222ba5423bbb2b8d6025337e5db057b10289985224c862536dbd27cb1107c0249d664ab30576cbe668399152efb8ce0fb052f506b4ec83e676b0777ddebd9079be4d69235746e49f9d195efa27f5f59179007c335f357e03b8f4809fe35e83ffa8a1c8ec3e649efabb53d330c2e6b7470a3e15216012aa325d05b97192de6e5be866f78b0a993ec2b47ff34a99dacf68b8e39ab56ea0435c3d31809b53082477cb1df4e6795bc2c7ac8c884fd10b435d729ac186aa6d958276c1993bb52b84e4a955866fd02be2aed2eec25b311e95f9dcb8b43e91dca10ce6769ab06e0ce69ac6ce026a71127a4b1c33b963847945ad55ae277fea2ed2bdf9377ca8b000faa6abe4a7c8b2fa15507e6c01d79134eb644110d0c24afa8b18b930d8b48b1bfb2aa4739c9773839fec37a2831c67d96f15538becc19a794391421e0fb5243125dd510d1401d1c6de8e93cc387f5e17b3d64d819519a35c9b779b785f7d7fdcef92706bbc8301b9528357cfd4d21d2e575b2dbd09149776fc3e10a498fb3004d21fa5c9e7896c1a789259eaa45449acda3ffdda786701a8616106a8460a7548338fafee816e86a86288895b0bcabf21ea109ff01d9864afa682ba298658885a68bf6dadff4135f8654cd7a60f344a2ae6f609896868279aad84df01e81a845b3a7f9374c7b84002a65f69e561bfed2f71fe73e7fa2a4a5b0c863a477087cef69279a8d71234c1bed9ac03c600f29846aefc286c8c0f5a31f756a33278ce703accc5c0286ac2eb1d87cfe73f2d7ab9ecbcb8e380c4e4d0e1a1bcb3394c5ab3451f2c572b99b591c2ec81fead5487a2c8c0864e936936daaa0bb30c3980e45ef29585f165a763e0c4dbd55a45c0b94085c8dd7a91ad9df3a34e300da65124a029d311eb8a02e3459fdb1558d9e6a5be77195bc16cfca99291eb45a45a96640b494441557b0c9e2686897e9f8f96da2260a3e61ae345caa28de61cc859a94abe629a5f360314df9fd82056af25a10d4490ccd16987ebfed7baf083e8828f3012f9d3e56884224bbd70c46140889bf0c616fb59d239286f4cec1675fdd8cd1d848f057ad92eb56f9b16cb67a63b69a02e846e9c6770fbf0172d84f8a0cf99cfb5b83ea11297ab116e7ca111a743d45d2d80c9849afda9ea0f202cc647212735089372ecb6485f7c86571c58a1fda3cb70b14f8b91e99cb6cfe204258f8cc6ef144095acaa5cf6c3416cfe2c560b718d194ca0fb18774ba2240ba6811effb3fc7ec214c809784eb50b1f780f5153d4d54086549c5d80a4579e2b95f96a6c8e0a65b022b554af5414312d5f57e28ef39061b8dafe4dad24b85510d82490ee248c0d89baf98f36d81438d006fc455fc86f8d8f52028402cab4052c7f0b8b20d0664f0c92d8bd7630435ff358e869773b1e573719a43b2527cffba79db3586c26569632d08f83bb84028f1688a6d9fc0a984fd829bb910e01d7296748f2dc9d0ca18f0d65e6fc7c42ef3be473df6ca388e8b71cb6d702c4cca5a7d10ae37fad80daa2f3cfb7b3b3202c1876135ce3ec7d70cb7ef966ca04729b1a2ae911e9e36b0d9fa01e21211746df02cd117b9ed6e5dd704dab1815dc076fa556f31bac4765cc3d8c719cfa24a1d7952ada57d4ed61cec7a1bc6f230072e4542abec0367850b8b386e041335b87283a6f475df9805ccad208c2596cb1c6145bb24fa762fdef0d93f6742e15c6c5821f58db3e116eef603aaec919547a61aa5cfc81190b00e5c62d98311586f49e55202efaac153c77983b47852951b91fab4866a15dc15bd8d83cb41c832a2a51939f20ee70b9e7caf76e6c4db2b62e3196d757457cfc98fe9c153158eebed644a0069ce4647e0c8e3c59bd94cf793a75532fe947909e9955e60492f628e3539ae3520fbe0b1049c81ff92395d7e224ba4705dd138fba9d03484174cc83deebaa9b95aa4b4f8f41c0d94851227a1baa2ad90e158671a0edcffebd485d6e722cac0e2ca3af144aea10f81dca0a1e5b3664193580c040c861fbef8cb2a4b9bfa2105e62b3061f1f5682ee63a94891cbd38fb512fc5b892b493931748f0556c134a611cab0aec1f7980bda99574a5509926e630ec6eff241383b392245c54f7c7aedab17975dda8db69198400d05671756b0436678d0fba554ea8dd7c1409fdd27187e5fa8cf0bf03659b936c161c5f2a092cf77fdd9f12cca8790986d92feb7d22a2627831aaacdbf7a98e1d61dd2799b4c03a81be23e79e6259a8d754f60198f8b40c3ece6b5384a837d35e4fc3598b50fd03e662fe65fd8925737160849eb52a841c3b497defa53fa99097c896d4b732a1dad966fa6b578e95817290ca91a0015756c44f41ebc15e8efeac7a65acda49d66cc8d2d9a66c87a5a533c7d4da71d0aaaacc32abe97f9da7e2c8ae608c452ebbef138b76aa0fcae7dbba676313bdf9eaad6a33c7e9a21a04a42ca429e59076fcba75fa544467abbc09cf283830782875eeb57f9a220e7dd4df74db40cea6ec4ae21ccce42d93ab0fc8b957a2f7f4a765b4315a11b993cfec6666f48e1499625e55979eb003d24160cdb13f59cdfdeda8b337aa247a5c9427c34f4c8382babd3cd79ffc44333223822b3f83b9267ba80b35b91cb1aca61926e8a13216f4b058307fc691b92187dfd356da371ed29201a5cb9f2de197fc0d70f06eaee03d736e007717da86533ef5c3f7500e8d43f5eeda919663aebc59b4b1b4b502627c498a751a8faba17c11113ca4749a0794e89b477a6305633bd49f45044068c7925ed95e9a6cb9297244df62ba99abd66eb3ea21b1fa7445b40634b48b19d511be90765c837b37bdaa8a2b8535a4961eb51426b810d0bc0785ff5f0cb04007f6554ac59409a30739e9ff4c5b0733f044ceefad3eaf785c1eb1684656e45538a500f97782d2366396b2a9f3b402b8c8394ffad73463662c0fb997a791f84a96ac0caabcdff62a4cf0bdb1138d4249bb728d516a29243720525d76102246e4474caf061b3fc3ce4288437bc1f9e2f9fe7927ab5004c174dcd8d95f7e3e5ee97101bddebe0c10756e2800ee033ddfac4e96c0f6b128fe86951f472e726b1b0235e381933fb9243ea69931a1ebcf2e4f012d0dc22489a1dc0bd44c238f7c7a89784fc5ac1fc664b968ad538924a1d928162d267ba97831b368f02c58eea14c59e158eff742dac58208d46be1c0df782a7cfb9df8d2c4f604bb30007621757147be3c072d6ae979b96cbfb192fe8883e3bfa9ca5b04fade5310e07d6c20529d19825e7467f3f60b2bbaf5275dae629669c5b2f789c8775f1cf93699de608878a9aa4138305b8b1b64ee3b1f2d8b2a9ca81a552e932a93fb6387c27d3db579c68ab522d347a96a6d2eb02114d835eb6e3903d596ed68c9d1c204943af595e7bb1299c131fbc0eadc75f03c8949e53a52a6fde06bca15134993df5c3052150632c6178173f68389f4f0500b0edb4b14ef9cba0ba20d68a041320646f7852a500d287f7579ff004d5b8d825d59751e7b28fa2c63feb0bac4f4c92e049bcce766c88ebdb492cba0309dc891cc31c3d8289943e3effc1462d8ec59a7e9b1d99799f198abf7739f5734d835a63b0963f7f89fd4ebd839458d1651c050515fcc215042804fa3e20b196bcc7a8f01244fbfeb408ce75c58422f90f427a22485333e184ff45ebfb34212c6e4ac711f32cb9f4fc047e6ee3316704ddea141bf47fa1959334a0e3b107172b9fd3270cb064d02eb6bc63c40aefcdb321bc1711d663440ad4146419419f57d4652d1f73a9a672d47b29929e0489b45f06933d2d3a5b9ab7b18b374696ded1105de16ae6f8836e83ab0f44be1c1b67c97d6a2256ab33d7320232ea2413427b5b281d0b8a3fc14de9ba892559e131293a078677b994daea13d2a7a43f099909a6adfd988a07809be24d6278cff3b908c95ee934a17f42f6c7942d302cfc078f59cb49ad50fef2d7f7d8d8ea6ed60d2a41bedf0410cd31436f982108c04be9fa66bb1b307824de3d128a70f198d0a97e19481c9a73eadc9b53464c56afe39304377f339c36888d25003a5ffba9a003c58a5026648cb78f17983d76509f72da5aa045a2df0ce387b934f72393105bec75a3ef5231a1e09bdaa5bae5742a98dfd4cb7bd9a5dd0736574ecd788d10614806142037a519bde53ad87b1bf590369bc55a3d683d49b7a306a4ea0f6d3d688d33f6adca498728977ce3d35c9f530905d4455cc4b2914d71f652de851f461439f25a976166e27fdeaaa290836fc0e8aa5821be1a5ebad3663db2efa71bd2fcd3f91c6d00ef8b401558864e0ed303b5a42b03ded2b87f4929b9aaa1c8a9e146af39c50692406ae5e53436a82802d36144249aa74a912d05a69130a1df88fba77057c69f0a8eed8e7030f06cce6d5520704129691f3075fce8ceeb9ef2006b2d1d76343cb28bf9fd92a0630cfc30e4f632b12979d87de218654e4162f58e83ce1c65d97438076bd9967ab33d953bd5206fc9a0941aac84a4556e8ca532889e0691713fc8dda195058887a5b652bc68357c2e9264f73b107fcde5f3d9b63159098c317296d7088db4790dc388b8befc8663327e265b31209d5bd82551f2267e0bea3ea3bdb5e6e29c80da0bf9b6befa45dfb0544a9dae46323bbc0e21a8be9605de4b34738e6aa6211e8ce0b731ae42c943ae83fd74cf6b67f257c8125479a0f8215200880e13d01a24b541a05df8f4834098ef589569ca1891ed439bfbaa88a32a6348c4a1f643165e2375e9188058caa491c4ed3ed14019a05ee879acf931cb1119c1641ca00ac211d93501e477abfef10fa6ea60b8999545c85c033e26428cfbd1458ada9ddf08ea1325d423d2b6583b1f99b0232fa6873850040a535ab866fcb1b6153b0342c235495d72c18937aacf689d92c1a95f455c29bd31085c573f577af2255f563c5d65c5ae87c60f1b61c6a936ead60a01013ea13c522462e5b06c4a14b1f5c4088e281ccbe95c9bf84e3d568fe155bc67021ff67285a507a4bdfc9760e5f96b5cfee63b09d0290421e321cdb064f9ba2e0ee0fa088329f5f1dc9c53158ff4a36fb442fc203a19edbe3febf72cf9ede8a9bbe39f154d646b524b1527c7e64cce71b69d30a4425aaa31ef80082466b65faa1e63a6dea25f65b05c00e7ff012105be910806c89a67709baa0df64a9f730092a225a5cc9e5f23a9e9c72baa703a93a5737d320e1564347911fcfa51b91217cba19d2865130ebc31ef49f9ada0c7e5a65a4579486e28ace489376c20282e9f4379e4d7307c3dc8d79d14055ebc28cd772d2ad012a1e6d56124e424da55c59753079ce1370c6449d2be29fc22eab01c62fcdeb2d2330f8d0774edcb4e0f044b2a3b38e0de4e62832ffd2dd4c7f992aedd092d488c9c94bacd6b4a9a1455f4616aa20faa667225b7d4e41e1690b5eac3cfd03de546eb7e00523a3f900f21ab346b6b776c1d0c6226c2d2cfcc5040dbeb20906dd54e5f90b953d65ecbce13155dc3621620d3bf8473a0dccfb4d793f1d4f9ad370608b4211284837427e96515f681125fbab9abddb02bb96dd54c98a99a8fdd52f4ad3215ff985e217530ec1079ac1d030d1941039bbf23da49e2378e2910fb10f3f2189e81e05a754c6639ddf1eb1df8448dbd00b95cd8f3932bd6bc3c0dfa44d6fe0743ce10f20d4a0e919ef9a901cae719c9c8ba33de22d59841167cc8410925e38713b09e5dc9bc2d7294d69065c1e0774db8d166f3395e9debfc959d572e94f21a2c665eeefb41dae20d5113ba63096716a8446c7513dbac46306bbcd585146c8c4cfde8cb357764885b3e624558d0771cbede6407130c7d0660d6b348c184b124069c7f3e4d8fe06691d2c0e7fbf638b12559a05795874b91a8ca2b2ccc8a216c3e8e22474c2aadbdb9409f000fe14b5029a54314230703c384a2ebcb604146a0dc5c33cc348fc38d3c3f6c00cc02286faff0a43256395ec1654895b0e5dd009b39e7cb94263a61cbd07716ec0626f80e4fbd2c183450ef21e5aeada87c41bb15c8eecd7a3f57e5ecf8914e3a1ce6e56626c3665920227f63cbc5865882670e20aac1e400339a71ce74fb736f2873e6cd78fab92be57992d5c2822f85e76c9d64c2ead7666699b03f8335ffca36d9827def9c0d37ec11f5a8985bc7f0bdb192df8eb669d5fb136b5f9b3944421d7ddaf63b832ed12b5662828b48795b20c558dab02a6d8784dfa901157ff98217c0ea63e71cb1fe09db323aea8a884ddaaba125efb852ab895ca4aa3aca1aaaa24f63d75be8545c03b922bbf4714126c2a3b2f5f343b26b940672bdf51d174e99a096a8d0f36e98ba1fec8cca8df9573f1370271d5ec638a37e8954cc52d88c35dd00da39fbfdbb4cec3469ea19bf2d72cc7245062e1d7fb637ded956c324a4189e4f047f7166181d3db1819e87e924b50e9f2019e3b5a87524d89d8e03355355e330e5fb246922f3a1ab28743d3a2ab6fcadd61d527bb4f6455e49477b7cf97f55614752b17ec1ea3f7685a73b4f3aa0cad9d41708910eed8a3fa314efbb9a6636a9023e888f704933176b75784db62594a5778925cf18621608f3ee18ae0c11838518936bbb528ab67f7c92ff9f5168fd89a8082684d572eff18f9b53a56581a780b72dbfeb3eca83612a4071654ad51f8fa4512f1a2614b745030fa638a4fdd66d9fa8e3f499ab980dbe70bfa5fdeec9006d6cf641dfd22ad80166f42260de98e47ff4fc185a5c692d0fd943ec8d8b03be34f3559a34ea3d0e1859034f6c46c16ab6de38ca61a6ddead0a919149e2164e37fb1d6706262dddffefce067dece3ff1a6a82cae5f0ea1cc5a265a4da3720e2b5be9f4dfebd74fc215637181014c48f229764e05a8bb3a10d5473ec20d355743d3f802936b2f13ce9f9dc162f0b0d1dbb63439d91ca7bd895a79e507477755e2d08a02b8eae195caffb99a3d182d8841ed0b6767fc3f4cbcfb4f21a44a9b35483c0abdec64f1fcece820dc96cfc293c67ee1ea80f9d1a34276af4e204a7dabef4e57f387027656b54b9fc14ba40b0ab139ceaffb6a962c7320092401137003df66c23f185647e11764d976a7fd242b451c49b13d63cff3bd135c1e161c6112d27448091c45ad96049638e00d84a75789e74b95c7d0529eddb11e4626ba43cf9b9758bec83a2a105387be3fa7bec8eba48e6e5fde129551d19c9f108cc39ac3aee49637273d9fb7052541e49e27bc4c8f7b30395b4d7a364292fad2e88bc9cd20930782cf421d5eba976569d9395a35d6fe1781ccda6e761d92e48632604aa395e7501697bb0dfaeee395f00566dfae3ddc5f8535b409607cbbc2255db27db1f7f47411f95999ec485000af7cbb6cfc1a7b8d960e785e6d572a8e5df3e69628c17fbd03af8f983f9c78216ec17feb658524290fed8518dd4f0233e82a9c29d503478a830926eaa3763cee744e81d8a731c9d0dfc3ada6576be1b043310f2bf9ccec1e0b5ade8111377f33c72d6f40e75d6379efdbe7cd1b1effb945c0cb56a0e9e6173fca04f5e0e62bc241aee4e97b6c17d7989dea88c505d8ebf0543de7619ecfab296bb69c744c2397d53fbf540f4c5e8007a6ee0ddf3a182e88021952f4d89cfe76dbf6df8ae486015473797ee3c6d182ac0644a4c2eb8c7d6182cdfdc26df335ef0e7352cd446b1d97a7a367a60fd0ee90ee8ce3f5414e4a601d602c280fab55b0b1a2680743c05074814d8edb02d05e5a2df5c4f0b3b1fc98726f3db34bb298773885f66cf78ddefafe3de89e5bf570bd5387f191e1299402a49da6539e2077e412bebcebf8b3cc4e7edcd297ef6da4971d72f6b6b3a9b4d560f01d062a713573ade7196f2f394b68faa23d4be1973478468d0998a85f4cca4a52abeb7ef23b8f5d0a22bc1c97bbb47d4c668e0e774c54dbf682e340d6675106889659b00a636d631b3683e32b1f03726e7f17975eb3348094a3c3253bb099a5a45c5ebfce3e2759959550549afb05d70044787a67260c004326edcaf9b98cee3c505556d28d15cef87cb6c6ccadc93316b1c6ac0d1e0ddde47964e054ff7492da23bdde24768993f9a56d4d0bd5ed00c31479f94a07c6768ee2aa845287acb74313a7e4f4b037ed66a3580c3324a613ac5250a5997a4931f83731945328781d9524ac08d62fcc20d7758309510a7b43c5d7abf7de205c054ecfd3161a5032c61d40b1ccfc3d66b97cbcb433447394ccfe019a231667f59c995dac4650d77ebb866ca560102d7c3c5c9fdf639084add809c2e731b95584c8117e4a856afb963eb9f3c26eb3d76fb2a17fc09e29bd127a53ac062025fbf5cb362296a594f2095226d4516f8e713cf0e60721741fcf6566f5fab78ea2616fb727c5a1357a8ec7e26ad20fd8d080c3aa77360d557dca0fd2a3b930842f6580e0ccda360ed9139c045a823f5ef2c68f4f4ca63e7751b0c4f2f64935aad1e0cd4fdce10463d0c0fb31b9224e20c2a4da44e334e2202165d66ae786d5902f4bcf66dd69270fa961ec9a9a554acf9df6671b608fb04bc5d3bfd3e625a6fba59171512bc220e63f9c195f628f80d7cae3e1eb636757821dbb7f9d23112b69de27d14ff314cfa0ddcd587a94a0a51184a962efab4bee17ec7783dc4464a65196eb63ff9130db2738033a28eefc9f1a9d20ad7e2bd84f175095e9c841e2f2fa64cb21f8004a1620f9890ae1b07711d990945f83076a04bd8c8ab503cb893ceaf7318a952a708c0e60e8cc64f1068eebb3faa52c9335a4dbda174f33d41f908500e8e45b019101de9ed749f74b1df5898895dd115c0f44955e46d6749bb537ca9a58eadab3ca07f261b199160546c2f83e8bd0a5d4ce742e60b8b85876a16e06c5a4f77a85b6c4d759d7f99efb87e860454fe8204abce12847c296a937fa180d85402d35392a8f09fe7f7d889991be2b43fb4831d70c05ea749e7efc8b6cf7fca58d1987a3a90fbf7b0b8ded9bfdcf58aba69031b3271561289dca01d747542606f46f8dca5feb04ae1e9dc779a3a81c7e4d9a0c77","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
