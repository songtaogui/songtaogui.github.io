<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71167706e8ea61a496af2854f8afcc3c54c364cbc4fc1a98678e1880547009921e97526c4672b8e499b954e6cfe5b3db4e9009752e27d6e5e75b2902c6f0fcb26cd870537aaedb9442297fd0e27fce925e410abcef7f034f1dd87d3b8c5b0e64a0f74174d3e96352b1236d0d876425f17ae3d22ba015d0a8f1fe511f1aff3801dbb009edfd15d6fd75449c0db6b7875d27e4a5bb36bd36912be80e5688a69ef07938763950bb4f0cd4cfa4b3663aa54262fb0317a9bb7b1bd6307cbe397563ff087db3554dc252b8e9f12bb0e091795e6caed12193c0a48eaadb172753d7530ebc430c97e979c64a3c4263b850ad4711e3c9b7853796bd134e12fce5097705aedc0076d5e845b2bc87b4b9b01baaeda5bc7bcdc517f5906c9a8db59814900dc52b8f6c70dd524adb6bf6db1a4c40005843af645b21f2264af4a6f475a096c3a512768a891e63e86d567cc92de8ccef83f2ec371e5d13076cd25f0ed1f14db244c557eb1e25129dcfb0c7be0b62bc7267c0bbbce19ac13c6769d07c41aadf7d924cd8692edd4a596bd500b481e50642b370f50ec4546d18aeb89e620b6f653ef5bd6a6bae7619063b2c39ca4e81c2d721b49e810ead841782f44e6dd509a5d5ad855cd1b84e4ae478dfa556b43f43dfaee7ba52c09c13e754036e1eb0c916bde7aabe4d308d2567c5da5ac3246099bb8b2753bdbbde7d63fdc6de350a7dee8753cd136595702ad595ea68621c637f98acb7f6ca609e3705185c2072e7af09e87376529ab220a15c535ed6259a6f1216c1cd6f116c058174654c42646f8c7accf52aa264ac3bd35894186c1e4051f525ebd5ab3ff9a121a5bfcdce6648247d8119067ff7f0b6b13b0a41ee0ec89325ffe996c766819d9b9e02afb0ac77266b96d438f6e16c09c03ba86311da0794b232bb689972f3d0b08a9d664abfba0091af8b9d3f9daa6c984434461cc93640acc4b927871ad29dcc76244e890e68305285c3778419650d47f208bd44035e234a2fb5f458e67346bf6444e9a767d7b44e2276d2208a20cdedbfb9070a066f436a27e407308d170a9e9108adcff79b4915c8db63b49ab021303a4bb4fbf6a60bb7335638d7eb0b8f2c241795cbf0a682623ab85619ac2549465f89083b2791ccb2f160ea6e6e75712502a6fd54c4dcfef40361ab672c15d904d10183e9636bb6da1d2e576e02a1d4fe88144c1ae873c7fd6d58a3dca2a0cbba4ed490c4c983173b5ff183f677490436657913bad9d35d9c38b80ac98db065681337fbf15e9c3add28693c35d22be80bab08eb760d86e4b6a8ab6d03f41106e7f6dcc061396809998f93ddf2d484a9f3f426439b47f5d824448e60d66ee970941c834fed94346b1e680b5219be71e61a9d6b1af03f32cdca815fe76a76126a38e707dafa6d632168d11011cef6be565f036cb8ce3075c5245435079df9788b13c53ead482d037576ad431385f9f9d439c0c2ed4f765f6cafb747cdfb676bd01e1291fe670e7acfa9da8c8a41f91a736a17f7d7cdc2eeb2d3905d077a093803a556f3be2eee78997087b5ea4123bcd152cd52acceb2d507df28b7b8501a924a7f18612e8a609ff6a280ecd0c17ba27faf1b6b7ffd973a10073756372a4150b77c0cb56e5099dc53befb336266e6022b6afe17cd579c06ff3ae401e0489c4a37cb4a251f3cfe8376cb49f22b3f454aad1acdd8c61edc625c88e2ccff78f2db93ac3319a401767f1a62fcb03ec3412711cdfcc1515fad4ff87b1cedd5bbaa8571ae87c741ccd4ecf52586ad43145f25de6aadac098b6ad54ee971213d476eb0f5852d04756d0daa2fb7241c6304ad91e3aec1c34621bfde982a8491ea6ba13cfea1ccbfc4a9a44478026a963c46c699ce69bf799d435f9f27385a6f9185d838076428e7efdb3188163d2d5285e72d7ee419bd3aba0c335104f8c0d45cbaf46419d40eb85a100d6ffdb4a13d7ac65623ed66a162f4ae04bd4a094caafff72c76e255cad6509ed02a8b4c217bbee2c267c11f00b6660ee2f7a68431ae307cb3401e2bab06a47bcd3ead7c2ce90944a155bfe65edb5b9a4e57aa71ddaa2a2a9801f7f397f4847bb204ae8c871afcf4fb69ed22434498d7036b4e7a1c14c9588cc76dae1d24382bd4b399a28a0afd2df758d34c5c37190edd778d181ca7b48d0c9534a8fef5dde4179105f52a99e7ffb4be3e910d7a815cd4068b3b7baeeb5dee09e16115955c2323cc6b284f6d8c8269e2d46e6842538a04c986eefae1c137d4bfa663c586596f2a396cbf94d2528d54de7905a6c1f9bbe17b458ea32ccec7ce1ef61f0dcde100ef4d2f0134ad5017737b43eb8f80252fa261ea75d8be4a1c2a319c821ee859c355eada42f78ac6f97c16cb6d3f962a07ae5c410d09023136ba770fa8375b24d11eb10a250446ee477dbc9b34b88024ef349eb3fa4689c21796d9c819a73598c21cd3ebbc8a287698d9dac853ad4406f3248bf87d190620158e2eee4a885ae5042aab7497e7d69aad1cb437ed4ad8ad3881b16f77b603ee1356283833cd51f7d4582792ab474092ccc9c924b52fbfbf2ecb9c87c864240d0019b84b4c307001e14801128b1b2efd0476b9df7081c2a1b14e3a0cc2066bc961034e9aac12236b157b4d2d1694759aca73ff0095008a4de46c7aac30966782fb93bd65a8fd29adbdb649adbdb314c3e46927ea28ceccffbffb515bbde3cff9efb36d447c7c3413d561de6ce4d2fe0ba541dbe5156de0a2a8138081b5752411f80ceda43f4616a1b395ac28feaa340a5c272477ae8afe326ce3181cf78dc27fa09bc325865f4f6d289b2d4d90c938565c685e4d01c389c7b589591c18f8b632dcaf763b5f8d5feafb69d3b18ffe8d8784305fef2725072ff8f0c222895ba0b117e6b12205a3fdc198bdbb35116061cfc3081d59ad6a18d7ac510cd03e2cf0b9a676b49285c50c5a59a617becc305e0d58bea799bd326f1fcd535ad795bdf97ebf7435cc74349e81ce23a40ea1549a0d7ccd57e6ae063a2e988fb821a9a4282e8de0ab1a6d24d6f1b18eba5a653a3578162cfdfe9ae804b2db102fd17a28c5c749b1a8fbd5cb4a2ca8d565486ed00d05cd7d33d949e24093d4994be2e803ee074c04923bf9056807700058607b052bf8f504f4ef0c6bca419bb87d9a564f91a770bf6c82862c5bd2d3b73744c9a81bfc598a56bb17f7d93dca47a0d8de621d001eb0f69cba43b79d576a0546c86b43979148ba9f3e3b922735241eb487ad22204f9e43263e55cea8491c2505ab7ab567b9b1bfde9946de8ba19a68b294d53cd3ae52d26acbc1ca7189a641f6192b563396a18313e565fc3aa6ded22b49a25e30034ec0d533dbe9e4232fa62421db2d4bb5da19521cc50f0721ffa4714d25f0c26bc069c91406915b5e7d18e446090bb9c48667459c9be91241b3c5699e721a8bc1755328aae0fa6c7693f0b3d6a5c5b92aa39e5243fbe3ea4325afdd16410875c1066488baf221361df2f528e1b42a1e6984904b789e101351e071f3c25785800458f11e37d92c55d880037b93cd10db6894f4e9856e5936f9c35f00c7979de04fcb0716b89771c4c829c8285ba34a771e68741fc268238dded6bb7ff13aaa850c76a93f756382039d99a93b22fb0e3d2db02a459ac208c1197b0774e77d81eb3e4665668fd3cc15aa148bc91856ec9ac7134e4affe6eaa9acbbad4920ec4b6ef00ece03c297d8640fa749f185b1b0fcf8d8c324031f31273c42131181a0b77f2bff83d96e1b78658ed27e91b0ee484b8a5237c5e6f65fc8128f358058090a2b0e023d29580ec4e0a62e27bbb882e4aefec41ae51e180a127f8f598f29040a080d3015b624d1151acb24dd80d17d2935d02013a5d57381153ce98babe366b574ca9e9fba78b22c1e69d4999326e5624a95ec741027b1ea5c6d4577733b4eac497c7a231d9168305fe095eee35a3b4ea9f6c9d8e170cd6213f8190899c2a03179db4ba3a278cb9d26eac9e8547525886c06fbee61dfb15bcb43a646fbacedb2992425f4e0702defdbb80c8bb8123451a4ee6ab41ad2052ee53fb2c2b4ac7c71258dcef136fd7937af3f74764785e1ff254c57b95ca6f30bfe36a16811c5d075444e8c242dec79080fbfd486ba52ba3904f356ac4583b76a113b926af7ea921b66a7ebc660b0c583a85167ad184b26c0c0bb806c3292d388e3c56075cb63631a28628c09fe66690de37fa70915736bb39e50c99a9917a24b1367ba48d874c7c7ee3439b6d826f52653ec5f72186509125552f239c58b201cf0b2772e5a68590b00ff259c2cd6b0f6477e611f4f102735f5290507588ad8272fd2af051d0caedc44957b01c5fba341dfa73e5fbf784fa477864de5e5f411202496d0a5a2f806061a4c00f092d40f3c6a0f9772a3744d9006e6d4e2946ce03d7cedb7007dffbd1844fcc9212446152082f2b17240a4b36067fe4ae9dbb09400fdff7a4f06656b232231a53cc202c5f12a2212eb6aa7cb68815913bab00e6f62f28691532a8d73ff4d7da81ebc6f541d807f8c29999a4529ecb25efecd67ca3d3c32553180e47cf7a928a0f4a15b0f49f85e8e1bc24c49665a5bf4789540ebd3c088e172b35cd76311ac0538e546465d08690a356f5baf7fa8f0e6e508076a1313ba72b0bd6cda9e9178c1f361137168a95ecd24f6be5b3e1214d291ee9850971727761d467f524bb1511d7c29e1f1adc9eb0a7e9c1950437ee66c32c3953094f75470a090bd2756533a828c8e847ed072bcd023454c4f927dad2af17c72ca9416eb9243fc7f3f7f27984d0f90e0a0056b04c1f448aad0afc24f964df22910a81344a18623d021ff6c288a700ce00b666ccb918d0ac8a10e3515db227b21e827c9aef770e4995b178d9377f0acc3e1299c4146d996c654d628949c74d107e1c3818e07ef9c0594e99f3a53578a62f65fdc2d070f0a170039ee83bd6e484d85f4689d4eae37a0c978b4f7c831909b8c832d3ad3cf2803d1b1e8e2b0aa1370224aa2ce2c9e90617e1c60cfa29bbf7adff147c1bda1806c360fe4af0497ff1326a265b52bcd61669d89ed8dc4bec2186e968ffbe71c17615c4d9ce96f3510b0610ade2c9055a10e4ac41cdbc64f13f2d388ec370598747290df67e24a2827d6770b8ba39b631a29742ffc03304efafdea15beb15861af39deae0f9fe39b97573c1cbdd0e1b49a038abbad1db27eb1fdd3cb3b43afced34ae142f131c6a4c2dcd3287e506e6aaa6c0e852d93a4eb56098a57b3c74ef9a153ea27554fab40cbf1e1044df5c7187e4fed7d4ac25f1ea70e9267179a948e9adad689854381d1dc1f7a78b64e3fd6f769428d0a45edcc4bc89ff9a166c323ecba6eac13615a2854c7e25c0f4e50f06f555bfac2ce57f8acf8d4f6b8aa53e5a615a9c52ad9dce9c68d264414e43ebade7c9cd12ba98a1782c79bb954441d286bded71ef872bd79c096591da468f1f403a2cd524f9fb2a53b4a0e1e559c54220c62d782b5d6c2d636483200757cd768d86172e7169d9170522cbfff471ecd1b826c814c7d33031399bf0545163d3aec463765a46e08e9d111219d63a9ba6892d1fb017225f547a02d737da12da83cd3bfda330eb1f569e74eca5b59eb47b5086288aa1a4e6b35a9141c823762463610b21f941b4d379473ff95eefa89f5d6a61f54f051a021930705d39d0d07fd7d733073d3acf8f0d2be7e841d531c0cbdd161fdb8af703062a97cb9013ea781b845aa1d85681fbf79b6fabc6dbbc88fdfb3874a6d6aed40c1002d89469e65d04f819b8c6c56b50903a8e63560f1f2b1df680a1e643c03d84504bde8fe811c7f59ce4e43a42c3044edee541e706a4727954359d601ef556c603f5f08189ac8d0c1524624e492c5bb6d2e877d2bc8d46cf02251d73672b9071967e80d788d227ded329480e290297446c191940a181bf702d98239119186be9e8270cd286704773f498c2c2e099b73c3402bf5d18ef4fd9b8a1d727e25c9d2b9a17d1a8d723ca15dbcd391f428e3d95fda801cb01606312ada3cb4e8390074be5f03005604afd39f04a0c1105097f4375ee6e6c9797a101bed72a7173d8130be6eb571624f424e83ea5184884601f44ac191899e603798a7791876584a1b51b3b17b6a5fb1056e6ec9d7177d95ee20ba216c5c1abb45764619bad952e6ce65a3dd70fb6fb9e2fd685c1ed7704c616ee129a6439d490d44e4e2b859bbd122bf734e2a0d0a60e2f1997104f63e825b981a69e41e0e2afa172da78c37eb71332e2ff91d3ff5f899156f67dd9185891dd70cd2b7adc7817c16a5ead00cfe3f73e961450c83798d40e89ea2f38ae6828d93276b385ffb20ea1dd42373f6f8ca1a28e179c19621f6b0916535d748ff66ba6bc045c563b95d078e109bb90b9657f51f6f97505a1de62962c4d74f52b3cd30e7778754cafd8e8a99871414e1bae6d81184a1e08ad76f6014e21c3a7c1fa88ba592e5873609942ce0a9325a867a3de49ffc63d8734b416b58bd880f0a76efb317e33bd644b355028a2ffd080d31ac407952f47f1430296bbb2a349a541f4d647a063966ae5335a669f48573fdcdf1e6bc4f1bbd4380c7df7df580dbe0b8fd8fbec97ed107258ffa91242655986da146822cbe136038ce79d971764bf9372011264ad59436f852d024223c3aaf584afb4c1304864edd82b3e13e59435d5f26813042a22ec26e758f20cce529385850a6c07c802d9c305bc19fe1f4c73d9d9d08ebb344de35f89144adfc889cb9a15d124b9fd00e0050475cc85ce77aef454a021a1aebc001b084aa35270cecbd742aa56435ca5bc442e51fd4c056ea238d25278f1baf1be2adc9653befbf9ea2f41506d6a13a3f27eafd3a8382bfd2b73c58cdc295b02877de3907ca415961b893782a2fefc6131901edb8a81a9b0a02334e69eae6d259814ed220066eb403404932e09159cd815d99858fac981a42d6d883e4f9bfb9f0396a3cb24fa7ce2761e69dcc6a154645ac4e39f39f194ad8b424b5e93a80ffa47015f92c72a34ed0dacfb9335620fc93168fa848b2debe9f96802ebfc935b7344ce82b19c7d68db53f3416e8921ade6987142283e00ed91abfb19a48bae2f755b519b13386e80bb5b6ed2d08cdba214856cea1e183c9e5805e109c3ac14ce7919e1ee073f768b7289a11e2299c39aae145e09ff464f389d4c9755c5bfd4e5dcf6a6c75fb7673933eeecacdd1505d0ab3d29ac874c2376b73b09808ae1919d72e0762a62f386a8c2f4205b447f7bdbe229383d0da16d254a83d7ee3631d1536b64e18f8522e5750c8a7e044bc4e8b68be3bf2394a0de8126777966940d937bc2c73b7e96bbe21e489d466bb08a68978d99e59e77a1985c911cd9f5e969c84d604a7a01d3a94d97a12e782cf44331c2cd4be7ece3253f9b57a942c65e61c92ae5089dc99b669567135eb9954e78edff268ecd679119d386ca095c25a124417b90c21234f3dfc69aac49d7c9d1864b6c61696e280fe9f89dd708ed71e7e071818e90d51a6ced5a378d815463199de93691d6328bd118bb4b8c021b495856f94cb11d1ef0668ed2350fb60b6eb525f58927d39c9603810391ff4292e59e615a9deff0d9cdfecac447697e4f84af8dbc9215c0435c929e6718b016da7db0cca689cf22439302dff248f029e8ef938122eee204ec94b25968ca6b5ad23f999437d7664b807023d2ff425d352da3819e41404d9141b0e2822f40ac2ac4b5c4a1f5c27bba266914a6b30c925691eeb8a9b1754db4ac35b5b9134898a8e672a59e3973edb0706b6b8cd8d5fe3b3e2ccd2f29b56f9d4ab88218f83032172d0f080324192c09bede5f0ce5dee147cad03035148b1aad27bbc5f44d385142e73f5fccd41614836922fabbd05ef133fb6d4d315048c88e27bab491788f2f528340de00c40eb761dde5178480dc2c41edae70639dbbbb4630254865da1922751f540c01ebf6bff4b71e082f63bd3bdd3d62daf86d558bb5a543c92af1f387a5948db88034400f6990b9de7fdb3b7c04c5f6f509490f394451710ab2aee0fac0de1845c62c29cb9a484871db1947e27939770a4d027166fb3bb3d24402fac028df59d4807ef77885447aee1f8d755d3b89326fa41dc27daf59d651c8e28235b5114f33a3996869ea58610c06b8a9cad6d6325f189681f1a0afb5021a8af7c9c183db842021c96f9c43b56b8c863cff27b65f847fdadd783f6564b8f1e85afa4fe5467c875db721737fe8a5ddb9c8265be22420634711a68399e6941250d03a0f5f9eb28d893b45546fa52090c2e763ab27663ec50975c53540da67274f92725f8fe690b883ebb1f081b5e7c173d66144be1833186ba1df811c594250cdb50bf59d9859d135f39882eef62ccc8bbe6811625dca0ba49f63de0b74000c3139425886604a4d39761118c537d37434e970567746c054710fac1276a517efbee6ec4f98da476554ddf67e53d979a9fa9ac66c9cccef50df47cc83cb1efca00a0c8608d2f2d10328b9418c149c1816e64b2dad6514a0de182dbc731fc3154b55b933e5a6e1e811362c8252d7df0af57573e7286455ef78d1c0a2eb64dadaebdd5d8edb7c11cfccb94dded87a6744468cbfe7b81e318c1c7860e69a498dfcdefca53a2bdef97223d0a78d6b214c53af4ce907693e3f504fbbe192b9128c567c9f9d06660c85d21909c3d9131a928d4cdb25b53ffb8218799584ec025a65d6ec52dfb4772b2a911733d9585fd9933cdce026cfa1fb31624dbb9ea16d3b5edc52b1401bd82efcec3296971904a51601dbaeb3cdf7872cbe44a909e89c8ed7f3c7b339fc5727618632da8e43fa2968811bb7caad38e22ee20911cb7ec1607ca4ed47d99dc98b4a0c0568b7d1921a3afa6a4f1febeb49381050f475102ac803cba2c348d1b203667ba6528d53b0af5e2e8dd392251d26377cd9a098d8043e40c38d59ce712e24ef1c4dea2334788b4ad0cb058d1967177e2fdbc51349bd7063435f9a2dd206f7bf68dbb42ca960818aa58fa7253fa3ffb1513db0b77d7710d874b0361f66fbf67f1676010f3182fdbd28b93fb346f38fe5e2d76d80e3201e9f0602cfc5cef9e7c7205713889bfad7e0619bac51489eb2cba63ae1b7f35593b5822dfd4fd2f9f826e768db29bc3583c84dc9648d2761b00a54878741871091fc5bc0938527272e86dc11c06f595586ebcbf6bedc257e50517349c55b49e6b7d6ea107955124afd8d8f48a82e0eb123a63d83768e93b6c9394f7318894e2e03fe2ce554481e9074997f769252809568926c68db182fba1bd3fd0a6f652ae6168f0c2b2bbf76cc50e678d9156edaf039d2a80507dbb0b81932830d3883a82cd0fad3259375630ef821b5c20589a149a4eb28f419c24b6d8e728b2eb41e9850b35c5a995aa9b891caf72cc158668e8d967d78362a72948a9be7be01b3526b464af4b3b68b1e924fac28ad8cb9f013f30acf211e58c5c7ab6c040f1483206e9e583251270ea285fa86678e7cbf3fa78281819ce497741daeae975baede1386842d36e3020f522b08daa3a838a1f5671759e89aae35849d7f8f0613c7def51eadc0680d47e659e5d7084726f5bec6e02ddb1a0bf429bf1e8b37beacce42b064f08e9578c0b6b67b137c3bcaa614425a31547b03f383c5b5c6c51e29e145a2f01d61319e10897fa194b69a80740da3d62bb1b19070e9f4735a7fbf833b303fccd0ddfd67fc1f3ae0a7acb99f017133c97128e95d64ca588d695786ea780c6b749459e9c1b2739d8daae530f95390d3b687f6940b2810e575abcc6141d9edf4b380926fb64b2bdbe0377579cc828519e470fc9382c7c51ea214a8ff7cdf478781ed49feaa8470cb34517d1d13e6adb34dd9761dfc47d1a65d129197e3dbc5df0068e91ea33c2500ce44af4e68738319a6dc86f32c29caa130fadee8fc44f52cc6ebc91f32fbd7a59092d711635e5d8aab98820cac9517734b17bd6cb1fb8456a9308376dcc58d0a49c9666bc982a4296e19f24aa1a006c7813f89bd61086debf060ef18eb6ba910f2a0c301d2ac12365df9b7e4d448e84bd73ddbb6bb2298caba61bfa91984ce99161f670557299df67217989cec103d4b8b98ea4753ac305fe4061fff9b411aae27a8534a9f2e168d9314c517208ba2f232e30f31bbf03fa6e4c0a07fc2fdfdcbf525a038addf252f348b940e4b2b17662e51ae0ecd94bb97b479b239ef127c50e92f95f14993761079c88275da3d5dc3fb5b223c1bb89cc4fa810afdbce631663c7aad91d0a8546b99950c7addb99e46df8961d5a61414febad7b111a342dab9720a4f983a3e27ae10d3ce5c63923265ce6fa5c5e476494865503b080d1e93cc98734eed0e5c1b376331b06fc26008a1336531379b038c6212b8dfca9585ea3e37aaaf558ae92ce8ee70632fd16576997c1088455bffd779fdb3deec5942223eeec00b50bf513437a1c18cc9101031740517ef28e653172f51bdaf0c913ac334141c2964784e4b2ac7b7bdc18308d11b8c8fbb79d8cf16a0208ce3b9f5d11b2d49e6fee2a87a70e5566d826e78ccf4b694e9820cc1b6f3fa01fb94d4d9bb85f6c4f03c7e78da5059c98e53add7728a7d0f8aa12b051c4f7ea607134ba5dd6b5646ddaf5f33808c849a8de7e43ccc7a8cbe7f07108374c5cca794091b4ce6ed8f5a328789daab155f5478c8df4fab44bdd0f1973609e2313a322e35f4ec918a6113764d6ca9a629c87e80d43b40e1f44dc25bec395d6bb8e92314372b757f48ec33a758d902726a1c6336d7d88eb06656929e379aa06eae950e6d52d30a07012d356840a5c23b316e20b57bb11964cd84e7f2fb4f8fbad0fd157c4a7d85a3f1cdab65acdfa36f94eacfb325fb4c692e30f16c7404178479899f542ff72f1c1dac1d3df031017c1589b11a6855760ef9a10e006ed7833e8c4650c72fc4a69f0bf35a138c97bc3d2581419fbb628951fd1e8aa5576e7f6f74b1d17acdf1d5928d0eb74a2ab665754ab9e9132a5ade9c0125a054a88dee78b6dabf2132585d381fa066b3ddfa53b1c16e4b7378d0605e60a3af3d69bfce444933524328dd75e55f8f0217cc2a61978d37caa8a131dcdc088c3db29387c04944f8762b718e21f2094241d176b72d72555d0c6bb8b9690f79fa5cba96e77fd9cd27d393ab46412382cdfce53d68058c153fd1f92b5fc8a5affd3a1b646e7af7d7c27e1060b9f568a66a95e7f3431488eee61f0d5a2f08b2694bc37f86400e0b1c1a49ca827488770d1d559b1f2d37568d676b9004760c0ad448f01687ab81d5bc6ab415c4e80c8d9243761bb0f924e5aac2a0aca1768987d36563539e0edcd4def70c1e7e9d3576a2c927b6c836fe8c65b579a4efa214814a575ab82c05963a8a4ecb72c4e4fee23cc0f05523ec64ac58380678aa121ba253976cf03afae4500b2c224c7eccd1910622c74d471bba0c990968ac0d02525ca1fe9b6c4139ab74bb5cd66766123dfc66b1ee735cb9eb5e81a7e961adbdd2cd199837d648a1dd04a1af29cf07e9ed4b5cdb6ebbad244c72a2c91a4a1c0d1531da1fbcecd40182641804323ab7898db38f6d17980f657399a2ae323399fde2c3fe1e874b2ac7a0c0f0cb19795cc3f96ed8f8d1e0cb83b3b6164a6d4d0d3d8382f0b6f18bae6643f1f68ec5eea59e7520c21875271946111d8a9dabb56ca4915d74ebdbb0dae4b33e6e0601f7230aeff9b748556a1943e89594f18de80261f3f30ef8429435725827318d2c6d15bd7036e55fec75ab52bcd56d2c42506d664fbd19ca47b70a69445873002d08c075328d360022b9987d3716d806934013097af651d9af641adb19a07d039bc5262711f71833ec3253515a19e18b8e03ccacf3e43040780f451df6b7956c7f03abfcdf2d0784259c2d561f536b0bb4ded85d671a76bed95a97b6e258e5e59f35a4eb0410675d004bac6ac77cb7192db21b10de8681a42db4c6a786fbd48d79c2cccaae44f6f58b100939fcb4ddb93ca2bba531f77820294c8624ee16af620dd1cc382f8b104ceb34ceef08b98184ccdd99d60eb0f00c8da1c2127bf492f5c5e7c394a70903e248ea71e49a2e00044722346488fdcdae6121080596b37486b7bc2b32a6ac470d50007d02b5d68fe9eaf39830cd772382d4262dbdae92bf408d6e1d1e68c7419a1e0af18267e61096320700b9046cc4852b7349cf6417dbfffd75ac5b1620bb367ab1fa938cc969d553c97a7f07968db24f1db5ce7db3920f8e1078b733d18804f36feec1e79a21b92344fde8066702999f589d0fb364d835f0f7457eeb7ce866890a8cc0fdf3d234551f5ad443e57b3ab1e5f266a6c086e74bcef544053121c09ee6aaaf94ab17374cb0db6d843c6f173e70bbd8f7f4cb788af0d5d06b74c2dc92208a1b087d373aa564331306776ff03f4d053b3c62f713d71c0110bc05e4aacde0f51a2a2e62b6e3e8a5aecf3c410f147dc019311c7a95b0bd4d0e91731249ac367a3accf693400f4a44e66a8d3a227c3427206260d801432a54e6ed82aff8cb2e1efff1763acb6fc01542c5155525ffe5830a4c70215a297d47214777d35e62097605cb5554a181832ea0848f8438e9723ded4c4744d44a4037d76131c7179ca3cef52e7b777bf96360f2e506a608883cc86859eb6e229c6d9907698f6e1c77c49c3037350a0e297a40492e3e918bcb3216c8c16b8d8b27ea297dab4f887cab3eb1c1cd66468b0d5525a89af903107241118c405b0e546e2dbf0b870816194ee0bfa382b0dfb498cb493bad2cd1cc7c42ccc0e1b790fa257bfe06adeba966e55e0fb25e66242599858b42ba917f7a59c606ca754e01c46aea61aefe00847bf836b77ddb10e78b8c03c7028ef674a88c6a8cb2a7d13a808ebe7a75e8411b36c9a83ca36a658bc711df059ff0aa782c1dd00914a0ac315e627392a76259b5a724633405b0202f6bf17e37347ba501c58c932c640c6aa6447cbf6be4355fa505e8babac3b380f5d11297f94bce047f61915870eafa1e5b4515f3e7ec7eb4720d3129bb9676837e14a19faceb01c77ed087b728234fc184695506b51a54ed25d2ea9a9ff1a19e6e45b281784b9ac678fb5521395fa015c1ab3e57e5ac93bd615e7a7323bb53f8e6adae213f7b5a8083798cb7b6125f930a723efe3804256e5890b04db1b061f700dd8d701988b14c710586a44f9bcba3a6523b5d6d2335d8c9fdf86a908c643715f955e8b684ecb8933ed3ecc75067999ff70e8524fa3909d57eb8a01cc27e63b58681b15a6718fba2f25e84223ed7b6ef43dbef9daf732cea515809ca91a0098e78b627dd21f1724fb8446eae7fbb67401f469257e671e7eba9db32a75516770d5f2934b14a7d39872eebb07c99d384166e94c8bc349a2de984030387165e14000a4f5805aed5b4848d6cc6dbcd110e1a5cd5ff41724184bc4124be87001e130661608b86b34984c5899fca77be50b080b090f745b222eec661631254ec0bd92a7092e74e536739e280ec6346bcedca8cb5aa70348043555fa49bc67a5dfe5ac2cb7a62dd86a8f892c4a668092f521094af8707e28f922b1223580ed791783463745a5928925abcd7a390c6bc9a2bf15f6c8a98eb11b6792b30315ffe3703ccf94060d66f2b67fba7b0dd51c4678eb934ba85359476279e606c843ed45691f9f10fe65ba66d5b25f66e8c7b22fde555bd6f3b03e702b19e37a4a3bbed36e280866b99dca4fa78256b2d2813b91002cdeb9cd5936d300acd9f81d884448be31662a19a4fc63b465ed55f575d9853e50848b512fb9d8ac3e378cf3bcbfb2e368c4b908015f5a93a99883085d7feb7700bcc0524dc1afa9e37ee31a61c81fce038b2f0b727a178098e708f1fdf5ade3ad4d48f80380cb730f82824894f2c51f8a17d0f4d0bc6e6befe3b653edf3adda5d532aa449eb7865cd8c6ec254f33993bb2e89b957925669383e92f176cca50e72fed92501c69bd8dccad1fef28e2e239abf066969da5c38f6999d45e322070e29f11b9eebc7eae8ea3051df28dcd7df83f0b2f3c5bacfd889ca90d404c82d6f1a568bbfcda06b983f292f0e0d4efc32923a86d0b1770187cbf8eee08d4c565670e159ed8cadf622c34c0f6470855cddb4db49aac803d1dc18fae9b64b19f114ecd7d17da0a5686433be390d1d9d95d72e15c1615bbf944a88d34cccffd9eabaa5b4ad03da767ab7a2ef8acc3bef13741a4b3f34e42e07b67df14549bab4dfc28fd016fc996cb9ebad6836b4d49a1ab3973991f01ec11d4f832cc0a2014afcf03113cf5259bf9c4a6cf0ce2e50c612afd1a73d152e03515b14f4b3aecaa071251cc377870296f27bd688ee280d977008bcf99fde22834dc404d60e8f8b093dda947d635ad37cc97bde35ad58afcda6b927e9dc3b4b89899747bd2d569d6aebcb70b4cc53dc8586d6024b3dc21e551098497bd8a8402996aca4713342d451f0df4109caad2f18d52fc0c54b62349fe76fae064fb951520fb9a22c71bce80e967952709e985362675cc90bb01c5acf91c3da2b1b29408690ab40642736ffe13175690d5d5308a71cf452fef033b8a9cf01dad016635567b5e9cc0e766cb8a9cfc8134a8cf46cccfb17771689b7d70d729c51b47a406f40c0cd3fea575842eef7c69c9dc2fa4dffeb804d9007865175f2b398f5b3d0bd86ad5a41bdf2f99e39e62c1a1b95863e6a816523437a345839f330d57fe983a048527b4a762788da2d28dd116c3e1d76c68b520d0748b2b94e9db7db8597d0dab042b07e20b462aad46b095ee9ee66f0ee309a72c538417ff740c5d782ef13a1e07735de6ae4d2fc7203c2d71a5eb2ee4030cbe2385d3856f3d88f00d427993bb1481ecd5045d606ff23d711a49a4f7b459c1355a63b5fe2a87fab8f15bbb2e956f0db6f58c127eea9798bf4104e4523b0bf7838142af45534e1b6331373b6e4f80e5fd0ff2aca32e8af60056575a11f4d24db2c4494b45a9327cd0e427373546a2352321b6d45726cfe8f3708d692855ee1f560debf85c0526d7da0cdb789d2aba54912a8e12e9f6439cd1ffbe7523357e982d057df6ab4d1fe5c9bc7bafd7f9b20446427c8e3043ed931e4ef57e86c69e0eaafbebe43cecc2bf57c1c1aaa3ed1f84a6d576d90faacdcd1275380f7398d199061c1d417da1e23c9160ea3e643b1abf1699222992db37d007d0ad606f6fef251a954e5d738b264dc9ba3b107d11314c49d2213f419d1fa4b184e942248e1230dc721ef70af6354b0fcaf60ed306bef87459f53cfe90f117d7d34d114169378d660137b907cd4fc5baab68fb5b963c8d11061363fd6c865648127c6f6ddf8b4148bee919da998699a233d6b1ecf588ac0302d03417245bcab02396b8b97a89908339c387f37a6d4c0e7a8f5b2e713d49a61103cbe46472e464af7682125d160ae5fb8903782ad22f48eff81cc97121ddc82ec4f16ce0abcf44dfe4eab471278e5cf1c0242768be30225e771470c73dcd502f7404ead7632eb20f259ce3df8bfa632f39792ceb64f32c1b8d576467f80298da1699f4c275998f8d13987c4dfba6a70729abee0047eaa180f12305b87e936c2cc022fde7efed0b276c9b18c94acc1d24542f4509911e0237d663efcb004623e57e0d9a010e4a717abc69ca5abadc66f4baf7e321e4f58295eb0a3ffebff668bef5a71825ae5256a66a9ff276b7fb4fb4739efab4895e838941cc82cba63adb1c5af18dbbfa81963c02b92a11b469c519aaf60400865749ef8bfde075dbea0c905329c62ad230cc46fa5b0a791345ac52e0315048e5312edc86217e50ef77bb156586a35521d0e44a2df907342df1567f8432412c08d5ed28cee7ac7726dc46c707b3e53be5db762f0eef76d3f05a5a801a23944df0bb78beb2b7a051344f3a61d386deecffe0f1caf08c9fae303f91e49f306489c1627ddc60f6564f79b5f8d0a7d95af9e0eea51912412ed919a5e8bdf265e10f3209d19451655efb5233cc1e0695ef3ef768ebec5d1ceae15fe8b9ae95102b6d6a79cb2149193856d581ce71dafe9eac0a923bfcc5c5540a00efcbedb5c6c9be56330a3f5cf7eef110ee51fbea7288f2a237bb32721d0e075ec764dd164cf37f444d6f6a087dc92fa02335105aa9ede0d2fb952bb75b1f445781a7e7cd685fc80ec51b0bbdffb7a04eedd3167b3337ff4893f1a2ce860978f95556f0c1650433d4717668f877f9f587e64b4ec3bfc5fab2d2bf747c907b4d9d094c45ef9a655e2c8471081c6f030304d3f56feec737c02679dbc2f6fe7ea119ad3e88e0a7b608326616faf374683a74e1d23ec202c9a5f6aa92c6494a15ca0537cee3ff1508bc93c1c3fecdb431a1034879ed46553410e2b87371401a838a258c28993ff23361440f0b6900adaed418e8e1184cadb5e0dfaf8bfb521006771814d38e2079d97667a20c082ad4270ac003fe8c92c8dc6fa184c2a5d3ae66421210b2c0a6267aab5dda0b30715672f29b569eaee18094130d0a238b6b93c93f53d1d72437dc889e28a79e7f81ac504dac14168888e5d09c7ddd054b28c60dda140bf22db70d0d6cae7c58490809ae0be91971b4d4a85835837783648e3ed135d0baeac7a5453bcfb4354dcd408ea4053dee15981b261e7e0918a463646c40b45d039041b78ef66efc3a439722929acd8f9338102b31f475969d7bd7a919065c978b69d72dff119fbcc107e48fe24bdc05a486fcaf4ce6af5cab438863b622dc3cf21b968f8e3608b63a6224e10cf46fa2903d55382c8cd8224b2b328be9f99f51c4771066cb9ae53fe65300459bd7cc8c179bcebaea2d1a309c68c5ef390da85d7a000cfec42c25b5f21f6cded9e485b12987167f146150a319213a244a8544017a8d36d682455d7701b3c7ba3e0c163396c032f1d2cde05713ce36d3cf0c103c940d9f652ae6edbd14f6f3ab4409155a5e890bacc95620a036141db8d05dfb5afa7508017350b27be603f35f164ef00169cf6fb690006c73d6579174ac0a4489eaaf751631caa6af731ec6e8b9ce702d7b7e4e2f13132590a6419ba11d41336b5434543113b72b00f3949ca2213304abeb7e6b5dd7b5481d4736dedda6d99ec8a876284d9291f4d2ca5ec44846af59714e3fcd1a3c5a8d90d210c6715e448cc2e989da5f7b06aced10bd86649218f93affce0323fdf35cb77e3ab28aeefba1939cb63d663ac85265630b40850dfe5bfb0a6b9c3181beaf1599235000141bbe0bab974efc7e4d648e84891f1570625de0c47e64fec53674f5017919bc5aeddbca136061455b12b864f02e0255256d43e52f837fdaf04bd8c0fc496641d834c220b29502b05b94c87f93f8fdb737f34dbd416455be1647ef718605ab64735b4f06e28ebfeb37e8dd37ad39d5504498d9ded43a6a4fba19e7fe0c9c442e1d206fb7130c91554673e7a6ed66c0a7b2d043c4f0d4bf1358208e70cc9e4c86e36882a10cf6481d1c507deeba865fd99b3909fe2097ed45a990fe9c945c40d7b23f8dc1037b61df0f1ef7ef3fffa6a53623a453f7a792a1692e62da80d55ed80bb2dfc6a1de59bdcaf582685d66bdd5ef53bfe794bbb7daf5916a5a3f31281138a28c281fafca8cd117c0a39653b8198c165961729c72671bda3ff28091b92bac0847bd91af81b8348dd1130dc9b0b14b387e0f4aedcda7dcfa12e7a00b7aeff808f3cecfee8451f9338578d8dd7abec43656752ad9ce266799b4214c12ecab01183add6bc348c9c28a9814a90e9846a8e63126b2b892bf101aed364a683639566fda011c7129e46ef4e93798581b0fe9569c0aefe3f5da775dac0361af11130ea4ea26ebb840a3d49de825ce4ef95c2ce1dab96702bd7b2d3d3d30706df8584009df0bce87985c7c62a67ed0e9b50f4a0405d656d2ed9b3dea956d84170325ee9b27437192c721350e2ed35be75a8712228b6116e70725f87768d5a5058170397b10602211d94af7cad821061fefdb1a2547e4760371d2bdc22f1767ad7926380d6adc8f5255a2fa6adedd5b59badfd9ea837487b6780cc3b1bd2181aaa24bf77757f345e07d46c86eb3faa969ec9e96ab643fb5aedf6826784e74b4dee28e9a832814a6ee8b6a3375b119824d73db0b33e2a2f787d831d379eb0e25883abea7409313eea98741fabc5a4d271edc4f3cb98774588fa884332ce99c72bae9f4264c9a06bbc62dc5532d02025be8206e4778dd7acb7b2c63a6bc0ffb4b73b75cb47ff847018ea9c6820f4d61308a2a53eb338a0d17e136dd190b65f475e8e77ede844d50c5a827c5f01b87ec8ec7278048fa8f73303405082f5e63a65abb1e12bc653f6b4bbb716720cdd1bf2b6fa37d30efcfd48bf5cbf752cc2c3c628a9801156166ad6e8bf75585c63ac89f7ff250cfcdf5fe580ee3c6494e756c12d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
