<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e8e770d0f55783bce7ad536c8e09db4eac294c8b4a6492715a6b5d7e7561acb0f8388f9ed112105b853e760397292864e67f71679eb27011e1af85f6c5b0dd2f59f5534b896aac0b6c8aba97636ceef0f44d8cce6cd5a47cd9eb102ef74d5d269946126192e833edc90ccacd7f8004255ae2e9095396ae330b63edf17056a8cd495ab284ee861e485f934c6dc4d63c6d1801193ea46bceea5494b89ffc01af17927b2c9c995db579217f1a340b699ec003ee1bdfa0189530313baa2fe66d068d4a08acd1ed91b20fc0bdcc9b7e347b22810326c9a15d6a34d9db9de0e4c22d671ef6df6904d4b092bd28aa02f8af81bf5a289310c5a76efa4f0585ac6b47e8f2dede6a78c99c8afceee2be6b847b98e7a37791a928a0535cf42a5bc537da9e7f4fa5349ca66f193628b77b70e75e8ad1ac33da9b6f84bcf43ec8f29e23b6deedb3f0cb4b2ad916180b511163034ce54738d111859c61cbbba23a179552f90537abe7780cb6414e5c18d77b4d35ccb353295ffdc4bc66634fbc9aca95f9ad4b5cccff7dd8581441ae7f4e4f3bc959357915dac06bf6f5cdf681c6d457780472da153711cf18467385a5d4bcf2815b8d7183d9fe5e27dfa836ccd1a15596418b3d0fef9c17189884044f81c0bdbe22f6fcf1bc804b6bd21da9b7fa002d836fdccd2b90875dfc51f7f6a1109cc8a420b318f8c07dfcdd8a45d6219c596a0384eee2df6aa6563ea819e7ab55afb7b6562324989144926ac624d79a5a4274940a1afb761a7a1010ed73ecdce94fd2a8b691ebb6d93d9f144bdf8436565d740098492a8083c7ca32cc2210d05338d4baedaaa5d680a708a28c7fe1feb3694277bd872fac11fadad64cd350857862ea298a4bda7268305095b2ec66eab5ad5c0e397f468b6fbba4a908b649c3b697735b91f20d66d15cd2c67bb566cc186e26e438d1786410552eb04c6c3d332f9cbd3bc3c2793b8f49d669e5465708a6506c3ad7b7b3e1019ca3b8dd0d189a730d5f1aa11659a8375b4e430d255e238482e6cbc2bfbc415ea483ad03e873ee31f96c63c4ef54066247cbc813c12fc2c5e6be5e5109e0d877d53b40e89e317c5b2ef2c207052a870496594354847b2b4cd0beb8882454df516b272a3f24a6c6ea313c41b2b7cb845266b99d1fbfa43dc74e7a1203f8835a9cbe3389e9ec7453221decbe93cdbc2e7a0e7fb67bd3184a46ff2592d2ba864dddfa281c9c16012271380a3982195f4870cbfcc7807aacf38c80dd7e2429fceb5ce5021f890fecc13e2d51b95a5b12234f6966539c05904822a487e2fee3446a3d1debdcba7c6467bde62c34c72754d53636d2c16f2d5cbb8c843aaec725c8cd3411a1e9780624b9951b64278005c2e65c9adc662eb44bf75ede5d79886babfe8aa49c1061fa9caf27d16794d705c6a9b020007d1eeab7804d3d5897b31e14a952ef7e7155a00218bbc38e97214a43ada34d08a4b13d362a660fb55fd2fbb0dba6bfbc2d92e466463a59d3e1322b0e93357e1d3113eca20db42f21b7a181d26f27170d6b6c2084c3f84f481f9e6b973d97a60c2533db0c32560cdc21d7412146c833a93d51942316094a318bb01b0eec3fd5336febf43fd32216fbd4d7b023f83a33fdc9b12fc980adea77292487c42c059ccb3d539aea6755b661ee5bf0942d83ad075977427e05216a906a754bda0c40846473c51dac3c31ab19ceeefffd2ceee2d879b143cc7f753641492cfa32ca86939d8a2890754c7374f3a5b341bd1f11542c8e6c39d1cb3de7ae62e5d1edb3f839f3408103c969163d42a64306bc78ac43698a935add518e93e9a8456850b3da559b624bee18420be87fe663606cadca22a77dc847501bc5e24aaa0b75dfade3ebc584c7bfec0d761617bf441dee8e6adf6682f51e8277bf06b8e5fbc441dcd85b11e1b269e2d4968c265a2b8787c38d16e5f95d977e4b8b79c0bbacabb414967d5ba635ec12973acaee3c9a837b0243e7f6bbb96c2d3309a1f9805ed72b423c210547b5618f9720f387af05c31bf4662b71601272d9cc8e6e791b29777de27a89e789e931da4367029e141aef93817a6b38139fcbb916c9a62ca80c977301addc4bf4a33a82de1cd51525135dacef4161b11ff569945902251f938adcea0697e8d306ad16f17f1d65c5fdc8b4236310b7998ece0cba358727fe235ae9cf608d1e9d334278182c7c1d42468548911ba5bece7adc17f897726470dc2b7b82e05e585b8dd635368bef738fcc4b512a2af078824a7f8cbd51026d74633f7abd6fbb4a63ab3fefe69af1ca148773f4cbcb38940414ab1b2efd41a3f26d3f3040377a3fe7ae8522a467ea7c7e028e9c71e4bc2dab169d01734cdbba840616323c8052e284440c89bf3ac6201bb0ab6fb09f607b5fef9149e7dacd780b143567bafc71e44204907fd6d7095f28110f507d10debfda0a642a2e7231404f30ae6fbcb0b3fa0e6b03e91b1ee20fb8feb5535b7a54fcf29e8648ded65f85862ebabdd5035d4567ad71a0cc708992c489f46603019dbe5c339fbf2546ebf979c3f49a1272b7e8cd1bac6eb1b41681d6eb32eaba38100ceec3d09da24840c9269f978942e7277134227b0ff76a88a20bd8ed6700cae14197656fb0553ca785f48d2ab865a3b1402a41ceb37b476125429e21ebdc64dcb38767c9d33d112f4fe7cc7fb31d5f9aea5a4a0f0184149f474c2287af36a111a7002bb932268b6e6fd4da2779840e0344309c4acb0dddadf5f009a8f9a78c8a76771ec813199e5518202b673fc662caf690335f75665de511eadfd361f36867628cc9a5f4725100a6fbd270fc991ce71130ebdf914317dc684e442a1d3d9988d892b9b70ca8fcd9527da2e98e2e4190f920abd9c3cc6064c15ce142da14e01cb3091c063e8c5dd3cdeaf7fd424f43cbb2abc1ee4f00bbfcddc678a7e63b786aa99e862954ff5c5ed547987a555ea0c4ec4471f0bbc9866c1208efb97489f50b20655234be0883b17632538eba4b6469c4709df2051857425f8145f5eb75b375cd477f8b37221f944ef047551c6f294ff3608009bf7275ee2eee6ee43760a9607359318cb5156fc5d30a937408216c56256e01a2368eb239690ae2295ee1ce6c39e627222ae24afa2afd238942a4b762cc294a9035cd4225f5db8d7517fb770860c27e4c7e7a174863435bb3d9073f48f7ad072acf1e27219a8a239d87088a803acce7550f1394741040ca64548384f8b6f7c4ca5e23500d8baf3c743d1a21d3d87cde3c70afdd0ddacd7eacff9a00009c7a8cef2461717b191284cf5f663e3078fdef855b5f6baa52b97dd37f8765e0bdbea31e4c330088333dcb4608473a0f73732c0934950df78b6bcbd5291be663ef5d2d065c48430da3670a22dde7e71a38ac44fa77a700c4179056a46a1d839def21178b50007c7a83808605e1a93abba10a24bd6d01aa5f3f8d1380e202aadb3fe769b9aca1b353b8fad950e863f3e4821f03402ca0360a2664a1cc2a204ee1658b44c29852b6bf35ea3f819743da4c6bdd39c4d5fdf73178dd7827eb546ee2a204b04d0164ce1ef0754e704fe5caa8c5e9724a08a7e46dcc177db0adb1e0fc51a6debe3297b35739c4d7540064eb479ac002d15a0089dfdde0d3bc864aa807e3a6fbbb5eb821026b4b672afdae3df567cdd1bf41f65c3ccd7cb841e5f5603d93c0b3e43f2dc349b2386b4c466f7f849b68ca41654f12309e962bf15345cccbedf112812db47900348d5446fc65d0429fd3d905a78ef071a6ba58171f0fc7dddd33d6038e2ffae81dde947312d5e6bd321c5f41c4d604ec3827c64fd8b24d8432ee81c3a79d36680a2538fec0d763aab2d801487bac866e201425481641c65087648ea235950189cc3d0e996cd35586d925d2315a2b0b1d313a0bcbbb1284cf0b28d39745431889f5f4aec3977c833407cdcee10b5705a2f0d49f94252558f8a13d7cac2e774ebcf31d6faab24cbc0a223eb62a60aa15e7f1e7e2b2d4dbc51feb366aaf57c1b451b69de9660845802e4cf29a1cf1bec7833967a9aa92dbb06fd97c3de226cb9a57aeea50a9b0d56f27d69adea291dd2c965249e44c378844e85068a2c3b3e50d1cef53878a5d6d7d35d7c8f3b569b238643b4dbf0e8a0a8e7aae6448258032b96792d0154f703b5092b260d86fe914f5d47a66564e4df2b06b6d3b574854c4a817b0391e97a864a6ba60f7a70febd052d744c1ed92f4366e15915d04468aa13dd43a89d15552e5a7831f22fd0360c7a22e6d70a31780b8e2f9a0cbb09235ba88b28e15f71be206d000198dbca7eb3156c16564cd720b7e4b3b2d748f30a70a6ad44d99cc96a5df10dfcefc1ff0ec300e385ffae6b0de1c483daf86794c18f27aed01fb826866ee073823a56ac491c02d2317d24f10c49bccd1d95152c00d1bdc7a63928ca3ab9e7851b72add5bcef921e4afd871e68bcdb6dc08917400460a7fc0e33f093b1d4a4d11b310f4ccdd881699385053dbf3963b558359138703f6a8cd0e4eff7601aff9becfa0a2dba83221d18911762883d86151db629255932168be2cacf861e1af605aa25917024b24d29280a657fe21e86d140fa9aa0f29eee2808687593b00a7bbcebad369396b0019612a4f554ad21ed3a980f9738e6ae6e9d35cfdabc1a49d7f7a4d48895e80dc2ec8cc8cd2ac51e5d8cfab11051a8f26cac7f23f037ebe47c646b20c28aa5d1db456a8d42f80702f1988ae7c80db78cafafb1feaac77a3a4ba705e8b920fcc025c9ba970d3bbcad0e9eab38f1f2ec58b1547abfb06bcbf7f505902afc4be1e22f4f941c380002cd4fd8f4de46597194976ffcd9df68d034aa48ede13fffc26904ff88a8d294877feff1a14dd3f8983601acf7374670dec3499e5380da59e13aa9b948a6c401fafcfe95bac140df7aff7dbe8be29970e084157eb1361f0671c080156131c58f1516ebe8bb8f1a78bd2f590ebaa4dd969b5d2620cbcdbf0b2bfeb899c7e6a059bf34ed02aec27a3884f2928cba0d7a6575a90c504e59a7c93f8dfa135c0f4e9b0e90ebd01125158d16c3ed218e66dd408a148841bcb2cdb8bdc754a1f18146e0686928e26c4676153297fb47cfeb7c79b710332ea1d1100c71021605ea54fc3b81b2d9089c36414a7c8fee996bfc4e37cd595fdca037b4b6d4a4cf6f72e23f7d99ab5fb0b8732a443a27b3f2fe4994ec1247d97d7ecdc15da7fae8129c1159a80ffa5fe54b61df59eac487dedc310413ef0432445cac65e15016af3799383ae4726db33a5010405563947a1def3caeb6cade8bfa98d7a35e8e4512d54c7ae940e0917c5a8cb139145b01bc8a1bd4c25b7794d408e155a7c7b2a964655e97fdd2b47dbf96a8dfeb0eb87a146937a9dd5edfed5fcc3b95de1d6db72904b8df6defda59ff09c7b28a80e54c72b6ba551b60bebb971c03bcf697c08eb7d5ae9ddd87b14a94cbe1c6450b34d72a00fd7c610a8b20306b9f4a0ac9868e8d4a63205ddc9bbcd8a546b1d9cf3f5025e2983c919ad37591acef9b3e46f5cfc6f657fdac8beed3ed4f642c9a6818c9443bdc84c6fd9da2988b673bd22de3c5f1637aba1e8a0a76330b1ccd860b6fc4d9f32be1bd37d0db13fe7eced8b3050b5eb3106aa2bd168cb5f9e13e25c555c72bafd977d74bf9aff216fa1d2be2d48aae865bb14a6acd9a3dbf26afcde15c6a2da458ff5d8dca8fbea9298abcf147232093781f90043887640bad595d05e3823f069da21a917399d670241f18bb7b83bf43672817859e03543be16ac9a30769b761f71df59c4842c2a1b785de9332399c62e169690dc35c8475379e3803987d92dc22554cf8a36e4f57576e9b417928214ca725b0c4c29cd37d4cb1406ea1b79e697d6281c6b6293867958cca8e380eb4241bde8aab7faa6960925c7441966ac9c8865a013b1d04e97a37c06e14a95e9801d62c4d76d2a9176840d5a34cc961ae8e30817e741a76971ee8d46e4ae81b329e963d0e91259a18949e87fe45d125ee3397596a0af3e26aaeb35417b56eca56bb28e01cfa735429d88e6a420875180a69e4f0dbdb80b2f8d8d9a7708b61bf8c302013c3076819a3a921687ddcefa35b1d6eaa944c781cf9555e55491ada145addc6e32dda8f93661d2434b5a51d0294fb843fba599b90d43d2fbee743f646b169a10b8c38c7af7e6ada8b10f78cf593eb12a8dbafd9c164d7093136c99e8431d60e8fb1d07546493fbf60cbaea7a9a13d4b57ed534e2b7d3461e6541e889faa66b1da30f1aa0c5c4d9b10f7bbf8826d851bebab569b1aaebf39f02ec4878211ba10908d9faa9afe4b357bef4f95cf1faf0ffaf73a5399931d5bb12f0288a025ab053f0126c51b377443ec7ac655b5eb6bd08d85e47d055c8782496e05427812e0534f61c6709427699e09171a7dacefc1672280316585b0119459a71fdd870ecdaf997472f7c5123dfce755b908db6add7b2324de0a43c4f9a3c9a6ff73fe70f5a33ad0cf0723c1b9f37959a8bcb77dfa0d79186d1c5496e7879312bdcbae6206c2476fe1253d50489e8f2d81ef8779469811665993c7bbbbe41eb493eb93ce21fc4d2c30cbac0a78fc70a0f878cb7652aba688a2fccf7f14b9744b478cbd2195f8f133510ec8e296c209117d9bbec1179cec400321a5cd160fac716f765715a06c4486f206156f0cbd77bc86d43233e82c07be3080012f714d93ff8a09f49c9fbd6467dfd6b4af9922c0809dc51783ce739f025e2a2d052af071c79353fed9518d56450ee131b57e912d34bd1edc8269890b17171904a2e745cf6712ffdcc23215160c4a408837d4d6a63d0d199a5bf2d452a3c550d4f92441e32e286a30e6d408df05a840451f396c3a9cc3b60c1f594822ba76d7669bacad17549988d6789c85f30b6c46b62ad64afc2749fe7ca3262b2aaa78112601a49fbcfd71137d232103972e49b69f73e0cb9fdc21505b04e2d3b32271e2693bc791923d60b5de839ae90f0e4ddcda360db566077cca939df60bae646643a4d2ccc4bba5ad11fc70be718ebae9d074a82fdaef2cdacd61d877c3467fdaa1baa91b864eb08cf10ff00428c7acb4e30180e7f2351b0ec19e507843bddba88b7cd3c3188a638703473e2316e5574816065ab250d8d6af31e99968ec8ab6c831677c3a4e965074af82d27c546c700f3e6d67fa76a2a20df30d7a5cd74fc8275a8ac92639c9cd1bdb327031836eb01bb57c313d054c456c47e3c83d40fc5f4fc5a8c8104834d23eaf856425900c3f9c17c43a07c78ea8b10575891bf0e2bc4f0119e541089c7bbdd3a2f51fc59dfda19185b3c7a782346fadefae1d4ad4b3288113cd2832b621057c60a5fdde3f7b2bbaeb6778e5ce07f30635630ea050fa50f0a070d0d5985f8c4f1882558797da3e4ec498e28884e71ef82f8f6cba0cba078348e09bb6943b4c6397ffa21da4a99a74a9c8f80394c4d3bf7aeee5f73d51de367c2cf1470deaf66aea5eff134fb1d90e94d0608a70d4bb0a196e22dda03f00a25d71db8e87d93bd7911a0a59eb7267b440cbbcfe12efb69377aca098863ea727c41e8a4d253c5e8b3c0e9324b73467eeed74587f3922d05e98a6dec3f429f77984c0337586a676efe70261a0fc5aec2351a6e37f289bb460f18f839f8f6268e3d9777ae88798b86159b96e038bc08c479d29737ef396d262af2794b5ba2f6341e2f1ef5f65bdb5eafe20d66c69c42d54837a6f343b1d8b7b1ce39ccdbde31f9f2da30a5577ffc57dced919fcdf6660db7cbb4ec76766bfbd462760113a472dacb4ef5549f1d10f6a1d8327d42c75d474d64fd1529c299c094b3b10170a30d55b5120de67377551642032ae6a8e86d85a5170c4d5e860ad9483036a1929651d761a2523d8071e7e2604f290c29cde2c11c8a291192429d0329dff8c77f2baf562e33b0adc7bebfffc73dd1346ed65462f444c88a8c889f237c60147414f4909fb8ee6517c04c9c146b23ff500c268aed8c2565e5eff79e8c716f3b07e92eca4c9070dd749a9c60119e0db451ba6f62e59f540d72673c2939d2a8ec900ab807e90dde4df257918c26ac561f8132dfd7271dad5da0cc5f3c62d2e7bdfdbb41a5d23faead4e5c97c8f3d6609c685fc7f61b6bd73753e9deebf77b8efb2ad5356c14b71b19458c40fcc30cf4f1473ff7716d6428e8844d25fc4155f4f14a8dddedcc25daa82d97c8957739ff437b70c5b65656f66d9d102272603c5d7a31468e2203fb47e76f8787a0532ac668527384955b920f1abc03815c232351d642248f034d255993949f8933e31f0bbc6234c5124524d123d6c23d3dc679c924761b57be8a75ec019f80cc302e95058bb0875686b9b87c3083a90b6cc1536e93d86778c63f0aa8f324ce2e726e28ef05e06828ab56195ad841da0fc4aa4f765b3d387a87a9ef646e73742f102f2bb3ac5d0b718be38c9741ec4524ed9dcb25f51b054432996d3cebb3177b3008140139b7f71fa56148aa61cf2268180796707d4f101771a96a62bbfbcda63972d23e915bad1b2ff9600ae259fb1fe52f3a8dd21671f92aa139c1d52ec079c87bec935c97918465fc16cb4790300f611da70d0d6ca5b7d264f2a433f1d2fcbb08af7fab395a2b0076e9e0b44f33ef74fae79d09fe26b6de057f54967ffb5718268975646ed32260b0eb464fa891e8cd83cecfaea851a58a4117c6cfa68a4ade92da3124425167940137fc51dfe3a2252f203821ff2d4950a4b495dbd58aaa9fd21a1e9e9d78bc29d7ee8a381f8130c35788959c981ba7dcd3642675df43831a7a1aeea107d4704fc1bb98cb8ecd2031717b0a7eeb1865623098ddfd0a6691c8fc7115a642461839b10e24742f50d0beb450d34c80c17aa13a0f32b9cfd130941d1df262a47c8b1775c5ebef02f75e0230fd9f5007cdb0a2f1823e30fc4e1f5f03ce834d7d3694bd25129e7cf8ce437ce8beb7d03572f4e4b9ea5a2449a5a624e3cb4bac5edbb96bf8a44ccc818c9b20a8d8032bc6315ab2d563a40775f39b8b46bd1d3df49e40ddb068c28d94df396023d9d9e418fbbf6059f0418ad7cd51ec5824e20fcef150acb6c1db4c5c6dfd5b4eb168ff1332889a75a1aa3cc9f402a7fde0d06c707c2ea03b32b3fca4c8d834839dc2b40f6789089d6e2bcef35b0a2c7ab36500bbcdf5137aca442798bb45f90f726df3c20aa1035ef4024b48e89e0ec5e284f7f9be8480f75eb8a0699da90fe688d8f418b6546480a13e39379ad71eae14cca45667088e8c28dd48e61700e579a1144ec9f0dfa6a835dfc0a3dd1e5a2d5b72b586e0b605970a1f2ea6515de9e29268818fccb591c4ddd01cc5038fa1cd670a67d2c80015fd37adc913bde1ce048400f08805fea53d9092213de9be66f92f5b85127ec3a4c8a34cd3e7f0503524b3827026774b4e3035a93b9d3dea569714a37f264dfe812df609d6b1038c963da85ca6cfd36bd0def5aab579e5c5708016e9ad2046b9a96a2b27977e53d4a2a6f7bc3ea9a1c17611e224a16a3de201c3056263bb1697c4099d553ea9ca67994db6e0b342f35593500227b30fccb5a1ccfcbfc761b846ddd11fa2af17881dab42d4fc324288f37b9308206a0a197970751a49eba2af282821534ca84f44d858a3f257f1599347d14345cb08153c3eaf624e4dcea062e9603903fb29502550edc2f22a91f94ea2d117a8f72d8de95419a07aca739e1b21e1864ab1bdd927b3f5263df6a9ce93b53ad5c723705334856c4c21d815cc053e63104a65263d6262941fb82b1de1c4f59fa821f69bf2ddafa571dd590a5647d3d300f2b8901949d4fc4761f46fc4330203abbd5caa77c6cb606a22e25719b0fb5766e18456620366770ec4ad7954cc5b7b20e4c556414ab12c5dc710f11f2965ef198d09fa2485180c4238e3a3569db402ba08c13fe18dfd5dd4f50af6c6d3b04668bbd611e14bdbda5ac6312186a52f1529854811562f36953247e415e7a438180a1214aef5cc2a4e93533fb3294a3323c19b89d84858253f6650fb11c8f599aa806b915cae0f384a2e2a4fc31eb0c985beea0e2304d965b8911b8c4295d23557616e96c86d5f402958fc997252ae6edf62436360e2085894158be31002fe1fbabcdb980fee51bca3723cf9c5a9e067b88c1dcfb9de222bb33f8326c52f62c2b18834552c71c5a843d2c2af4a829d35079d8cf7548aa2a679fbd09991971dd1bb2803c0cc8a574c09b850e0f85357b4c150e05a6243f04abc2a9531f50e8d378826cd1cffcff0ef1489c3c3e64e98803c4f5513edeb7b550798754c0fac6f7181d3138d66b7b47c3b30c3952143f78404e70af81e1dcb28c9f47e628c5d8dff50200996a6d5295451e9d115aca1f3c3a1a91b96989334a8856e893f6a5236505c358656820cd790b728449320491ebc058d5f233c58619140e6e0886e643e3b17fbc5fd66c0732c2a620935127f04ed79b1da566239861c68a5b2eea320727b25ab63c50f0fbe3e7bac6bdd6900930a1cffcb597183504bcec43fb0e7458c9ece81ef9279e207558e0116f6ef39d4e125141f207aea9f1c232eeef8fa5e3dfb34957b0a3b4c8b404f5d9a2f95ae63aa159957a0623e811155569a6f27193ac458c208ff5b22e3972f00cffbba71373668cf9b300556d599febd10002ec9f745c37a24d1ec2ed670a33341f7bbe354f62dc6c9e6c07796eef592ae89d1344a3cbfc1ed0245c93abf4f653275b2a616b237ddf75bff438a2d818355134483fcdacc0e6f25414637b04577052dacd8aae5f6dd46c5dc87719f569c5cc214d5b636799ee6d6781c553e046c3ae1b55951902aa6b1ce45a59121e9650a242dce57babcd5ef3ab751aa8e527f2474f5245cf9e73ec608f3e3ff234759e5f0da47b2dac6a6b63c384c7bf68e140904f9172c92d023ffb8f9462514ec6a8f5a86718c56c4d6607a9cf49f897bc0ae38a47798955b7336bfb8d4f9b2f24dac21f2a9815e47ad2c1cce995b6f45c7d752e41e03e465d9cc1f32d2744ebc8453ea21427d50ce5308c8e727b3ad207b21bf3cbeace50eeb8a8f4ffb26817344a7ffa7c21f6f2b982d5c8467c61c021058f7c00581735a25544cc71b100ecbf2b9c590b92d1a65a205ba5df230b86a9745d02d90561305fc6b9d4ef2fd30a8fceaba9ac6ef62312fb205cfe50f22172c53e1c7cf3412e1973649cf8589089a7688407340db86c8ff95a93cb90f755cbd56a05e4829c94a766232641448d758ebd31688031c6c8276b4ff32a7eecfa40824a7abdd062356f22d98feb2d70cd6b991547eb209c250593c01bc0655698a954d0e7eb7c478b0f3581d5c5cc95fd5513956c76be7e35cff83dc8a38b8b7b0a86d421850a26cb2e9bbdd610664283bf858bd76b1932efebd4d36acf59f94ad66aa2759639324e60fb3579571cde5633d011006064f055a474b6ae36594a19dfa2b0833315cbd687c6a5ab3553f427123538d02c410ddd59c3e867b52dc1b8fa74464a02ada552a53400c99c61e31f6be69b2a68fc2b7f351ed5e86628b756d183a8fc76d8cb227136c4ff947ec581f0a28dffb55e9b36576164e089a49eef154ec262d163744dba03f5124ed0c7450df5c359875393674bbfce6789e39985e9991499ff8e6487ecf9f9463b10e2cec0caaf2a8e78ef78c7e761d34f7a67c4c909607458805191899538cb5a3641b61baf020cd3c68163608906663b07681c522a81ceb6ee7de0e52af14dde5545362fe4d4a4e67ab967254adf6a601af22aca5203f9b0ceff9742149c776e82430bbc8327ca9bf3ccfe102c1cd2ebe7d92ff142750582b17e73ee2ebcf71f7b304759c22d7c4841a5c875a5ee2da2bde22a8014f7d974c3781424ba97f1f22c3cb62ec630e539f14d71cccb212c5a2c35ba2b31b5d22c369cbadb9665d03c36c9fa62f524b4a4f969be0f11b24f23ccec709ac6114f7b8596959f770ff3d87bdbfbe93629fc087005bfbf1e52728cc31354e9964289bb6f5a9c5c7c48f1b59de130c45bf352ff40bac8194b5e5363fd1d58342249d1b9aae5a6272a8f95891add393427100aa5bf33f1cf29674639a250e925f22e6057b62ccbb93dcd3023b45ddaafcd9fa14a5a459384c0d5e9f33a5ae5641b960d3854d1fd9e2320256f930b99a91def371b5c542781c3e86485a9ab391731e8099dbd0cfe8c91ec160dcd631bfaf1749cc3616bb84facd59afb78eff7e1c25abb2776a917cbcbfc65fdc497acd52f8d440fc0fba19b35e36bd553fe01be6ed82c0027dad8dc3d994adf679fa4681301b0ff5c56cd3e2939c4fc0d8650451334e30b745b862a1222662039eceab9cc58e874b6ea0081b3c1f626e75c1725addb9ca5e00dac98f10788aefe252b7a01bc73fc0dbb0544e5685fc3e4e06f1187a4ca10cc93bfb40c6ee93dbbdd1d7019e424f1a0b6c887e68f02ac76bfedbecc9c288229d559b0b39a147076f1c5811f674ca5e6a0c532c4bb345124eadb2bbcc1a4b34407e227111e0768335befeb48aa757f4688c0e33d0c4744217094177f711407b1661fd7588f893129592d37da289a9da093dd11f898378db60e520c498a5f6626421d8c7205fdb2a7d3881b24c6784df37127eb94f1c9278aea58b31f4072e37e3be4c5f8d0dff3da7c6debf0d513261310198650189c1520538c0a6097cf6fc1b839c493a7115cedd81dc6b13b2ff22b328969d95198d5d1201d142d11088244051b7d5c965c9bc225e1eef086280c3340dc831503bd33bac0fa7cde0c704c581c9be7a8dd3b72b03b156de4790793f8dd830e0c1c83a161dd85d62645139fa94f0394babfb1a65578248f84d876a28b893cd4ed154125d087592e8fc03b279c134c3615131de975da975e9e9c2bd853cdf189fa0f7c7d1daf59279b503a7422c46f832af32429e60a195bcaf767d24d4a6d7992b4bae57ac01a2db86fc6915b705c413f61250850d65c438d530b59da6409575f6934f382e23991b579694cbf41543f5e277ce69669c43bfcf0397229aaab47885c484c40f3da335d399a76df659f3bd0a07027e3461120d0310ba3be425e57fe8c06ee98aa912795fda22601275d3ced0a10033dd31a3fbead268df76b6638b2fcd00ced864cf97f572e29de077c6f1312535dbf4e5305764c9d6d91b4b3330bc204fc5e52176489dd35f605eaac1e32329da3c63c9c0691b2fcfacabaabb01c406528432c7eaaee1b1bbfd9357c2d520ff807a4c4988b445e60c9dc5721d199afb72d9eda8508fbc5ca407afd08daa885fb8ae08d950c354218245d6deda368222502fa7c7d507016c8131a7f5643ada6ead64efd58fafaeb0c985f4698001edf49653affe857c287adfadc0c35347508de91f5eddf250a8016caeceb5c71c37e9a9ba072ccbeae9a72dba83216877f4f86ecd1fb88c84d6aff6fa1f90aa0a36364ee7b85177acb071dade06b7332cc6f1ac7cac31713e644961d875fb39cb57865860ec5f45924f2a013981da05450b2c008474f1b12cb688de4024c39e712e75690796a9f2be75e076d9e4203547c1dc4a6c0b55809c4338755029fabaf40ea147e377d54250fa6900a702773a8120e8bbd2544ef7311136e8eeaac080d976a529f9ccdba0436798e3f0e3b058d4d6cefa6d53e276643ee9a139b803f964db610e7de3c8714062cc7d8509b223f2e0c4f148623fc896e8d246779d6ea65de02c2fa3753a4dfa3457f643851be835342031984d48afa849e571316900d2b955b09e4ae14973f3fbae0428ebd9f1a82aa54b1dd33f8000464f745cc3a1456a8f6344162ebd754c815f4c0d1e6907baa2bc2be97a994a84d7cd82750567041e9242f20b91d0816d86a86c1d0a38bea92f05eebdb27bda3722ce8f9e5b935b1abdbc6b7541d1470d2cc11b73d521b311f7a55615d4f14ff3201c5e79e56c8300c6005cd0e02a1ad8db8787cad1a23db8a57d8d17445a255ee90168c8ec932a2a8114a7b8058feb3a1a7e7396a8fe9c70ec9506abf5c2181c36d56429ad29156cda5866745d2a0901bcd572c18fc2197d1303e2d1f71d3669ed1f35e913167ba446509cca8578c2bdd8bf95cf352797f841eb7b2522e79edb45e5239bae0714d4d6fa24e7b52bba4a20ea5f5da91fe534f245655318066d9cdac05a0a9338083e9aee6cfc73fba94d542a91d0aa57119e51847350bff7a4839c0fed1e347717e44693f08e6d76df8a03e5daf870948a7a93ee28e7c3c7f4a4f80e94546d1c70e620bde272ff362c030f36e243a279073b31205b76aa9cc2c41ef70af12e3dc166fa18978820af9989d2b572ef1c6cb743dbaf088f29a4d6ef90603770d2cb393718981634a1ee44ba279d64cfbec1a046829d5f5bca8cb2556e35b983a9f5be247c55d1137575229210d5b31182bf6c263505b497fe2eef367fd91776b0782196271e9fd3e2e1620714b618e1b29206990054306b4209fb28c923086dd3107fee77edd60fc84aadca9ff7fc2cd5dffb8d88785552acdc56e7463b9e902b77ad3acb5afa012dd8bd7fd4be4e8cce4bf9175536c6d04dc629a4ff6b4cdd7311f28b67a1303baf687e8e44b6d2eee8bcc9881aa118467e0bb89ec7e04ea071e12c0cedc1f8b19c55d56dbcee867304931cc48325a0b0d8694d48e532a95598dfd0de40964d95890bcaf6f1a63dc4ef4734617a892ebc7d854522732dd0b6b244a527b7c023e3b58838a8383a743fbbd188036dccf82948023d98ed0bd755c57bf4c3c039d94d9be0fb8d373956669af0af8a124400e9500e2db0cebeaf676b50c9883b03c8185cb7026a242ca83a909a02dee61aed199cc9e85be83a1a3adcd8f265d00018bec56443456418c129ee60317ba33cdca9bf47b2a17028a19ba04f40ad0f1870ee73f4be412f59c60d0e99c4920eed2e9b0f3d6694eac0c6e0f2ab7563dc953921a8407950c035f5abbcac7ad5740932eff1e305220d6fd71db900b28b61732797cb83de0f64b691306c4296faf11a7e94e5376bb97905b81dae568ea9b25be786887d831b8252da23b43ea1e87124f3d43f52c552cd51f5199b156a6cd987cd050bdf9cd1a87f9098071bae4f51cd2cfd31efe151eadbe1478f5ab39a76a57bff7977c17193ace905236efedc38816e9a17179b932be5954f44924ccb064a4750e799554f257ba27c819c788daa63998064821bbe2df7973a8772209c3a52b10a6ad435f9f5722f70ca40c964f8e0b425f4d5d714c45fa21426617af4044cb6780fbe09bee6263b230e6cef7997ceea29f2bc79eafb5f6c86f6ccfae83e1703a16105eab096168e5fdc2290a877a4421319f29ad66c8b990bccc5aaf825ceb3968ad8a6fd0d9f9fbcdd2f2fb942b3e0f11b9c81900cc848e9cf64288dd58bab3e9a21de6d08423aa28193bd6da34ad8dbeee2f63941ed1c00f564086d35e5046af42e84206d98e8c166cd6b3180197fa11c9ecc1a9613c59592823398b9e8f33fffb407ce7637cc10e5d83cee1fc4a99b9a9ad0c50d54ba8b49be8386d4fe0500852ef67a8a50d126f35edebd3b0ddcf659d18845e87447e1897bb9e6d8d812c161a7d55d35ed7138597f36256dfb47a0e1d8e832021787bc4f66e828f71cf48bb98c9ae4be0703e86ec0d1ef1dd924ab3f887a18bf4a9982587df7e0e8f8e71daf0dd5852fbba46d3979ba90e755b78c56a65cd864252874a5b9ba76ce25507e08a577dd844d93424571942f65e932962a69aeae5fdf5ba7b8212813896796568b225273c9b7e6c4bfe468bf9f085831ca7ca416069308ec667efcad196227be55c12f16c322eabb7e97cfee644cadae8729769fa0918616772f7be6217693a62e7d1a5dca2821a990eb31fc9a06357fa5c632b7153e98733918eaa182b629bbe4a029adc0e994bda32d4a78ef227d7790f693261b76738ec13cf25a5224f09850d27ea0c716a84fe70e0998b4e3e6e8d948a9e12f38321c3ce9c03ada8bed4cbddd8e5708bca6f1118869f3e093682478ac665a7f6389f66a52cc94ee8fc21224d12409bf5dd17007ba145b2707f2af58288504c6605b8c7159f4434fe2c7ffc9b1991d85fc93b6add44035bcb054507b4f1324a0a8d64b16cb9e9a8c84fa9129ad94b46027a4f8e4a7fe6b09500e5498780946bbd982599aab2a41afb1f826ef419ee802c2b567218df943b8a85a4da1fb10b167da7921941ab5230a87d473f2070b4f39fc4f9a169537b902a562596f17ef0ff312f72f8d7f09cc1c128f5bba98c0787800b7781bbb3ca31a9306994ac1a308d590f8c1a3e193d20617b360154f3279dc703195a6ec8225c7ccfea099994028bbbd43db3231c9090d7d77eeb6554000c0c469bc27f34bad75637a6e0363a9027b2bb013b6af16067d3f45eb098afcf4292911bb223d4c9d464073a6dc39be9cbbade4101abffd8508187bc94f61f338e68306845197f41af1a6adc22c0deefc8c821d1e41403b8930ab8d3877e2c89b2b4d40547085e4610ffc891b581f5cd180331bc9ecc240b83dd9b1139a540e864606355fb19c38335a4fb85cd387d82840deaaeec4f3bae0ab726d07fdd764247fcb3cec80f21090fd34066f18072e024a1dc281922d9463ca32499485e66f1bdf65a05b3ed0ade7378b90f36bd035de25b19262ed76e51a9f8c968098d63d08abf9834565e6ba79366d003024319a5f6c4649e8e56e2beb1db49bc156fb6d165010dbb58d69865aa99b0f9029e6b2b9d38141137e446bc1710b5288d883986012934f8ecfb1c2fa93a4e67e21d2a76a8cd948484bde232e49a7155792c7113b38dbc782c4eacf9d7a3b2d3bc2151a2d6e3621ad0b419fa5dcc435e308b72e46508807720429f99ba38f805ee037049760dc61e8b9018d729437e1ab3df25e123deb148eddcb308e19e5defb3480ffd22ad1f0af8648c66e4a17a8691f0bbe8ce39751107cf089004a7778e2a19ffc10b43501db7d43111ccba08f4e96529962ebe65b9ea39d131697c7f666b4001d0b0bf9be88b89946231e381cdbf6aaecb1e5e25671786d3b908c11973c58bf2f3c447bb1bcf519f0ebdee550ab1ed18f2e138c7107d361a2ff3cf60af023a9bb71a35f1ffe19478f2a5aeaaf25a429d33164d24495b2741fc1338caa47bf99dfb859e30be0f76e400f0b038d83330a9a17bc6496db1b1fc399384941cdc50c384a5d5d0d88bf0c6a21566695702502e0d4fafa23f6bae1737b4cc846e6d4864e9799c9d071fcf3d3f46c446288d78dfe2546684be4062ca1534d9360b0ba430713fb28febf856dc181f54169f307aa1378b130153b0b27db4892102562301bc916d291de63eb86a545ea82d8561ba1c7855d9d5c00aeb38f622370e69cb331489a439955dd794947f2d140f695824edf6fd1e05bd892b7b803c5e9329660b2bc5199b6a8b58fb202dc3a966ef1d52c2d19b3809b66b66501ac3f4b7d9da081e8a312e89aaf20b164b23e1e2f588ef50ed377258ff35b76d317fecb4b4dcb8301041b84d0ce3507546c0a3c2bbd4caedb8bb1eec84d7e2b645048c602ab24533ea9863ac393faa79a528452f91a4ed30864ff01fabbae071cdb01b22ddfb5b5e4ed500f39e56268159bfe2437303bf081d72d0b8947d950df5c77695686f4be231af2227f13a93b0a67d1087b94249334544a532672a1cd9329b048a8f8b5ffbff4b8089842769fb015964aec9c8fa1b3d6d37a0c9251002e428c3be1909024366b9e8c3d1b87fb627e4fe0c809b4a7dda6ce9f8d8dd6a242beee94e0b6ae852347014dad3d21e33b944a6d8d42176dcdf3c52010fc84f76ae84a80ebc81bc0c2c191ba7cb2fa790c48ca2588bfd12cc200b9e7ca3fa6c068ad6c79f836a11f5b23530bbd02545e620ae3221e083a45c223ff7182a1bf64d30f5e80201ea87a805f421056c5417dd6568593551d1fc4bdbefec8c5864eecceab819774607cfc5ae98fb5b819b4bf4d7320f5ba7dff9adb2e430e794ffc9ff89dc9e0f8b7fcea8c671c51853159bf9e0d5eaac87b793e4b04735d918f1a8d25350679d0ad4d03fbb684e682678ab2530e7af9970aed8f0e73718417a442f980967214dbb26549f9963b8c8e96041ad5468ad176a0bb69767186ac53f132edbb35ae739532d8ab6abfde4ccf3ba515c9de6dea2b18ae8b73aaa184d87b29f60751363c43a0b24a93c3ce200b47f174aa956ed1b1cd90449cdcdf83224213b070eaec28517565f01d8fa7a334c0b667683fc2810142751342963752cec28328c8f1edb67431fd9ea810b7b28a64fc645f9bb40b302cbf00fc9cd7b194139a73c9427a7adbc2f7087a410a523547e1275b64306","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
