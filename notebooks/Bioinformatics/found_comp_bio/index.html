<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6c8a767e90781c08b3766a8b828928c0f180c49f7c4eb7e6da00a03396841b3643df6d3d502d262f94a5edff510101771cb2d1b6b6a0ab4a58eb26dd493d272afb1277f0d3ccd8967f9885fdc7c1f727f561aa100129145520be6c8719bb19985cec9736618bfb49702caa4e3b777b0398b25f1e3393df00ba2648dec6aff7024930299e26e068935ba59ef791852165d738874cfe9546351ba41b5146fc264d647955794941134aa44c5b0d40feffcd506a272692239896c21431f2085c940feb40f435ea73e27db7a899319d7b7e4657acb7accf807f120476bd9607bc123fc4e9a3a660846f8007da62001d4ac9dbcdf3573ba01bf11abbf9a5f6a5dea96cfbcf766dc2ff6a80233381877a3103c59929c9c2980274ca808a610fa150edf8b23e5bdb3030056564efb953853cf4863c75d0c63d2d1731ef5dcc99b650b1dbd6ad4173c1736c76d8770d5d15df34542917d22c6fd84cf7addfd9fd8f8442c7358e4097f1055dc3e7ca73daed23268de9a97788db65beb2a2428d6417013f831c71a96cf149377628d11fe99d94a7aa5235b9b49d1610abbcd47f4e35c195020faf36b894d152cd6e11ebe27e531931db74275f03e2bc09974e05f2daa71e61b8f6252d379bf5a199ea59a4a40c4e0e301102fde222d146ba7e4f8258c89d01b865b2a82772bd0306cdb0fc542f13e838c058a95aa7d6b76fbb9b222789f8e30389bb7d9a6cdea700ea59d3cc03857da30ad55684987231e2fa3bc8cb2c1911cfee77c9599db85e4fe3075bc3d0bfb122394d209585a1643a210b4462d96d344d11ec6791fc9dea5d25bded4cd2c08c14f2829a6dd2cc775cebd16dc663ee36596d02126a0daa131860c6d42cb3baeb74fa853c388390b432b6cda0e4448721f01835505a7b4da0865f299dd88cc171da0240ed341557f8facdeaffb86737baeced19efb32d6087d42e1a89fc917123d5bc4141adbee0475ceec2cba2fb51a5efe088f6d4a07bf9c144b28d651be11122f4d4fde871087aaf9ca7d441d178b44d935695bfee3f1ad96b617a2b383e95ead4737ba57ffd0e5280d0a88cb34b90a71ec81b7b5ce8c620d6d92289ac9a19944def76ce856f10a45e6e46d7bd37d611ca8606d5a0dfb59a4d739217ff83ce71fe437e55ee6c4ab28896fec0e0d39b1de26b60022a5baa1ecb022018f9c331816304c23c264c13e958cfbe05378fff144e8d1c91057220db68d5621327a2881992d7e20c8a5de40be9a54598a753ba9a1748c2a1c4776b21fe0861d679442ab844c4b1ec58db797b68a794d0bdea1cb2d2ad6fc5452dcb069c6ae63c14e3aa820052a41960774f20d22ca7f15395253fd76884a86863ff900010d57d69e474809685e66f3cce77a3ba43d8006d65621711d66ce818566d13fd5aea7798a230bfd18a340c332597db9c85604d38873f79f68899e1929862a3200e0d5e5d3226476d6fa40c484682e4ccab00e6fc842e9d06dc38d3d72c9b03ba1890932b73e4eb950a947edbdd62de8d5fc519515b19859f23ce803c5580a508f9a594fe6f771faa7c7e9ff87479ab1a124e08af8d5477aae8c5b565f917d847f43ab6b1b76a400ffb6ce7629d142703113e449fa233ffb028d84b1d2410604f154907c4cdd89eeb7e7c117203e5ed2d857ebd4dfe36f42d807aa58fc736b77302ce33af15d9a27eae877c470dcc0d7b9b0400a9a699343bc93501a5592dda33dfcbf471747f9049a9e144afdc3898cbd1e31b8b8093a2db42cceed366bc7656b45e97db767cae87875951b9fa5940d5890bbcc60e4751fe8fde95db7745fa1e65bb76b9c65dbb1e0cccf1d0a51b9074ffa51113c8966bed59373164dfd7d1d5f96cf73024195aea749c31acd8fe6660c96b9261826b57ca882a11247bd067f5ff69027c228e253522e1574977f8899523460b22985e3b1be3b8a10388411c45f0f4f58a1db5968c480d09731ab36eed45bec852aea908b8902e5e82d3b9c36dcae8df68ab7a8a04ca20c24ae023a86bacdb1900a43fa5432a9abdb946f41c3863bd8b1236880e86e237b307a6dc5f04cd20a68194f90918eb55eff798075b7ed6ed5a9660b7fcea6d2b93ba5ba7ded4349f8d6ffc392b0298b9702f18da989c78d03ace005b3f281c8747288f737e35d76bbac995ef61354555343b0727d5fa8071d6ee79fb77f2ba544c9c4a0bcf49a11e85bc3c6dfbbd6a1b40bd1d219eacc31272965949bb64f3bd56467504028ad7ebb5d7d23ac63fb6b34a6c5545fec6a85544f2c7184e151dacd421aca481860152919e3b32bec72815dc4cdb59dfe2681b802b9ad7a1715a536e771d5a26ac46cc351851f287e7560eac94833a39615323aa6c9a1cd872514faad5a7cda482c16462c5573e85215b89a804ea5a38673dd8fd13c45489003467c412b126ec75fa8515371d289e7e9378f40c2a2d54d34f42ce247e8d42a3c803519fa25132aed700791238a7b696892fe4d08167e86dd2c318ab56323519f3bd63a8dd9e0642e583b8503584430f81d7bdc63679802abd7f210a2e78effd4c3a378288003ae05e2eed90864e19f295874fc77f18a4cf8368468a2a21f2c1d3e952a12ac693a7a2775e84d1707b56b2a6f8e9045b57665821fe61b6fd9cf866bb87ae75bd9374f43208af1f19b9291f205e3f09ad114c2a97676da18fcb78ac8a0ac4ce8d21af8e4466821c0090114cb31524ae2a9d9ac9066ea3e9c7fa1242dd3b2e8c1a6773d38f309815557e57db263debaeda2552c59e602294a8c4f63408d07426b0f95354d1452cedbdfee901ffe59a45b54bbd4374e3650abfa499a25a738bcf5ad7b709c83c760049ec7dfd1df078e2ad0ec1d4af3c795ccef60b4a123d020038b58bc1e8c39fda1a5f23c4dee287c8c68a1d8f6f7dd0a24def9488465959ac6ec519a4fb75f0e71934ce09adff437991d37edfd7b4a328d73484bc38ceada2c20cbbb0d5cfaa301860d6cdf2d656e130c5c0b80f217008541262ef18622a64839cd97955b1600a41be8f42fac8da547045470d45cfdd5a3ab7986c14c76b10affc7a1db49f4b8db5e68d8b4705f5eca88fadef742d9d0d2da3ab21f1d491d21716b020af5bd4018fc80055e251dfa3e933b3620e1ce641a4584f2503b5433cf52268aeafe8cd3c442735779adaf6f8a07a72654247ba67fc7518a987d022259572cbe0e0b96eb8192b7fc2fe0ebe5037c562d7195639d3037dd5578e5f6888e970a34921a73af28eab07a21bc7d6fcf91906c9b344c9e5c1f18d383e1316a96ba74203d26b84dcc46cbfbc20650196f809b35b9910963a886de4e91739f9fddd1e011d273a13390552bc3d0d4d3be29094bee675f3c046024c8d2bc4d2dba89e79fba28962c58d7db20075a8e7b687603e5d22dc6c5851ea2e2aeab2071aa5864b5943324206303bb53f6afc9740a6cd35c5b864f301a00beffd9c5ccd5471f6cf1bd61410cf117de6f0824b1120ddbac4a3f775adb0858fba906e4b6feae5b4bac74832df31cd6a5163cc250e204c1cc625cec731ccbab010e9e2d7458a230e1e77daabb1c93b439be2978d089fbcbab357468ae68d9c4cdd2ef1520b3aadc4f044013562d2226670071571a99fa9eaaa0d1e268f579435955cc85dbcbc2ceabac42fd6601b616a94ec2e8afb4dba57f9337099577057035024cea858682421089baf6799e2121e4418623e817ace883fbda5e7c67b5f2862120b86f7dfcb3552fca09613500e372b0cc421534e32320f3d1161355b3d1924767130a91a0b0971c6dd63c1590ea9c3f42adf274d2c55cbeb7895ce70a968bedf20bae83cf777a1db3a2ceacf63179e59eaa3e32d6e05082a30d6004b7e1e3de37f2fa4de91ae923919f395653df2c6d8aa2374646c90dc75f88989c6dda458a5b075d8c4ff4cfc09aedb55fa6e15b21517613118853d2deec68eb05f74945ff673fbb68af4f3797c94ba957ecc5db57505582be27753c9773750eca9fa271e85c48c91b3b9c2b2039779d443bad09e32073c5a040f72d41f3c106cbdde69cb7d8792c13d876f358eabc054ee803ba6468b408cc635321c255fb4e1762ec5a512c8d04c39e7608f8a77e9599faad36b4b570526f70996cfec5401caa5a47790cc232c1c493a05f58883b9bcd8e7ab202b9bac11a2b9ca1411d94390eaebed96c61b4032360c72689e030c9757f07ce22d1a41182c5bf668c4789a77dd09ca55fb6d09abb6d49356192df8cd27aa1de1a174c171fff83a6f410546ac04a62b5c15721cbc666977eb328ee196b55248048a4a33cad4161343abea87182c861314d09231b52a70768115cdf7681763bbffb9eac2217284a1c7259aac8ee322034c7e55cd78a54fc13760a4aea4f9d10f94ee8897700ef484a026534053bad47b1cbdbac3969701d7db4c7f23311849402188cae637b576ae8d2a1cf23032b14fe9c01818bbb2a37580fcbd20b7ac463f45f8c166c9bdc4b4b8827732281bba570cd9d0c2d65590ccb06588d6f4929c0555c119ea9af104a61dafd1f3aa7161ed226c541ebc68e7cbd02c9afa43f8025049a721ef92820a9c1fee653dd590b408cef4d4114f2f2bb83dcc20ee873783d7496b97e17b436e5c86a9f5474dd8fe6c49f5f42e47d8e3500bb9d6439c82251621a4bff3cb6a69e8b6018d93d835d7d38d8bf522bc6da7ec264d559161cea0bc318b4903b3fd8d81a1e93639c218b47321bec10bbb3b07e8c4dee07faca744b578d9f9e94e31b4375006e8a5fbb8647e7c2bb121e7ef960b580af3fc6fbeb2a1f0a78e7041fd2aa32d435828948a40de5424e77cd672c61bfd9a20f30f2bed8701d0ebff13e339dcd61cefdf48b0f2570697b05dc2387c1d5f989326dbe5efb01c992d9567e3fb42ec3cc15a2e6bddab602228519df116d22764b9b27c6f87a322f90188e40b687766fbf72cc2d55eb338d2c3f14026297e86374fd914034699774d4f3be1782c9e1daef1f789c0977631c822e951a03fef0c5956b090d6607353e0752bafdedf0eb80901120217ece923f570d0de7d72fcb1bdd8f87b70b3103fe8c3c5007bc2b7b7f8731fa048fbaf219c43eef022d8a2a106cee20b49a48d26a5c5e5d34cf209cb90c3903300d8eff3df11522afbe2d0ff0258662b510cc142f8bb3bb57a2208f866cdf2c2e3e8d4227014bcf7162b6724d9db19d798df712a5ac3ae957a5841e3cec0e713374b0dc8ded5309d672e8eb7d6123cbd25aa35610ae25da1848d492c49a97e4a704ad3f2281dd97724c538467992ff64fbdb2310a73ac6ffc20967f5a04484a6ac96fb2421db488b80db3d204ef979a84a152d62fb3bca1bdeca5457f5d93c7b355326535353d22e646ea9af7d659df4a5617783688daa984755aec911cd805fbe3c2916c3ead3ee48ece44521fe095540b06bdaa7cdf1a1c7566f0f63bb62550cd8d67ccff397df951e35bcc1b617b22d84d2e58850ce40e63c974ff7b1aa62a9fba2ba05a316cf4007de61eac0186762b3d88e7fecda415823a6592e47fc153c338cefe42f44362935223aaa8c5069e6225a2c97879ba7370786f49448e61a183283e2e8fb8161a3ca2cac2b7406030f0f168cde6cfc0063600573bae56786c0dd45208c55387f09aeb20bb6864d0a689724db25d85196c813f46dd0254f3279494fb7ac877a7a6e875c5c266eaf9fb6b4a1f6f2cd27b73fdc0f89f45ba4557f5881abd518e89c9170ad30779666270b23dfe367a54e40c0c3499432ae0c03f40072dbf0bff7acb67c4c58a049cdff0f2031d29be09d9ebb5ced417f0ef260376a336a0ce311f5bfdb2f98c89a4a6f87b5f5885c37ca936a52f7ae2772970c1db94869aa9ac1c69359bc5a08c3d16c2d171a06ffc1e8b407840deccfc58e3ebba3d37984957eb8be6a49c92fbfc25e38c980860b0a65b495128546d101c64e46e0abf3e791a81bd952914e5daa381e8a4b9f8f92bc050354a74fd6a14cd1cffa1fde3f4b4017db401cc0e0fff38994bb66e343816ee46343ef7cecf4baf5fb3330c956cdf151a2bf1f289d1d34ea86bb483e9ba73e1b4a1c8fd892f39a1b41d8a3325d3d4aef08a0946a9d9ff5a52162267d90574bdea4dd930c73412c61cd708f0c0ff528e83046ab043a3af1d851d1a45397e5d43908dbba9725908cd91f832ec3d0adc8ca2e8910419e84d07d6ce1574a824ebafc525df626ac30a212fc4152b1b0aafac08a0b88be42c6dca993ddcd011f75c2ab07386ebb2a9cf2f8baa29e91c73f8ea45277c98fb36a002a982559617d55da8657e0540956b26a192bafac141859be7d05803f91f74313b144ff0af0ea6e46f0ffdf4c8a3b94fe2a248e5c104ff75e7a42c2b0bd22698f65837d1fd0f9cd66324f9f67f47f6ea427332895002850eb51a81cac38766b374fa4d8db037a352e0230b4701395617dbe4ba4137ab04e5dfc5fc22788d60236eac475be9a710b81c75d2b6ceda79b45975103e2f6eb75f74f4dc98d80957a51398cffe9d3a8fe5a0b08e510eff28fd1fb7d51b4a8a4106e805a2fdce3a87d5b35c4330cf044a05c98d7aa4e6c0497cb9671b238040269fdfd97ed4f8a8e6ee1f9ebd71faa5d32cc19aada9084a2b090d55dd445ece031d0dc6ea17a8a9dd161e983e8f7b6abf3fdfbea2c269bed14672a38efa54d4a8f2bfdbff31bff995c759c9db268c425984e9b3da3564c12a4d526888935240986592e39db0fbff618e853590ea42286151bdb93fa1a651690b7e31bb34bfcfd731463a8efeffb334b2d47ba18802938638da8cc4233de04b44b6ad5f18ced6702d77a41eb09be854b2beab02d5f0adf70d3e94f3fc5186774067b627aa30e5bc88a94e4ba1235c23b252aec34348a9a86c9d0003469b7aff8852951b5a5da7c06006a23ee372daf4ec4753870385a1377fd8fa0633a2b61fba1c40f8dbfd128562a57180e88b7acc392c243cc25091b57fa643a6ad7f86a8e1e64aea7ed4f7dfdf357468cacea31da647939fbb9683afa4a47978706002e5499291ba5e3753e3fea26f12f650a1c1cbb2a59db773b14df60e79848cb766a64d3eb14eca6099c4fdaed1a624cc1c1f8254cd8f2af82306cd88fc8c706e4bf3fffaf5f53f4e563676bb09ba84f19e6f5736a6512051148741751f60ede663e81b76024bf23f32a203c3865ae45e2f553de4ae6ba49d72333cbf4bc7c8400954bf9bc970f5eb19ea9a908038bbbe6f576fc201601c64241f2f4b15f1c8f8072831627dd64ca987adcf57eb3c6d18a7a619711b24e71256af83bc0dd68bc09a89de3bac4293e56a883be3f31a518e90878ef930447f37c360ae72f553db684b00c04cb30e02ab90fd6c69c6595289d30f08dfa1c0bd51359902366ba842b747b5c12bf72da48f418e62553f6ba8fbdfbfec4f67c182ffcc82e76a348a76b2576a3c2eaff89cd42f9ae245d28460ae2b56585605a2ab17b7e1e6cfc02fc9b5112de6b3c2dca7588c9e7793662ab341a6dcde25b11eb2893dda5c5f1b95a612d3ea2e737ca5137d23d98eb7c626ca84d57c2972a28f873e4f3819e6caa1e87367d48541a312c864438c34bcf321fd3873f5106938725347f4f172fc1c84cb271d9e960fbd819302e10943b9b3adabdcc7c8ad1e3ca11feacf9c2db5725768c60a25808eba00dcce70acf9826d5c1730000807fcb75ace263d495e3c3856e28391c159869b57f8eff791cf8de69f9ff137715fb8f045fa31388976d7f874daf8592b4de1cb195044576f4bf485d14f04d370d37a84ad2c888fbd5fec596028ab4d0f5b64408a78408de47dfe2f3ed15c46e80788c6a1c2c49ea6319933237218dfe06ca1be5bb8a8d8a588ef63ca40dbab99b5b7aa3b48cf059e19d6cfdfac5994ba5a19d3d5551a93440ef2f114c593c4a6f177431eb7de4a1d0a646c76dd0abbc93c13eb260094792b53a6d1c35e9c3f4d83f2e0f5ca39880e52d79fa13249641cd32d3dd21756b60edddc120efbb34b8e1b2378fe684b91ac5618b71a295052a4438511d97fa49c1fa22153996b302da7eca900925b49671c24b69a4414c15bc758ac40ca30aba6025a2479baed982fd369410809bebf0f6beff24c3a4c46642845d5da7d5232e9c69abbe021048cafdb141995693630acfe1ed3ec0115a0637d00502ee71e608e2cca60be27b248a5068644f3b2c05d671df527e9ce588486675cdd4b746b8451fc6e123e24d89a2fd571f63d72226e0d0dc2535bb60add0ec9ab5c6241d5431b23329da9930015c9b37a85ced65ee1bae5955cd57c5d3ed537f2d3ef9dd18194364f8386b43c0b2df599bfc2c8a0f892de2e0bab8e6d4d5c9f58ec6fae6717a3f7b2b85da3204fc7f01bb17389a592ad9e90f915e721882d22a7ff86879ce8e5195ec69983e703d11f8a409e3d4ef88f2b4d7ac70d82dd0c2d4f9fc2fc2f30944c91d047a6c97b1b7fa2dfdf1ebfdf4f14f81b2a9456dbf91885d7b72c5c977519e891d0bb7b16b0725b17572b22d4071ed7cd3ff72c22f1fce0f8dd0b5ace9c66fbf205aa8ae8ee0ab5055809f0dd0e601c364b97318c39fa4a2007da9e2d9aa1d37901b95e1eb86caf5d068e177c56a90dd5592abdb6f0c9d49c00e0d0a609ad81811d90a1d4eeaba7ade7b9c6b0ce23219c857046b22047d69b0043c4a4c4e2e104bca685cc407d768cec241d0d2aadc61fc31fab00ff185fe3292b3dcec31d6a2c8135f44d54d81e16de36e34d882c6af7319161be209d39fc68dec514b8a0cec5d209db2869419d466ef4e7401a585d5797ac6523985c064386da1e8721ca252daa7437b14854ec81f063ed4df14bf7dcf1fd7176880d0cd5bb52ea77678b40ce9ebeebf827fdd2e358a63864415db91612b700e62914fa0acc330f5bb9479d69c5942728dec5955e32ed75713df17b641a147b7ebd49cc66ca0916858ffe60832cceec8c2bb21ba1efe67080f111325769f25fd2d6e86580ba3399c737d8f0d00b8cbbfa3ce217ee234a44bfc4c1f04cedd6a5378c7e7ba7004635637fc60a34a9d2fb030f354f5879d5e8d6cee5a57c08f39ef402a4231663221d4d04028aea43b3b147da3019ba0532cd3d89c951be697a9c2afc3785de0d08ef6e1ca60c09ca0702b57c16eb2a5d94dd4dd41da4f5b64a053e8eaf9fa66d20ddaf42b9764f14281b1126324a4621d90fcdb3a6d29900b33e487d5fd13119bd5a6e34a2476549a24d7b255ac82ff8a1b9ba5ffd14820a0accdc146756ce60480d5603e735379d4e46e06be29a667459f25950f3c88cbffcbc0666c545c1cd6c76e69b72fc240cd18b7187eedbb870e4e07b38fb25da484963fe41f950b768edca129418fdfe5372bf097de1432947edd6076c504f9bc7f103739ec02efc6568e76d4c701eebb76bbb62f7243ac3791a7c3670d43a55490402448ab2da5d94ad071f47dff854fe80b0386256752dfe15b1b3018564373b5e09965c61c7d7e79eb073f18d291cda2aa2a690bbd29074a38c58cc897cf06e48786b2ec696ed444533c78f62028e39e84a14128dafee25fbc39f432488d731b4135f178be9c56ac468d6f5873376ce3881983e424ceed00da3f140f8b805046a346ecb2c934bd54337fcb3122ee0a0f3c2059a3644d583fab2bdee3590435dc9f7fc99bd0be0930d6332649a82e9b7537d48ef8e611f90194662551c3707567d4ced268bb4c867d5826c12ce8dd4c73dec4ad2f5049e1134e9d537a3a023425291b3a858491ac588255ff71c04c42fd86e8bfec686877bb2303c295d46a82260b194b21650582a2facfeb38a5ba89e960e51aba2ecae39a8acdddfe1bfaada1b7d9dfff7689b4e65338acce520c62c07187cbe3f441d1829a549f7cad95b1cbe67b5e4f1c82fa0971068e904fe0278a4ff3a602fc619ce7bcfb39886cf839e191c8ae90bd0485e8465bbbf75a329a12381ea05edec275ccd512693eef9b78556fbd6497cddc25c0f1f635f4a46e21023fa0a0ce84125407da1e869621e751f51ee44016c03cc90a1f02314911d313c62deb6d406815dc1a21e8a5548fa6891a63d23b2a5d9725c4d1f758d59b46e69454f1c1c2ab82858f8212fd331cfefb545d0ea4b6e436176f8677e48bb2819043335dbcca4f2f86342e8116034141f8e4227a6725a5c5a648910faf13a9e6258d3b272d5e0e27cd01e5111987e707c92bfcf96998d8b80161cdf08d81712c80c516edea52bb225c0ec280eb9f1ed8499b0f0004af47fcdbada495b2d96bdd7bdebc2f11960c925c5bbdc66dbab0afa6a21a2434764e30063bfe451b4b7850813c03ab38950d9b11055f9391c923eb38ca314442a94728aec06365ff3af11c1e47b412c0f2822ba3b3b03aaa4c482690317dbe02982cff2898a00b5401e26e9b897ca8ac5704c930fb56a476c39c6d4bff609f3ebe542d3aca8c9dd8fcd88bc91a65074b52767e50487f0029dd5b864ca3dce92a308e85c2a2bc7042bf1b9a62f48a5a046da49d7ea22f8ad87e3597d24ee87416af7dde66cfbda2bebd49205cbb2752610c76518b88cf58e451b54c4b4a5e56d74876447902481cd179a44fa25158751daf16640d96fdc8c44290b265289c8506fa9d4bf3caa037d6dc4f3c97ead0a5147cfcd52cb2990de5861122689df2644cab58a604797fbab4f2ad114b398503fd40f74367326dad2c5bdcc4526bd2e07a6b9a68dff9896d16d2bd35510ff414355c9103a857f86334f9619f052795fc2d43e889ca21a37d04022b7e01f188c6910f69c179f9d7d93dd9dd7e5c572b1d0c3935d74e31f55c9ea77bbfca8dfd277524588ed17429fd89235ec867566ef29a22c1c640c2eebc32fbe8bed54230c84afcd24136de2dfb5aeac78c72e8663e4922c9c0777eaa08a442d50b5081fa4ceff9da8233f1eae3364a59ed53ec9a55bf34cef06fed8611db8ed5f963047767feecaa6a074b33a6bf55d52a7fbd313987646950b1e36e3df374d8433b74daa14fa47b1193b6986e8f1f9fbd4c63dfd5e90f250410248a29e15479341b4945d7a4ad4d6d0f72a50c43f7c8d8b6aab2d373b4184edb7b8ad14e9ff1ff54da0265a76afc9c3ff02b2114d949bf27c3b1845e87712d688f245530c0d16eab6816539f4891521937ec7223b1743c83be1a4917b5e43d210051dffc01256a48ce6e311c615a16687e3f0eca8c4fc714b33ca7c40f4b65464b4bc656f3ca85702c361b1f4e5380a83b115533b5fa86fbbe58e4d1b41c2832be72a5b30e58374ec1a5460c2d09095e0c3dc18d9f99cb0dfdb4b68e5aa88dc3c206d94c8fcec0e12f26981d0847154299fbd7108258fb6e613894569194343ea711a8f7b591784dbbf889f7ff0b8d22aceba305b3594a2cadc6222771bf2aabe59fde89b26a0bed6b92476ebe82ebdaf51117357669c259a3da3640d35eb1bbd8e3f8ec74a7669d4023adc8515c2f770dbf2259106bba45bb5a754fda747d7f098af2b49dfeb018d74218e0cff9cdb990a4cfeef8acc3587974319c1ce69b8c4eebf14249c7cd544ddabf128392c1db45e51307c276debae8c6007e7468bd7db2c731473b85196faf5f688eb43b35464af4eff00e4db95825612b6baf50d6aec26979eaf6b84f6acd884432769d5e55d918009e7d97ebc238b29aafc9c03319250c375d52ff1583549f693121eed3e2b822b38e1434bf5ea1bd90480e345172b28fbbb0c11089e26165ca86ee58a4e17adf31e8fbda2673a041fb2afc61cc2b09d9377e14d50785638765825a6446757916fec36332d262ee6ce8fd97436baa7b847720c8603644f6926d9b7c16c0c6f49c56e171f44691bb5b03a0eca36a9210e3a7e72238e2bd2efa03da846977485b8541401c89dddc97b3f9c5ee25200990b11adf62d7eb0b847119fa745d98d12499d443f67a29cce374f1ba4441ed967bba0e4ccb54c669c1f8c52ea16676bc9c42d7579427addf9f56ff37e59ec520dd616eae7305fb9a9ee4a012a0dd5521ad31272caad6bb884a04275b6d1830035dd8d34ec3571af9b216eab1b18db1e1f9e358240c7c936844db38bc692d9b9cd79073804d16cf594db1338aa7ffb216dc6c580ea28965d59f10b6967b8214d31f2e27f618f880a1b91963df204f89e8a1d8cdd7eff24b1ed735fc794f81c6d07caad8f70bd5bae45925c1bbee9cb85f7256b2bc4ecb443db35e8ee6bf56e006b6113fb3fac7eb6a3a82da85127f7dab095a14c7834658b81b3365f302eee6970b71597a1cbbaeffcdc1353416e4eee956a2c8a0e2994c762846b481b33b104fc0d1917a63b2385a53c50e8ec4802999181a13bc979658b39c4a1c2fb8872f82428a9cf198d6ccfcc57484c093547096216376bf84199adda732e54f99dd11e2a1e42d65c0d7396b731cd339439699b34e9967e77289f17f672528056adc97f8042107c79ef42dd2bfe56faf4de9bcb9f639a8602b6fcbff6b9866d85b13d6d99dd843e272f6dbea006cb6aa1915125c80989d7c102f8b0cce25a13c40a0e85da6f6db9034c79860c905db22be7c2f16d61c10e30101ab9e0acffdf40da72f538891e094aaa63c499161a7a501ad5706e1a8f978d2094691fbdda6d6d2034086196b938071b5c93f6d3bf9a5f6b1521d918c52c92e64402e9dc922c66906935573df2978772b6c75383b8744005a755bc82557c8e04f246ce576b802a8cd22a722935ec13fe2f9838a4022482e1553e2fa8c489eb705aecee69bb89c054a186ce9a58252b8c106b2fd51690ca4899bb4442959f39a9e33074ed34e1d010a23e80f94a8fd968bf37ba9920ad820278cb3ff9d3591b1a258af8f70592b7babf7d2fdda5a4432888db588231d73246a6e96ff28ba94b45e756790eb39cc7b80075bb4ad1ac29798ec84032aa491e2109e5d11d509ebb61b6c1647ff166e207a6e3c381f4051bb4c4b7c0dfb5473bc8b6f8821af4d3996126064728bf20b60dffb61ddaff4b654a485462150003a1b9f9cd960d83e25b77f065caf1b1fe3f41d8ba704292b5a4e955c4e841198b7ec004b360919fd2934a755b9a43efc4a2666d452eb330e9ff71387f0f5311ec56c107429088cca1c082512171b872167e61f6cb8c602fe747e53872321bcd6b9a4f10d4d5cf31ba0a1cb598633eddf6916440fc33cb2b832b32033db980538033add89d03c0016308d3c08f2334e001a05498736afa44ecd5550c8a258b6a8dd71fcc2afd5899dd14b78cbefc5e6a0b0069f000588875ec617ef252225ec00b1e0e2503933c17d7f3e700cb71d9a2c3b614ed3cfd5b5fa8f688c9a4105bd673dac4e71ad9d6d0e0339851cbf6ac99f029af99b3f115530fbbba3cbe945fdb88abf4333adf8c242d7431fc9ad76a3730cb5798bd62a006be34df6d8161361c6d5e565b02f735a72a50336e612aacd5007dfe19a7e705b1d36fcae4b660f1bf376033fc3715ad40fcff41d74e1d61e413061e0f811e7648a723e34d7ab78406138115c63a0a98ce0cbbda0eb211c0ec65346493de243f6fb9f695ae69b27028006d94d33e39afd8cfe420bf2e2759ed95e2d04a07bdd1eb10fce233a0d0befc0639c53f71c5faf3a1b21a92e112512b121e114ad0fce0699ca071bc399a98f398ef9ca37798ab3e9cd184f5a127d2a50d7845500512051b340bc076c6ca3c1f01a6ca5955171ea6c4fb69ec978c353d0d6ce4fa130fc2702c32b70c9d363041124e2aa87173bcb7849db179456a381520e4c509ccb2165699314be8acaa827a97e0dc27054ff1db2c84d0e27ed8e0c2b9236bb3e88d79ad097ee73da6e9ef38a10579384ebee7d3213cfaae64a5f6d1fbab1fc76c405c53d10eed1025aaf573c9ee3dd92ef13fdf984f236599fa40bb03a6967b153501d953826f5c91aa66bd23be9ef347e0ffc6d278049d4888e7f5e46c09a7c07d7749065781485f70249d62e2aee62660181661895e7ee91980628e07cb148426ad03356ea639778fce12838ad3b75bc4831e70b60bcbdce8bc0d079aeb7233f89613378d6daf27df47193bf0e341d2e46e50b7a7fbdd51740246391c0e1a07170fe8e2c119229311651dd0391886d13617801b70009b737e5740271cc1a82fc4458d6bf6f2f9986631aa8051db0cc73a62ddac5eb1b3f621e8d7d1bdf9a487fb7014525e5a1f3286306d00fa3877112b35ba85c8827ec671a7c9432300a62932a04111cb29e36d66bd16e1415daeb9f7bc38b7c3b03959db7fa07222aedae7f7be13a2c4848039a060a34b937abee480b5ac76f2c4f0976350a8c808001069df52358bf44055e5a0a51c6da6d4618de23f22dcce9898b13d6808f5c4ebe7310ab110c6a3013219df56de496c9ac846446c482c89bc9002bd12c238b5f6f9d466d0fe761731d2cba2f1ab37e33dde130466077d706c04fee7487047524c32e09d3e469897154975f2e9009d7c87ad6fd0f4abd19401491cf5369f358fdd62903456c80f97f81041e294cc7740d18f64be862f0f5611fb6b3868a7a4ee467568595d5323544e2488ee1e53c17ccc041d48d8111f43e82838fdbcbad4f62bdfd8ed24222b51babced2199e43df2c9c4c467b4d556c5090f5eb90fbe0fba3f8ca261ce00b34c179d6ae67e4e8fce00ef8bf701cb38cfbd502885bbeeffce3258b326595bab68beb7f9bff9f3187c6c19766138734ee4b1d1a26f224da4785b19c4017640332f3b4a3206ff672c62fb802d4746aec67c26670ce1428f9b204dfef4927a5722dc69b1a779b9eb770683c4b97c1fa81fd885d2d044428277d203bee171e6fe14b931327955c6a94e0f58a4a0b27b086317288e7184fec57e7002cfe672c6b34c8be496144b3f16d76a34412e15543a68c4f473b33181a817bc51bb93c06c8b97a66f7093877871ef1dbc04ee04aa6625df7c2eb478d672128f5db47fa08c8afc47e1da50c8562cc70829cc6fab1c36a118b6046fd4317e63a732967ea9efba7271f9d931879c71a1e7e9379963b1f81b551fc7dae24f6afbde7037bf3a103f2c1bdca066319d3f2140caf5708c5ee43478131c43fa03be3a062a2e2d386ce5de3fb7fc03162e8505ea0b4f8c24f6ce6359d49e96cbcd4b20cb67547b164bbf299f0f7875c262cd3841e2db6561515ee461e5cb693bcb02e6742398f30453135041a3f7db4184394692bd2d03aa7b36584c782f4bdcdde219e2b58391898c0c1fe3266f28f9dc1a33b51ec3bb28dc122035da1e91b8fe91ca0399ec0039cdff1f4ce91e860c2cbbd25a1256d7a47c74b0e5c528e553857129694c54d99a2da92afc3d23fde3fe7b5c7a26f908b08d4783c4555659cf9edc635734901988acd93c57d46ca6d665e2462c99ac20dcb3942ef65020db22f2c63d9566e9eeeb38a5fb7814da58a8296a8f326c13f0409119f340ff53625cb9526a6539fcf00f6e9595102e56c10cecb31085a49a8948a972b7d9c0e8dd71613da787c86698f39eb90c4ce4d2b173d0958558f563abe5da865f535ccdb8933dd09134141720b847455197047664759a9bc75bf8bbbc3cd2baf0c486c4d3af860ec3572288f62363864e36f03ca4b2e66fd9f277f75633e898686abdfdd51e15409056cdc45f6c500263fe9e0687cb7e7fe9a29add87f6e1a4d1eb929ffb111bb95af310b1af53e2bb74f96da8a7e169726dc1c305563ed93256473f46291ebed4d8df961202abb1ddda89696e689a91e5d4b2be1def83619f90d1c855e62c32f1c91a3b5dc9f3a5684e0fb5cc63207ca7fb9830a6b616a7e0c10099a318a091ec46806531005293063b1298f917c61e1d653c08392c9d07f042e3c9fd72e4db317e5eec7a7002e53657f595110c461106c7e71054c3a87465fd34a4654046039a24217133409587c190ae4ef5fcfa0e127d026e8ba29146ec37cee6b5e48d10d3ae059fdb8d08a3b30d608d7e3a5044112d652002c10aaec69a4f49ab6e7797a79b6ae9df1fb9e3950b30f0c8cc0c5b84a8232088919164c932fb24eff362f17cc786829f888d1343c14074fc13ab7bdbe31381f8d4820a6ffb07ffa0946b01b8fc0d28c31ca6eabe233a04780322ce771e80573c53cf8d050bce91274ee9d0bd16e34bd1390d66468773d2cb06e346605f6fedd36217a095ec2646ecf2aeb85d31beb53c9c97f227c961485fea7e69daa7f85bfd22c20b1137eff6123e2b56220a296219187f9733a5f45dc3f5c7ab19043977cd5000cc71ea245d24b4620cdd5393c0acb545cf52054d1dfe2d89217d4e31849e1c219ae269aa09d143c81470a35550d5d1aa84c7386f7641191930082f1c10f48a2da8a3499b3aa4c57d34841d84365e9c14b358e9c7361d75824804239c5d388dbab1919d1eda6842e02ae4fabd675b76531a2710e07a72df5f40cfb28778396014467c90307f64182a6832e2a7f1f23f05a1e0524008c7f024d11e287cd00ca2221d14d87115a459163aeb45394167d126f2e9fea1a0f7c996c1d090217f8a5fbf1fad703006c7bf314f0ad715dcbeb3bbb1718ee84164a473690215c8829e3a5ae4b0d9335a4eebd0fd094bcc9489190ea4f66e029fe9d71408e739d69e9b8b6df0e502a1c4c4dfa74f3f87a75af5c78e1952cd766ee7e2b9e4a43cad9960485d88fca9fff0c22e0a04a3fa9ca9a6f42d807ad69b1f87f8d7a34b2eebe8b7d517b85bf64f7902ac275202526617b3e0d639bc9c5f7508457eba8dd5866561952e02582de90a62fba406036a977c7dc73c32a858f0476d5436b639d3cfc7fc3c1ca22a9e9c8e2dbc41ee07c74771685f51c512c7ebf22f718d2925e399863a9707df10a366efdc192209f0c2ad9bbf247f26eb14658419d719c4da448dad37f8e499dc0f5d67cada7bf93d84acd4a5d2c7171761b900dcec1da5eff205157e22ae7a34218cae79cba29a47237a05840135906e1e7bc7f97e23bd58aa7839a07b3e42b0bb3042c3eb441fc39142724c9d005adf4e5002105d1f755398744f903d2a5e9df463e6a384fcb77a87a78cc1faa7d8c2c2d9f79fa6278ea563553a8ab8b8e2bc5be79e79304984c6de27e8b66a3eefbc0dfbd1a7f5f881ffad6d26a9cf47bab526c8891da7f86add4f30be05f69001906cf6d53f726ae01ab6a2e6078a7835b347f0fd63548c4374de109dc9acf2b91d933d1f599b66382a4ba83cb705d8b78b0eb69e032fda18feda639345ab5aec212d927054cb79762fefb4b15f340cc536dc83e032a6031d7e923b8ffdf2e2c9b28c926e0a34fd416244dc1e26fc5d4a504368547e8cdb565afa6723e3474aeea7eb64f1c5759b4863e28c0e66d40b8744df08ee80e2a10480f6757b29cd8d053fc47d1e6564b3e8b557740f11ad0a61fc95ff38af1f8c4f168c9951bfe09c1c898767bcad792dc73aff8adedcdf3aed992b29362466de1fbe2af838018203bb296fd0f7d73fdf490a03ff7fe9e79820b242b4d4711b282212d7f3f2bf15dfbe00c9fa691200c6f05f1e64a29bbbe715e1299bfdb52e962caf98b53428821177debb4784f12d690a57dc690fe6b9d97ac98f8937d30c2779bcbaf429c6277a8cb0ae7fefe68cf92a91989d051062681eec5393354c92a4de597825c4604a7a1de7bc09bab58184a51e019f2200204077170bb67db9af3bb8d14ea4b2956e6d92a6bcaa47593fcf5e417ac3b31ed01e25eaddccc2c66d8ad9959089c121b32cfc570656d76197e0a4e55eba554dacaaf6b8fdc905715999af3a0ea7ffe650c357f2327da227b4ff612fc8bf281dce6e59917a279a8d693c41c37861a158d6d0b4d4a686fcd01d2610b775718f930f0cca9fe11774dae172e2c0707a2a8f23febcd2a8ffd53865e0950fe034605fd5b0733a2534d6eefda4ae3ce2ccff671350cd011adc15b3e78207724c3e212477005f27b3fc59d86473c4c65ddd338f08e614fcdfbe5081ec3d34cb90d6ebae40074f2db643992b097717165c3b50d5c6dbca8ae8217e795b2b089889f91314cd18cc38658a56a2080372dbaecc29cd81022cd305ed04d86dc0d45d80b5baa8a205fa52ad0b9afad79fe692f6060ae3930214e50870e4adaee42c308fe49760731e906b7d26b9d60535f4a048a5302b2531e0c35ce8c146d25f6a96c7622c0c8c97c671a59e087691a17788ff750ef48c546ef853cddf9d8a71f47869601ed99b4564233b3d20c60a251b63ef2cfdf7768341d42d273be47fc03ec6e5b9bca787174ab3cfdd387768c9e89f0e2d21f2a48f315a3147f20b2d3fed65cececda24c8a636bf5f3ef6ddf4a9f4d20f876d0370cef0ea6724958b6f2f9c1bf08c6d5a1901dbc3a6f0c1d4907426e257800ad3225f12541","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
