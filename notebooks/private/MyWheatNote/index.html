<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94318e953de914c9819ba049b05407895953279eb593d902c234c84856a1cf66b1f4a9d8fa0865e9557ea9529837b0f3d4c0fe7eaad03f755e4b66291fb5783d1d5f722d9f6d63dd6eb014965adf1899b09ef7c56e99fd94d26d075b4003707ccb30095f28128aaeb053bd35e4529380adb206cf35d6eee13e509b49731a07dad1bee7fe7c11cb0542778287cd5cf4fdd01645f550a66c919192449bd74ce5fdbda6b0b1d8f8b7191a5b83119803b50491bb8e83adab135dbc009e9b3b35449ee9e6de26a22670b5b3624e270746615f6f94efa7430eada344bb70442d7ed84f5785c2647799db3d5f8ae5b9b8acec1dee6150e3d90e17d99528d00c813ce533bbc14ed6b90f417fd5f0042a79c5533604f44ab9065e3ea8ea90436184722491200ab0b072c0aee90d0bbb1c4ddc4c0c9746439b8739253f7773c0a8a6e96834dfcee6da8c3d7c9f7f24d614ebc9369e612fc97db06a371275f971a516ef444aae835d9bc7fa0db09b6529a11fc76592efd036bd9f9855619190b2044dce3b28e7c81533be7db34df8c061d8423f4369a7abb6599a607e8973ce6c0326fe0ae57107e282ce6d2bcb27ec89325703e6a9af9c283f769b61324efaf0febd186291184bf70e2263e2b94f001d83e52dd5b114cfb0361259227568027d02d04869aaac6f6b508ca5560c476067dd736219133e495b3423c17e2d6e110b7d57149eac3d02a7682fd7a8185fd398d66abf9afbd608de8225773742db1511330e3856b1d9e1f66330b5bf1c5d703813424a050676df9d1fc4ced338b2fbeb5a36da2e48cb6044a620cffc71c1b223506254f7da1af2f51fc8054385aba3eac2773f4204c1c25a65c04cb46be97a6af0c93dacecc24cdd48b5979acea734a2979ae81300dc89a72a6439be95a42a03d225ff20202e7e86e2483c1d6465a73feda0e83f847aaa681b80c56368548821a916885873e5e25585ace7850f87ea2a38dc73b5548bee02d0e4b87a70f58a4424aa552c385c7d63da55dcb1ab0093e49f1f3591cd97c81aee8f2a7a7f47e41ae0b31f3211d9e3461cdd66206f74009213bc9d121e6d7136068f60901b90463aa01433a05f9a66a8e5cb2f677c3b4f7e3b1ec98fdd4a87557ccf519188b939b9cc4e14486cca9c963c7bb9f17bf2f6fc9b88f90a7016fe4b475de5ed69d5c6304e7b1afdfa47f5809cf5edf9dccb0824b17259d3745fae985c51d3ae080a4e2fa34f1fbf1411a5aa55068bad95f2c0149d624a34631e301168ef3b9f40c2df74d47beba13933e22a8404224b6153745be7180ccc1e820f500505262806e5c441f8fe10706d5850103c85a6793ade5e4dfffe8eb26924d5f0fa3221e5b5d9aa1122b20de935d46efcb28dfbd2f27783ea47d520f79382366d6107123d57602559f9642dc1f381040e746fd56825943fe4d9982b89db003f5ce2774dc026f13df0fd12fde56d9ff56afc73a295e75080c6d7a65eb512c753c99989def464dd4633be750c60b3c7775ba52badcce9b4f1b0acdded19f98a253219750ccc863a54cd5c6b44fdf5eec761813379131f5d084d22880e4f9ee00d8643c7006a9d59ea3bd7f0bbd8b0d7850f96d229cfdfa6fef7c54989422ff2a82cb37127555c00c81dc1e5facb1b4361dbf9f753a122c048ea6f15eb55e18bc1c5e068a581749860a83fcfc31194333f852420676df651e19edc8e403fecb08c3b0f5a93416513039243a89d45301889868c264820c77d4721e432257b95bff8a1b22ff090574732c51d7326e42fbc3509ca8eceaaeb8d4b3876856cec03fdd592a9258b53846b698bcaf16c06d03a3151154d02d91626974b33ef6905f10783dc2d71431c752c3cbe84c8de51a31bef2fe128b0994f978a84aa229ce555508d083bc8c1a56625a3a7d0804f2f6629024e278e091ed8b91079efd07c230b768dd55950526812b1d3283ff42559a7ea5752d9e4a73f7a0522f89cf7282fa3a8702a0afa24fba393301d6093692e9064311f547c71196e34b2c63b25e53db491463b1b3998d89402d9f7b8fdc398b29768161ecb3dd82f88a392deba99b435ea0493dd9185270839c9a44c3cd2e1857db2945cbc9e7c762694ec43c3916262e9ac1aadb0ee4aaacf026adcc4a2f753201f9c1671f812cbc58663058b594759df1b51eee718857cf683798897f2e7a3161e653144d37655dbd55e2430fc2d92b60571279fb2a7b02fabc7fb5b77848ca1b9a4932b5f7f6219a69e4aabc03f543af3db1cddb51b97977a2474bbf75322ee7f3cf75d59debd31a27303d8241fad7968c2d5b42e966bb8af0fe2b6ae0d963b20042dfa5af2f48bbf6717ac787e4d455a9af40d109ecaec7bcb6c527fa1647f52c7a451ddd90fde2d7978976fdefca3c8d44a49edc53f7d319d949b3b73ece8128ddea344bc999dcd4025221cef42ac426596bece6d2eaf25bb020fbe92f613a03cab01dc7bca8ff1b88518eaab9c2eef3d2c45b14119b9a0ab1466f1bf5d4a6babcb60c65dbc34968f7b82ca0922be5be4529bb5fc69ded8ccc30b2d55328d64b41871b12dece53f0a20774c0b45528853cf119529f6ce40c964932aae347e8eff45bea7a93ca9c9de21a925a6ecdaa7832e62249386aaecfe924db164c224d2c010b17962f3f7ba9791089cb428dd869057d402749274320c5f9b7791797d6c59cefab04b5629dcb4cacd008675ccbfe5d6b6cfbff38ca04b5c3224412ccacf1def7d1ffda211c34c371934631ba2610e69eaa844d5e430d4d44f62de55eaf09b0a90603135e9445ce216244f8949d079821a4c2534e499feb58951fba55bd1024c3fd8ab1a117f3786f93c9ba8df879dd74836eb510235a4cc1edc882a1f7c33419b365102d1171b4df62b23c4e06fb91e3cdbac7f90f17bd8dde3ca9a5590d36000f2ef0f280905e69a212e34007c14421eb4b83f6330e87791f9e08330e34c308c296e9ce74f19f088f9f93053fb5eac1fa14149a008159333eac32b7d504508bb88081da359222b7442755ba7bb9da6edda37501c7fae4e1f34fa8e8396c3d0c9070ef78fd6470ad8603fc98d646928ac3bd45f287b0605efcc29bba74cd8cefb0def87ccf8010eb3a32de7b79ad04db32c1aa8a287d826d1d1b69064f3dbd29519fcf1ef30387988d454f884b9263375f2ee8232abe8119c9734efc349dc22b9f821e415b058011cebbd38b2e7bc2991ce289afac441901363922df62b00d14146e987fbd8cf6d3cde2a1f48b5a00de594fb5507721cef6a0c4e7eaa9a60699dca5273024f2b8489de4d210cd72f9ddb96f1c1437937ba1f139ee82f43cd9b54bbb0500846dc83e10a044c52b4aaf90fe89c00316455cb91af6f74922c10eef59af9c6a44ebffdf3808fd924c0cd684b9e1a42d5c278979e4d5a85c7c4b86d6763ccdd10030bf65821883a84bc236d54e9b078d1c40eea0472845d0987c7ec0975b2f16168c19d8793e1c05c1a2078b407775b872b18dc5a8a7efe001646252f01ccafb10a3730d66184057883184f18c7831d1acbc1b909dbc19930305455b310568165322ca817ff996d4e3550035c736a6c7e4ec3d437bb75c7c4b9ca4ac89aa434d195954cf55a111ee54890c8504cd3fb837d78e9fdd066b19d1fdd308ae08200380249768db4543f896811f5cae7170d4bc9efd69652ef3cb442fb981bbc560033e9c7a8276ff669ba9a6c6956986fa7351941d8bca8167cf9f6179d784203d4f06259cde448ccffae2321b084c1fcdb69a722bf86a026d3c15843b7cf1c3edc25f471ccc63f95635e0f26873f350441c5014470ec1e51531545706db15b6c15da0721e4a6696f2e4580d6931c88d58946e4b64748824624b88e7546f90963714a022aa12b1699a86fd44ac54bb05976c137c7928f94f5ba831ed8052da391f9eea6d6fb770cd7e18b81a66ffb6b81409337234c5868ce0d0aafe2dbd7fc3f66a49893065846a7039eab8f10397694dbd636c0040554cbd666aaebae2e0b674fd5bb736af6919e9803352a268f1d95e5487baf6b3338a17a98431372b61f2b0a8fedeec2740d161a16cf519626cd53a3568e0bfecc0ad67ca891f00968bb91c7243bb3a76d882c837be2d23d3e317f1fc5e1944b60b422a08c9d585cdde9f42096b7dbd81ed3af35c6b6f3176909e30e0e59b91d4e7cb2295b8ba823ec748d957d8dba724fe388cd9088de70b5cba5e706c3d90b0d41c1e7b22bb2adeba4a448b969d3ac12f90b43852842393602b0a6348e5059cf297cdc576588ee3cf50a188e2686391ff3607271559edcac7ed7c1df4c3e0cfb3452278ea54eb79648d76c861d1c6c1c79ee140a24ef9c3f2998d7e2d554fec951690215e77ff0fd60fed45a980d52077027a2dabfcbb0c2a93ef0d860ade299cfe2f09ecdd3d1fc240e4f6004be4d66cfdf4843800c4c8b1ef83ef6ef21f3b76f714da85969caf0731784dd5e1e4c1b1d4d4a8eb57298266aa6a14655286e732daec8bfe9b860c42af1fa3d80880b7fae0e021d63714232c48a4963073857de8c4965f4fc78ebf48097f3cb9048c67d63c60f46ad6210a11a525af7e92fdec7f71c183063c9abd35dbce01a9c5acb1d13f21a018aefa35312588ff1a33992e8b2e2c7bcb4f0270fe1a037178cae214dbfd29cb3ba6456a07fdad53f299cd2137e72611bd1d7a9913e956deeedb79cab4df8543dcee0aa5f2708b346a90b99c7326406505c9f12cbed2db6518457132463d1017a1758bb3cb5404c0ecd6b9fad9b8c0577b514edec8cc07f97bc73f50be485cd37f8bbcba2df31e3774b45add8536955c2a25e18be0a2a3eead7deab821456d83de745d590fb1f261717f3643161e4e52a57bad1754e8af4440debf10cf07c7ca1077996b15100bc0121aee17d3841b72d766a07c060d36765ba1f017cd63e299f11a8fa0ef46a7fb28fddc3ae51e57dc54c11cacc4731dba8a9c2ac86c021f4729d521518b0fbe86a8e727c028ee044a978ee03023ab9c80684a327f58388c90812c15ce298bf1ad58f888167fbb93fba1de0927798a81625d2bc432f8e8d56d95f064202ac4aa27775cb83300cebafc1af939b17c0628f7100a409db21de4277aeae4ab890d9c1bc24ab528f72fd7fb0444aeb20d1dff6f1fb9d7ffdc985ed29e01bcffe5224feabb4054866295c2d293720508d16b6995e23d9dd715a97216423a08420da07691b9c4fc595c907fc1a5739eb72c68222d7df0a744e79a279e9bb6d9a145ee492fc2995f233cc8c8691d8211776cfaad0ed2be8deec053bfd0a26c3c035d43e71c6fdd6ccfda21735d61891c82cac65937720ac5ac5018ea9537a7b79652fddc412206b1b0903bab3ea11d7bb246ed00439a3487811cfa468473d435fd17df56571919383dffdf9555ca5a459a4e1d8082861a2fda6980a38c3572eb9841a50b303d32c0a2f0227675d08d963412ef76f5a3bf104834406d608b52451a81950db1502ab899ef63a903b0d22536fd403e88d9aa8dede1f2b03449ca7ba9d825baf34fb0e6053a7f1935f73df7a1921637417f840805567364a3e21e0830dd35a990bb70d1e4a1f7011c38edf106566a34ac7913dd6b58f1e2f1a809bbe5c72321bd6e31d1a15daf9e4ec4c4e5fb347005cf8c7f180fbf8ee23697726630c5294aab4204abc17b0e80da67484e51e71bd4edab34fa9d203dbd9d98833bb1341ab1eb5ff13c8ec1552900a66a6f8863ce93ae9ae84681bb04fe9a843047827bc1ea1ee6decbce1c82889b4cff0d9937919b7e7a596855911aa8ead3357d06e71a4015a01f6edd5008848a86c1bce4f38ce7d66249f806786679590f4b592516dfd97a1b8d39ab5811b0555cf0fe8f1f694c6a1a194ca21d0380e46e49e6c5ae525e63608b47454661e6bb1713ec02bc585daa3266197c7e8a7b04ac6083be8e8554f1636081865eeead70ada73a367aac156bf0e4411e4fefcc01c00cd7aa5af8b157e0d6a7177ec5b5ae591f2ce1705ed9b5b441ab1ab94c2e8412aae12d5ae7578a5989bb782d5f694f4d9ef9c3fc3bc90111471d644baaec04e7c7f15a33cae2a85d975bec4a3c25d7e886a9378eb839394fbedae8fd5f11e45ecf56bc181eda8c83076ff87884dffbae427a4e8dc5ebc37837e783e282a8f8ca9d56305aef6ed33bcade81bf2fa5ad869b96382062f6c15f941734301173a1fbacffb040883f50e254215b24042ac80854c6b9c4d9bd4f6e4bc0a5406fbd175709b87117db7ed1bbfa6d1b37684a3e4fc7d8644e08242e7453aaa8f79b37ccd4b63eaef808e681777d2a618486ab53a4858e702c598ccabdeccf68db508b00d9428ddcf325ef99a09c15915c8ff9aa989800fc3285f62d75e8969e09cfb34fb1a2ad1900f6635ce24fa5cad1f382b2bb0c5327dea23e2d6c600022a76dd6662a44ccc9db4f482eeb0e2a88bdf47b91064b7d8d95cd42cb42673916ce4c2179a54d4df09e642556e7c8b2091ea2895e75db01badaf12dc0e525dfe131ecec3497836fc26dfcdf579111fba22dbe34269cb62d0976b37b0d02ecd2f86de49cb0ef4b88bcc51c82493dde1d1fd73d69d0fd7324c84cea1d4debbe5bcd9afca49afb686d2b715730d973fd49c72d9fad648e93324f2f704ff5917094aabd07869d6630e5ecbc38b4a58c2fd99779f2333496afcf788791114ab23a45c4e01da9e1c0e4ff87052a0966745a30456a2689946b5a28b16818db0e2621f613c7f7a28729d52614dd6cc70b90d62e1060af6a2c48f58284406463b3a60b4d621b790077860cd63ad6888dae10aa193783815a60fb04636e33794d7475ed7f6dbe69a7332c610dd8db4b49ed102aec3dc3617085504991747e1dc30389af16ee136e681a558b846a9485992d1d4f7446d57c9fe4cf90119d10833a714397d4f0f29b4b74454ab8dbadba1484322210baa78ec05a63ebf855d5bcc49900a26e40f6ce1f4b419b7fa3e84e8f4c64e58454250353a91f7f110ff8202f1a69faf0f02472f4f2716208fd8bee3bcb365784002daade933525f75a9d76f98d24acd2494dbf333d784757dff530789b75cc89d30df650cd2e96649eedc85a61838ae14d52404056c8f9610d293e70cc5cd21a5ce5e0f791c0e976c8f9198247db40774d40988a07f9a49570578d7b57f79858515c7121e657188d59092c050f0b17da8aaa77fbc4328c09b1636f0a05a961e88f4f63f02e582d9f9c93becceca177b1d5254e61b94ef3f7104db1805ba1220eb797460b2eb12c5bccee9e2feff00235b480dcb9e14b8df02a752853a5b7fe59844410b3c41e5be19ceae527cf509a9d03d5ef083b73ba73f0c4f737a68ccfa1c3ccafb6bf5a0edd9c133d562801b0190ff6d8ef24e8aa16b9a707d4143be05343bea0c29f0837367ad98ead93e5102a6850b8383227243ec8a8a9fe040c4ee3647787d7c3ef906d7f4e8a750ef0812d73cca796926f88c21faedee86f40d260c2b09b588b248035ad64292d9076d36111280ebc0e57aa48c731b48797f9073ce02c4d798d0e22663a9baf6af07309eb2a250dd50f2ae560153b53ec0245619c3f8193cb16ec2620abf9a0d7d8c4d3a1556f191b71b1fdfa9074091e77db3a7f588afcec93b0db7e22f4899941cf586330f6fcc3e58c3e4e4c65ecfb073513c0dd6d539a1aad569bfd9948cfa4ba4dc249e406bc1c1bffe9a00a82a46c4d27e823367cda1778a5cae419df607df89bd1ef0c4501f9490092ad19ee948b90bb0805cee076406f43fbc4d815e6c53ddc67676f7af0469146d126c2650da173f8531d1827c34d7c4eb43fcedc6461743a482325ff2c11c2b84149763d5b958da43d60c524036b0d6f60861a0489c9df092d45b7bf5cbde0a72be8f980fa3e0217e184035dc871835db04bfa4c909079b50ce9ae6ee4390ac293b2cb21f1a8286bf2c15582211a77f0892ae1f253ce9d174f7721e1478d4dea9768d0c2ad759119bd998a7b0cc44435c0da926c0608f91b21bcf69b73d1c711adce9bbf2acc8f38edda1b18ce8f0e2d99dd962fadc1678d26440052b10be543a0fa44cf40476cc5e81388f65ee3fe9de044b6df296cffc30f37450f69f0247d7bb73221348ac88978a78a1363201de8afec55fd4ff36eec2bd329d5747018c399b94d5cafefa45747cfc72d4012f8c92088c93f8e9c143654a0f21fc2ea87783b3ee784f74784e3a4a2321ce155ecbe508253ebc61a3c1c4dc93a1bad10f83de5f36e2837dd2ad144714489703c087b1e67b4cf44f8c5e8e33591fd073ccdcccc9d0ccd8b0a40f7c88aabcccd015b915ac7bdf8c64e4fd8403c7f019957006433589668780157296d0fada6f74b955933fe89df0fd9511401c7366d69c0b597f19db008b1cf4a96c5dba7d6b02c8bad33c2aafe2de32ec94ec62ac81b2bd6cb2c014cce5044c5e2f607aa878ae72af8a740eef7b2b413768782fc28eda5cd8ce476aa210203f24d457d804155700f299d556c61ff281637799b6f77227270597ee54346e3b56240a58a3c7e883cc1b35347095dda4088657c48176aea1a09dd8deca7d30f5af3533588a5101436b81aac86367344f4862fc4ee398a8ebd01765d8f550af12806d9b2828409b8abd08e42a116b30f5019b990173eadff37b7b92fc39e3aac27f9332e8f55942a1abb5f02dde3d2a866623686486efcc8327b1c172b1d51f042e05401a91e7cffe12c9812bf8b77996fee1e6fde93c00ff101f7f7b1de450bb806f3547feafbbcff1a9ab1f93184fbb26e5e0c18bf0cef79eff2bc22f528577ca2be81dc3854d484a25d2314ef552f8f05b8bcd1f5d1a92ffc0d58c5fcc47246ca74e80400f38c2d80b9ea24784fb2cad9916c75a1d81394615da0aa90030f82322c43a19cd2f4e6593c3cfc64042a698e223ce980f09df47b7a47a8ca9140b990935bb43fb2ac8d76d5845832d1352cf826f77b9eb482a31fb261b06dd3e1130a662c6deb527d42fbdda2bdced45bdaa0c743e0083bfd28574ec447641b7ed72f522ac35da9ffbba3b40493128d21f14712aa3d31933422bf664f19ad923f2a6382773f3d8c52fbe0c78701c5cd0fc52aa7dd535f6ba769223818f59c4ce5acacb7b8544b947edc32506f726de87cd58da5b9c399756aecfcbe21e287bdac59dd5c6ac54aa9163c1bd393b14d76a3018cc56d4f22aa3ff41381db873130627963c72391335c65d2e359a5803820a896f85a15345bbc0e4589c010d8f85a30a123e8b7ed1270103d88613561e3d10520f29552d2bca492fa46abc02b679cda04a02525cb6d32cc9703f8f91509e3acf789906fd9061747d847e6bf156ec2c7c7d6ef8f25c5c9dd9c1f2ba349bbd76c539a33d21615d0221b6c217b47995a7b01f08539cf8c1aeb95a0509df7f55e6f871e3bd3d1ce1c1778056b08ad70b20ddd5509d2c14dc154dd5fc96ca9c8654fc2e624d9fa355c50700dee96c917e1336cecaff6066328a4584ac1cc91e598e55d15bdd65f93a13bcb52294c24166583582ef231550f04c48c3fa68da73698a9c6c19955383d2595aeb6fe991b2d84ac96b7d56ee6fdf5d417b695072d99875654d62f586637b2de8dd509b1ccb03f23590a48790c9c6262af17cbe106a3c5997b0235953f87cf381c7e2e8b3b611426ef1c2d76da1ad98cdede17d00d9e334a934583e5c88242b74852042c7b9799378b12a9b8721fc1299d636abf890771641cf5ddfc7835207177383899e00ae033699850f963c71734ba18d50761cc4b2c379e6774a69c71f9d402466fb598ec13aa970bee78237d70e4c2d734053b430dacc93478c7207f8f507e5e2199dbf425f9dd09145c5ee5b6955e6fdda4daea98b15eb2c01412cefca79c2f90f49f33b3c6507f78580f86adbce52e614a2a190efec5389f6b2a0c6086cb71804f3f600d5d1cb286e8f31056e35e8f5bc1015fe2a3b6391227ef13293a16403ba398ce0b9b269ee19a7cb9f929109568629567bc371d63fb69762c6b91dace8a74062ee4dcc6c113f376767e2bcd51e210ca8163572134360201f2a0701796220de7f4f2e0600c4fa5003144c4dde91b97ebca6d0d81cead0ee0ef0fe8b898c97c3f3490a89fb1ca76b8e7cf8907ba0f53a3d02944c2ba43761fbe3981f97536ff5d4312f69334e2d099e86a4d48f71815f9eae69097f3f399e0be23ccb952ee7a9aba21a9b6319db977aaaf0a6ad773fba57cd755a98bb95e2665538934d3c056aaba79f23772aa6cc22557f83dcea791915006a6c04337a65d8d94542d7f484487b30bbf181485c36ced89ac3a5107b0ce84e8db77abfa08c0b3da92bcacc2ff68b5583208817acc3858b4103af3f0f2cffa6f25d997b7d3f9c09a7ca1ae55a83c900c4efca10e95e6d7fffd8232b3a97eb45c7ba3bafeb1d94c587dca58ace3eae2ecabdb4ba2535cd2fd18d4f69074967fb1111e10f178ec299c4c5013df490e98614216fafbd3cba295dc527d3c41aa79cc476d718faea22cfab154c1d5df713142785a7c0d1aba2a31625e2242c73f3375f2bd5f0d09e7a21b57a8578eed1a9d7a11a6d3be8fc3d118f387a6ee63838e6dc147e70ed037925c7e7102020cbbc4be2af909637b665ea922dcd8b0aa84dc3db1c381080a133cc9acc21fdf8ea6f17f7646551dd88c873992bb122fb4ad7ca1945aef2f29a5738d074ce314944537f3cf91e4ccbcce197b519eb0177b4a338d35ae1d4958260afea6ac7ec2c5d67f74c3707fb10572452ae811f012b75ff3e803fcacc0a1e3443ea030b170923bab131d46d714baf974a8a955045ec46f667269e4530acbc1904c48c4307824cabc6d17713180cab1971b89c6bb0e58e309a735092a49d455aec3460acb244d73d3436eba90af72ec20fed44270f8364f6668d99b95e8dcb8c6abac78ce9e98621e6da24ff08d037be88ec40666e69fec53da42f733269b79258816c06eacf2a9e49c2bc81f5fa1d99184031f5e5ea74da2d14ec5240fd76512facd8bf616cbd9383e4abf07bad98ac1a7e7c23f5aa4b510d5cbca06fba34114263e0e11d146ec9dcc0d647c293160055fc2e73fef5b30fe137c9bd326c15e08570953a556a5bae69ffe3a0306666aab2781faebbe657d97ceb4558b63ca570d6cfaaa744e273944044ba4d648eb3a279649dff638b95110d0e7d6541dbc1e1d0e20dde568ea03696588cc750241796b28df3ac7b3a890bc93ccbde200cb3d2a9f40e92f2d7def4f67955ae892439d008de03927af56e256d808d53971f19432ca3d3c3fc23cd6dc11a30f904c4796daa0beb84c6709f2001b66ee4cab781ce035cc5e39a9342f24d528759cc750810edf4b72550a41bb6754179a2d119183a4623522df60406c1cd0abca3a108f5f32e0f900bba2f7b14be610ed7aec5a26ab4b7264f666ee67fade7c778f44c0af396f7e48f198d0363814839449c8c518cf65e7edd67989c617f55c5798d7ceca917c3286b57da9bb87c4868c3406b0df6ab21765dfd0ee77da2db123459474a27cd9346228f44b7890705aeecb57f6472c1deb3439d205cc3a20a36ca0ac2f35a59a0d39b67da26420c4a2235e81a6858308bbc5b62c640b60031658454ddeb8e2ef4f434492b5a63399c5805aef1f1a2414d6ae8fbaf166716650f07ea14a7821adbf589e96ff2a24354bdf7297d7bc73625a94ea5d8db1d6ab989b7da0eb9deaa6fca4b57006cfbc6c115fed0b584c310c25f0dd4a78257f31eb38c77a4e16c5a8269a356a253b17520d0c8cabdbb5453adb656c00433192788d87a01b761df165e0ca2876f37eda5a683c00264cf20ba73a265aa343a31832ab4fc15d994e56cb980252d2a220aaa8dc15784e95c02e945e24ccc9fb11d6c9dc1758c03b2374d2a9266991160bd3647d85873c3cb9ce80e902cb5d6a098445b67f9b9b4111a1e93e9693c239e119757cb77b25e06a198eda5568f35beeef6f65d80d64c6b77b85c256f9cc487c6b93c96efeb50ea4997d31843805e3684e6caa9bb949aa7990b87a4bfb177b5a147fa54c176ef5e84e3e1ecd85fbb35f8e9968677d35286123b9fac0b0ce772d46ab4557caa61d7d6bba495b96b718960d0eb0ff55968bcd1c11b8d9d38d6ab5446a69aa9ba780548322ee8d9ca39d93d196a366b06411bcf5523ba47abf96d8c491c151cd2f3fdbba2be4c99210d420beb6a40bb7cca5596c63e5118d53b620ee0fe061699dfbe8254b2deed2f47add31e818d2275c4187405b799b73ddf06e50470ed396913a77f3905eace13c3362dce4a375631a31b28ec81a4797f5efdeb93e3ca993c2a051d3cdaef89988070633cffe7b890498ea2c4f364c518a6fec4ddcfc621e4511fd77abcf9ff4daa6025b390dd595ba02f6388bf09da2818fcb7b56f2ec74789e01467af4f3565cd98efa20e9b10d3ea54a44d3cbeb6aeb08adf4c6f579cfda1af2ab3a8909507bf6e022f1958cba0ed6b8fe2b183ce320870b70178763e082c2855897b1dd103107160aa04506006a8758395036f2df20bc6ae47374e790dc020ed12c3a4baa076886e758029bbf7a0ebe83e0168b2e35d7192aa86c37b4bd64375848335c442826213371073de2bfb184b8cfe83917d134e43b38b7f2ed927ff21ab5978232ad42d4d3a32b4daaaa531a9d711fbd8463ed67e1b729b64421a515215b0b2df731af191a66e9bcf14be21dbfb2480147be2cb31b0d9cfa9247fa2b9fdfaeeefc3a6e1b2d33e4599905f2b81dabc8715bf191138c51ccf0e876dcc6b305dec0ef28b7f66d6138133028ddfa359f8e152ccd37956aca3036e16cc67da43c409f9cb21f22740324ecb98e4c52484cd04e599be7decdf3589806f5cb32518a5f07223474da96de01fccf98813e4b48ef26777b6793e24f2bd4ae3bc1b9727e8de79355619c802edbfd85c2c871c891b2a2923dafeb92f82dfac8c088836afea12db2e2bd382259c1b9fecc2aa14652a7d38a030c5b96afcff914f77e7e19764aed5ad8b5b9c149ecd62b96c95685910eed7b95b15e3529fc111d6df6d39a09aaa5814acca20f0ca5fb7f2eaa5cbdef3a2f55b838499c07dfcf86619029b9d81e0b8263b20e82ede890d5cea1d171483d8ba6f5960adc5dbda0aef2e3e63859be732e81ca6a648491cdd6d16e7f553588b4127f5c1eb0bf5e5cbd45dc1e6d03aa085533bf0824781d6bfaca197e641561ef661fe9114e0cb0094bf5cdd424f74ece9b4e831d7b5cb1c47d9fb30f6d3bdd4051ff70824cccb29e3ba79d1b709ca2be48762542878b4cbec3076b74c28305e65e11baf75f50695686fe0d2c9450e1941d0e09cfb0b1b35271d9bb5d1d777af51fb99d19bcbfe96eb7d8e8f9d2261e9ed3f5b92646687b2928be7d848dddb5138885f16c0941a187788538944d171cf5c96325799f5f30042d134446be1fffa850682b0ef67ae7444d97d209fab801589ed62e5e82a0cdad3ad7e8facc2eb40d54113cca23bd2bade5568bf298ad96ff234bc8b30eeedf679845ca30047839b64e593cede9b4d97bb4c18cd45ca3cc07919f5574e282dfa49e4bfbffdd78a1e82e8b168cc4cad5988b879526a00148c477b8b5a90db833c96316668197de760c7fd85dabcbacce311f940a32f5f06e054dcdc206f44b80d00ee775c8b0b6d44683cd5d7a2cd5dd4d8290bfc8d98bc440ea5857cd5a0a40e2ad7029c53a6ebb26dd28b1e80ba639d18ddad0b5192627a157a31b1cc348c437346a0a7d33bca9e15935bad03913bcb831377073f46844b6cb423e554462988533671ec3aff13f7fa05a06eeac59e78c3b6901a520d649246fe055860e9bc65a25f361000201118dae34c49200566be09cfc4f4e969e0baff7681dafe403aa7642da6ef7dc4b6d9ae4fc703cf464e7bac23a8ea478649ceb9c90019ee123522db4a88ba4180ab580695613018b617d7f56de9c2c9776e7fc55ffba045d1b6566514a42431d30ca7cfd06224be12c5bc6339d95b430a6521972e71830318ae4940314cdad67a0b598770cddcba1debca83b599be62e3331df15ab170e86cee028537c47fc05bc6cf55e3f90071eb6b53c6a2d7f9cc9fe04bd36a7633aefcf23cec269f6230ad9a75f5ab2df8f6fdd904fe53ddc452f821e5b6751cfc3b88675bc4631abcf6911335cca7acf5b6c8a455b86d51d3dfc85335eda6c59cdab46e3532a5cff2dbff330c5ddbd69aeb8e205b40bd4a22f5bf163b393d19e7c72c6ed57267d4fd1599df9c8e1e2e64c407a8751f8a1b434d86cade44ea7fe4c611ed0e9b34ff0c5da8f7bfc8c2c6d1fd2f41711e6080e24e4d620e92eecd6f95c1721c0f296f0548a83f5caac4768c7193cf6330609ffc12caa482efa9be2e34b6f3a8baf03463cbae2358a4b4c5212bbb300942e98f1011bcd2b52576a8537365c340d45d0dd0706986226c2b1c03234dbe73454a77c37dfe4076944f6648196e5142c6f10ee6f8a1a204caf69a025b3707164825f6a53896a5c0c799975f9a8d33501272681f583f6f7fdeb0d3a36cef2297ddbf9e0f8fae5d2fb255119fcd1e41586d378046cc304b011cfcc5f32203b3362c0d0af101bb440407ac3fa8e7f342212eaf42e2bd0c1e6ffa50542a126071424dbd8febba3bf5fa9c49c91444b3f4cf8ec7fcb10f3cf4a930cc2380c6272e4a5ce96443c490071dbf6d0d3e4520d75e9d33530790e2cd0d5fee1d23f1da049eeab065307fd3c8d514e048651b88362471b1c299980bf6eb6314271fdf46cada297241e621ee6bb42b5e79b9d663f38b6bcf4e212c96012a201d63952b11850133b16a96f5293c3735db6a2c62148ae433b9983d668e755f5e5e29c53112aa8ac6c75c18038a661f86c49256cde000be09a70eb213a122d95bd4063c0133457ce400b1bd895bb3daf2a5e64c20e4aaf222d855dc0afa3c645d72dbf68f42c270b51744d76ede38e7fea2e24bf59b32c479d3a2e66f10c808593e815902514d026711b8645bd99c76179e6646d73bc971fbcf5a45272d5e4671688e0329d878ee0cf46db43eae8ee38a311024d4398412454c751dc29447115770d9aecbd84aa4eb00eb616f96d1bb8c7ac0dcd24d8ad71b3b4e8e34ae48f9aabaedba2b3aec23429523fca06929cb7288b0eec1776ee54c133627de8dd0d6a48879d95e33bf5ddbf63a4e8866e85133ad9bddc236e3ca66ac51a1e11efb920f609958c63052941345f40d8b2f24d688fe96a5a2715e4a138ab96b1dce9dbe39e37a62b5b80ab0a87bd652d70171575a2ad90e7961ffb127478c0a4daefb205a269e905dd1fbe1a56ecaabe6a6e8f17fd7eccfed5bbc1e5cb8bbf584ad2e508c4f03b53030f26f1a5d00187421c31350b499df1f926c4e1b397f905e275f3cb943e33618801eac33f922a3a6a288bcfacc10ec635e50d2933e5b9500b2dc66fb76939fae6897ea9e6b286657bf23f58c8f998bb29e8ec9df27717c9f7cd687e1883428da409f3a9c4428ccf84d7f43e094922677cf15c137e7455febb56bfde417f6dd3e1d3e615249fe03afac2bbb44f0789276bf42c08d955b443dc63477119de94572288eb527762f0f819d148260ae70456f272ef510255a2b5f0cb85be01c131a6b40099f5bb33030e917055fc833105334aca445b4be85c17d9bb8f1875ba3a0eaab2652df4199f364eb05696d67feef6b0e004b9d1393a0a063d43fcf545db7c58c3855bd84eb0cee4e731b9f64d82d6e507a51d7dab574d126677180efaf2d004196c0067dce7a6ca1bb47edce2b4ff6b214757a924bb32a502550f2baece0d08787def1c205ed3ace73bd03b96a696825cc773a22e9c15df3ffd8891695603ebcd6fefe457bda21f8ac96cf62216570c788258bfe3aa22659f0ab07a1aa4eea6d3fb2407495ab48e4f3cf8d9f5217f986d93aa63df342bd14c6d50b42abae8fded93699e1a72e8b86390dff82cde98a4d8b60c1d5246fc7fe7d48e82a246042ad351ecf1499f3387a5bc15a4a3d6abc59cfaf1119d128008b268cbe95078f4f4d1d264c927167c8622a1ff0cd17c225c953b3d1f5534b028db506b5e59cb813bce774671f957ff4821dae9174953aae5f6767499f553f2a0865b69e5b850de15762f9a7e7e88115a98e563f1b935f1cd4861151637f18e9bff3b586d7a3c78c9a934f5b798895ae70686a54a8edf019a89e8bb2568fe04ed9633494809c1a4f6de7884a8e515586f5775c3f8e436053533bb592bdc43de226023f318ef6d21c67a35b553cbe557446213d9c0988cf628fdc0cee04a8849613433dc3cadbc893a68515beb28dd8a29074d0664dd16635687e70c32101aee67b9e71ceab15875f0d7caddaeb5c8e8f885d818defb44908c1b892d57c8b789bb62dd2ddc8177239f25a9dfd9657dc6374ac6cd997073625c27a9972ffd519d79dfdf0de6847be77350145790c2ced115a25fbecaa773d600016ff238dce7d3ec92dea68e8b9ac042128915bd36715ced720348c1dc10cc320ed840bf26e21d57f2c76cd5d4824cfce5b6f64d507ab9a5161ab77c208feab0baaade15a60245c3c6af594197945e287d70d18a9ad90c1294cb3bd7e18ce3e362d02a6f55336d191094477f15047bdc593e91b3fc5a0282fd404516ce4db4494b8ff4724dc77fa2971b88263798584cea3a865d903abc03d4b854de6cf8a17080351987cf240b1ee8f515840f0f9b95c3088683cc253f47cac5ae29aac2e305ffe29764ad16943e6337e1f23ff591f2448a152f719d61895edc255b0d78bb8faf0a1f9b00ae3e4b1fe2d6680a07ee4d2467c23bdc797882e0c90139cb975581f6b6ed08ec3e94a39e7b69b76d125ebe783fac2ce43dd1ea2700401489c6ea2e1cb1921d54b923813faab751b0b1fc02c1b0e6fb7e482e6a2a2c9a1eb85ff0178b483e2834896a4f5674685f6467d5c08ee754897c2c85809499b9d4d8069397bea5aab1f9648773e9e5f0ed73a02c3383d50f78ec03bef592d8da388fbb1cfc8cd2b1edd9343faf1f4371cca057bac627ba5d684509459135b38f5c293361e7e51815fa63e69cc9001561cac70ef1da76c663759ac0b7487831a43747b71471ea1463dbd13de225ffe75f0d1fe52f3fd5b55102819c78d2cad37c02d19278a2a2f6c66cad55d9553551a44f8055c3e671a79897625a5be67941e50a9e94cb243e79697410d0f99aed4f58cc686ee64e7a7098874b0c10ca13c5985ccf6f9f02cba5fa717b53db129bb956256834026c4c846c1f89443e7e06477b5963e56fb5d06398d50442e0cd0ea5ae9fbb5fc4dd7cbe3a82cb8c2ad577e9534e929d99fd9942c0e2d7278b29d747e9a8be3c5cf89ac01032141310132800cd25502e9fac88568a9eea39cd1e583e21fb1effd94a8ef7fd0d2536ca09cb0a08fac9cc4829c6d3ebfd90357d3636a5730d83323582d28234c3aae4604e8769eb11d634b722d59b1bc4b48d2c846466d96c3312b853174192c09f9316ead8b93ef963eebfe593488d3a0bc41d66593e1838e8a294b0df2019cee9b8198c8b3c2295d10484985b237226eca58c292d8787013f049b79bcf257fd09224abfe3796dbf24656a322f136bded671d8c5343ebbe140c89fa6128f885bf852f4150d6ed6623fde65b411d97fa312489db855d5b7b82bd8133527ab0c50838a20fc0174d812692c74f8fe959910b66b0d4822b8e11a690db5ae592f9cc1480bb8c8c77baf3753ef1679e60102a3805554224f09960551c62c5f8d7fd0d12f4dd5d59141da90b3550cf621021aa86c880b4d25560a35199afdcbf546e9316c21344e552a142e59a454e94c301342109447199af2d6f21f9682c407dbfac675c1799247612b5fcf65c36e4d48188c82ae15dabf4e6da3ddaeecbd0547670f933c488e3b6888b188e74de444d8adcfb302f89beb78f9b7ce5e63b1c866c8fdc1569ec24f8528d45126bc987268ea05d995a46af27fdc8f049413d077aa64e8249d6e2cd72ae6859165c0717619025fafdf6646eb99c39dbf6c033156ff1542526464a9d08e382ce6f0a0afb6c5a58da76c510b8c5bfe214cdc5155c65efbc532b733355991c4aa0229c88700a5d014d63d7fc3617d56c71974a21a0f7f4657c5df5eabbc13e1f4d7a1b50b8e9f31dc78783ad691eba67b8ab570b04e26367a8d1b56002a360da4a6c69669441d5d17af8ed4d9ea869493b297bcbbe9207d15f381562ac5628873db13401cd41ce2b3f304d763b91aded64f63a459e02c46d330d0d2db9ff35ffc3b24fbacd47f25742eb617f557cfc80cf8e1e0b4ed6eb25e2023b7823534faed15bcbb8ba69cb43f0e8be44f5b4f4e75f5fd282ec224e8d0f744c6a2d1ac97423a4387458473ad3b796407638f9dba29de3e1c6730721f0ca1dda706ed3213de08c838f358e00187163414f21efa0d649979ff958632e9fcea0aa4cda0620742bc3ad6eeb7f3cd5656d35c1225a3d24866a3dcf467590859cce341ee1cd401870c9a6f87092e3adc003b44db4ed18141b56344e842cab2670386595f42cef6d05015099d48a38395635c926140d16d1bdb620322f802e3a05047979e587d38ef8ed757bef0a836a85570eac7dbe7c3a5b278280648741ed51f5a6036c7581dc30aefdf0433732d7fe617ade74937c54b6da8e8649b60e2d0139d8b897c1a9d0107d7b55e663da31e74cbfcb10b4f157cec7aac09179856f856c9148476fd5d33e97efd6d75bb1f46e9e9d211b07977279d98b98ca70c19f44964966fcfff5b27a174aefd5fb890fe2f7fb9f2f1edcbb20c80707f7b289f121f7147db28a134c1865548bd6d786a5606de10b7c28240855d44bf5531098b76ffe0c045b4403ae5deebccddc5e7b8557a52d9405ab0de7b0087abac87f9daba5eafd33cf617e6b4389602312a0712cdb3561d9ce05bab0f0b4720af4cc0c633c6acd9380a5576b5e61662a1e4277272847218f83dfe753a921e267143cd0c7f82566eb294a6c1e4189c4cb92e43ecf49225bd0437f969858dc94a419e0df8e231b2890a401b8cd6e78e6681b402e500c74816a607dc7b15ea69a3a2ab82ad545e3a920a019771c66d1eb0c7ad72cdcc2ebe0138ceee00421bfc1c68cacbd1d7a5d861ad513d47e50e2e26cc20fc9f1dffd1546219a4a544ad704c07d24921c826a8ee3783b74e08a70b86adec7968437b9531df1db5f08354a3ec5ae7eb33956407ca04ac943f6ff105c729e1b3d995c45b23ee49ec000959510bb9b418edc0e8178f9fbd2d8d205d731b481490448c215ca462845f7db18758aa0cf512e5f04979bce9002fbc5d315981d25d9236dc48fa32ba1a03b393ec427103c2da82678af875b0cbff6089c9a556da612da890b933becf5206da1e82df5034bd21516c335a86220052e7c923507511317a3c9932bfec76b49ec6c055b51b030f7ef0738ebfd0516d5dc37eedc7ab67655d38dac7206aa0d83d0f56b5e916284a6912f9ce748da05b42120319fdbbb14dac879eb30392a5059fc677a4e3697a4012323bef1f53502141c29c3593283b92f6acb23467b01f74bb4d28c17b74c63f975ccbc9327ade0d098f6c805c5fb2855dd216d6885f95c6fb8644df010cfd3a2974df2afddabd7bdc6a6e3a27de01501f80dc35695cbac14628cd40e4cede8ab10c7b9cc35bb1183890380254a69abe1e4158aec9220f5a994741442bcda148c6055f47369519ff3d52090cdba636b8bfae3f313530d86ec25a4af33bc2de35fd0e429664f182c4e9502219c592e3134d7aa3bc191c249365ee135552a4eeda2227229dc0c48db0fb7a3a0a535ba76b7570891f01c9776288648e650e64be0b47a8c1bed1ae64b716d6b7d3330a9547f07cda1d913563d6ee4b1c2a0b8658f300a6f7f2cc4356a7fd28f4bd0bd91e9c940d693364a6573745e89da80902c427e746b87c09484e60cb04e1366c65850bfa0fa1b17a200c6da0683e8f148ccda4c4cd42387a3a302c1fb9067c9419c37d731bfa7d2e99c7f194ac47ff783bfb48abbee5078e6bf4dc80aa66f9b94df940a29f9527435fba3adae28183eddd53e802fe124f78865d249c2776df5d1182ca0a3bb72561d886bac974ced54ec6b617f7c12f99304ecd59515590942280e2489f05c60f56cd3bdb07a80ce7a32cbf9e114225a4e596f25f6a233642f77c2a020d21d4615241a906ce0b12458cc99493b9acdf8949cc2c7e9cf305ea8012b1bc29690d0d3935cafdfd21c99c7d0a12ae0aff7b343fa0894832858515032a3e0b946f12f20e35011b36540ccf9bce4ca279596c13873832a6a17205afa95cdf0e43c59550aa92ee5b21e28757c8f559a74160608f6d5b182c5540ace84040a5a267e3e52fd901b3beec670ae2f4a77b84f5bab75602c19e81a83f750c944bfbcbd1c5197d4f5c754f4c87b4645ae86c44f6c692cfc75c32cf412b8172229c8f22c4609359e810dbcc8bd90845a0aedfb90d33730901a9c3491915489365828f0c31ffbe795df93e06fc82fd09ad66416ff40933d734edb5e9cba48f7bf2a0e32e874343a7f7b78d431c4cf54b1ab2f55a013e2c9886d738421caf1243a564d46cea6484adba51c58d6ff43df1dd4e74797e706a17d5390b33bfe8451990b43699c406e9e75c22b2fece0a03d3f9980eda1dd7292ad378252837d0e9754204fb7c9b300469212186823f60a36360735c2292799b2b00430b7a3157d303921fed22e35e11a34ecb1697cf09fefe87886afc6857e3c077ca3711c719437fae9310d76827f88a34b73f77cdc064fda7b1792948c44f5a34b22c8f5ac23a89204a4895499b5425730b0674e8210274b15e7ba5e6dc6f2f3a809437e950720156c3a7d832fad5dcc02138b2b2a60dc2debe1ddd4735dbb77185e880010773843c32c7e4a501a5505e6fc86d22e93f6f57bf049cd2a98c745a840e0c79976d37eea63619dbf0f419527694f7c45829ee5a59155c2db0bb46d650f6370551b152b905f1bb83ab8a43573bbaa7eca129693c1b73cfd71c09841e3ea16b969116f112cfe164268abad0a85dcd2b391e965bac18146b8be26bd802a7d211059f9cf7b30735c312cc69f49201bfa14eb4160be835efd1b8ec1f3de6295d7550c47fa49aea93c9b7f321af3ae699827ecf8da8821073e3f6dbafb76e0e5304e757121e085b3503e0b2f70adbc9706c9ed3fbf2318cce95c515dcbcf013b08364edb0a45ca1eedad98414a2f021ae7695a06e4279f0f50101f4777a8e0e58e1901c4a4b24ef53cf8a81bb7ea60f758cdfd2bd9842422013209e62253c18c5e1e55fa411680f8232ff65ae64c491e5a02c8a65a290507363ebb16b1287a171dfe6bf4aa2f80a3d7cea5a14b56d5a696437d8cee2a121e21223ed62a5c22984bd9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
