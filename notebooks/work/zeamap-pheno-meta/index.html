<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13a8cd61b9e69e1ff4ed30d13a5b7a650300e259a12c58db48ecff7e85ae347c2d74b664342721f5b12c31175d89119e6d8ade5c160a6e27400a30cbd95990a6db2742b9c69b95f5b61579a147eb1dc17a0eae2ada91774b4a907698a0e5b651c5ce54a81e94e237321b2c3ba0bd384e3823e359b7224e4c93f8b344f3c7fd4a77332513ef0009e9da0f01fe8507a0f91ec2933388f1ef67279a15675aa6bd2fcbb77c819e861e815268f2883e78dcfe12417aca1eb1f605f7c85998631b472030809e621489ef56ee4fecd5adf4a29cbfadc4de8a310f784d144722f4fce31fdd3051b0b39838b81be9b36fe6510f3cf4d399fdcbafc6817f85930bf7f8a7bcfc3eaa5e49a8d310015a1e67280a0b71e8c1b9e92372214dc9e1b839b4b8765b9c68704ba7bf30c4d4359d582114cb29f12cea29e104c9f8ea5a14cc2b243d00de9f3d376b1d98100c7b6b2c5f05fadad9745945e978241cddc5b4279ccaeb3fefe942d3599489df26fb325f8066ab6d94c0bbde82e721c6dc675a057ba5ea08ce4528bd9864e9eb50c8cab2bd7a7a3449c2f62ab187210d0bfd4d0f848119be27b84ffe2c727084337afd7462c531b06ca3101352ebf625dfca78b5d22de1e47060c48c57f0532a70f0cdf3a05c1b8269bc03c58efd14a60721b139c0fd19ac1a484ff7eab482b7176d9f773857c1c8f143b03d257cbeb2348f5721a48dd075c2d94b8829d95381f54925df192d6f7041b4ae9ee4c16e1e9a64f6269c56c2cdc8d654aba5be0ef70285d15872d54acbf564e66dfcb82b72b6a69fe06ef0c8bdbcacf0c3a1fdf94b39f741b2f80f6e43ab13bf53687f4e501c74251a0b1f160df3ce986927c88d649f4b76a4462c2384679d15ac6ae98963de5e76133fc222c5438f029e7ed05aabd8ea551b3b8ed32e4a97c70b6a1bfd06d7a37052cec6b122f6ae70bfac1322ec69ed365d70942f4d6bf8e9911766ed9caa3eec708dc963112b94dabff29d35173eb772b87971431e1ae34efb452a4c09b5df82b3f48252782a8256d9d2fac482078c7b041bad6a54779a8e529110e6bf09593de7808540f2dfcc8f3473894349f0abdec1b79a93e79d30f232134f33aded9fb7cb8deba2923810342c88c726f79136a42d1e65341b288063f5ceb2e3cc8f6ff5f91bb12520ba981d949392d3e93a6450e2a871ff62194fe8a96cbbee412903b82dceb8615ac5029f88b2a1a396037101f087cecdafa868d08fb99c8a9e9bb700e1868536b134fbb2d6164e1e1d25b740938db9fb7cdd7ded3c04ece9fe5cf8b7f80c704bf5b13722de806d43daef24afb48495b49a47eb0c407161af9ef2938bd48d4cff1b97ec1cce95588379f7cc3cd235f309b66dd65a71ca2b320b2507579d58dc323f584d66e91756984eaf05cdb2027fd9b745d4e4da294f40a49704ce1203199aef15bb35d00f1773ae0c7fc5eb18638536ab4074e50bd6fc608eb1660d3e36cca7a3111279e71f13435b2994cc9c02d76d20dd5078f1ed7549ed62fcf23bd2e71f1edd023e79fcc5f5ebd3f97b0480a3c331621a36ab93bb4136e4f1479bbebc7dff69f69d188004f548a8bc1b4ea5ac65782583c857564da11865d211beb777c10670976e81174099a9cd73803ebdf1746ad201ea3592fafeeb980554572c805963d91d04f4ca56d9de9b10a75c8f7c15037b1016ed4bf800af4588dafd46849555fad2881f303c3219eaea1f56615f88e2d833ecf692556c017338c4a41e70948263afb1849432bab9b50457e0dd5fb55be647e8c7310eb397d36752191048f7c43fe6ccdcc4247ba765b9b1c051a93cdf6315fca6c8fe6475129f0371e560dbff562dea46069316842ac23f0b3fd127f8f7a6d866e5218bad9f422284b5824b0c6c4c65548951167635515d0c082bcc5d7d58f87e8e46fd97bc856bd00002c4672ea5824967b54f379741a7be88e107f99b983b0b64e7512aebc9dac504015d0ad1ff43afff14c39b1eed8a38d364282862a2b58c18f4ca8d311dc8ceaf355c1616149b1027eecbf239a3e456c1ed0270ed2a26937b40dfbcea6f25fec47ded0b30db476e6f81e7c5fc11c5620c19d1da4dcdf7289aa6a0fb9eb7a523e15c3a8039a77a3a4dabee771383aace05afe1be92d7e8400812630f0ca8661811b53e2257641c4b8ee5b1035ddc29a409aa6198539bc37247fc07a692a4dfe2ffdbc077c16661373e9181f4860a2f6a3fcd8c0cd4adbc0a83da83f9a6021c5d1c880828de828fe82cd9332cc053722b6b8887016be2b24af17a5b874612fc954a6a10b90765f68056f1ba94ca41d219e14046537b60af5cf12c418abbc9d5737a57c83ad2065fac06fbe8eb2a4d17eebe03a60f32e12197f7a60f644a29084e544bda268a4f0fb7bd513f4ad1e968542df69747494b126c2f74f341b2c2cf3b457628d715be61df3f5f03024d4e555ef7407c5c2ed90d0fabbb33453dc13af6cc568dd5879566462edbc0f3ba208179e51c3279122aaa23b50b5dba1fd2e74fe81c542718c0c64b90746d2c7acad8f2e8192581ed108618237fe506faf9eb87d108e4910a9542115e75ead43a022ac1e905d192040e18726a05e4853035f98c6e3c629799663228df81a06fbfbfed0289378c925000c4333d50fb8f5be8a6930d94dd9483faafc0961904e1db72ec2c4c67c366f03260d325a6d427d56e400c075775b85297ba2eef2dc8c4a360efcb9c7e2b2a09fdc99b641dc72dbd0891d9577f72e54b549b6b3c27e764a2ce34c2f1af1710e250d84d9e49e6ee17e4086970a7cb6f16cb58c3270dc612aa44c4c3e6dd3ed78458301003bc90a02bd0f6d504dc38a593e8f979c89750967df920ba7a98ea81e6038beedda4028f221511a43e8f607716f7e24fa65e90d0a35acc20e77dc401a7f66dc10d10565e80a2f05f2c273f4568a35050c88017a3492284679e9380c51b4bead581600462143ed7c1d27450ccb6909200bebd7d8e92eadbe383e40f52d9421c7712ebb87eb0e99f93c0cc6cc6f291a10664165109525284b34efa8f1e82a82a0ce3c6900bfa2368ec053768aba209c558d3e1c66e1817c64e0004ac08e434fe3bef69a6ec740c9917b23f6efcea53cbe41ce1073dad1e33bf937993ac6b126ad35d556dcb861e70972e4f0a4d0e30f5cb86c7366d08a693593387ef6c9c8e6bc5eb8946f9568bc0b59d6a74aa03df5b68923aa610c8fe4c1225e2b1440cba92dfa3b9c546d3718a5e3c6f3f44abdedb51a58b6585c2c644e17f51c0fc4f075b04106cf20af14f4f5387e5bcc81a5a5724657f27dd080572cef8eac99bfac2ecb3b257a1cd95eac5a83f327babb031ab472229f0025fad3a5b7e67556130c672f1b2bf9ee933ced84adff64c8ef632a6e96a4344f0756e2a49e42d15e3bc4b0fce237deddf4f46ac653c53218459b008182b8bfd62c6ba127a7a6d75d6a31acc7ee36dd91302d1c6af31b155ddf47066f9a831c67e952bf2494cc98b77b5f131f33b1a6f12ee2e3c01facb1de48f23f65a664c79514c2063aa84c190b0cbd2795a52a937b4f1e13258e5b2d5ff6b54feb6273eb1092e2820d719ea5cac369529ef7dbdf6593911eced82d39c9b6dc90d7c38d2efeba9799b02c55a4f2fbf96255647250d9645b30bbf96f3a50fe6a087f454d3174b5a3fe0ed70cee40f19e6520a74d7fbfabab24550af7ed1e7bea414580d71381f9262a5906779e677888cbe71c0ef8eb41b6aa9d745e49a631ecf30c1949b2e53981a2c7f5af8f74bcc701d996314ff8c2466abc46655733d582d775740dd9cc45a743b5bf37e0efb8e7c2b5669aa8e245ff95cf2505abab56e010a16c638f738cc78d4d1b4c1473b1208f1ed7f5dd3d2e77fe3e5fd6edec301e0ab444d3ec60d41f972c672505f7769211c48afa3a6f23c18e6ba517ac69c206f58a06d2b13ce6b0d959d9120dc136718d8ccb1a305fc0654ed7c861a4f2f04ddb1fa821ec59410023515b0c1302e63c59fff863cf7fc52862ab73511857a8952eb509d3cef2eefb53fc583f98831a1861e0bbfc447ab29016f0678d8605ec62233d1c8412dad93604621d891c51861c2fdde7bda4fc22b33b0df23a6e2fbe5d763e9638a77a852d8a9413521aa8909336b9e48fdea8e83133c77670445447edfd19de5c1407be3e8ffaf71b8c39660257eeb94d5e899e76915856255d59d48e859cc99d4a902b554731433b623dfda590912aff138cdf89176b8fd1e8d61fdcc570ca6ec4236d2a5b184707a1486b613e52e2790fa4cdf017c9bbb674ef85776a1779c2f8ce13b6f169e1efaa334be1ee53d255367ddbc475004e641e1255bcdbfc155e2aad82a046664419fd26ec7826b30873c96f8aab7e27b9bbec6078d0a37197420f582b883e6285042b289957132f3cde8d802c30059014317f6b478622be007deeab08e77cd9b7b229fcd7d8609a703cc1f721b9a6a9dd7625cde6fc505194b46fbc183a768f7e1f725ab901bbf8479a23be52d38ba3a09d7a7f75591ca889d4a2dec63b398cf9a1382e9547e74f7ea4833d6f89ab3858b39dc40ce85424b6387df043dc8ad65e954a93a017520854de22021c1f8cb190dc3edc2647dc7c8cb3b73ec09e2c3f702ec27c56e6705c208f0aa1f187a6d604a2d5b25bbb823f3d2957f2852a9f8bdda63ecb7aa15209c0074936db2c324174a0bc205eee20bc4fee9df9e2f7fb4911ed0be0c9acdc2f518aa1923e695fb1c0247989f6054f9d27314b6e1889bc15e34f373578417f431f145ba0dd6ee0ba4fb6009dc441fa950d4bf6441805d4f3ddfd1f22daabd83d697226ffcf7d6fbe61db4e988d490d0164681b4afcb1edc2ae62f2a93d7a74cab77cd58f14b28232807f2f2943ff53142d5078ee02a79f81459e55d5dfd06465b958685ee313a382be69771125ff280dc1eda1f04bbdd09d20a12f043f15bd53b4e6fed05186d4dfd0a33ab909815e6520010987ad78e45cb925e25c5e8b390bcac92e05c6553b37ea5c44cb6f65a1d05e0296f5546e33f83ea5b524a4176f12b240d76847bfc2e39397679df2cf586ec6afd5b2bfa2e4358b9c35078fd83cda6789c24752baa7b535e36bf9d900a4809a6077fbe07c68a81512fb695e4b7b24422995b7ca9d428060d6e12226ee71a400775d435d7ee213b473052815c63e6de257d6531e649a4e21c2c861207e604cf3c1a1f86f9047a63053fa4c85251d72d2e345fca999c977397cd49ef46de0b5765ddbc24788a23e264d7a2c129d1c46eecb2b8e39b9f3e35a6dab828cc2fe8143a1c3de970a0c4f6aeb06c368f128cb950d034826aae338d79e2ba25646cde36e7871b3b5eb3ec28825f75e053972e283688f2004a2b2a26125e419e0ca3ce8824171547f6fbb3135289b331eec9ff198b6b1ec75fc24b413864bc26892dafbe75eaa1f04e543e8bd47c54c75b4e0478ecd5b195edd8717a10eb98b5ec3ed304ae8dd326d1b65e50ce73f021fbf075db1d5cbf35b5770c51907defea76eadd5f6feb1a769d5889c28453ede7060bd40cec0ae7795c438a921feb571542baf6d1c7ede941c290963a256623dc6e1bb747b494495a84033164bf9013aea0984fccd914f9e37a6e2927971452d5151aeacaff62180019779ceb33724d7bebd496f1558f671d788e3e399565e7173cb6383b8dc9542e13b68fa71b150b7c64f88acebc34b8ce9a7fd3f6e1df13b1a3c6b59bfd343a2d3f4d1e48537ab62e4d108a8ac5de9442c47d7760f089108cf00b20afcbd9b09cd79e19e294fd42bc3acbc7eb2dba96e5400d81a5c90a4a3aeb63f1e9c388198cda8075d7a7dd2f78f046e85cb9972fa9bc155871480ed5836073499d7b923b4b4614582f50b57daa7a7ee5bd65ce18ddc1c21f9f8ebd0c9132832f66b1ba3b6d1e0986119098244d80d81d1e69a38b2a546b526bf19b1b78cb71f99e6b11b781069a71bed08278e664cde73ec10d49d3ae39fcbc842d708a33c805bd9634b92823bb83e2c48bb896f3f4e07f2b70859be9cabe29e70c74d256cd9640dd749252b54b9541b8e25f1e738ab530bbf090cebc6c3ae8f85eb4235ac7cf78344f5e0f87987bf04bde1fdb4196543e3d21e7cf4d89fb5426acf9458da55f7b373a22bfd8d9ff876f55284eb43ba77cea5ae2d6ac00f84d483d72641e72988390bbaa53ca252ffa70d87e9021cd59f8bc75208b37493286d3bca355c1e7991fd5feff8fcc8bdc25e7117325491203fa42217c3a45fe25142471c9cc6804639bee9e1259d45e235fb1469887c56a842778965d29bd05eec51c016782e95011e7010222495dbd12237e98b31ea5b1c2dccfb997079ca401c5c1419d687d467167f4f5500d8ca45fb3012bfb7cc3c0ae1405834196fe00603e04adf708e1a1fcbb5552679f3f3043990bc7762d42974e5fe1b93c0d1300c288865a8324843274140c52f604a8325b371e7ec7141073e3d6afd979ab18744e726ec38dbba0fe80e2382d9d68576e438a14aba717b21cf5f65f0b5b5ef67088bbc8f7aeef638eeccd0c756b28010d07fde8f3cd8b7c8a13cb24d983710a73fe3073ea0407bc62a9d4c8bfa7c761b881699bd6bd07717a70a80469af0d73017624aaef4f6b49c6e0b9e075b17e71920fb50b77b49e64f3c7cfece391ca051a2dd4a14022b3343621da8f7de8ea43bbd94611cdc78743f728edd17d305b71e931b330e413063760a9cf51ce56e816f4e9d4f1d4494ddca1fa6a0ff3d5919b4ac6a6ae0ff0d8dd601e03951c1dee98ef1b1996081edd6c8ebb30cf70ff99f0d7ef6b6a903bc0fd5113205fb8f98616b262432d8d0cfc5666767f8fa95f1156c4b445989647a91668ddadfd12062afc8dfcfc96cbbf99d90748eae295f899fc0c89c0774c430b1f015ebdf52061f20f9b63d800b3540c8724e1e394900f6e41283295d4d7f66679c0062334318f6edec0fbb93f0d8677b0d604d49eb5ed901449568bf38b10ddc9d1763227838589658c43db863abeb7fb996fb8c92141424227fd93c2067f8a3d29ea2bc2defd34941d170f4121d3580608638db441a80f12f9080e656137cccc4f862001478e29885fb72ab1a9b60ff1590e116bb82d6e55e9e64bc94393ae7893087f0dcf86ee21970c74be6d3b04e053bfb0d9bdf206f478e0ca4146315dccba465ceb44952de7a636f2b66256227af6424b52acd9aab4ed584706b01e5d224a7e33c10b8780efe1f68fcfdbe54239daffc4d8c4fb4406f8725314c52fdb0b57e495f48f86d44f594dc1f7341c0f762baa8e203c5e4b90eb1045711c8a85de4b5577d4ef1051ffb2634910de81dc29a1e9ce25296dc4598e53901f9cc646ae5b36e19b20b4b8ff0f506e2e1a87b18ba725c6387f24eeadbacc0abed7c1d085228c04b0832226db78bd1d3b06e7e906d547978fd4574045ec3b73ba88a23f2a8a3267df70f902c6e7a169c9f48fa98266c02660e81d4bc31f1dfa5fd749a484bfb00a02a094aa2050a401eca45662690e479fb97a1f82246ca941819b403b0f617ae7e3f703d8f1f3a90fa990a7b4bcfa6bb40ab5073230724d48ac8b46edc937f1d81d9a1faeb015eda37193aa6cd65062b5111b41731a5271146811000afdcb7378d0ad2ada08c172bcd8ea230a833e7ad82403883be02bf8980c1b149f0ffe7ecb70001f73129ff58f07e1994fe64f839b000662a7b80e271ff5e2f2f54d04094bb579bb57f0d922503ea7c33cdcd1c057023ec80d713bdbcd71fa2ea486d176b6c5eac09f32a32128d96f75aaac14bf251014aa2c58667ac76ee26a2c4a7c27d726b4279a05124418352e92d9e164b1b5e6afb7546926c4991963a3fda9d02d8d54c5a4d87c7181fd96133aa420fa37e92202b9c19fbeb1260bf14394a7b3b439c6f0d54796026e3e9cb4639f50aebe879ce451d76343d8f484441f30b9ee55734e2397105c0ec76b4d4b49d3e6e6b7aca251dacad5e0bbbbbf98e02e0b92acd9201466c9c925899f65cc3630a7bd7fe0851463d0033f05bb3da9dd08e9425657d49644c49d75ed76f9ac34535d89fdde2876ee0260fd945afb2ac2970729975c88c550983c2cd673fce73679d6be8a2fb7ddceb81f91c0cc6c1e8ac998863d43c89474e80ed1d0b6ffe8f88a77a88092c77c5879fccd85cc9894ee0ace7632ecaaeadfa10df9966464da6b8e652fcf0998453293818c997338346e5f224377a0c30873557e08775e7aeb64572642705c3670114008629a6dc3dfd1dd90fb3925664870451ba3879f835adec8a36027be556d13812974ab77718eb9bb9d182fb6ee08dcc58f0cf85ee89c8191182627f66176077419f71f03f76fbb2b059e9cfea75915fbf59e50305e62b4b0852595543b43b2d25f59db03259561807eef3b79a3869afbd0bf0ae3ddb3bd67528ffa6016fc9947d93ea6c86909b06fc5713071c9ab405b3686894ea0c9224f615e70c11b88be92f0973a6e9f7da37337e1db880a2dfc397dedb49fc775f1469fa50a4a2e665a05ad77573d0b408a117421d655691ced9bd3f8a546777b9bde455a0aec95c4e82fd63ed3c1b1cf9e8492b2db9fd1e9bbcc428deef668a446d8e317676b8070501975e36151319bdaaf7d00596c7a09aba0ca4458afe6a0ac44467fae70602a4afd0186789fd809b9c6103792db1cebad2f4bfcaf2ecd1dc21608883b9f0936445e686d4fcaa52918722ce9e789241bc7e9b0bf467fcb56bf8d9775562b0382e5b6a870ee801d3f04167953e52c31f8c6abe206d309461c1d138527e4732602e716dcfcf09164508527f9759685765ee737dd79dfdb3b78d6c4951019c68525dd6ef45fc4a66f8e866a231f5300edbaa9fc5b73c7ae325cd5f4c33b433c83564b2d9bc0d7872f815ced20ec0d110d7f5d31f47bd6fa99933b0f9ef339176a4dcc997dc0b0ccfb39a3ebf785b8012cead1e5dea3cddcd95a52c8fc64e8a13f6ab2b212544b0e6a3db5d50fbedd7f3470fbfa8de7c0e6147b72a0cdb8496e3ef2bcb43f3201879d9460fcfcd94eb224d25544dab9af9a4829fb843367bc82e4d824d42725ad55e86cc718be081c9dfb218ed7b5a5053eba2b2b9a71dc0300eae6c624b169e80c1443779a51e21e453e7cef990585c100ca5c3312ab4d63d8cfa9cb93b3cd30636ca731c4f6a75dd07ee05c84a700d206861b521f4fc36dfe03c902cb625ca344b0a4c27885c6c354198191039ed42a0ec4d92324bafe0ccc0d9c995922a73d3410d5028c0f9b544bb98151f76f83f63328b05fd37163e22816c0d96e684aa021933822d2498bae8194beb671b72bc2d40d41f322fd798551e3f5bfa34f3f47090cd768fdd62d97d77ba93a925fd791808efc60ae4a66389a03d63ac9c46c4371eef4462c1d9dfbfc0355bfb0781f4712afcc2129b7cf712e88910c29e162e7a1c2a9bd8b34f3de1da4c3eac8d8ba980d825d2304c19d1992bacb34ec5f2aa65e89a429b5b90a83efd5d2e98d48e30a6e3a9de35ca1c78bea3d7743e12a2284b013724a27959089a43bf1619a84b925a14f5026c6ac01964d2d7b6545ccd9bc6fd428b4784324ca4485d0dc79e653e51f90129ec7dce1543a85bef34a3a1bc4ebc42fce21a73ac44a481d5fc702a96967165adc31d0aab1b94b5bdbb11aae926192db7aad1f93eb05555be91b062638c475d00387c7df53e86e21cd475bd0e0142acd902ee36205d7abbb507d0362a93a6b411e737e4daa38415c3501b16be4a4b88d8b8e63b88c5675ba2fbe507713a29a5cf773eda9cf09f8930c58b7dbcaf5fb052e0685e94dc94ec8302d7a52c195e160b9790b333eff80b7b2dac83b1423bc6d3cc9fbecc53c163fa1b0f3617f70f44d9e868ab0d7ee247ede4e603c10c1b8554585b948a98e6a7c1b043e1676ad324250557866c29f796f1d2c59f6dd155c07e4919a67ef10503bec1d781d1c02cd1975758aa82e2fee1b1c000ca07891e1a35a2b126582bc268c4f8ee778d3cacbeced64f73e2337e738bec257797c849214c0cf2aae8fa712169ff8b99b683f32937ad213dac580aeaf05e9e811fd271d07838842da4ef9fde02091b38c94efb10626381197e9ad26811ec1882d0ed929108583feb93336d29b66720219b7f36a42afcc4693e6254def174beb123e30aa7b53eeb8aff739148bae066eee0d861a956038161e970023bde6088db019feba2c445e59c28cdd15d53baf1cc8bc555046945c2523bede163f339f452d70aba444ba0eaa83515a011f481f275f6bcc68f48612554fc90f0406ec43da197721b15313004e4f84cc363ce2136041fa0c22dbaba5d69ca1620cc5d77faf4de1a30af189ead26e5514a672fbe2348949019a6d3a9fbf31c14c60815206e2ed70f9c0b403b5cfb1ae1e2887faae7df0b5e2d687a4dd870d491b9afba1378cf43be3626aa0e6fb40665a3dc00c372ecea3c4f21ff1033ff9a018b91ca8bd1e0ced23bdee0fc99b5e57ac866893a0c5bb3be23b0123586407b8e4e0a739db68b7a5dc1059d940ed5812a537e0e436872afcf57eaae2be02c533bebe8221e60808a79e0843893df846deedebf6eeec3318c535b22ef08d10122d1a1135815f5d552de6d98957e2ea1507e5f2969fb630bc2543d6c940e3cffe5e2aa0bbaa36ab565a4df335954177cd2c4c4cf6b8fc60972b8057fbc3002166ad7e97cf8bb98272fb64e85d08be2f96af68eea339f13ce3c1f91c1c4a47a26e4de989e4ee2ba05ebab84e6363cec49c85921ebf38cbdf30082e74827b8dde449c304489be5a14994274cf4ba821a10db41cb554520a093b6c052eb704bd24841c8d19c2fd3c4e00d7157273852339e7e2dc9a700cbf34bb6c3532bd2f8e9dacbda88318bb02c98f324e129a1bbcdb22164bb3163b559e6b43d80019881f6df776c7586d8bd8743a360c6091353f7ae6bda985852a156932c24920580ef4000939862b24ea875dfba90272006694d0ba43ca3b3fd7b972844df98ae3eabff7eeebe5b131c5e719f361a5e4b72884968481b10ab3e726eb2f154e0d133085a407c660e6bce3122a75571992ceb13775b21200aa9a0e618109a855c0f4719f5059f4a6e589ba5baab4c032be6f0cf299542c03a7499197dee63377055528827ffbac57d8edd0aa75d74633b1ed8378c27c2688d5321e998623977953a8fc4897dd4da2fd03800b55967a752cb84ff64c9754c4ac1b98f682d6c20f4fb705555d377ba9bd821c69ad5fd3891e552d945c5c2f5a5f93b7a408ac8fb119e2a988bd47b9c399bfa440cfc46ec5e397b8399edec392eb8367be653183ef170cf60783b7da2bc321c729e1bc79f16021423768db5a824a0606d7abb63b5947433c26781b90d7f335bea71c2dd598585fa90aa14e139fa920d634f8235fe24547f3a4dbe599c260af2934eecbaa986cdc67bce98f6ec80f690eee12635706f8c085a570595dea5442b81b08125cf95c56da67c481fd1253179d5b981396ac257c7fd673a08678ad75bb77ced42aaa87db705c17ed568b33ebc883261c08015ee5eb06b42df588284d9df3188839630140d56a78443672faea3928a031a610c77b4569d606e08075e4a797ff026e3eb450929f7d03c554f58a739162c8b5ac4163252cc45c5779dabdd5b4eaa5067671b66242e6416019f6f9d452a517325add9ea18cebd191c69aa739d55ec95b211e1cf58af7ac6c07d302a375218c6ca21462b84e314837266fcd318ea63f01bd1362684181453e3f6851d310b87f328c213bec615715996649a5ab0e144d401bd596f5fe619a213d675aa1ef3d6cf45d9b323dcd57270f690c5b71a276a234612ff94a27e99b607e25eb019e52479476c1e936c471fe0b40a55bff2ca1848c97cf1d64570940ea3ecd4050ef7bc94b841e4b3dbe75795cd486d328b50114cc9b0a3497144b8d986b3fb34d6b4abfc70b00d9179f4cec367ff1c0fdbcb7b360d61b22d4a9b2bd9d176277702321eb392905a8f2350483bb7a8dc9e080bf893f957bdbc571f2097345796f6a821fa5c235d6feecedf21035c6259e4e683220fc42f3864a12876a29e658464c26aef63f9b1963eafe76e17563840706621fdc3e9ca02d1bd5b27150d1a4a23e66dcf96eb2a9c7c66a2af5097857ab88aa3eaafb9f47ed5edb8c689321ba5713a993d22de44ca1b651431120089bb6b3548ae0f54949431c06b21be578870fa81d7f4ea9aa59bfffb7a9183886cea56d2238b7efecf6f979fcfbb02b543f26e69c9a6b833bfee247322598232548229e33bfb57eeb06ad7952b669505520e3b8f11c3d2011adf5b056b78ec208f44531993ff71996e8afdb0a0a75ee2327aa161bf5a6ed9ddb4e54104cf234a173995df993c71eebbf5b98a0db90b98a6a18aa37a5e7754c4801cd93c3b1b69a8875fe29c475dfbfd6474997f7ecff92b16d3f9af919892658d5b1aa470bedaf92e6c2900c354f68121d22a2a18212cb4b210d4674d89a670f4289b7686e8f6021c16e66ffb04f596f9ff72cb4b57f024e369b1e5ac7939c3bd797bbe4ba57edfd501fbf8d61436a6b35b303e483cbbc52a9332ab62f9b888ddca51cf135dc3dfadb53634d76c2966673b986574a582e21c2a156d029ddd228d5fef9384186dfd2031070dfc7df82258278e65d5bbca2b71c11fccfe98729348979cc37575392bd0701e4a408ba393c5d3c509dce23256ae88b14553e0233f7ca52fb941a2149ef0eb4c44ce815ec9eb392f68b849e2a0566362d3c45d0536916adfccfe85caeec2c8e283785e2ef80457f3f619042a91e5e097da282fa380ccbcec7d7eda023d39b3b9bad344563794d001384b17076678bd3e3b14e16ea46d2e3f376492c71b81de7cc4558845d4177607c19a108bb78ad03fceea1ea5ae6904ae18b96189522413c074587bb72a910852689236f9e7a6475748ce00cf3cc1f8cbca309425eb6fe2d6aa457446e9bcf9b9d745597a261ac98153a573c3f7b066d8ae969d184d67cff9d7bf39651a020e4b382d985611807a9271397f5b17ba4ebd233de28e81a7e8973fe17e589aef09f22cafd7a27ddf27159c197085c695224d4eb2fbeced98fa7f6bf88392e21aba9c992b9e9b75d557e4ef99fa84461aaca430fe90f7d35a4b78952ee488e7c7dbf2d9c35973435648e45e872326a9bb8c05b0f8cb305a5e6b0db7212f18d61ac50c4e25fbe31bbae9af077b435d6bca9fad3f7d403d713b49e7c1af1019692cb7027c565e3619f7564570b67bc559c4ef013450f9d74d47bcc6ce0357e85e87047d804f4087c1132fdfda17a07ab278b79681a383f84619a6de1aa732b797ed49c00329cf26ac4a3e49b934f24892408da4e36eb30dbafc98e11325983ebdb21e6acb6897e63b83ad430fa2a0b86374a3ea3cd4c52da902b68be399de6aef1e41792a3d7813947cf285cb02d4a755a3a307e39d7ec7581f13ca91a561e6ddbb38e74628c5b3238ea2b1d2dd620612e590a4986c3627549a0431282965c8f9f9e0c0a1c712ff75f15b2bae8d1b8ed9ae97942ac32c3a20857a397de6cda8b3e1f51a6866f30bef135174a05001071e1af04e4f77cd1354d6b2668cab081c645e5ca45d1a32f10a53ccaade93a8c932a13f6ac8e7e6af1b79e20487393b38fddd785b67590c8ffef29947173049003c63b2253131d948f0afa80fcbc0df60a56537f3510231dfa74c53d3b45795a18cc9ac821b0f4858068b4cdd59e681b9aeca6f13eb90a473f3dad51b2e4cde81e6f5721b1ee2459f797ef7eb833c1a41abc910469f0ff2983c879442e7d57be2fa234691bf2f37291758607341298eaec07958538f5fcf5beca86c29e5f8c1118baff2d32ae66b201f9c82c1643f0bace81be8614f73f65cd535496e63f5e225cb0da74668cca8fc9820ddf6208b2b1bacb99863b5fe83b92aad961d26f98e9016acb67cbd03da1e9f16391668bb7223e4c3de273584b94c21c3fe7bb4c55b3015da71aa06709d34e3e538ed655ca0f132b4fcb582d7612dd4934a5d3faf551ed520af38cc0fc766fb3a024f298d0bf6f1a73017a5c95b93b4b15e25cf349d2c081c9b78adee5f2d43b990cde3453c42471e7b41d17d3fcc9b6f970fecb31156fce45cd5ad385636d25c0d786af93b6dba0c6f99a9d97bf84f829499613a02ec95184f1efaecf220da9652fcdfe5421c9153f3188d802380e253a380237b1ea2ab28a799f12181153f3bb64bd5ae4bc9c4c76b030af52b4f490e924a42bd786be614ca12079f45a9796f88fbe2bc018f8136714e180b5ac706a2287ea8494da48e44f0d4892389e0cc0f972dbef5489aeb04247b7588c21813e45d104461e0cef4d75293d5693885ad8377aae9dbea599d29313737dd889627c79ada0903db3f80d9dbcdc5aeb7cb54af27d1bbe35343a0fcce80cd520624d897c889bdc6395a7b46f21705fd336f98d58f8b1c9f618fa4256725897a551971af51dc7547d57aaa402b4922ecd4637a689d919052a3f1dccff0db846d6655ea07d7ed9b240d0f8fdf2fe6c2817a5e6b6bcc8e2ff9f0c3dbded69b22b39c449b26079bac319365c565b44487b9925593a8e6cfff48810aa4d1a577d4ec9f859111317ba83ddbaa2934d9cdf34e3bad5bfc4196914a3e9056017fe1a3c0db5a9efff9f70a1ed4b925845a9c3c6e484c357a93c6cd3bb0fc3014657ca012f7d7b557b364abb817a3d07b17ddb46572453da7a74f8bec7de95b79827d2821450f6d8f137aa846522ce139518c7b7b9973dccaab2f13cd8c307c67110181f7e4f25636a97baba55e2f47994d61fe8840a984db270c44695647dcba8c671c57b657c8325678cbd834021e95ff7ecb05f91003f6e395d882a905fb1f8b04339c1b51ae836b08e5f20d0cee675447d6d59ff77f9df208d9074d8e15f2919a63682656464a28df59e5d7abe3efa2ff3442bc442ee10ff0036219cd7ccddda1d2cf7ae8a52ba6003a608cf468df79988a6a435e21f965c8ed9cd8e4a99143d548f34e256b202eb5e8840e882161855c05d2e18660d456b4fa9930908890f0902a9f696a2c0b88eabdeed66660ff67d5034c0d0103a28c57b3b60fc4409acece19b2cf44e694f44446e1651b8a61ea9ff181c994f4ca13c2fc02d0608d6a53f0dccd7a20a40267d36a46562d1deb64c4ddcffd616c7c51a5c436b2668718dce279a849b6812c8c1dc635cba28a525bfbfd68804893b4176d5b9f2b4bd4a466059fb41931f9e7fddd4ea0413e0b1e713c0f67fc1b74b092aa4dc81d718ef43792a8ef0e72fa00cac71e1b103d3f2807ec9cff295c1de59cf7a3691cc5777da483976be17530d8e5f2c87e9354118ef5f8d8f11b9410e402fa4ef2a687830619dc83f549d8800bdfc97330109d207aded9d0b187bdc197c25855f17b3b9cfff1feedc4307377e6d21208d7da049de660aee4b4d2a9e381b90a29ccec29132193175d94f1279a214e7fa70a4960c93773b0aa70a5c6cff99586947b8054a201b4d2827654935b101116fdea8a255f295ea3b4c9383bb400bb175da2707c801d67636cb1ed7fbebad9e70935f6f1ac307e3b87ef23c9bb043ab32aafff59b993652a3699281f961a407bedf9c1005dd4950184ff36f7c40619747790e2221b7e55e341c2e90b51eda2d2fc627af597b4c5f3b056dab1616e196aec16486e0a5f79f378c415230a63ff07e5f0869b7eff14a49632c020ad2ec1c1eb677108132f60f045d1caf329e5d729e548c45b4223506ad868f0ef0c69ae8256a9595344ee06bb2617e35f9aea16889495fde61fed375ed17ce5da53a89b583d0c3c4b313b3640a9d323ecf8930c36f7e5be4eeeb4c118856b576334730e5125edf2b42e6bb8c6c97452cf8ac7eb5891ac29677b931d05d1447218d42fbc12f32f9eca0d055d4930c3571f5cbc2ab2740af7807fc8aba07eb466718cc7bba3df4601ed70aa5cf0156c43edcb838d0bc0d1743cae9c06a2889b7e5017227b83092721064b36440227438ebbca3a301d9131f1766bf0d88b1f44dacc15c8b9718101d992ceda1aafd9af8533d9929824d1e55f425d6777b49e1e309f21ab3339098ddf09b724800259028390064406991d9369fed8430a79f80bcb3b88c4d7dd708701c5e40a730136615a40187f763868a08801546397b07a5e2cc395b32196b32ddd994c002db132541f40c8b731fd9273ec1ec08c5dabecb0fed4daa5d9e4b8a7d1c764eb4904cd851d7b821e9a6a431a11537dcf56e540b468b3ff9498ebd1d55223e4a7fadba1e23f41afe9e3b8243b7dec54aedb562ac472fa3965fba3bb46ce0146a07cdb4479a92be9c8cce8335ba869df6d16d2dc70c9ba658a0c4f7bc68a88c951a22836f45af63deed5533eea6cc0f1fb11752d14765b0956747c690939b417e26cbe8395c82367d12945cf0744a8d5c66888d5fb061d39be94c1d6872d0877decf1217924d2ee2261c86d940b21f24cbe63be026f6f7bd2447ece99c7790bbd01a0f758bd8062c30d35271a81925e23c8c7e93499085b70853bfc7335b0505199db76581dfe8775ac2457b197413b7464ae4658cd366c994d801612e2b115ac2d4f56baf7c4a739ceaa131c4ec2ccb4bc2a4c6a21fa780f13f011ca9d3ff2a8f3263e76dd5bf61e99d532343f77f897f1bbc48b4e25bbe2d8300e52dc6825deaf9e7042faca94a665d0f7e1ff13a929c495ffe19cb2362ab7355af06b5f7fdf9e7229ac2b8a70f048df9982d50444e18321de4b29aa5367d2f26a5d00b460973823a24b37d12e827b8007957033fc397f47835b48d7fcdf4e54d70fae16e6ae2333d737e20890a3c2641dfa9e42092150bd0d86259ec80d21600a6df6016c6de5249730c760d3ae8e2532029340d15de6e43300d3a6a3094b92e75e840745d7ea7f8151a6025eb0311070f42f3661a9072af30a8473df9dfa8039401e5a58c45b674e67bc62d30c91a93105419693ea09f9ccb687c6a8d0a2089de1ebbf647cd362aa95b675d823978a26e5fb54b5aba327b378d4877d0d087fc22ebb0afd1c2f7e8cd25d8acf7773955e44d9369933538c8cf82b0009d8e4c6f428100a92bd0540c088f38394f08845d847f7b2cac3b026d2fe1af86e9d68678d617cb858f10095c1c6bf1a1b6a465f7d2b39ed4e553691b24c36a59dec39e84525c8a2358900f7de3f635a773c4efefd50982362d5f2b6c2e934033a1813ac3946cb9f3d1489da5eb72314a69155170b29a79716e20c3bc175336dced1f77de3c8255e0f01f3d8d25bffafd9ded813c7c3d1636ae086a0c5b844dc6816d45071a76ab252a58435b345ee63c0238c47a08994031c7d73247bbc9d4110c2cb50dabbdecaf32807ae8a55ee4b9f2fcec202e7cf3f8ed617f445ed6c1f4fe99ba89ba3b4303a4031d9ddbe39d9f6ad70574987458bd31e18dc79f29591534ff8daac6f92d075a8d76658d1d5c2177db4db690bed3b7f26e6e90c6e426a46ff624c4b5c3855bcd6b3179aac5d359623811418bc0a7556d78bb90fb50bacd1869b24f9ee03c0d53d28fa7ac5377ade79f3879d19273108922a0c25005fa1dd6f191e63de0a773895d01405676172a39b1111075d7b1e322306ff86e46f6594075688f0ccedc3cba50033910c546369102c121796a294e5e79a1e24266136a31245eee7bcc1d4a6cc4ff1a5826c2f53763835ddd31856686bec4d8648cdbb9a3638f77be54ff4bf40e47c69437ab556c432f94d6f2c46aecf7bf60adf3ea911f080a16b2ba95969e003cf10ab86e132f669f5fa2f932245c9995033a30cf98a90b3c48bc983dff9f6944d7a42c715cfd99eb0a453958980ca389447d5eaa5a8291265726388c67977a705d367f8baad25b0763ed95e5394f459b84df6ae55ececb8607edd05ea51f2cfc61fe404b8213584f36656a3c5e69707b9c1d7fb183e7d75c3e991d091057ff2ba","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
