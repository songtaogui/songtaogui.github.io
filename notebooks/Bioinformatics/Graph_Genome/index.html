<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74923b60f65aff0452b6da6a99b7259556bd55f12a5220ce94ace77dc4b71e10f6bc4eceac8fb78da67cb3d67bc64511dc794e2ff3972115c7474b8c59a406487ae4906e9023a483f2ff5c3e0b9edc6e1a991674de07653cf3b346abdfe1c84af00dce797ca00aea5280c2284cbbc40905c4bd2cbbdf02a70e6c53c326be2da6feab6773110d2df4fd458433fa933d5b1fb247c2f751f72f4b04f308d293440d55886b100e0bfa0be0d30127f65a994ab67178c3fd235b2ac60cd8c974bb0f2c25ee82687714c9c8d1b0d512d861920f4e550f04ce417d7d9f79e83272bf92331a5b5b2b66ec2f2465da49122dc2e443f1297a7130d86b9f13738f37cdc253cdb4af5979ac212ced4ba9fde151d1f852f393b4289028b8a0e6dec7745e5d3d3b6cfd227b5074649e59c9b5d18a6d46fd32618fe9afebead9e8391543bc27c1efb0d0c9deea09b85ce2a37ef656993ed5fa3d87585d5d1017d2552700a0bc6c5ac21e5aa67502945218798774777a02b1e2e2c3da334131be009856f84d0ed2d6ae01085fea3cbcd820a4dddca5603f543d1056c2a2fd9b589884e03ec207db540b3eb2a0602fc6f5d5680180832935c100ff610514d97dcc5d31517aa3febc87da3e91813feb75d2bc663b8c8216b68df86e5df5cda77491d48de5958c6565bd24cbcaf4ac24a99c778ef2057e1a5cca9d79c54416351d494743be79554eb8b8aeca02cd3e9fa79ed510d4e2fde7002d3e63dba65e2cacdb259c618ba3982eace249176a76ae44d5706c2764f9fea6ebf9c1d1494bf99f38d86c87f1afd3fed3c0e4e51eb7fe9f2de0373b7ef051ec7813107a49ab23640ac7dbbaebb426b5e86a71eee0d3009c15c1bde01950f9159e02e2ba4dd0e854b5294827d87c7dd0d2f619a90e318f4fb1daf50b42da33861011015b40d9add8765df21cac50ca4d95f7ffb2be98979c6351bc0b21bfc798155fd014835253527d775116c866c6472db5adfa0a12f58ac10502b3327200a7d2dbc8db17afa615aa56b1f03d87969fb54b3dfb3639766125e3cef143a00b3ff208dddd77eb88e27cf762b7be8e8e42388e0d817e58173021873c3e3f6b86b5d7fcc959079955ace0d01b1991bf002ab94e17637417ee89ed21e8c799065c8e6812e57bd91a94356b0d7740a7365c78c31b085dfea5ca1161a7682824fd177349f0f41bf960cd0ddc3f9afd15fe4decf301af0e12c4fb5a324ac51efc997863c1301c6b8452ba6f4b1ce555e7bf9d2740679499039e324dba4777e57bceff40eec2b3f5cc5e04ed4aa254737dee4e67b36e3afd3a004435ee5d6e1b5417286aa155a70075448419708d1b5cb67e86be199cef8aada7b4347300a876b59bba4250dac104df74c6079ee59ba686b7010274b252e13c191394ef2cf653ea86ed560d31869ba61d746c77766aab7b54f207ce4ffe91d4a53ce9d17f7d7213a4436aa96e35c4d131ff9a05585d3da221db8e26c71239d2ce1aa1b948c629f06a351c42c6fc572aff2ea8172312e5839f35b5067ff95423083a1ffba341b2c9d6602e18a60232c4f2e57187c7754f9d454aaad9fa70ccc231395596c12bb8a3a9896a60bb1446025122010f9d97e3295d4fc73673a5e8db04c47fb2c9259423721a4092025fe73b313c9a52d9620e58321d4bc6fb1b3dcb24133dde53e5a2aef628dc42f059f25abd527c4090cf71d41d6c6353ab4b50ff725035d0452499e1ada44851cf04f950156a88a7872eeb5ab4979e32bb911ea3b0bbc01ce5c0de50cee7955fe5855d0468bbc5388e7e52aca9867bdfeec548d87777393f01eb65d407b55e608e13dd9126e742f087eb89155e89140fc2f3c7c268e72e596ad4b33c37e5e3779145fb48612bd3522d920afe880332c83a4459c6bc85b3e803dfa5caeb15455b206b9d5d97fa4122a89b6f0b4121e70feaa669341bdff66f3f1770194eaedbaa00538907d0ffbef89c1bb0addfce594adabf4a3def15f5977f96e7a43fa6abebbec716c439677ae3a95e9f563258356f253b18e33ad01c37dc00930c30c7d95256b4de1615cb52143fc2ccffc6d0b1f5ff8c800ed75763c866302a4c995fa35283b68a6ac4fa8990106994bf332823f7f9d6e8e579ff1ea41734fc8043d7da5846be3500bdc51007c0658db873ab73716f2cc20b5180c5303252b36cc3f28c8b131ba61313bfb70a71affb4e0567cba02ff5fb006de8de68c9d17b3b8f080e189e3bafbcbf9be23c3d4665336cbab802021a10625cb6c1541a769bdb214cff1eaf6942159d38fc4a92c85dd6cb8bbca95d12005e6025b9b799af410050cded8f9a92a343b86bd8334030d9851e96440f7b2cb729793779e665c27078d52f87b81c6f3ae0aa6989e047b71bd9f56c7d3832ba01a464426ed69d97abecec4de7c2ce4911374a14f32564d5e459533ef1766fbd72ebeaea7ae9bd05556d55ecf8ceec44bc6b25c61148daeafe4ecaabb614a55af32edf5516b58930edfd3f3ccd762531ec041bfb886aa5ee185a0218bcffc054a75938431c22495a2828170cfd29d51ca7d022a920042a82f67a1a291bd7f2ad0190bba286c23398b6e46cb87caf1969a67a4e1435f3c84b9419d7e8d03ed9ebd2e40a023805bf779b9fc4a86aa7c2f7c7a15c1403f4bcb2e591224d3adcdf89405dccc939d7cd35567851276596aa134f3218ffd5b41279cf3feb6a2131bb8ca980b8ba79320f71c6c940482041a3f904d300e6c3907723d296d2d6bdfbcd20e7641382461004da7f1e449396abd4119c90af6550cbcc5713cb346d446cd84bdc97b5fd0ce0aba0d1a308fe27fcfe0f4d4e234c4576179f5bf32acddd85cf419478bc874682ab34fdc8f8d5ec23940f9d2b0251c51bfafaf92d30eddbfdefade2c3f2599da96f3cca1ed5e5d088bd86c002f6195c773aedf1cbabc52f20c9c06d0c81d1de8767af79a1a0e21fc1da34525d8f70078add3c4d0665e04a447e2cf9d6a6028d17e2fce9485580b54e9ca3c78b2c7316e841bb1c163271dbcf65c678765817852c4a8ff879743ebb4206f3c6f9c433be07cdde579fe0b222dcfad7c6ab60f66506b06b7c93a565a9b83f565f0002c435c60d97afeea82ad0c1bd1b5444319e733a0d8b1344c3799cb4dfb0e559c0778968a7ad01321acdaf4ae1916709daafe56ce645523b36a1caf0ec9d0f5ffcc2e8d541a8e976bf2bceae2fc6e35f862675635eabb5e3c743cebe3e873bf838d8f7cfde2713f7383ce666fb03348d7547f7a7d4bc741cedd292a7bb9d807643c3ed835e34042fef4a7963b5e7d3f62c635e5222660f0b0b6e51102a6c97824d12bb141024d6b12e9d7e0c5d95dd66488fd13089634e60b98ec31727e7be95cf5328f5e72fa786c2d1b10556cb6174a66f9aba8d86184e9d65fc14282fa6a3eed08a1811dc35a386eb11b42dc1424635d945d53e3fe81195d19789291b77e11c42a151a8afb8cdcf0f69e61d516d258a694fdcc80e7e3d90c08e2c650be92760c7709f452e548f385a72a0fc3f26432556dda02dade802cfa50ddd11de4ec4e5ed202316a30543e4551c26b52cd7fb17a5975ffcdb04c71a327c157cd26b1ef8585573fee6dfff2dde83e705c0e3e43ff955dd6c7ba564651df01567773554e53b7d9065f133058a8a734d4897673637a6ffd2539b41d5b94c69e2b66d74f8caccae14b46a906c40600d3b4e76d2125aced7c7d587391dbab3a1c83281290e0424038039e06c7f238c8a41c7256ce181a927630db45f74a625c235436cfcacd34d6bd60388ac098058c5b12e6519454ef7fc49539f3e0c2aeea6be8533dee6213c7dc3ad4af237cf7906ca93eae825b26b6929c5e87cce9d83d69222f7c58c085c588b9d8829ff28fcc77a4b0d3d1b7e5c812b38ebe45f06788e81ac98f97b472c12d9ef562e0c47447929632c048df295e6e0a3e7fcf112790961ba4cd3736c413ddf7cf42f3c36b4d2608c58d0d3789d88d0049c59d75a02c3ec0078ea3b581bc878a6283f0ebf281233c398819940ed92e263dd63aee6e634cddcf532d39ea07892902a5c384efdebd6238e2d50aa86b7855e6ff8e79541611d6b77f313fd28d7fa9c6919a29b24fe094bef600a1767fa226f9e25e538d71c960155f1372abff83ebb04fae914f3099690a60ec44ba4dd7a7feb17971eaa54cdd6b6533c86ab1bd8f405171db7cb427086d060db8b6082b08a34134b3b08ae96623aafec79aee7693b012b60236b2b2242e81707bfbc17e3bb95a2f431b008493a8cfaafec267231c844cab3229efd39905b54c5335f940bbd22078d4341d4aa88fa3a69486b48f4eb43093ab361c1b0fed1683beaef4d2df35c055b69c1628b7efce358da4d6bbbacd1af63d2db686f457937c42b88c7a5a95bfe1bcc038e91428bf470b5ae82adc45192374ca18ce36cf917353fa1e127636dbe28231c3f6da5152ce74ba3feadd9a4c430b61b86f4cf556a53f89548e299c962dad3e04afc7cd3b3f0dadf367e53d4a129d9c2aab94f1095a9ec692fd9a9091e7a437295b52927f10640ebf99ca32451fd4741b353787d76af76184ecebe733fc1b76e70de47b3e20dda9cdd2cc22da7dda7885f6fad37885fba8b072ff7558eec6ef01286a7de6972652c56271b52cce7c682a03f1860262337c92f03723bb81e708dc0febdd378b4a3ccfcc3dedefa216b64c636aaee25d70e5be30d45c7351a3a53b19b3339084b372779d3aee957fa3cc42e466d12ffd4bd310e9bf35fa5da62e17f16ef6eb13459782c67247ed83039dbb230747f73643d66f80a387f1d865c320b83f550c44c29d82646c6bc65e7f0eb80bef9889bda27a48f935ff935c1ad03fe0bd8637550e16c0ac3dfa3ad3d98baf4c0473439ed52426d485a94a363279ca330c9abbb3d254369ccd17b2a918e6d4c1804c06586b7bfefb33e624e95bac31f336240a7f4bd69644850470000976dd46cb28daf4ffc2b53eb58eb9d7bdc6d714151d7eb6b2f15f6dbfa8d0781b7632a01a8ff6a6db73b35c44c9632d08d29308c4bf909143879c68eccb7900c5475e8b0cd0bd5a0de1c4211b02a5d30fd684f8cc22f57cb8dbca1ce2a2b097db75e5214d5cbb5ad441c277afd18981527e08745069bd6f902915eafae8f5793f27d51b1a5c5af2d590b47254c2d3c3448de1b8cf5c77f8109952b49ffcadf2fd08b4ff7e02413d76d4e6e7325544544ed89dd5e085a236ccb7604eaa5142cdbd167d7ca532c1dddbc748f5e7cf200e542ef96b7e9df531c87bc017120e113ac780790e2aab8d31964e5d1d1bffb952d1e7edf72b98e82288b63ce4b56b8fc5f151c11fab54d0461adb754a210a850d40e612624bfb72b6215710fdb181870bd27875100931a167b8deeb37c4e9fb1cf09c19157638a51efa4027b5a8b2df470570fc2999dfd6289d2e0f9ae34299dcd684ae767807f19399cbf91619d8e8df46addd4bf8f52293545b8e0f1c431f65b3ba3d9c9cfea9c230f23a01987256aa059b90dcaddf8eea7f230230b0d8099ad2e47fe3031d16ff1d35d345db4b22ff24878f9bb6f7c12a643a58ec65cc60f8746efdaf388896a4405f3ef62b187cb7dcc4d5960fdec720da1c62de93a9ecc518c363b66176681ce46d7f34bb0929c666e01de21be0d7513cbfd1a677fa5ec52c51ee493b2f68675f3f1866d0de6d580c581129c3c36b339bc7eaeff2605b06dc379f48a498f049eac7c6bb11d1caff8882e9dd6ef7c4d5cc9827055dca0bb3e54ebaaa1d4e40f80661c57092d20a7b2e51b620cddc02acacc8aeb5c1c178b7fac4a1417bd121351a1df9989d8d54709bd5b45e10c1b2d556dca26d0a7375ba9b5b3cbcd68823f758dfb500de2c6333d54d2bb79cb7b6bcd6053d43e273a2cd6aa27bcaa9ffe7d85dfb63c289fdefdf26cf452f3f25ea6d9c44366c17debb24cc7832832006d9512768f4fbf19523affb63b4b8eb7f44189a47dd21dab79c8e82900be8e662567853cabbb6c682340a1b23b0809d48ab560430749e6a399595dbcaaa49e59a7c58bff5d368a0681570bfa7a287016ed8fa4fe99f4ded08164694ce4c95284d45de5241d6c71a560a6f8cf03045681820ccf041a7f229461b23857a92fe77e9012426c1e152f2fa4e34a6177235d7f6200ed24977f7684879a5430ef1fd82f841aa2646dc80b4b1d94f604ce79844114d3ffab6d3ee6f451f81a7d64d4e309f3cb1a8ef8f20fefa1f016c364aab99156ac7b2bc89d86ee3aab97dba4cf1b71182f21a1525d5cfabe0c2373938603a575044a8c547337fbbeddf9293f71845e0102e3391380ba00c7ee83eb5228080dd48589c47e3d0c4b7105417fdf4ff7d3b11a0083288c43010015321e4ec54ea3c787bad9f8263841141dc27ea89cadffdc93cc9a0742072b65816ca721ff0ef3ea0ff4c95ed87d7030190d3dadfb8894accb9dadc57ea1e1c08f997fc02855aeda0fe0b048b36a0d3dc20906f2f978972bfa2367a146d7bb013ef5047b8fe22604a54a11078478978c1575136567ae77ee1489c89b4eb9cb570c766dfc7c9220d13dc0525a67c9581de00e96c4f9c5cf2b13a3d3e2f30c27b4031aa25d4aa6b63981b7fc5f9d9395ea6a2e9c69b780a6bb1d982be41a14e795b754493fcd72bf97ab169e6770b3d5e88960c312e0429dd617b49e5684ca4e64a8d33d0b841e8db50e20cec8ea7844a1a37d58108094be1032ccf48140a941d840d6ff5157a973d5410cb1c3a422cfb3feba083cf78ddec98c534095d678a6fda1ca8da4834d67aa28818c4ab8d6eb15638a04cd9cb421f417e87686d656608fd931c26fbb951e5d293462e29ea8eef1b22ba90a6aa259d84b92affc66b8a32a1690ddcd74aa632eedcbbef299dc2f8b9989dc2adab4e47f6966eba1bdf01bd76c4aec87346b390f6275498fa6782b0474cdf44cff5aa41f0d1aa132937a15c8f03221999bae967bc130c506706b008af5846610db77e2c2d58aefcb10c2ff7087b2babe8ee83fda30cf16f1bd407b76df6288d4861c9e69c5319b2a5175cfdb4b0c6ef2ce391c7044e446d79c51dc2de6eab62740d2ecde1a3162f70a955fe9f28f510b8a1b2232dfb8d38b4729ceeafa63dd1adaeae29f1c4bcd1defcfd32eedf73411b61e413e53d9ed73a5c0f789076c37c0a69a2d3e4400ce4dfa25e86a185e4aa5d8db8b1b24a5f6cdcd820e4d6cb1b6932f0b3bace26a89a0177890ecdca20e027736733e607e6f66fd7bbedc41d4de0927a821cc749aab4a0452fa26f1f57808bb2ded3511d592b7ea460346e0edd011d7e15660de116fdc9212e8e0ffdf35be5366f719c6f3d8aa403e39bbfb16ddb04a7c70600a6b566ee6c89c997e96ef842da6e290283384f6d2c500290399b704dbb35c4b989aec27e384611479da7bea447aa215d67def28915e662efbebcc34e8bb8e0ad3d193d27d7ebecdbad1d68c7508cd1dbce2c8327ee05af1c299424b32c204b2229faf4d6ed2f758c17be9811e8b6d3026854a5885a9f28a146b1f69fbc1a9fc7bb226ea1d21aaa85c86c6fccd89c7fca0d796e5df2ed7c421fc8d3a150fd7f4756a111e81943d4300a6f425e579b11669517b91de4d8e8b04e706817f497287f4fc91d3b11ca96d76516e7df9fe056ce91274467dc123bc626b86646e6dca2fa14eb09a1ff8cce3f43764963be9ba6fb4e5f000ad3afd34fbf2aa7f1e954497a38cc55416264af870dae64e01729a5f63878f4e5fb0ccc5967fae2feb9fb0169d3a6a99d7ef75c43e8893faa20ad1bfb909c97c65cea7db8bd512bf1add8d4ab4b201a6ed2112412c02869ea5beffe8d787f343ee7f9d6938b95bf571b59954c2f1142fd403dbf07d3560b34cb1cd661be1640003c58f4fdf557b7ae6084ba5bcb6c644b9c428baef2ca96b0d07c6c611c33492a0767e8a13dccf066df4d856c68a5a552c77f8033ad86076ac637eefae511bdab50995d9fafb2e4ca28cdb672651a247159338727ad3bf5318a4075b16cc1cac5ac9ab85fc6838a5e37555df033632ca80810095dc22bba82c05bcbcc92e4b94a08f9775459875a54eaf4c9c53a2165568e3729e41643e26074bd9b516b9fdc84a5941d45628253ff4186740f116d2454298c5cfc470083d39759bdf080b0163f567ab497e92617e4f197fb9e0e6921e77809f6d8daa866e3c78235bc141fb2eda7800694a4bb0b08d6188409cb5ffd59a12177e0c041c672f3ce8db15ad518aecef2e42c501f04b6c671883049a64ee67048d8a62ef7621798d2db7645c26f583acaeb6b50487243ed842ed89fe75b722b34c2e3690ace9a59e9b47c7e677b7d209210723af19cb7bff382480db0a2fe26efaf185eab21a73eefa23d3bf5a41d2c8443c1317649fe3ddeb5c62727fdfd4e28b281bf8cf535a0b07379f07b84adbf3efc6bb95d9e4ecd40a67a69a4ed208af9818223ab8d9bff4f3332190569de8b6d74525855162907c1d0fb3fc03aebc775f5ea25f82d90efe47c4cabc29b276a16defef686421d3fa230620fcdb603fa83afec9d914aefb3407161820e6b8dc8eb8dde2047c43924d959529c716482fb8b898bac436282c0d48145ecc429c4795a88aa3fea3cdec8ea1521e17b15940c961363370b05c2cc189f4a439a0b23c5e3c83abf043fa70aa87cad4b549b9df916da6f7fb12c9be9c572cdc1edeef83717a0af10e43d4b6fd0fb041fc5dd71ef8c22335c3513f4b49fe7a015d2db6df465122080b8622da820c6ea1a4586489c3324c73b5b59843d975c5c7170d8265130cae88a7b4bbfa407e90f4cfd847e863894256e048d6d83dc88fc54b5b14a8f58ec00d48faa77b2cf1f52d65b775fb47ea083f0a6e3990d20c0634bd41caaf637fc4e7158b7c7a8b5f76ccc20f05eef4708254230f5b798268973995cfc01804d59558c43f80b928e7a56a425b0c01496c48c0a74e022a39d6182bbcec290e8f2398ff73fcecd6b61735748e9b0fba4618f8426c2d75e438232a911072489028d632690ed0bf15ef5153e7e61c2f91fe64059bcb857e2007b2588f9a9b09ed0ceb72ce7bd58398eb98a9df29a837415dc815c25a69b803fb047c8c81e1cce4d56bac9a3d5014062e4a08f98094b41a28f01b637872db520ad869d354876134991ab4275819addca329d8d3f5f10f2e3573dbd90dbcf5580ea310bb6aacf2821b26e3109e70cbecee8a695cee284adc4f58d5191f13314e77b0ab6e601e919fbd177724a3f7dd3e4761ac39c4f4749acbda7a61a425621d8c6d1809ab0912b748fd83334d091ae5652c10e3804d70b81205b998ca13f45f713f78033f53a5f93fb9b24d2029fa22e8d536bf80a2628febd647290c0bd5f4aff8aebad3d8ec234e91060acdd4a5cb043491ac18bfc18f612e65785028bb7fad127a48b1031b0c20e46642d9ec9b1074ee078a3cb1c7f42295bcfe17391bcaf01941159e0a1140acdfd419ab441a5f9c2f1a920d4e9bc1223e65543787e1175184659707d1287c3f9a3b8a3f082fb60354aaeea684c762b3988aca837508f883ff467af0812e4e4edd2228a63bb27c2fda97c997b559c24ac3b582251d199d4344f375c73701a260d6f8f6a2e18df9f039fb517e37e4f417a664a265202ab92841369e2d641b89ae4e6198f8cd1573b8c3b5c7a0ad351a6239d4d42c582e788d736a4a9d9e67618f1856222b96a9edf36c283d7956544705d6118a3cab99f2e2d830484bc7cc14d35db83f142d6039c444e8e6c731c8df512a46ddc6d1ff8e15ef9ca69d2693efeb5098d3941764b2b9da845f475946107c1faaaa1121c40dbea3f38dca601011a10486d1e83a3037ad5c964f28fbbdbb9cb0f0cd86487d61ec2545ead4fc8805dc286c8d174c01ab133935582937376b50c3b1660511a805fee200fc2ea54a2ca11f8e096a1d3886ba2d8674f447574bf8393e67abe103d3eb8e274282bb5fa8e10955eab376d9b3fc27891a5419c502f9ee65b3f009c248899df54d0b9f0bd7ca09cbaede096fa4ca955b3ddeae23880e2695d192a20e3a061a9f8d350201350229868864b21942abdf2899d18965f2a7ae705c719e8a6c8ee8f7c803a1f6552bb97905bd101cb65acffbfb71e50dd0ea3698e4f46f8271eba4c2040796142cd6e4a6a41e87284572e4728bee47638c5c7bb39bb3d75c7e2d0f70e511a59ec47848ea64f2efed08ec75b5e0b2a6adb127a57db606b55c559fd0aaeb212095463753548830ecdd5e094fb90c3053fe66065ddfdd02342f0c98ef86d7a5db2f1d94d3b08af8b9bfd3541523641b02c669c80342818726580ade4d245def4c9cdca9c25525662f9d9564f4b592ee2bebf451fad0ccdd4e39fb5e97c3600cd8db342a37c9b3a1489cb6ce649901106f1e831699cbd5143ff922ef8526d08acbb64291521f50070949c3e12cc5b451d762dafe45c384d9965798e9c874e158cb55aa76e04dba8be610b27214b1492642dbd0a19c2a3f8b7f0d6070b49fd8277211ae6392562fc857ed4b87b5483a010427f60a318f4d549de3dea5ff9111f49682035d036da6d74f1da3ac864b5d6b17eb7aa54afe92c590e91e508de07945ab30eff4519f1b837a6e0e8c3fffdb111653bf55ac5e1d3934eea0dbb5fae1e02c1e9b2dfbc4e8033d8aa828975f6fa29325c0c797c36d1622f83da03ed1df27bb550f4acd121cd0733c80c7633690596764f9a6c103ead794f30460ad38d8e0fe4636e9619d1389be19a4bf17468b3180087f7a1f1e6698bd0ef19c70584642244c5546f04d3c46e3c4baf7cbaf8f9348a3e5ea8b2326baf3f236380fdd36326a7d7c641de21ae38ae38218e126b281780f10c23db36c9c3b978355a2425cfd77132150b93d7c168b090e7afc8113320bd259612da3317acdfcd26da8c5c8751eca19ad16ae3a1b436c88e37f9cfcf0b57bef3701f47fe32dfd25194d24c7fae1c5241dd5ecfa92278e99740686bc10d4ff9ac137faf5d14cdf2f25840fe038c503311f696d51a958de09865d3b1f3d7dcac421faa998f0848c57d510075f56d6d9cb8524d38eb5c2d3c86384e959d852bd23b0b9a986c905d15dae4478f194c9115e658ad084971bfc3771310f6c951cd08d3aca6d25a908c5986ab47809914341ae599ea39f84001fffbdd06a1cee61e53f684edfd9493593081f91d8ea851c8daaadbe9ec97bbb5d1c30ffbbbdecfa83bb41f9339887b7f9fbc2bbe5fc39c681223a8b98dec3914cdcb9cecf57cc1cd044f22f16f6b2db7601fd08bda39b17a098b61d4beb34537fecda4926b97f813eeb2d50c5a76a7ba260b18100a1d935c95f0a6fc75746759fd5b7f697f56e57d48149832f3a56ff380da92b333bbeb1594d026e507d757944ba2403bbe2bdf0246bc245c7e10ccec2bd6948387092f9402f6c19c7360710f4fccf121ed165495eeb48013206db6441cd44ce09022b515efde2b63cd901f904768b18f168a103b1783c9ef26cfcff460f60339230e797b6762bd718de3fff0f5b471ba5f2405e316945ef8c12d80ff678ee02aedc126c8579050a13118fda079fdedb24cee702b924bdee920a50fc822cf98067820cabbe740808a33ad6dad8853611f458f55dc25fe8e3ae0b29ccae8c7a2d519d037e75e5990b07944806e887130790d83886f2c938ddf16a35f45d24f377b62a29077b4be8cfb8098630f2d01abebfbb2ebccafaa5844965610c2523e52de4d651c04ee2e26820a2411c7220ac29bb1216d574444a43232f3ce986af1823d116540ba2cefa631ba3b9130289c68c2d9b421c844efff18fbcc0bbf831b984f34fe75b473bd3e58485f0b8c272f6933963e91e71b81991db80b41b2dc9da6e6767da97b6c32c92835577b7601a32cb09cd5d171bdfb17a598a3c96426e563d0db8b3d5c498c962b44679be5674f0f7a97572a978afd5bc7aa933ad910629ead5a77bd60f52d2159cb65f3cc737ddfb47ccbc45c26b6a003511112c75fa16f6323ce1ff78319d5040e36ba010224de26be52a0178e51c9c7535335b5ddd67a4aee5f6316a5003608669a069b323ffd2a314f9c3d8ae9f09d79c2f7f55fd64178805dd734de907680068d1bdbb32e9a483ab454feb2259f344e346575fd979f3838d85ae2e7e241fa8ecd0b3b95a8c12610b8f2e9971f6879d701f7781db7f042ab5540f70ea447e31fd933e3018ced8d0baa5e6c1b69bd70e5ec49480270c38032c6e21d4e604a6a440bf52a89d26918cd6d4d3b365ae11bebd4b4ef5feca794527d138830317477bf7f2c27ca24f2b7dacf6bb5215b7aec71958d8263a0a0e488d859524d24f8474fb2f15706d8c64d84a6fdedc82bdd1e6bdf4a6f13347aebf413fe6448c4e028248a416bf862a49d52260bca1d01db69bd9336382f4051038b2276c299a4fef20d76fa2558ba0a8b34ce1e51d7b2b4e3c5dbf2c72d5d92dd1b779b04b10f9a7d59b431d09250a6f62efe8d01d988bf7319cc0b19c48ead608386bbce621d7ee30cfbcf45eba4a7fd1ae3ef429c3e9ff42dd4d43ef87d1d3e3c96e6a83eb6416f7a991e05383fc6dfc0c7a911cf1e8837fb6c9d6a908d15c15547b834ab6483ee75580f3c56e62630d95808fb04dda8d5d2989ba4155c622facf8cbf532d2f6b6b4908ef0d90cf9645d915186b38bfcdfef695db131994d87eb0b9f1de9738f4821ab986b3365c5bc1497966ea5331eeae9ea654f082ef66670185dd3795c12f429db604622d5f799baf9a321509192d84539add286ddbdfeddf52d10c49b16cee642ddddff8ff4f6663f817f58fedf7c13e712f600c51431b0879ada46d4377c4daf66b81a9222be26724593b6a39eae94bd0d0039e0e901ab54a2fd4c18709fbafee2f308a62c6e7560aed7313323580822e0e59a97ebc93720457ee24a01a9cecca7d0de0321fddd05f814d0b513990fe98e0acc1e38f68f570ca0f43c7dc3e6a58949d146d111c3e140a81e5687b66d242a336ef518deeb1f2592af12f32efc5dbf9b1bbd3d0ff21cd75e97e856351a3302d34bca83c9b6e8e184b967ce9c73915e3091ba80f557cff7982ecb2017691a5fa9d45499f5abf3d3833384c851d9cc1736b4ff20f473d063b4a49e95f3a6b984a0cfa2d5544444a1b2d62d2920d929a976da1c3890d47be9c677c3605a9d02273ebc1df1b371dfc4b187e7a2fedcda096469882adc670a77855ddf895b40ed012381e9d5d0aa365e7bc40d4a8151e4ab58b42105faab66720079c6b2e58a68e323ae88094600fe9f458bfeb2272d727a17e260eedffef664f3d923f3c0af26cac647d342df22aabb829d7528592bec46060619a90c3ece14788c2912590ad73e0684d3df6a53148e39a299affd24d0d38640680a3abaea34301500188d398bb78699d02e48ff630e06a6e124e11c2971f2a6905b5a4c006b19b433070f12482f8e517c15c60d83794fd9abfbc4aa77591668b9b0bb55a7d899e7296ef0a4105f93232dd2f2c617e51b8fd99cf575414261691e77d5bd48e1c0442636344e526e227bf53680c46c35686f52197307afc6c601066c81c99eb300f0c21b27403f54f9c2bbe0859a31af0372bcd8f8002b59cc64b9167ff1637505bce63459cd3ae04ea805b8d74a8848135704005689486d80847ac9ed802360f8b8ffbdaad33a1737932f49ec92a263da3eb887da8c1b72bcdac1a02b8eb441ec01b33075890c7d70e23992b8d069aab46bcc60915f81015b091397d642309fc5bb23d3f8a6e330b816eab0558e15f550af8a88aaf864b05491946687e7c62946aeda3b045371b4751bcbdc06f09bad263e0bdb52fa96036a7a74ec3c4aba7f8cf0eb22e5211239f7df7d6346433c44ffdfadc348de76bcd2409cd229c1270ea4690d6fb84f1a8e09c8a95ad3cba59f8e086b089ba7c35086cbca11103b454953dea10694ba0ad54090d4c4a26f760a4c899182a2640c2e267056f1621846a8a01b47dccfd83f5628b98efff91f29fb46b3b067efd69abfde81c2ce1f04280a729f0337739c565a60e99f0acb7ecf1debf9d2052f3cbfd2956f9f85fca2e961fcf7f99b675aa4fbf27cd995cafac3dc65f6d0a0bf416ec5df3f9d9ecd9acde599b2a800f1550d226883356d1b347f8c253c57eeac9fca73df3220cadfc510a64090b046886777f3d26c459d086b23de559c9ad550fccec15d8e556cac0abd7b85828b45477e8dd34b25b00030f410dc1e9df5ec6609cb338174a0834f5221d0b8e38a92470affc300ea5cf2ad336f0e7ccfed2f00fb7534a939380ca6745f5f1c4349cdd445c78b3bd4554ccb80c0491c80b8931111ddfc76a6e7e438504b785b7fab42e5c89fc4fb9367afe0657985e2a44cb1a0ff98a6c5254348bb8ac757218f11e830f71572dd6a09006a8e8c4c46761f435584430545dd8bef66fb6922495562a45faaaf3047c195fb7aab9258127d857741f9220fc890ce43384da54779bc794e675f26fd81e86bc30f092ceed74746919d35c5e2e6ea0163347731f8e7057d7f0a60298955ab3785eda0615ff7faaaf1cebedb8a36e924c5186c69eb33f4b48e4c0a84ce887dfe0ecb81e845737c2752e54ea2b45ea3a099acc96fbd063c069dd502d610f3c9af44c2d4cc95a8eda19e67d896e92d8659ffa5b310dfdd5baeac7a178dfd485e960c28f0b4e1806ace8cc010ef1a0ef93f246eae1ddb3985bef0f611d8d63d0db5881d5517d895069256efb7dbd5de2af1767f6a4a9ca8fd3bfad5a6829768d01ed4ca514f056d5ce27acdc72a0e895afa347414b646faaeb6ca941197308f3ba5244f318e316b533f827ab97aa91db1e0764285428c1ff5afb76d40ebf1f6b15eeaf8825f87f9849660911144c17dc2b27367ce07bb8d566c21ccced9fb4d86c2f32d94f91f4e770a69a51c69d523b7e0662c8c8a42c96abfe1303f765dc55f50e6b94c7244dfebb65ec92034dc60cc799b7a10a2865b908bec7a3cf0ec09c07c5e3277917ab0331e9d2ec1d9f7b9e3cf64cb58d73e3f7da8c29b218973f942e162328276707a3af897fa5b1df843118654d029db480cb280aba2f5dc057f52b9f4d6f344f3b3e4862d5ae8dc756667e25bda5ebee841ac96ee00c4fbd252be585a3e60ddfecf0ee0af1428716dc97009199c89b8801d45d61038bed9140d1717e4bf419e3bf83815bbacc16eaecf5e363fdca2e8b3cfce42b2574f07816275cd776de2345f29d394949e9947dc4d21f40d0d667d5e5ccceff98f5f038400499f49bcd08c57ecbb8cb4f259ea1fa8b29902bde7b370fd8699a566559e70cb86c231ca28b323fed63e6417130635276248b857111bb3639997f2f89a022fe7c523c51c89a289a3cd550b77ed6230388cf642d66303fcc5f8e2cd6d9404312a726e4226668c312baa7486c4374d3868acb377f281610a63f33cdf21e9de14fc2c4f3dce7919ad2a6c69fb370d95d2983f3d678ad83dbc044ce30ed3734d3533215b556683eb6d72c8885a17737623fb4d8ebdfe8f180d92140f1e416f1be2e58ffc00f6ba6c6ea82bf2fd5713cd595df2c80f15234d8f16bf9379a6e61a64788125c3a872794d2ccb2574ba5713f5547e514c422f1f2ab489b113f8ab7ac846cd56e69d5f7718e8f68df2f877fed78bcc0497f8d2575f424c741fb87ac09bb44221db9468567d00e40fc1be4cc237f17345a8c6f63b9cd7c2420e03014b22758b10f63f794a0422e6bbec5c301fcc44f8b0ced55e7042ca682b6c3621cac7a84c0c80f3cf7a9bbee8b9611d78a10c583f4d145db1c87410ba59f046ef7603cada6536393dff2fd98dc42ce5ec28394000df03b25c5a63a9806058951aace769a0907439afc357bf7fde313a900f2df7f2272609f053be85301bc0b3f51b3bc9c586080dae675608fb235680dda021a04d3c3528aa5e94d0dd57027c460747a59e8d6bbff254df7d026ebe8e17cea31264de3f996915f0e009ea2cd3ae4e7b155839f7f68e6613757b68fe55e487d2f6b30a573210dee2e5e4731936ccf952d1fc7db113f370fef67b442a3a01b525a17b0578de6d161a4db6c28aeee6a2663c736b975cb830d9e35a5254c5353d017adde360e24af13263f1a7e44e7ef591c82aa31c3a95e7f11e736ea095f7495ddefe960d054067125bc9e9d51e451cf02c5e4b52a0c609e6f0ca021e429e7f7eef238fea6d4b8acbf1e5b9a98f56e0f19648e75c43f0514c1cd84f674f25bc91751a92880927515eae595a478907d2e2b2b78d888e77bed3423ff32ba8ca7def8812584afcf3ca9997526b1ab82d86666a9470d583b3440df5d3b45f881378dc5dbe131542f7c3a80283df380597693619fcae4a2389d15792b9922397854bc6287e20a80268b9602a0c18c131de445b2f60da13087d3cf040135803f293d0ec842587acc6ea08c52cdd6f432b3b54dbec224b64ff43e72e5b48d68609ae5384ebb922d0ceeeb35677bbf52d2548b25c16f5a1efe30b1be905b147274849643358d3f0917085a9ca8ae3e585f028551c785e40f31d025f39b2aa99d61cfe0180fe04689326b1486a39e31c3460b33eb38e561f97103e549929bf616c395f6e7289c0d371e22c1d2883b3caf746f48cfc3d50ec1cbce97e1e1bcb6cd820c1851a1eda9c2807affe07d9bed6ac16e9ef76712ff56148a042f587482efbe1af65158560a6774f8a238a5dd916b59f10bcf7e4a2b03e2805380a6ebcbf369bbfe105e10b2eb49cd5dc9b97a18812afa70ec730904abb867d4d43d843b27fc53c136f9d2e40e8bff08133a006dcade4b234dcbabe3f770137c912ad98b86d0bda36fc0f4e603886d040cd3b88ba65e5781ac5a7143159fdb8421462e11627fd8549cce18dbdf7c3fd573d7ecbfc11ec7d306f903252774ea9b4931fde8951104175bd0be8b2b9a5241f6f57d8eb273405e538f69c764e3947fa531694230c8de51b65844179005ef01fa036e9b2e60596d51dcd7492fbbec6f634c1933414a6a3e14d84bb9a807f936f332a1dd811ea6d1d83daf4f6d91fee65fca964347f0e09728d231c723af1c1906236891f964285bd260c00b4b869116d43640b6e71ce0b23a2e1bd282d6150454ed90c24efb9e9237d2867d46444332d57452eb740f15d7b68bcfb624e30c40a317925d18c5beea3756e0361c82168ceb8bdd9f0a85ca71e8283c3e41beca36128f355c961dc81002409248064abcba180d55e3a7a176887fa7a69cdb3f1945ce3597bdef0739a5c3ffaa9b915daf5f491fe95ea05974591fec3770fd0543ffbc2fb8b748b34ab764edbc2361738bdb1a013fcfbc141d5589e523a5f0034eb1a7a14a62f3f18bfd09bacd2b6a1531942e75759991a0bcf0418755bc938024b1c8ae970b8fed3a4af3a88d6b81925ba7e6ff6446140601d0f6ece7cca43642c0d3898859f9e62320d0d39784baa7eb788cbaf81c9e620374541216ef1cddb5f9ed715033fa7bbe0ed2095b82aa598bb643793d5c1577b5e5228c830613f1a51c6b5574275ad36dc20e49b66dc36489d080e92a7c58b2658ebbdf37e5fbc346d7297d9e167b5cce3ff6b05a14534e943e7198947d3473e6b389f638c0d9a5376881f36b4eaf0ef8a95312dda0a177ec1e5e841906da2e0890b2be52cb2d8b4c6fb5e9337700d3c7c3df35e12fbaaa1ebb56332e9924694528c270e912a92dbb067e9badc701182ac579b0b7d4970a8cc962c23c4abba40f375ffe5aadd10124abb0c8e7557dd66685d1f8692a7b94cbfbca7f79c232428a14b5e87b713c883ead1d9a4e00879c96427e571fbcf2c6ed6f7d064e4693be39e830b8bf0cb033e6e2dc3738527fa11102251e64f4e0ffc57ed2565fa0fd07363f1f003c5b045b63282bfc65eba76e0fea2a5440f9ef554a39e75f6e4e97559f868073455a7464bedcc71e760b16fdfc5171fab710bc161ad57285491c560c2753f521833446fa2209e6f6f0c126fc5c8d8e5d402b108150e2241fabe61ed8d837b4014eb5aa31216ab0969ac6460a80effc299d35bbde3ccebed6bdc7366c50b3004c1dc4bad35d656e123f34ac7ff9b4cf1c85aa1738efadc524a7d32b12767c7cf27a3a6974c215144768b37430def1bf658ac1b4810f7062a79cde0342f9191949cd4db13479e49a3b41bfcfb97a3af8a1bd170aff0ff327cfaaa8085ccdc5f3a9747132acb45e995165be3e0ed7ee711990fb7b74584b5cb364fb25ad7ba41c86e5fdc842285f06b037837596648cb45c5deb13e06eccef39034d0e5ea9c3eaef3c5669b346ddf3588322cad56153ac9d668f0cc6428b28bedb846d02a61eda09801ac2366b07320b3cb8d8036a030193a226b492a535c2bf8b1735b78d2097a2ef9306d6c4c146cf74939bd4140f7a1043cde9bcd49a5ff5927fcecafe18fa4cc21265","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
