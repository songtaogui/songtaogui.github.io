<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0140b8ba667d678a865396e98fc60aac4f79b85f5542c844c94a2f0ef239fc8d71b57d4f396e9109f5c440c2ce39ae051e3c21ef02a48ccb9f12821b9b9a6969bb4487fb6569d388165d2adb6bb63f0e5af5a561305a0c641895c7f35dbf4969d764c2e5f71b29e927c30a14854ef94916c20e12bdbea806fb31466018cc34536c3f7f26629c16d36d10b9fb06d7448ad5952be4d9193323fc8469e9718152c70c1987d4b51121ddba8f195b8c39ebbf40ef41ccbc36c9b31e9e81a3d583db8b627b079144e511f503889a812ad186fe68da544f6ae15283101fc781431bb472043fe0369ac1cfdeeea8af1389ca745a2e79ad1d033885a92cf42fd501228cea0b05f166611604f0ccab263cd96d9facecd64e7043a451928f44c20433ed5f22d7b4f8337c060fb0ee5fe1d28802c8692e067dca67a82b58782f3d9499cc72c78b79f3faae9d3268fbffcb694b014b762f089be1cc3eb5010e4eaa5e61a156aee734e4a5ce74c20de2c8e6d8e376d9e1afaf1e7be7b6fda27181b9078170f048317c7997f79013d066d9d586ce1c02cbd9771ea24a53ce2780a2a95dad21a3f8190403c3108498e9c32d68d7b9b6d34e8a76540f628b5973c0b4fdc78719bb1adc6e0c2a68b49b108f4b11569e8ed97281d720cbd360e1a392e2a5a85038c95ad8d377d1a473068cd91057abf914479781f7d18373d193964b29b67b8f87c2c22a106b5dea8d68bd11ae2a60e86899366945eeb9d4ba44ecc7c7aa5f751233190f458e4b029bfa59ef7821e5d2a85fde786d469c571e4a95018cea389a69862abea8f72ca9cf1cda5feafd0ab642b761c1740b568ffc540dc1c5ce71cfab4e8ef425ae71246eed189ef4c41396761aa78b29eac0c3a1507e2fe68d6726527cfad591559d0e685181c61bfa59132b0a7524d7b7527a3af3d537229a90773ea23ecb0ff700b365d8237290c3bf38c1701201a97c5331bc4e01bdf615b1514006e2602a513e3c270e5839ff7721c85ea2bbc15cd3c491f0616e224a51f739877ae3b9ab747aa0c2e3925266fe855829e6bf916c4c2f772c9431cef36fa7b94182504c9adc293a3612058315a7860e1c388bba9e1a32a0221b1311ad4a00d3026ce61371cd9c1046ae97e4a7608e42545d3c32647b1dfa4bab6e8dcba3ae94d09bcab6d04599322c87a22625032aeec09bebcd0212287878b059387715249d5b3c1f45037604ca7adb5fb4a470704e1f5b8e70bd342565149a51e51f484a8b9c819a8c2a2e9ef4fc23131914609bc6a7723367db1b2044cdbe6e6f1ef5f4755bbc59fb1e1140e50f4534d7b4f3eba06a70d26b406d92705101b02e09655998ff5348cf0308eb4a5a918656c31c99ef2863be3c60eb25484e1575e4ffe4e734e8f9e42dcf76d4a6776c075367019cac5217daaf9aed701171bd170a41baecde824dbba4608e02d522416827e6ba49c1cc3a456a87d7dc6ac278032532073ab84b4ed185a48a5a720787077d3f9279c6258034d506df09f637f5e4b5cb26f36b90db99637466f57344c21e3662c53c4070af80e6d4ce2ad9ffb294a857d30f8ab9209483a8ca291e28a9277ea029a2f20cb1d3069c62caa63d354fa5527242620a0d5fdbf06e6b2848ea7737a392a0a7872e5620a34a4a06837770fe0f1e765c5254905d09b2e3ee70d640f336546130074c2e0c2aabf1ff34e41c64db1f35b147b5ef09efb60359df6b81de00d10cbf4c61c111c77d7ca0a7f03b8460d42c78f5b2966edacc683549574c8241ce5189a2d6d2fd935eda3d8306549ed7b360bdb6689d777b94d16e48ecd5e85c4379a00f9e246dd0f52cf6a802eba966aae474f452aeab5b2f89a389e543e993719a09e68cbb02130528af22301644bccc5e9728079eae35c88fdd54132b8e297f72c84cf768136e3d822e51d20d8aec76bab6655d0e1f566c15aeff1f050fa6492d260ff64d0bf79c2cf669ddc2c2802abccb1e0262b78cde99cba60e9fbd6b29cd6ed893e69a78ba95e213763af8b834ad5f83356ff10c1e69578d2b2f08e32367c49c0ac9dcb158ae6200e03d31c48d08d25a0e9f88c021130060308ae2248dfe431d4717ee42b0eb9b1071441ef64f0aaf5ceda50c4d9368560a0f88064b1ac49d44898d6bebf4ebd4a0be4d44358a83ce01f7fc42618733c941ec8955be6f870a0e6534717093e5b6e65c7ed6c562d3ed148851b4b566974b225da8e1c389a96deee91256d3f6fa483b8bebb32a3a53f3b00410b976d5aa038cb16f947d764a580124b5a715972e0ed0ac8349a71c742e833b10e45e2fda20f717c486c8ef52dd07acf9da1e5ab6bd9613e3ccb702c1fa01c29602f3c65cf9ade6eedba9e44d88de7099e617ff54f5367067da69c42e44a815b1f1dc660510b6df3a4680215f63a39a970f75215b077b831b24e58bc59839cc59a94587193966d6d775618c2dfdbadf975ba6fd825253793e54142149f8d81a2cace083b765782cef803aadce8377c68ad5cb7c0de0b98ee89ac3709010882e703f37b4d4bbf45c72f040e5cf8cf0f78b9385ba89f6adec292f379aec3d7f74b16173d656c05be33d6ad174e38e9d3b17ec487917e279f0ee0a6bd9aef7874cd8ba6a2d19029c778e601c069227b3c2bfcffd62f3455eccb3a8f93e995d66c68240661a40dd3b37d3709a4843d361475f5ae1fcdf559928276da8dfe3c38156396be1b89bd35fb58c281ac2784b58de54eeb41f38c212752eb298f6b58ed6f5343538835fbe98e0bb97f0a8140d92c1af22531765716029df8ae1b1e53affb5f3bc706bdd336bbf8a163c0b26d542fc0e23089cb3f7049c576ef2d76eaf2ccdb9741b996248a259bcc8b4fc026f04704a869059b41d3b2728887ea513cdaceec8e552df7dd45e3d51d22eee50951511f63308f31bcefbb846b5ed4aa88ae76611c2233ef3e6a17ebf1ede97efca32a4c1542910c4000119b149880a8625d3d2c5e0a6105fb67c3b8583a400840b78339a2b60c2db84146c79a5b77b2a20eaad997ef1c595fcebb4866f722507d1e6bbddc43a32764e077ee856d25b36ac03f3ac794dd17fe8cf65d919d0fe0ddcb3b04f90c3ab04e049a62a660392cbff7a6b4a456bdb2d6445525c93e269f5aed70a6047d4c40c01131ceee6bfac98fc43a489571fb871c84b79bd93da0732b20a628a64eb800f5e3574152808649eb0d53e5eef3b39ecd49e6ba4b2adf23c550b334d919be3f8508b71bbcb4f0c2c9d9542ea30c482ddae032339bb5ff9735fcd2ac5d19ebf69d01ebee49bfbb70a356fd06fbd212546f9d55377a745490cb115a44a6f197cc82761c3d1b9652638b45dd0f0d3e8db5cbb05ed4a104ea49d7add9151ed9a8242d7a9cf64c9ec2c2079e9946385ca1cd5ba08e63296258490bc7c196b7b33e6ff9540bef0427744d765c5b5a2e09009998b077852d649c944980ef2545e7d5ae54ad55a0751efbd9d5868b5b2134db8973514e99c4c38b21c3f1e9b66a747a3bc159b62480730341db1704abf3fb0dea08471c1de14f066d4942f251cc604a8f69e80c7b4e95895f26283945aeb2886fb67948926c7dabcdafa2229f84ffb725ea2d5653fe5d805ec0038fbf5897605101d3bc3fdec6875c2d518c12bb272684c952e7c1624ebb9c00c3211fc47a4cd5de54c895233d9d3d74e8c8f932d1420e1b0ae103fb6ada165be2de6997e7de33e27f0b04bc5b2998eb278c22fa7423b9426ee8ff6c1ab31ec2640a939bc623ad8eb59bc61dd3775d375cab03e69ca2fa393caababa6778e06602885a3cb18061af2dbcd88e5a9e9716baf05ec11583e226af2fc734758dd6d6b61bbeda51bf2a45087f974e0608832b978672aa30e03a9c24c8e212da1a32fad023c4246fe8d8b41da2aa1ae4a173595e704f638a8f7f4603292d199f77b522a76075fa87b96858bd0478d756ed5bed420ef93940d5e15a6d11339858800a4aac1120f139c641bc3036d0f89e4efb3a67c7ee83ff9b5637593ef80374f45b869d2c51b7df624abcf515eff9ec1fd8e661d5c4fc490d4d1462becec2e9291de9d54d0e5212f8d8020e8a383be6deb911a9dc4b56f2a0bc912816b0fbc7f64d553703dd0514033c1878ded1470b23d10750c43972678d295a30d0fbfeacd6ed623e7ab4bf793f5082a587dfcb8a8edb0b25d9d6074872d7abefb198630174f0d9bdb88a8ae54db6bd0f439c01bf37878c671a4e3a22383d9f32d16e3a932dfc21e58666fcd480189bc32a526a14b4997d4a729d148eea83c43f3b898023f361553cc7022d1d8c1fdc14c3153a03258b214c9c94e3ee6a431e5569a032bec58fa44fe45ec9296060397f9d18c63d50a7343df6078502bb34be023c13fdd43517951c61d93ec427b57052cdaca7d38b6f3214f5d5da69762377390a4c877fd7d048dcf21b6a8c23ae29205bfce4a7cbeaede3e1283d5ec254c222f9194e9cb1d778c63a12103121400866447257d7b54eb011b8a96d03ff5e92dd87dc7fcc5ddb93c43e839f472dc73ce30a4313a1476c603a021e701106bd6899ab4d9b71d99cfedf9c1a3dc67d50e7047699ec5b07ffc1ca7791b32786ef12dacf34158cee2d0036fdd7a77039d44fa97b76d40acd693e5593520bf9387b88928efa86b40166784716c370ec067e215751107185c8c9a214109d777ce43bf11125164ffac87c0dc98130030818f6925d0ae55c09814bc5400b100f51cdd78644f6d3e947b30421645f4a93346b00583522b2eb2d05b6c96314d0fa0537a4a415ba02cbac079a7f96f1f1c5b400abfb5175d3934bf9a445fc99c65f002d8dc793c8ad89354d29d7e7940ee2972505e8c9ece29aad39bcb28a81254641b115f05b178e2d144eed1631f5962f6e7c8c9f78da51240ae880c2a865779d3b05315980256ec6ab75ce90c8b3df26d69418eaa9e984ea684e727a8696681fe23e89b42921bdba66e8d3b773a5037eb3370b499f060d0b77fb3157b8857161fbf94a93a74740806429f435b358fe41199fe2980316af1f8299dfd64850d76a714818315458ab6686417fe3f3cce609c3f40746dce76387aaf6df7a9fe3cff1c5573763bb36548e9d51350351f91567677ab6675fb1cb3cec5665c62582fe762e6d96901ec0147bbd0f64ec4b6687fe2317a403623b1cb2db30c1e859ee9e764b99d85576a62416071dc35b0dd8b69b0cca377ed0ce025d94fa4143b02cb0dc78841d97b44bc7fab07ce186463575a0ea59be13b8ceaa1f1c3f3ec0dedd375f28ad433e360a49cdf639faaae10b78a98574c7d40487c529fb267bf2f0b30d92ece38fc432d7b34b9583e661a051768e77b3ae92c8c61f3f03b50b2c94352529005d47b67a6acbbb81622d4f8e2c0a6f21860ad85d2f05925c396a34ae11d76965a463217fb43b322655dfa4325be32f0eb2ac2e553faf88ea13cb6aeca4b23e7700ca508d31964cac17cf66ce83f76588fcb4cb1ce62bc4473680c9cd2ba8673dbf27840986a2a40feee74e17ef9dba9962fb140d41d9047b75b7e1945d856d5cebff9ca56fc4fe6f86ccb89231f13cb2b6d775229fb1211545ce497aa5c812bb74e7d3d168c553cf3a39a1f3719ed77d0286da66f72633eb0d8ede1b4e030db2c8dbf4ebbd29db8521cd825ba4e2c3d1b00e2a24b5f92da402f38e1b758a8ea265d196489221ac03f0cb10e8753284497d99d81e3937300f9b77ce77ed9bffbfd8987953ab7ea6dbad6ed885eef1010506a4c8fd77c2b1fb5353e0cfef30a81ed256fc8ef941543a438e8491381ce90f246829c8065e5645021efc3c163af5a623877d5fd503efc3d466897b7adebbb63ff7839f4bd417e93e682149f6cbd46930fc1502e1a5a76e763f47d98c8e919191a7e799e8c3ec01991fa645cca2af59b0ab04ee6025302ef759ea200c0e00f72630773bd3588aa82cd925bf654400702c339e16d304ec8aaa831e4e9dee97a4682566593b1ccd34b4e42a0c5d73514391f385661b2eb084e79a89e0f0e9d390db7ff7b8c997508ad017d95b00adf04170321dda584c6b0d77ef98b1c3f007997fe0847b87586438c5824e47a449246c4fb0c09bd3b840ff6b1d87daec45c381e6d416b4ed4d3cf1b6a7b72fecd71749563e0998c7bdc4b66e363f774c5a32c23298c96958c42f4d5db20c8d6d70a27f51efe6958d20a6e2c288d4a0b07c6b424ee5b93908875db0927c43561d997d4f45575dc44adbbb6dcec7de6795ba72be7c115f56f3389af9d6e622d88893347472f7f8701d0a5f0cae0c39f5af63c38ab549f2f1474c221aed3681bf7d41d8bb40d5a3bf093f6ec92c08ef8477693b8b9928272966c0366aa8f8c4050782d0c26658f4134e338730a69c8b8d698c5ed4cef9b68399e8b25c4a2113ad1c4355436aa86df59fee39d7a75c2db0f9933f7fae7aa3f3568692d4114e5c0d90313d61b98a5cba0b2b1974658b714a2ea59e58426a05710a72e960df9922c1ec4f61c10eae961a0763d1d4595218cb8e08afce3d3d010d63368e7c03eb18ad7923c208434296dafe127b5fdb5505163f821bbc16ecdbc185fb97072b2cfccb6146c2aff476529b149fcf700e2f98f355d9882a62d0d85d713cf3f31f4b749505468834c0f33fe44c1b152e2e420dead35f8de026f0db517eb408507ae7c47b62d1e2eecea4cc279d21330b7d36d32eb2a18de034fc641ef9bacb68e35c5a645a608ace996ea8ce3ab610ed526a122e9adbb8f5ac7d284cceffe148a3928e40c3e88fa6a99be820f7c0d8e057d61deb045aeb207048b3c77b2118279e6e83153d23605c9e1fc45d037a9dd57029c75e0345980070f8f05b6144becc134d2a1e509a683a7cc87400d868ea7ed68abc2bd333a7a753724ddee23250c7784ff69db0e261a5831463759dd3d8c440b2f1354be238c5567a545a67b75e06aa3c7f86f25fb6ede000d787a3b92dec131a5cbefcef9c9ed57cdc174b69912a593a92c318d350bb46e704841a857c8471ed8416394a5f363d814e23aba939fcb648b61227731943712228e18f162248e6bf20a7f92c1a63042c7a2285ce32d3396eccaf9d20dd26e529c9e584af4e49946a7ec497984d5c89042d579d401d859f2dadf5471e21591cdebc139df3fc2c71893fcda50ab0758398c51e38772608cf8b48748f7a9105e4d0c7577fea7b7ce6c3432a8f98898f49fc3191f27e422bb0c3d485bb3c43f397eb6ba8737b8a1af16c29e326957f28b7607d32c32fd32e37e45b82b7900603dc8d34941e3f63232b3851d4242d3b427b25964d46d0cc5f6ab49ed4c668a912495d6e727c85abf093485106f087e034fbc264d7aaf54bc28b0a9c15097b62cf2460bc3695054c652171f6e47fda8a4b23d09a992e3f6d4cf1696470da3600217df9bf5ac3d35a94020135647ebc06db46dcdfbb379ac6dfe43501b60b4f71350c74d65d8dbf9e295dc3dd319b515fb7b882cdfa6adddf2f127b4f7a5f5919b3bcb2f4db1748fafc2039bf9f288ed4bbf3234f2c6404ff1bc0a71423fc5154acca1cb37b67847d141d54bb13646042cb700791084573d24f594aefb8d3d3ecf4fac32504fa5efde4e997b526e62dcee33dc5d64ab3c4a24d6e060ddac55685bf25df25b51cd67c697a27c4113ffdf805dee2e6b66380cc9589916599e13d6074d2ce1e943f7468fb7ef26f8f892a6bbcdfa0655a1f194ad0ef529dbc37c7b3d11dcc0d5fce22c3bf65e4dc68271e7d74e6794fc74ab32b8f0711fdae4a312440ec3d9eaab404a3e1a9c1500d10fb3214a1356a16dbbfd4adaa52d09c9afab102ecf2370a3eb8c5a34ef36a3d09623c9bb1c6421c389d42dbbd9d1fcda43c6bea84da829e8bd7c12591e1ffd4072c053a553149d11a93202a6d7f58adb4ec36550a6a2a0f908fdb98ec82499afd613309bb679ee246d5852564e1535a9f92668b5d9970997884fb0ea8595a23898cf40fcd543ca29652770a4f295885ab5fea52f14a4ae48d10b840eed702ea6d93c3abf3ce7e6e584295ef719fa98747b453478b2fb00109c0ab188919fa6a1942f64989fdf19a95290d09a9a19bfc404e5ed997664b1c365611c84a65c89e2441641cdb7f3fdd7808506a52ea091ab3caafa93749021b6592bc4192d9c433f5b6533e6e7c155e429a2ca4615668c7beb6c8b0f1ddcfa5182ad312d78f78e4fbaf5f0d7505a7d979c313aeb9019954bf8778b1a0d9ee452595c5cd76a2560edb7ea56ba1d331db74ae9cb7411acb8ad18c70996242dd8da3a4daad43a49c09e2dc61521c6c0bf01f78ffcee8a894b4884eae9a13dc91f2fa3b18633617e7f9e9c5ae7f5cf10c291e0cc7668811433e48d3cd9972972f542c432e3a94f8ce3b4ab66472302de9a58444740d5e165c535a278776164cdf6f15bd175170ec1dd5991f8251b028a936e511d0c1b0ae5efa5009f15ed65dc2ba85366d80df04c62a97978bd9391ab7712d0972e0c67817ddf9c5ec624b822813d0aaeff160295c58fe6259ff480bc383c362d2ca188d616a6f7b6deab1e083fe7b9c996b9113555cc490e31cdd669fd0d44e57ad3adec3bdbc48d191c0ede766d56ea24cec6c64e4459b3992abfc46f8f5fad54db74686755905392786917c1fd653ff9855d2bbc2f21490cd25991eff1d4c921e0c4dfb2832dd0549438df1ead6cc17018e8e66640ccf20794fb34416c9d7717b728aa095bfabb71fc2e73a182b93736f572bb09d894b5db206cb941d923806dd99e62b5c06eaf2776668cc45316d34ac443252d686cdbcf73df84de65e910ee54925ce24072a148369fd0451f5a886634c5d744aab6394d8f771b43e16d48ac39db7b3cdca375f7d563a109d24597bafa6a0bb011ee6ff31a2ca4fb3deae550a4a5c655939dcdd8b47268ffed0a8aacd95e7bb78004f03cec27a260f3c1a696d5ef34b47e96bb35e81552769a7b61d0331ddefc6e48b6752403fb24dceef494dccc4cdb18594aeb4d9082efca857a2a646e225d6f2cceafc98e659ada58c9243e8e131eda1fd45d702f4a4aa84acb7796393a867c9af7bff340afbd3e810e8ce197fe494687864e6d37c87ec5e9dc629f2fc1ade18f5d62e4165aab5e87b196656872591547b778dfb9f453e6e0c735f4d0d47115061b46e0b6f616cbee265e7c664c94a9b3edc3efd4c0f5a9c773129afc1341f861054e560e3b19ac84119c3432f353a5da0ca2551e7f62a0fa61fc5dc7eaa42c0c459af0ea666ea98c7e8882a585a3220f84351bfb2d71d49fc2d7fc2eb316dad1fb2578dc5032d53c288cf8f229f3342ddce49ebe3dbacc44b04f9fac30df84cd53ca8b5470b5074f28746a11e5ad35fd564de0702b9cef54d60492c127384ca8bbae34eca512434d07031a2301d53d4dc42d387f580aa422205f44d10eb62b2c8843125cc1719f67c79987d06435013c2e60c83277376d9f63ea7eb3ad69659c678ed328813f34bc87ef2ac884a448743986ec5975a6629c6a4c307a9591c4c4994bdcd4dd0d4c39c7a286934cc080b4ad37571a7925d0c083ec9f801e420dafef1556c87466ef1e294d00bab4a2fb7c285f4c7ed13eba141229fe2b9b7a701fe76bad467d60b17c8f72191acf462f51f08a77f9660eeae15f7bab873773e12935b616ce6c5b988564e09e2c602315cdb3d2307bf0efb0c1b0cd44de35424f6c879cba1e85a0f137f55547051e12ae6efcfa2cc9da621daba62260c4d3aff2e6628f39f052f38a9a1f568ac19f5b63ef97909892dc403f564117cf0bd5468ebf1abe14f55796d0930decce3671f419e491640f9cb30806fbbb65db18581823f88709f84a2e6bc3c519ced878617b7a25623ede748b64a82490094840f5c130fe15e09c08e11b69c3a663e2a730385e8e8ab0c69099c1114d0b1e3da0e4cac163e186c0abdb84d82537350b8c3e15cefeec58c51fbb142a4ec6657f5993fc28d78355be834267feffff21d4c688de790a37c9f4a2bfcd97450eb1b9a336548659392e340fd84ae85113efa9e77ca7c96db1a9524a67aa518a39edc1c8ac76444b5efa302fcab36194c8dc57dceffd7497c319fe5532781784f5bd7bdc76a068e831588ff4f86a0a57385adee5c83b712ce92ac2cc0a7035d6c982b67f3d801be507d935048d599732ad1220c1bb24bb59ea2c8dda6b665aba352e2915a99ef7bcafe9d9811454699059eaf9f68844115cbdda14e36584dba956e9f332d75e886f8771da62bfd48d22eb5b89c9965f311acfd43ab2713b0a80fbf905ac06d10326e46756ba5f4e0fd5f4e35c1738c0b5d364128b9eb09e7e1343a5d521a58f69cbd2b33f0f7d2ec43d6c709ae5e8a24718b25f86274c068e48e8acfe2e521134759738649d94c5fcd4752092769e59867700f1789c9b07cdf9b42c9d7ad57c83a6e39c76b0a976d6469caaaec1d1fb599ffd91b6fba4104a2599371b4384c29411b352d68a44202e391397a223820ed41e589ec81780f81b3d674577623fbcb1d09b36eb6f73c96fb906d74802c6a24f722c60f2bb4c4f67d655625a2f68f2d436cd97ff0fe2bf179bf8d2e890db1b71f7ec4136468bc92ee24eeed0ede6146546aebe3af8e9046e686c07ece48b0471136144ad35ba72ec116667ab75d387f89a104e261998267ccc9f018bf6187b3b2b688d199ec9c3f653e0d77564067e6af361428e48930a138ecca7414fb33519e07e75ea48a46453768628a5f776527ce470db128bef212851f24acf73ed39401f7caa72b3a2739595a10bea50ee61a9d7773589e65e93a21f4eaa9dceb609a683e9dadf0eb56cd0ecf91488f09b7826fe6d13896f35f61dc57800609303da73087609714cd086693928c9901c1812652ba2a66623512ab4d3cfbd3dc58986e8234ecf88165fcf222adc7507ef721152a723ae613c9b5f7e3a24bc93cd57b7f0e012850506c0402ab09b2eb1c1354abc98f6d716fb0358b9d6cc9e3fa8fe42dc8d39d985f9bf725662c53fbaadc14a720eca4aeec49f99b4853a6f4bcc3e0aaeacda2c1843c0533822c06803d3939f97a9bfb70b59405aa12064d57469ab33ed7be4b5e7787bae7cc15a9214a06ead97ecb946f4f4e4d13662862cedcb5b9314ad1dc7753a36bc9de7db3001a4faa85a133fedb1de61fec80d4beb9b1ea22f36bf3e9590615efb490a15638bd6f063150e1748c3c826f5638337f9278b0a61e996419b7850413efe591f14efcb3ff1d2ec298dd80b5244987c795240c04c812007db2ead6c9f48f5523d77644e4d5ec62fb33af0c3574a3ebffaff307e35be178b7c5bbe4fb91f194a16f93e24b9cc187a634d3e20faf1679d31229d65c97d6a24f65adeda2144ac27d51d32a3f30b03fa432f6976523e6bb56abb8d1f64add92b472606d5f445f139fcdaa44c0d373cb8971b8c9a3abda0df9d93e4ad496185a3997c0686badd3a1b8a1a44968b89dde4e3919c5a4e3987c4013eae2f52c13af347a5888c847a90faa2d112bd33010ebbd8df0103357d66ea221c67f06113ae05142ac24f5020bcd744abd97b00d396e2d619d64ffa72c86175dffb4c021380a2234dd2f4223225227b6d81d88d13ce59dc786af2eeb300a85f225c8f11bec3e64af7c6f46e1ea3cb502e4c73d1ac93a59a90f44bc2da2e815c3e63fd51ab53bbbb19f0ad2a2511f827fc1299d24d9918e96c936c04b9417ae5e10b2315335f4e500e155d1a64f621d5835a3e7cf51cfe573d6780e6dd89082b345a33cdfa2d5dc2e06ed6da7f6c5e6535c87d62be0e31970f58fd0638e178caaa2c544b0a506412b8966a2f7de78e3e72f0a6e106be93b51074e6631e69d607c08311307e1a000e3b41a868da71f73ca602db01a240748dbff38b6d79a01180958579a3680e6a28f617881bd086486af8a9f361d91016e656922232295c8a2ca46d059c7449f2e04300594e6b4c6c1f5d8d29b821912ec52f341c730da6208444e783dd33591e4eefb5b7a5346803c66526c61122b318ca95f293ef700b618245d21f0adebe6792c2b5ce7777ba5ccf5a2afe4e5dddf4b2f79dffa1b2e124621d65e2eb38979dc7e5ae71af70679254d82cef0c7feeb77293f7ab13732e21f3390b63cd2bda0ea1a207226ef2fd9f8aa98303ce79011f75cdee84737a26fa8bbffd69f1f62f3e2526c9ab5a2ede923ad6919e1bed680f08f555aca788fa4f417bcbb30da5cc26f7679df09c3db9ca89aa63c9fa8b9d85d69930caebf066d420fbc9bf6b47b3acaa08c8d882502f119f95015907586e57019ff7d80d08275e4f3364bb0b4383dfd3ba5d7a5cca58c969e05f87119727565d35595283c96428f45e86cd0c394ef34f7d505dcfb1ca613be66bd18924f6e0346f0cd7e13a95c1bf8fd8ce67b4a3786e740251e214a9ed57f54b2a608a45fb8ac2b0de170f560b583e69c31ba8cddcc4c887c72b22b2f1b38d12a38fa64fca46f5e5894a005f296d63e09d3fc85bac02e9cfdb2a624df3d0578220ad00a0a342c3b6271d00b900ab2d116d3791f74843c6a7eb0096d0641f8219a40a6320ae2a90ba861fbbb4b401c62f1dc4b37b6362673863dc140df05016cd80c48642cf29233ae8354a54794af09f53662f262b763f56a38bffed7692f93953ebe5ef176bd1df4f4199202e42d00cddf987e486feb5ef9f8813a935072a5f9ab99d15db86a01a5569bd408f8189ee56b0304042cbb5888b4d652357b9855876a5a6a4ef77c43222e89f1cdb68ec8092a02743ecd78bf5b984781bd834fec14f3cab121f6b37808c094beeed5b2dd784c4916a425e81ae2ebb421084a8a6193dc5a079fa575c42a422a63c038509595296b9401c24535430201911485f823ebf5729347754cc43e39a2c2f52aa4dc7cff61d49d8b4a8c426c87c697a36705279a3f373f71f2174604fe98ffca00c99ee2316d9e233ade904de3d0aa8d92e064c8e225bc591a840be5dfe4147af8f4d904e88b619a1eeea199e20dd03345170acd2b1078f196f83b89b15195133c3b7c58a30d1d5f1a1b9ffe10eaacbfbfce5850f9ddc28b48588ff1d3f3c2f3027c00e56c125f718642c5bf9b02613aead6c7e3ea25a5d921623f1840adb41d046f2f438c5fbccd9ca0ff769978e7bdbb0004a57e6fbab0608d58345ad224ee331024716782bbf53d2a8124785293e53e0b842245fc263212701b24d5e2dd45142cf8efcc0b07093857eceade3efd1507bdda9a548cec4f3cb198a746b3faa0100d37dc5c95b5c11ca42461ddd90ce43f0298dc24ac2c143676e7eb5166f97d15880983c2c068b81020d54e63de61bb9f7be90114f73140ea52ebe7f9122f058c78f11ac507e67eaf63822310103491cd26fcae1cf9a0392a832ac015d7cd438d785e89ac5a40d4386448d900a1465ad040fdcc6b37e57e28b9d53bcb3d46564be504fd6df18557480e5e38e73350352e0f8dff2049236a3bfe2aaf93a5665570d05ea4542463ee5506288bb9dda96bbe39b33347f20858eefe156cf9909a837656070eabf0870fae88d587b2637d5d94389ce90b93734f3547950ce8a4bf81b90990e86cf87397f0f7d717a5171f4100a51897d33631354c53fa7f2597b3088287ead72109a0d85854a3b3eec21aa9f5133c69905efd3ced7d461b891cb1c656b671dea192e193bc8276ad40b9dbc308f5a0ca9e6c77dcff8483880001bbda01248166219d78be0d4fc2b8f1edef36f69cb194600b9cd113898851858bdd6642b44961d147e634b63303a889f9a1e6880a2ace48b2fac5b7d25beafd3f9096f7906e2a94a7114142104d7d9961f784ef9bc0b4c2ef93923a5e1219044dbe0aa2369c0575ef1b021ccb364b449119ed40b7f860477bccc54fd3da6c6e278dbae58635debc22e70273ea429838e15d492b315129d5b7cc52942a105d60518e51d5691fcb90055a898122f9788129c55c229fb872cd7a0e3004e211add6b4da541aa72823922b8675efca765abca419ac5b9e0bfaeddfdba60131e398f4068491a3f6020f1481d73306b927d65259cda96594968a9c93b22a255e1310edc85649d5459ea749cdae09d30322dea57c383c1bce7c8d9bb96569b262bbe28829321729ff9614155a76e7b8fde37fcfe8289fc83dc424a4ce9bf02c7b78cff67362ec6eac5442d7f511e209c1d9a11852ab7f7718de0201d49b2f97d5df520ccd72a95117711baa9e081936b73a796b051a956739d443c0e415971489a2f4cc35ebd8ae9ce0a9903dd9128cb3efa42f4da932b716a1cdace89ee29a7e09b96f340b8dd45b3d92ab9e33f411713a3e4586288dee70b871c6992665e02fbe338a4530965ad43cb611a4ad67f1e0dd96203046c474495256c0f02953baa1507ec48e88329218ae6e702dd9a8295255e621f63529bc941f08157e643eb2da015119ceb0858516cb64c0bdc295b41030f202ba6c057acf251d6a468d13214b001a55aa028e668f4f7fac2f442d1b9df6cae4e66eb351e0d88b9cc0d09e858c7bb6916225a552dcaf91099b3efc22ad3fd9dd04d36991d75d09727039554f8ef4417dae47cfd7f62156a6218b16ffb5c2f2b82e13e4b47626f6ea46f8d021d713cbe82ef21a1e399fbedb7a16073c649daeba3a1490c6805050b38b131e367f1ec5445a540de05c13d6b573c860bb21102e3afe679bcaabf755d30219ea360e3c27e785e967719dfd5c7c15e7e00f3b3e84cf51ed7383808cdb598675efa979ff654733f5d280c1a0dd8e9da97ddcb62f29399094b1e7317de0195318b8eb9ea44c61c9780154b89e703198024526bafe04d597f74739e61b30841c666ee4120a4c99493c39001e7961ebb02bed3d17550bf9b0481e8dcb76984bdf1dc088865b4577e2a6ec14beb2eaf3f44269f491f0b88992f5de693aef158b10badeba9af1a60013c04d138e10a1a4a124e69ae2e70256ae5a79a645b328483e95d7d02fc98615027e0ef909d3b0cc1cd7cf2c5f10a4eda6d71aad8503a41568c0eb7d0f9f3e526780545753a1414d2f107742c61af521ee3e094f8660241f0258847c65c605b7c7e0ed7be1bd5271a241f78f6e697f5191b7cdf2b3b4c1ad30279b830254475d51f31232785a2addedb47a31ecc959a4b1db85ff9e4309d7fb957452e48f0ea7a636bb80b81d08681f394d3eca4ccad8aafed6da5b0608392d0b44b69c63417daaad367f58ae4c297e52070335aeae15c4ad12775ffd469b38508fc4924dbe30c07c8d4e7422d6563d51bfd21e9d1ec0d24b12fa7c0b754dfa369bc1174e94804f4c4fdc37da0d20ff35ddbed1be0ca926b6941f465efb06904e3669095b92260dc9c1806357b1b8cd07bbe6ee25a40c490ce50e82777ea636b82485d76b58b4051cd8dc341976e0908f164d6bc9f0c9a731cb26e137a0f1d7d97d82d9e62b4b301ca22cb641dce306c233e63380c51d1f9dc669725b33f901546fa02de710840e78e5a9095445e7407beb765ad36783f884086bedd52030f45ef1f24c5b1f5f33f9b09ea51260ab7f111e4c6257051243ec274a660e7949d82c66161a0bc27e98f77451288ba4d4b2761fb8686d820aafe4f276b1b7569af3e4489c675d75edc6b23cd6d88f7fab2ad7150e638781c4220b37c05165bb06057b501380d97043946f21de876cb447884888c40233b21c6daba1d04658691d18915c621b233317d9dee7c3b17286d0929845dd96d78dbd75cf02f6aebe474aeb37b1ddff90b4120115354841e7e087db0cea355490beb0c9ef8d67298fbf4b4da601323f11ccaa388a4ef11894d4c60bbd9b53dbc1c87ef9eae90d3670a70d7fe5107962d09f0f91844e1f035390c03bfc74cc9fa30de1ed2c154abcbffce257e26f61dfeec4461496b0318227f3e8c9caab2447b0d861172cf4e6873cb1ddd090c785ac9b39646f8815b2d71fd1bef1d90e8fdc20a32439bec016353551ce0631332e664d04e29a1c41a5f0ad9701390e049966fd4934e8dc5a85ecd90c199c345a9508ad9c89f357dd64b2f02bec85de58cec7e05df4182a9f998f4d40ea7487832f066fe37dcf9308e845e547f1d576d6fa4e58ea0cc00d36cc161f3af3206c1c45ee533f6630c5a03820588fab5d89fe9366840c06b273e385e41e47b83c59b40094e87aa6890741dfa8163d2e942cf9da1d78f373846b1b746e23a8896d539f27bf3d4d5d14be3b2472a929c1e9a6cc3acb2f4cc8c4bc430744264f2449c8e6aa230ccb4b2851d5457eb762ead66bac87ec8a11e13f0dfe5a2f47dba6fa5b593d6d997300268ece8cb956e04ed09e1895264528e9c7ced517539a546f9600fd6d9a07b8e48254308931d53f80594d1547dbbdb90413ae42d3f8fdacdb17f74287ef7f9637bf14eccd9e9538b39c8d8e0b5298154e7d26e1471b233b94e308c902e095c4adad09cbde109b9879b10dd1e799f199041ab61702be27b6db1525328f4d1ba8353e2e5ee288ccb67f42a62f2585156dc90f5ab1ba8192c51fa2834afc8cddc359876584803299dd3c8e1bf8612ab92c3cd7cf51c9e69f64b2f988e3cb30384c59e59194570b1b8e2ae341eed85ffae3e64490f7d0ef92d953f9bf0a0c9a72e91d19fa7c3a0c58eb5e165ab7599994b2a6e6b4c39f6da29d1be8117223dfc872998f48bdeac539d3b171a572f67570c36de9b699d09965ac43a13174cf0eebcf3025a43466642db291b479d2adb22864cae96b17dc86eba29172d9274188aa57c2c706646ba04717b195f7d3b0dd406f26df55ad1a6db0ebd3433fd476bbf5154332d09da8b004fd4ed0f8e1ac07a7a4bd8fbf2078a5e3ba7b857009c80ff5ad9bf5d9b4070f868669796797007ad3aad8d7aa67c1eef89c072e051d45f5176f663c37727490e9acd9b6985119c8b682dcbf9be8b7a2d04f6adb46526d591046ad4fbc95a818d0ea2295eead9c6cee26b9403b141a54148d07a44966fd627ff9c8f7958cd0105e20e7876c1c950d1519f62c4cec56f94a074f056ac8e343586b90bed9f091d3f65bd3b04eb67e617938d8c2daa848acfc4757fbd9b29497b62d6fab695ad7671314105eacd83a8f6a899c2e629c17855f72b0723b6fbe131dcf494530061723fb9cd952059434616665ae3193f4772417eed1bd359e95c981cc8590ac7dd2cb299e801ab96c851de6c9a87a9f313f9b38ac6be1c48c8587d8ca4304f265a5120f0e9fd658e4cc7f1666b9a497cf927f881260f3f4ca948e064997e732dd5b072d48422c464b2d9026bcd25faf6627c04ce00ce469b6023c6bef6e0fe2ac370555ead9c08b949feacd37346421ab638b0bb4f887d79cfa48841c2b860e39f7ca3d05584fd590c6caa75c2b0dde125968f23c4708d272165100b7feeace40ec67c05f6f513145d7e029ba56a7017c090d257969af40384670ad202be381e09823bef0951ef62a5ffe3eab46b0daaeed17eb64c2f7a8eca45ab5187ea3c2b4705627b6cbcaea85e9a4061240393f1f97251cfee56a9f74aa4e94e57b510cbe06de89fda69ae9e1bee212eb5d45dd23a6cd17cd18aef97126916c890535bfb73afd22acb72cd3585d2fe30e2102f28d7d323c336a0fbcd483b4df09c879abbb39e22650b7a84325126db06b0588d82d354bb5b7b0126a9c5f88c87323ef0ad349514acaa941bec36db3892424126d8696a32ccf910122482c93a81d3de3f69308b37aef7c96404ac83b0208137a6529edff7ddff88e8df1f2a8d5e7b26609719651ea710cbcb37f47524aa01b28d9186931334b0a071b7050e7fe9aa31cdcc0a77d4d282e2165db4b5984159ec018a98e6466c9aeabe7a4619420634dcd3296e67c83be679f3aa8523b945da27dc6efb5fdf1228722c0c9aa56aebfc0dac7c88dc352720e8c96835c425a03452873730f50cc9caf7f47529b278b46aa79fd2341d3ae1bc93fdadb536af9624bef0a9095db607e94ee179a988c48cc659ec2aafdb41f5e9bfa61ded9ed93d6e55bf755039f452d20b31ef3ecaba018bda033632c421ed4c0d72b199d7477726dbfabb4d2a1ad8af8b747a6d9ae4c39174503d498c94a89a8c172af3cb111860ad8f00affa4e814f3d58621e51338e28f223c0cb07d8b04d0319069a6aca153e1ab86ae50b28fbe0031893e47cfb06de46a8ca11ef68671947193f032b5a14b375f846877fe996483c6d746dfe8ed352439265da141fb80769465873da476e37655008c341f1e6421add8742a8737081f13d583594a240492e457554daac764b584cab0075220f6f4eda6f983b5f325f5c9e34f9b475de7a39ffd5ff17a2bb1dcd61bab33b745571bebd05ada5205c081bb5b1475f120dc3c68381a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
