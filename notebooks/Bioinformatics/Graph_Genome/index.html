<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bedd7d236b74689ced70615e1fec6a2dc242c91971467fc7883eec9d6ee08aca38dfb8bc3b7731dec43ed1c9e0ebec4e7819f47068840b584851faac9a7c488e3b0910ad4c52bf1faefdda2a9f6ee700dc7764f98f0f887b726da774bbe3270d94a4698cbee3a30c6710490ce5712a71b9f40b966ebce03d5d911a9bb2feec3c2b0a5eaa382fe07f15ecc836840fa321235daf8bd592ecfae5615edf5d8745312363780dc3b230906216ac90384bde47585830b1973821945c7a28feceeb74528dbe99546509b3734309b0573272c46da8fa1fe71552fcfb1d5faac79557582cb2689eb55f284fd36fcee953ce5a6a1f22941a1479f608718721fb94428c011f1fdce408999078dc072fa565b43769d337f7ea00f0c2c67d1f318883d167383e971cc3081cfbe2b17fd029624578debb738fe7bcb556bf767b51ed26703f0bb0822c5a7c6f8158c55b6197b4a2e430900959589bd25100f89fcc1221ef11831ad6b32ddf387e6567a907220f6366783223c7ac725df589fbc9441536243556425837fc857f139ea694f8451424f0785bcead9078438d12718108d30b5cb45a9b472775414dfb550cb445df1267ea0b02ee3e4b93986ceb04fb74be404c356acc868488777ee74a3c013a90353c0078027e1f302a6db45e1d4748de6803ed52ccc3ee3fce811447ec6b24cde32647a20632102e0241eb29c644f2d312220eaeb83096dc5251e18ec6a11cc425387b716f42dd4fd9731a4f79062e1dbb675eb8b31c423ea83bfb0d6857e4def5a4e377872ad585b986b1e831fa97ad15af6ff85a8026ea937c22c30125ce99868d49c12dd47e9f538f2fbc2790e69f5ec6ef74c1c0181087bd47686fb4ae2e370d1654df05dc89d0568fb08749aef0565743048d3b492b90b69aa560576e4f2d5f91894a68752530338bfd3ede6c4ee565c98e80dd00752633a65db4ed8b9398067ea8b907e666c3309e0cc6e92b1b353f151b1ceb6e951d76ef7fe8af200999fe7d3ba09b24236c6a966f388d979355351b715ecb276e333b55f18fed90d11272cd622539dca746c86b5cb67fc6a049e2792ee4288897df500a02abfdb80acf3dca0f58aac999a0c4c0d33026d17d603306200ee22cba07c8e90e61ee4126ac7328780e8e37d49364c46c3675f1d27e0c73f5738bbac0293ab4690d1caee04e7e1d10e8c724dd87b33007b4b5984934901bfe60e3c3fac872fb36b0fc183c8e84a140ccb8903b193bc86b938e7de584110fd57a685c43c0c49fa876d3c804391655d70d2e4c3074b2d224e5456cae0769fdbf183fd873ac410dd8a3bdc066096dadb3f1c517dc035537cf68ceff14f6ca3d6ccd968d2560ebae0310b22ff2280b2e9cff002c89cdbe43ed9cc4d87ee9332f9d3b3d90d3c579e0fb4d3bb7cd5cebbe708ab1d219e2085f16d329a2aae11105f8e14995f8aa9c43f21326adedaa171a0bcfa751d5afcd277cfef07e295bf825956a470d75fe511ac9610f1bf5ed4586428be55bbe7b35b98e5f81a565b854b0187f44e6489d33482b767bfcdf848e9ef3b5bd55bf58ea3572c5da2ac13f5800a163ccfb5db56eb2c281a3fe09fcde6aacd9eafd330e3826352dbc6231c64b44b47bbdc81e20b92d6be123fe37b39067d773b4eb064a518efd148821992c7f1cf7530c75ee13ad7787beaf6d8f2183a4ca660fb7048cb483f34a87f4e9e134b42d6600a0b252d4b529a23bae989c888ae8093d531de5444af519aa8d52fa62c40ed17ece74244c571ab2b163745169d13a5fcce72cca0ebc3c7f68227269a2e9011b597abcad1d2424de1c69dc97c03ca3bf365d8bd39c82f64d3a8cbe866bc4c46b408d8612c503a9e705f2f7c500e763380036de09ad3bb0d9e34e2d1fdce8e5b249c09e708af8f4103cf2f9cc64cbccbb89953e5b9971f29df8b35339d0db515f1f449862378965537716c69a1de3eaab59fca6aaed58c4eb8a4c1da7cae590a3ae5e7f142aa618ccd4a0db832756e43a49a46ff6bb03af09bbb3d650492f63541af11eed6f990c04910d42d84ffc416bb0f82e975c5de9377910ab62c833c9f9ef05c8a6412090ebfdbbb1d015741fe45d78185c228e3ff0389ba123e056f691118c8da261515c1466946bbc839bdcdc13c8117d2a1b2a6d3d25acb368d8dfa94ffba25a2a2ab4f71404eb0bd9d006b4968e9de56c412419dd937fb4276335fa637b82499606a8ebcb09b0f3539255de8361bff9185fd69a0d0f38002e5fb6c9b00c8d0eac0f42911bd1e08a8b2084a162e5ccdd080abd13063ff8d998fe31ab91cd731b54ce8804796dc536e67ed77514ad94d927ba56d34d462fe9400a5250e6729953d30097051618a1fb45d57363658c4c8334e02efb43104d328fe26a082477e8cad1f95c0082bc5a6251917de77c066038c3fff04f360dd8f6d98c02629c74b32afc0818c8b91e9067ddb2fe252f5fade94bfc7aa25c456a022ffff9d30be29694a929fd0302ed0269cc3bbccbbd64d00cd2ed6c254abedda85601820a23a2ddb16129e792b439c806e8718fa1f814cc58fa5bdc9e790797faa220e012f609c94594c9efef28f557e9fceb5080198407c96bf52990fbb74947d3b5e68753c84555932d77413ffc2ac8f7ff8f12cf362d0e54b3f533f6b9891d9d1c7638d2922130ad0b4d4eacf3896dfea8a0d5d59b06b4a59ca5b6d3a643a5b701c3d849967ef3e7885c314fa9cf1d74f7e89246b6601a3cddd96049233fb9bf3e719ea8ca21154d99f7dba1774ab430ea543a65163f2492f6dd1a75617b609b445d7bd474727be6742a20886788e3e3bbd0fbed24f67cfa416a92bf607f998bf4d79e71e7f97ac484f4457dc2017ec0f290fde6068bd8df86f054ea9c1d43bd3472061f0e34ac95fb8b2e9d144a47d0115e180bcac12dc5051de5366d53fc71ad20c05064fe8f90aeb740f3926bd57d4d3f612cd31c99dd3527cde35ea2326cf28daa370944aac9f0cfbf525c3be72ed86298f4093ea5106ceb00e96a187a705c97bde7341060557fd2c338e0ab1c8bbb00cf1e955680c9412c0ead0f948371742495c2cf29bab81b6ebdd3caaafb07081e313d6733fd101090892512b6826c3abbb3cfb527e9bcb07c4812ffaf7ec9d876046a53b80720074062bf47b634ebeaef202ff485ad57cc9acfb99e203381003c34038ce5c967107f57298b10018948973e83c1a0539f7a78d6fce6c1c4c3a0dda2ab83a687a19bd8b562df1ddb45899e9f0c98a1dcca341fb928d479dd4ae1c96deadae390709b21a4d590362d7af593376774704cecf48f8bf04c7fb65debcc6925b6e8a15c2ce99c92f1ec1fbcc4485ae4dac6416b70c3702e503076db762f60e0f5f0551d5b88f0d423bf8f49afe9dd1077cc0564bfc8829aa5306d6aee89a04955a6ee96c92c3cd9c7860252ee1a5cce5c0ed6a2096ab8a6a957b2d43fe2f99f49228e92ecd9f93e8b73a9b7ba64dd3b6124a85d4c53e6ac24fa3937f575f0ae1d7d34e0359f730e1d4793d85c8fbd663b1f266ba980405a342b855cb56a0833fb3522e4ff435f1b1dcff53e8ac4f59eccf755b93bf6566daec1f6780faa964524c0931095c808283ef7d1bf9295de087aca935133e522435cdef4fc2bfbf9c136f50be19bf259a10db4494862c633cc66e972a15fbb9d8062a4e81cb1e2786cb4f5b04b852630d0b2a40e6dfaaf653c333be0badc7ac38a22253dcc63a5e849b870848b313d5feef572175f9abb9c16a340b7115e58202d92a44273650752f74cd7a116419f8f475a52e579d354597fb9badb31e6b2d81a4c80e53afbae4eb66b0b3c575ca79d7129fa0256f18ab4e0ffab5764b12341b03dcbf3e2fb8c5043e6d334d8e79ef7028603a401f9216f74a84f5a2af6cb8701ce7925c8432f0a5db79e45cc39226ebc26f79187daabe79e356e0146e8790f6beb683945190436523f77da5ff9cbc0a3d97cfe8574fc26181cd1ab500eaca04797757490d3091c90479253505eecdd3094c389e2de3ec9de94f34d223fbd30e649d701a1021631dfae1e8155a06eecbe1e879a2f0764baa540cffd096a750eb0e0b3cd2ea39507d461f01252b2eeccd014511ce04ed171e6ee598031eb815270bb753ee1c83048460123bd9c60d76bb8184864eb55c577d1f06a8fc747d075dfa23468c25e3eca554061d01615a731b33c86ea77b7b7518763d8e6abcb8ac081dcdb044e313038b658863141c5b415c5d6a541523bc73658cf7e19f8dbd09c18edd9d24d68609952962d40ed1a64069a73ba4820f2012d0f817ca0ba46d36352de70414607ebee70d51e5a619fa8b13e2765b3fcbec02036d4ab8187e9d116452f67bed35865a07a468259010613ccb4606fb0706432d71d6a1989b7c33f02cb04d99e9cda211e8fec0ae6874d32d4d020f76c6967bb5685e62522a6d2f8dcb8ef56e41557765d51c209dfd0f56a8b32158a467cbf51e9c13f95ad03c94517998adea4e67d474e93021b8f2a8971a9a00d095c207be8509c9f4eb3a72a0c86e293fc7826b9232f84e81835ab2e648121503ce4d20bd8d9129d6c1ce6427673a6577746b49ec93d966733c0dfc3681c3aa65c2dcc5486521c41222eb41c1af1909da593314ffa3cac8db87e22f1c829d9385a244f79e2828ac05b88e6dec18d0cc32f3dfe0749246cf1a0c437294ff9a06176c439e48528f8d54dd65ceebe8137ca5adfc32d7468d0d5cd07d556d74b3e6926b361d33b455eb38f1b15f0babe14ed9dbbcc0dd77f7bc275da8452571869335f64c0550c1f57064b7d0a65478d4d1a3716679c99883c94fafc90b2b4c32b0e33c2842ea7e94c97dae73490de2130af506dba7cbcb881fe6bec93258ddad60674d3b80b3a5a36867f2e078901195cae102004c54cd879c160e52a7c75631abd57c7bf8b6038e02891d2f452d532892dd3a5a6d5609e2817894848e53eb9c59060a3fff4ce1f32b85297948cad720627ef3a88e60844ec3ff9363a14daad8e17f2a34cdd8c8c661d54277d332cecfd23c233bc68e51b88f0da0b8535c8df0288fa4edeef5989b4f24b39a5dc9cc1222d6896443a60740b88c67f90e9ef40ec673ca39ae39ce898872f3a24e286aa2fb77d53c5e48ac4034afeae60ddbf88cd80c939ab85c905c3a4474322dad7297a9c9043bb73451c82f6ca8107f444210a7fd725cbbbf96f29f12a1dcac099b0cbd7b1566887c3a5c3180be46138aa70069238188edb7974631e068819f1b6b99d1cc38076332cf9bc190a796f4c99b8abe0c87200ffaec0325b659f9f18ac43833ff0dc1d38684254a54bd26ffb4e167ed6edb084c21b7e23c166f55f88eeb9d1ef54140ced7ba4ffd16bbd2f09d1aa59810e58e875e53b07ae35d4be47dd20b8fbe235c77e38c3f1ad8b330c8ab071589606b5b47222e518c76ba2f7796ad651d0557b5c1c608be652334cd4fc9fb35b3a1aefab2f5f40319d455ec7a05b6725c3a96d3c9b462af05a92582ad2f148c02e7525261b6c604d94b3d1ccf31c792c297eee2bedf9faa0cec94249d4bf8bb35124a60ce1d86797547b86cb73a513f3188176ee0902a3f380cba379a347ea78f0e764e6f9dbbdb5cd888f1eaa497b02900705d8a61ba93b4d70ffab38da87021a46cb0c144e94ceb9eccff2ba30660796c826011fa4404736be7ae0e025dc4a2cace95604c2d687a7913d93be18796821b277c469495ef47644da0eafaa69e82eaba96fcd220dfbba201f66faa02f91f32dcd680f6ba3912da227f3b5eba5db87978a90948edafbb6175fe253d7596b5f69afce8b645bdde2de43a01cb320544a67d9dfd8afc077b708792ead602255bfa6304b24525082a5437d8f1312a33b0c9ea4e0c5841b3c5f0350b9b0318818e6bea76db88fd698414d98f4e5df81a71afe43af98c5fa459e29739bfd6dc60432c53756fcfb6cee4de49268f945df12c5eaa9484e652f5523c3be820e4087a8e7c8d755fc146506bf1b7431b085e23d17c0ca7cbb06010437b88245b1bb708009fb4207595f2dc46bc998992a8728579e089c113042795d9efc39ac358ed43b4fb5df6d2464aae079c99f2f7f555eb1c006c335e9dfa1d8e6b6ab54cc7bbfeeeec909619e134c0d218875f94a89d4a70b01910cd11623fc15afcfce217a51e12cd1dc54ea00de7145a62ff554594d51982ce1c711c2b96433b5499dd93d21b0c8b4a5869ea38a2f75640c74dabe747f7c671064a6f33775db19f83dca279a3aa10fd841f73227f853348109db61c85b1d341656684adf5510d4edd09e6d24fcfe1144089045dca4284d812eb74ad991096263be744dd3980a3016eb8cf28713706541864b3d913bfbadcbe5049b0db72426a8fd8443fcc7b2cf5d40f69f461f076eb0b2d50a9dcd70a62659a74c83f8fbb06bc789b7eba01df7d0d10cd55dd38dd42c44abb4b890680dac7727afbb286178f47f92a6a078df370bb76e5859c667e36238a39a2ada571c94c701810cbf1216af70e2b0e00461eab1b63eeeb104269e67e0c0fc178cc093c6fcb54c9bd5d9702bdee09e2529a1f27646b074b40eeb2d3f0e817030e13bf3982e31330c808ebd9e2ef20d2ed6f9e767512c6881b1c19d72766f845a2fdbdfce54888c70ef3882817776a67bc92e1d2da001427632ff88cc19763cdc660f2c04b741a7fa6d6f2d7026b1e2c13f8596001dffd0b78cc3e1444468d34af854aa0d3203fdc4c44a294cb6ce2b7a268ecb2995afe1885ac432950684a31539e8740701600bb28e0c26f25a8b6e2fd1dbda4d9202a954208575b7b818a36a9037a15b98052ed5e8bd999bccc601319a87cadc49e7865b2aea9b24b5fd38e0f096ad7e35f6def6b8251c45e4f717e945b2db966e6c06561321622ebf8434c531f366f1bf3aeb916230773464db2c416b8002d2470cdbb7ff6719ce16e63714eeaf3f6aef43c5c7849bf64393702f1f3f872b33a4ed740423c712bdece7ea6f9b376e6015ec5e51ceecc124a9d9ec9f91e40b353f6fd1a2cfb36a68ba4a5b255b57bb02c592583e71a1d5eab05192faa09ce819b775ff6d95c24dded07e02478b3cca7092b9e56145948de974f35fc1c198bbd01650c786e0dde523f6a2b96e8e04d7d076e5a4fa262f974285efcf8f79c4a8b782380bdd05537f3752e116cff63a89db0884daa6e627b249680bf98c8321e509c0fd383eea72ec0a11fba1b3366cd81c6ed3ffbfc546791c1406f566bcfb7ef820383923e059a6b23cba98d630f6190a9d082606389eadfefb4c294de8bafb7b75de8c4e2a7b1d924e97ccc2e9e27cf67c41de5b142093b85e2386dc2eb6d843cf0e8f085d732868e13c8588ea33949d323d4932471ba9039bb06f316a068eba014e618fe494724d2656a3587db43d3c216f0bb33f9967bda97f05933b544a3702b5e5e806526676a585490d853517631faa723b1ff60d3f3bfa254bbfd389a95cf8e2c3c006858d50b947e4b36c31a0989f7633dec60a5d73103e4481a5a88b89dabcc70a47917bce8ef5f62f63e95520f1cad1e8e6503a2c580288b438bf8c1cf6c37afa56409b1137ad728b9665c67badf807a28f25e580d6b552498aa4c9fef5637879bcb05b8e7b816c8e3d0e77fb9c10198f4e5819064e89872424b27a99dd3fe4931be77dca2e5f83b46d4e8d119663d6ee1148e78e5d65b04abb2160e2493dfa900f66c4ab2ee90888a7ea0bd36de4003f233d7ea982895d20fa973d0438fe36575bae480464bf740630e07085f8f840528131bcf523ca939f7ba24c8acf86373069c3b73ecca67814a2425dd2f6e28d5c135bcdd215dd2b0088e7443fa22e704e1114597d7b70f41671f12993c6a3fce830777ad5885fef073809d70a35772281daa83a8931c7ff0be09979040a694bf156260892e2038975cdfd068f23a1d66a5af6b38b688a3537f2f5a460af527af23cbce4ac6c0737a5a512ded1cd925ba48c0d56043f0bf9e98c44d4f6f43f44eb47a1942ea01b0b4b1193bfb409b6d07d7e7bcde1493fe4ad69276c27d371c9520743871c5c7854dd1287eb352d79fdedf08c2cd2621f001cbe97ae46284156770e782bb0e528646be9256f6da4279fcbdf96ceface001a4039e69bbafed13c714d67ac9d5eae1dc44547b9d6e3be1178311b54373d41dc6b6557a812f8abfa9b203f089ad90870d693f9644bee6d142918cc0ba2b2b005c920496b916a13363b8756c0f85604ebe3f5832b72c75ad4819a3ecd0c3a620cfe95c40a724d1b0d4ca0fe24b0ae35c16b39f20b24c0b4c08ae6a28e6156f524323f00ee081dfb9cdf6136c7c0358cfd638cd83b3cfcde4c75f799cf213cb3f0d64f105a482d7fbd118c763f16e6a2fc6becf378b619b5ff621b8740fde00596ce85ca3dc242f208b2e25543f728d2614bd49506522eaf80c5661963f4e47fc042be105ff6d88c4de0c3c30ec8ceba477f59a75b69d400d06e44f55b62a89b88679d5b830f22b16a0ec5f759cca64631935c57989ddc245049f9ce13a6eebe14a349900d12dd8579502c5bb82e13003ef4ad869b6b447fb455df185907c34435737c99b095231773933bfe915551a5a0fd3b723c309dc871064e519bcbd911687eeeb2e4675a1b5e767a09d0da2fdc8d68251c2be68f3f85c30249e47ed9f8ea6e56c0aef2a4d1cfc8ffdf14972c294117c652492228e13e8db95774d836af2ab2f611f6fe8697193f5944391acdd0c91721474344304d19960cb301aeb349ff955a7d5fb4ba35c8fb333399c32bd0576514e816defc1f1978d65bc5e724a68efa6e6dd2c1b60ee339575ba06e90861c6f62a310037da354c4e055292968ff552426a95199b92638ab42d8320b4293aa13cc39ab7c7f46596a34eb77ab91def99aed4132db126fd5f4e95d8935618ef761e3a05b42f8ec5bb04ed6b0532687e4bf0e2a54085fb110b0a14ae07a22028e43f6d96033ca8197ac2dd7d328261b49a45826f226b30932eba81e6813146c7be402d9dc2910fb9c62ab438d3e7ea0a16b17e261046aeff5c61780b97f4eb92b34781d84a598fa8bebc212053171fa2a12f579cfdc79838d1ec4908222784b62935b96fa35c56040ec652951d341c8a2ea721b9769354bc3af35c336acf55b7cc45a04f1d3ed6a3800704fdfbc3e0c84e7b9a7d2c1487cb11e3853cb5c430f75fcc2eb0ca2b159a2658e4dce0bcafa449e597d07f620fca669b5c991855fa7ad0cb2a59d1b66688bcf05a779519f0120646fe8b849ebe1b8390652fa9fcee39083668360c6f6ddbc8573e70d8cd10179075b47509e4236c32c85ce0847509fde03756f0bba9150362e0e75b38532b0a9acb8e2df174ef15dd400b0926a080db1d7e1cf6b4e8f7b3356c7dec1d8b7a2aeed18394d8c819e9a2a66d01727b2a835f5e5c70d5f4e3e879d016edc8c20aac2d397769ac69bbbf29cc31ce8aceced958245f36da61c3fb77b43e23c937a9c38eff8f77aad1ed78438b1987180d4b35a31129b198891f7ff13a5704428702ed70d93915dc400935f1bd1ed8657098a22ff3e1b08ab639e711ee728d8b9085595410f976f29cd9dbe9d820a48109f1fdc2f305538474b139aad74819a836df37ff8ba5ac0bbde1c100d516e0795fe94e3a3d5a9227ecdfdc97a1ba12a434ee1d48f921cfa3a8d37c553ffe4a32331ca7881f7fb759098f5ec8d9d89103741979ca4c1524d32d99a81c7399408907188cf692527540d2224d9933aa6d2bda4db11be2aa345209298ef306da733bd0e5dbf6f4bdcab5b70383fc93ccf41d3a183e9c9f224dbc979eb06e9c9cbe0f7525bfb38778b84494d1c91efceccd4c3e2a991b42d381011baf8429918ff331ee4acfd5551c0a9800dfe8f82c2335a7daea9ce2bf40fd14d107740c14f06f13ade935a0535c732435ce725207ebfc86c3c0b62752cf435f528a091e6f7c880a7e41e916530521a2f89f3313bfcf658a59acd475a343988b6fb4d2092e906b15e77a1f381cd722ecc64a6ed17a3c3d0304a837081e04552595dad69ce3bb99625c12a61a6e03251fc73e969e22ddcb3b70e43eedd386c243c3f330a2ee86effb1018f0861555136d023136583b680dd445a29bccc3f7456983fab4b863fba871d94f1807d27a3fa028adc5f265124f9cfdec3a438a9bb5888fe4f828107852e008a9196c317a8d8dba21def98655a854d218eeda1a554986a33719881e7337efe4e1c065b13db77bbf96a0f46eb18ac1c05bba3277d76903602df5a41e884dea071f17381b98c0373a9c62c19efcda9e369cff639a8c13a559813c41339c1d10b3a471e27c1ea33cefe22359f2d5dff404cf71f461d6e8c535914c31f4715fe103826fa6c71546596db672441332fc4bd80a8978ebe23b1a1c28b59b57cf4f5f682b2b29592428ad3ef240e147a03bfe80b3878c75dae130c92a9e69a7b21f95cf21e65bf28abe262ade87aa66be5120213a5f10a2e8653e6e54159b25a7c411b5c8e614672ad1fe53b9ae4065b24b8c50ab394d07ec4fcc96bf99a3a2533c942f236cbfc271eec755554963e4d47d2d45e652dfc339c57f807a545337c91d59b803ade532e3295b884421127919a72b98b8fc38a2d93d5c62ff8f951d2f01e92898646fcfcdeaef05fd1b71edcc1b5c5649b7cdb139097b5cf9dd049d4103096de1eb14134e1bb7163ce14cbe960e2141a0c6e85ec8bccde0891fafb9118fc00d875fd96d23a64fece3f5490e56b08ee9ec04c131c29066abefcb5e46340d8ea963fb467e3864f6c79b9d3ad5bdc0b90367d2d24065f669ebb164d3d5df34341e783a1887879594d229ca5bcb537f2f6f54313aa616d5f4985e2fa3579e38cde1f604f4adb7a29f94206022b09bdb14a15dc8709104288c27c8c11d9372392c23aff597b5c63e0abc5da5badf444bc82b734eb04ca914ce8a18de114ad4cc146f0fbd810e0d4f42e5e4c2c58271399d525af196888e3d25fc335c818674b3b652a2dc19270d7af6644154b40203a1eeda7a4e1a23b4a9a9cc22c78325f1c058cff682c938570a6ffa5266d02a3dbe0e3724987d345cd0545d2d26e355ffdd326c1d3048898eb72ac9a5088da50bb06af1dc3e022fa89527c0d8bd88b985900b620a3fb924c3812e177536a4c99a430d2103a103147977d7e338b494569ce3d6ec16038c63cee61b4bc5e6366b68ba2fb65679df5f81cf8807c6741e990afad283a098efb8fd5daaffd2d72c9ca4bcea461bd3c2f4a152f7025206a7ad55a08d55d23d193b8fa096ffbbfefb9867682699fb9fab72b8a632dcaf99a64a84ae43bd316227ea631a0d346c4a50c798ac8663214e8b93c52286a1092e1a3be822f385dea2e007b664af3f0e2a8ae747d29f505e51953529479b47b5c0e4c2f5f276b290bdf064c6b0c906375a99ebb36e645084c55c9588880e2ba5886fc8b0c1fd63a95e155c1f9dfde3ae0b7cf3c4b5953bca9966a21f63750de02f6b99dd97cc99064b9dd4644e4b6ad4a7ed70da9b2a926b94b76cb56b28bd7bf076a3bfa82f82b02658c15b3cb82b36b3139f7151e1a279402c95264a14e0d8ffc2de1e1cc64d7ef8bee2ad5923e77557272356936d7c06c43c85155ad8b4e63caaa0147633733ee3004304dd2bf5690f7f53e2a45875e3b4a5b5f3a68243e387319de5924ba49b00c45362387d9b973445585bbc13f06cb86cb5db0e05cf84d3e8d062fa21a133b0d662028a4b41f86cccda09984041e465fa6fcdf38902a5dca2bbfbeeac97127f0f122cde71c21a4d4e4f9c7c9f2e2f453117d6a40a07646cc5528d7b1ff243e08f120e3d02232890cd2057f1809f75b7f4f25d6ba2fa1d21584a0dfd471034acf5155ba024891b515aaacebf946d35c0f84a47e06ba03de2746a74f9b20c55c7fc73f1780cd49de0fba2d5779835a84f5b085ffe748d538faf07f5eb9af8c1ea0f51a5c35abfdd9fc69ec306c6489d381f80f540a0a9fc5da1034f18aafb18dbe71e71ced38634717adff12c52fd0c3d4c159d0e6cbcb904498adf37aba4af1dad4c6e721c39442eb111da14c980d13a29cf8f15286f045ecf7f6f60fa361edf1dfd0a3ff6dffd58366ca59f99a070006b0a03a78476b0e240c3a2474941a54d338431d5f2cec817de55b162f73fe60011e0dca906c06f73615b42da927ade2b00f186d71cad8a97874c179046149799a061ee6c4a529bd86c842cf10b03dc26384dea8591076817ec31eb446c521568adfb194592d8cd6bda7526a9dcf8b3ee7cf856ff867a6bb59bab811446471e9f6c69a670ccf06c36620397ec25b49c90c5a582b16f2612328f42f62a3810388c7b6da86f23399b3683604ee0e4c113c724729df5e940a68db7d453bfc422f0b54bb6985e1d66f627e1eb7d1fdb66ddf9510f49b85a56c9c440647c92adf0e979b062d80cf3d64981724353316a02d64bbbaeb72db9f21c9bc4db859381d9bdc89834d91596be0f07b216fb3dd77f53e5247a81a2158b3a20492d05b389ae4ad4380defe17db67fef8c9ac5953d89ee3dfb1688901c2837d2b744dd90e626eee4b4375330e44c374359f97cfa762d1f523218246a5cfce0fff742502788d1862946bc4b520b8c51d20d9e08e112d82ef60a69edf23661f16b65c33b326d860715be05c0344ca184a619e50e0dc3014b1b75106a79efdf90338c5ba2a39f30924596dd4f117ffd99502e88aa58764ae34626e73d100487b1533201ca681931a43b7576089fb3406848cf933b54146790eb72882f071f4fd31fa07a9106f785defe1193d5758a8d5dd9187d6f5a73f13e7d6870bb37f8ca4356f1d0fade733444107380fb409dceaed609387ca6697b733c603fa7272a989e45f5834a3f467fc3b0bdc660ddb22a44077bbe87eef7483ecab2aa3209c8b5c87f2e4a3ed82600745c3d73cef5c3ead938c575fd9c6eb8904cae73a48ac173ad8ff59d35803b3a9268249c58893347f44c5f4961683e3fff97276c71396becc849027ded2b50b13465fc6fd0bee83da4b2950e56631a6f1c35a4ca6fad45d4c3479ecb11d0d82755aa8ab084207f3ff876968bb3e5a41072f0f8d76ece2cbda7cbe72051db7d6ee8e443f78485c9b59df352a291a8e4d890bd33834d48fef3488cb2bc8d735cece44b358228d6295b7e3ca54ae9bf296ee2f640574cc589998387ef723884fd0fa86261fb5e54762e2dabbfb899dc97d025a038d98a8170d732d94274527b94a43c13aa9057c7977aeb2c1071c4910d1b3e0d438b4df9dc943cd2b58548c72e3465e1275c6ddc1e11ffad3e201869e9d316f00539b596a122bce95441734a02dd41f9d8e896a197c8122ade593863d06b3761e1d4bf20d119e0f2451f6a173664890cb9cad22df12630eb89c7e10cb1849c5a81c8aaefe26af00ab78f474eb8a35d95df5e211657f29ad13b61e7eb4d6be3cd88503dda2ab7b1e2704ecb0eb00eb35eb0de42130fd4307035437ccac9b094e1b6f4e38e59e6cc342f13b8e93a30c6a0a4334dcc0c90bbd1fc0fc0190d6945fb25e33860f5b20976c2a6fa03a70eed8d1bbebd8d139e77cc9282d37008b97bf9036a9e75aecca3f6d77ace84df6d9cf2dbd44151d947260897c8528f2236b1bf26c22bf545e9c56faa3ac817b9dd6926313c090040147b260ac0607f07649e0f17323e5d831f438af9fc3b7ff994a5ba38b725be6e965f05b0f907dcbb5d2c70f29a095a6efd9989bca92c8c29166dd9417b47db58ef381480f3434909a4af0006157bb5b29cb810db1e5b8c5a0118daa3dc67e56eea351c415faa0c9a11cbd063bf10cf0554fb7ee967dd71cdd49e2eda7a92e0333006665d6196c101a18ff00fd4158d7e9d0fffa02895401dbd9f79e320132d1c2b00755cb27a7dbe317e3b0c53005dbf9a956ee3af140128571fac7af75e8fd9380dedaf86d1ad21066a32d5719e260592e58ab712c84e3804c11a47086ae1b684bc0e0bb480914219b676471748ed0504e668708710266e9d4c5c90a96a2525d0a66389bf246c4fed64bc03b559cd9c9b3aaa4ab196fd74e77e28b4f4f02e048fcaedf8ab7925da684abf54d9bacb287984c42596bbad063e5d568a29271cb8c10d28b06035d276a3be835889b387827db0afe36a4d87eaa73596b247f40024633d019c3bde085c760491624bfb5c25fe075445c464b309f573ac5b0fdd51ae225da8760ecf746e907c96ae4dacf19c2793801d694a44c3647fc92cffb67edb2d0168adf794dd4d261be4d2ea69d4e8d50bff60699eaaa0e58c6b86e00b798e85dba61e38c9465761408100c43f0956c21fd8c68cb7fef03a54e3c7d8a8f5f4442ea3a7694da5fa40b7536177457368e5a9f95f99388d26fe134f2926eea2351ade9c034ac85a244f4c850ead5fef5af21023e79a10dbfacfb48c12cc5472c984933111c1d2fe307aa749b3ea079d7d48a9bd70e033b0eaeb3857deffe7ae255ed85f8762b5cbc68a540ff719e08a448f3466f2a14d00c338e55cecc9feb44c988d6d0f4f1211a7093440fc0f5be7fdc8cd2d57616345afebb66e73649c9c1d287a5e80e05208653fb8795db2db9544155fa6659a08071d1142026061afa83d89a5933b5bae3d29851b452f8f6dce088e929898a190a49f5c1be541c5c2b25e18ad3656134514d9a6fe36ffce287446b4541381cfb8d28752134f90bc36f67b87685bb64ca4dcbabb87ebb4c61f750cea29d96238d0d12e390c1eacf4c8ef3f6c22f5a413a921cff46d325bc9c86412f6c288f72caaa4be2b5e3c98fe41d753749a427d25fd3486756664f8cd6eb68bb27b4756fbaec1afce46b3ec68c30d38aed77ceaf3407328ca8c6b1c2b5f79394f837cf81cfe9b537fe03853036299ff6429e070cedecd87d486c0da437e7e02abf8bb42ba5994e3b76e5ff57c95abf4092df79cf18ef652273ca7b09e302dff242415120397ffc8c6f6d74c177c94fec02015632d014cfdafda78dad2159a2aa99f62637efcbb71a6b1afca86fa4837aa3eee0ae0c1f57abc16e5f1bf9a88b4f78bc60366a1ca5a61cd581118c885ee02e109d26879814cb2cb5730c32d9aa9e1b386a13379700d6542ec2d02b906fc31ad2937cfa47822dca952dbd77d1b5a565706206eade3fddae45406da31fdea817564683da992bc6f092af8fd4e47c7ec6329ba935bfcdaba806805277b572a09ae47d6153cc0e3414d5e1f90b1f8353aae8b7326d8241abe0dd774fc11ad1e41e585116e908bf92d9648ae804dde68352ea782e34cf18702428d59135f9befd9112d6886a38468eb1450b520cca29b949d13cf485ee1b94fc3b63edb13cca89f9be512dc66633d37424ddef3e83dc098a41c08fc013d3656273e2004b7a9e617882069437f7c16d84047c89526c5eec3467054c880880487a859419463f50e9cf430b2983e90903c1cedca8611ec2dde582b33cec3c4779212df229b539180e53ea08c22f55316a211e2320284afd5fbd8437dd860fe48970cefa5d2a270f4a795468f78679dfae90004a77768cde7eac137fc3dfb7a302d00c5cb4657066fe2eb954edc84189e182abed6a35b7f10cb695a2345159f70261f70fe6e119ca6d9276e66785e799537db504eb3dd31ef4bf26bb2ca5e62bf79a91485bc446ab22dd3885a01fed323ce167014ce511192d498f03a0bdc8acdc15569fd99d4be0beafee0f51d378803846edfca40d452c995a83791014934d358210598494f60e6b2c6e08119fd6461762458587d5141462982f6c493c6bcdfd7a1aa74de436eb182affc41f9e006242e6785c604d4b135a10758af60e399efaaf54471835ca80d282bde4c913e1c507ed6c735f5e8ec1139e5177d8923e3e9b2544d45a20bdaaecb992edf37e99e601d7e24805de29ae12f9ff84973e3ead6a1783f6a8f1b7d142f1008536ad500fc2f62950b758aefca875f56804c00c256fb0b406cbc54fece83b1161b57c3aa4e2819a7579cf4df5f5ffc9c68893a2b210cc4bdb729790824a7ab6639a5d56ebb593e4c5ef63c6ac0913fd05e6677709285d7605577d8eb2a37a210ff2fbdc768aeaa228ad66ce34e0d8b2a1b7a426dd50ded8b868c96e9c392049166451e450c7addb626022d9c954de7fd39bc4cdb9032e03c5f297c23fe9acdaeb945271c3533b46da4bd215109fcd6ea1fe6640285f0811ee56f576e071555552077a9b2aabe9a0cff3b8884b4193d2c223e56c1537a257763430c2f71c7e0c0d0668acabf81c98c0d38744ed5c8c7a76434dcf422c4af96bd4169b026bb977d90cd95d87940a047462d55c148814d937864471cdb39e8f8ad14e3c31b77cddcd951a85d45062ff2bbb36159e38a66c3cdf711646c02d41006b324768edccb9bb27cf051bef20169933cc88cc2eef91ea1a78d69d037c78c1ac8f662b876123ab55a2753568708a10bba420aafd0be55ab60f8f4d360e41a87c11074d2ad94a603055784ef7c4500ad7cd3639e4afd4561564c863eb7bf947d66750ae5add292a6922e52ab608f392fe55f5ad1fca760922062925598ba79d1ea63ad0540a820a180290d86045cd57ed922b276c11d4bd62830f56d744122c914643b166cc0566ae9ddfa3af8c6bd3ca39dd71750d4c35ccd79198f1e0967436f40ffa3e4994e83becd9e1681daa05a6d0981aa7962fe8becb762a28da0bf257e71ab10af4c081c1d28ccac56b50ba48e1aa9cc927a9018bc8992f6bbfd12dba23ac2c549af32b968aae25673614568d01190a8cf389b8892d65d7ee701f755985731bded1b953606e967c78355aee7b2052aed5e37809cf09871e8e92b28a57494f83d32582aef02924feb5ee50405213550c9d109a22273181abf7a5db1124689d82fe6ca88c9f621a5515707070feda738c92f7424cbbefe5bdb588b9ee080447543ecd52d8b9e5cd10e5d02fe9e3bfb8dbcaf1a5ae40d098ce015df4f52a81d1b5b06a116358d5bab2bbf2a398195abc9ac20dcf5d2eb59488c97b69e8720c1e8de77964143f51a6d34ef5778e4702451065911d59cccd0ca8caecf6488e610ee3bb3337b1bb5a1ae7709ec1f37ea18bde23556a68f2c5578ff9329c93d1473ba124c5ebd6cb7d0c1d9cdfa46e0905778f07f12addaabf4148a3834aa223816d1c61faa1b2736f4a3d02ee851f0292e175ffb8e05a669266c44175e052705d58870a42c4ec3a8f19ce1e0c96d2e47d757a81d8845a3e852fc3930c137587d5ce23d3acc38450a180ebd822cf0999b0d5dce0131c4de11b9ad5f3e3a1c895cff8b75d789761a1e192ed924f3499c7f84e456348df1dacfe2f559a5d6b040bf74e6f0587a0a565991d3ea038a23e960e97616b1f5b60237b0c7beacca48897109f646c7b1180902dd18ba794e87706d902e24532e640c4cdfaa2fb0ab8799ab360fe1fd0acf3e7317efd47142768e987c8d263a7521cbf6726035e1ed7807ee96ced850650e64a5ec72443a80487b1e4d39dad148d817b617f38ab17f3db0d4779bec4a307a0c6528f0831f03af732a9ec247a803469eae8e2e7a9238c2df62d1cb04302540fb36970b92c5906f083f8222d6224660ee2a8f3ae23571b039a9f4be2df2cb86f2f5ac87948e6a010e907b332e768b15e7e6dd7427ef38764941375cbee63126f3b471db0abab6c553c979f24d3ec2916805489ee35c5578935ec43aa8418a274e38c08b515ea864baa34028813205dbb6779964c2f44e7157f49a5b938ef1d21f3070df835945bdbdcc0700da5a3c5e6638cd14e63d744826a5c1382b13e68584ea2eb3b01a49ac11e42de88ec50dc056b344c9c939ee6cf834441f198c698433b850bfcfecfed86ff3dcde4d93ee7557c8c60fe29f72e885f0583b8c47331630d27446de76d381f2bf42ce5851e9d04e7de9de0560fbeddad2ba3d71ae15d39e676320c018f3fb71790e94623311337e5fb5ea149a5c929657a16b29972f06bf601d7fb7888e6c521a5fe4ffd12effec3ea0dc27df7bd7f0f8a48c4d9a0f6a1720a3177d910377a514d70cbbca5d8bdf5e3fce88ccbb7cd8286b388e902a95936b62d162e8701dedfab2cb04a1f5fc7fa97784e188f4cb4be237b0f71c76ce0c2b040cf181db0f36d90b8559bb2833e11e9935b96417ea5819c21d6d3aec9d4286700cdb71d7609e910c39698ba3e4045e2670dbb7fa41c45eb0ef1c32c9118bbbcd5c2983592793b636d4916fcdfdb6070bf59dad9f9875611d96e75392bcd0ae7b3378551931ca7872da73b9caa4e0cb47ae339b6303e95c8c06b94c3eb280d4827d3e47d13bbda31cfece03b2eebda8a9f09a635b8bce53ef215cae42cf170b0b64df7f447f6f7c5e6be866ccff4cd2eedc6f711d4da833da2a37e60156f42044b93f156cfdad8a8528b710eda07782a3bf18727d5f9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
