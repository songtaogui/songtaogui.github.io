<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"122ceb57baa073b415c8cae7c356c262bc59fa5df512d507026327515d4c4e111a1b70361b0bc5d78a5d3832b21ec8110a6949517154a01e9a2fcf16d9b8caed1377290a078ca416a70179501ca6422a3b77ca45d12cf98f75c238343c4ff572c060e661af527dc25a784bc6cbc75babfc080310e507ff926521ac75adc579670e4575cd9c9775078bff5ff3067ab4dc0414a4db4985252a2b6c9d3b3640789d35eebd6255681f93cd103b1607d77e2bf56f8b5b75e801af65d3ed7c8310091a562113c0dc9f852833ac729d74ffe2fdca3b1f82b504284d71fe3a8cf6f986dad9f3c138b8e4aa8638f9da26cd8ec84ab4d4d224c38ee8b5b46b8fb8677d62d5131230ce21b5053b544ad9c87e6765bb2c63c43d4017e46987f07e521e7260f983c61fff2aa5622803d7d873a943a115926a4c4261f78cc7e18501914801fc2b2637f140871efba0d25bb93bafe6717c0ca15256fbcd1f0ed882e1beb1290a040f2756aa6748b4b656c4d99fb8f239db1d03d4290747eb0b389c0ea42a134c5d1b4cdcd0d167a32c6e11d0746dd2e1b130c245b398dc9838393487bc9cfbd7ea01667a9a114495eaa9e7cae94518dc0b640ab934e7d06ad0f960d8a0973cd73fc7b64ee0109c3a2bdec090811fb4e15cdee482eacaf3a81dc9e27c5ae4a745d3d96324d53af580c57ccf1d9f75132bc893d5399085af2d94cf2660bcb72fc4930c0fe8a2d33dd10d668f293fdebb649653ed1307f21e877c5c0a9afdeb1e0d0c10e19ecbbb73e246eb7bac1616f90b77fb575a9503dceb503d468b2ff841c58a598e13ed027f2f5f3fc628a1184a0e72aba97d5327b313112695398d9af6f88e29611515e0693b0aceaf44a4a1ea412bdcb34dfda12df7a553c84f21767533adaf2914ea1b5a6fe2c32b9fcc8036a0825d14a4deac28133ec702ca7f970ae3ce77e58331c08150e3dcf364aa9f2c581c6515ee3cae1f219c81b1c3ae1c01a201528cc600be995233a35e3cad9bbae26fc580a78fc19d97962d84cf204a9b6e4bbc60f8e723b2de1929db08be568d03950d7ca53dc0c3ceaa6c20ced102fdffb48cb1e9129751fda4dbbc7a0b9265f895756634c037e0f72a4cc94000c8d1cd6591f0daf074bae31eed7bf77d0bebf577b66ca377fb809e356abe17d0d43563c70f5356cec27f7d4f262faaeea67a80100ccb59e6e87144d53d93c1f87234a6245e6c72201e97a631f787da649b223656354cbde0d0d17fa2ccbe0dd8d5530af895747d130847f03c73975863f2d1c778229e965af73d2c180e3f843cd10c7c259aaefc438097d184d23f2783402536b3f61c8b9e69b317b1a5a806654863c29d97deee4d732e18e7370cb51d70a552f052f6682f7b10a2106bc8f1b0faa0118148d865864c3d28bac588d177508886c1b9c37dfe39da4afc87439d85fc284eeceb26b3c3a2e26b17bd52b04971120aec892075c9ec8cd86ec78b4ec3afdd2fe829698488eda8588eeb1798f4779bd2cf58f57ce69922edc634549ee2cc9b7e3784c5bf7aeed7339644721480248a8ba3bf0688022bfcf7af0031978ed602e2ad1e70c166ec808cb8c1b1e250cb0bb9336d5622d72633ae029d9c0418d7aa9ea83d19872cd9c08afe6d79c65718a19a808a6453435ea7bc6a1ec73fd9fee56146aede5962a7fd521ec821c907812cde1a249ed57681921cdf23051b9cdab78cac31b8ba60bed40938536ee8dbaab2a1dd922f48da72cc707dcd4b40bc43a6cbb34e56fb79e48a71a0c4a068eae8094377c7f7f59355ce026073d73777e984d9a671fdb28571e373a31d45c27818209aeb0ae2ed5584d08c8dec26e9033157306fcb264e58eabb7e0de81648ba6ef8f4711eb9d1b1d24e6c56500cefc5b3a9c30c275e8bc613a3f7d3b947613917670d3d39546fe890276127136b76b0d8d36d6c680d5ff4567915f996b435f2fccf0c170f48836c05a5b4fdc8f054e850dbce88b2be15663bfc5169b3232aabaf1316dab494155960d15f1e63a73bbe33014edf4d21889f88c9ad49ab625d39945ebd17cf0379e4d1a352103248e191ccfeed58ef3eae37d8601917eb23c984f171c46e44ba5ff8e9bc87afba4c8066fc4b886a8a8d54bafa463000da17142e11a51d2b257ae8d95bcacafff9652e51da36d0773da604449595cddc7f29fd39a967c5a0cab8fd5909437dc3169a89ee856bb2a225df3e68f8c98066901d49c8664534a90d7ae3a8ea6683dc3ee93bca147a22aef6e0721fc08b48be3401469d3c6ce39574e2ccc78e10922cbb0175d7264af76c33ea2018b351ab7216fed5dfdcccd193c514a8212f9291b0d3571bd286e5ee6135fae0aa9102edc7346cbec74704855e09c37c348c8ff8852f5e2e063e6c2a7dc22554ab5bad32b47716db5938605d3d95e69bbccf5b2d5ac3c7d4850c9a7a959a16f8a99cd851716b5257a1aa9c2b82c8838f7accda44a46799b8b8ac216cbe84500ef40e3f75d9d14a23c18564266acb01acac134375eb4776bec7fcc4b1fb279a51a387c026793063ce3bbae54ef6d339fccfa8922f7cda1f1e4c77dd0dc2e06a512ec5cd8422b5580273f63e0a8f63f28acb96a7a1add5d800318cda3228acb27336b04b33a48de66fb017d091179c4744b138ea4eeea0e41643a134372c9b1357c56b1d8f914ee70d21e508eea440a309507ccd54b07229f580c6d8ae8eabec19fae92bddfec72d4abc6401b454ea892bf7124b66e1d13c9001d0247787921418df6e3c674366470a4ee32a833619baa58e028e1ea0a16e72029539f51315badef5325694d1b47acd9f6c059d2efbdd121a4567ac5207ac68e4c077f7ae6433c38577d89739b9a88b81856ccec649f957dc0596b28226d10ec8ae2f550d2487f2d978ebe7dfb21f360a62ec7513a35110c1ab32b98f25ecc22929d250fc1b58f1ee9db828a259983038a9c1086c70ee8315fd4e96a086ea8ff5791defb8cecc0b0f10cd496fd7ef9f2f85a028bc52f4ce8e1ea27619324c94e397143de20095d0a4af5a20ca6c2e4d5af8edfde73043e9d2416322b2c50b673080b9e48ea22fc6453d2953677257c3ef8f1499aa18520d6225b9c4e4defaab21ed7a737223915f867be5f79d739786f1d3ddad026e804ac7973cad051b62061994bdf05eb8cff62102b5e876b6ecb6f09bf6b630979f8c92464980c075815902b4630f57cde643e0cbe7ad61c328132d1818bfece03cbb0a2f4aee8718a791dde5b1490bb1394933f97a7c1d86c08d0f546590827f92d9da7af1011bd2991a61b137c0d0bfefb5a267e294fc9ac877669789ddcf0336cbbbd684972f729e911c28b728ad4e96b3e0e81226966026cb889ea99cbf8e27cf5fa77fb04301eac2fa75de9bca1fb6091719db60b1e2e4f86c2757ead4049115603d138d93594817609b3cbdf342bffd282bab3f93280769f2c0093c27736649395f8071853ca0e0014e50dd8f0cb13005f398fbf9f23fd7c38d6e29d0ccd223533189ae1ab977d21fb8fe74e7343551e339d7a88624b14ba3a9a85c4a67831e61340b120545263da2a3b662402d5225ad60998b8eba3519fa25f2914ccf9ecc60954d31f5f51f5ab7b95c04247a6cc96ab2863fc1935debedeedcd5ab69d409da08f23c2eb8e407f6c5a02afeb12b0a1dc430f65f96ff9b77bc6e88b4c1b0cb81be246fb4e4093cbdcf02dd583e11783291081dfb403e3407e04075e3e8afcd3dfa8e36a40551234354a28f5443e60833e4e4a6ea461a44c3f30e75d3b69cf0225c32bd3a9dc258e2ae2e76f0610eb8e4ffa147ebd92060ec98bb6a84cbe7dff98da7913a4763bd7602eb56c8dca6d889603d23bb0e54aab36e66421b1ddb84d8ba3516997660d3840334b96ecf078d5663a96d53989501aeea4777053f12c271451b5d66c2347e346161ddde272f15f082aa1378c997f07f587b846a98154df89089223e89fffa209a1805539d66a585fad493f87cc6dcbef2766cebbe0772df9e7c5bf9c2eb246f0343d7fb3c8112bb08939f7527a32ed2e52548c8b903de5e7b65362e199ac1e8128db84fad59e871deb07d3bf89da1d6c1ffc55bba2742958b062a009e17de1d951f13508e193c2c4104b79cbba4fb7f6e54a648e293d5139839b9a63c42bb7952ba7b154879bcb5a4929fb3e5e4861ea0ad1d5730bb2ba8684aab0dad3e35f9b03e2a174edd13c93b636a33f162a9659c287bd784f157002aab1fd9d421223b6d0608579deff2820ff4a31c9452ba79b1609722bea40eee35688926d9ed983fdad6a70f69829b95d8f22fed4f156023844918916662ab7149aa2883bbc5f43941c4813e11bf79185c2890fb7278ca61579e94561852cba00cf6f0cfb288b00d66c5e2c7d7ba79053f108a227020b0a9e3b80f23931b1cd356cc97c017f88b6afbfa39655d013e4130c888386b64f1c16ec54c1282f24476493254037339862ceb66d888b1b16c3347a409d5c488bcdb6df7d4dd080e42086e1862910aca42a569d7ed16bbf77d5c0c6ee350ffc43a32def70859a1236c1f9f25f13eeeca49dbbb801463fc641f5274159b7f5b897ef44a284f7d1ecda184f4a57e3877a70c6dfa77f016e75a34d78bf922c6bf763d57b53c8000935d917c96d6cbe4fd28eccc04e94b1e394479f60e9794a0c9a14ebd417f45e63de373e96d78651e65613df8c1494d13d0a75627600395ca3faf49cf2f09c9530ffcce86ca037e1b53b6d5704a5bf01792df1faa4e6e29e738cd765d58ef41f4e1f7ae101947ba407d91ce435a49bbfca8f16d8fefe8516aef2e13ee680dac9d0a9fd67c9ab70dde5b487472d1044d7928a32aba45ff7f790fe1aefe375977c12a7c9a4390953c141b5ff199434b839dc692ff7fde0fe93e675b8ef9e084eb62b45aa0b57f3d16bb1818d1c634a50d4dac6f86c09b869b98aff003a45f42d72269fb9927d9058adca431e99607d3cbf8107d65ee32259b8afa06df9fcb2831e181f21c57d84cf4e66ae83b490f2c2ae09d9d8767156e4655d2b83bf9df3bbfe8d6b0292cd6ba85fa94d0d7cd5d3028633636c29093e24b7950b9c6e7227f5accac1f7b01f873293b1931364446c15293657c9bd489cc7ae0d01065d756a136cf98d354a7433b8c1523f1d3ff1e9c03467d00e53709eca844ff84b1d286e1eecbfe2fd503f3ff0886114b935497aae640b946597e35aa9bad9af0878d24fefc588887a6759f3afa4e4c8da5ec6f57eb7b375a242d74d82237c98722478a5ad3d754317b6859e5cd1ba71490e97eaa189b0a25a107856d45e2e615884f1107db7affd41382770bd9518091968b5be1b3561c9b440fbdfb4ca0462bac6a72c3631eb8cfc25c9d7b749d04da966f4f60ca4c921270f5cae7885f5d38996955f72178a03a0da932353cf4f62549eeb87e44f3b3f082bcf31f6d1c70319d92e9e12ae06d95283cdc3a0e91997a088e03d5c355ad0ffdf16d46c0cd12d66c62727f3700edec6d694f2b9dc7960f601875304c0029cb657235690b4cb15bd47bd00a88c7bf1c18c24b6caaff70e9194bebd6bb423151337f1cd2f892fcac79d998521285b34e956b35bbba746d02df955c5a3db572b81f6b154536655b705849b16caa13022ffdb92e16a41c515810efa79ff902fd8a6698d9ae519b238fd5ddcf39d5207931c728ed776ff823f3a5840c9973325a052eeed1a936574872481864d598ff7999f1b13323becce0a629c083ae8b1814fe2abd8d392ee7d3e1ae628e574bf28f24483fd00ba99163cc75750744c66c738d10d55cf0eba2f672bdbba487973aee3a030f1552ca338fecd960c996e857adcd00623fd9b97684d5b0408994851051706dfde0a9d66cecc8713b39de4ef1bc31d9d34a21e4fcf65f6a44b5ba60d9d4606edbf4d9ae41f23f31d7776959347c488bb9095396026316a11e022cfe4cc2fca4b96fe4a594433be901ad21eb8ecff4014cc2c8756c996a0e56cb3a3af2100bd91c49cc4ba39f3bfa56adcb98857fb594d92b15b068cd4ad31580b7838d07522770c3d8b0043f5146b341769ce0a7e40d8f5c8f0a52916f458a55fc1418c478d31b95ac3694f37653d05e07f67d54da564404ae124d793ec2ccd46bd59141d76baa7b38a4d7c41945d7ea901e1e9d8330cd5bb8f289027347b8d6aed7e53d459f625f8a087c092e68a65449d7364cf55836fe70d351ba8b717a927f661c21602ef9779db7df0c39d808e70ae74f381e9f7f812b3d733db1e52d55f918b10b6ae694acda2c5b1514f989fe94c8a7f37da951e2fdcd0d60801df17d7a24633facfea5eee4a0974316166f7d008a29265163e3a119c83e9f1714b27045e23c1e17f6e11fe6433d84c5278d2bd06419db5986857791269c89e0da7a12644919433d6a4252aa335db99ef1f5f8fbaf57813b59597512e32b9fa373d6a1a0a0a0c9f6b1c61be536bf0100131ae5cd507426bde8f51d4b06381a6993f3c1e7b9dbdf283b2b42f1a2d5bdea8d9cc5fe2fa032b508cac706506aaf7846b55828ee6a875791581c98f97d28886e77dae1dc2b5024383b21cd35d4706080a3cfbfcc9fe5e0e6e7a9045dea42d1d8b14ed13d85af7a255c3e0067ecdbe905d1f083a5145ca58fa8700c3f323d429fa03c66d40d5f2b7f53a1b16ba56aed50ef6824c038aad86b2f032a3fe79d7325f8b4dbf8a880146233c081c0de3ca3da291c5184e57a40675af0e769f5c879fb329f1004ef3f50e739beb76658b40c5c4ebcea6f87222d0259d1f09abe5afa980443ab06ea30c4cce807a9171bc1f8a7ba0c3d4c0e4f4fb910071bc47c4f59a42b672e2f7cff4d54d4efac45d03cd3644cf37d7f5958933904bfc9af1e5b111c26885eb6f091c39756fb3201cefd3caa91faacc3d33465dd4d642ccaf15b071aa141a100aa88c506648937b15a0ad1550a7623281d2066258e5f3b1ff54d82cd8eebab1858458b774620354f78c2cba3b30da48d3debab1e3967e9ec9d8bb446c2a0287ac592864d8a5b47b6e8300f5123a8787b1858aee28df72b3e0e348dc276ed336f5d279f0988d578f77993d1f5a5f02f5f4d9980ee8c6953fb066d130c59023ab55c5794d5a1d013a36e995b753b78a2017f0bf852f364d35e9acd0e0749712bdbbefcf54b9a2fae605d54c8420f3b41caf718883e91d4b30ead33ddda9f0e6308689f991dca6ebcd802cd6554a5be3c9b9565875f3908ef39f6b1e5bd9f6e914bd47eb369853b76a47a9a17824fad8289a65ac6f995869901454a11db966663becbeeca561d259cc27b256efaca743464bf6a005077db3ca65563474bb6d9d66330a4b632a5b74ef7eb0c6c14ef2cbe2dfb56c4a0b1e3557af818a819a83dfe0b146670065735fd27d9d83d6e37ee890be264add06ed1605e37ad86a1ad7f249656dd888f0f6d99da36fca1b62db4c5b782889ff9d1743a0cd3ca81064ba86bc213f1804588df2c445a25d6d65b2db08e4340e3f89d486c0d80d4373abb65e14b19bd3c1b0e3cf275d47fbacb6e3a69e197cc63b59946352d6fc602064857f1ddb7198858f4946f3273350cfa5ca00b54f048a7a6d247e504c38c80a7ecb69b56d9cb09e83064a485da26c6619a6f7474f2b8a708a4e58975018fbdbe0f30f5d7ac3d0153cf3987c99c0558c667ece9e211cba8ed5d0e9bca4bb8b587fb5efab1f5b3d7211ce4cd8eee3b1152fc36d207e8a318b9fa17d853bfe0bebdc02222c305601b4d4a350d90398cdbf7aae6b8f895c3e3888db7eb43c00129dfebbfaea8b00ce4f427aad39286be1f19f6e00b8f9d0bcc62f76c5e95370a926e49127eff357091120232bd746daedb84618348ab514bedcb9fa8c582c1897e2f9cecc4b0fd24f7a8c88ada434e73fc4b073b8442ba6cc656ecb514543497c02532bdd093befca37e6d3e8a0172b06df304fb735b3b5cabc90921e88ac39cba7b331c741d0488928983cc812603464b8feeccf88f31f73ae68fbe1b6d3a383f50bae698318a0e7164064fc1d518a2967701672bb3e59cb5624c60be598bdf42f3f41cc2b8d4194c1e411ddc2865fe82c7ffe8e3ce0c2a1f2fe85ebd634ecc069b92e3616d0569c4da303dde189d1b6ac095d17e320a0a1dacf3a2ae93f418beeca74932e48ddf067b09fe5cf4acb56e6d6c64e08c67abfbc59608dd38355a4c2e595e66773c63bb35377eca90fb252224832bad4b9aa8c85e2777d8e030c23c8687b736e24d0b93331fb20fe9c3ecc531da56c1c2f2b4c98f5afb3701fc781c1a029dd154c17d5798fc390161b853265e0c573fc7e05b7d01c7a1760131eb54ff6478d49bf325305a9738154b504374a5ef933da572c77bbe77aeeed3518b624d837d5e8da73bbfff07e03f004c3a7a7f1d3aa38b4f0ff4df941cba0e96c91e8a8299c80f6c4caaefd757116f9d4992e3f732c3c1a8f39a2a2eb017588f36ce6539a1ae8c4e05fc2ed72d9a2fa8de6f01ea4271795ed1a1c00c6b64e7486534e621f28216646c0fd7ee60ebb2e6e44356b306408f00c0c9b7d979e1aa35fac8555f63c5ed76579ca7c930a5eb0ebf11f826e68b23dd82e9a7752f0d46fc7e9ab12b67d0724bccaf5e9fb05b76b0b0f8a323c17943bc41b38c66915eeb3721300048d70a2c665b59f9f58d70379d6af1c9fddf649d67772f4b5caa3ae3f126237443bc689bbaf023d4279b4f7b706686e712eeaf3f6befc265a7fb5cf886766abaf9034538ce68cd6d921c603cdc1b2784eaf5ee1e506b275d218ed0e1a6206ffaf4f6ecd5c2d0cf7e9f62b1cea58e4c9ff6853070062e6d7a3b0458b13d083ca2f10dfd8eb7dcf114f99c2cf0ed61d8622c64cee79bff41bf0d9a45f8b0eadd60d7b6092e8e2d23b8537bfddd4df72c0d9d2be596c9ca8137e1265bfcb62d92035b1cef39b0cf600b485baa21fc453004b38e86b30bed6ece23c04f31dcc1df0734e6079f0ddfb146d561a74425f3f8a6fc5b3ef133e37ffac3761b429f794e0f2277e2acb30568f3470e11ab110c0e7ff00643a235decd24fac23defeb854b57e963dd194b354098aed9328c426e74170ba86678914a6be386560d8094b3fa3d33cc16ccf0723079fdf3fce2fe880f41c0eef7ddb4b2738fb1ba6287311c66f3b8ecbaa67497f51b33fb7b882db338cf7962ade7cf51b4f93258c8456bf611f209e9adc8fa577a86a08fc78cbbd1253064007e65be94c5cc6593e7a7ec8e75ec9fa305679bccb185be3eb7eedcaff69b0012ed1ea06b132dd562d0b2e7323b491e6e3d10b5e1df34c603c9bf33b11baebc0a10eeebe5e0222b79eb38a39937684ca9fa78d120efa849654d21c0f9e37825b238fd609da38d3530529c0f46b6459acd7d0a9c67eae24e26603368c1bb585c2cf4f1c19401995b6131e985e067188995a8d3f2ccbfe8847acf4414c00865de6481c5d573d17fe75bbdf7a95a958b6faa141c261ad01460146eb89c1e8cba06cd903616b43fddcb8c6f7189e5aa7567c213826532c06a13293f2aba7776b009075aca14e7b5c401da75df641d7d046e960874a551b07e1f89fff85338122f3887100ff25d9c6403c046da0d00bcb2dabed99b7e421e700e86244aa2c0325991c2287cd8f28358a17b17045466f5646a2a32d746ccad26e38010db6dfc1655b3b9874a221d0c2dba60b3ec29aecdbe37531b8100ae96a1c768ee56ebe4646934c3606642e0d12680d45d7018549af521bdff4564727b11f6250f495d5927714620a69bbad6f29f164b2c84d26071226d7f254653a739ec42ff4d4393bfd6b424a33de8c0389c6cf219dfb59cc8c64c71ee468dd84cef3bb3ca629a9511d614c04789e1e4acad699e8340e273051df44bd0dc02bcb37476684faea858beafeb5a7cf11ce14aeb9cf06f2daa37a63d93591fdc278148b47786eca6aeffa97399a981c039a9c6d1fd3fe1c15fd35138e188082b950c636c20bb15a206a4fd2441d99b196b1d1a37d37754d0d9c1a80b205495278f8e6547162a2b52402cc51de80ee801d1584a2c75bcf6d6e55b00fe1b5fe33765c06e228fa1b434329c4837db6fbf04fb99b71c47427d6ee3c176248363bdcd861d23864d8d6bc315f1044be0451f79ff693ff1b3c2fc94274adc82cf09e7f93c06a04f41316be2a32cbee4aeb8a847ce0bf4d968fdbc282102783ae2b72146ecb238d80f9c3b5b5e6152709a3a03f7ce744043de2455b4a42eb286b2483100d9beacc3e795194f2c30aaccea0672cccd9978bd97115939c04cf7f7ae7ad09568402d4fa4c377e4ac0b05b15732233dd9b2049e74e6061926b75538718ceb7a6ef0cdab56b679067d54a7c82701a6b6b376e205bfa4fb3c5a5f0558fe829f55d22fd45fc13cfdde70d5b761f9e4a02b02be544f69f9a6e284bd2f79281bc81fc4aa6c2834ac9d04d185bbc61509596c346828c1ed5190b471f7240995989629abe6c0df3241a65695b0c130ed43ed33797e47b5262843dfc61ebdcef68d955bcc7293f4863209cdebad70ce67e7905fa5b3535df66b601a0c1db37c904bf08eb7413113ae8678b9ca6498ca4af2bae44d21eb25a5b2357e9aa5af38c5c6adf1ab9e2b8427a5628d33ba83d2f3cfe85f0ecdfdf89b7aae69b04eccbad2e5d823e2d5306ad0dea5b20ff053e21a8b717a1b195432c6961ed85973e643bbc1f1e4edde4b21d888115a5f1dbd7094d59d35ba41057b541bc389027122cf31155f91ffba27b3cd71c9868cc69afef2563730390f4f13d6d52687927e7e8cbee6c899c5e90ae0a5a25889439bbb88a89e024215de0fd7f23a9247de2438be1ed80e1250702323515538ab94ff06a611275f2b8ab20709e1144fe4d02d25eb025500081a434e6cf700457435a09574168d7f978a6141a68087d4e8ecb78937b0e6c4c0bf84270c13f96ed3a655484eebb73f19301b69f875a38fb28536663e66b847e67227cd1114a87d053f105b6eb3ee9704e7c33b670a1d96b482672f453d887bd270eaa08ff1d3a731cb38e8f03de28bfc2c670e80ce240f0743037487f7c32d0c075b45741326885cc14cefa3911d05c8802da690b682ab8e3133ded787793737e73704940cd56a814bed42e166f59837874384e811f89ee6faf5383f8a6e280e3234615e1ffc68b6ee2442095d80a1d482d552133e5840b713f1c3487d9e3a2658a43a50583854b50de3cc89779b9a1494a194bedc4f05f5ba9b1120656580bd64930db8be10ad92979a28a31e9205509946fe0ecadb8b811086d02a91572c14ffaea1e128e82624c2e15e415917b1a0de439a5c00f57eba9122421068f8c9790db950cf29fd291181733e0e13f100275269e58aa98c3915ccc2716205d441092200a5e59e55a9149138e1404e5a03d6a59201aded7a7f77206ab2e5c52c80b8a8119926aba702eedb9d2d2f455a64732e1a756bf0231c6a3d6676b01f58d934b748e55e4d9232d269f02cb87a39a877a09232bbad4f9eae4cec2080dc0d0e522e11b6ae8bfe6158d3c9a80fda54b8db71b9223c5da2573140a978d4cc174d56a154569a3804a7825919c6945a1ac868c34347bcdea862fc8b12f6ea1d992f4eb64bd595490b3ff1c418bace53015f95ef565f07130bf58386841916f123bb3eccd6d968d0568c1d6a09ad1b93f791b27d1bb1e9625fb01e8423da3d11037b57868ded4f18597900c6f08ee0c824aa48a403173806a9f5526e7014466f9c9cf98e4e353b0acc13286ed925eadeeb4e41376e46c84fb81b2acb3651130978ec6ba57f1484c13a3eb59670beb7e04bb40fd40ada4c7b2c52f4099c94927cb8841b817c491860e372e793131f13372021ed6b703ba5a7e9fe93dc0c70926ac03f881f64927106011b14d6dbd04a0e010a885a6ca47314558ca8b0612d2d8d38c145bf64a26d3c8645ba4db100990892d843c9f389770beede463db38955a73692267d24f5467c793669f8e8d6ced58963de344c0775b1d80ebc5154f8d30102bf935f4e15e4c0cd509e8bef909f2ef3dac3d486bcd3055fc712f7fb289b81b42a3cf675a71aa08f68e6fdfb495ed7bb9238557470d24fb94d97c6b8ff0ea9d25a90ce0f8c396baf2a2f6ea06106ad8a42135d5b077ed9bee02cbb8bb54e9e65a0eeb616d1c99427332ce2c319899421e866a99f41dad916aaf02287334f707a17d661f82827d05882b73665d00b961aca8282fa0e5eb8eeb3b4dcf5b7dfaf13bbfba5da36a41f917e7feb26e11e2486ef627561e0da784b7ad90c14d2d1eaeec22650d9c4175580c4cb923b69a95c43a9e4eb7b490e62aeb69cc48b42b667abf1f3cc2301b9565ea9df2f180c1db5a1dd637c50f836e94c482dd8e9bc79eb61c3ef9be9d9826489e38360514058674fef7efc168278546943d9447e57d6b49219df7e0048ba5ba90f08b6f78a217bbb87a916e967f4a63701c6b08af6e40ff42c2a6f53745cb2d3b3e256408b974297a3406f6aca8252787287603f6d9e930bef2fa9f87a00c73516389bd595de1d0e461b1127ec30f9377b8fc96416af653506f9d84e9dbc00b5e09c996c3f1c80b8f8afeab270a1bd53d787214695e2e2c32f23dd30ce68c69125b3ba3174690c3479a4af184bd64df388419eba1f75e7238a80b2823a47fa646384f8353106e699150331fc132a40e7a44d3eb3a03ad4700d68d97bc6e320bda1e20edcf50a5ca35bc429a849d659e8a5175e4d3fcaf910fe75eed04d79b592419c5f002f8c66156bb411b6d1ed82d7d53865c89ee5542b388c948ece24dcddc7366cad54bc84cff04015022d1dcb57d2ecbeec77256b476220b55c48b53c56308fb787209fb8b7bf87a06371d1d4407e48340f06edbe3f39593aac6b3a28ffdc7522eac9cea34243b707a3c47e31e604161ebac0528eda8faae40e64f56cb174af39b585561c9b85c02692f53028e7ae0fec52502e37c521b8b6f1f6477c2bef7ac8f258628f1b7f7923597d9e30f44764628f384dc21f8f36e8014874f214f3acb0f6a1a0aa06e3aad8f1f1a388438495af2fddb28da8ab0bc48baf22ca58e2287b502359581042b22a109c67b072a1ec26e226cbb8573d4c93349e99ed2365b0b591a9591639250be77ab944001a94e586f8170c2b594f20fcc85b6eb50dce8e66600244344ddbdfce65c562f1e6256d3de0313f0f8a0833a2a19f8f98e0a4fbe31515b847155dc38438d40981e8f8453db1568701bf2ec0116815407e8312f4920c37bb65d8709d8d882c4cd769a330c482dd95c782fea845eedc63c91b4f9b2902b4abdd9624094b5bb361b885403d56702abafe40b33ba9998e8fc2e532fb5298b20b0238ed1d81f8c2c09f286fe36c357087a44feadddf9c079d6c0a32cfb817ad404ae6d4960645e4dc292660104dc209f2f6bfe46ab3ed0c2e1c3229f99275c251bb9ebdec304a5d2503dba0536fabaa3119fa3edfd2aa5faaf6c29e53cbf7d1b69e465f7f3bec7954a580e20ca6f1123fbb8ba0e7e2db125abffd70c66c2c2ea3e28d447ad0c5a882c7642f2e556131c8b5c0f0c380a75d2dd76a13f1ec52d36d155776dba95052f375976c99867ad2a3b8da77d64e971557f5ac59a0f74b918669b6482c0e034afa4e8e9ff9593c00388ec5e10338f80b5cc699a9c483f49f96b70f3196ef479e2ac86f34cffa8645764324694670f80e96ef9bc5a499c13a4f2f5a6f65610c171bd6c64eef037b475eff388416b3efc0074c09ceee8b64b3e1de70f3bcd5da00c07bd107f548f5e94adebfc73b0ac30c9c9a160c2c3602346ab2d0efd7fa8fb7ba9daa82fbfc9eb9b9856937b05b6f5ec437a6926042f42c8b23a5c854a194ee270d4993087bb326e8deffd7ccb71c28c52c03b80b27c2e91baffc50e69dcaafb245445c2e4b2c716b85ce4208f3c41fef4cde87a257b62068812f8f010413ac4c6e0665dab0734d6170cb44d28e4d744770744eafc404142fa1f6b403875aa94feb05f3364306c6b0e51a23b0995f7fb79ef4bdd744a50c9332e8a2c8369921ed56f8410242dec71089f51c7d8e87d1e51d942dc562c354410f53e46dc7d586bbe79ad572184cda38b504f37c8815eac1716cdb97127966b989cf7fa2904e0004b06b9d51cccbe1f46faef7dad58074f86afe959516cc6a2b4dbc9811ac3922cb18158fa454f8b708fff89f9777a15ca0ec89c00b306eef2a842f184d7b11d9405b0e496e4ece39b0e4c61e0e8ef991170586c013c78a077c49f2efa75f4278328e2ee71f15b30541406da6738608a46c088b07b9a923789169702801d3618f2b77ca5f06e5c7940e2d8c82bd7ed47175bca6739377b72159ce4141c98160f292575425ccf6469e3285cce2319900edcc5ed37a852e6260c5736d0f1e2a90387340e2a894f1667edf8ac28299a2ce40c9729f8cb8370eb568f68eeced658fe2ae16568824d179f176511798f1faa1403fd54bed1267934581a76f6368757fb558c2cbe05d068efa362e939f7774fbbdaa429cbdeed8569ba68f122954f41cf50911b7adb1313526bce4f428da933898d70053fb8d6d694015e2c6f6c743828e317a05fb1e64b1183cb3bfc96876adf68eefad0dbbf0367e3d5e4f8077cc17af5508498296718643b1a53062085ddbcd03d3b415437e366dbcc6921b76f6c7af3a42772cd9533237b52b0f462839439b94e47d9bcae96fb2d75f551f16146bb8e40b2c544f9033c3474654c3ea9abbd083ec557739e0472141a88f2fc5f679c3d66b7572c2e7c79b670875698926a77d6a7ba5a6479816bd265fcb4b7129f19098c6a406498d3f2b03f0d04c91010c0b6c4587fc9ec41290c2a62e540e92726768a857088ca90595fef4a63ed500e8240e5bd8872197f6a33dcea8fe0232afb60333d8e67233564be0871b625f927f714606dc3224f6c35d27a9c013df4ed1b64555d4a5fba3436fccb1b9029dfe81fbc3791a0f24cf89c4b686ff6d2659e77c8e959424ce22a73bc63d97418698dbbf8a49d4efda96dcc5d2f0ca448569dc9c1f0acfb810253d5a8b944194e44e17bc7e196790a05629d2a7b80b1cbc48414af247dec23925c374aa2d12410b7287923ba4b97a01bc7e533335c9bdb73859a4ea242659ec5a70476e0a50fbb2f34594ac6bdd414e9b82f935f6f4a50e4f88f77b7b63204a6c39dca769d307b3e2e91df49696acc280adbbd8f5f52f171bc34c3235982aaad525bad46c9d57d55e921dfe9b5b8e6f9073029a747379c5d8d32aca5eeb40bfe6e4a07f413c29cdf29e3fcd6af87a00d8ad68b2930ba8312882bc1a42bfd1fd0290c7b4876f4613536a0fbb8ad71928cb944f300d869b8c33a64f624a331f1966ed8991d7d9065c14997e4392940ca7fb9e348723ee3bb2911c0325ff2a6c66cc536ca8bf5d9abc6a1daa3a68f4b38d08097905da569100244ba53655b278d8d35cbc979f5a2cf43401db3dc76b689b536c72f2287eacda2f3a86ba9113d6badf95698380430d20ffd57f2d848ed19757f66eb7b118b29bc2f786d71802b6db3d858c8ccb8f0c6044604ab2bbc128d40534c359cc17142cc385d80d21532e09c5d2f630a7e801c69f446083f005c0f43654a1df9242f229a30a07de4fbeca2b0e4cd6c90957991bdcaef416556c77c5e346e3f97c6bc4eacfb624580b792ede5f379c0847e699d199a4aeb98d0895eb3b2e8da667462965a8f6d7f5e3fa47e3af21d24f83b6e83fe1acb00c49b0fcd19b8c0b6d71b3ec3490faee863244cc5cbd89e3278c32be776c8fc75c1d843707eeab591a5a0205a62dc65d878b6ec402442ad3ea3e47f4c12ee2f257b44cf37c7c79f2e7bc0f43ca387d84576a43d7ccb4b6237b65ff96a9b8b5c7daa90fd0ad6623926c5fe453d93a6ac471d3b8d2df0ae3b4ce84d6cb2f8568f1c044585394cf8b1a6dadab76306844f6f43c15be0df0529649edb46973c47021c208d63a821ca544da7ee57c3c240514b7019d544482b5f3886d4f96b358d1ccbacaee6b3c4d96679ca3f4bb4331a3fb94cc35cef9b22ff0ff5a24a0fa354af7ddaf6de63ed94bcfaf508e1dfaf39bb33985303566deef566d78a55480b84658c228243f17bcdb078a97d3eb2a629924560529b0ad087e3010d5b8ad41183d0675b9db8b955f3e5f2a789fdc034d858e05c2545aa4a30c253e8c9f421a45694bc5c60be8bc2439daaa82dba5d2ea2b9b88cb942bb1d75cd3a9255d7bee1ef4b101b965cc21c92dfe47a0bc28e5423ef49c7304cabdc3805a2eb9d613a482d67dc8aa0e6b6986d7b3586710ecf42333a197b610328c7270ef3b0f4e7c3e868968d4cdebef5996914215134e57c594d893a26d5d04474bd819a41835b59b0d7ca0b977ba8ca86b16b102842b270ab402ff2568f3b337c1c64e324ae7598c8d0099f5a689f06640cced10f81ac4b8cbdf36f55ef12a3362467b35d06c0c0ddc685c5d1cf43525a49fcad8670843970f26230846e2d0f4551dbadf9ca5065e5e440f33df1a1fee365c7e2e5c38a0647c3d0063e574031b670ca2b12fcfd26114cdbc8cece3e7923b587c51d063427a8fd0a5abcd798b41815694a31bc519a8f4bcd07a97a661b68d68e3194a30a0c5003e992f273cee9bd611b6b113ef36f65cb34eefbe23802765026abf8b8d75ee701139f5e3374503c5d3ab33e0ba7698c5f528dd9f1e8c27cd140bf79f63d66bd2911b63197f55b6668a7bcaaa2b63aa4a40e691dede722c9450e51124c8f5eaab3c3a4885401bc5d818f81c534bb0b594694a576b28418e83e292221a63afe64c68bd12930f9c42758142168a4f69b45a73eacac489a0175ec0a4f63d9c9ce8d6ab0b9bc0fc793a0b712a07fdb952f1331b90e4c1a9ac5595ec18d09bef4a36a99bad6b5748decec6bb06e2a40bce859a1ce5f5ea86ac7bc875a37be961659682e318b078fd7902d25e9b26846ff19279d038bcc2753eb40f30a7521bd5df5fea4070122d39d7ef52b498531e78f17c6bb156c2924a9af5a892e69bfa51b0aef50426c03fc1f24a365abf77a89bbfefdfbc9853be054f459553c499486bc49fe9ce61b3eb5bef8c171c6f39c7fd49398866367b6680ebdd9758a895428ff40de3aba2bdcd8070a357cb596b027d066aac6605eb666275da2a743b7731abf8c70319d2276fc485be16840ccaa1d8d02e2b83d753c780c53099d1fc074a3e68a125dbd9779263bb78ef0b69b1284f0eddeceefa91ce9173db8e1ea1d4058a80613bbc6dbdbfd1c2ae20f7a967210941532a01c83d416f3b6404a067418278ad425ef3a6ad0945bd2987ea099c88afeddeca80e6eb97a20cc807d3db2d536f9ed532bec2801e6f98ac6fbff940171ec312f243dca70a1ab99866e42c648f27fa7da07b85b0ab1b246c138e7c25688906834660d43d0a190fa9ac53cd3f8ef2ab017622cacf8a33dba5ea6a7a5a5917a5e4ccc374dc92897c926a1d905ad8159dc20245939c1c1ac811cdd0119179ca29674ed8b8f0c2c9823921858e2673cbb4cec0b66891a9ac8124dd8168e9953adf86e64afa9b7518d8be33c61394c0b25f2d5ea5959d353b36a50c0be7325d61670a791ee0329ca89e6334460f98d717a2ee708d9d25ba8fb3ff25044cec11fa44bc7b9126c8784a2e5037c3ee01c2e2c5cfc3fac37e1507f340d676b1377c96f42b35554c6385f02c71f58a4adc859ae40a432f24c981f4e489d025fb311d29a3ecb98d606f5a3bf125b4da98a3092e2d8935e5f0da104dce71bddb7052b19b6f806f74c817a362fc954b9acce0326954c7647d0b0d305e5b5a8ee1d760fb16b3c6f75c1cfaf8f304e5b3292dd8d069ec984a72189b1893bd5647f19af9e53d51db2d587f1ceb1b56ff5f66f61585b9651b92026db9efdf4a0a72b3d3455fc60137f4bf46ce0a9637abab9f2d7a0cd8a3ff2f313d5d34ec9a1fed7b7eb3960d22a68acbfdd757ab913d1110071307acf9d82833eaeefe9159f7bd4818d7935195109a59c42d3d23c06260738a443ed9c6b8c21c9c48d50a60d8d3c1451d05a8b4d4f1af0f4bef241a03ed3043f7db9a89d2b43525c58b7fe935dca942040aa96f00b71ca7174ca3eda575de5069ce05eec56829e3a6ef01776cdd87aa718796e59e6a2af4d2b763085a8a8c8f5bdb6d2f73d098dbdd25938bd51f6c44cace2b4fe5f87d8e028a70396419e882bdceeb7c6bf503cf1ab77ff95f7eccb3736e0538a9602f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
