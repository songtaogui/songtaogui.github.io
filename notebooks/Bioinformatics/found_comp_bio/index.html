<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27e7e37e9cf5e492e498f5cd48054cab1344e4bad8b27acdd6ba225ab5efa874db4a024930e0bb6cd6dd2f775f0d5a3c1188e9a737adba49ae11911eb17612941500ce1be8a24814fcc2dd1b415aaec0070df4a3252ba4019bb3535ddb1c6d783136de30a920cc2336c36649f2236aa68e1033044b46de4b5c9536c5f083f6887dcbb281fc16a015c2b1c9440cfe3d5b55580608ed22c5f36e262ee79317ccae73382f1f047b89cd9b03281eb50c418e94597750ec65e7bddc2467248ae179e368089011140a32ca84c1e4a79092af900d366c4f0590e63525baa48d093303621718ed35e8a12728ca68659704d031caaebeddb40aa5d323857a3d9601b2205e0dcb9f1eca4a8cda45b72a2e85299d1f04ef60b70c5cc46f93ea64d53b4a065056f2be8ec464fe6dab0e852efef89e1159ec7ec33d1944eaf72f7476aaa5cbee9619240c71edf5f4206a6ac1d804ea921ebccf55ef1d3528f61efb8d83c35d1dfd1b7593817cf17403ac994756a7c3a31b5b4b232f1d281a0ec4d734227354194d403cac13dc6c7f6d933eba4ebc2828b5370e9b5f7b2a1f9f404cf6233132a2ab6281c65bc63bb4333be12cc708fa9455ea8b99bfc489cfad01f8783388d9b6fe143115a4e21e8ada42a86b3c6121d66116588865c60c66373bafc8774a715c84e955c8b4e53d5cceb4d888376c2581782380870491677664317423678270fcb1c1a36c0c8f61361b8e00df024a5d11d1dabc83bb674382ae74871cc8ae51e63e9c4ff6d8537b777c028923e76e42b3f8bb8d9a0dff4e68f515860ee3aac99bbd74a4da3d51d7e3e9db764e6de984a1efaea70b5775fdec78a2c9923d08d47ea47a861f1475f9b5331ea88232ebab1a96d2860744b0ff99b796e55e1b0ca44b04391c371185f8095da4f2a6d9309155e8f967cd37f5140ff5d95c9cb42bca4467650a42c546bfac420614f02daaba86b29b143629bc54a350f697c47a3458aa117274780ca284d588a64e81af236b618e6821ea5ca92ae9be1fa9aa17c5d240246feabf554c6a5bf5f97433c1832a733d6978c37f154e0d5a1148228610149ee7be7242d9385f37690b562cd0577d26bb8809bbcf7a4a08ce32fd4fea44f390c5bd78700f40fd78879eb70b66fab581db09e9e88c0ee3a55efd823036d4a45ddc3f7f5155eb4c4ba865d5eaaf10aa19b4cbe9497ddc7f2adbc87495c4abab208e3891dc488fcb6ba3f1dfe8df6b5585110f7baa86945ac2e7f56aba7df6a9d177465775ddd41086381d2ec3e5f34c1649c65fd15eb9f449a4fc97abc9d3f677008c13f2f27d7eb8c00f016b06d2d5683a787a6253f18b876d336dbfd507cecfd067225ba9fe240c0c939ec7ce51e06558f403ee0a0d1488104df1d7c81c230f9c38989f19bdc039b7a6d9073856c6eb57c58950d4163290251f21445427432092351fd56b2ba6a337e19aafebed8ed1b8edbd4ef0aab517cdb812400b4a4769b9dac6b77cfbee475f78e0e26777568c6cd47cd01280ad51c68237a4cbf1fbdc746348e3218018a1ade935cc52def49ce0b4880d041df8751be8f6ee1f042367f777f1d1737636107cdad406b8a875050a0f82aed31e1a407df104d8309f8e1d593880bd14e973e1fdbf27ea68182ff3862b8128476a2489ff674336edb8b08c56e42b0daea3441c154deae8e4c428cc3e96af87258a7eaf47056be1ad8a5514183c97625b22884d006774534897bf8374f83f82a61872f2adb330f346dd3dd5a09377caf5c70bf800cce0744b5d08afe69d5fb2e8dc06228e7370df0a1dd6b7e8531025bfdda813e8cfe541f9528742c9598e80a9bae05d27c0f82ce435c9fd06e8687fbaa374d4af6a226af8f40c73073e2784347205b82fa790e988a4529bd6e6938fe2dd0d9de38908abf6ddcdf506ff6331b1d3c437030753052f9ffcc8fc006bf1a10fbee7a7a224eb3d1ab1b26559301a4ee5696342b5cbbf3e6c40228178e8827d81615f14c9ba76cf26301728d024a66f1025b72ae7adb80e769fcada09d089fc81c3167b4b7349959cd221200fb9f59ed7b725c9b49f7c2152bf81cf4581e21822dd7e94cf4191008e85ec2a3a4a76885ca0abcc26683be415e47d415d57dfcd2a842eb841e97c8eec6748c0c97bb91e4fe13d3ecb1f908d8ab84ac64ac3a54ccdb85e6eb2d4ab3fbe79d2196b394944dfa675a5fdfc260937023643ec204ff9c25badc36c9940cddba3853198e8af7bfa6aad0b39bc8f4a615a44a7061865438c0cea8ffcb8b61be5be441ffdedd033770bff5fe992d164139968bab0cc57c2a21d73087b94f7990cb59b7fa3b937c8d97ca61776837b400f5093e6afb3d11aaadc20e85e8aadc62db07bc332abfaaf5b5055d3713c39e17858bbbba9a752e019ff9ae754e898aaebfd69484a0ca46700a73047eb80c07586c607e1735d1ac46aa0e2fcbbc81e156b6c9d04e4944f84222d6a45f86c4223b2ac7bb076d791d6041b1527d3b7be1ffdaa8f4213535e46e04bd5bbd09eabf40ffa2f1b0e749cc816de62f191506fcd6ecdd02917dfb22c54b341b2557cc7251dde2501ec4f5c2b6ecc19db69c1665f540244ed287d19401010cc9903d58ff61e08895e2f7b3bb4b8549ddd78fd78f2d896e72d172b41788fe43fb8104780e84a7c3e989ebee9a3117eb051a1ae9de2a6fa59597bf44d5999fbcea36be037c2883c6a70719a31e563f0103bc815e021150f2697005f8bf546e709d2b225d278b4979f8bd59a23d3bb48b5d39cddd0d2d5ce6c6097dcdc735bf9340d41351f187b87477638f9979d06e667658f2b52c6c93127abac2620a6edb60b572815c6e8444f5ff35c65489bfff13906ea1e4a5b336772bab988a98395edf74867ad3443875bd68698d1cce569ae00dec8e74467edb00daf6997e0aa19681391a359fc13ff9bcbbe4fbe5ce3746860260e8d417d2a738b0fbd3e28e57831ed1e0840c8ab52674cb3d6e14272c62b27dd6f21262848815a30831af90c16073c24b1d572f972e21a945384d460a5943e7ede820aabd3ef4c59bc4ffdfdce29032306d761e4d699f922f288b9acdaf5cff1456d69b84fd5cbc76383575d03632c2595008c112dfc6a44dbead02d315c7debb464187880c0f00ac4aebad37f72acbc20eeea6db82076d38efa57dfc0054d25cd50b8e1166f77f5a1388b0e548db604f23d4b54060d09281d563d2a674d922ad9bbe0eb065cf018e1c3c230dfad92ce12a655b79c893048ec171f8c19fa6e644c9a576ac715c8e24c47ee5aaae76fc0c6036a944183f6f11ebfcf84eee2d302fb092d55694327a69d04d93a798086d00c671a916dbe992bb27706b6ee41c0561425d1dd8af8df31341bca9fcde7e35d616e77eb743631b9c15d4e1e5dcbbb4f961b3c5f2e920ce2ca71d95aa50d777eae820160aa29036807b0e9474dba29bb1d78f2d0a6a610fc360dc28438d506e2f51924c75d97663f589a3d464e2805bf0044b2c796e804a46ee21a7d763831a172b3658a0c7fddf21a172950ec22d054a4a232c55404620c7019a2e8d64ed847af972cdb0d38b911deade46c8dfada42cc8751c941ba139f3ab1f053c5e46edcc754e3e11b33eb032fb4d3c188c06818738bb01b4155c79ee4407d82979b9c591b3445d738683a68cde32df0b89b683287c0b918ec8c0c81b898a7d9691c9a57cc2b30f91b18c5d357334265161a62abe1f56b31a2a75d6370f00a29915d7c967aebdcbc7b89d54a68c0b54dc54df753467da026f8d528ff990ac29e43e3deb1cb0c0d36a17873adbe95ef7cf24f0ca612736740bdb105b7b4c02352a7fa334529932a019d53460c49f376523580ccaf10e95fc48f5de16240aa2f56fe78fa304be721ac0037630462a1680a6dec401278aec44c6bd8cea4307067140e9497215b68ed9b2205c7f487de25aed0ac2c06ea0b4b5bea23f79125fae91811f6af4897e91f627bfa3655e3f95586b653939537afd5ca46a4de4cd3373d10d1a8ee0c5e115c77f620de1f7b93cb3499bf6e96ba8823264656fb098d8cab7e61ee2b64ce9b178c625c05d8931383bb602c4b9abd0ae828533c948186e11abc714135f19c17084bd307ff7af7ee6ac8b75cf482b2aa77d2b0532a3049141246d067e0d9e2a6ea01ab130ef436b02c02bc3ba88c5579d38794233c5e3dcaf0a8986d1f5913c21585773d3b1919ce632c9bddacd74031780215c119c98082137cc039177ed895e7699bff47cf4eed8c8b0792b3cc77fc60653b0a8dcc3e2efd30030c6e8e90f4657bb15bd8267e5af07099cd4e10eb34af216c7590af41ff4099527b6b54663cb427ed2f7481571a1030d60cb2968f968f68a07d0a097f4c1022860618711d3aa803f7d8dfee4d828ec278496d131825318c5effaf966473681f078354afd1faf9425458e0cad89d8354911a9a7525cb91ebf7f76a7faca0f2073bbf5d6647204d05c225e485402e1b1421c42ab12b701a8de140f638938da673cde2f68f704bd933e2b8b71ffabefdf6090f08fccef7ecd5159b838f4148f169c0ff0ee051a4d3df06b065cbe6678bc8a71f9121d89157f0bf012527a386759779bd378519745e72087d79d86aff82f705d654e112f1857c1aff55f8a2e09315178571a4c1612aacb8992d5a0d0fed96ed9e5ac6b421ed0b11c24b6ecbe93bd0274d23c0fb72601e7a6eefa9534d0208b68e6876c8c30fd709df1607eec327f12a324b9574a4f597dd26670b7872f39cd0b83fc7ce7a84ca4ea0dcf104e38050c948610bc66d25bced2da5011b5e747b2da65bf049b3cfc28ae1f5468e7ff24f2a13c15e9d8b91019f7b864c3e35146b63c059e332fdaa3633cb283c549c39a48be764f0020748863dff3773bc112f547833371c6883fa0160de7624db6c5647386a8b3051e385d3db611cb064b3676caca6bb3e6da6dbc1d270b07f29af032c968b9a9b8e3a771cb96fc669218034fdbaf5ffa18cffe4c9698340becf7801facd8f5937d6255aeb728ecf2b58678199b76e5136a85f5721eff6246553e9d6b7ed15f889980769bb354725358183c9824d7f980b66f0986a2810408b70cfc8268e2bf53262a3448ac65f1ae793802ab7e776fc25346aa63b19707b2ebca16c35d14c8172fc4048e619607a5c9c55c12c0f6899e47dbaf5ee829822a66a5252f50759ff3e9f27da72bcdfb265c8da886fab28f4673c35db9145caee1c897537aac2a43a8d7c66f7698b9d8fb6b09cc62f19e0294d388c17ee31572fc7fed6c27d992a1a7a0302ad984614a1dbb25927b4232ac96fbce6784b3a4dc1e981204d4f526be7adaa987dc17f191d662e02a175897197c4665f9cb8a08ae5297d14e7108ffc3e0418bf9b6d505d6d38888cd9768a20cced95cda7fc252fd9ad696bb1e0f21e5094fd7e0a8ddaa8592fabece6166608fac22dc1b9ccfcfcd71491f7deb1d0dff393b332fa5eea64750585602a738ed25869e7cb7782754f898fe5ae82fca99e8f6f5a3dc99fadc2875c868a2e4c27e99644a680a4210fa06036c45081520e8d3ab6cb4bde1e5d71a05d3f96a943075504a85565929276c9e139a4afab9e4f119fffa5bd6150ada514ed41e2c86a4d8fead0c4bcccbe705334f98decd696775a41887e4a26c7906a3e80af6586a490387f5a667a129687c8c181af7b8451566f9c681bbe6ca0be13d7ae0cf305cd54943ca23e8c735cb4d609f5f564c584db73cf6fc79d8fab9cf22a647dce26044bb650e1deabd2859dd84453bd0424fcbe7ecfa217a11eddcb4847a7fa1d30a2f12cba5ba949271f8febd85bfcfff4c2dcd621e542486d448334db586a5bfe32b81ef5000fe0785b25c5d014c952c6a3d73bead9c0ae48b42074faf25504888194eaaf172e27aa506d80b6c6da1ca55bbba0be7c8d4ff2252026644b3dc24e1384648f67f4bd45e82f053692df957acec4ec8edd5a4c4c36bddade1aa6c76b460df01f5a8ca766bcdf8d7c290d55b97e188b603394a4b5f17a1e9588e9ed71b39bec8dea95c30c1729c8137a8f38bccf6807815c82fd8751933488300b7998fad8e3574c669cf8c6500a9cdbf618ff40bbae56565263cf6a9cb84abdab763e5b7f9e786413dd90a9e30de03d9a23dd1bfb9009d0d2b4f1a47e76028b5f05dfabef7564dddae14b5ac0e780375c92bcbaecc7c868050fa52848a4838a256c2acae0b283113dd0d0033745ffcb4e02ef039977cf92a3aa29baf2e627530af85f99f449f2e452efbc8ef885a8f9f6124f57398d4a74ab77ad68773752c10f61ea9729f22068af213b5d2a640d64e0271a57db225be0b50e154f97e1a25b641a558e8ce2a948a354d181594746ffade9982a6c5c2760a6a8392dfa16887c04ba4fb874443f5620828c7b9f0020124dc84344f39ecc1be360b9dd5600cfc7c90da1b457eaa060621d48e7d4bd4b0129ace58c6a8b7d25e4e6fefc40f7b2e8088dc21546f828c6cbbd2bbe32bc7a83537114ec7fcef3bdeac517582d1bc76642dcfc40b9f7492362bdd0425b093298e888edf2dd8598c7fd5c206788a7d38218a7616e785adcddcf486a8baba1987095e3ed87ef3c825b4718c22e86dcae610e3f5a980ab6bcdefea28732922bd8387333ad59d4d24ac1d1dc84cc4af92cfe1d7866d67618eb70c0bca130b6de437eda32173505adbb0d9d6fe1da7f72f3df82936d35d1e6c66fef1113aee2960fe14c13d6059772653c1f9e0901c2ef6a7e4adb5c96275d4907f8e594fcc2ee3ca6a88a4ace9b8a30d8679b93fb98e8631cfeea05c9f4cd2286246af5c21fe36a6b46d1fa24805168d0782bf47082b9fa8e9002b51aa8727f272a8af930e277151d8d268bc5fd72b227153219b5e6ef4b9072f23dc00f24aac8ba4a60118abfc5385e709025b23a3362f9b55971dc2c3dc107ec8f576ac11b196c1a6c62f6b754b97f1efa9e2786ab4d5f4712d8d811eb12d70e0980e825a3dba329c190e8a4ae9e6ff653c708dd6dcc2a4b032f72deb228cb9ef3859f5ddae0ec48c40ee90bba309ffec7184ede4e6e46640f048bf5f5b0e52532e4e559bf125a94607a76139bcf596e36a4be5edd153efc92d24ef323f1d9e181b7470a5a5c6d6e52f3b109594a286087f8ed5f4966594ca25b8a740a3a4d0d96994484e6ea3d142ee38a6a406b354648eaeb28618dfa282ab0b4612216b41c08527ebd8561f6494bff93a753ce4c72397a4fc8aa994327ca36817e758466be379376354ba5e34461f99088526046edd35e35fc72e3cb8b2516429eac197f73a74b90a6be8210e4f3aed92ce9f77db33bf065ad3038f50459257816d9fc79c168980fb6645386b299bfec21404eaa26deedf8b048487ed98c6bbdccd79ccc097f73b61c4b84a8f74f802e67bbc44bd895914494d445247ba4fada192a92870241525b36fd24edd10732ba12011525bdae8bc826343357c1efc72a4f65e1fae56d211742fd1806ded535b7cce62b5cae3725278e7bde32a22f43d763518913ca26385a07707f3a77f17454bcf940bf4cdc7065963f8830aa5a562f359b646c1a4b829df1409f57954a90457de7a944a35e0c85f5a22530815163be6f8571f2b43feb8c0e4196fb68bf33cb25de2e8ccf24122c44612c9b386f5e96cacb9c671889922208808b949186ea8760d69b83b074bbce4b52e9bf50501c754f68e73136b465ac4b00453d72179cd289c05c7774ca8901164f614bd381daf90d2fedfe43d10070a220e466ca790020dad271dea64ef884c817a585d70da893072677b0c89b3f32b451390cce242f2efb651f29910bb59d5c4af69a619f073b9b204af9175666e3c020b9d79b541b28370648641c08799a33bc21794bf3c657e01688c07266ab223d002edf18f2d6ef1bb41b9228ef2e8d28dd426c9da8b5c5ae6977840b7962ab2a140d617f45a3fa1451cc2a5a5674106447a8b1e196bd24e49f4094315039801d54cfb1da9637a445c8c38d5f3c2613b7ae0926705fb9c1f34dc802a03525d3341bcd689905f53e7ff92ebf6d9a50d84babc26201e29df317e27031177d7ab4a8bb56acb6a0ba7f1742e4d004401f794e9bd83d893ed3268cb0cb42151808f9c0e1d69d50520e92fd61a2ad6b07055fc51fa16332c4e9a699af99cd81eeb4258e8c09c96931b8207c271bd3ba9a40c902691d966a6ad93601c8144bb6f9baeba5710ce502d0c2acc77ad18f20c7fec2fe23823afe7d604854d86be26bff24bb929ee6d112e64a6ba559b9578e439b2337eaf8e26a7fff7b12b06a2ab118e34b4fa3ef18242bdd0d087c9a23d1d77cddf574a641c77bb2889b2b4998e0fe60202fcdad903098dd80f8ba2a08efb1e3a5d3b2619b40eee333f164df46217718f37e0badeae2a59f7e8a765c6f3f85314a39e3dea0b7507edee207a65cf27376c97b94ac0eb4ee1b49e006cd5194151076cd2a3d6b1c2397bc283e80072cd2ca04df96e39e6b0786c5cf69f94881ad6cfb72ac9a2016ae1cdd5713307abfda91767bcbea7a9acb935129efca3a5bf32fdfce6c0f8fe631b84a1a1fc3731786eeb120571005207d6da4020a7e58786127017bf5896dd5ea8fa736a43645d7389b6a6602f983ffa9536a8c6f02c63129600a060436a06e8b34b674a841aae24d33992e699c187b124174e4999886a6e4fbdc544e0cd7c95ecd303d4fa431e99ea1582db2c0399974ad98910c4d4483ba25784a14e569adfa3ea080c3977cd27bec9cf2571a41742cb5a53e0dacfb774844f14fcad5c61d55eb804cd59ec38b7e6c759564a9113577ffc1a1d504690b6cf3c21fbba465188af3224e977be3fb69621563d26999886024939389094554c722902cfa7891ae8a1e9480aae9fab2901c15fb9d7f936247130ec132b69e44262713f4673359b95e34f5c2f47bbeaf112aaae03f9cea0057505fcc49658c6aed524cc6741a346a095373995aaf71f1bd251d77d7ef503c40c375a110b8336aac325e666c1d56fb8c33b31f3ca5cfecc89536d54a0ad81e6c1a23c57764befba7440680be64e524e35a73237db0b01694cf0d9fedfd2589711a6325a0bc964dc7b181cd3058b6906758069ac6ab1ac70d54b3e01f7e556037c2c4d80ccd81c327b00d6a57a37af73f53450a87d47904745200188a684f1d8dfc83a31a249bdfc7881f7e9902b0f4294f0cd9b36a3bbc76a76e60147295b46a0285534f14270006059187d82834d9398156461ea6ea01763b65929eb9b2966ab1766252a23b99a53513b4e92f8d17a70dd41543857d146d774e1d960245a8dcd992f195b7c2b89d36c51dc8f3174e13ba8fe30f0e9d22bfd809b5a3af5e3f166886707524970f4659e5c42b4b93b1d5cf40916c99e039b907ba4b6616f666614284cae3a129efb066f8545895cf13eaa0e2edfae40b6a94ef44c94f7e3231c0ab23904b320fffe65ea4bb53924b65f344716e93d5cf34252ffa49a8d1159bf98e24792174ba2c65d6d91fa83e84ce513da67dfddbf5ad35bfb9900bd7bfbd75f902d13285951610e53c9971142f50b0204694abd92c4d16f29db7acd13523d5d6c3e686b2fb503b1d2710724af2a8e252da97911daf33ea0abfb05f1f9ee9ab0d6488215835c37c29c8ab58d0e2ab870405d28f273b8e323b3f7267007c59c995064e2d3926656c3586ff2afe7094baaae91c03d61bf1eea2d01680091adc3b5a93cdf5d0722ddd9eb601316c051bd48ab5f5b50b095ed9c047ced6e166a327007e5586a4e3fe25fa222c84c1204105d77ff92591487f1ae04a2468654f1dce85b18394d28e5d2418e8874a1d74673c76971ca51f1ff529821d399e02509cbbe0e1da3310ed564f63989ccb09a85d0efa4204876704846781976d094f8eebc947e5886e3733a4bf4aa00c8fc412e726988d5f761fc5167c50489056e2da123bb5e150d799e599d8b19e68adb0701f858c2034a820e15b695a9f692c74988ff6247bad8a377ccfc33d75a08de219a87f4049097dca27e9c8c2ff73153004623125cba393e774ddd848872f13d62aceb40ca7a791370c888c03ead98c684ef3fe9205f8da636be8685497c0a3490158e8149354c07ed4e37f0dffd353155567f8e382cf2ebd09b5b4d0ca23922c6cab9675cb0dd7842a46f562048050c997dacbd9c24c23082a0749fbb49e618a278caccb35f790a26e1df73d74d6def779179fc13e4cc39b5801be02661df02f7c9cc4381fa0685ceb291e61f81f99ff7e34289b743c7063fcc2c6515ce464cbd4cd093028897db7ec848b4bd5a227066dee752687991e22866a4a96e1c9af3da6a31eafb3a6fc191c7283443bb9661d0d2e1cdbc6350853de7b593c2723da81be6642d3e62baf097019eeacb5745ae60e88e9007c874d4d72ca86577de54ea38646bf1de3a2b3644b33035440ae16e2730301909238c6acb9e3b92acc3e8cfe09715d72303d5a12b076e36ceaa8b7b8d648a07f5d43b46f6a65847c538ce032270e7b46ce1e024d7ff56258279f14d6f38e7a510e86caa5c1df91d4d1c18ff9c3b4995e9bba3934bb27dc952487b041543ab24e481d719684d2f3c200c202db1231d401abd4101afcbf1a47c853384399889f09f24b046f82012f1be21a29fd00c867f647af850563ccf09b22b564595c2093839a07fc516f8bdea177eabf8ba268fa19dd3abe89f1f05aa95ff5f04acf23026742717ce442ad6abe1e6bd28a1fee8c111cd3e5bc2759a80c281d27f04d25f696c1ac3d4458aa057de529deaa6ce135258e6d8c3e9ed78aba50e0554be1bb20504236885cd094e243a4a83ce70d127fc2f43fcb9ba37a3c16794049d86b8ff1a5d959bf5aa645dbd707fc02475fb417a6eba350f90f6b0f0984914fa5e68d890614bc6413b322f9fa85fb885436fe7dbacc9730f6101bcd8a3fddd0463f6e2c243cf565d651ef3a6215662e89dccc1257bdf2f531241cd687b1dac7b89daadfb70fe7c718543b126ada9dd0f3e4fb5db21df70a96ee134e5f313f56afc52709f229de7c4c8a180f8fb9b2a8f5d35b6c7112d790ec33f4587427d569f1940fc9a8a4c899094ed90543abf0e26e6f13a3e97f4dc1ec8adc7b414f6f66f4e3e9ab7c1e4cbdb37466a7f3e6c80814504584f80c8fa5aad012ec624728335dd7df04215c2dd81ef7a54b4c8d010b7877b30da6df732fc50064a4a5c6030d1c28a5755c822c0525dd2e6ea9896189db602550705a9c4a59138f5ad02f32270b4003515d2620aa30c629e40f332d7a4b5a8bf8b83d411b7e10d8c5b3d36e13909d2de55e0ba6dda23feb4950a95380eed5e42027414d2fe072583b1339a1032840d21ac776a7ad68d2be529ca213aa8466ef06ed3b3790f7c19f502d36ab20174f85965ce5b9098f07e33ca9b6dff23980a840f17451c8bc6c9276f80e5ad0c8e7c5e80b5f7b9f24ba3ce1f09a59eeb21e56dfa24248e9e7ec596671fa0634ffef179ef751b717f926ee604181c71b0d655d8dadcd9b3408eafdb19dde3e5f08cc064ffd3655fbd417ac831af09f59709d3949ee0e4f023eaa2fc3ec1e543e740a66c02c6c08fd80b3359ae7ee6427cb571ce5296ddf6adea648b187e13d51090d2e596b5f06078904b19fed81b74f9203686ab04f7bacfe1faa99677c7fcebd14693f13120ef6472463749916c064614dfd39c7ab3dd6e299bb9be949a1616f63924a014de06765bfefdcc5aacd49acfab68b4a71ce1bc2f4ac1bb779cb67c2be290336f97086913695cce60032215264acc36ed05593583122fa0f6d1d6f1e830fe7296fa8c714657f4234cc716393faa19c6f37681ea357393d35d90ef2aef3a2c1daad9d84a0f19310182869af56a09e288fec76469685d5757b21980fc27366b2da38c7e4e598ee434d9ddafe35511bca754f954722b3b6e6b4f6b287f8534029e03c4dd5573511ede6db3125e0d31703a88ff7979e341f35d7df1de1df4fa54f59abc0fc92d2e44e2bae2c515b12ace7e7af09ff0cfa37fe7a5612888554ca9b36f38992d4d59f548a732a36041dffc3a52569622c6298d23c6993fe433a5e2ae6a3302c64c53253d1a67516e1b719c639fb78326996405ee4bee049b9dba915a7008b5e0be4a28a3641c178f4bbf8b796f063f3569ca0493da3e668c8cd71b11ef564a248c845c242d39169d3626b1ccdadadaec98728689cbc56e9c0c63d1d21d6cbea0b8cdf79f07ecad2aa70c467ad719a5c75600cac40c961ddfc595bfefb575fd2bae59cad6012f9f1fbce02f63cd4643fc57bc1636db7099d7788a52b788cd2711332769feee35055297dc6a3cb8d5b6195ddb4611f51cc93c9dda59136cb04b12963cb0f72b56a5db9ac668e10c7a09e8468f29e9ef9bb9874ab5acecb2fd9148fb10887f4f8124a4cbcafe9420879ac95d61a6a93ea4e38199477561cda5d9b01b57a78177a8d9f8ae10736fcace3a2990c50cbe4c5efa19f456af53dc82ce578269babe8f77edc9dc75d1de39d12bc7a889b21f956d098a228cbf0defe6502614d4df388907f9696ed99cc5a2d386fc841fd65185daeadd2f5a9da6c92e43d316e24c9e3d13a8a81d131dfe6c68b7182aa8d5bdf8e4896f41f93deeeb3c86b3f9c5dbdf42ee29ca8c1ca90648abef0d0c6383bdb825468c58efddbc400215f7778946a27e6ed748406ca1c44ef88e8dd02ba61c549cc92d1be1db50277dc5432cc9b27cbe3927ef68817a9fc650648d6756ec6d0c2d3e311d1a4c08d5973a688f8514d565aa2bd37906489f7a01b6a675626be3fa439f11f2d28a6d2e72325bcdb651888b7877067b2e3475cf8153705bc7f3b1c2749bdc77cc5be06427954c882e4c3464c910fdf35bd9c3b7b69bcf5f8d2e6a5f712517491fbf909a82765a42986ec99f7e70bc6d93fb7bd903b5f16338e56bb6e201d3e831993a740c1a9510f7161d9eebe231acd8e2b9235a11415f95a60d609cbc3e80f89ecb8a139646f01ca5f727a44e354607aa86ccda90d3113f7ebae3016564268383c6123cecd48ae4c736958341aa95ab2314fbcabcde8442c0b3ea1d7bf296ac867b60118c0b25fbd82888a845fb8401bbfbfe3c87de2ce8bbbc717769d685db5d5541a8ebbb4e45b37d582a136846ee0cba481ff8513dae841aca5991661b4de28aa44661534037103abcf65397e90fd9975e6d5b7a1009012b960bc2a06c77af309fc063b207fe1f9e15c620151294f8f1d1a64dcc03b643611e3cc36088738ad627d9f3447fd3b211f56b29c147ccc97c912bbc6bdedc7b54f8f95507e291c4093bca9a082ba0c9ad14653a4c4980c15608a69d6a39904a5f1f62c107ef909187ceed84c071d221c15db2d3e4dc15fc710586d15c1b6b70a9bd1c7d465735246a50405acc4062b7814688a0badae10ddf541d8356314843a3b061a3f65b43f07f82f07bcddd36d920cbed959325715a41776030a12a8e151500cd481e5f77b7c110c6013f730c2d8a43a61f0e9f0f4ab977954d5880e4512f11aa7a37903cecfb3242053a46b7b067998e15f04dcd22e7e69597bc318f0cba865eae165b3209b188ee4e427b1801535406c9b291f592f50a4c607fb3a109a568531311bd52563f3631c48a6bc12de793dbc4ad80f8558497660b896edef2eaf173c495127ac3d1a74e55a032e6576cdca6c30c885d89f1c5b50f8071c0316b37eb2d565794667459a8b5cc5b0e3f1eb02050706e74cf738d49b78ecaaee1ce245111fbc75fc02ceffb77c36cec5ac12b370bba9de9ec21dceb7e3dc6d56cba367602624cf5753c18fdabcab0766fa4edd3828cf8db7551f90e161a900d3f13e8a13ea654bfa7cd4f9bad2315180009f9723067dad38a2e764932a8b8d5f912e5acaa75b282346eadde3fa23dd590401741bcd9a59acd9cb711aa8eb734eb8752d3387ed03a9d1e26f11205fe3c2e1cc5779ccfb3a115367a730895f5cbe8254163100cfdf034bf9d16a660a5553b6729946b86a04f062b79ea5857e518bc07c601ad62fa430d0990ea69426baa74d7784382f39ce6e65cacf3944a81a211c2ff74f652b846c2e6fdde58f346b47da566226e53c774d444bed2d40bcd0df27506bb2f3f65cad054d56d5624e10f945fd6d734cdc8d7781e4ca775955e2f9360ab1166d1453f9a872e72a0a30a6d8af63801b24374615031d8e36dc55a0c568d7f972dab7ae523494c442cc744a9901fe3b73d5449b164a2a8d81d167ac99c76ab07375c8aa0b15c44f89c7d519cefa417a053e49845fe34f2936c550af5cd263b058202cdfc8f5a1584bed00d3e8505103b8dc9e72221285c53eab79509d2a91f85220569964a1a3252d5f3831ae096038ddf6eb51f3ce8aea65423e3cd0f122ab5f1c7b90997b187d2b7f25bd8db38b40575d575cb0daf6c4540a335ca44ea3fa19dccb98a7a89f60ed2049501157039d0cf79a02256917eb7a6fddb014bf80ca83bfe82d57ebe1a4e11ecaa9295e71cf6a714b23538999dd5b89432d783a6e529c915ebedf4b06cd28215d6f294d5e3c3ddc28089394b6e9b593eb4a9b9e2a07013beb947efff124d8c78794473af36bda185d2e21e91a402af19201b3ef7219c127c8e66a0d01fcccfc99962fd2280d52d994a9ffad8fe6caf841e20261d31b5ebd337cad36404bd55483079967376c0cd7a24e8a762c144b4851ed59325860cd7b2a5285e429c217eb78f06a8f289e53bffc9c0e5a5fcd3b7979308b6bcaca7c5ddc886c951eb90cc74932cf8d2b4a574c5ff8d737b9c9061588b4af2f22f5fb3164a8c150f99c76938e819004b17c05aa2082ebb2f3b2eaa1394ba5b8039515fe49578b36bd6f563a8c681ec72c8f252355ac99aea2caab7a4537efb8aa6cc1a6d15238971cd3d08ad3a280be3dd194d9a5e9bc3d6f50b2e2040f71a34f098a2c6ff39a8c52816e7bc333bbb111809f4f8a2ee7902da0eab9c34ff50e56e91c05e55bdd2a4e09702f65f9421d44830791ced6e44e432138607d71800082b11d67eb14065e00f2c67bc1f608489f131686e9b26ff4fba327eccea350238f556cf2a5c6ad81dc5dec2adc7f0f43aee8acfcc5893b192f60af18e2cdbbac7ace099767a13b60b3d7294a18667cf0e5fca06c11c807434fe6bd4bcb3904b95cdc4a877a92057167f00d9393de7771f95d767144d6b0b8c650a34eb571e2e7bba5ac6c3b1def5b641701bf28eb6bea8c781e022154200786be5cd4904b9e6a3c9da5e0db1ec6402108ec1dcbad870d0ff7fe937629af8ced0fd9c8e1c72f5964f1693fc7ba17989109e887cdd7ae0c8886e3769261df3908fda23b622af26c5a0d8bf4681615a9b127a3a6f172a617d244a76e6d2392e16ed37e601f97ba2e22a168b9b2f9069ebcfa4c72985c3ab96dead58cada1b4c55e8d3922775d03bd397e3283fb2f21127ff76a86273f93ecf2803ad2ddc37d023018a037314cf1d86db3368f2c957bcfe977872ea9f48f2ad167f1d45f07f62f564ffa6d71e8895dc5336d81677dfa1bab997e538bec629218e819881efa108fd8a84f48bb7f229768eb0b8e18622194cdf9c76d2c87fd67f06ed290c3f8aa236847448d3fc3bee08a8d9eef9ae0e26276238725910148529c00eb52a391a1b4dc5b5dd86dd37dace25562cd731505f9df1af21e0d885078ffa373992d1fdaa1385e44cb7d93b7889ee5172f68a5ead19338ac28f2f5da511c70308702b518ecacd9914deac01d07c59a9de9c8be63d886c1f539ad2998f25e4230d87805e8eefec13d6c6a51d88242beb7a702095c9672dee1dbc87d3e35e6b16006849a44542a69160482fac5dfa65205298a1b6ecb0a3594dbf6a0dd0bbdc3b981c7fbab03ad84557db583730569fc8b7b9e2a621903f2798df8942163821a10256bbf58f13c832ecde699491fbda617587074e363d6c91736d864dffb62f6a1e0bed84530341208777468a8ff3d5c4135ca030980c545e296df7ac152c40ff1e58310aaa208bc853611227ebf0a24e795689253708b2079c4877f39d64e8a0cb3490567bde03ee49a0aaabd93de65883c29e51cda15d0060108e678ac3a94a8c807742f1a3ef46d532402f93529d564d1095276054b2e61b2ab7c9e15fe17b18165676cfb7ad56cebbce5e1620ec87ccb17b4f2542e3ab413a0a590f9fd126fc8530ee1407a926c82f673afe43094bc365b2ad9965b103d3e785f9fecbe4bcc50bf43e76816f3e78c59cca1967e27bd81ad07cada3cf487849e7315a3e5d41a2dc52d01a3a50509ff1aa92163ea3524b99a4ea79e30079fde6bd8935c2aa5102056aea05be46329b8942eefbfc77fc46bea46929794df32cf34469cace747ff845a87683a92b309b73109727d1e2231c76122729fd6c4a8c7b4ef0c32084b4412ef0c344b475c901fd7f842e02e248f4005c0fa73189000c51041a3261b10ca21ccee59e6b3a4eb78e90ee562aa08eb09ebbef5a84d10c5a66c3f26f9e6f50e4eff1f1eabc087ac7e303c6126ceed0f9711b6b4f90b81e970afb9c8917a80122b5b2ce3db8deeec6219b76effb103c604bedbe7895f0eb52965a47bcb6c86462c47060cb8c458e26fa231207c02e47ff879f031c4bfb57b67dc7bd9bc473b0c4e8d3f657bf6ac9b4e64f784ed423a2f7de79722a051c4ced2a66686089e6a8439417dbce85f92aa2ba2f8c2d1dd3e4c4064e2b51f4a59ddb600b4839b5595d96a2451c4e4b7ff9b3cf7b16c503d93e5ad9f17746d0105c3b1c4215993f2dffd0c9ca7e7594d515a2d0df5b397e554381ce6cc9ff310663c5b8c46035bf941f34e6c5aa6f282a4e0aa9e70e5c8c125a13cb98da2ffeed6a70c4f831ae58fdbe46c3ab98966f348fcdd81eb6a5c99a06e0d570b37764860f443e16a62b83cf6e6fa5c5597e09ae779b7cf2b509ef793ec3a00b95ff492ae2d2fa6baa644181bc159a6d5733d8628ccf0396b1061b7d1a0ca65e6bb7eab79988e717a0f45368e9c5641969609ae94ac960431265d285f34523b1be65e831160c54c442a85e7e0a3d00dc7a380ccb9ab1395bfe8169b4476ea46f0afb53965b1a0207649552eba720d56c98cab135603e932747dee0ae24c23864c568398ba5e43cb87d34e5faeb97731c5d8d69120d5f2e040b5a1d096efe71db763253dde66e0ab1a248f448e9d74037d7930b9d9cca70d013877c0ba439624deb8ffe3fd5cde41536f9eae40fb527a8a37a56a46a3156e21b3c00e69e7d4dab724f3d07315b8c776c53c0232362dedaf90d3937e2c2780a63a8da362393db9a7534375798487cfaf9a47b8e4da836777224f1d5fdad9140947e4face231903f700f24795d2d874e7a019a5c275c6469ad7156240e00f6a4feef58995dad83279eec398e2cfc2faae1d2e0aa056583e8ad36beb768e110b188ecc1ea55a88edf71236744f23c30efc8fbb66b404860e399188417ca5de10c8c973ca73d56b2638e3e7bf75111356ba86c35c428f7634768e9da3babbf392202d10b2629366f79e1a096f9c038a7c4b8342df0e9b561c8c36b38a71dd38ee8a06ef77434580472de5f2f5c2cc6693ae7842ea07b70a834b8c4518fe9ad8b0c2d1326bd46782ec4fee023dc205a422ff778497a306da14649fe750a7b64c88464dfb31360766852d687aaf9d0ab605add27051de3c7258e508e80facfd1f639392cf66636d508ae7a1fc9edd861065c4cb30403a94d814c9c1b89cb70221f68be7605f9575cdbfb80333c7392199a72f509b06f3a19d4522eb646f667dec7aab7aa8e57db432e2ec32d919bf963f5c9adb68cdf21e9e9a93416841c03175dbd3d08da684cdc500ba3613157c3fe1492ae2395bb3dacbc7fa344bd4d9a1075dbbe7dcbe58e89a2e0d7aa0e7adb2e204d11ad8d1a9e3062b3cbd0aa190c42df5b49231f0841d8bf30deb912e6a616c89131452eba263d3a450ed040364b940f7e84d24e6707f2f01b91f5bd192c63b51150dfb10362d0f1cca053264b246231396746604e71b135338af8add58ac1024f8b1f4b98ef7304944a632fb2dcd033052ed2c86c562de38c5b2c09e95b60d68a47e1063ae8b8f7c6e57af245aac5c63fad890307a292c8fa641b6457c30da","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
