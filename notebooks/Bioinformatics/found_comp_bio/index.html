<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d38ee5efedc5173b8e913b34517882f8f80a487051259ba3554de380d3f087fb48b1657a19ce00b98bbca4bb7d843d403b6c4a5e123efcede2b40d857b1f3c2e96cc2cd61dedcb7592d5eeb7f3c50f0d04bd0222a07152819886c81b88caf7d6e9ae8aba28447ee83c101a789bc2577b17aea731d9465de21703c3f47a2e0cc68d7d4ef3312605fdaa9923017009fa1a555c6c695ab7634729298451e204f54e0d769dc83cd86d64a76e77121f246eb6a706849a96091164be20c662fda97895a3606ad94a6c9328c48cd49073c99951cdd7dabb968ce60f7c3a9120eb112854f2f8a0af44ca50cb27623edb3c0e1d4a9311b025bdef59fc6f29f5030a348d8e173668ce9711188a0177ab0705f38d35bd1fe3917e16b503ed4d3ef145eb0e31c63caa26ba64136ec91f96f3d8e246732241c7d5d9ac07f7e47a3e57e6db96b222bcf2daea961d3c2b67bd738584e9bc27b882ec8618c874a87c434a5f84d980f83db44309e284185cd16ae90872c2c75d5a40f12627f6eac4281a4578a6b7cee25ff45e1c149d1290a13094e819b490f3d768c057a1a5e0180130f7ec11ef5fe96756357f4d1d216bc6318c2100839ce7002530c4242574ed1ce2d7e5cdf2597a813aab1087759c5baa660c406403ea0c9ac188472ecef92b97bd99bbe7684028c5b080c7bb070e9e64cc74f60f32432d71278357b6778f1328084c4c606387052eeebe0a3c1798cf0382e601c3bd58f3b63d269fadce95a7f59452311945dbaa1794d854bc35b72b57b9c03e59651e760433721fa2b66af465f29cb962de08cdca19a564ad36673680469f799f709b04542495676be0fb5954c1da55f526d242e2ae650ad161dd249686c642cc73293aa8c0e63c8c2140fd735e74fb31f27ae80523aa8a4d37d42dc3285ceef21f4159a358e1d9750d0ee60b8484e96d89d5ad9ca43702b2f3c5b776c9135a4b497d6336a86bdd19af8116d2f4cd9fe283536c87e8ffc597670e86ac10f28b929e282750682a39f087ec1b785cd9d09c777e150b4a426d002af15e6eb4a166a2502e2cc8bd19e61e73dc348ae870e4a51dea4043f9bfd75905ea1d48bdbbcc928836848fcc3616916e4c6c62cebe3414dc74061c3978b3bc43801558b0c369d0f64b3a5ec17f2dc89ee884b2c5a2a71843688ac1b19151316819c31e37df1f7f58572e2fcaaaf8c3855042606e6ec2f1537a20278910efae9ff5c20b4aea86964b043319c3d6ceb117b681e023fc65790a9ca93bf560a9cc024120b2c2e7a278fe317420b14eac7c1cc45a45f7859b63c7021dfd832ad10725e1fb29a8214c21d9f8bcae031b421f36901bb9704b62e18fdeac1ba42dc882916898fbfbeb1e38e7f17701f6e88c5f63a71074e5753bd18cbe8338838c7235dcaa0c52bb6e6493bf7cedde03511c221d4e58103afe48e704b02019ff46b9275cfde0244356176fd0d5fed7f4c8b3dca64f660acc65c34091c12f14c8ddbf9dfa6d65ce057a1385e9846f62081fe60450d26504069a79171562b22b93c9b42d09af9cd120c316754295dfa7865ad2c7cdffebfc3a8d83a2a95421604043ec0947b8d5fba9b6ce2c50697ebf4315db6262524cf1214df130932b24d8a1bf1613f00fbb877eea545c6bc45db30f3e439d075e080bd9edce8c1dda2cbe114e62a9afdb7d5edebb060545e9aae9e936f9452f708ff230448016839f839ed4bed3437da4111f0230a57fdb0e27e89489c3e429859cdd513be7e46f5332a38587cba74031d0920ab942e5ce335131436f992fe6cb1bf310dc854095796b8afacaa3e4fc652d51f09fdded631749ef9a754b43d31c890ca84b35f1e370d8971ef144204f4741f6ed7b23decc409cfce7eb5be76b2cdfefb6a8e6afb2be40de7eb623fa4daa8d1da96ecc1129d22617f367da9147b3f557fd3427bc01c54fba96efad2e94f245415ce3e2a0faace10024d6bf52d50a83627e284bdc698ee45ce428120467a7392c2326a792df650249cd0122d16dde800f192d84281cbf2e67ca8dda6a4890e2d787521233b3d1eab14be56cd310b3c4d826cd0201db812d80d7a913803dea8984ab47e5a728983d3555ac7185521ce41dabc906f4ec962e17e1ed985753cd46fd9db43aee20c8db0088db25c07d203769022d4a4d66f6325a1d6923f04a3971b3c6135dfba72ebf3af1e6dd5ab0fa596ca153a4ee91301fd4f70488dd749b411ad6b273ddcaa7a8246da248479e6a8f8bd0eadbde4dab0070a70241fc54f1fc6ea9b70a92c0bce2408e2a2e42f3fb1e9d39afe1661e515c3de1ab529524a4825117bbeb4632d90e5d43c91db3ade7dbe5f94a413177e0855177c4c74d6b913526fd77220ac060fec502e3fc4e7eef90e9e045c75185a999adb8295ad7a4d80b459c410dec6cf4ff8fe0dae9e2289988fb0cd4a13a28fe25a62020dadda1024b0b869d85a054e36e90e6bd829b3a535f1ec25e53de7e4cde39ffa230e9699577ae76285bf2ba5d2d8f702933a76e367067be88c6db1974f8eb62ac25b01c2cd0bc19fc5ddb5e998d16bc913f92b4cf2064eaecd6cc87643194d890681237c27f757dee9eca35289c2c97d10237fb38a0938873bc2d9a9847474650438a54aebd4afe925dc75d9f0e3addfe1bc4c09d42bbc6db16ff5011ec43feac512a1406db7d496a24d9b53b6a3bf47b797eba63b1cdcadc056e61fe06cdfa3fad0fa140ee0a4295ff541346a8686aba35eec6a306dfbce3bf03746c6af757ece79aca704db0bce523f80d5639f5072b087dd35d5c4780a42f0e9b7e458ab85481da853fa0a1b1bcd3ded63c0ebd3039e76c603ff52fbbddd95704b373a0a09a80b5ea9a5f7bacc3f10cb8011fe4001117ccdc3431d25ac052085fb2425a86e97fc590e2b162c1c9c57794271c6abee4af4668b47743f18cf2cbd4e54c2075cc730e3e879122e651036cce12280c67be3b40f69b290741009e98d07f3bcd9f52ad3bbf7bcd41c7ff58bdef89808249f937e8c8393aab58ecc1c2011f75f4aedd551250e333824c68d6abcafb7e1b7d5c519f524f3150070cc2222c63c8f20e46760c90458e877bb4ccee1abaf9dcdcda077d9cd3dda96bedeb030fd18d3d80b0c9d1ccc73f84ab0f801437beb88bbd4409b3675c63fa928e2cf4e466373598c8fe9045c825fe99bccf403b2025f594483dd0cbe865fd286e8ec32fe7ebf1749a5e8303e0df7927bf6d0e7dfbb7b10066a68aaeceb308ae7e05fdad89ed6b1cbde26c0ea5c82cfa3c1b486b3decfddb04485bb70f04af2ae13cc584445143de1e2048c90d873b398c107e3879764358509e6d8a8c514b3070f9aaa8879f3cc43d7025513572d7be96f98c8abab548a9a131b8b06bbe9780dce84392843fbf45da14a66adb39a08d92335837cb9e29445dbb8e7a16aec928c4b0a8cb31a135f6b87c0b420194ad33c4b6d563d29fe896e32a295e46bfbe167eebccb8c42566e4c694637a420226a1627edf873acd6ccb835cd8dfe8d401c33459e27d3f393f6d41e63266d844d96587caa78c228547795dc8440ec1973600cf41d11f34079cf28c0fee1c1dca485bccf129e41abd310c7f976ecfd32724ac595054f325a400b36c764ad3523b386946ba855fa1fbb0b343ebfd5b732f75ea54b77237979d56a3655188a12c6f705568a1833d1e74e2397a4f9f92a157d6b37ef8d70c0bf6758fae00d02f5e35ee9df3bc8e5f657adb7440ef5cb6c4e2098e90af70a07bc086527af6b1824bff67dc865d5047c3f2fe92b609d45c057b666cebcf28ce99d8e4ed2afa5417611a5f2e34e8ffe8fcf6fbed43af24efa3715ca31e7b5d105ff589420beafb7a2e2193a622026fde562128127fc92e6d22578f6517934857356a8991bbaf7d7d73261577989d1d252981721246cee2bd6b2e35a1d5d3a6ca7f089120b825e99fde4269ff8154828e7e90f23aee2e361c3bd6850300d8ba7686823a6bea3e27238a5f6b13f4edd3a725be8639c58ea301dd338d0c39e5ea607b926173cdb06a9a6c7ec9de27b5b2187b866ae7ff5f960ab36458c65afe61a47718f6ac5a0fda44b757a864ca2333a0f5f1eb22f627db5a9ad46079ab2651c0556caf27ed97890ff790090d86ab9885dd5f7b6385a62ba62d8cdc277887d9e679d100c3ec2374d94f3b4f70e1391c02c755426dda06249231aeb474490b0c722b88e8648e3370586c0718bbab4767fa4b5cbed527530df9cb12c112b86fe25af205b17a4132aeab892520751ed39ba040f97f5022bfc5bb082544f4d3554b4e4591a7dd885c5d911c9db02e845c03895a71e075de1fb8d5745caf7b9407416ec9063723a68b4d6f7d2079f09ba885936db0aa1d28e1c613639ca9fc058e03f5a7e4b9cdcf56a2496cfb256304c5736929d1d7332b6297d279e00adde838d70fb41fac64a189830992d93fc420fd92468ea53aff7f6025a1282fa71472fdc2ec09c7edeb674cc61f9518c7a01079f3d7289a4a99cfe93284fbb43bc3a91467bf65f6f70ef2a276ea0cd0a4dabac3f1137ca6d89d997411396eff32dc89add76a69270fb42fba41492d2b1f8885304d5c9111653c9c825c0cef9020be913266973b7af6f7ddb170393226274cdcb9abd978113ec908f4954d456d0eb1d7c9d3f7c7defe0f352378afd33e34ff8522dc7e973ebb3db5b07a00d0d86b68552e0e8b726932dda49e6422d75f46f87933c247419f7ef9070612b2d2d35afea034fb940cb7cd327ae3009686f14b4f4b22ca9f525fe8998fb6872567b6f12bf413619eff8da314e1b854c4740b015db9a55c01b8ecf9ec89b0418964b9ed8e97743b413392e7725650f614648b81f66c59f561649cd792c17bb3b7728e91f1b30a59978d7142480a0da2def4f559de819bfcc57b61a6eef2118a74c17da74bdc441ae51831f62371ab22c2b092692772d46beb7c61ca86e32184c470c4c8ed9804c66007b883fc1411a369afe606721098b24f90d54ca1adeb67a86cfc1e6c0d49a1e72e81b5680f71dfb34b2aee511d06268ce14475946b27b8266bb4a171bdb78af5e5e4b1c16e6cd8b5429b93810df8f74e0e0a5b1ea7c4192f0b88f46d6cc37e485f47b25b0cc4672a6fd4621556ecf91073a11685e2ad60916c4dcf345d99a0f501a6f7fa09b8a4ec1f08f0eeb788c6934dfed1ea97857b776c49fdc3d0378d0817026071a82540cf69c51647b8ed7406729957422756e55ac2f74fe5a0169526d6f214c100316e1b0bbcfc7f526a61745d7a0a12795f55794aefe03e4991c3afdf119cb5f1e20b7f1befc9f6ba353ee64708e0a3883ed3a73d4d901a852b710ec884b276d32221af1012d07c2ac405263eda658b8933661cf8b1669c8524dfcbef8c7a2caf9d740d5283bfd15fa405140a9a4b1d3caeafb73699dc794d1d8afd9be3f5a4a19703298ce5fd57e3fcc57fa7ba61780d0bb72ca1f65b92e22c2572b32a91bb6b382fa153f8a0b8f681a800600774621633069f689b9d477e0fc205092d8ae38f1b13bd99a3df4bde43fc6957da5a2d79726cf77cb1579cfde0a9af55db8d3300f8bc374b597d5c01f0f81827633ba7f630c414dc95d415fa3744b7b3f9c98d7c8d30634f3066d276f73b63d90e1cda91f893f795f8daf9f51e3434c5b0ae0ba759936aca8fb06b4ebb311d7afe62ced21b3ef7c644ec7b166695310f15205c8501b777c690f77ea73636a8d192e437a8ca8f437784381cb20ad038addf7691c2b07785d68292adc58badda8a460700564298fa3d7929f5de2521e1f43884f99cde429af5123c61d6399e6664bd5a5314907c552b485206abe43b51a560f741acf7751651d622663faa743fee384973ae8698e9b51afcef2418b08dff7ed335f025a81d8b813d78f740e373b668d3b296dd60b8c5ed333a6d821a9a74834a6726940a6efbf5502dc57cf701a7e234018da3baa98ad9f9f91b6df125a11c9c3804b87f5c04fc20e1338b094f6f81186a5dc8dbc71507a6053092994a671c1de225655116dc090cf2e651422854bc5cb952a6cac88b53ee91cfd32dc1b316ac28fc89ad77cb632dde0fff77eecdd0ec6607866988b266051fe5715365e3c69e3e2a61f2a32198896b3e7a99fa3086735690dd0c8ed3afd2aedb9816639c8384fd86cf2fbd770d31912850479a34dc1dc488fc6522ba817ef7abb6deab8fd69d1fd4c20ca897ddf9dd988c1d03d866ca85e3be755d963c2d4e61f3516cc6949cf0288710a1ea863c9524335e5999a19c7c83863adfd92711eaf75172e9b70724122657c1b1c236893d7e7bae5fbc4eb1853a41f88618caf93d89e998e36584f622f601f628a788e806c086bafc19f6fba0f5803f3b3ba268acd7bfcffee7927383d09212c739695a6d07b6bca4169e54463f3d83d31b985a3913495c68b8edb991ffa53fae17098d01c1935735df3c7174c47426e68efd867c9a322e9c19a7798965d62620488cbc6ea5f2b79e6c13910efcf9e92ed6beebb6532d882b9d50749693081310eed0f628baaa25dd3df1dab56efa9f0c00dda39f263041098dd9ba99974eda2ac75be84cc15c171a6f3177319ecd68a22d2a4013d8362a00f58df287f59369a84d0ef767aaf6ebee95239d40ce19a5266c0f1b0ae5ca4188042527446193664e05078e4418f095e36f52798ee099b4e70ab05c8c1c1254dccafd01ce8889c9262492d894c0920f7e0a1e5ce25b75d0599451fca09910c3fc2c7cda6bb638cadef4d5e2475e05e1c7b39e70ac737b79dc57b8c3baf0b4c9c47fcf87d4ea6987bb4cd7447e032889e77483abb83811412f29c6d00759b098c05b1100e99aca8db9464fc19f47c28e0d6abb6520dd75bf97a04950b5254e5d28a38ea80bc1fd060b7eda2c90350fd2a3a0b0752e7acd88b105c4be866a517bc5e0aaa1b3b523594916ad385622978a6aada7705aec7ef1102dbf0f8e166c9ac9a6b9c8f9d1cab303a210f0a3d6897955a9f57d2702e4342990f6b6a662d96a4608eaf54882ab8431b7aa87ab4a21ef5f453a9bbc531c43c91983b3900ff956cb3dd4e8af0291e9645266f7da4a65c7c5d47610452ed115c8e3711090b53b1011914d6d8678d66383631e4a191fac9d5484ea6e57613753ca46bf8b794a3561679fa8ba9bc59f78c7314d61e52e3c214dffffea45cabc5ad6894d8a6b5969eff5795d231181266538eae8a5c4b27e94268c5cf3158165c6d5a982314f543218ff3a85333ff5807c83071ca80a077c1c0abeb26d27994d3e52a71569ab12b3c8895de1666deba14bd91e6578b713e85f19baaa3d106803c63fed34f838bfcec8038eaa4c0e6c6433fbaae36fd54073dbba7c27f2daccc4e3eb518fafa4af700b265ff37cbab1fc9b9926e8d3b2f3f8610dc5c0e790194f4e2facbc69b6decfaebdfb923f5811a423883f8a6dbc396d2979ede6e619261a6fa24f6031f4310933769a0d36829d1625182a6e8142afdc735f6ab80ece7af51ee81a0bf0fad673aa527b8b9401246620d2f9f32b20c016fe1bca39841f3e436f0595aaf529613a2f99281da3fe2efcbf2826234fc0f6dcbdc72d394b67cb745e0b9bcfb907bc9e72dcac6d5b69d5934e22ad04627d9cabf3dcce47d3b5cdb6e536a27d05afc819df7010e51f2b8049783e6e1ecf138607358d61365ec7d909339b33747ab087d748a78f73d97d7e3428955ac764b8aa138fbe921d02d9b13ec12fe339d5f968ab21ba4d118b6a65b83671291aa560c53f58460a66d4023d42c4a7344badf0057afc5fdc32e6afb230b91405953c616aa9c6299664fcc15d6607a96983ce5c75a0ccf711ef9d2f8698e984f8d835b2eae4d9c27c329d20b20bd8e96c11d35f4ae2167c388a6557995283c9d2d7e5f4758c9f4507b74ade2ddf978a0526c1f7004899e0d12e00e70cde54510799b57133ec30fd6565308e8fd97b94a30d922ce889893a0bb218cc28cc452d45f1811a00d7f3c08f5309f94ff2b380ef5a4f802984648bac5122f98f93a6416dfee3feeae5a27d2dc723d7164473c00f6ce9d53ba9f13982419ed2eb0e6417a4cb3971d6bff347f7d9a0074f531d3bc2766db6600e39b98c73cea599013afe7361e72562dc275dd1e6c559b1ea518a385a2803d895398c72754e7a4c959751ab50fe3a14330359d743101d680e9c0feef59d8f1aa00c388c299def657adf71bb40cbb694b28d91f673b38a993d3114859d8b26ebfc400abf768731ecfc07111b532b3eb290f68198d4695a84d96b76708628c587b9463f32072049c445565359b11de1d8421d153e551e21125600ad08b8a03b6720cb116f1492e9c3f80bbf2d3a4c3c29b9561386709d3ee87a477c32469cdbcb93a7d725e1728ab84cd105f6867303f4e27e49d1c5eff9bbcf94af5a3df0f0e611718da1451e7d194bf00193aaeea5d329210ca220fd7806671263b03dc4ef44e85527536887f21eaa84b64cc526b38f6b82f87b03449dd84a2db71a7f8c01bb93730889c2dfccac1393094d13df428fcd332080f8106b3b6f3419a543637e473c3152fb89b7c0d7d86cc8781816864cee1e1b6e48a57fc542f4533101bddf2ddcab5b12fc1a8749f17ee89b135bef2227786c013260c2124a33eb2a0931bb81063626bfa117b6566223ed9efd170372fa35fd717cc6ae5e3d7252f07c174785a759de414231a9ded3efc0f51c2656c377e5f273ed690e5f19ce7026c17fbe656fcfeb7960db464161608985f205920586db08d951b076ccac7bbbf640bf3d13b0009941860b9ea29b228f51ecb27fd4a20fe59dc8350b4b309ef1bc0f39435e745eaa08d314c836e51e26d3e17c4facc48070b23f23d68e1d2309fee7e3c244d646f959bb573da321538ed9dc84885d3ec392e1784b9b819c7ded8fd159b415fd96b95fd98c151ff452e1d76da95ad43b39043820c09ef8db1a5d62154e90f46fa46b2f6430ddee0147bd855e581ad2bf4876de20dfed38d982b4cfdac25253dc77fdcbab46e4c499e5bf318cbc908dab03f8f29b98eadf857e806de3d05521298411ecc2241c8a625a9cccd16da17c012413ea03e9ce14c52b906b65d6b06cfc7fe003f2c2bf2d20bc76aed35c04bff69e228b5cb0b01d2dd6d912fc3d7c202795a777003e3b43901ca56aabb3fd708ff6c5d010d67165b81bea3b62f9949a455792ceec3d59768485c2f3a180542de08b3b30f49d9e488cc2aba789d3dba0781424a974888fc5567df5bf65f5cbe1b9dc6ecb6b7abf4a47698b2795a53e6895073a4e94f6a51b9047ce523c844e88066bd28ffaea656c5ef9c36c838d5b2699eced75008a39f525d211c41d64c60b1b43aafd76c4572cd395cdc598bbba5ad4119e93dbb42b34692eb822d816e2f0f22e43538ad5588daaeb0344530ebcb9216ea568f7fb6a27832ef7d43b167b26c39ae09ec38dc51d86f5dc9b02edf2e97965ce31ad75219c4d062ecbe6ba628b718b06bf15a571a160516e62a8b0b96276ac725d50e18a29f1af2422e6f1979f73336429f64d7442147b1c2589f4822bff52680fd49dc29fe5960f86c1cccfa1ec47ac820344774cda33d58eec65fb9de97fbf43de89b66449b56afbdfa57a43eb767b94eab185be9cafa54006f716facd8886e58408377fb23044d801577147ac2a7bcc3636aa8b7cfd773ff3025f2af64c8ca9128efce78a3170f4e4d8a55ac58f5da2443071a9a1c963b941cece5048a76792c76930725870ac67d2e3529d2255aaeabbb59ee958e5c27369b489a2335a4b37ab79a09f3d1057b2ea7e62eb31a853843f48e464277859bab05bf4fbe101d755eea8d647c6903e6556e3a139fb25e56c996a246383cd9164a13cc2b7129ad4722b034344204e879f9f86acf0ac7589601ce1d0e2163d71c90d0e1fe31be2cbf5de081133a974c3fb205d3f40a7774bc193d259bff15ced024d352283db91b52096e488ff1747694f245bc0e491a877548c332f52f1680a32d3c3434bb96fbb0b908fe0a33be3f8655aeb0ef1c2b22630938a5a19c9ec9cd6d3ade807d1fed85aab465769073ad25189907afc1446ac61921299d311221fac8653a61ec93bad5d3b8c025c7ae7d0435c8938db398e6ca4e3f64ac8b76cfeb017b3813776e87ed9abf86b73cdac2b7637c5f578d4257c870a0caa82843b7e23a7878566d183410fbadcacbff9050445e289ea9f6877459e83be326ef3ca312b2eedb309f462ae946e165449510839d9cfd03d249289a38d252c856049d3c3aeeb8060fd8ab652bb1b2ee87dcece03b10005777d1ee0de9e1381bfaaacf88ce6274f7af91395f8c93a242afe74a6033e5b7ef1f2976de0a07f2be281d94ba467e11838fc4b51870b2b719704ad9970b6d0005f90bdd2c0c461be7078e66909d53612f09a2574ed3018a724d263fc39ad16d1db00d713aa26947871e5104094723067b1df828e3a119944ba46ffb9bdbc60b0444534bcf05b401b7dfda44538660c85396a44b90a00816860cb38a30590dfd78f15b9d3453bfa30f13741eddaa52bcc08b4319557cefc23b038d7c55ea3429b2a7abd3e8a5b4652da113fc4abf7f2af2ad0330afa3fde7f27c1380ce34d96fed7f038b5a58caa8a03eb0fc0834af4af7800d8718a1d45f2b603fbfa55e30e904046d6eccc3f9e1650f09fed5d785eda20f9b0ca7dd20b13c63991208d341409a3cb3dca26939bf378937c8e95f3b1c1a7d63b5db9b35d0cf2be5106fd281dd5c25f422cf6a427c082bb93c7836acf25840dc18dc654ed15193e6b470af2f6c5c3b1424be508ece4ff0d3daa4bea4e3e76d6155e7b961aae0d6be8d801980981a34bb3610466902df6a3e0be32e60df8830acf85155efb5b7dcd73c0ec2c7ba333d851f9fb60d9cb93acd5bc24a808303fc6e6725f35e12edb8b08a89e414be29ce881adb8d84651fc7deba4a009cbd75caf932212d873b74652b6ab878eaa5b2565704ed9f6b9f361643a5167f0553b0b9cce6cbeb277d38d37a2c932ef963c706eb929d33a864f965ebbbf0766cd0166ddbc4e6441762f59ad8651782cbf435cbbd5ebcecb933bb1ffb14e6e9b3c6c5b03f9916a6c37f0d7a387a14ef2aeb31832e79b15fe29d23e90768f1278c521d275482602f18454e996ff275f6849632219c0cc67f0d4e60354ca3832ae4c05a9a5f3f1d0d8c8797bb16d44096a5d0b9909eadf245fd3301310a4e648199c741839675e5451a5cab589b62a234d11a6743dafd5c34a9e59963d4e4f169defe26cb395e791877eaf875b271a5ddf017bbc99b09ce26c429478abe0fbde0ada5945e4e8fa3e708a01187bfa73019256622dd1e021603b66f501c08ec96bcf6aebb460f80b3bc2d4f98cf2d3668da8697a1eae0b9f9c056320345e188dcb317b6faa627dad0d36d14e51066cca48d53fabccfe70f88e5e2f867e66a9927e7b842f46bf8c626da90022eeadd26b30e253283034ce607ac26b8323bec84f5adf6f1c4fc032317a191f10f52d57c39997a7f323da58ded8236d73fa3cecf337cb497b9b69eeebff66d4529428e7cf289b3aa6e63cfa12a4d31842a91f0f66df800be026807074928efb8bd63dd228f128a1a16000b5cfa3a1b20e8b216091aea0b68051c39c55f098d4b1a137144a38062f8535e7aacf5b8b58afff7e5daebdc2c8404c8231dd3d8b704bcc35eba0b10fe2fe621711f83cf4c242e4683882e1a90d01ddd618cbdd4a5f959f064d0e80dffbf854cf4c3e4d34bfe18af7a83c82ba51030f26e3d721060e04ddfb80d77b51e22365f59e3dc157bb8d8240f1faa7d4a0a9ff574341a3a8e89c45af811294a7d434d519912d673743f80072ed04a3efdb1e67b9a34d5f07ba8d28b4e6480b27155a718949de77bbd1cb4973daf17ff368ee7d6cdd18eaef66cc8343122d3eb8bd6e8841bb9fe1ba308273c006e9faee7a70c66477cb8ab8a17877fb8c9dbb7f763cb1917f6b6e24edc22b794f88a79127bce3aa17c3a42e76d016e0813e6252e1513e3dc91e62a2d9cdfb15861cbc3f8bf0d4b43f1551373412b142e99b4e5cce3526cc0a135bed80f6b081661e2c1bb4835cfb9ed58f21f58f303a65443566f4eb6fa5c365751c39b93235fc848577c368daf0d37c4bf7d004c8f3d1e71fdef3bc43751fd881389c18cad08300446020da4e5f21d557c27c2210bd7b1b60c437275903078514c96802e26f6109f0ac08d9bda8d3827f62ec350d0f0084bb4b43683185c445850646ff2b4d26c0146cf49a35d052b15767c816d637aba4abe2ab10d2bd2bfc8e91c5d9fb5336c5ef6478abe1729079adb0d820184099bb245e5f9ea6de1a48b50c8918cbab2bdb5101fe0baee006f7c15700acf8b31f62d29f987277c983585e5e02c0b146c451bde35729a5f21f1caa3e89a02918d5dca9e5fdd8f22a68737254fc0bd4206321d42b36051fe411de371b78473fc26747a8ca8b46ae80b132039927f585b803ebbb4a4196e365fdd1138558cd8f3001c7dba4d88aa23ade6adcb8a33c96407ab4141827a9bf1a675f95cb2c2f9b363a18ef0d76b132325557a0a7d75dc80d22a5d46d6c7afbab27dfa4858ca1003a98ced059451f2b70ca3374e5e8fd935f53837dc3ac7754fd516574304b65d729b2f535c9bc0617f0c695caa620007ae81021168312a56c11aa503e4837e469227dc4419554196edd471b5700417a5fdb54351c228366891e03145a5cf5ae96175489899221ee83dd607ccb712c3a01174416b49e8abfac4df7bed4a7e16e83e0c4109003c61928502d7b1d7ffc3990038783b205516a1581f8e94fcaea0236b5c970523a5a778b066d9491a4e586f7d079ed5398c9a71bd8e177186f2422114efee177d9e239d735578ec43529818e2d88dde8cb198463e7ebbbd5fbfcbc7805c2a4a61b0a9349053b3216c3519db9c2d757a9a5f79196d0166b322cd90bfb86c9d9f50fd4cd3f5ebf0a5dad0061cbed022f1bcc46bfdfd1cacb0ad8c7f8169a9f62a2a56440cad024df1ac39e8506db1b7d64e189f438930b41dddde658e06f9a515a888ae7f80787b71d1e2afe5e658928109d13be651fd9660a59463df810b26f4fdd24f4e88070c67bf0e5aa45493c602a516823f10ba6d4e82da04947835a5cad37dd7d4198db0fbd5e4737d4c738e1918b6a198cd2f55467bae802b1e0780a7cd201583ad512173df51d1640ac5b9e83734141516c6275daa69112f3fd80cf5c5dc7b61e8aba298274f42b6bbeaa23badbdc12f2201054463ade4ff9b870d6717dd2cc30925b2dbc7406ccf9c7a70da60f52ab6af4172882d1807bde01106a2370939daeb4374f39b2776083c770d540ce85c4dc127a0b6e394d90ba71efc14e9c10288f0725141499120c1324bc43a51087dddaf44b8fcfd48c707c1c2c584e8a713855b37687fa911bb741ad83afcbfba136bb172a8fef80a94939f7b137affd79972ff0be6b222fdc065fc91bc4c8ed24e1bae6f26349191b82fce77ab86ac1f49e51ad407b694a77d6ab3697dc3190c5253f384b76f7e32c8553c20d84d6a323ac9f6bd9127441e99874dfa8a8371909e2fc7aff8cba08bde9149921249d5b23c05f492dfcb142e2d90ad9214da5a40febaa40649faf06f60447059a5eeb1f61888716f2a743fe933f3203f11cf7cf81df668261ca5fc21737596ffbb30fb5eaf82082d2f1862cfc00dcdb518cef36da2bc5e0a9289565420ab7359112360d6d995af63c6ceb6a0d7cf01ccc6fcd0e93f7a04cf35e34c9fcfab25538d47e9966f598137627e5df4fb6d270644bb829e43e4544fc890047fc28db8ae8ab05e84debae24692386561022997cf892fe08856c5f2d63c85b686f6c3e166f49ad03f72329dbc558c3304500f01db37a7a0450234738ca53f6910ebf68a8736e5db2e1f27a4dbc16996ffe7310a58c462266585d5143247fd261232a587b9b76318ba3b44504babf6f3a0a0cb58fb888fe27f95615aa43bb57e2587b6c990bdfedde13d9dceca404f2bb949d07722aef4232f281d20002cb8771b88e36e2802ba7776f36c48d3847f62915ac460d8869cc13a93863273d55756772be09b5cee27ec2009d3a124768efb14d039a5b02945b8d5d78be1b7c829a571abed3f93df1b1dc0ae9ddac8668310fdcd13ff37b37f5c59cafebf00d693748574c705006408feff9568f655482c188291cd1c94243a103b1d90b37bb8bf756b3cdcea6808bb350debeaf6594d54777cb3f250ec31507fdf10cc35089b3b2a6743155081459238baf6b6b6dc7c0234fdb8bfc550a2e71e7577cab63039deaa2ba9f3de68b0b1f2f9b97b3469de6e651095e48a3e271b9ac10b412dac1ac036cc2eac9df122bff5ff460e2bfe1bf968f5e8ddfd0530264a3f2194e3d73589d771a536de23619a997dbe5a0c37c0c10b7dfea481e875e776e4e86bd8760da6ca3b90913c3ba71f58cee0d4cc8daab0b92c3e888a08c21fb3e97fe9716b0191a62767bba6cd9bec34c5c14e508905c00572f1f1940c0d35afa2a56f39a828f8650d2b26152eac6b37b50a09da2d787b1dbd37b45a3a2f63e9fa83fea3aa66db2f4b5e8aee2bc35ff403e0b1bce942b32efb36eded799272a6b326b32b7fd2208dde9c8121c9f9d5d733941317acc07afa263ca7ad9a344af5968009b105621c73dfe5ed6262cba996b261972edc58182b1ed97747aac1e46ca7a41684b1a63c05490f6d1d58e1f4c1b1efda66c668266a9472cd79ed38c0107c9bd861f9d05bb863f493463d8832ccf28ee25b1768baa9bc1d25c16ede391fa1a6e476fd2a7caaa8fc09c2a5359ab5b7f5b9a7edc60b9135761fa9470f4af7c6ae3610f31fcde497b013abc82e5cb745ea3c6efeea567322c79439d627d90efe7bc7b010cdf428bc845e75796a110e274b99e1045abda1226c2528954f94b1f4d9849b7a2989878ccd099e6e9c8ec96729fc76e40fbc1260eee8a7003619970e2307debb11f896be620ae64c8b5b800828ba64a2eb45e94a68df6d9b57f48ec438041393f6fff744e164d503954c0c7428401dc8f1a5e52b54afae941b986f362de1a53c0b2a28e298037c1a0ffaa09ac6f02dcddddbffc5fdc7c952db796c91103762eb98bea3330f91b3ecf66e7a3cf0b653b064adda07c511b93e8cf3984ecde77fd989f36fbe3d2e1c10dbffaecefbddc54194396840c6cbc974abfa044cbd337f9900284fd4de99e39371c7e554078ebc6bfd5080f6340638cbb7629e2e79f35c6960713e6cdb8a10ba53b3a5b70be30f99a8ce612acd167053bafae5c016d7ddcdeec50e89af27f3c17738a410b6a7bf49529144c6e7bab7682b8b6ce0b4e12775e42d54d6428444bdcd6c9ea0d651af00a7b36c151eb18d0bdbc8f637da81d8f7dcb2df408c38d0289f30d81153060dcd3a9215b888b761fe361ae949ee9f2a7c47eccd7aa700916b06538798f51d487b1ffadb8c322fb7d6c4b407aade3abd5b2f505859c48da32db48fa59ad5b5a613c598c2894baa7d02a5a73367b05e9a186f2ca6bea709e98c9eabfb4cf7699e0ad2f4d8e1ab7e73cdf2e9e01b6427d8630ab0f97eb8ad9b97833427cd5b5466bc7df537ff0fdff53776143b56955dc307e4de3e1de2c4134f8a7978b0a715d07b08b0fd2506ac40a71d544df32dae6e0aee0349ef87d153419a35f67999dee857d2e59ff7e37797028ae131a9855954ad0e13510d1a08a61d496e80b34cd5ba6b53072c21ef7a70ccf9135fbb9610b0d5d14fd69f585bd1608bd5ad52a3a17af68f9580ade1e5a209545e427e12e144f9199c66ce32325a97e02d38eabf1f5879b95c3ebb35276e4a598710c194d234af0dd75b97f2f7b42bd79712ef0637f88b00e539fee28c3e3c4d6ad7280deadba9f36c5931e84eb358795a41314b73afeb36eaf95accb3c5c0f9333fce1584bea741005773bbdfc5589a9834a466467d9f582e1c04e2b6fd3105c82376aea89a370c4a4d1af971e13888ee66b391c08670ac3db5f8d69417827c53353c57617fcf4f4196c5355cfd3e612f534811bcf1ac6dc879196dbbd43abb436342ca9d75e6f58bba5b99d6e3ea5110456ab8100055b0d09c0e4daf8ff1ce08b2cbf6d87085728f586dbee68df1a31e0bb6e68b44b9dc90f91b2467e4a7e75c605876bcb76034ca38c0cc20bad35aaccca5450ca5d9f12eb2e2b275009acd5bf542515e7e791fe97965ca1cd97cae84a5e2901238442517fc3a50a217bbe8e64aea9798de5e329bc772c4d5389077bacc54bb96402b3087e859f2bf6460bc0412dfe747335b05c79d12ea3d388b173490541ea1927d02c967b634852231e4595205e242d36c572d708340ab625c0a9714d66bf78b49931de4f60bad64d680c239d39efa37d5b030712c716fc39d29dd0e53c43fe2b0962625299dbaae08346c49f5ac885dc7d9eaa0712c0f7e2ead6cc7ff4e592a615d9c805cc23945479e11572d5dd31a6840e877482726692efd9eb85f6c2d581d412ea2bf0d40049a5c1afd284d4004db529ae6a2b5ceb51d064bb6576d39bb45c30002fb51e2e8120f9e811823779b0022072cb1bb1cb6246e36d71e4db61759fdbd5397a8c011aeaa07823df5676e3546a87c4fb55bc49d17c3523a5a3d8cd582574d943cde600f26501bc0f964541211425cb68ac6cccf832ab9b39aac2edb4dcdf604cf01bff20590345c401a057ca432cda6d32c9616eac35aebb6af2cf948408bf79ecb1cd9e6e18f10ac131193b34d9a3bd939a0e7b0f90f3ab922b6edecbb20bd0797964265f4ec391111c8316f71fdc63094bd85384362dc5b69e92b5e6f13d3b12f0167a0a4d8bb0bbe856349bcd26598cb6ab12679654206520162e38fad7d6a6b3f85526deadb2ebf5307bb23fe9541e3f2a93806d7b2479433e9d1e1a38ddb39106b3d77f05e823b555f3b48db80d9c0b1c897f628129c8c1ab72894f727b2bcf42a347b4499a98a5b5fc9427ef0ff2b2f380efac62cd5fb84326caaaa29c513f2088c68d7fe6bb7009323c47abfa64521c2c4d223b58ade2f52f1d439e621cb39fe967c86c41f0f6172f9512d47e050f49b6725eff37ebb0c104c9f00c2b57563d3cefee5d5c85ae8b9a31b5a5e0dcf1aa7b31da5da919a055b7ad08d2be14fe9afcb4c3b9b7a2b080618e8d093e2f34aac926b3f339500821f79ba7416630deb91f466e73f5c535f84e255a607fcb1256c9ff0e9378e0cc60995d25a1d2db846c688a36ed090c29d9003657a9dc3e14756bc147a946b833deb8057a55b228373301d22c3640884f7fe5caaa06148a8926e29fb7f3671ea29ceeaba8f688a121b6050745d7335e433c18f3c6ef58d502012589a38c79222d9c2521a9c73db5fcacd1c490f3cb1a099b7228c700af1f90ba3fd64c8ea3250c9a8681287468ecf41556ba72222c81c0f3ad3e9202e4b75e9f87d1f196a3c0fe007ad967b0476231bcf0089ea8077656d77bce8385cc7c1b5ff3a8a8265c521f7e8101cecd1b3edacfbbcac7d9baed304d1e4cf82414534281db6f17745e85aabf9221e98154d736c8ef6d4b363d10c0b7dc18318039624a19138cccd81246ddc4fb982be7abc3e93e4b1541264513345df79cd2fe405e0c82769e24a9ee8d3acac617d30ff8a113e72d5a5f331705a11d18824d0394f47c9472e4e1378e1855cdc20918c3617f27d6d13009a2accfb10abb629624e13e6395825743474586242109351ab9098bb54087862513c3343248100cf17b2ce0c75f9516faf4d6d597988a2f1b48b4fe27127377f4c8531f73f1b929f5c614fcbf9f4243e100bd20c6520819a5838d158ab3345129a31fe17322901527abba6bc81e60e6813a3827b0feb361676773d1ced5258087653adf2f46a6cbc8b75015e9fcab7133e89524513133c90e7989e7583b11115344e0afbcdd043d6473842d7fbcc22b3a132461f1b190bb9231a521bfbe2b947da121c3f98da688a29a2891cfe53467c8ec51f7c912f98c8c01f34862877fc2fac3351d1cbdbb369b94ebcd62932bff91e433b578d70a932409732c7301c3ff8804b1d93b9a1b5b7a307b2139e4407d2558a0063c7ff2cf1d57","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
