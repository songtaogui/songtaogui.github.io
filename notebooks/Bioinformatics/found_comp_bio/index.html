<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6fa0d0f3b3fac48d823a521b3376f6964e6db3dd27b493a976ca83b4cc2f6a90275989dbbb1e671aba2b02bd67ba94d61a68f64c26b9465c962f6190f8bead7ed70adcc0868373d5731840bd9358f08861bc43f01a543d8d9ca81e29e3500187cad4ba524aa5fdcbbd6c03d99a7105934c24b249b8be9763f17eac47529127b334274422ef19741a41dd5df98fea61de271fae52c23906bd91b733b73070389c30c9e822549ec021ec0fd16d1942100052b7f062c50ca455ec366168179e2507c6dc0d931d49bf15d51a062e6ef0bf220360058fbcb8e7e3da3d645649dbdb10aa0a499919afa159ffaeabc08d56d14c3690f89b2fbad748537df7f38feada94eaedde5a18bc94519833d21d34bfb942a1a96c2acafc7aa99025cc3c266cdcc4bdbf59303f0718e139cefdbced2094bdf092beec58b7c3996a8430da28a1a96592e952fa67e546254cd76e94007620f7458523c82620e85dc50fbe888d5221ce8a08d73f7cb4017215c5c5b89c25917f292283a6de20d9784d584a4ce510520d29a4c24dfeece1829ac090c07fa76bfab25a70ad58a3fcc8e026bae295d09477e3351ba5e9e1732d064949d89d58a1a13721e4d421df3d108137524fdfa1d12f7f43135a62f592186e52c051f5e6a58bf5a2982894ef390a8ada92e329a35e119eaaee400a0689f91197d04ecb48b0b100e7963c983904be77a66d82d852728b214c7e08372053ecf5d0c6988483c934342ddc40a118bb67c142cf6be308630193aa79411eae3aec6e30ef47f3572a2751f4287ddc0fbc388499cfee82efca45d68eb042aa9cf34e66e6ef4865fdfb87f98e4b4238f1740be3fe26a19e6aa1fad485d5f9709e84cf8add5b9107a4c8baacca01b2269f70af66dccba38725a403c9bd996887f9195ca00e009ae8de1e50d34a61c282291154651fa7bca7abcb4a78e873d664b8ab692d5a22a64609e47c514a2c42be3995fc59fc153b859db4813db00e2a7728039440537753967ec6a62091dbaa828709f86eb7519ce57f068b6efd367ea772723b9191d47dbc0b89965c4e60121455df82f70d8bab3cc4876fdca9f5f62de22bccd5918d34ab27366f8730db80c4a9a277b53d2005836c69d367bfe51e5226e1a8682ffeae951cda30acb628478117ed1a4dcb197b44f85c6be8cf9f8141572b4d1efab5d87660b873798c59e24da69b8ddb17d15851282db58032f51b237d396c30877d0998ff480c249f5f87b2486675a05a6af9731b75126ea800d559c146d4a37d5efeb2cab45904c9041af1e26dbaac97f0a02d94e5abdfc4c8c1d83f00bf0a8f4b7f21448d12726c4623dbfe93d263c978b5cf0ab97ac7e81d7392a7c4028238d5998aae77adf31b6175266d6fc2250565237f894a04d399e6c6e60695740ed6a7be59f8e93b4ac2d8b14027a6ed544d858e4c44a335af8c8d37ee3bcf5c0e8e75f4247a96cc707ebfde730696452e1d259cfd0d7d3a28f6a3d0769916504def7cf1a1e6e96fad34308fa180a6396ef904eaffe8fa72fabaf8218d1655c844fde3dd5d4fa2f78649ca4cf2e73d94092fec8a15c9df8c7dfe814070e8fe6d03d0313a912b01ab8e5dc36bea9033833a6c7f52af142dc8b8cdf78397432e0a66c9dfad5a1252828e22cdd07f1f1f66f6a1f8d12301e56e8a2b69ff41985d071c23c585929d04d854a60ef8401a63a39cc6cafcff89ef54723e17ac53c4ce6f6c339b8ffc1e5c96a314ac60cf234655ff1d20b4b92ab84881010be59d4650d6289e4b1522d6de20081b67236451e6406b598e30cce68be5f045c218e73a1309c8a0a78f7c59f5a143514da469ed77b9742251388356a3e77d99f1fe8a8b03c7e1e83aa7c8889b0c2e92fb8bd8f28de1566569931695a7fbac5cc326ff50d083bb06da5f03d4366852613d517697e91a3273956425eee9eb544c1e3302bd76eb32a0ae6302e6489254d3fa1f22de7056894980f54af0c047f97b40049bfe910ed4ecded552028159120cf0fec0a8371253d72ca8316adc45099ea152aa3c181a539b3f55a7fe4f3f6d417e0bd0d3c71d8d00766158e8ef55be8db876e623487e6c4fe6be64baaebafedee4869895767891b239bd76fa34590ca519ca78e3af8e5e3b116bc7c6a2c147f2e897e22b050034998aced9541ec633cf9657b11fa538c23e706ee1d88dd7440bcda707d852d13444fd44316662371a1eb2c69a53f924ee3e89ecdca50d58f3ef8d14edd78eee0df008f566f27ca3c4c2d112c41c61c87c3cc54c843571b69b3256eb6db08e74b8821d0dadde444bd87cc1460b3ce3537ba034e28a15be0cb3cd97c485dc3a3879468ffa8c9dc66acac7be7e596221e29ba243055a1a6df1332ff3eafa8a369d1c090aaaad6d1da13c30f79af10a66b66a7bde4d0d7a7920e9172a63200204c0075d200de51b5aa41d236a7e55b84f4697319487553b0c88e4e9497037a8659f5f096a0e15be152cfeb9eaa2ceb46277d0f738626afd5a0fe3d0c669356e2bd4ba11bb5c898ee110fd6deacd7f79940e1a4526f512b5c9c54a117da063c6ebfa8b378f5e65a4b4ceb74deac70da67d301db8f66b0fe1b0985ad80f10f592aa6948dcc0ccf02c2cdf260b6bf3e1edef16afd78873a60576a19fcd38043ab855c64f37103190be42ae3fd928e7b353337e980cf30ef3bc3301b24ddce8bff1b3fbbad3543f47ae76cef1710dc97bf4d7657663be036ad077cea3dc71aee432e98273487e7174ecdc4e5af130c1315ed24e37a171f9bad6f5bedb0ad5376ff03a5b2e170fd3eadd7c89d11ee69fbb9744061d994797c9e52509e9628abf136141a24fe7ea0589f5f4170a400d4c33bc71b14821a72d7e35812094f986cf73f527f78f0aca56202f7541799ceed18a0c15875ec2b3670da8f13227a9360fcecb873eeb10b08280329a2553c67bd8da0915404276f614a879ac04a14ff5aa78846d0999d0dd728c6b25838f9137c61f300f2f42bfe095b0a48baf3a96d8a7f034f7c807cb284fc33aaba83a10819212a880eb87c57808bdd66fe37e7ad920970ba39259f5342622e5382c86df656c5bc673cfa846748126e0da7b8679af00bd7225d4c86168dda313bc9790f73ea6a67fee10928f406fb6851d15575ffe1ac5ad8995e0a750c6a95ff2801dec1e5e429ee33601ca18d8126754378f663814a0eb7a8c59b426a374b13079382ffd71a6db72e05dcbfd14be89ddc00eea74a6cf6bef3fb7802f70c0a6c054aafd8e5fd44f4fc4b92de31afdfbcfd41f9b4785dc96654250e7b9050a8a58ef52356e3cc4a8cab56ebf8288bbd3e5c8d7471b09b9be4b97873e51a4955f3cf0a316a84bb667994721b71b8570cae42cfaa489a1a1141c0a8c8fc4457a9e7aeb4b0867760e3b1de8c4e8c00b96fcfb85a08f761d343e363059a52cd759d08539cf3b8f81717ced5ea8d8685a8e5574d56afbb1e6a85f62dfe95928c34181b37e1830def2838d0e556001213a66b63391d42ddc4e8ae41f3c1deda20e0d03f8b23297e9540fedb7d1981a47c528ebbd391b6b66ec90a5c3489e8de0a331cf3da8905667d010d71a51f8f1aa1168ab9bdf1649dad816cc33d1d5dbbc4b327e35104f192eb9deff5e680307efb891793604ee9d9b72bf334c9044284f053bc12d9b337275c8b2eaac769f85cdb9b838ef7eb92bd1d91f1f71c89edebe814ab3d010a5250905e50159bee7e2d49fed4c96e189aaeb6210132e9ef13b5ba17fb25b3f9268934f1836fb970ea3f270191f829ac279142d578a6fc747e138eb8f339a1a0d475acd90089fd0df94c6fe29608b0f296a4d14031cf013e55da352e19543e4fe0e3c72e7082c96a1c905f5909d1ca6c86da6aef2cc30801ad0d538d3bfa548a34750a4d0e1fc3d3d1b2eba32042a89823842649fd1555f088a6ca8212211fbb6c1b40ec734cd3799fb4877fe9c82b67b87b5d3b6421edaf56a4d40d145655a034442a4b42d1f51ffaa706ba34302c62f33854caa9742c3857aae77ae4c5e908065d63dbc6f62767de7987cea4b9e89971c5d4e33ee492d6b5e605662be6bea41e7c1a0a0b2fc42c6be0b5218502c0dc72f69765add57b3c8d21b8e84e65f5ac6790086c34de150edbc3567001720e6c8063de63229c81bc8edc651f23ce8dd7253e067620b35c6f89781afcded1e8c789b1d9f14729694a956a1b12c65c4dbe7ee7ad00fd43782f4a5acd4bcc07754f247a73ed4396904446dd64f810a977d69b1268d577ff57a7068c323d354e9d5d9efc37c06f8e1a18b8ef11e6e875a07dddd35e8969395c1dce8d0547abf3075e480f0a4f5df8add9fde24f60904b104fb5aa25d455f17cae0dfebbedbce4cf12e096be1d9a48a7bd15794602c6c8b98d7c3ac63fa2f6575bef3f17895bdc1f8235b89bba09d9a89c402e6d8eaf64ec78bfb67799f0f49e655384e9013448e02ec2e5363e19d03bb121ab0a7212d0dacf23f4188e0b74418984dcff34551361d914550080f69f53d392ae11154ee827b2298d53c4469eedd97fdd413f8403270748649c1a37c923db2eb7be55ebdc0288035b892c6d868e042cc93b080bb466f8a92e7c537ddee6e7d992b67c12a005904dff73fb88907164856fbda34c52adb765da25d7851e06c9b04d1474269130fd14ed4e2e270890d00727f4aeb449496cdb0e0e3903534717c8e69e6e5328e2036ecab2a4522fbc3b20739fd2c83ddf5344d6f41571e3722f3170d127d80b319714305d92949ef14fc3bfc11d79531891eb215aa3129f36e2f04efe2559b4711dde854e23ae71644f48816c05436afbd492d26cc0b732652cfd951c47ebb6e08f54d45bf5ecbc316faf3402fee077b887852ec8f07ae4d72b695394cd6d01889cb5e8dbeec330f61e7e699aaa9de8541edf015c2c44c968245c03f9c458f8b288f0be8cf88a543eea657ffbd1b5d0bbee6a273cff647f99efac413653d41875d486d8f37547b3f9838f2a26982aad5c224df2cbdd4d834a832b7fac22361fc3b55be4675daeebc6a7807338ec94eb62220ba96f0ebb57ce4cdb3774a427dbaff03f218cc0c2372cf081ffb03295f0a3eac96e2e2449a2f069b2c7b01400869bfb062622f3efccd5ca817ebc48a451761ca829a2785e22af564b14f0b778fd21a0cea6a047c5070c45346f300f91a16776e755f9bb54c1886c486ed73cde4a1db62390e693bc91a6b4411ffccc8adffbed7496e3a0896b1bb3a413084fd13a05ac7bf4521fc7c2d4483d06f2d4dffd583a2d4d306d0c32300dec7d932678140f6b7b97021ef6a2558e306bdc712982e4dcdc054d902c39dc6b0c5201026b156adacd3ac1422fcee459eba4419d1e6a4ce6d9ce40611424aec152216089fb70134f72b695c915fbab2849be4aad6a917dce6635b08429b3c4429d8a2435b8c3d0c6a630c73ddc58b5985747e8531a09b06749cd61018d2f8c6c5d930012a92595edcefa36310110f6085a4561c63e27b9a2b174edde85a04fa6d029e7c556488b83db61a1b54cc0877bec2d84261c60fbd3e2859336d1da7410608f8cd3f6b8e84f468ffc3da410075e5ae0619ed80ee41eda46caaf48bdf5c6b2a0108462f446cdab6f2740211e0fdb7027004eaf7a46e0e756140a87704e67ab338f30880b3c9bcbc3bd6104ff919e3e8068628f59fecf705699ecf26dc1b90a22e47e9d6568b0502d5036c539721eea1b6c9805d09ca4fd619fd11135731f676a046723be534b1afff9c01814abb48e2176005ffefcda019e4e38b22ca27df21a1a6d78b473f9607bc146df16e2de0f8859744ac328bb000f07969eb9617e2c1f9b5216c24c85bac17fc338ae9639e80fb998bcd4929e23ceedca092dd9363c41d06d0baa32e0b4fc4ec14aa1e508180fb1e62021ba74ac8beaed97f4ede971b072616699a558218cfc9ca58182bc08ef0d8df714ef3204fa8d8faab8a3d21bf8b94bdf2abf10d47e5c152fdae45553300393073af34e97c94205b78b59eeb7d69df50025edd9ff191d61d5fb9a856cd4d40666e4161ae5eea5451329513534a264b389d53d5eeb04faaf8d40315ca5d13b1815de939a8b751b1b343fd140898ff73f25eb4b543f148856848b272271590ce5779ca4ee286184374638a6eca3fed626f5fc5fa67e342ab4c164e2caecbf61d5e05ece241a96d1cd9d8534d2a0a286de1cb6c2956744f1e2e1c47057a64345cee4c868af19b6be796657d649db6b3b95557db35fc7c8dc25efbd90bb96723b983e153976a1ef034a2e4a3ec2f77335579aec56472012e26ed8e255602f8f907a4fb69af47f492622b2c7cfa70f768d93606490ffeb79ebea040c759ef875bfff367822786199c764b4fbae2e8945489073515b47b0cd17925c376b3b1d3772a628c0126aa7f67d0b40ea2679f85a5fddb8d1e426c5c7353ddf29bdc97d050ea1b28392076646f7e31d8f532c8b34f09dd131228761ab1b8e80374c984875259ba9ea27daee488ab381ac990c42e25e69ad3fea8016e19dbed246a946290f5431a7876578eb6a6bbf012f0e3bbc8da29c1ae30d5d6f47cfd09cf05eee81ff14cca2d18a27f828c8e1b5eb9a865271b39984d546e900b9b1c5541fccc443313e0c029dd151798a4a3e2f28bab1c9c5711e4147c2676024717be41b594f3f07417dd0a910ab7cd9e93fa6ef94891447ea26bc5576bc68d8f5c0c4eb6f9dc7190667b47ce32d76c09a17bc7951ac03c3b5db063f7f0bd23a2d9e8ed94cce0196f3bd70baf126c9b1afeb9b3bae9430f50471d42c8cc5af0dae38730228dc9138d5129d08858ebdf092711c97283b21b2be947f0d94bc5bb8a36a4da859881d9a036313eec4d82e72e8860cc1822c23d342fca4b693ac6b7608c93debc580b97804f8310b091e342a31ab9873566f71e71aa33dcc765e5a1899f901424e9c5d540802ecf7c13a16d44234c272e20c3bc21334c69cb733fbf09758929ac9853c1780328ff21310b0abcbcdff326142f61c07b15ef582035b743338c28317865e48a02dd90d4c6ada9a83eb2941757f3661d4abfc317b881d9fe4f606d4f6e176db7e0ae2934d1c0fc6bac5e5642cde5d785bd7bc576a23868279e44fd9bae6f3a64eec5f5f8f88689998d4c54b294779415b5726eb6b3991df40ffe17792d1688098efcf18f161d22c03c6b86a56b9abb14d56505201e87743dada75275618459ee7cee5b6934ede1995ffc9f5ba74e162b147e07a1242eeb584abef73ddbac40a3dbb27a52cc00597be572353ccc75cc4a35850bb36d8fa330ce182f0c0271ed98033bd03cea75b9fd0e24b94a8ce81760fcedbc7a828bd62ae5352d3a9d2737f27af939cc6a8d1101252d0a983a229383fe93ce16065abe022cc520006d281354df8b0bfd9bc94ef1d4e39e1190c1b0ed539c68836effadeded3b0f4a4376ddd55a8d79922d1474936100c2edc319d94e9f74915ea5943f961b06c9f1b0d1ea4bae7c7273b060cc821c70e6477918c6222c6d39c8e2caff455de21b1bdffb6f2f83ff2ee4ef4519454e460e2be914e625851cc44f05d6ed8eb2c63cb8a79abd1c37b90b599c153abcf3834325a3d0a5aaed04fb00fbd4aca9af4e5872f2c54266b6acb60d58501ae799e46d7fc562c9718771ceb2a46dbf938a0cd4405290005ec315000fffb18ac9d033e149d1a5d7bc7a7cd46ff928d2bd02e7522d0b109a0a5d9c04a8ce33afad2d7e956a88bbbc172b3ffa0d5b9b2df0d551735ff9614b95ddb972962fe5186453d59cf70be1ecd503a84a6077fbfce1a5439d976c47c4288265d4cb52d5bdf0249a28a6b980daf076b0860245fa9071d334f13f0d68e35e59d5b079c3808987fe5c474563b39f425ef4328faf036282b97cffbfdbc0704d38e16e0ce7fdc68a9aafc8107f4ba6d2268a0e6293c189912b9559c2c4710759652f8b172591336b45fc06cc2d394ef967c77a41c882a3ccbd849e2f5411a02d3caca3c1d9fe5e726623ff0fa0b6e9fc42d21eae4cdb759d388b315c995d49ec36356b9e9b2c19bc7f4c0c5e5a7d71296c0c0337bfeaf3bd3001125f201ea438fdd4edf50a7460a223687ee335612870f21355bf242ffcaef7edaccfe14846f3d099f4c493279f7e92142ce6b8fb6a7f458c5d1ffecf9192b5a16b50e65f7612b2a9291043f976154e6d3a3d5f311eb4e977926a82c9b4aefd015dc4844077450b5038ea220b193e3c5db149e97150b21924ef3ec32cf192ea7b2efc42c52aa781a04bcde05fdb4d4c58dc20df27908d169bf05ee47ddbc3823259e805979ae093eddb3fea5bdf890264a734849c4cd4c073bee4a12319853411cae2ab102e031cfc5fa1ad5fa9992d35dd9966d241ec40c5e1499a7e014860468734b904569d63e9b6592d5a76e66e39ca98b1b1cbd8c083dedb1194fcc6b782ec9df213a0debe280f8d748dcd9b469424f7f6a585d81a29ed4078e40250c01f2b57cbfe2f6a55d1420d9d0984e4191a3e87f70921ab3239fc07e3e5871b56da2d85fd6e439025ea7c5fceb755d37ff6affb0f8bd0de001e5b198394e924d0d060014794e03ff9e776d36d35ee0d156b10fcf2287d82314d4639afee6ea149f9133ed917debe816c2cb1834c18675f6b4aaf0e72327149c5733143daa320bef90b88a7f1785b8d55764056fcfa686079ac99e68b7347e14be4095c4a8f9263dd56bb80559e8b06df10280d0179f79a9fa8fb437ac0705af4da96099fd47a6da1293d2da3caa71e10b55dea22a6d51084a4816707270463fb3828aec460d28e085b0658f8cae14c82a0df8a866cc8afe075d51669c270bc2377b45ba9a139279045b19ec004b725096c5119ba79da091cf7ec32ab3112be1365332915a18d344582959f15eb4b1f55a7426c45c2f49f063ebdcf8ce8a07ea7c11e77a03825edc6abc4802de942623d4391abbb4096710fd1ed614219bb20474c95e04e742c14a7b1829ed04c77040cb346407bbb16d05b284fb55466f1e1f8edb8fa995353a1ae4662b97efdf329091caa2b013eb63c20d13f0b8ffbc8556af0d61e41c2f7374f43aa1b49762850821d713d8a5a78fd0ac6768a175b1a4c2f01d12103cb9094102d8a021d5565d725db443414b2b8f162cadd962082cf7b28cee7bc6c639b8be6abacf344a77f8ec8f4f41a04eb661e371966e36972939124992e222216cf1504011191bf08f41fe5109b45100fb85fb32b65d6c6f2fef4346692014f3dc177dad58a20c7902c93f0a7eb0081f05eaf2bc3ad25df85b7690d9061f463ab768be59a584e01adb90314ebd90081a5aabc331877d54825dda1e98e2b57314fbcfefde9d2eb7cb7aef1729590633d3ed956b74861f8988bb99b13ad043e631c3e238ac723c56981b082f554b47e349be1c0b44b3de1f5d55050d6389d3d65e208ef74ea168aebde9a5a9c123a8ba1f2b4d76dfeb12c3622343635b469939625602c7a4d50a62acaac3b9c9cc2b6afb29e43a4a2c5da47e42c7742dd7a2211996df8978ff3e4a785339f80e785044a7022113c8021ff9a8424e8113cd90dfd84f624091999a060526955c6cb9a03ba00853ac85b31061f55fcd34b2df81f808a2a9c2e8077c016f3c54661a7408af23040afa7baed0e33c6997fc329ed212f38beb79247d1f0bfb7ba3016824886bc2cdb4a789db8dbda91ba21fc56a5a4508f36212641397207527e947c807160e7da3ec1896922458c3494a987beeff9bb611f55e0d867e8657f1d694bd68d4c665a5fb631fbd727b0aba30dcbf08b76d7210f3be39e9ed6ba90a27ada8da6900e2d87c00d6f6737a37d104fc8052bf65a213a04b939baeb182ca4159c74784c631b8d30349ce5ec1d96e73f7f303403d28f612b911e761ee373d28c7045fbacc96360503f788803b732e6c5dcfc25845a4b415ac3dcd1693643de1dbb880acb18d19edc1be5dc6f582d7ffc9d86cc913e43891acb9e7daf7223f4677b840bb1e9657b5b4799dcf9c42027fc038f9d9149c763f6675c172276ff05ae6c2d16721735a3f4a1c0d149027046f353a9b257702cff20986a2f0c48704583a50b06da69e5a59dbc90dc37716d4fad3f48c5982505cc6867d3df127de0aba65e2b9b10c84813ead2b0841a1a79bf524fb632310728a979cc266cf5a8b9b9591e1b91bc832c0d10750a73d870b72ac2e9ac6f128eb04599a977af9731368c1de74ed725c044990db8e9d852bf859fe931a4902257e0369f8ad3601202031ff55be8f85ee63b4bb86a721542f5e6b846e9be7dafbec6ed10185b406d5fda127dac65270db41d34057047dd66727cabdffdc0866e99ea21d242e62748c47493eb474e8fac16282760014f5721eafbe6af3305bafc8ffd9b64c6a9124ed42ad2cb75d5ff68056ed8e86c1619c8b30c3c3ed12f343e5e09b820711915b21564ee5f0a4a36b9a91cd265ab54c4bbdc41a3441557a1eb188fcfaca0388d5cfff34cf8b19fd11e50e22340dc209f5d434ac32a381549e611e3b229a89a1bd20f8d5898acbbb62be89d4ad4ec58413d4ff1a9c60fda1a028c7d89d593a7b9c46b0bce4ff37cac6bffc8caf1f18bd723dc1027a3cec076ceb5dec7489d6219b3b883083875e8c95352e124aeecbac6b4681f2d59f3e0a4caa24dbefde5c7c13f7692a55ade214abd88b36cd84bc250bcb810250268d4b583771f30efb17c81b3bcc2528c78d46dd99351bb89c6d21c0376975ef6ebe299dd22d48c6285e4b1034e2fa4e2c630493b119ebe1410cf4fe50c36a6187cd9293658e9884aa4aa659ed7d4812b959e1a95a52c2be86ea473aaf2008fe6e40a313aef8ce504f9c05baf28b252dcc00cef81650f65beed0befa16aaa7306cac3220e68a8faffa92f8a4ad99f165448afd7482a38a1ec05b6d939dd97a4e7d31acefdeddc10d32c31b40b98c56fbe1be35cde585cb7d9d396750257d887b9d9e4a79ad92060e9fe458fa275857b1188895a87ae1c0ea160481394aa561161a383fed336020ec570fe25f613993ec3e3bc7cc1b26f4f5c9b6236f7dfe6f6c09225619e6c8dde2c5eab46a7ce5487e5c3feb1cb5eace2156a91971d7bcd828aa6e169fe79f48ceccac433922a8d3249617cdcaf1eb0c74a2e8152091800cf1418a0ce1fc162bfec1aaec8d613008464ed2a3884e96f1d5dfd1e3a0a4ca47c888654945b0153bc5bf9c8500d7ebeccb5dba135366c0f5db163464e17de4dbecb75bb2cf1f1bf55ce52b1a1defddc0697dc1e2ebad862e3f764cabf9ade8efcc4b923330dbd8ca161847d0ccd3b014ff7ff4e8e96b90f9ef334bdaeab615ee7f9b7cfa4e0423ffba3b1975799a9787009d226863533587f63c4bf43f695d9fc0e5eb186123476fa761eacce5309e2a7d84bd9d4753102465c0e504fb9dfa0d3607d2ebaefccd8223766982fb0c2ca72806aaf8fd7e9314d8180d3730854b8d328f33d49fd0cde6d062e9480073dec720724fb71888122a36b7158fbb957fba9100f2d56b23d4f1f7d63fd70bd329ad73ff3c884205d544b0999c2e0ca78178c06ca5df8d43cd5a991e78ad606af61bd12e0c419ef956ad9833d52c400301adc861dabe60d77731c829c84c193644f2059eb11fa57b1dc280def5ee4cca819dcf258e79da802717ad5a35e9e5224d819529150cca1635c127f135f41300136bb1bac3b53faa03e5879951749f8985e2b0e4f5a4ab5efadb7b640c511e8fb6b8a7ebb16d1f08bd38e98dd156c430ec01a81cef345fd77f9c1a49f548c4ee96f75db6d29e796c9e73c1a363820f4789203480b49539bdeaafb66bac0af93f77fa3d29d92b3b8f964b1b51f8d289489984b176fc50b1d36f693b6c662859fad5230ecb108a36ca3632060b9a56104e75bded7022494124f582094154c2251003c51a1eb62e8efbdd2d1069d15ee1dcbdab17270aa8f54b69d7604ac64d1d9384fb7d9505ef600bcb422d68882553005ee3931447b324d25541030a3f69cf551fa3a4735d44b65154ca7ab244ca9f945c42199df215c577b238aadbfc2fcd1a438fb4e2a01c9e76313292b9c37e4cb1bba639d9e5b90fd066b5f03f5c1c644fcea734bd5975ff103d67a7acb7739f1882475245637c67148ef52d0dbf42972685eaa8d0c27edcbbe00757a660efcb8a52452c05382bf0265b6ac366371ba2a6dfa6dcbe694eac50fed6b7846208725a8a23ce3304ff1dcbf359130a767adaadafceca2e66c68a4b87794dc483accdbf7e021e064e4e4e680f8f8bff094cdc07431e5e321ed8c806869aa9880da917b027c7f6527512a8678e3a9a6fd5480cce0cd2a45d30aa31659fb2062f5a3ced2bdc4e9c7d327ccabe89b1cd48be83b092ce6e5f0a3fc870baa6d9b8d8004bb49df4f09472c5192a3f52150e372cdb66c97d0f3e05e16b6a99683684a925b527849da3b614528ba791d984792893de3da14f95cbec24b40fc33d07ff005ad4c38a63c61175857d65969777c8a4c9e06d508363ee0cc91e267b1393b6a38c3b4fc518afe7cac6cfb197399d167c0ecd2e9fb5341202c32971b6d1262a0cd367a9df66ef02fc62fc0433cceec2e01968bce850e1e079dc66754fbfb7cb91f7392d0157565b05692c55d6c35f2fe98c06f882fbb6dbd101ae2138cee448931e04d4c208f578e7baa3f3870f0303bada38b3e2d055ea2cb7de070c09e4c5df4468b96eb0fda8cb56380c0f577ab37e016221dc315aac580ba4613ccfb7c848b8724a20a4c15c53b4e7d86604bbdeacc508bebfbd74638282f17f65b70c3385e54accc2b59a27456a7cbc49de04107416451c0ef102e28cd364666594befa7c658c39da445bb918fbcef8b9b93dee2269aae95e2033d7533f0276ed1c77a5bf2aa207c3021371a607df14e681027b7d8e7a3ef66be4bb7c943e223c706e2a1a8623d16f5a9df34dacda8d5cb1f2f2c4941613e4d1aa05d0a201559d9b301624135765b530bd3ec1fc9e0486375393686cbee7ade804549bfe6fc8b191fcbc722b885976c536b3024a9944f56112f6358bc9f52a9bb42ba946cbcfe97d4b8c03d5b8645b0a19676603604b9afe428a6024f36ba4b0a4166618a1dc7f53091abd3d31699fdd197ca6a8115eda6d23afa4f46cd3f105d9afa3938f8feb3a4352bf1795e5d9107fca12b96c0d3b358b0f331c5f9803e2adb08bc30b481e85e9e51f386d78a726d7f3b198b790b9d42344eff160d96e9d79ef5de0e3302a5126a19b356e868e6c72bb13e52abab2397f0385937598e3415d512f3ee18a2806ef180c77aed0d2cb31cc30a8df3cf327005faf6e33d88c2fea652ef21219124aa0cb6c9f3bdb7a0c4d17350419d6bdecdf9677cce736549828e533b3af4959e2c0244829b3e8226c1d8c21123d1b10d652b186cf38fcd336167bb737d0e488e51e59537d8c766216f8c17ec6f2fadf795bb035d2c0c604d2789f87cbf0ea340eea20737dec2d47be28ca7069a69790f614cdf187f9141a3593b1a9ea5530cb5fcd90ebfce5b2f91a57d9d4bc45424798f932099f9f5e20d263fee318ff61881158683c5a5ec801696f76f8ec5433f8d5461d7c4ea1e76162f8b0d48d339fb3dc638098785f205ec0a07e3bd3708e7bf321b15869cf67a4c97ef7f02faacb86d0bb65a917d07ac5600b56536357c0fd94a024dcb23a8b6eba762b5b1366f9d14952315f142e071ce58f1fbdcb8f636b4286e6e9bac11dccb0579699f033bb9160ad86913e9f064bdc1b513ec9e4c2d04fc6b00d40b5fd4240b0222a32cc1d03f4e13af7ca8374fbfc59a25440a0dec3faaa1eaff3fe609a61c5f3a22a012653ad454045a29a1cfc76078b78df5b564608b27ecce71c7fe1561d4d5e8f27558c56664b5ed520f2af969ae61b2ae8d3459bf829113b12b12adc433fab40c48aec6302d697749a9b53f7e24331cd992c4344f5850d14bbf9a811e676680967517fa531576d21f41a8383437d16f45da3a374541d5d9182ff638b8f0baaebaa391a97a0b5830121a0ffba20851c33312ed6a1ec1134d6b0044bf360a281d5d5503b2ee078ef02f5149ba8e5d99ec75c2033434428711c070118a27b44dbbc34043ff791d8f8f5df4843ce385a7890ddac778643a05e71f3ef913ba24a20c925e291e2d7637f2d72493e0735854b381fb4109ead7d078dac015e9004f520a8c720d84a87518c5b0edcb3abeb42ff327f1ecfb906381ce136450841857a4c88a55398faf7025f42fde35b841b3b859efdbb98cdd936ed5419eaeb90060bb09820c8d10eb1a4835ff624f65e38012180fd7e210b3ef412348e8d99f977f0c2b17fc0b78220ea2834351f45f1b726c73803bb4f88235a93e81c37e3cc93881b907a457801f5ad08afb870d5b5b3bae27fc685f872c6b81a37eed517b38daf6940638a003c07d779b852ab301f415ae99f8105c455ac6eb6335f284a15d46f3e65d1d913001cc12e8157fe7dabad1f163aa8899735e91f9b05093d90762cfff105abbd9df1c6a132aa5ecee722b803c141e8df6c9c499785ccca27361a9c62f0ad34b964160dcbda65213d0c2317bab44f65cb8efba0c642ab9b43e339039e73fe8bc5aa7aa207766d1f07cd16acb6fcc270adae3747928227de3fc9aebade5f6292393adc99020ca90b90a8a3afbeacc8a1abd43822110e547a830ed2c2313ea6fd79d8260efda7ae08cfd760d56ce6bf356a2c260f53ad7b9d11e4b435876c848636188bfc2e108c9760385ce48b00c1ffd8c7f2474aba1b8266cfe81056b58fb06be995ea2f29cb35bc6f64fed6c7b6925dcf5b2fb63885a5cd7b9caf467a24750f8ae6ee9ed7ca79c4ac876a1a185c7baf944a71232c2e79d9edf11070de433c5ab45ef39e0d99d904cbdca87122f9dc75b72103f9580d5b48c3f8b08293b41f8c8d974be9730ce3e7f8e1e6682c194c4e7e176bc66f5034ff74c706ff63d4fa1615a7e1b74f54a3fb92bce9ba83deba1e0763cc9e1c8936f3277d0972be25b61fae8ed658030781bc2f990132bcc5be864f91bf67eacaf1dc11d74f9f3a71a29beb88b43f3daa402e8c0b90ae2ef919ae88f5f076e10e6dff1177bde2b4e29d3c4700eedc4e9f42157aca48a4940d07ba9c4a49c578a33cc5812aea5295a7584ada3f8d2b9720b9103e00d5e5b2ce016bb03644cfe13dff83921925cd06dbf3db2505eaf42eb09caf05faa71129b131d5de46e4a12344f2f6c56203b9e0a940520637b41283e371a876e5fe07ff9e6ebd142aab69a8973cdad96d4ed48fa51e453f6868622fd1c82a41762f67cafe432c0e34a876d3196a8a686ad1897a405401acef80cef6bf9e3ed53d748277f41a3c06d9d298dd60d1c5836a3e6a53afea2a878c169d69e0c7080e82c0fb0ecd6f189da47fb4e5db6f8a39d0b1f1cbf0541fe3f37c82b93e4e37f337bdedaf490d57369b20bd4b160f43c86ea51eae4add7df6794088ee021a772299b35429135e74fd1a3802d48b13cc58b7c9d2c5630ba9d2c591b98ecf643b44652a1889afb7c53e0f26483922d05c957d909042fc8571782340f68e77b74b38d7340a28e801644b2050de3471030580179f6d286dad0a71b4e5de83f150b4b4b1f1f2e4a2a673a01000b478e33ddece04dfcdb7865d0f7ac700ead18dad2b588802877019235a7b51a8b0748bb6681e890eba4d0a526e6660c3efb82877c1daa7683eafcb9f667ca07955e6df6b1342a4e862e9596afddc3944b02790a1f08c67ba58e1b521f95c9ab27a8f56edc0e94407989a82f088da89ca0b5f5794e0b30f4f234418da8e701f100eb5b36abd9bd0f4fd15d576d5784bc97caae2f1f887901938c518f00801bc6282a4d7a33d2136b6cf611b72ec45eae24a5d205d754449af80f24e5fecea293a28bd33f4e570029706d711380f4dd519685528b34cc465947683bc06311f4b5e8564035a4a5f7cc476b997758429908a382a2d5035d5a9440a5f6a87ae45d50adbbdb56800e2dd8f0a84f20c0faa7168ea4c69e36b62365c725e7c5199efa3b230655f88b4df1b0fb8af5898abc3c422904412ab5bd74057a390b1ff1883c8b4b70e65f7ce9d6c55340dd858ce9a60e99e569cf440c16f91ccf8fb21fcdd14f06a9af85778ebe81f0788b961bf82087a39e55ce0ea0e9760c88c066f5b1b851f5844052d4a68f4c9f7d5cf06baec49d09ad4a94a06014c3e008482d22d7fe7684593e092fd5cc7c4dca17d740465920daad61ea6a963b0c093bea658c9a28863342c26717e1c32ea3f909f9105e535eaf88c20054742fc9b7e8b5155001ef2f5657a5c63893637a1a56518c3831e3a3218b0ebcda8ae5406db26692322f3da1ed9fc3b4857f13cffb76f28c41c13ea9fc8fee8a6f7f03d22e9770e0680300a4df2791757f5211a8d8e1cb7d09f38a958da19fde4e221d0badcb8734d37e936798b5da6694d68dbb66f9645fc0bf65d1b1052c9364c2c5f163c03a5e2fd7e7813661100d59fb78561233c7ccacacbf917d9a755239a67777483812e81ae620186510995615f2441e3ee732b73a7020ed2729c130e0518f049377b9b826be0222a4bc736487dc2b3b51725fa6976f66c1998ea402002b4868e1f009b9b634187ff8f8ef3a2576efce343c0b740597f5cf818b9002c55b928378b9972d28a7bf5e6703ae14fed655f1a061a8f7db9b665a450a8deaff99863cca10a301b5c50e20bab3c5933d0ea49bf12054138bb9f6bd71abd254989277e9ef0d21fc72def6d2d7e6613ef3a5c86ed2b2716abe1a1a8a37fc26a56aa14e7f822cf9b7560bc81318b843276b42522f8398e4ea0b184da5d5b3f1b3a1a33089325be5a8ca8a66b40375b469aa14bdeb2c653fdb1ef8a77c4660dc55f2e4eded19f3598080d9bf97adab0493eaf38c3eced81c36c56e4130fe89350ca9d0921fa8ecba21c3b355da8aabd95ff714576e63646a1746617a045b72bd9e712800d0742d2a920d6be8d0e2769b2719430355103b8ba30303e602606ffce285ee8150a344e642f9729849694d39891830a8043306ab9079f11f66490dbde57fcca5cf7a03b16a31b8d2e6b41d355764d070237bf8c50c328ebafc2396a67ce703b89a7b2ef9806ec3876b4e72918d222f00573f55f72847c29b8904c7300be9a33457f280bdaec2eee4c6af87143bd2dc5a3a7288eb02946ef9132e761f5feffdc8d9f3bee9598ac6a6f87324268777b69e3e632bbedf8da9583fdf8a971153db2245b3df166152aec94f302d7c7cbf6584df3b0ccf8654369be63d80e13566b385c262fdf68289d5acbbcabb306b66fed86d286faa582339e94e62004f48a47252bb0f6d336222a8915fda0c8e1a969ff50dcee64b157b8cde694b72c7b38042b6b67c3f93167191d31c269b4f209d85d02ee14925ecaf294478aa982ef4cdfd238d6381f9816abd15fa461d88823485697ebb9c0b4318172e0bb530f944a57bbf0fb84a67e0a60b76c85701aa7e4bd5190025ff5b7ae02dfc4511bb0673ab1b99468b988bf806170eb24f712645e0a678244ac4b8d06757b0cc396844632ce310bb40a7174cc50c07f02e686ad35c9952a48a6ba8f36f596ee225d7289ec0f3255bbfca702947b88bd5af2b91fce81979fe3b0a01cb500b5070c859240564c710dc57df849724a9b40f2f10724232408f445be88a7d93b843d056bda8818635f3710ec7af20a4c16ba7dab77c510a1e55cde2bdedb93e457d1d95b00087d689b19d2f122eb0cb4778bb26b5c78bc7491ecf6811c008a4edb8404d8d4144d77371780ac5f7d8bc0db5af67f00edb98d491c9bfc04b7ad1189614d397c06d61d612383ccbcf35370690e6f10d580c8b33b57c1a0478964b33b8cfdd563bce4ce643a091c6ae115944f6f181d1242a5bdde0cf2834c03a1c36222ab864ad2134eff8d26d9ad719e1ff92713ecd970d20a8ae4c7a6f819d695488e71c7962c0b11e146812f48800805c4fe778ff2226b477524dd60749e4f57bdaa89f012ba2f6dacd98f5849427b53197aa2f5794e8954ea4b5ae56e08c0469c1b416dbf731ea47d1b1f52cd51f0788432319aeeac0987ed2e288ef748793f9fbbdafd20e77b6715ce00829f6e9a83","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
