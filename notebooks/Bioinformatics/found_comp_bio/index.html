<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"668f532588a058c6db9508745b01cbb350b4614d8275e0e4beca4045df4de5179e435a1295f79f252274ef6a2af64881de9316d04155f38bb5f4260bd2f6c3101018879ccc05bb64f920f525ac70e7fe89fad01380c002e0040b8212d38578f08a88a9d40761f9ff02fa16bf1725194ec12279dbfca1760e601b33c7d080373a9fb1731b36547e781d308ac0593bc3b0de4c8da49f425fb752d7b926becdfbba40d676135db1a249320d54d8f44fd5d4125fba1cbcbe7f25ce3789815c4d9f077c008ede28dd65c9a37f9166cc60e1c91f578f0de1c4a64e1bf353507a962f521b2c42fbb862702be856e0cbc2ee01ce683e776fb622f56c619be6a8edfb5e5c4a22a259eb194af8057a2da8d619fd22c351331f0842d5107620f7238db4d0792c583344f5a9e5e250b0d831c693f1ad4e322ee11e90d575660e8b8c2cb26bffa444910b1b84eef790ede03d74e22d7f99630aae78706823a6f0365ea86b820d0db748ae915cd628321fb608fca7446295e99514c0709d8eeb8f1168d4e2c5cd9a24cbf8a4861bcaa1daadfff6f29b352bf7f17214673e8d5bfab196aa9b49e461905e5035f179c2c9cf53c36a537ebc5a8e4b4e5be217e4c8d3df3dc24afac2bb82b7fbbc4f46129e667f78539ddf7df86d1367e2c3f5ac67b94c97f6e506aad07ba2ecf7a7cea32cd61766558f5283f4afcf4635f3f819f8a5425bd7a4d776055d2184e341898c1e49467f1803f58f0f0b898620c3b41b171fdef2401fd6b2f0ffefeded8cf392ee0a9d9fe579ccf385291a1d0df0cc074088981f12168222e36b4695778d70a117bde77034291ae928ed7b9b1b8fdebb73b7231e2dc966ae22764052dba42628c583d6ee01ffefe61b7701d181b708d28ea41c77e6ae0f2f633d2ab922ce671c5f05d10b56178bb4dd8ba0f721b60ca363faf96fa1c4308a51c0f0554dc8ea150f87b5d06d2fc7b448f38514a259b5c30e899f695e0d062355cd612df2eb5dd39f01cabb720fb5aa5ea82c918b23596b836dacdff68cde62428db8790f10d25a46f97ad2ff264e51b89a640df7354e13bb9d5992cf7aeba587065939e8b6a04cde8826192823488ba9b63e186373e2c7e50caae7bb74c621c4669298564db7c22ee34ff44cf4760f0fd2e5e92c30286ce625a5e38f39f7233fb508a7a3b2539426e1aacdf1c9f444e89722c37690b9a1541b6ce9e076f7b8812bffa86806660532eec2ab450c8fd9434cf1bf2d384100af2f266a6766702fb74872fe1818c574fccf29ff38cb74698449f8d886cd0c0b0d6f290b47e8653c85e7a0025241c9f20fe1f06a38f5643f8e4d71687a5e876fbb261f793a50f3e3694ca5b037c6981f2cee6ab61ab08e4f22f0d4b1572ac4deb907cefa2835e1218e574dd49a72c31574c4715d5fbb0d61250a61149a6b059457f2a65f53c5320c94aeb1fdcfc462a69a472c52441fdf467b8975da2acb5d9722ed19e40ebf8109d47202767cd16cb5d04b9db96e3be46cbbe7683b7133ad186bf866b501712c227530f4e1201b53d54c78e5243607b4c2782f696d019baa5a2028aeb05e8f8ff117befaacc13c37b24031af026a027d7eac22585039c9e9c79be03ff38cba578a0ccb7f0d7da36ef9460f7655688363edb04ce443b5e0ceea743a22b3dc76d4c7b3169dab35daa8202503e3deb701ec68b63536b49ee4b733ee0c0b2b13c736649eaecbc6be31f16bf090b7ca5a8d5dc354f7a6cde735804383e823186cd40a2f2faf700bdab9f9b0df6f50643b4498b8e056003e1da30a8f865f37d016ad62cca7a21af8bf0919079ff4437ac2c24e97d71b9274aee5382a3f04d62f1e195829f2079e38bd774e891e11e9077cd92572cb528ea896e8b8b56de681825987e0d36a83b7c8167e0093d12b5422bdc16fdd19d253c5345197fa2b6b6d0177f8458afce7f81c772a0165343cd958634fef6247ac565c035d2f76b637369f0f52d4dd5ad9690d637349bddbb20ce2dea1cf4872da8a0693e315ba4ac4bedd296353c00b02167cc7cd8e9995abf4e13176f44fc7f7fe46d54b15eab514e689039642aa56bc6692c6d9412c508911c5b99d72060d07be996a3661b91f97f64cd50364b81259a5d06a9c37138f95e4ee6acb49da797065dd4935211f214a889c664aa68d016643f571de57cb2c348371f3de41a655cc448a886eb634af999ffa978b37865e3168a8fd2799ba477890c85780845f313301e1586083c9c9431819b0b7c75fa3319c5c847221fb078dda9c412c61cba232bf7cb137b639de4f201f05d67770e7dadbaae13e1db13b2f6797343b35ccc52005f442af387968d1b74e58d6dcb4ecd4e2040037f08e6c63cfb82cffc09ec8ceda8db55c664e30365279e3f20f9720d19e2474aab607940dc10a760be92174f1bfdc6931325d797dedd882a79c4244e6f00360eeb07c62d8394c191a2ede72e9ebdbb40c08d8a29b516b163abc196967aee6114b13bfac137285c6ed92b266def81e54b2ad5bd6c41715c2e7caf3d265b637708c2a7a57c74f264832eef3105e9ff7851175b721c5c353511c046ea555ebd1d253c6d413ee98db3e916645fc324e701ef8b7680b9d861882a418bfde937cd9f8d3315c94577311ce6e0ae0472a836b1416e1819f445a8d2308d8a3627905bd2ceceadd044fab5449465d279d0c7fe2298498f44be5a5e17926377ac49cff213d8785b3fa7443459a1d83f7073079bc1a0dcf0b1c4f73eec5297a9622aafca626a4bc680957677aa98963eeee871e5a0ae0b3d7cce74acfe5269206978ba6cfd66181e0894243a4930f36d7727e3a53b5ddf17cf9a166858d027f57ec74055cf65b34a5293d70bb186816e2f0b73d899487b88a9939376a571ece5148a0253fc121f4b4564a98bafdca24ef492805ac5d7aefe8e50be1a2821c27c16887a9626fb772cb5e44da42c7208b7931779a1a8ba9c5e43b1400e1105c418bbd232c000799a3cad36115a1b3269c8f10b9dc3a8b6b8f7bb6a2d48a366395ea19187c77f75aca91f0157deb9fadb4b75b5bfb97faafd2b161ab1fcb8bd53bb54ffebc86ac71f9cef2adbc1e349ffd72a696ab66a353764457f09004d7387d80c1f0c72afa35efaeb01fef2a45e47f18b93a9bca7d86454de3e4437b4b399d542f65c5a34f5c76baab5769c490a8f2c4a8f64b66d2a97357e2e0bb73143bac05528130e060172daa915f6c167150e0122c00355f5a44ace9d24d79592c91ced01826d28e543cb1641174d2a0ffca27fd4c6d6a1325ef859bf2f466c844f925750726f694a9c99f44756d709453e637c73df81c073038d551263221c91222d78f41c129c1f86fa15e7762176943b70fac2589b74961b917ace004e89fbe17634bacffcf4b53032a79d58fbcfc28f60d294ce3585d301d04134894f824d90af380104fb95829470a9cddd24196190db85f4eda50a1e17a03fe89259ea9c62df2a2198c92324e000af10d749fe5295d279ab3a101b4a4eddfac18f15c20a3e45af2fab6125da6b8e59fae74c6350b832a73e1c8fb268971c3658cd86de500c27d0bba89d42345f75cf018afe4fd5f8f87de081de395f201757be82d285c9ec458d21de318f160b06ccf26d6a2140fe3592ac895f3c124bf85958e81d596f812d8985d21cb923ee4bf4ccfee34736e9ee1e115c5c501e2f8efd9a160f4c56eb14f969339652bd79907f25d2c48dbc129ee5c73334c19cc6c33210dcb12761cd99fc841d8550001f8f828a037465cf22436bef0a2eb9c53a5cc80c7dc1b9482ba715fac4e05a202ebbe005bf7b6a42e77be8c1b1b59155c2a4bd2b6a06c44b6bd50ef05adbc4215cb4bd513ba095c6879e790001b41556423cd861ee42ed2158f6ac8f8edc7c388af38201bc14410867f61f8be3a2e1cdfe7db80d222e8cbc9bb75102efc2768905ccbad2e588f58ebd5553cff4ded7bd181f566983a5dcbe79de9694d6f49dd9107f4364e48bc13b903efa47e9344cfffd24fb3073c55255bb167942a9f777747f909551b61bec82a592cbe40a6c25191d7f05f296ab87d286617eceb90d966f362365dcf4089a3e2f893f5cdfc944f6ea7483fdaf73523a172890283486cb68e977f49ad1458510942057696771995cbd1225209767f29221a6b1e9c981d3e07254f702769432536ee7e35731ceea0f489d47ecb29c4758b126af932f53bbc15a17c0174ff5fe244502e31e1e3c4807302774637782a44b6c8dfd4fa33ef40c4a11870aab1b318a83461d1a6b08e82aea5839b687a8bac65b54ee3873e03a3d71c461f6906ec29227d9af5d71eb7197ef3041cb3033c23b9f244fd7f67f34d833fd334365ec4c7d5c1b6f079eb4609b9b7e1f38791f6c3026aa5481c001290953360517ee07155c5887a97cd746412e779f8dfca27eaecfb1d6dec6ba688797b530c0667b319c6bf93446df12aca9d0039935f22f20df447ad511f994b55cd07834647e91e442d7d293f8acb70c6e3b1549a6cf1fcfce6068600f6b3c8360e561400341c0386815315d99a9a372895099e9897ec5cf61aa412d0dffce0aae78bdf4e9560722f2c55956e5c5f7955b4aaff7b9801569863cbfccfd9c1462c03188dcabe2665a452d0b5825997f46bc9133c32341e3d782ad6211fa0e4987dc8d6307c8e22da5db501e0b436c8f1fad87a93a8bc00294f762762bc4e25e4f785351fc92cdd77ddaed0bfc9a860e5faa36c87e1540c0dbd847a2efa9ed038c680d128e221d01041a67c125d81d4333fefd3229e373a51f62504939b16c6e8bae3718f12ca6e10ff712e13e448fba535e366b29b6d227e997424b62078a76371bdf1376d34f764fcbc581704f087cc145d3f15f4de16b39e07e1ab1e39208f07631d9306c899df83c6dca439be80f872ae1ddb09ec68473665ba006d6a5dcaf4cccfd9363ed628399714b7030b4ec951ee5f6a56547bf6c36e06ebceb3d0dfc3b71000f0264e7d6bd9b1da5345fb0c730037606f7a6a28372b2415f92048ed81e88859bd92a7a9305af7dcc35b0d5c952b01265741407224736e863f0fe6e2e4155d30c0614c3b51df92dc1b38ec88f1be7b2526ef597f7d5a387866d8967144d2cf0e921864654925a51c343c45757b5dd8162df6d80cd0491cba684a5c626d91b7c07a9f7bb3e5580fa973bc7fc16fb046526ed3fb2a487911589635eda6dda8f185f2e8f5b9ccb93bde02dcc0dacebcc819dcfc6633473124ef8d952202cc7a4c56099a4b180684d88c9073771d7cc1be2e965cdaefdcb6fa157527451afb6a9699427ee44bbf34d9604840de6ec61e96b8ba8eeccfe04da8a4445c0535ad1bc92bf377ad2fee43d9ec69d75e8e953977e41e76b49362675903f56d3c904f0ec634ab4c2ca6449818164ed5f107f9727f0d32aa530ea7d2b4b7058e35ca7fbf09363f0ca75b893087de1ed531f1335317d596f4eacc42eb5cc6489db709fb65a0205ca97436d7523bb732d563132b9086edcc398d6ae93180904f68ecd41b165b65a77bfe6358457c4623aea585801d1539b06388235556efb58437e2437346966388bdf91975a26e3ff491ac65f192d15d63d2a660c4c1925e9a487c578b4b3ac3de2c4c568e46db9b2c63e943ed039d59ab9db574e241c35b007ad31a2b94dbf803b22d7073b6bc0c34a7f6484d39cdca9925e284e0c6821557cd3362c1db399d4e7600f35ca8e0d88545cf26d25e192def831828ea2bc59651839abef60d103eebdddd9cb3c7ea43dcfbe4ded6ddba3dec476daa1be1975c63ccbf268a03b7e903a430f04d7e90443e45224007075c857285670bbc02eea499dbeefe38783dfe3d92bf4243267e39cac88ceb7a440324cb270d95bd69dd33c3daac883ed7a2f0a189540cc020b8188ef9e019bd5a7629726748fd626545d8a4ce1b17177ec6438738a575cf82595cc62bf961296faee58fc441e46e6cc676e2d53d4c6add17ccf44766efcc733ad69a7c38b4f881dd79ddfb513410d8dbfad03f4275657a9e2267cf590ff8ff2b14d4ef2259ff60bac4c71ab8c01f3fc580edf588503374d935ab1364a49da939445e9c43e939530baa3c6e219fbe7df748980fe55939c61085dad2c0de8ff7e27461ed946c158ec83f9d8ad3d8ca948a7a4187b46e10e314c3fce9b8b0f33cacdfc6d9a041d48fb45793eecc9aa3c74fc4351451939336d55a436d60ee18d6e1b2c0eaa019127f82d70b780fbf6daa6bcc3bb129235c2c3c5b5be265b4a715b4c9ae7e505d810a260cfe503d63581467c88320230dc1e543c52c8a65113276568427a6d68990f263b909a4d35406e468e6f782cbdf9aef2ad9ec8c3c04dff0192d70f872b84fe32e8955dadff2aff75c9916c7c35dd9e94b70881bff9db001c56be61d02142ed05181946314fd38ead7e41f023f19c83f4af2d5f04c5b88f383c7f077faaa716f99b275b21624b173c0ed6f7d8e19fbfa99f00279cf73590ad70a84d3a2ff1851cdccb88e4a95da941546639fcba1fb8ea14f52b5667cf1628d7ae142d02b25b5f33bec9f3b855eec3bd4a867989ee02a22d4b1c32e15a464b6493082247e2589ef343ef9b59c5c12ec51f19d6b9d8422b01668c78b747ddcca89e299b6ad09483ef0140ff7d8d54aa2939832b36d0c6dcfc485abe97b33a935f2e1721dfdaea3b290aed6e0c98a5c4e5344713ef7192e045e0ef3ef23f732447646c2e5e8e7349bb8e4e44c4ff0d6d4ede728e9abe40272651074fe0f66068f3a2019bcf43f77927344c10feb7248cb33b87f2cb8f6f57c3cc0113a91c7f4e6f384a1294f283e73de7342250941f0750cd35e87b219717d9194e2bf39309be2e85005e808f91460a8855228ef1a8b01633c7d8a09368a0df5b50cc08d9d6ac9237d6512c4938a906ef633c1d5ecb1ec192126f04f2021d78e5fe66e0fbde48a0ce73be58ad33358717aa8f1161b466085132e28cdcf4a3970022cae1d6072fd75d854aca9b531a499f155c99dbf26e7510f7f5f6be3e1ec46e7d1fee96433fcd3aa999e02dee1994cf3d7141820e57ca76bd79d874217789fd1ea724994c9bf23cd6e36adce67b40c013b612232aed2a78a351bd548a1e6fe9d8a84f046af67bb8a951d1f488e59810b4ebfb4cc888c511ce1fba4f7642b44b323dfa49c1205418acc92a1c96bab834601657b7750c23bc0dd556a56ee5755700b561e4e7208922fba4475afa29eb196dbcf0e141287274d86824a3c81bb3baaa1d0d59fb2a151f42c6290ae2e41c5cd88d2b12133bc8c2525bc59bdb922de86abd6541df7743ccc6b2df53fa875609b060329ef489491d5d7d114c9dd01f8b4e722f7578e8dbf9859334eb9141b588bac4fb0c7dec563b53062d4e203ee1e005795b530cb1bddf565cd918133ca25e3fce85763087580a222ca2b8ff076194174c39d634138e2eea97cf774bd2a9283766c68bed4fa3607c496a577cff1d91e9e4a2af236847eb64c8ae94a8215a0baa72b71a68c20bfdc851dc62aaa4a27b99ba48625179d6b55dc7304de09a9067ccde03dbda6598d7c6616976d8e4ebb9aa4ec7c7bfe21934cf90393c3c81fa17c5ca1fcab8a7640e7c9a3bdb9c86346ee3db6d9a4b107741f033e9879ae12ebd7fdb1561a47709feee74d6ed4e1762047df0fa71d633e04983dec2111cd65e489054e9d19ec89750a6293e81ee5ff8b8087242f248330a40c288b1c7402146109a8aa2d2b9a15db29993cd86dbb70b2eb8c6cb2173e64bb58c587b629b2a0eadd83b146f40f4008426dc710c7bbb94228b54e29d0eaabd4a380d3c98140ce23097c36e04a409989b5acc2753fb54c5d61a54b9bed46f7e8bfa026309cd25a6d32f265e318e8613ee8c8f946ddf99166e7813e2bd33251a937d66458461b540a442875c11a5cb879d11534625fcfb4673fb08db4804a85df86eddcef650b9f17aafb62bfe3c381ef51f666d7f0083df003d810b488a5aae003802993aede893c69f0aa6b7e2084813d9d0c1718db45029f832aa8d6f3d4b319d9151d9bc8883a63e5771276c643274f12e5fef77cf48ca8412a82d7ce9718d6ae905f5074dba73f08be30473491d1df0c44770a2e6e9986f48bf4a44a611da3d785f0dada2f8dd592c90ccd059c2f0db627754ef42f36ffdc7ce46cd961ae2b1ab0bb73b8b455706b62bc5528b9759a92775d90a37ac6a7d38d07a39014abf0e16b092317c7a7a82ec7362f27fb179fba7af611299dccd78d3d1a04c7793b0ee796171201ef4a9dc7faa263952429327be982eb8ca287b8a12e2bd54cdec0de3fb65c7cf44810f6daf505e985da9503dd9ddf97470d8ab6552188668af13a324c40a194c804d77b424e2aa67f176af936151623f8a46f2c85e93fba4d7651c693ca627ba7c90ba33bafe21d6f2082b0cad6a2c5ccf4844b2b698f9b44fbf514251a8fc425cce286deb725820dd925f321f8929c11039862645fa33f53c0c5bda5c457bc8e0d61a358e0a9d04f5fd414a218e313e8a1fae08d119126be1582eb9febe0d481362e8f7d654ef321e5497dea6d85c72f9942a0f13baa7c6f8587f340bdf4a7c7e95a12d96914d337bd5097164f84d5a76007896273981b693fa72585c09654274dcacc6241d439fcb50d94a309b2c1fd5bb0a48ce43faefdafd1224a8249a83178a5cc9823e787809261de1b3efb7e7f1f9248bac364f8a9368768fdb98644ed30ce05751b41c82be3c09d34e45e01a337b094826022631c4e826ed44b7e5f0ebffc0985cc4bf08930384c0c781b61a4f2fe6023540e6e865ec3007052bc8068a1bad790682488cfaa58362b50bb751cefc044fce906fa0f50540296ea44ec40f8c7e734f4fe9ede81748e1d9a19f6da27c73a458415c4f1cd4fc9937553f46e3f087bc34821007eec093324ab6368d0d3257784057b8b4edc0c10fe0a592bd788085a137d19d5a919113f3d7378bbf38c69d065fdfe206d69b35bfe98c17566347ffc4da167b39576159b7cf15598c402b84836ee49ad20fff565457431f152f9ba555d4e22bb7969ccdd1bc9e4bdf60b768c868609080f243ee8b4df4964847fffcb3ba196996dcd61141f99f8013b62cfdd9b60dc1ce3b72d421c35d2280f1415b72ac2f8bec5200af4d1c9f244950cd59a6a2ad80825eacd3d579cc0c18a7046a140c42bf86397ae659768d4e53b911bdc1818362ccad6cef04e4151971f84c5d10c1f0dfec716e4f8682b7104f03725c8a10e279643dce364f56b1fb731d1da84f9503310fce1707cf259983730d5441e7e181c11070a02184b0d0fd26ec381fe17e6f61b448ec9cb22b9b7ec3ad92d18d167f15dd175b1d217e106d8bd52d8467b1bd5682aa6418d78cb80168656418c7558505f826d8b1cc80edfd7f82ddafb677e5585b25aec0890d1f4e97b76bd29f3c523525c4bd81e8e101f558fc497a9b5aeae030ed9aefbf59a04a0bb40ab9193a568439f70294acbedb5527436af3f40df1b17db88ed6ceb13d25373d7d08a2fdae211d4a08be82b3eb8ffb44918567fd62ce213925109a397948078cb94f22be6d31eb51f1327564f677459974175fb7e3f192303d5bdf39114590ad4653b7b53267bccfddb910070651bac1fff14757bfab1c815de6805e072f103af91047c74b8ab038187a5e9338d61802d1e36815c87b9acd1679593e825b1d3e46acb13ef18bf675df6cda605a0cbc83c76cc444983ab4c176235542f1ac68a344df38933bdf49841e8b9dfc3c474a61286645d83b2f7443819580566189ed324b3b12a6ae4a910ed376b71bb6f7d6b35fe3bcd64cda7f166fd322e8f930fc10d8784cc2f3992aa01031b3877dd23b45756e7b49684dffe276bcc84bb11835389e034718a0c7d872ad14bcf4fab134f31de1591334130d022857c30d59e5871bd867d7f6e47f47e50909db364409fa295de02b099d442cbd7e5abe82f33a43bb54029b4bf5b66b2dd201c58d50bf73c3f5827370e1484a096dc129d170e7722877d838a62318a1aeea66111b5fb7dfe9e62fc3a39b2e95be6509deeafaba6aa63f232140808b250d92cee36a525bc4a89739a6347ab3a1b16722662023bf8afccae8e2118c783c5b14700a4a134a08cc77e578029c260d3218e7e9061dd49ca7e94b6247cabdb5ea9c2d8350dbaf062c86f325639ca5a946135e3febcce0a41e7c5303b6f4d7be4ee7e3c7ac193478e3eae8956d38bb1e2de619ab4a3124bff674a2b44879000eb51124c1efdadf9231d72413f79b635cc5d8508dd36b43f1a9d0310d3c45822b10e8a520b67b6cb5904baaca525a12182b6e1354aa2d890788b5068e0de5750d2bb87a0551da929bb7563e085fc5988a550787b3f0326fbe3a098c3fba3165184b85a63da093b77178df34d233bd2aac67e98d3336ba6244ccf48bea8abd53217774dda8dabd4bac86f6f35f77e5144947896f7884f635a35125ba5b4912836966fe806027dc7b73e21acda47d5fc35849e038235d3157811bc955a9e25c51fa51d330db659303d48851dc83f1b069498c54a4288991b0acaf5dff36d62d6f47ac8e438b31a5fb3ef202034b6f7d4521a8ecbe0dcc8ca1542511ce9ad69b70f581a1376c4b064e38fc41e7e62f827b04ce1ff78612a0aea9d2134c3bbc1ea9e00acddd182624a03e702bac37c2944d4b01656910d50c0fcbe21c83b02aa59b08a095842b340dac16c7e06b20c8d51b13ff04de0ef0d7a2e3842aa43e16bc5e747df1a23392dee933a2f1fb0dacaaeccfedb8921b942de757b255196871737b041c356eb3fd4baa97f8ed97f78644f70ab36f8f2a0421f4dc93db2730c1292a9257f12b3c207249517047ac09ee0d911aa5c2a27b50c1484ce68cbb8908d8894777a04215f357036fa594ebffcb4fe9a42993401d929de7b7e65c7048e2f6b57f6e97124428bcd54096b4dbbd93c0437391783ae412f0ca23acab101b31feb6aaa3aa7cfe57ec81dac8b12f74bbdc48177c8385da734d2e67845d88cb859bc3d55264f003749c29dfa1d2ef4c4b5d9421049e3773a3d0c4f5b7ae04a4abd8e323ca6a714b41f2d7d805269078a632c8e218c93ce735dba94abcf015ab0462aec24707014aa8e9dcc98cefb47284b13178991b9fca4a52aa953ad9aea27f23178cb550e0edb3ee3fb9e8c18ff287dfd95d9b921f35a0d3b1a16eda113630c4b94dce341bce9845e52616629a5e9996408e260dcfc7ddb0e9096d3a6e4274fac57e5bddf2dc5d34025cbf37d27e15c2077d0318fbbe8bdd181407a0d85729a355cd8c67e6a898b3995adfb5862654335a8e8fd8e60997dea19a56b9c9097467cf1a414b7fa0c0176c3f5b64d41da22a37bccf521d31012b289f995014416cd7eb6bac7fb67d0788a37af1230b64786075d8e424386fc1ca7670077167d3d163bbec6f75f9e0d7359acb87f15b3fbb12906376063c0b39d8fe5ba71f4ed41dbe1c285f68408fe2b48422e4495fc3681adca6555fea013cb49ba29e8222dec54a9dc1028f5228a0d2b21fae324bd4a8abc577e3dbf013b7ff4e3ae1caea8f52d21f457226f11aa5217f7f9a1faf728f301a260c2ce512ecf60b1a1f3b4dec01cc02c28d436fea56ac24617050eeb13673ec7df637582ed9e029e0e1e620238843739d1c595c33a9d501119d3f74ef9cc835ad495fae8e0f9c662340063b6f6a9fba7a1035d0d9de9cfee48df8d86cd374135e79566a678e393b2a4226bfe3f83980890db02b92eb807461ba3fe0b8238546202c518946b6376ce29b2097e4126167ee2daeb98a7971dd0ab50b18e951daccd68e2f28bde94b2bc4c4dcd7878d733f8c599943c17b2d75989208b721377d9ca1ac774860e97902b490b68782a80d18ebf25d9eea4991b737c59ab83890cf1e381a353d603c5a6a44f954509569f3f3f74c5a7016fc777980cb63d6ab6da1149809ef9870d81dd4248b1eaa91dde002840a8aa515043decdd7cb2b87ea4ce4b78194d797fc988bf14e0f2a0cd86cc2330188620bbfe6e766567a1d2a1af1638d7e4806a3513721cd6b064dd242f4c39b9e3a669aaab83f1302182ebc617feb7392670feb619213abc0b14ec3702d11f083134c88858a9a6d55dae25ef32943a5d567f2089cc3e2d7b852cd58416dbf6c302a637788056856cf959bd9d8b52a3485a78730e02084f709c51c63776e14b2fc1390fc219524a5702a2c320edaae698f3afc47c6de8753185ef7ba45e854846bcf4315505c91cc396f47a6dba25de2b1a037838be51591bd2c57e826e8f9ce331b9f0fd37becce7e5fad9720a843ce7dadc3e1151972f6029cba4a9b0b422f6b9e202556228bba007d79dcf746da4a618707a8713ea706b0a1a339007e28d5627d6277ffcd9b7e93def63d4cb2a6e74d8246256a8d11596e462d8943af40310dddaabb38e74d07565a2729df9430ba247f41f8f66df0df43399d3e1033a6bb4a2984661be2e79d544ebaee3f0e4ffbc4bf48aa923d535d1523358f470f7db4404e081422603c85d57514055b6cf0a0ae9d3e54ef414a08ef42faa513a710e5ebd5f990992b3d64018de612c58eafd33038788e4d81e865d890211bf78830c253b97f6c570b17f088efac90752f3ed09b92a167091b64ce8d866c86da91513bb67177bdddf4bcd13f1cb734396bb26c8137f85123b8db7a2a557a544d9eda3b6981111ab2c59791f1afdee70f200e3743c6a24c69a898c5d221067bd62cd82469588334c68e10d5685f36f0139745468d233e8b6cedd02c37fb02fe6e77ee4e476925d6acf10d5e37bf1b770b738774d4f3e91074414b74364f908fd663558b6e8c07fe09deb22e0dedb125c87be236695425b6202a1c660df987731dab7acbcbbdcd908add6bf0a68b5df4cdc2aed0d4d3c30745b2c5f1799012056236d65f6f8b0912deecdd3b92f82c02c77c39dc5ad88d84250b7f03e0165407b9e94d31e9da6323769a5d2dfd660d5cd144d20e6fee68b1c8a69e7627500c175a28588c41e8674cea770d49fd2743b1ba636b517bfcf40a2e0fda6894a1f73447a9aef04775560a45bde5bff5e2dda003cc14a7d14bafab6898215e1d9b0cdbfa0e7ce289bfd13611dc3a9162989fc3e0c30c9b33e3aa94386bf7229cce11c69b0c3d3aae16741b952a130ef9abd3044e2084cd598f6a548342524704b7a1795c200f18699ee2720dbf124d74b9f188a8d9df161767f80fbf41ce9ebb2e599db064e0b19b5069ab616b5c9c9f6e050a9554362e7de87575a61f6df11aa733837f1dca84d16ec6a805399b6754b81143c3a5d27785103870607943e6c035697a8d44003735251befc2045aa4a673168202f90544d4adb222950225b65db5ebe1edc4361c585561d26d74367aadd4ebe131aef7391ab953758cf8d4340028a541dbc43f43d3f487592c64e86839e35c82fde4ab3ad25a7f80f79070c6875dca38ec127ea83917009bbcad69cd7a97dfdbc48252cdeca568da73fd79a3da66b4edab9110a4e7ad646c062c0cab24a3021ddfeca5c765d342b16658482b84537c78c8d77d31c7afc6955f9d92dd1bf215ff55d5099bb6fc3983fe09a901cd553b6a2384efd3d585fc048778bc8ede4382402747d355e0bfa8fdd80537653dc502e64f2201979221f9770c8d9a482edbb73020cef6b594cd7ac628063c5767c9b5b1460056f2534c2bc46dcf04a5c6f798a829d587737f9f6e8db85e61ea1cc811cd898088831113474a4b30629836a6abe626b6796286b18bb37f0240350a38abb4ca568e7fe373267b961e13c58b307ed258ff2694d624795294f99748b869f6d6985e8a77cfbd77cef0e6ba4cbb04d136ae3ad01983950cb01b52bb8dcd7b10ace918358f0d8748c0e65b9d9772596987e50a7b87479c35a0a8acea45d450f24198df5eaf01b286add11b1060ad5603d2695875ff6022b08910e2be76d18fde697efc2d89c53bf676d7f9c8a7237f7263074a20fb1d84c8316504afa9ca08e6ceb984c40ce0185234ca36254b75d9cffbfc1d755a021525702f4b3289fc5e7ed242ecbf48284c6cb58b2359c5c80ce06a968080f11884fb660604d3418171901a228d7749f875999eba7c37cab3f6a091ec3e902bd95be53c5677da8fa4871321d054a6ff3493ff9c98ec62addefd56a0bb48af6b4044ba5970cf50d5416d5e15ac6a77cb091ab338a9c02566ab6698b430815568235bcba1751ec4c6f27e8c02447162e4dfb5451c1f66188d0ca45018a8974a594520f85084df33441c12da761b27f904032e036f28dc68731b0a2d3765c5f0f0689b3720346e5a0487ce1e7d994c781f0b11c3563c263538bac2d32f27306985522a9b3c6a0f688429969756bc90fc9b1e9a3a415edf9f71ea42bf7873426f897d9967ecd55dfb4b521d6d03889ee57f21415f4bf3b8712af7eb1c431ba56ebfa9eca5e78a6529dfbaba378ec754cc6037b12565cf10ee49f3b7eba285ef28569b89b1195818bc0cfe5b5bf30d39f118daec36fcd7375d79b118b2801f7fc9daeb7eab0b5e6755a9d02ddc8f24cbbea9219946a3473befb0d2327c6b7af7bfaef76e6618583a72bed36e8a551b59e2f317fc0a1e5a21e4bb57864f2e7fecba06063cf3953ced9878497889e5738cb77ca8de251e4cfca371b2a9664e35b0dc8dde1e3b5131174dcadbcb0db34e37c18edc424f1ac91eac115a4c87bb32f09c07317375f1da6c755c0d435765ef0cca75bfa31de97637e89e17f68c9d3ba310f430a9211b4f789a925c915eac48a751b4eb2a325a40255f83080b72cb117df0509295f023412770fb3c0ce41132070fd52395320f2372ce9877cec300928cabf6b90ab908477c8291c6363f1d2bb3b17258b37c3d41b97da78c88cd861b1f124eb3f82e8e8f36e700044e9f35c0ec9827e0b13c597fcee8f3f89cf20e6fe7ebf216141bfeff17faf69cc2b7df1fed842b21d70f203ebe9fff6fe5653044669f678d638f7724588b19890265182cc1579746331af3d9d4849808b85988f4a0d74816883fa04f837518ff443e503d5277bd234ca2b233b325315422d1fbccc52c34540877db7b1b6812cea5a7fedddc7ebd72ab30040e76290e045be672d0048daaece61dd23d0d60bd63192e96b2088ca36ad8b5eca02eedfa661dcd999efc0ddb692f6b6484994264fa47cd9e83179534f3d59661389b04b898af6029517f0c49026702b37a7f815a5d6b404df5d50f714c80d32a00fd51837849f8c730bd9b7b2bae37e28cc06d6ee19f74bd8e170108765cb0eb38c686f612af75a485ee2d0059e9d081c34a8ca76dd8ec43b620c089c58d4ddc2606c2f661bbb16410a9f90eef5226ea2810de2754f7176609e6cdca7727edb12006a47a9034e51d03fd55c558a674e95683bd1117fa87493981550cdf88993d36e9b8e82acc2f953a8581d5a64ed339e398ccd58208bc446132bb0985ad8f98d065c8f42799ef3a3832baec2c144df861491aaeb9dfcbff93ab7484ec9080bd1d56ce897d8c3b770c384805a232cf1b496239b1e9e5aac73e150504ddde926f5bc95534b2178ea1231bdd4d489c16d18aa2f98574cb6ec0b2c372699c15eb263720b3b664a04759c1f434110089ea8d77fd5c822685e72cf01db67271ba3ad01cedf6a6642098d1f4049ab7362c3c4dfcd98706e72d947d375efc4976a6959160bbbb48d3301469c8eded494ab9a72f372542b0cc4c9cfbc3d7e133f8664b81547cb77b69501875d67e1549de7d2489246d4134aebcf70fe21d80f0f8900f1fe314cdf7d1d5f807235ec7616b46a7f542466348582594825f7a09a60a2fc8dbf76ee9929cf25b7dc0fef20b3607d13914717c134955ae90b0dc583b4a833d268e73cc26a998fa6590d57652d90e498ac7eb45577cb03a13caf756d4a42a3647c883fa86e59453347014806caf4819febff94432b5aa11e4041bcee2989c719191e6c0023538a9b8ab02d94877cbf9b419ad40e6b1e90825fd251502a44dd14d39dc495c52115b3d287d789f1658040f5cafcd69c09c61b778de60bb80a7639e9ebf111f0e0cef3f0fe435d3c1d40e9c3a7acc75256ea350e504a085f71b5b4ad3247745d5b4276f1177f79a94bfa834c884ee503b967f5cd2467eb1916ebdf0e8cbe825a6c45d613d2d761c7e5efe19c50046395c36ccbd33b99f39b33d85f5c96e87c13a0b1ccb803095ef2391afbb9eab59d00e8ebed46d6f1f010352b1395b9e16736135c0023147edc9c83a9e1ef4272cedbbaf2a6ea84d88724548155dc0e3558cdea8e1acbf64365a9bc6019b4718ad45f2faf019085275701cc4083495317d34748d9958295043e20c7f8474d9d3b1dacb4a8fb8162dbad20f48cdd3e065860b26b9f943d39a0e8243ac9782dd30c1572793e670ed9d9a2c98957aaa4abf8998f34ed8da8f7a9260942db1f5aa2124f6a0adc0627b6eb380a5a2600c2e5be88d2293bd59a5d39fa4b8752369dc8b26de7afd82e71f7aa6505ffc8facf816f172107a38ba164ed3ada949813048bddc7697b338f404fc1667cf81f5a5e91788a96de4f013ce201cb61f287122b70055a16a8036b9e3f0743ef79312da5c4b18571c023192a461ec3fdb4edaa65b1c9deab3d1f659788af1602c08374324427ac33ed6e9504c4112d6f75778ea1249e769d90f7c7a240d3e76f808ca9fe9ad4988de42c8fd3eebba4a68af20596fc0af352d67e51157af2c863de811f78cff205ab1961da1880b54260c6699fedcd767c122bc2531d3bd521e980c7457704a37f9564852d7ba2342aa3a93237f5a2df75ad5b7a4ae510cfb387e35ecc68c7c61df5c58f5f149fb2393dda76aa218de698faeab9b0bbd06183f2ef27877ea58f60c829067cc17b5e09873ffd48b4a5fe7db336d6324d999aee946bcccf42a3f2e60adc752549454485eb156f5d265b7c001c36571da4adc3ae141fd709f9c6d04aa3fa610304c25867d2d59b5351405d1ff2a8097bd064916a10cbd518edab6d39942f8092440c8053094455574ef8a2fc88bd8f9d999e6240f2dba94a1eea82382291fb7c3440b99b5c935c45b449f9bef44dfcf5c58800a852b0b65a391e15fa31f4e983ee7a4b671f01911a6cc14a9b1de1585060eae82d803983cea32ae75fcf310b150e940e9bd1a62e7c9a5c2fe82a6ea01efa203e5eb8a7a421cb08feeb3d305b1f1aeeb618a2effa138998dd49050f68ad75b604d3c5166473951d9d87e072815bbd57dc7e23f4261a4cb3211d55a7ec800d3e729fd43cb0579a5cd347ec99bd1c24b16f792e8190c7326866c41dd08dfa6a8f0e1559c1ce18da38ab270d7497e67d470b5fbade5d20d1c0a237ed7e8fa2fad00dd7ed09340ee83bfdc66f26f6b67b55fb7b9afc633b7951780fc853c40a856164eea2d3a1423107c5725e9f74b4703334d5957745b2b92e64aec89e0733df790596a3eeb85ac9c316051e3a53e9ab7a9b57665efccc6983469bff9768af4fe14cfc4aeb341e6316a564d9bc3eaca52ab0f42f679950a1079fcb604d5638ab99723b6a87ba70f39c5f2cc324ff4a60081b33c38d2d8f3a538d524888017f75a074a708c00127e08a6d26309432172565d3f115dd0749afbcf00994f1aa10f087fcf9993d5ebb16d26017b0f4c39beb62640ba9e255ff7ab9121a4467bbe4a7317a12d86a71acc9c2f644cff7c95840b9e0dc97e048a53d2a5f342c7d92d2275ceaf85a0ab98e1c007898bcb2afd9c3619fd0494cd96d1d0f63ed218d1204f5ea22346eecea473a4f81474d3e08142e1ed37164fbb8704f193d7cbcecd1bf941569cc0b014482c38baaa06dfa62851a0f6b32162b00e293db15a92ac2308c0cf9584b0747a43421ec368a09acd370331cd473578a6bcd4fb007ad568f1886356b240509b86b30057806a08070efc873c1cc757dd908bdda9d04072d92efa9e4192a82206c7b1b43b33017ccf1d3c7e028160f4ad215ee913a67d8d059d005a6fff82a51eb163e45b965b8e1cebe696a218f4318023468945d963eb0abdf321f4e8ae317b59584fb6cf460c6b4091a26364e7015b17a3306f0007256a50e61aab47fd961424aaa655","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
