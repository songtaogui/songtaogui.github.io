<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ef9cd024814c482d4aeacc078bfd20b879c7c105c7f433b84219389b0358919d0b23f709362d185180fa44191ee88a99d75d1f715ec4b03d1868378537fa18f9ebc553394ca115ca2b2f07168e8f47253b13dd4aa032cdfa5fca42cd94bfd9891c3126483d843cdc51b964d3833449502de56ea6bead92a9af2c5ffcaf1565932e77fc1e3eadd2088222d9e149308c9dea723c3690a1485ff7c0fa5cce35a84db0d204dbf36cba95a805acfe9c325e1571a1ff54b0f15ad0edeff6fa3ebe91e43841bf6815bb2cf1105bc7370b2fc1d8fabb5cfcf5775f2b83f0778bc74422dad4d23d5cc2ba41ac65efaa701b21d9b391606c0093ddb9c9e8176c0e256a089ee8abdcf0ab687d6bd4f8424cfba61d41e809087dbac5d41b45b6cb4eec545be57f08227de3c018135dc265abd8c455912d25a008a76ee1e175537ad40a5feb7dc8714f7d84669dad744a9457fcb5aa464b2fe41f7b8f874c7d1684014e78da54b63883cc504780f62e40d19bc90068ebe1002072a1e886a75c6f21d34fced9c39ea6b83bde0bf06ef88526cc33d88629c51b2ec67cf0977fa9db8a6916e3b79641573ac4e826415aa8e7a169cc565c8d20daa870ae09b417954d9e24b06ab64172a8d9e55a5c03534144d5375485279b3dec5e1d1e4a36fca0f6edcea7198cb1ef26b81aa0fff3374ab89d99dd40c48257869697f06194bf64c20db56cd7afd4d8c7b118567e53896e2a831b17cd2351fb1f2d747c445e09583aafac17489bd7f277cf3d1a93fbdb3795ed54fca255c080c40a38e920dd19aaf75836d4b2dec26191de59eae8580bbea4662e0222fc9d87c784ddf3e6aa324e216c18a74d640eec356c48101b0fde0e0323be53810e610a5a12a23c3b8f6647f3ed39bbee71b0b2ddc196fe9e3a4a8d7e9b7092b08c1168af09f28dc600fc17446e2515fadb4f06a8afb591da1fd56016c65b75b7aa6bbce533cc39a20e5c2a1ad77f847143586889ef0ec19106edc16df61e33b9a8ceb02e5d64c1c0c2c16d9aba2f497424a0e1303657c274f6b51340a44b8ae7a74b12874edf004bc0522c61b14d8f086d55c0a33a35f8d071d24c88df5627a777579415846cd3b70dad1d006819e3ad39bf91bbe5a27c73aca63ca216e017cd3e5a1fe4daae93d49b01e772b03755d044c64c36e928977c118a1b5a1777e2b330450fee25886033b61c32157e908211daf3e63b550861fbce2c2d27cb537ede5aab802af830aa3f44b5b333e664fc0452355e0a97ed2c427e7daa3f9c7a25274c990b383cf223a7eb648f685b16975c42e811a9db4e8d4b33a8e15d193bf29599548b2877a5ae80480c384ba82212c0c12ed7c03a50580fe103a5f8e89dea28be6300dd364864d3306329e150c61cdaa961515e2ca0d19e55a2d8fa510daa536b23b7ec6a20abc854723a08663a5ec84273ff3634772edf534a521ab379cb1487eaaffd22a21c134085c95b88cf089d24f71c9221a617de46611d98bca49ae2b4cfb178897dee53efef030b0c12200169771de1bef9a12cd67efbb1991099ea2ea43bc01e045de4cf5360175807a6fb7b83ec58b3f06e2d307816d1851f79f8a850eb4e7da3956420bf6e761c0a97a4bd3502f41d50fdfa84017893fde6b129a0cc3ef10c3b4394efcfa70d5482d63ba150b1d68908f3a04de53f01a3d5bcc9889f23207b6caa1682cb9749d1fcdbe66fee8bb82ed81d4eddcd702caebe73813bfebc7470778c6e6a47dd58ff66fc715cf65b265c0f05dfa04c495c36a0a940778f798c6570803d8fc5379fab8f960e20aaf84418cedda12d447fdb6b9a2144f511770a069cabd99e29cabfabc9cdb0b84a132a5d82e755fd04f93a4d9491b24d70fc7641a696d21f6c1c64a87cb65127d38dc31e60fa22a2d112be26b533bb285220ffe016dfb82d53c2dc95e6d8110d65a754b6eb14b06f0d3c050aef53a2fe636f33078a0e2d20d8fc6231f30b162c24746b068bd7e30d70c0df1f2be65fa0d304ef72ae9a6f8f21d28611705818e21eeebc3eef17d4a4d5c8f40079e19c611bbdef89aa704f90504eba564869e6b88ebd83a7f8e492dcc4a13ee7fb48c3a861a7a3f0a41ec62c1c3277d7c620695ca5fe2d33b70b8b2f10feb79848e09c1ecfcf729b7851b331d583c1b48b21088ed569f768d316dd0ab7ff65aaff9045299ed35db46ddf40d07aa7f646ae7982e74fb1ea622f6bbe2a45ebc878cee15aa392bca75be615e3709ed7be25b257017e58a1103a90a68b7aceb79ae9708c88f3cfef036c195a320fa06fb68e1aa154e467f589e93144b67c7d91402385a52da4c54f314b471ae5a9c956d45c53c8cdf5ba90df04dd5ef6d61b08b1de9713f9b9d6a8603e9905a433b7fbc6c886b6214becbb28946b5dcb73f2dc8f25307749138f1a21beda32d32879a392b68f7ece45d76fc1fccb7056bfe850acda3db2d181136f0c2364639d9e7f1c52ebf4d87f61702b276f9e8bb98a86592896712f7edc3dffa983e1ea998c7298050c8b403b287fa275e41155b637b83c63972ebf2482be569a44c8007229e20c49eb47bcf9b59e15de2e31c8f3fbbe735f6087c53bf1a309beb83e68b3c37373f77a267106cc5f57c1c2ef761d6ba3113f9b16aa6665c034e2507443c8d4a3b79bc227b850a1ad20ed48027acd9dcff153231218e7a25074accbe8b3f7d53cf173bc1e0dce876e9a7a1b015d75c0cdac9c9d538d8626fa252eee7986f4626f43d34665ef7d18b8201c563956a0db7a2ef64489daf29a817bb8ca9f1d9bedd59ce4e1c27be5d7f2d2740f4720494f5bfe40a1d1e07247a856b3a2a28bfd65f019bc3f96de6fd748fc4464dc97bbbfe3caf0e1fd384c8508230366483c47e4bc85156e982c91023840aa8e8dffb34312a24d7fc2d07e80b5686ce75e1dd394fec8e99e396afeb9ec57fcec16b06525877dfa7aa7f87d471141c5d61959387bc43f7cafe067407befae6cde1e72c8a1f0afcf25a602ccfb4903aa239dedc3bac31a16c7b0e817c3905421931fa8436db6feb4dbad5bfd021d324f8daec7864eddbb73a61fc8c1d910b39f113f9978e14411873c65415c36f506bf76e820bdf4291ea9c834e4a6245542e8ab34232f42c7816b4a37a5bb1891167ca9cd705a29819ca8bf23119bed7c30b98a8b5b2250eaa353608910bb59774244651363f99b7cf67a2d630099ec35c3705145b498d73eee44dfa090200db2b2473c9ac6c45d822bd4b5ae14784dd86791c6907b4b623bafa04aa2a8cb0f3b65f268d627fa28f93b79f288a90717c3899acbb6a2e989884eb3fbe6a9501f7c914c4e7c0ebdd9ff9519f63e907d999073cdf56c116f318fb273400e71708e2cb7595cd5f678a89ee71834abdd317b780b73147681f9c32b757589c9108675cb00e767da7a3558214480eb31f6d90c224e714f8267d670a38abe40188c1eb50eaa3bdf505a5162f3b07111e1859d670c8aa2a27033a62d8829e0e5ca97956cff9f763ace646b73fac253974729c8d8ee089464ccbd39e797ad0a6a6050e8eb0935cab3e65a4c58859b15b31b3fc1847f8c41a8c8f18e4e4113abcb5459338189f5886e6fa8d5d1efb230a54fb7e717fdce5ba0bb81e137d584514d46094144500074861dfe13c063a12894b9b2d5c71f93b9cf3118c1139d7f55f1011305beb779dfd38729a4cc93b0c306d28a91c10ffbb990667b53bc886c98aa415ce6fb2d99ba5e0a6ec285ef9b21e969af07ebb8d4b06681eb663f07d10a4f305b7a30ee837d8e564e79290008a8906d168fd54d15c258b492e07f1d102cbf10a57a0fad1e6851b669c80a21ee0c32436c471c3406996ec9887c3ef42f7fb6fd16dca393990ff71b4b432046c1b17e3523a398ea92b36ec7acb372891ac0adb44cbc38789a8fe133adfbb76f78bd75091b09b15474c6bf6584cdd3487f06d9bb1b5fe441dbcf3b3af853ee9d5adfc84537d6a73ca320681a419ca0e279e47d5edc0da32d5592e141dc98c6c8117eda1bf292aaa9ad007f6e96292e4d8c9ab8e2014c1bb67e611f3719b5b4a6bbcf018705ccee53e79254e7c1fb8ef2e6ce9c6d31885c17fe33f3e60344f32a5c421340ac791e8cdccb4ed9d42f1155beefa66bbbb17ccb9397a70c159f572732411bb1d03e620b9b8c4f8373313256ae14923a7d1aa5a3b3e0c98d408a68a47c6f0c91c8d4b87710d3d524a4e72ac88e20c81ac649aa51a47da1194ad1ec79464ab5761192a14eb97f856fad71b45f8a1b748655b570f70a2b9c17c1b9bdb47516d51e1bb25c9381e9c83a3d88b1e702f966a2bd75125aa9b69373e71e0dd9890c4369b3eb218e01f24e38dd363757cab7b80bdde9017482da521aef5eb1e7b4883b856b69efe4af69a668a501838a2fa6bad2598a8293b475f348cb49dee5b3ad5e7a7f0244266579849658668a52bb0fd24b3710a4629c033a9185eca3455464320c494de31ed84677f5470aac29432bd57d1c687084b6c478c15baed548ecf2f00292d886251462cf3cda62468d500bb6ad720e3ae08b12e522e1698bc1db14c680136f1bbc2fd7b7c2a113596cb816c0186f0593165463c254c3e68d61583a3826cf2ad189616b21ec405c6a5b90edfa8b1be30ae8a4780b686407eec52286fe478e45caf140b764e7fd9d55c6708ca0e7690cc301c98b14054d0aeee795bc63b190a3031a12df607ec8986be462063acd615003ac807f6f27ccc06ce173c6ad977ccf7342fa22919b08b5ed4350c251cd224f4113f223ef9adf933995db642056623b19975119f9f82398248a54e6e1ec8ddd2b3bbfa4755091ad573c8bd66b648c5ba4131fbd930a00734c1e28c840a36b9da8c7f36fc88f65d25b6682a08c7b6076a0f5d93a13a4ec139301c95e3976244ed1e62c729c9dbef7b90bab1f462df772cc9677267d0a43583ad790260a31fca9e558ad17c94f5af0d013774663f9ca4fb69abb0661f0aadc6afda96a1826f04422d8c4aedb5ec333fa3cc3c83f9b5cd6b0827c22bc82816d96145e64aaefff0eaed336f8d025ed9faec3ddc8141b3139629bee0906b8b614c9ed05929ffbbb771b584ffe7f9a1507423b59c1d88758a1a077c24b3f1de969981c4dc1e91d544d4faff2e082023cd7c459f68a0b96bb97a39414312fa2a258ef3178b4a9cd5bb16a709ad7a9078f63f7ad7c62359ad270d22e24eb8a8c067d5b0b15f05c0c2079ad9e3d4f88ab1315eb8d70ec2b641ba0f3e4c79901ce152a06ab98b345edf96f842c4037a6044ab5e5520e1228b6d29dc0b4c9ebf260d409124e7b604baf363c98b289d5c405ac2888ec86109c694b00a11d4767d8af8281d7f88ac1f7e2189ba7fba2555d689886760bd6d2aee297977fc2ae110a55edbbb24508f0911b5b61a487d56fae338c85085fa36076c0b9f58f9e6e4b1e37247a4a6d15177b825571545033ec88d5b79f347a385607551777abb9617be52d11cc8569bde3f0ed3336f7c8fd6e144fea10a89cbf500fd565c023522eec99d65c194c4148210153d696646263801563b4a14467483c0eb4df2bced3bf631d1b6b4b1bc319d29fdca8bf32e5e0a95dc50b8e6f6dfc425d207bbbacd8b6214ad6382b828bf6ca471b9bd34123d5ab5d1e463d48659a7bda435d9852fa6c2c12bdce23c312c08bc27e8b16b1ff2f5e334480217b8dcbdc58934466a9a6cede4ef76efbb688fae7540500f31f75917032549cb2fa5cdfb64bb4186c17466aeb8554f0118b56c8e79222fce4cb672b31558a9b9d166f088b6d5b7a2b9ffe3a2931acdd1da93adc8c314f804c60f89fee26f5ed9c1621720c7877e5472b7dc66fca11506882f2d83bbf6c52172eb7d612339a66de344c225659638021a2466183f1f7c64228162b6d165595b1cf8c98392c7f26ba8be027667a576d3287a756097ddd22f4f642a9764001bbd9553093c10e8910e8f32dfb44949411228de8ad95580469018097b0ba494f42c9427ead1434ecd88e4b5b4cfa8733b16c8f0f1c75132e974448685cb0683a16464e05c30b516c4241d099b695b8837726ac30cad4ef8fbade78fd21c0b3bd478bf34d335529b21231818861e84046683c2ac09ac5cf3f79d52aa33c6ac0a5801d669cd2b048960ed8bdf2268d120acdf0eb8509b4064e97c12e1a5c7ce553cee74abb6c87171eb9e350847eb4dc8d0bb70139eca5cf342f44ff2bf03d8312f722c07dee344c576dff73d34d4bfbb7c7be7d346578cd207db9cbda4ca30d5b6cf25ff071d6c6b4f7e73dffc0985ab342c131be58194c2b64bbee4ac623a25dc6e48ddad6d2bbea0bbe51775b2002cf2f9bd9a0970666f523533b5a1c7b48bea41ea9246a49ed309630010f8cd22aacb553fed3bb597f72d5a95ba8c06a2755b9eccf1ee41dc042da6636d85a1c17a396992bf144dd4a488deffa6173bc9f3025632fc5c7442e825120df838fb3111eee00ee80a624879af7abf4a293bb2c7fb1909e6209ed618ccfd79c87c553b79f874c4999fe1b50de0d1a7ec88c74926361cccdf7db06c79bb1af89777c7f5696a786b3698cfe0744d55b6dddec1891305b666b8885fec3dd05c405ac3247749b027b16207167a780d0181bbe326473c3a05d35f6b4745392c8f70af941bd2fcf52bee3a238004886686d3fcdebd1d3f095913c633b41292f22bb994df7128433fd6538ea00069531aca7af97d6b6ec61e5ce3dbda4785f7ddb2acda52101219b0df68c7e1715f34705f2aa3eea687fef819ae335d3d4bb879983e4018afaf3c301289236a73c0071fea304dbb9abb8f59eb4597ee64fa5252229011e15ad7c70e97f9cd64a80a9533c4cb9795f594a4dbab7f439a04b108dabcb9f0ceaf2cdd862b022a4c81a7468c7730b1044df3b32cdeeb91b5a1cfbef14fa8bd0cd86670368da6e026aa8b783bb2d0a15ad2da172ef99965537e2bddc57ca294efebebc14a3d1a9361190a21f98aa681e7fcddc4a942133278eff48ef9f3e10a1e50ca1ee35ba6de8847ac570e267cfdb646e5f00689e0f5c54cc8fedc1a251497e9c44f7578a1a0b8af7059cee2d6f95645d30a0aaf3c4410045d501d4afa5cea36fe7cd2b241d89c71824e4f04dea49d456e4f6a0326f09418720360e9eceaa1213624e43e3cbd864513b3c109d0c867b933fbee1b69897f11c67c58545faca69c83345b5ff2c299899198a186b7fbe257d29944d317eb278b183b59f5b90abe11317ba1487c1f05c9adeca2bb3c73f297ada2f578dd0a7c935f353afadc5c6e7352537096531c55d2001572096e2ff6a8589c1af8d617e9d4d8df261ad0a383e79b71f82c876b8fc23f7f1be5a7eb9dc4add56e4f51eb83c92eeabf29ece213ff06e9357b0dd7e600ee3d0bfd423d8023e0bf64748b85e5b7bfe70aa948394f5209d98af80affb05c4fb1796487a0feb9485bc9905a987e731718efd5acc558eb4aa27cc2cd7690fd3c55aff30be893d3ab9810bc38f2a5d4b0d3d6a6b17e86645f8dfecd89048a6d54218dcdd842e6659798f8e11105094c9eac04d1e3471a15175d8fcb9a4b72452be168bae84471fd56060ade220587d80d1f4c5ab0e084ee9a18d96194ff53d4868e236595d8f61ba06b4985ac6cdc116c62ebcd84c706d0da425d3de654e1517166c52c0897c03b465bf55687142c7f512e226532f392a831823162b5a2c13bb9d2f7b662765a2f18ab0f834ebe87b861ba624b7803de8cbe04242a809474e9145ecfc514891b254c65fa6bd4f7833f8c4093b09f7521e5ea93accedc72afdea96345e93d65b5a6e601a03400025ad87e72b2a7011795a2ef8abb34fd0f10c33e0fc5c398a4dd19e78315b9d5a3b9f9e2b8ab8825eee867a89455df252cb0e4bebf3ffe6c7481fb6255b75d5d3fe9abb9690cf9e5deae425950235578eff4b0573100cb651ac84620f713725311c564c79ef04a6aa3688dd44440e35b20d598c21993829a6239b448ebf0a6e09a03efad7993587b75dba433f78d75d01a2c418f79e5e441c82bf77e9785c248ac83fd8197e3ddaf322a4abf60c6e903493fea796ced656a25b20733f52efe3ab7bfcef61d257c8dfa06b07a28861f42da80d3baf834de48ead2672568dd90c11f99209a3fae5f05ad2e6050cb56f1c666a5b6219ccb6e5a651d51599ceedcb950f79b81e9dc3ef6109822c1dcba97d32651570f639c0862bfa9453b8b92c3482e0e52205d042bc7b8a05ca160e2b2f01254db86e784583aca0a3972ad4843b330aa16b872bab22b97fde65a7b1fe38a5cc2746ce5dc956591fe032cfdf223c1f779b43268a1ef14759f2810f0ebe7389b2db915d18e079620cf68811af1138c9303fc2dd9bbe889233d5ecbface18034d84b5a8f5c5b57b47158ca3cb08a2ff59dea5ce7b0263044cca4d4ed25da777febe87348a0b49ea8f92741ceb2e5a6d30167d5b1e8b27d42f3ce372591ac241489b1777abd8b8a41e7094dbe0ce7f9ee05a5d8120584f10c1e85c47840924709a8c80847b092d23aacb6cb1bb5eb373b38ce112c1d5dde71f4a776ed10e1c14471db3e1d731baeb17fb3dd3a7ddf26c90f647ef25bf10612fbcbd802a4a757b93ad9bfd003b5b82e3508b4ccaf16567e3c41462dab7262d06feeabfe60d2a257cde0f553265db3be243f75e8b096362484771577d814ff5776f8fc387250a09daefaff5c14ecad974e37445b696cb7ce445f379f33df57c4228f40b3f67e9d08db6ef55344739f4c5109da943cc0552539b67ed6f699c42b2b193f9112597fe3b4c6a8787afde9c4b7c55e27e3bd325589f7b37662a57bc0abcb82183597f8b4e720fcd4290e67a1225aaa7f2ec304b0a3f4070c6af92f49d9102e391647d630aa5363ddf3385ae0ce059e9527bdd7d7bc64664e2bcd2b21fed0521b4c1580134580dc1c58d66b14078ef3ef8408e63bf4b93c3c589b90d35b8d052370539b02650d9ffd2c5f1a6e5f4f1f461d96c2ab1259bd76a59b7a3419ace05f60aa70c13517e43152f247965a50fdaa5dd02e7ebf5eb31592e6f706933e577d19a71fc5f80c2bbb272b3a3d3f01e98689a11dc09aaa98688c903e55363bfd8bab6c229b2f9592a90df0261c317f96ad42953ce17fe02294a997abd58bdc003672c734a1b7317bfc5e24f2676f24cb3f3ef1b5febf3ea7b66fa79a13e7faeb5495312aa006f619991f5130b93bc990e9cb41bb89c1d0429d196e8612c74bb2ebf330f8fc697678bb3d7b57991adb6780faf279b7911f9bf018ed9043a689b0ca8fe02a6480f4ad6e02c1c258ac1fa0bd5ca1a446649c2384efd55f213b04c92cb8fa87f8e1329b33c30cc0ac69c8fc57447e51039dfaac0f27cc6c216e8bd992a4067487fccf74b97e62d100c8b640320f3fb58b27bea53b0db42841a4f1f3703b335e506c635d251b84c00f57c1271f11a6fffec9abcec9d27891c7a6797733dc3d03e5cbf1cd785d580ec0edb6a3da32e232d786ff627e29b856a2836d0425c12afe153a4c03ab3dc22713c81abbec7a86605700aa42891156a2abdc5e894760f347fd9a014378433d94b1f3bde911007cfa58ac19f57753c88e038fa417ea2f239a44bc7c6521b2a079b8225795f0ca7727323baa7b1f7cb50331d2a85a6f50a73b2b4897c3e493ed940cfa52340612b568fb877ffc9572d49b0f016b5c7298791f6904e55bbc2373dad4a1c0905e3bff7c481351f69bc4ecc1bbec4ff2d6f287a9cf388c17d1112f48850061267694807ba369406215bd9c9de6ff66584a36021e0eef36a8b38b572501c196e8430d0e687da5f2ebd011d58b446bd5d025afbbb6886368e4f8ebd95594368922a3256ca7fde4d1354a33b02d197541f1db26ae6026ccb81c1a093338c7b0d71b6c853e149779397ebb96ba188ca4c14f0ebffdc24ee98941b0429761f0b54993fe9bd70258a7b9aa9a3d56eb32ee50141a77786cabd3f71fc490af32c71a4f1a9de8355aa91ce50dff0a2d48ac634ebe1d5d57d236d730b17904914afdc4543baa4f316f5dce3a459c88ed4b36fc159d53f9a1207532e445307e800d6ddf0b98da4d87c0a7bf064c67c88af0c7b97d33558fba024d0ede5e1778fbbe9feff98c3380e47808fde61c591ab51f2b5dfb694df1a12b41f5f879c38f0e8210a100387190f696bddfe7ac54a5afe51075b1c0eb602c4b678d30546a729cae93fcdbdf77e78c9d0844f1f6b53b44e20353438f056ae7b1a4cf85fa3da6b1b1efed51e80d78829473bc5061b465f41cd570b3d3cb0c468c592deb11c893467637d03ae373508bb96c75b37afc5bb6b93a765d191ac2304249dc813fe92551a078bc9bfb89281dd95329f302965b67640b0a38f5fdc0e46490193df58f3b96b42c0d9795f8e77ee146f40fa40075ca11bd23f304c8cba4220a3385678d28c61f25ea469c022cac6ff394b3379c61057211a553e40f3a58a426631a63d27c6e77ae15eb0ffac6f87dd18ec2c317004d096b5b4fcad96a89162ef71c62dcd85378bc639bafd83170098cfa833b1c1e5e31a9775342763c09e7bfe442f40029785940b39c6728fc43cda2df39e554f299188152184cbf98674dd93fda728e44e9baa0c8d35159bb3ebb9feeda384bdc934b34525a2eb2d88c00019ac7e5e98165e0ca594ec9f7469310116f4f37dbc12d7226e7b70fe33c16807ab00484a9a7a4619f6fabb97ab8b29160a142a24b16131e57b833aadbb7a3e0a074c7b06876900f0f55682931ab37ad810e1282e9c9a5095ef8795e00f2a0759e8bc844f519a74b3b4e9d3190a301af10b9f774c574c46b76f0b8ce7cce973834e025bef9c4d02916c2967302caaf5647c20bda0f61d9e4b641bdf17a4e7e0c5266eb6f7e70fc868a7464d8874634e5db6638f4d137fe0b42c39b328356ec45b12b0f6ff37eb50b4d28579767561b3f2a3b5d6e84daaf6cc850df5cabaf53b53e443172370a86ef6ccd182ab8545ac9f9661b004684d3f5e58e881969a1b6692e3013c38df2e0ec47369adc1c5e854eef320e140f7afc3db35aad6eebf931aeae08f4ef21e7e237f7c331cce6928c300e4363dc8b7a5b00f8e80efdf91df4bfe278127554b8db3702445f7f696504b4c78a07643ae3bb446b7f9b4acde335445491c836abbd5491b88befad97ea8b48e480c8266ce2aa1cd4a538325af903dc79f366aafeeed5a48a2a01c8b806e2998f7b599f92b34224affc8ccc9902ff9ae6c6aeb9998135c21090016a397010caf425db335c4d6110390d8983566fd36c3ba8af88dbb7fe6ebd35ec6f9ae7bc6b66e1cd5f4a7fe2b60a841db641bf70f0d0ca29d7a05016ba7a5de418bc6240c7873ef5b1a0233ba010c271b89ba67345819f1ef8729afdb2e4d5b15463622a2442061564b91846cbe14ea74ec705a71327f616fce2d6b74a034754887da1f537f6b0e4ea1efcad780f1657b367957e3de82b377902004575820f69854b416f850d6898c2e6e0fccb8201c6ef511a8c6cd565d5d8ab6064e28112bd5e722a3163a84f0bb1262ffb51983f8aae58d9abe0e6880a2d737d9f58f76946f5072f1c363c16c60de1a8344913df5866fdedd07b99d877325dd0c4c526ee66d5842ab138c08c767abec9075bb73daa5835652b01d5921693a48799fe061f1b04a6dbc6dc99632b76f3046a0aa02c133c0661693a0834200e7af9a75f8e884344b23477fb41a8f67661e9470f9986c4c80587fee465fb9ad08c0fdcc299aa8b08cd8a9e8c716ed41dfdbf878d7a1e478a9c07095c570068aa62b1d00df79c17d1618d8d0f278d9debfd9cd2fbc7ff67843aee2c55f77b1e61722f00163b97577291300d79112a2f32cf1ce2eb9c0ab554de00da10569681dfda2d66299e25952dcfab2017bde2b5f39d9770d6a96c30510858b78d8111b75b6378a34e981573087d026817364a5eb55eeba55e1d292c4bfcf95e7241d3e13617e85fd31bc95cb7eaeb3b33199c5b2bb7e123922f385dd9bcd0751ae8bd3849b6f57bb39843ad48d3a26baee906552e53a5341178127ea9cefeda99d7627add8cabb25180db7ef55e82faa010150ed8d73c88aed1d64019c216c2ec5be862bfc59decc3214f3737671a9dbbcdaf0905eac543141302c8dcfc5d3eac945b3c60354631d4ab6126c804e740fa9e4ec61eb30e6617b69ff7f7541ac6e6aae2c1bcb3746c5dfbea5b8a34119a4b853c8e22fa9b9c1561dba08124f70a59897c46f85afae4837eea1b593ef7daea2c65fb95fd1c089c5ea968fb0d27b6f08f2d4e3f91604716fbac8d8c0f7f18e65c6c8a3841bb0ae1cc6e8a3906545c62a5c10ade61244256c507aa18c2aeeb2423440c20bef22a6002a0ff8f2df9ec67762e09fba45f7ac5e85a4f686b7f32e4e277ff035d3e2a71b5cb7d2bc3f58bcdf9ee3379f551595fbeee44664187e07e73d75e982a10e942690904678d2492e0ff0ec47c05ddcda8b97ff37bfb534a3b604442433c144dd682b726d364e5d08aa183f521090b710704d7e6469e557983478a57b81944d27d3719cd967c40601ea84864c08266a05b95a5d2f8f67372c47c1ab7367eca0011144ad7d28164930432cb39e5e287e10820d1c0cea81f122f8d42eef30f8a8b050a8579bc9e42805fe163826ce699df0bbd9ab5f99f5099c18fe8a7399632a20ede57febeb829c6d223d03523df53b17eec84a76f2bc0b343be4ac57dad9445c2340fa2426ef224cd531dbc1fd02bdf2964dfe00496e23bd697e2b6f44ff18f2560817c67eaf5a50e35afb250a4ea9b7de3810c90ba3d233e43c3a7dacb7d49dd66cc8c5b93d8a489185311d9ed1d1235dff59db8f7ca8da9df6b65d810be96d03c2a472cc01c2f6baa267a3ed2baa8e40b1bb4d2aadacb8330025866dc2f95ee915c194e8385cabfe4878c742d9f5052432fab0394540a58c6ed8ea7f754d814ab9012b9389a5b47f6f20614e2422301a024ed61b82bb4c21bc83a6325ba713730273aa4d98ece69eda9edc4c2826cd6188acff16314aaa61c0abe937789375b3a547d8e7d1be2c9344b6573e28a7cc40b85ed5bd836a095f86f9f2369173b13e2bac7b005752dc35659f19f8d28c7c632ab79fc637fe63dad699063307a54d94f945dc682cffb97cb34570f7ddaa665f73c2bf10945a99efaf346fccdc08f48db99fd1f2e29fdeaf8b0cd2fe09787e81fb677038491a5bd26e9d01e926ff433520e9e08129000e3071936652dcb3e0e929924ddad8f6976131cde1a09b4dd092c512bbe607caa1c283e020dd108729ad921f62f0e18fa043b3d843edac73847b689fec2427348e6db23dd8f1a3e9422fe2dd74cd3826bd09bad69c59bf9a52601ff1dd2ff8efcde3de48caf21a0aaa05b40bcb350e2b3c76e4ba6fbd5a46688947bf2037ae3ac6f1d4454d34b8685499867e7a143bd9081f6b5fc060d41cf40d71c05982e4d72ea56c58718637c0559cb4f36aa1014464e5de016f551058b78d50d6716aeda6f6b39d8ebd841c96383d12da89b0d9e0bf579ae45086dc96fd84433609fad6a69dad2b83d9656ebe89633c7d6ad2c06e32342bd5438525ab89b8ea18134d7a319aa1c6136be804d6eb46ad7da512cd5376ac186af21bb0a6f80c11028e136240c082ff8169eba940bd02a3fe9a5a19498e98ad2abdcb370d0b4fcbbed946b94a09e11efe0e851292cfda2383896f7c467a1068c4894b0d215ef525541fc4cfd52c2820e45dde971d8c2c5cb1a87f60837e0bddc1065fe2a09213e349caa3fcfdfbab4fcc3da0d46a6eb62891a39b04d0a0d24f30553a5ea953b2109c72e1603e86f5bf4ad1d3571b0871e687a5d2000e07f7c1d0ea3b1342439fa21ad07bafbb78a773b4d8a9b4c338fb61c502a8d465bce0539eb6577b3b0ca403da13b81b04611880df458a01b2bfda96b29a221ecb14c7b54e75ff70d6037edcad3699b48ebe188741a0be79551c041cbadd4d90b3177c53133d32e2c66a2de96a5307d010107255ec3c151047d24f86bba0e9e03b936df5b82a90267414607a714cd14dfb26db6b83f0e9d4fe2b9b4d913c74e6021bc19c974d7799f434804e8b504178d94ccf178e5b65d5e97cf6e5470ee026f0d546037f87b37d6bb7be4bd41cec030cc91be64f898eb530d0ca05866141997ca33db18560e22b7662cb69d54bf4bcfb9fb02eed493b1ea64b0d9188ed4e4b748c1fe199b4b7b0c45389f7f23a28251f70f3104240661fbf6779d706dd9ee1bf2747d6a3304ce7b228ea161347b5efb1cba510b688999d468b474b312c714937dc4b7d01b0d7b08ce980980fb5fdb8c8358163c724a6bb8cbd90f94c19d4442d9e949e7b2e0ada0cdad90f42b050d5889eeaf41e44b3e133b4402b35019a1b05f3fe368c4aab0267b62d0ba86d19bb4e9b9ad4e5377ecc2c6d191d32f92139bafde06fe45349ab555a793085d65893549ecc86d4e30c04f5eea93c43f55af1b8d6834ebb325e62dee3267d13323907fd378c8c856f95b29b104e333461f75794e2bfaeff58cc0ad6a449298aecb13ef37dd39062ea264f4852d528f635de869b6a71207c256f77fd37ccfa6ac5d20a1d55dcb90e927d546f5723648e80bc5ff12e91f740cbd9e094238baf3e1698b68319ad38f9e10ff526be6c4d614a18ff016946f632ff6f0f52b0d64ebfb83dc83517a4a6bcd1533fa825901586dc6fe1a7eebbcf9b2e32b0d5822d50e0c1943d2de932248390cf2567e82fa989e6b0f26dcd56ddcc5e11be3a7ea8513121d869967068b296baaf40c9d6b4390524cae141bb51bf2aa24c36f677b8ade16fca40e13b93462344e62f7f1d33aa1779586231e866e5894e297e142487b5c96015cbee24eaea5239c71c4d4bbee767fd85702cf16617d5597eb109972027256fb1538c5885b3cfa036e05ccfb161d875e41d82a19fe9fd84b28352633097f2bb0331b521df004805a2836b77886214b7d1107d5f18f1681b8ce73ab1421497d3fe98040c701a08bd67e540b3eb79f547028b99b0cf531204af86aeb875f39f9b4456248046fec660ab6677245bfd32480c76c493232d86d6e807305ca08d003601024a3e1de10d8447d25729f032f9f51093468c1a0d7fa01de37264073d072f4091c9be59fd03a91ef0175bc401d2ff174abca02ecb881dbee2c107af3a2735d4994a1fc003ef089d6b5f2b61ff32b11c7ec068136c3a16154689082a973091ea7fa3d608b548a7167615e7bc6900d4e48b37fa2816d1e97f7ff452352661adb970528368cb7cf7a5fbfe40759ccb6b647fd6618c8debf586f7144a869486dc3409e50e127fef9f998fb715d03f250ba30cf41f8ad2c1883454158924eb7b8f00849cc17cdd1857ad797c7e080e8f3d4b0c4c7fa264b94e64bce4a2beadc1c98fc6b2fd04d80f9f872534644321ecfeb98ee654dd63af89264bce53f9c4c667c2b5cbc927e0a7abcd47d89d0afe55b7656fa942277a2faf90df824413dc881bc50a93c647709343042aedf2a93e9ec41d1086486c2b84ef19164cfbd0717d00297e37dd50a8d5239a1b30996809204e69363f13b5c3d9fa45a9cf59cade7cca9e10aaafb4f819ec32f8b6a55d29b0a8e0e9b2354741d00f4894c21094c1deb845d94fe76e16a1f33115e2187512b79d8b64e86391df15f27bf531145ff2c02b4774bd0b0751d9629921fe91d99da2b09e55ff8007de42aa7342d083e436b787ed3dd8fc1e5ef14395dbc061b2236c86ce7bfbb76933412ffd2ffecfbb0929a5df19fe0b0758e4db44d5ba1b11eddb7fca1ddc032cb3d4a3d581a61b83bf9f1ef88751b78cff7168e630d3bb27bee1e7eac76e6c66a37e71e17f2bbfe92bf180de19036862db9de2c75c94633a44c3c14fabde65c5b8b67bb1437eb6b66c352b0502b87444c3cbb40d205dd46b2925b5e8cdc9c21c7c5e6481479b3440785f71cd2546ea7189b210a0cb3fa539449096845b9175e73a85a1cf789396a84c820e11dcadff7ec2d2e19c178f1e5ea38f805c7b58ed65b15c974829ac7b0d7ed89731076a386214c33c0c47df24b395bf3f71c22b293e5770fea5adfb7e71ab7408df03fea87a8f90e17c37065e0024e6d87b901a304b28f73b37cdb0b3a8ea0e3bc403aee1c7c30f40db93b8f65897095c0e3fd9ca54e83360ab57cdf553b432c269374e19d9d0918974664117f26081c26464cd910fdd9695e8f3f8e814e163a9ba438c21e182e88d17599bcca5d31db1af7cdec61234f932241cead30ac15f4c3bc4643b5e3b228be1d5c80939f75ecf565bba7758ab4e8bfa70dec956e54b1db8ea6aa36679f04c5e2398557683f456283bab368ca53a737f3ead0d8072ef083a7b97380a8f3189a6e7629cbd2b2daf631a41bff516157b55d7a4fec3921b27089c4269833e53c434e986ac0b58b5d6916fd837318d303b37ea3b0abe72c595f8f6094bb07e640ec7b62392adfd82d5d9e7522abfa736ffe1858d4f7b7a950259f5cca250207c723f7d81ba988ccad3e883d2f115bf2cf5b30d898032c1b048c00fa21e06609ebacc316233f3f9d6c8878d2d9abf56c525427c3f4520e2ee3f84a6516b271986cf41176ac2c7a2aa760533f847c7374047c510baaa44ecfc382458af42d845ac56eea5ab5346830a2d26093458762df934356df569eac02a23234630bd05121e9245359c48f8f8ffc9edf0bec41fbc3aba7e93e80c0301872cc21912842a3729397846ade2c0e09d07143d15d353477924c31fb749080b4cc5ab1aba3e8dff8f122d062bffc050836a5ebafa325bd3dfdd8f9dd647e5f728f9fe166dba707b5d4f37070a309749ab7f20662f56ad0374de6967e26e0d0e97054440a61eff155ba6768f04dddd8f8fa2f2eef3c99c55878c9c7ef10e298bbbc8035ba6c1f6fb8b38bb8c7ec621bfd6765da3c698d01c3a72ab92153ea354d1b9916b30a3044ac79a652db770984316344ce028f4f1140781d8e00844ad31439d9238cabf59c4128fa2aa91a1651b4017ea748ed03c5fa5c0967b124ab0e37bf15861880d1af23370898640a9106a5b68ead55a2d70c2609d31f21812e3050635135ec3a29c57510095700be4e742200e4f5f5f5da56a35ca0c61330d120a7c262f8d405b7b20f17ecba07f8832ca2aa0791e00c5d40061e033b7a3802b432348179a5d2e8656e1c3e8445c671c1db625a866573c6f9e0f371d2745677714fd4332433e22cf971e7fa924be06f25db0c2af3a1d04ba15a1de11898a3b6d467a105f15d4903a8859913b255fa33911c2c774f89f210171b7eb7b1a180c2da1f7d775288dd28bb5930f96beef991170af18dac8674df630df218028e1adbfd003a5046fe0d0cca8f3f4f7edd6458a2bbed7e6194dce34a6bf2c5c07be792ccf15deb994fa3c0172a36e245cbed13907309f6ccbfc7416ffce46e0f8d17a9cb81921b27599557da11a6cc046106ce00ff7bbe4ce35e5ab0b2f00aa4da1db99d1e2f8dadd585870e5293906d4307beb375e009ef1dada807b1085e0883d1fd14ffcb8eef99a5e5107f0e991ce3a31296ee16440a233a998446e6ce39b72b6b25058ffc9e322dee4c084a32f8096b454bdbceb994849736ac8d423477dad64ecd854b9ac49de50b52884c9c776ba409f5eb1f0942d2af4c7040bdba707634353c59b47180c19198e8b9d2369c422cd5f661632772965a12bf62ddedfd1eedb1c43f7bfa8dbf4795275a33d5ed9a30fc4b523ad3a7b09450d1c39fa86f6aab11d8a4c3c663f6db1cb5d45bf4d5cee8da7301ff9f94d90a515c136c31b8efb2c74526ff6e4159040321eca8bfd13d20ef4004fb67cf740827c22aa46ab68b589053c6be6f69e34da3d752d3dc1207e288fd831c6eb683cfac9f97ef392d78ebbf5df8220027efb91487fdf98a6d5fd03f81f9a6d8b9067f9116b4e3bf767d3bbe04339ef6eaee427112b3ee4c5e90058ba10a0dcdcc5d15e0ff7acf8f1ef9cf3bf9383f032c3bde5050dff1f5842abd4901be1a87c0d91a4bd313d1f39853e6e03c4947cb02d01aee7fd0f340c23d831126877ad3eec77fae31e14be0d7f8ca655c3cc5305b44cd920aa9343aea190cb5386c5de8a2ad4ad9ac2de160efbf6f376edc51d6a771a1d378f836a89463b697f612a036ad73d25c9276be6e3c77c22c3fb182c777a5f68046be37ce34c701484811511a4fbf94e9417069fdad7852514b737cd9c9ea44a6195","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
