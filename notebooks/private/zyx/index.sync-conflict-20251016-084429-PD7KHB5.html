<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4927391cce9ded23d4dca9b4caa26bc87e3144364d3778241a7313a872f13b31406a788bdd1220bed3595dfff8a39e924ae9c0b333ec074306bc291f68888fd89092a48135e1495ce12ca257797c3cd0e37281f6c995b18b9de5df592441155fd7a8f127c62ebb444b857c4d2dc78573b2355079fd363df821eccafbf007bb568cb4c0b45b209561d58da8ff31a4987d182723c0c5605264ad4447619c25fce9bbae4691445224e6e9c23d98212688e56ec028eecfa73354c6be9270cd85009e58a47dbd146ebe2dcbddbcb132d3865178ae624f4d0ae8ba769644638effb382498ef84bbe853f413d3388402641948fc15435c00ece01bdd569726a481ce39d3b616181b0ea529a07b112276fe1ea3a87a81285ca6a0e19d5c80238400406484ab3d83c435b38b017fc75469473749c3bc5980c83418464cda12eb4a822d5c2b1e9bb2f8c13634f960f389a5713170012d15877f227e2e5770deb3d12211bea233d86a00d08cdafa78a87076a051b2929d485539d67e163e7a6f3cdbad334cde188db6cace2207d1d75a5bf4215f74f0a0f169190ed621c470c167f659f0c9fab3ecc563c9f6e17904f873589974eb955c230e30a3d672e3b73d9f60f7501ae44cef636731e96e211bc837e8077676a9e998d64179ffdc6f1216a5bdd3d8f71928a6e23cfaad8d417449e2e4eba05f14c17806df8183e6ce4dfa9711140c1ff83f6c8397f2ac4cc1ededef72ed30643d887309fc4bc0d9fc61e0ae579bd717f5b32a1b11ed220e55cdfe45e5a3fdc6b3f486fa05998e75bc6e692f40182e54d42003dda3648f737d15beb3113840e1782213cbc438fcdbd9c7e0bdb6bcb942d0f746f09f320a5ceba651ba760a86236369f1a4989fb969bbfcb161d25c6e16e94cda9fecc1376e21f7db576bf0fd68ff26a125533f6ef074d9dc9c4955ce1b8827b735238a62ca240fc3a5a042b43dd62da9afeb819ef9331583950e491855ee35260b6e142aefa9cbd8fb3c10a5567eb7d0c348bbb18805e0ad303153d9b7a95bcaf164909e97a6e9e5c285f6b7d2fb8732b2ee98273c68aec561bffe936377f0e3858e164045c24b4814dcf50777a994a49ab2489d7dfb6f6a17047aa3e953e22ed353aa7aecabeca5c3a13109cdb65331ffa244d9879a24701ae39af27a2563ba513a4fcb3e9369bb04d941de13e5b27080cf982733b3a1bfa50554f69ca5d98fd10be6c8c4bf0bc156ef269975fa1a8215d3717780dcad24f154db9ebc58dcc529e2a27232f3bb2056271d7320f6b04162bcd53a9a2bae1e39c48d57e631e20ae8dd10a6750035e20c365b01ba0ecabb2e8bbc2679bbbd394e43bc0b3fd25e6213e37956f8f00599e9d246f9c6f10545f7a015461055ee3986d8e563e110d038bd9ebaf103d68b37ed6d13352e605f77ac8c4d4f7b924eb8ecb023e33ee09857b6d6ad320eaa3b547325297a2205c5f95c460a3c080a8e0d2d7df3a4c3da2fa1c79fa4b4e21dfe53a5ddeddc89b9659ce56a8b30b91538ea5e66372e7ec8d432823f02bda6408eab84deb2957e63955b9e31aa7c84b95ac75bbdbd03f900826708cacc9a7dfaedc3dc72cc068ca7beb8f2a22b220a8e6d58334ec644ee05a2835fcfae623854257b90b9767d55f0a18511f663794a86c48c3306d8020ee401025cb01f9492119d7668e57b0f9920a7f3d9d88552d319adf56af7e23923c0e97bede877a47034062abca8d1bd8b6b6a44799554ed752ca1e07dfcdac331ba63f77e2fff664c67d01cf3caf15e18dbc500d42d1e9fa84941614b50024649cbd2fd39470ddb9976ef01f6745ef09f7188f1c433c7810c7ab6919f2a07717e23280c52b319baa75088169d8750b5b673aa45b9711225a1e911b5644055c59f9f983a3bc1b1b4d0ab393568b2c4cb152c69d5f5f9d35beeb07c82eb3a5e5212c7add00bc37e52e21303dd1ab51a33e1c2e85068696b999fc9bc76687c768562c8046fcceed214bc5128b97e5434f7bffc4b874a5e164b280fd8100014eb44c7bfe9a61a1cfe18817d5b5c4d986b6673525845a53d7fa5955bb174fa0f7be41bafe2c149a427887882f41f03fd0d585ffaf173cccb85c2131cf6203d4bd329a2114c58f164dc675fc57282ac1797e7e191b3e67b691ecbdd1eb629432076ad4443dab29aed7e4daa2be1206f14e0d5a6023a11ef3f8ba8d5e032f223c4cba9c1bc9a1467180d3d04dda9e457a7625ad843eff8d3d06ad14764d6e2de53070d46e81193cacde5c66c7e33a540dcd5cb6e1fea97e5e7864c60aa3b5ab949b9647f1fe1c563179c9f6f73dbd89deadcf5464c0504a31a8a832d6245d2dddde8ec3d3436542a6b414202dd919a9831c4f4cf3884b807997ca01c68e20365115bee27f6bd72bdb28f7c4b8b6cf250d14a7fc2075bb508b2eaf0649fc4d14ff78a5af6c443786466ad30e495f46752a24080065818110f7464bc759fb4db42bb60bbf2f4a58011393feb5c239b277b9d7d8f555d0b8bf59761891f1bc2d106d12fb5555c93e5efc8e141d3147a5f484e8ef60614011d54c1254cacfefaab0c1491b1672436f8db8c6581d0585a2e99a11300f748b4a977c9d162dce09b10b39233a7ab2887c3c3a4971c74e51d201ce79a3b6cc9bfdaf2cf698c1ffac821d3777f3cade4184873eabf2a2c42f8c6f5aa97a162390ac69aee1a452c03768a58309a6e98bcd817bad70a49a498bd16e4e498ddc467e4dc50ed3e1fbfc964dda136afdf61baaca1d26ecd46d9fd8db988cd95ceff000831e4be5cba3a9a9aea70bec5ab09ba1e684d50efb1bc26d59b8a5b4f7ad8be557fa0c82fe9646e850fd95f351c70ce8b3112a6d56d6ca2a50788c8db0047d3a76316c793c56d24e43df33b48c81fd06f22b10ace792b430edf393f8eed8531a5af7da33b679a7dee8c3618929724dec35ac2ad785025803b5c7f0410aa4bf4756745b1bf34352960fc192f6fc10d33a75f8140a80feb45eea65f0eef03e4d2f1440a7dfd0251011066eb04c2e49e76534370bf4c109075e04a54ba77f564ba9f05b36abd0c4f96f7a944f0c9c5d36e4afd5b3f365beb70683b901a6ef4aa71628b82e544d4e2464bb02cc6f63dcd7ac378d2158d88673f8d46ddaf6c0fdf87eec4e8a0dd897fdb7adf86fcccca9678fc8ee7289b86497ff93877aec90e18475b01422d507e57ebcd839b612e87b4e86a08c9648c9d14fc193dcd65faa8812917654582d293e02ac87ecc94fec3a600a7dfa6df0d0ca78c9bdc3fc6563d379b94a3dc35cfab65829fe218b8f225be2adcc846489f624ccace45d101fbe981e60e491e834d5d401ad58ad6bb5ec15d9fc0ca14f72402215898bad0ef40bfd9b2b2f8d3647c11a0e186df04e8c09d4ceca2aaeeb535824940f513596ce33b5f81339689157da03cc2dc036498557790091944ba86ebd2e873d960c45457f49a39c4aa0984c08841cf2767370c5352efb58d7cfe698acf6aa75a8556324fa0ec61cd5d8f65b92f2bd9e4fb391dfae6094bc4672a5c462563eb1be3cdf34e0cb38c670afdedc26cc751257106ccebb32f31cd16ba706936df3f5ad39afce02b4929a124d71bab1565bb02f247d79f34a5969589af53224ed7107eeacfb9594c68d68fd273ee1864cff93cdb83979a39bd91bcedffc6a45ac250459534ad1267e73e89d4a91e39fce98b9b333af245b31ce1b906cfd29c343f306d5f569f212bf6bd40a41d92304939b4c28f6d1621c5a64dd12725d6c328f0b02a008aacab7b66e3083239e070c0884496ac52055b72464f1527ecf5a3f5f8e253a0d640d1fdfc8d856515b93505edc0786be25161a93d944ac04477f9b7cab0d7bcfc75f133164918e968d2409d03218aec3756699cc94ff196bab03fa60910c100ef0190cefdab5607a499d113c405888f7f7bb1cd9568941e16ed1706f073be4806458977c2cb92c3d7253673b2db7cb65e0ce6871b9030feb378bd427ada240179c7961d5c6c0114d616bbd81bd484b91f24db5dbbab6534fe682fa9d46420f85daa35c0bec6645cf6e0f054925ef6e69d8d9a77578e3b61d072bae4bb6c303f35f2d5aa226014eac269c7ffe799d77c382f6e58be7c00aef09d671783ab8c64636d91a49667a9b3d17c212d77e8dd1474ecd29f6c42c5a28f8be1fd83752d1d6ff6ff651041f32507f1b2803bd878e52a4c038a0278705216b16537bc333667b62918aeab5f78a52a68797874339b784d4657bc6bad626dbb02a71d8c3788c6fdd94a4488f626d8623cf2b9b723435b88ea401812777b168c968a9723d572fba27fb2aaf4cf6c72b1b29de4870229c057a7ceb70e14c0a368a272fa22dc79128f79cd0b0f1a621a902d50846e31476658cccd1e0cdeb1bc456bbf424aa420052353fb877e42b459a20d3f6cde98e18b537ad8b06c763683ccbd2b18a995c0ec51eef5f97354c2c66f20134ad212a5133c47b26e3b0ae2d13287d33f9cde2310af9f7b4ccfd3f7a89cfc6d70d40a481e2ee0a7102fe0b7926b53efac29e5d58e4e43d876faad5c626c7bf5b8dd2b0c3d60326c3371a1bc93daa1f05bdce50068445c8b791ccdceb5c348e781934adaa34e9498ffcc369c7a1dd8a835456cedebda5e2a1dc610d35346678d927373bd0a5bd1d4a639f106c3c14568067fc27d4841920b710b1b09b5220fe1f2ad7f07fb201f3f7acbc3109eb25f5585bca2b7c476af6076a32b0c58f875382df800b792ba4fee12fc5e3abba22935e508fa75c7791cf857eac3c6a9a473ff0c99ec4bef29749cad81037f7dbd5f7c6df148ad2010c612a72f9b659a33e205e37108c479b86ec0dd3fac8b589d00ee8c51b3969c53a5832287578feb88b5200669d831d16f3aa9574d245c561afaff26b8aa2f4efb96733499bd305347994c5590742cd94da1e16743c80919aeef381242da5a5fd72386efc27d5e6f70f542af2eb05931adad5a9c621e5b499d230b9f7ea0ee996a270421a016ca3a997a1995ee2bf518c314b36e5ca1f392908f88572de296bdc05e5ba347a5149ef2bcf267d1c799d911a979cdad70e929fb8e9af2c49471c29d00135f3883f2e23557d5137e4a0c648ad407ab1cc51e8610d282514b584825cdd48744a1a443d46d0301b935967e9b15e5dc35346aa0c845060b6d15ae4b161ef97ca0cf8ad640b20769dbb6e0031edc9feff390d12cf0d85be88846215ba0787ddb783bbce6b882d77adddee6742ba0518658d71ce643eb31d9e3a8e8ead5e50520fda20471331decebe898510499b496393a19af520241ebe3365d46880b48ed442a0064c00045c235ccbc451a73f343715edebb67aa73c6d9f9dfa9ebd8c7541da24cdb377dc262b1912c0cffb757222d6ad0de2091703ff5239f22e657ba989e4f5b357f4b38e930978db434c0cfb124291dc51821429d53dd7062dac2671e6eb952ba4f83422e41b0077c6689a95e63a37a1e4e6088aee76c7f3ee46b01b8668102889ad43722674ae8b57b057f845cd159aaf6418af7ebc2306efcf0065d3d9a8b0f0ce9f05bdffb6dab4c84c052f9a497cf4aa670e5246ba2994e1e614ef6c607a65a026605be315dfcb2f00982f1007aba281e6493457476dfd3103f68ce1d8666142ac799b5242c5175adadd61b7cdcc35d95762ce722a486fa6595fd5ed896b801bb59dbfb9e56ec09bb19e23dd07323c2b472606446ee237e9c480a6e1976be14e13dd39a520d4044a4d444223b6a1b2d6ef49020daa85062cb934c0551af80bf4d6776c9f96d2c5176a22e8cb9b51494e84d8564fb014e3b14b7f16f41b87d1c6cbb850d2d9c8aed21a6e7dab6c7e2a2b604257816b4d6ca8b943713de158ff79378c747bf3999107c5b724f122f711109ab030ab5cecb0aabb97032e408d572f644da86d6516f7196bbb60c5ffe08972720945626c2d3fc98b9d2b8c2edb7dd36fd3b10071bae81cfe77bfaaee107ea40ac250cfb93bd63759cf00ad4d3bf861329052ed94fb9268f8c80db545dd31602786f56c5a68aa6f0ea39aaaff7151f1aa8784bf8cbf875feb2cf319f603ff70d67615cd7a68d8c323fe14a9825fedb37132ec03fa2d372ac9f68c98bab2d8afcc02a8e86d1f3771ddebabbcce4aba13ab5d740938cd62854c1af0c117fc8912b572e5873c1e12a90f3093509825f46b45c152d33639c03bd9b192d8279fd7ba6bd4020bb745a7f2fb94ed9030b0606800a5e7679f5b58c8c92c05d870a0f4b923ea8271d71c99c53731caa8ed5c878beeb3ed37a2f0a0c4959bdd023076ee15182d752b204686427c400bd3af8915ac0273f55eed0b74b5039094dc5e8427586c84530c7a4e90758b36f79197444b892ede5109def4ad6b38628651052d7b560f6d61c38aeefc91fc4046f967f7c6c3928467cca9bb7ef470a197ed199c7c2466c1829e836d368174b2b2e84830e2266492fa26367beea0d920fda8d80d157e17eb491ddd1a4d4dacc95f180a0343284b9826ebc6d86f9e4062d47f9fe5521eae75e7f2d7622e8e9bff38ef2baf97e1a54b3a056e19e74f41883e29a1d0c3c2c25c5b9d4748e806c29baa4f66532f9ea7c75cc49875001f30cf1314d4e360359a92ff8f19adabc38044e548f62655e9f731bf6ef0753bdb7fe0d183ec32a9717d5594897156c47117718abd451849a4de14ce310f78463c83472a1d4c6a6e177651e34d1b179a7d81094030598686acb0532c4dd5b11315a415239f15a4dc6cdc6ccdc534a368876938dba864020ce400788997d27265b67d39a322755305a7cdd52ad24bf4c64b33c9fcf72310b4be7c833e0587f316a08c7807b0c6973db32ea43c88a551f45e66b143abf45b2ebb458feaf94843af408f1185ae081acdd5103ecc73996e542fd45a34ca3a08da7f8cdd5b2ea72e736114ebe14636ed7bf61c8ba0d1a90c32070848e39089453a6e6534dd8c0f5d2b775b59f188c6e2b093da6a2c14ee55ad5f6c10173c8cc745349467a17140c0af33ed902fdaae270efba4387adb56429313e5d92e71d9b216955f2e26272700e4d729b18c9aad535a5c6eb6f7b445171bbc5a1025f8550ce15a1073e6f4d3572aee7184dac5c58b8dde53e970165d7fb62c38fdc91177635294b3c0ed6e4b921cb799d23cefb9e10fee2490289ff8f58109e2bcd907a86155f0fc0486c2c07b4dddb0981e69957e4e2955ccc9b02d2ead15f7105089a019b9bc1627106a070532f149bb40498124af8866b998199bfe7d5238083d6262ae05579fccf401f8b62f94449e2abb30e5dc332ac9405fffc9b19d48a11bb1e4cd8694d7359e15b4068041382fd8922834b30bfc44e4369e88c6acf63805cbf6c51d37d9322d8a3196aa774558ed8f973d101fd1fa45922636d0e538dec46141c504298726eafcf8f2509325d162e7e2a059fde1f006d81e7be66f4b526751a71f825a99fbdf6996720025c6fea54db9f0d890d5d48ceda11db890ca6cd97e599c366e8dfb939aa8541648e5978438a3827220bb147fce135188aaf0036641727280fb31d3e477a9ca51c1499fccb2bab35bbf60e8699bfa35728245f0ff13c2ba80b1bf5efbbd74bc53cd4ae7fc26d05cc43d6cfd4f864d9b405e52df7a4a3a4f3cf3089c8607b1e56596ee7cebb7ec7f7aa45be8b9e7a409aaeb86d861b08166e5c12d6e0ac10a19a46c514cc3f220f3821e60cbe9c5ef5f18a544ac7f5d0429140a5092e4252f11a0d1c1f320f32934dbafa75597c6a76a92137975980dc4d8dd8c83fe1470c7b1872e10a3020a22a2c588a1c75308033e4f452e8e21a5c20971f311bd841b634ddda3ff6dc14316e13fea1b4e8d1aa8d625e58148812c93ad196f8e553283b33bf61238cbe5043b0bab816e29619fb1821af56969a173cd496fa777afed047265425a98a1a71c751c9b7c9df27b9be8761022d9f4db8f15380ef934fca4a493aadd43e4aa38a9e5541df1b05f294f8b0c388c7b9c92572a2209927684451b77881900ab4d4de23b09d241eec3a4507d9de08d4909d2b324f75ea2fbf62b03c858dcbabe59cd9b7a350bf72e9d1ae492e1ef3102e51a0258dcc7a504d4ffb43107205f543409cf8b1909549da61870b19b74e1ab16a602c2bd5a13c411da1640637098dbac6c6ded552b202c6fa46d5ea7a04b844ccb300a79ebec3222fa061369338d29e8fecdf14f72beadc672a36ef87036e666ad6bf32b0482bc009a4c5933176569eb7783156d73d0cf705318a6ecd5b25eb7d52fb608e3a212a116a92333645bcabc406d8739c9dddef4579a748e8070f18f100a9f9983077f8ca52e3d446c58e62b784c89797a04c56d7128534d8c59372efd1b63e7aefced3c5370ae136d3cda15eb6f0239843f5b55de1a0567235bd29be420b379f05bdb68461c769221d5dad353930097075e69deb1999ee26ddde05264f7da87a6d540ccb8a298f0498d30b4be675c78052a296aff50f9f531cdc39764003a09d4805795dfc1feda1efac58dd24d80ebe5f057a80263a85d7c61eeed8e90e12ad6363faab1e96ebf9e0a943da27a399b47040e7935114e3e27b27453ee3997b2da01a9c439d09dab3c144b41fd9a01c958c34834247ffe565fe5298ee32fba9c0c74350cc8707bc4d7f6baec86cca84e32838319ae138f6d4c6f43d9b19572c20814105c7dd0c2a4461ac61a3a31128a5cff3544ba670a6f1fdff34cfa8859b8b858965ceaffa7f3b6b5e76a1cf26f5097af41fcaac1e9954c21528d08d8d22f29cefa0f6aa345423d0f43c048db193fd07bed50be8e86207a8e6d0121dfcb567552f2c6509ab6d0842fe9246a75c05297db0ea3bd7378bb17558a7e9e7bea274fb875b3e7f593714d200af04f1d8bd529f4f8eb253ffb439d67f73697a4be16775e24f906266ca0709743e52d0d8081ad6815e76c12398a91d6dba22b4511c2b9acb212f91d40c9a0b69870b8de67d48c885b2609e2b702a197cfc8c266c224c59d68a0b03df3e208193e826dbb05bc4731c3eeb0ae67c72a0d188b20dee98a484e9ab27bcd9adafd96665447623db334e3072966f3d56861a7c9393db8e7f916fbca2e1b8a7ff3f30fae8430b565a82f5542d2e5df4f7b61fb8ab9c48d4cbe1cf39f179ebe8a22ea486d6061e69c82ba7e7dd5868522b2b340ebdae74881d4dc4f259dffebe3cb0432aa8726fc44a0b6d38246b5a8d37c72138da91c7430bffd136652251995b9868a5b79112999fece5d1f9e73c6622870a26e01d5ffa4b42ac664c59ec248dde4e34145962df8ca57c0931158438e0b2b9c2edd47c4ad6251faa25d991cc9e73642cb51fb4f5d500b1241d79782ab499742aec5ee98e7db405a85bc8d2e92d3c4b6db09b47cb07d88c3afe6d4f56888d6149e6548cb6386adc76e2ac266b19cfea6c366e0bbb841e62cf75219ee9650da099450e9382788b5d87936f2c9d5804c2af4eb0796e18067f29e4a3e23698dde9054f4c9a3c0507861f3ed0cd9502ebefc5b5f93c8244687125188307269dcc52eca4eb10eb58298aac6f5fafa0fc1d011de35ba4bd6877d55f438ca5e3c74ed4dde854d3e200a180d5a1a23198521d641ed205bb86b27f8217e5fd0396dc063e7b82897ced5160d0edf19b55dce0b365242eb0c65404310c5513465062dc2ca379d96d7c72a4a4dbe0c2a477651f66f71a3c02a8a2c470453468f4e50cb4d38edcf17631af4aa3f15cbe0935304f9c6ee79612158f660b735a3f20902ba7535d1a953f1e9be2ec200b795d3732d1db44041cb19697653acff462e88ad44b5f585f3063645184b130b2c5fbf88d1db6883a6763bdc438dc368a241c93500df59867c0e19a178a3624364a6825be3daf2769397ef88a55102832d19f9ae5f167d12ea39d3a0aa474d09fa6a1b86087c1153f1220b3cb6e9d99f789133c4a4ba53ad2efc14ed2481de965c9064a2a219aa4be4829eb2a59c24a6d4c79a665b542af08389dd30a4ae90186d0b2762b239b277368a75f4004d7b567e3c49e57b779fff42d26be540310ee1afae2e1532efea28477c9a11de8b80495c44d21705a68620bd00915033278ceb0268e8abec5a5f989e1188bc4457cd33d2214261aaeffee7c02a41f48f0ce42431d8cdda3e88c28d0ea239350654f3e21cda3abcb9bfa13bccb198b16e40e3d231dda75fb295059351cde77bb5c43e0cdfe223d62c4e206f090ac33918f3044729654d39f34d1ca0944b393d1721f69f7cae40be1e6069db9a4c112dc464fb3061db556a65aa85187357ef2a201bb1114b3d235c0d27445e86071a2f2741bb0bd9eb1ba56b01e43aa49e0989f4630ce2300bc3b26b776d3f199e621192c9456c8d3ac0b9477cc3c0db0dd4f649bd1c48ac959b78e661aea4ca7fdac86a063870f65d87faaf7eac5159cf0005a324d7f56d89944406768829687b98d3ec5938f021ea56bf3016ec98f1de038ff99390bda066e91166e0c286332973a7f329e2abe4029d2649005396c8786c5e858b71c5335d39229fd87a32f56546da3992eec65de2f39e09255463d7c64ab53041824fbe5ebd80645635b464837afbf68e69dec535f6ef8502fd8cdbd674fe5a7d75400ee528f981907c59ea7b958498cca4234f1cf1608ba458f5f56fc97c85d56a17be0b7e400d44823b1461b467e88676b9017ca551ac5b1404a8bfc8120654fdce57c9e1ecd45d7a27792f177b2de27271c9f42893bd9b6889893ec050b5b49f318e73e5cd472ca5e98e8a76e441e82c9f40da51471b0eac65025abd80960c62fed7e515e9213156111756def49bbd1dfb08154c870b7425c11a4649cce4e58ae0dfa02eda7ee7cb1e4eefac2ef382a3006bfe47bbb39bcb27f4ae15a60b9356b7e4d61ba869d690e8034fda15cbdefd2fc2271d04e558111a1c6222ed0566d2c6f8cc02224823bb5900641d5ebfc777982c8c60cdb99cd661c5aba8c62e33306c18c8bcfe22a09e02be4b1d038ab01f7280544d536f7dff2dc07892ee0d895311143a6ac0d7acdbdbeda74aee057988af4db3cbeeaa650ff8ea134fd44eadff5668974a3b33ba036598e56e5f677eba1a48ab99c81ac1201383cac98e1fcf02fa7db967140dcf57455183b80f4d6d7f579690d869e2da772182e14b014b8ed63c4a26d2e34868b10900f4289f79cd9d8eb7e752d9a9dbee6c50424dd4a147078600b405b736ab82515ced9a2a132f8945e2594c1bc816b706923c9bdd99d99b80ec9e28b9ccad3b00bc2e086afe16f9d7ff5618923ee75cfa490b5236a102aeceeba5614cf9ae2ba26fef20b99ce4c881524e6de6608fb83411846fb2674166b0422aaf307235e1098f7cb90b0d33a5fe597a22a9f85f1ed58c391e2ef449ab6a149217c0d5a5acdf20d77ef0277974a92b444b4233ba6cf708fde8b90af04adf4efc5635d06f7cdd3b7ba14ec48ff0646ab20bfd81ea18e41ec314385208e124de1f4ee6d15a95a1a4ac1acbf51940758ffc5fcf621c3eb87f1fb0debad4f8afd122a0b59d05a000b01650f7866d8e32a53f36ef7a914ecfbbfd7a09cb52bfd203f59681da724bb52505cb2605340eea23f93bcd178918a74d2c3859b59128491ebf5e5a3cd5c254601b60f382f53aba94ac5ae581b4ac0cdb561f2bbe0ba77ea19dfe363fe0c6b6476e94094f1f04ab0abe33aecc486db173fa20f2d858d6ac0e77c1d3fac2cdbb1dbafd5e954556928b5f29075e6eec83ded8e7fd11c73e9da3f366b981fe4fa18a3a2720761f9d23ba7ee8c3a5d9f9209300d93771b3f87fc1fc555a44c379a753ca22beb0ce7b0ab2bac7aaa543882f43fe9b8525628e82f83220f8912b7d6ea54e72926f04ae64b04925d41b20d8698a5eff38c063108bcea0d19e1a6ee0e76bbf1b1d918e3855f062d41b22f56c423c2cf2e161f3edb4043ecdd235eef8eb5355deed085f24d29ee68545e8ed9ff1ab710eb899cfc412d1ed12aa03bc431433e21f165522945c560eb242487528b9085a0bc9f5ff9265193f6cfbb8bff75ade7c62602bf36bee29e1382412e1e95190a587b949fafcedbff0b02988ed948da7fe68cf222b591762782e2134d422e8c152c8a2fc0201a86bce4ec86b59155dcee1fc41cb037b41c4c170a1245bb393c61be6a47c8c7a3b03807c6486e61993e733a268e29dc51de93b494ca4590d0e91ba827570843f9419eb3994517215be531b39955ac9596e0e15eeb0ff98f9ec8629f3e16fb3ef92e1592af59fe5717db5dd4e59eaa688b37c6d96c9d78d39e2679f9b783befd2c0e0b50c58825fec2e51341d33bbacb9a8666e50c0aa681d1b22cc0006354015cbe023abcdb5b321a8738dde3be12b1c15474b6f3e9e26ba7306dcb20a92040c3c1b878a530ded47bba3df1d52fa46d87bb93327c96d7bfa359b859b42df785f34fdce752e9c6f2cb6e2244c4735dcfe662c05a91180557ca4bfc74c84856115e4bb0d223659890ef7390b03f458ff3b2360fe952673bf05ff95488e8b544015a781e33716d3e72c8090e1c8055df09abe4f7dd19d08d834cafdb4af208209c12b6552fbe7a11002306e5af818f121bda73e4671b7657192ee4cc1a41abcc8dff95115c302b8daaa5750ef01588d7069163c9e51ba3edbdb78554132923e85216bdc2a6dedc114098216cb9776b9199b6d90744b1500f0e6b4eb78d75e6361adfa3636422798ac8ff4aacc7d1d4d28c637be4adec4a788a4dc6836c9c7b5ab29d3e6ad1d223c1b55e68955567086d2f6fe2b0e8980031ef14c09874f5c4e520cea4446816710bc01434e47bdf8b1a5dbe8f97158679e96ef327c1d45633be7ec8faea1f9d4dd853e4781288e9c8bd750e1ee99c535ec44605f0bf204e9fd8494638abd474e7e82f8dd64a1511f7aee8008c3e1b935581e6da9c652caf8d3160159d2696dc3a331a214073819bd5d488d6a7b56c81d029236a86d19fc1654d5531f885649dfcb301155441c87db84b10d28df6648367adfd118b710cb1b2f78ae2c1e34165591dbbac6a9c77d19c71026c07cd752b6cc958077a83f796e2b221b5f15d03eefb0d017265bfc19fb7d7e80009e71fbb1b26a9a154679b437151c95b3d951064ead84d5e58a0aa5d43fffe344af59d0e595652b5184121f5b18401ec63148249e003fbd896ff1f772caeb6b4c5ddd888c8e5778b5f6e946abbfe8b3b387c897402dad44660bf87436a1d539aa501d59a699ce7bc3891fc92a63c7112b8506331d01e006abbfae940982f1e62dfca22cfbbece0f6c75aec28d0c0b2d06b6c59fd7a33edd85237d10e60f326d1d96744f3ffaf82b8c1f8f3a02f21040cc3d8271a029f0fffc0723703d881a43ac5b8ff48c50df22b6f38b94622f825880d885291b57b921940ba1df973b97d7ca6bccf44fbb3b65b306439110a8d4f14987d25f144e16378cc3e8e8a3d7e71bbf805f2b91c8eaa269a3e5e5d633e05ed88bddb3284e3c01054712b866b18e1c0f11e5c42fe69518f7c1a355c1294717ac881b3a94f0e035608d269880cfa02c5dfca55ecb6f7678f8243a3a9a3041ea43085ff1a9cdec5baab6ac4d6f4aae4caba41dd562f18be69b76dd79ec9c8339c27f489c4e853a2f85194644f47f11f4a6f6125f91733669e94e26789e078eff6cd9eeb2825b694248e387b8c3cb1badf2da39317e68dbb489c8961c9b95bbcd044dc69970f98af97390f612cb6935847d8274064387ddf6bbe5e3ce7c181fcd770dfb878fa188662557e1577746c54330754f7fc1b89432a097290099f18cec8c0e9cecbdef0955ce5492a4a43e4db242ef0ea276f647fbd9176f2c13cbc69ce458562147d3140f2f21d8f7a42223ffe09bf88dd58036169b4b600bff395ca3bc14a446eaee511ce57d07923407ac7eff0897a954f24fdbe3f747a0cefed5455bd9dfd930067e48a1381ecebf680e2c56051492ac6a05e1c28254ac2f53516a964fac6d99abbb32965b4cfb240002c74ad8c03cb55c118155403b1c45462285384f1ac9d446041685ef6808bfe085c2808e16015c686517b88f07e5097e15f85182fc49f254f682cb7b6952512b181a16846ad89b8ddec38ddcb6f85735085ca529613eca9f653210fd53ed3caa83e6c1bc233fb20cd28439530a86cea7293a143c5ca391b48e20c7697549aad52d9338d0559ef474d354ab3285dd925c271556da92dd2fb0706655043c641b5982d9e665343efa6a26ab8f11895215b2c71a5d8084300fdd270d5a55b2be4e788878c6b071c86082ad0fee4e020776ccb2a583015c1fd42919d8613030ba01c12b49a9c4eeea8db07d6f13c3be8e398020c0f429eac6d8c54dcaeefdf6882a56e3a7bc5f4e59a0c502f9db2e3efc37d5cd15125f27a376c3a0de83abd05c7022161821969d59440f14dcd6fbd2d4302530ae0075b0740dc3cd4073cae7b15645e31594c1a26558721bd71630f8d69028018e959c6a80057aec16dbf022e845d12149e7e37923044ed0db99565709d0a3f586be8c9f6b5baca9dad15ffee7e41a7a3256b3fb2834dd9a441b2da12c19f045f1f27f77339dc186f07cd919e2aa6d3ec86c1f15c37bf5974a151e40bc7a6f6158eb69dff01a867374964040c6b80975ea06301c42d73997716ce381624a05f680692d9c68c796ed70501203f2ca2e626af59af9f1da207648ff7fc597aab9d87ea00046ca4bff209b11e46767a2eb52a0d84d0d66bf1db149e7a7afe04ca88b9bd4ea7e6f625c1de910f6a5f344db6e748f664f9fa99828b83cd01c37f3bfa34bdd7d29b4d174ba788ff084d1a031d1bdba2c5891167b356a24fc89a7e3d043e721f292295cf1cc050300122117c13bc42c9c17c53e345104b7fe28b47072e1bb7fd7933d108e96c2c77dea9030034e6a5acd9194ff199e70d6ea57345f6e60757ba4f507029963a07672de4a812025dcd538f4a12c5dbb4ad67dd6df8ce4181d6c1d6e1a4be6313dfa2b2f520217201a296d8ff858b973097cd11567a5af8816417b21c21189ee135e743847a38244613239754f60a295c93a067333221f9ba83e8f3a67a4bbd33e50ac0a99487837b9467021a7dc398ea0e4641bc3faf5fb298ac561067746f629767dd04a5a70ad7ab491681aa761ddd3baed4536dd7c49f11150697cfc32ba8862d8771cace2bd14a3648efdca1a13efcee6896cd59aa51361a2c5d97995bf20db8cc842a3c3e5b36d20c9476c52ebeb30a61a998900235cdabd56e8946e672f286369bb698b550b6510ba4b681aaae735f9e552f63bb6b77f01d4e7d178a5596b97bf5e3ecb55cb4e929a61cb60378d41c585871357441778147864df608870be1a8e967edd9dc0165c256c676544c6d2039f9e1e71692af17912018539d51a2b508d1850200f2e01b8ca1ffbdb6303e66f36015641b1fcfba03976aaa5c41b6a54fffb541ff1d06f1c87b1565424450bb07c8d3ecbcd574064b617bc77d2fb3ee0c07bd30b4fd194f947e9c75e0b5a98cc0d3cf175bcd31d4c8f97670c767aba01807f1b51c2340beb548c118792b61bb8cb90a947334a61744267435c60c8a600f4f10aeef295c156c282bd38cd46a42079cbdc5c1d490ca8d26c38965fba090ed199cf8d6d3073e8fca6e586ecd4ed854d374f8b40815b11f0081c0206d625b81799b3943ae319a30c1cabfee59202c1398a3c99cdb64fe26d964f2a8ba7819f40b9a43162363e040a909096b50a4e1082810c89130dce06f86c1cb55f016a7a004d2caa9e54275093013168a95d6a0d7ff9d1f84ad93a5688eeb1c5d561d110c9096a8548dfdd8527957f530808da663e66553f3f8dbbffd5a23d7b49faf5b13d79244d43629733e996ea618765579bbdb5d2b98475da14bfc446271a5f90ebbb355e295513892e9500877f5a2dba6fa6e42537f95ca0fb8b942823b5453e4538f050905aeb17a75efc986cfd59fa3f2e536b9672f1a72ba2eeacb0ad0a042647d54f706768267d2b275ba6d7e1d99a20fc82bb740a891080f325d3a72a158ee1571390f9a6f85df81c21daa2df656515e63bad1908af69718ec0a462ec9ed1edc5ed7004ec89049fd6bb84a96f19c5ddbe605bd78beb7d64574a1ed13993853b4b41b9e65e550883b593f284197026006c0e516d5a3c6920168d4fa43b4544dce08928cd797b1e43d83f9a98004728a119ff5e6cc982241ea2b01077783ebc9f45a6c3a08e0c0a5ea25c3a1827591b31a59a64cffed1cd9c5a0753b03a007cbea5a9b7ce05004e2236686446f317634f9be15fe26174f11d338a5144682e0829e33ff7b04c18163c0cdaa4683a6a0d1006a9fa0598d01194de34535f544274f9e0aa6819beaba9a1f8f89954d76ed7f8bf832ba47e293baf71990a06df01f74df9e135cb15309490f16c1a7b41bb40fbe118ba9dbc53c9344accf916f234cfb8625862edf8bc2d10593879e937e7678e3b2f934924429a2cf5078efde10cc3fcf7f8d7368b1860dc664e281ed78ea43fe748615ed63b8f90585ffabc2041d548160f6a99c2a96e7253235b5313a0f1e0f7ea56263856c0a90a584447933fe733ecb465e1da7ba4c5fa85a0a5b8b2c6836d2f2350bba0ce9919e2580a1a91921c03c2e621b339cde65c89a3dd5b43d7494a06a8dcf0eb9ec6627c91161bbe7cc70bb56e8b8e8abb6eb059773d03a94b7ba9bd162895081226eb2a0fa551d7b75126d609e729288dbe9e8bdf0ef4261b2fec38857d31dbeb8828b18f1a1b92b5b9da66dc0cc58331b30c1932531493f9da077a248136c66da1610ed9f8caddbd9237c1fd028a2e417e6a6338c6b586b22c258e37dcaadfb10d75b138a72767c9a07fdde5872987cea384e860721afadbd17deb74ae2fa53a2e536a049e129a52629300d81b9dda1dec66f1f1805ab3c12c0272293dd5409f0cb77e9cd74490b6356b6cf1691d9795ead2f1a5b5be1e617c0b8221b82fbd7e3eb4f2fd409dd0be258895f2fbff282521781a0d95567a035b70811cd1ec894fcb53045f9546d2abcb59da60adc5a056e8a466066bb057952a9497fb45ba6b108bc35005bdd050d79b3ea8ec83ecbd5812aab12a1dba0ff84fce98354309e0eb5100f40c146494032dab8980d06e04ade638d05565d513adfa4f78fb476828bbde8bd9172cd780d87b3faf678e61e18415c9317b3d7198e988b3451292e85d66ee28b5f2324b9055863be05445fd39c1c04653c1055b6cfdf2ada460972ecca1ec8b8aec74558199c67336c6d4cbef1fe5cfc7ec9b703acd4ff091e656d8ef60769943646e71c199400697384496bc9b13ab0cf5534a67cdb99110c6eb6d55c65cab8dd0d02ad2cc9219fd810b5fa50bade2d4c98e5848e4d9abe5e213b864a0925da866180348686336b1198c4fac3c068d7af98fbea64557e7d6996ec3bbfe6288f4cad0433860ccaf146d6113623d29266921ea8625b9f3f9e4a8f4515849cdbc6dd085a9936af08a471b0d94a9bc2942fa80817e2baf6e88852aee269e85f5447a65ab4ea3297879ca60e3071c111b1256882667b3d827b9147ef43a4261f1cda00032c2655b6d6fa4b18dcb3fedced6fbca245fe6a260ff0bbc55d2a32e866f66ebb8383a5e89b0b216b5781ff1922a7fdbe000546056ad783866a8a7275a1a0c7a1466da385045d1dc52fe9677131fa078f25b61d18e2adce2326da0d06143d453536318a1b3fdf5ffb6bb896cf1558a095c4813bae368b4f300eb80d54c78c290156fa11e5444e2e6989b85a8c95183718fc8907d0a85e01b9226cc4797d4825937cb9691b7890493f4f272258482609ed36dfaaef52e9fa414cfb69b8a91bf41c0da21c15511a0c094e558be2f12be40ec9b4421cf33a5bcd45e5a178df3d3c0a472d4036dd06773de15e24a29e87db93864a393457b1631495cd16ec26dacb35edb15dd38ecb5227a95adef6687ef4ac8e6938b50d42d1b13f33925787d782dda089bb75a4eaf8c88917f61ec00be4b84425cfddd4e54292a2256483ad2bd02e72b289648f32a87c4a868d0406dc42e6ae885ecb6aed250763e80c810a9e2adb17d0db7160a539ac666d6f3f4bdd88203c34316b3af9660c7a9020d68ceddf270d85b397eaeafa5bf1c53951cda355053c8c06e7497a42fcf37cc1595b635811382456206896c240a22c6330fc523d8643d01c69adf265b73e47c65a5a807da667ee1f787ff4b77f9a8d0fa4f3c75e63f2b2e3ddca945a044e87956cc1629f5af2bb3aa1eaee628c99484a2975de0a4f24338fe688f54ea22b8ecf70d6cb7c914dbbe303b2b4f7854f502833d89f87bb85281468d01e98e854ecc0905376dc1b44c93ca168a2963d6382a35645f51adb166cfb904e97a611755025fd80f6b8b5572676e96b061b2a685a76e8f3398cbd8d16e2361e8eca8f4c4040357acee6b950621d1fbe1fef1fd17c8a7940623fe5253d9c6302a9d3c2bb4ca8ee7c21184ea9344fb756258848a7acccb69b43836521455ea1f631cab187782eadc26001fb36374935eca38ba56fc2b4dd8c1c76d22fa1be29f256c53c8fc9593c39e01d8ec802eef6f4e85b128d8339055fe05ad806647782c238fcc5e8c80a7953400cad352a7ff2cdddcd834c8a11a9934a9c7e6c3ca823b85d373120c34b1c7f7dc98e44cbac201db61ad4eb54f3a0f493c5cefd89c311365e682ad07725b85610f16a82c46c7c0b94ec6be9288144a2ce83a47898eddce7af483bb47413cb39c742c1aa9dd061c2dcfa38ab82bdd0b86ca0fd276338e880800a7ce5060a3f7ec784843eef0a798729c9212e40062966fb9d9a3fdf6e6fbd471df0106cf569a31efd458ecf614b83fa6a66c25754d460d31acc260d0331aee866dde2b1d21e979c64df8819439cd8740c1bb2cc71f282580d3cb44f5462b82953446669c63136bd68d487cf95bbf9ae485d5a0d542bb5800c35df93ac95a729b1bf518c566deec74c1cb76a80fddd6a67548a705acdda6136662e3dfc6d62238bb698b435cc289c3362a23fd5573d78a2a40a8a57667b7e9a9cac5ef587de049a19b2a7656b8899faa1758df1a648dac3751f63b8721a6ff793d181fb6860287f3c6271b8b3120edb3f70a884ec6869bd593305ad33f7a071b03a4b516f2c4022a6438f738f45719ce8e7de8cab5e1fa5111e9c60a9c0c0cf8e8e63852fb0296966932676932eb70bd47d2c8e8312da60d109f410cf296059aadb3e86017edc476919f1f2c69fc5176367f594e4fa62d8f138e623a7c825ba553aac7d9742f811b13f75205c4e35c8eeacdd50ebe8cdde132c7621e888482b36a85c1cd94d3429a853f80d160d38b9a61e9856914a573b52e01308d56b05e7057fe56dfb533c68b35f29a8c86030a075ee8804f5a1a778356a525ea2ff88588d9ed58b00ef7567fa31987ff7a381b6d21c4b55f42131c0ad98f8b8196dfbe612e017517fcf18455b7680a939a65e7b5011d8aef61c444a34c84526a6465ea3b7869e0fc5897f51c6626586a6f759729c61b8aa69603b93ca3661850fbe29e9008c104e5fb940ede7e6d9672ff1c200e4fe9cd164f072800494c0693f9eeb617802176695475fa7caf9c185c1e55d9f725d4c5bcf4bff1c0f5e348df67cb7d911377bd7fd98974ccec28a3ebd1c11f182c60728264a397739ebaf2d5b794c2c305369ae2f81030ff8294c5ddd3054312f867e14d723b77aae0b3326aace4cb82587c529ff401093a8974ad00c4bef5ebae385b13138b46de59d52238ff0a28acabe0937ed3c8f160d17e51f48897c47496423a94ddfd23f8f941c529707095081abcda3fa5899ca709a509ffed0aad0a1451ad08a13b1f57104ad3aeb06272971facd2767a95b2ca46d2a6fe2843aeb8bb086e630df12901e9ac93fd891cc03c2b97e018ff4a0b04197935350edae6051cc3bb89d9602c132a8b207345490bb429983980a81f59a43935d9760b9d83252d0404166b32f0486388f71c604123dd705408a195782a5560e4a359243031924a16647edaaba89f4132664c365a9087ce5a764502b96f889918b27dda9d3bae8680adc88236187617267ed7da47e12ad27d2956987f17c2ca77ad20904095ea5cfcc9932b3bc47dbee79254c7eb718b56ec45ca8a1c74f26db664718e66a6c5a07654deadfaeed22a6f64fe153f3adc04e0eff871194d1f40ece16ee2140e9c6938f2eb662e9cc982a6101237ad2a68a9864cd6b23c005a843f670acfa0a53763de7409bef6ad5d37180b66ff94ad6a4c4ecc62c6647968f19553af3ef40e4f120f71d2e84ffa7003e7cfc7abfb65c0dc66a798deddccaef8615c18395ebcc20696dad70b5db45148f969445e4e8a1103a988cf995252fe218e8636cdf8359379fcb7ffa199985ed6468fed597349343d0753cbfcce77ab02bf081598615e6780c3b56dca73207a3f140800da7d280d89fe08af2fc5259f2982e777001a7836dbc5456f87904af79aa8eb8bfdfffba0098c4ee72f711c7c14a4b7016fc52e1cd80560c1ead6ae3eb403ff8fdd1818ae63ed89b85105c9b1ca3f994cd4b33e60ade70e83385812f92375f24bf548622bfafe9c38255251cae993e6dc3d568d44ed2e1419cd46e69624c03fd2e2c3492e2ea8c173bb94d622f9b9b968390e73d73647666a1436cf50440b1f497e7f102fc02a4be3f1022563d330b1c52d0988f367e6370d6097d2dfb61e7c200917c362c30969cb42b80c439d5b238165649d87b3e72b0531d64971df843fb08e612869f4f7c028974ad3f37a067e2d685fcbf7ec902842385f15a52c598ce3e68c66f0e5dc97706c86dbd9ecde0fb6a83424238b13bfdeaf377933544b21539865e78802697716051d67350fc1268c302f647d27da70659c55f6d758fdfb7879ad0f9ddfb14a642fbf5a45a37890c45b94622137366f9b323d8e96e4f33896c752ad4ef86c0cee57d6dd9116d9c9dd63e5d7ebd0324ab925a026128b80ab88534c1d93254040746263c90812e0d9fc4aa4fccca79855ec752e66cb440a515b93936853af97f2b676f0aa6379415ea65e1bf342d35c1008edde952eff348d98b290fa07f7830d1072e4ce40dc851fbc3dfa1dd27c0245d062911cf3b88108c212a58e05f9dcd685a5cde4d8c7b354842e21d36b4e40fc3289929d4e8442099986f9d0bf6f0fa6c38e4dd41f8665200e6ca267e300b58cdeab3c1684750e4c68bd881dc1c7a3354526112dc0a20b3721b20e68c483cb3c96c110b56dc49aa33367bd4f13b8ae7b4423f3faafe016e644dbabac5a75780a677745a3eefeee4059136f1f25cda70567f0c56c2b80549972a760fb2e6505b8158381fb98d22d27b43bc3f2c0fd2b9f2fa528e9840aab78991de696959d3e29b6c7dce337774513dff3c586f910dc5b0198bef2fa4b6a767bc1a8f18883e30f7fd390fd216bd56ac2a1d8bbd7a39166861c7be4a78f019a5bf71f47f5e20930fd6927498e7a34d10d8929294d2e03e71d5a53ff7274662087a2cd52350330b2d131a19b45f9d4f2fd3550b0bbe4c8b9ad36bfb3ed81656fb09b52dd383db2f56816992074c2f8f5a2d7f9b2d58dededdaa924a75be8f777233ea8b235ad6305064653555db21a1733bd945f0069dd3e669fcc467640de2e26789379143dbcb9ad217fe1cda496d65052b324d36d6775d76e84588259479c30869438de2bf2581d4666fb7108d415b09e59b1ec1bc9ba21f19deee07a9ce220819cbe8ed7451749a83812c5f428c9b1726a4b579d015a39304c693387fb0330ec2e4b6e78549152ba282eb15d597192ef48307244cabe893e58ec4ed76e3a8cd57e4032b81ce0418722c5b807f089dd869bac571b9816d6fe5f57899887fa8c36120cb877cf49fd805cc40e38c33f23d49bf987d5f429bd8f2eedf7687df8ac5272a78745ac261db832dbf6ae12cdbe0a6dcec9d9aaffad29872d0579ceda9e70515d1eeb18e4788ffe883a47a39e372eedad7d2667f94127e653699736b9fa3b32d3c89f0056fa70ef56e2fcc9c90385448f55b28151275aa1140739536c4a090dd6b2f1e435cdff0fa8b0df1b66872a9f35ea2fed275c0e7b24b5ee9111977b84acf69457942d0f2b5851f366f2a241f748d01d0147f918f46b9a1fb0221a80429974dfb13e39c0875c4e0fbfcf41f796573e6693dc12871586ae98063ba8bae5b5f6e1e240723a8a06a68fb7cc242c3f5e051aff70d6899a363f3a3178fcfd7bff5f75b2c301c7e9e6897d69d86f6d1ca8b9c61b586c10091bb2b283b3c6ef8db875192fbc68cd90b78261429d2dfe98cce52f0c8cd6b4b43a99ea68589ba5cb47d712986bafd5c9b66dfb1d5a9a8b0ddc09d6d8b1db5fe953746956c5ea1b62a632a7cc19ded8d6130bd2791a23f53cfa2c0783f8f88899f259e8517735b455bdb87aa46f651a2c76dbf4030a0ed0412260645902d4923689dec031fb9635f8f82d2439060c2b69f07de5def6e69311e05cb2479ed47503cbb3a866e0a777e44cf77cc7e10caafbf6d02e51d28f78e48e8338f4865f7a6878a30ea29243db870f90cf655affc4014a6e2329010f7ae439cb17baf087a3d2f97f5e6e3ef30bcb088775ea49cecba4f01b48104d1c68a773d2cb8b419b29a59a9bd12420e39feab46096362ab29e5145945a5f5e3d61d79c5e0ba2f52051f773d24f5f34e1540199543b6c92afd42b98632524e162d34fda0b9bda802ce24dffadea08efe0357d53d5956b2e9f0d1525bfbcbe7ecf3a25dcde6875eb2ab7552c8ffa988060770d6546e52bc18e8f5c14cd3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
