<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a89b0c30196c2275019a2ed64565ec4102d973906ce0fdee83d4672cd726b8944107f0be641591ad7748598403ae017f3c6ced03f2ceb1dbdf114413569f3d39e5846bc5472f072df0344b0fa01b1ff439a5d1b296998e6858e72d95d09b96f2a4de70fe958d3fd926847d724685564c70a773a612054e74fce6770916bcf48260acf93390efece6c2e3e8730e2922106d42818736f8ff24212f29e1c565d5bfddbfe88ce5690567814628d9f28966cac0449b491fd46ec47b820e72428851ecc5499ac8d65cf04ad1bc3eae7121364a449a349183cb12a306b611a6213e2bc91d0fe8a460307fa9562c05197644fa35cbf147d297f03403bbe7bfa0ccab10bb442167c8dd823d15d7dbd845094f132daf88928a436caafcbfd28465feeabae72c2f973062373c75dc84aea402179e05138149c608b1006a67105887ce4286dd42619c60fbde03077247e4899010d8d92c9557542a537697758e86ab6c5f042c0a326776789e3b556aacf240dcfeaa527d2297a7986af8276513579fb27dd56242b42a670474dd7688757e285ae0943b397bdd4bae248fbbb3c6725752c9326b99988eb2d5c36712c932295079173810b39c39c822d6bfd78ea52db322ee9720ae37f53a7f65d27dccd718b07ac68b9f30c917ddcf1c3e34a67d70bb5482a7f91b29e7e0e85a46cd55e192174797667e47ee7a5e2fdd65b5f2c4bee37d047c7f1c46c1eaee2dcec0efaa95b958da19183ba74e89d8e843f5287508352274fba6f8380d914c4582b4278da16aa7eadfda5055e725d6c99fba67a8bb1e291794e85bbf61bfce81110c5019b7ebd5371ff947a14e190a070f7918ab77aebd74d94d742d04212caf05dba6c90cb11fe5728e38181dabeea46872f58f8bfe3f250ccf62e5ba177f5daba16b9f51e2946a22db4b61b2cc14f251bd5f53d2b15c7ce098551b4971e687eb3a3419f21da905e0a7ec134b3abd7ef8a5abd678e945e7e025ef52fd193cd843ff48e3fe9649810498e8d2cf63ed77558715df3f1e08b65ff215c214ef3a3df6d3026af5f22e6f4f77ca07ff00716a5670bc3f87c72dd4e61f8fa069da8be64d5ad0a7cf279d5af7ed5bf43d2f05116865b3ca25dae92f7994cec0905302c5bd0f40a10aecd9d36964b85b080db459462b86429d595a6988d9fa13662115eb60283dd9c940314287f320ead6a8d7a70b3f47355fe2d4c9ad54e6d16d425452d4a2897bb24a117ca3946ca762c3e12726dbdaba3ff263676c30010fa1bce7af834da2f811ce305dfbb5062253bb17f7d56191e25b7d94c36c6fcef9744935136d56eab405a4b87ce3348d640b889167df9bbfd62d4c69429b2867c717370eb8ea1aef12e1534452fcee2b0ef51b835ab283fce214c035db3a844d9eb757fd9158c4a1aec457c5b594fc8b473353ae80f7d65c8191856f00c71184d3bf180732f9b9f9d38dd44b56319515d9077b7e0cf414915e63026df7a1857762c02f276df7ecacd735dd1b6d8a9b25695ef21bbcc2b89575b709e3de9a2040b995f66d5a2d17ce4a5ea87cd4bbb1091236d6169304516604ea199a6209ff274af76fc23f2d878a7b7dc5094c37010f10917db8b265b6453ebc20f0a4488f2f28dfd86f2d2b6836d0af49b72d21b14a9818b9a0c1d7251747d643c414ca436f2a87437236aabeb7512eb29017ffa4bdc8e5393ac3cc28244831fe2fa4be92027f5f42e502fd7f15eadae3ec82b3bcc2d7535b7e6752f7d3773bccd3278a31d7aa449b26af50015f41e8f512459fca326aab92da1d568a0475764eec95cfa0af6b85e8d609f0acefc5b0f3c2215dd95dcba64c43febe60895090204147aa9ee36771a3e0bc95ad2b222ad3677ca9346a6be104ae41d674034278f48476599e35a500ddba4b563e241c12ef3aa66543d5046b226acbedf23c6e91993d45a148d9e9989d262e46027c8b756141d0cdf7d651209e705566fb1bf80d61bf14ad55c39d7242678e0844afa136d1fd14be7ed7dd851e8155000e75f0f716e55d42ec448ad69f9d0878596039f0323c837d19ed53ce99e813e9825cb5c362b71df805d4ce908537e52359ae7ae4e6a556484305a808c0d7eef32b98194d388ade82c8ed8e8aab40c307a9b10657d4a7e0158188b506709cc3d1406acb4d380d00f0792f27564bcf9301dce2a2263a0efcda8bbe9bec83047905f53dd85351e7bb0a8234c3da7e61b72f5af16423cf362cf8b1546b5619bca5545a67e14fcc117e60ada157b103fa5c5e7cea771f309925c0c5d791278ca1778943e2b7248da27238a590e275496a2bba1b0ae4ac29f7a02356938658aee8f00aa3062df0937e0e73a315946fbb5e422453c712e83d557a1cbcda1fefd9080d4fcf56fd03cb132567145030313c7ad05f903775aa7114f31c415b1430c84f59450388d0500cf3b0544eb4a209e7758080183be692cc0c7eba1f9466265904b2654a16b95de63af61175c19a73b0859fa9d10c7f289869d6b2459d27472d1cdc636b6c449009e5ce573888d81ff3318e563fb4453441dd3e9bf449cd399fffa6f0199501862c85c436adfbf1db5d4320774437feb413b4165a019d1ba243209c35601a7c321975b2b0ad3ba892a034fb64d0e78489cdbba0fa796879dd5f94369702d7c5707ae40c6059aea4e06a9d4fad6bcc3d28768acf49a8081a29389f20de4152ba3b5040d54a6686f6b5365cba29c1987e08b67ad65f49fa1673a597c996ecfbe9fe3fef187a9c1e3c2e42ede64c459bd539bca0ffc8cee26850549baf34381b551942d99c37005230fb59a0dfd92bc1c5945e16efa7f3ab88879088342d4de7e0f47a7c561e3cbd6694eed63ed23971a26e5b29c465425048c4c3b261e8c3e39defbec029b47d42e7db54de3974049efe5bbb9c9119f43c0a7b9045560e61bd924eff597d93e4a8e6a4dd10160a2706e07dce5cc547cb29f30a533d7a6b16115e36a7457017d614c14b9be71db15fa0efda237fa9ad80fcae26f34166d95e2594adb94303f692b296391f50cd53ffa6bb6f74734d3a168e369746ef1c37316ceb0b0f21b929e32d234a1250b9dc49862fbee5fbb960664db344847d6b2909c6d2d96a237c950d48fd8baa2410c4236bb951bfdbafbe4e1f220a4a39739e750421c93e949b74938324da3700716c44c53fcc4878b0987c25d42b44ea6683fc926a140ceddce7392da3233c2c199c1e48e947534b6d58c4856074747110045348e7c1ab949873cadf2e88195fac2060549f0752f185504df9e22591d787835f358c3337a665e7574462b188f780c540c3afdf7f4b1280bca4052b4b2700adea697385c1c1232e892e95579cd5361cb3e409f10a4917799c6e75018bac480afe5975beba0325c869afad72f4838852ab4f61ef6cc272de9512886fed06b81360f86c601db3f95e2215feae1f80897f10b45cb27f528d25706324041c72819a0fccb0832974dec4216fa1ba065b1e9083ca88730928782f4dcbd72d5257755cfcb12c482bfb153756015c62b37539c1f5981583b37cf24c8b38bf6ecd77ec71a5ecae93f87e0c72114063459d7e3db831e8d4264c50d11d6f36ebe2d4cf7a97ddc278fe0ede8b1c6d40a9a716818ba5230472be528e60e3c3d23f5d4676ad01ae9eb2bf3855e56dbcc06dee564f8d44b48acf23cf0034f0592f0f4bafbc10cd05495e90eb1ea7915622804a1c29311555a22ab42ef251f0ac95b6cab968e5dc3f99eb6b66c5172191af8adb5909ec2300c00ff85297c0fbb86e50aab587db1300f887c2121685a0c17dffb006a6c582f676b34dd9605e7c0722db08b8d8e843f9688bd74060f16c77183f327e6f3a8e92bdda254d6410108dfd6d815280584ccb392b306a530ce5f7b36349dd827e81c892e3d4b2baffa6ba8f1992d1c1b1485d786cd99dd72318865806cb1ff2af2a62f63cbf6679e40e5bd34def11f507ecd8615647db0b9d5ad5e028df54ee3ff93edafae8e7504cf348fab58f428aa31f56ad89a5e534a45942785ae3ca4e0b2418ae0e8ba10f42d67f079d58364079e9c08187626e3a20821549079f11e0ea1b36b7859c963bd6fae93d2c8c7b5cc34e62c4bd1098a3da3eff8052201c3150cebfb9dda2c554bcb4090ab995b444965835fd975e0b28d67e9f4fe3e4a157de07c71cf79a327e837288e1535fef8d28778595e96d0e64899f43b8415d6e1bcf918ab9f237288ff43172f31205230554a4a9eb914668026d34ef6eda4e8d5f2395f16c78ff68135f047613134a09c3d2ad313d129e6784f8e35c35b90ee64d0178887f81ddb6ddec8314156ddd9adc8e9cb1e8f6c74953a0ef357acb1a8f8718b1d4fdc562ce3efc2cba4dbe95631f38221bd8453954789ab36c1762c42080fc3b8a5d8538bca9b4a9af55a6647826069036ef0e72538e5424ffda40d19068fc6df872c48fdb320b38fb8ddfa34567127bbfae83d9a33ed3e39b04e70f472d3582d66c440bb9372a3c4cd2e4f1be5911b8dde94578a440256075d1ca89a93e4c376bb6b24e81c29f9f4ec39ef3be02fe3fb24b7e8c8e73abccf32e8e86f7fe2cc2f94595d444f510df40c0f5d5296d60be4a245dc97dcac10a42cdd085894296bc867af85a2daf2d746aab7de1cc1a72ff17271251d08133755129a8044eed069c9d485d1c4fa0d48ff6101194ae3f3c6ef170372f2efe7c7c0e03046a83f8957adf43bec0111e8de379c51f870d669fb4bf3efb170f0ab4bcbc6694dce37148db447815975f4e4ddddb59353783e15f5175a34da1528821b349d66cc963596d5923270d1d0ab1c0e0e19c54c7748551915f2b7eca565db97e21e9c1948e7f2222ece01094eb662ccc8f7c46dc98ad08a3ad53d0cb7c0a4192d5e91f98d7408867d3d68fdbc624dd9c4538f216f2f941d9085ea32d0160428b8f873c95f150d973d979d8434bdddc3e175b14e9fd5a47f451c23d3bbc3c335df41ee0722d3de050a92c30bbd0a179669d0d3440bead689f7c5d931435b2bab18f9a2e9d2c657ae1706d0479ef18cc758d4b178c4f187d5158a1c96bc2ddc49eff86c4481c833961b37fe103efc9d59089fcb2518be90de1be8dacde4505c17f933f423ca5f6ff186f6f693fa467f6d67531dc591bfaa1a22d785e0cdd889949e8299f13f4c9662a3f3080f267d9dcc256e5b4cf0f740eb70fdbc1ed380a917cf316f26c2ad7f2fe894a0f4d03255ae231e1aee39a71641e57a3cddf550b5ce52eb7dffe2a339b42217b37fe5e0826da29e16dfa475ade80384ba9d3ad8ea48ccf03456449c55f5c0fcd14a346d07035dc80d69b841ca5b625232e1471f9c4d57c1a15d0e8619033ee0037e5aa8441f6f23ac55b43303728f675a92f6d91c6a8f0c1fe43dfa1fbf6d45c08cf436c698ac061f1f21b9c59544d328390d2bbca02843bc820d05504ab4ee4d3d21c3827c6bf122a981b155c2aafe08e9824b42be7a7f395087792407e1c1f08c7acefed87d6fee5e400e6139e8cfac60b80abb758a282e9d308d4ceeb956e5bf769286466a5b6f21ae45a5462370745c6d4aca617ab8cc5cf7a0e63ab95e5d4616db2c05f01030e456ffea612e9ff605117c5fd3319ea3cd3e9021a8e7d191070a17d019e893590ebbe43f355bccab53bf418360aeb86dd5bfaad12a15c61975a4d50a49b41fe6cea87218ecf5c2e9cd5abf327b2033215af35377c1d4f7962c3db14a7508b54115cc4e3d143e57f681c63068de5192bc66944f0fb31791b2c7033cf44e1c4db502e6dc5f409ecc35de665b03bbc6d0cedf1373497a2de4d6358619399f7a23d36341386a97606eb0e0daa876b1752c6141d3d2be3a1f259c9cadc8893e87b0127d66ee6f3e3a9ad975bc4aab32139560254d6c38ca717963784c075e3c1b32f6fb581729439662bdcef8f36da4b6efd86ee7ee871746b9a291b14cc19b356235f3f6930db672f6d9af7b145f703a26951d9eb9c24685d3c378f7258470f99c1dc404b87a1fe484e61eed6f800de1a6e841c0950785d72664cd9db7c5ab0a62451c51abe4fd0d7d2c258d4d5d3c7ad841fa10c5ab15ca2d530739bb024e4f9a10d143694b4d48e40debfe194a1e8d31802d495b533ab9240eac51e2d2a289d0a9bc8e4f8e47489c258eba2d6e6b76fd2eee6c3c80c891c8ba8b41f138d00a8c6fe89e763ead91187317bb364a13cacdd7bfb0890ac76ab2e29835b66ecac214e50f5580cc5072c05399da375724426a54bd8d2ddb335a5d9f478865b80670169a9fc2a9e7496db89ec9098e976fe86391c6ef1e422ec7dc90a799089a43773a9fa6e5b5fe9f42462164e8603a6b82694b165e4f23519ca418c5b574f65ddfae454847b8f59a5530b38ed0cec0ab13d8f837ee6511c166ca25b83d49ffddd058b0c8dd2bb2587b8f55959c82621f457585e7a58faccc86fd0ac8b906387316f608d5f9d85f3f4e93498d60c82d470c2877d2cb6b5eb704ed6e8382efe7e6db86e5da4e6787d3a808ff6c8ae5e6a0cf129111588292ba4038e78354ada6376b92d3360eeda20da1e7142670b0a4cd2a73eddbea434e738a17bb3029fb6008ef495f5cb57cffba5d60ba60f6ea8b43144e9f34e08ea1a9c1b067f0e6351498d1662ef0357d286996cce9b73f40b5437732c21b7d8d6350d91b28c497f6f70ab99a2fa288e0a8494042930136e11c51fc9acc0fd6f41142e96099c2aa7f54af77027f922a69ed45292ed5b4fd121090d60c708ecfeabbc662d6fa05ee092182ca9c241e36b5c6b2800e1aabada888da9a84b27f597d014f8e298744d2caa1cdc23ed0af48b0812e5170b3b41848ae9d34837d88ab4dad40ae8113fb90628342e63a0bd0b06317329a8abda0cd0146580e6815d4a1ad6431eb8261f4f0738e12cd8a9a5d6431691d979e877e05abf9dcc8695e3f3a6d91ef819ba29cbdf1f67d257e829e7b37055e48906bd0a926561285317e789667b23fce45bcfa9f511c7b966f43d0e06e4d7a848a06c2f108c30e809c3045d6366165e90d986600236d017b226df70e103ebff2e43e25001a3e8de57115846299564801c0248bee29528d12d754b76a2d11678306331a2d4dfe0884731a08e21ab1981569370b5a56106443af8e62b2b34ae8e71ed60f4af726fd55ce23e45cb01d73b6d6efa21b90048477380651a6511c7a6ffbc818e2b5fda7a450c7270971631c03540b1256837fbc91a1292bda127044ae5a4a8b1b469b154ec1c5313b0f84e2acb8cf9643129684d9b93d7791f57fbda959ec7bddcc95de81ed1c2ba83b71a7baa04ae9e1b40b92e8d59b3269cfa91e30b16e8a7bba8220e22c763b4da009386d505bff19e1cbbb29f479a1917b29dbfa6aee4ab5b6dfcf44ddf02aac6ab3aef8dfa889e89056e2315a8ceea7595b2b8b79bc1ef5aac8f9d1ba643a15f3bb8ab7c2b845a1dc3a2d0ea8cd3cc3cd530376352f829f9d3bb16e38f79d4d63ce9c58835bf0acc143941fe39474b5ea93c72adde692798af1bfd28a1f9cd6821350eb9c04d8fb60cfa23749bae24c5dc21143bc40549041d4cea2d3e10fa2f266dbcad070f491c5bdbe724ac80fb6035f96775f2f17367f48dfeb64d80b9dc9d57dfc1bd3c541ae208cb21260fe15bf76a8ec977a4c2ba0d5d02b37aca2d619d000b3c0f4f69ce308ec2a7f76714ef9eba3011d5eb8f7c49e4377a5e62aeff31a940dac46bb26e51b7a43145973f75f06c3f5f929f325bbf3ddbb5221d7faab81c83088d9be72bc6a578c2ee546d5345d17d56d62525c3b4e517b73b496ea3fadfb211adc440c511dfc1b5c1606596c52eb7418e1474715924b56f725acff20c0aa77e4c7c9d8fb4863774cbc0ded4c635766ea1a8435ff3be739afa1706cf940375c0811a985d217a501b9de2d3c807e1f2cc7fc6e102025bf287f80ade3a4702563c59144049e2e643fd5800af1a11ad9418bb2187493f8ba41f437c91f28b236d40ea12488815b1415d725770e88ef64008a36e6fd40b4bdcf336d7b11c162ed79b8178b2afaa6b50bfcd5e476ecb236c9132852a7d3d83867c05d2ecb39e551b99486e39824859344a223dfeb668876a85e70c3a1e454be5ac3db36135f391dc75950f19b0d7163e8bc26871ce8a1bd4ed0837ece76b3c6e39b328ad8a2a3963fb0742d6a9116ca8c88f11936b97a6e4607b72e254e717b7937bb1897f58bfb60a4b101c2c87996418df1b294fe880e2fa7ad53808fe854eb76a4dca63655f39c13bb661f1bc0384ef7fbbe7137fea16a673059b9374014dc6800e1c77c8eeadd732967573c7565d32973589cfebc491fecbc45c9fe58c910426367036c9c3e568f463c24ea19d26b54d66c188185646bb8d8a93f438b538750ff120f711f194b88ac1667b220cfec6a8cd44d71bc9e70351b781556d5f39d3e6c789627ec9dbaef1ca5ead338542196454dc2e6c2ab7c00bc7bda5e3c68959795fb161bcc4218ebc6ba0a90dd9759acc2af7a90fd3421d620d5252a72212ba165ad8c6fadd1305c67ba9742b2f29461c437e3017fccf1069985b1811057933a053fb8266bbf36213df1bc725c6206aaf18e3e6a9ae6e223f7c040179f13bdaaffe5c6697e02ebf3b8ce07af8fe21b9853db753a21be9eebf4b275a70dd2fc7816c63dc8f663b22b6c003eecceab481eabb4cdcc23a811635fc10617804a1dad788a09d75929263fba95d71c1aa88ec18543df211e6ff8a4d32ac25d180bb21ed88321f84ca0d84c4d9511f26fdc4d08fd93f8cd734fb73a97bc2d9351db17bfcd4acc4891c1af09a7d5fb6458ac9cb2aaeffdb844f024c51e256fee1541329e1861fa3c48547b50f55f8433b3bde46a09ddc357e2a25a42c17db855be9d055f13364fb685827a5e7d2390d7c8033d25d9bc5766a4b87ad5fd64eb513cd121807142ccc5941a128c8c10bf2331d1cceacf4df0d4673f307890f06673b58f21295b2ab78bb3c502bab5860825aacf3ff96441511dd5f9129288ae4c403ec16873202ebd1ec1c95c0e0f8db18b19ba1f26b89a002c6b9acc15d150509beb274c060edd4cf4a0109db91121bf31400478546ece4166ecff2333bb6a1382949f3d8f0e0d52b1672bc59dd64ab5e70eeb35e12bdc20b6207d4d951677863731d4d79002e0b8d1c986a2ef51b59909092431d7852cbce366de4371e3d77af059eb894c8705c498030c1406988e6f4cba5171de256a1e6948f67030175c50046099f7d38f821f31a01aef351f2b9918b8467a53dad264bca94d09478189e64388d2166fe68c2828d3ec7f01ec70259b3d8fa37859930a183a9e97e1df73ab0c559ac196b9ff851bb7ef877728129ae141c4d39cd2c11db128a67e2a45d02477d47902f2f7a3d40faf9422e5ec05a39e08714c7f385022dd0bb62ee2d5533517df99a8176426cd2949e84715aea3030e18324a65a4ab82fc7cb605309f7160109f50c30395acd25dcbeb63b97de42405a14adaafa9c2cb406f6d8e298590832a134b7d968949984f2c652fe1c8e399450eb45d4f0b5a8c63972bb8cfc33d17bccee37d9f9931f5a8b355c60d0042fa594d9f8c3182961928a2413ba1e2db98d34808f80876055d210674401bc8930c794e638f8626eb4698ba66518017b388c790dd3e7fd05a5f1fb7d6862771fc08ad01cc3629f370a477209989bdb74a232d672c667b88c1e7e549ca61708250f78b4f3a5295bf05dd16729df552b215eb58fa9b105c47cb59a8eaafacc8187d7239d73a14dd596c0b115373643eb1050ec3fdd18803ecc1bbd302016bedb2ed6872e867419e080c6128b9b07fb2d7c5b0703452197350352bd32e394f2ddb910b3b3c330b73bcebc3e149450d84afb9c8c8a25054ab24d1ef3fc1033ef77abbbf4fb39ec59937c856034dc6e1cd52a3322fbc0717957788795b43cf73ca5f663482955803fb226c0446bfaf2628ee06107dc63b3c67b661aee36ce0d504a4331be6413b1a4507f7b3ab51662c6a6406742c47230da100978cacb02de4c2344e5fe63bdab261093af984baf3301b3a34d5043c498785225a23bddf7cf9d110f4d62c42d348414ef7fb9c750c1581dd1daf2f59c12da504c4be175658318f281cb19ae047552270f928f96bcc6a865d439e91bd0f13f8a7097d01e82441e7d54051f6cfb6e6db46ba941fcc10f3cb0e9d99d9a5c71a25fc35e940fe601f97c212ee6ce088b8d78c4edf2b7a46465a696f3a08f8813674feaa8eaa68748338f9b907447ba43ba6b42397892f414944bd3e0f57a17641dbf5dc54483ee6cfe4e6110f87595e0d912f442e9545d3200465473cabd6c0c2407f2d7f23479b160019e22e8da25b4ef78cd9271b52ac17e2282f4d0c2a74bce53062b3b956633b9c9cdd01ef55059a37bd5d057e44a96852dda4c56a141146b935c7bbf268fee4c1b936b9df8fc29c0320de4e297433e0dd819c7206fb07db7f5026d6a63e40848d7f84775f6303197bcc97c0298ed1a19e2eabf84aee540ad279a84d3b5783c7a103b921067835f1747ceaea5e9aa04346723ba56b1be9607760bf1ba86e0489112266e24b8828d57ced12a77ab4547d1b560acaf1fb85993fded74cf69ee14eee3a07a4e1f35426e2e6ad67da468bf07fb9e950a2ec11ec58cf728c54dc074202255d9e1f68a025b7a2655489d8e1f102f1139309dd31d14d941d1547cf303fba5aa89d25135573ddd7a0182328e2e99eab1589f32bbca69db2d9c7ab43948139dd1afb672997880175fe08dba50f8d4b38621b1a94559ceee09cdf0b5b50cf62ef0ab1ec54d6fd5ac25462596835dd8a3df6cf2a3df90117f4be82899d6e76416093071d46762472c98dfd8bcb65ad1459ed1ca042bab3e46e19a61e1eb12c7d3a8607ce4eacc4bc7cd6c806b82ed7dbf05dd07aa195b8a55ef807b61b8afe32509086773a73d8d65261bd542889256b6c9f8ce728423615c70d0ff4a9254ea88cf6e9ca2d3556e228d9c945429cfd914d3cfd4b3651ad620ad1864e39d2f0148336a8d8968c1397706eca97458dffc8abf6ceac69b2d8a9bde86f083160edc0b35a05abe2c260aa7ea3cd1ea69fa9cec1b265fb001704fd6190e405cfc63da36b19f3c5bca04c157d9ec16846bcea6d28907f0af140be8a7727b0d556914086592bfe1a59858ee1dd1fb3776e332773824372245fa523bb25d44e52e8a07fee56ce6970cb6a97235177b67c929da8f92bd428db3abee7f9e42652be9e1d233497cdd89de452cb478c8cb85345d9acc040ede97ddf224055f6a7155626ab91405c921fe8d82dd1de3176c7eb662bdfba0f6ad9bfc841865928017fec0222c9c26b67f14952f7d680d6c221077b05b37368a9d21105526997bf25ea73010f4b0cd6f2fbf148c8ac20827fa91b71d484c9a46b0542ab1e77fb33f22159abe1a77304601a48338f2b5f6bfc8c275f12808358d64c3115dd5b5f5c6489db5c8768365a4c961f6c9afe93abb76c56aa215c51c4817d23c76db860c2fb5e1aa4db1805a48ffe422cb76b010fb75e2476ebdf0aab5b8b731d68e878262d68507f1d8d52f4ac1a6ce4036b44e721353194abf52acea3948609c97f21d63d046530e6243556f050f441416a7ec63aa202a101adc52279838a4b44f4f16168b4607429029eef630e047345b4ab4bef6195bbdca171b2f6e6700b094663582bf8c464a80177d1de923a7b6121ee83e0226fc1271d231a1fb859c1c989c959ae63942764af945221a3d78fc1dd23d82d9fad0322a1bd3dd2126f7deb4c0dbd6e160134a11156cf58a24ae38e6822681ba149e278717b7848d8d6c6dcec47add2121d5bbd8fb97b67c598e56cfff6573f2714b5453d3f0c1be6429a5ece4b1f294065231ac46db72a464fc2b93298ef2340b91f90033cb803ccd04912e6d309f1db4e90fdf925d47cc5bdd45cd59a5834909cff4485a580a1ee7b433934dfd720ed2d6b0d3febc8f3091c32d88b80ac7d385f57d7cb12c9ef6e4352572d31ce8fa52d12cac76a25ef0c30ab73b21e4f210028ab8be84c2422886f67684bc3c021f57e45fb38c4bd0667434dec8019ef8a690797484e84c180cfed89eda8f104b1588ab3f0a235f89085e6efb318d378a3ab5e418620ff42d966176a70813ee62710a633a288c69869fde5d8448fabd79a45481ec427b2cc6a171c9c5a094a8df966fd0b34784e1010719ff9c63ccfef2b9d3c4cc0cc516db1c56ab960c9170d84d678dc243c5694e87da14db94da928bbd2656ff10921289c59e469c0f9e6bd0c7c2bc41c9bb86bf46e86c0b915e0b4cfb470655941c80b6d8420afc9e1f07c7f28ae781059ff66fe968f571d32eb5280e4d5c396517ea142e7bed0be6f087c70345a7c4c6063a659cd3717c55d55866abad6a0f1d9022f8c8788b833c67140b41ca75ce39cd491087f1ec289d23f33285f2488737b77aa85822a460a104d78c9165289a655b22b1b51614b65ae5fa75f00a3e8c4143b71fbaabf8e3786177a8b999b3162b1817cf78f2ac44707adea5b72d66b128433dcccea4e8d2b13da60ca04ac84c346b05ac8a55ed14a077fb7baaebdb2c50f5ad8544b381a6a4d2e68adb3ae778df80ae3defabce93745b8cb1d4c36476cf0d9b8be7dd8cfc009b7108a4890f32645c6ab46ca6eff3df8f6b14d81105646d9189c28fb0e2d4a7e715b2c3cb5a15fed40874bfbbd7015c0600d5e0a45fd77de197f0c743173bd9f39166c0c36d2dc8b32544f3a03c4d41244bcb4de97ae9dad9ecec221a434402fb698ad41b8d886b8fdbc01b912ef2827825ea9155ad3a82ca54034f2c6544ab029ef655a8004e84823a987bd27e76b3ac0d0329da7f7ff678d342a1786bd52afb48d439ec2e3d0fbd6bff82f904f7aee6ca04dd3d903767a27359880bd382d0fe4c8e1aa7df6ed8ef1c9528d2761518bf4feebdc76c114881acc13caebe7a53b0738b19bd3628b1a0d10e15bc5f266e9edd40b8acdeb1562118ccb4ba0ec6276bca10a7b498d0b9a08736f39a5b1c725616f1d21a773204af912bd688ebb482219318ef6e7382eefa52ca481e828d91526351e196a2e017bbc184f27ef0eaca718db3cb745282c54943091ceb8a0491cc64a148879e5a1416833ce97aa2b89710bd78f89c2408b1e9ceb424c4295952505a9fb71f62a7c6639bd8fabdb8b9ddb4f305991a3ec581d0d3e8e6bccf846889ec7ece8f9477dd940d5dd68768332cb992d63cfac6f9460e669c09aa383a38ba167d9b42f73076f513dd2787cc5ec672879db7769b275027930f068fb1b1a6a452741484c5ffc038d5ae554d8326284d5b092620e3f751d96c859505fddefb7a647b7ef893fc48dcec1415897d285ccdf15f1478476b031fac1faa0556e5286640d6c5c8f5f921bd20461bc9efc79b181a1b1e1fd5d2f49b443b5217ecc766aa115b834d95a64bc2e0d11a3fc7c087f350c23518e0a71e077af5b10d9809d5351d1f8e5cbde137eac821bd3a310cb9d85f28bf0c26badb5ebc7406a4ddb911e348f0d20592a3c11c8c2c7f742d320abead82f921552123e237ddf211c777a82ecf8c7258c927a4dcc015021eb39e7266fbec209ce6b470a069510384a7df51bf48480983b5ebab9cf1a31af747b25a39213b5ffba83e08d487600d52661cf596f166e0df7d4e2cfc50769f0197a257ade76a9e1be4eb97da6e41d1e98cefbc38fbf6d9577582d936822aebbeda7860713e286eb36fe3833799cfbd87e32e7b5408baa67afe8178843c6314ae7540180e925cdd28c308842d233de152474494e0659bfc98d9ab135f36b979963a9899e6185873406d90fc2d23fe3dc0aab2e7d7287bfdf36f8e0ef07af4f07ed0321897ee52ae01de015d5db50a83895014431255840e9b48072a212500be6d4caafb296e317780ace7e62823a38704e066af8dea2b18290692501aa10ba6ea2554dd3ea114a4217fe1d078886ba6f8b0a3ab044d4ce006ba4775fa8c1ea0a489d07ecfcc614dd84719bbb7c665e691918aa27bd69880c8d1216a6267ca8bdaccd3635fa5a00fd4db0393d48ab72fefeb5bfd15c2a83a4d4bf03b9f5334fcf2fddf6061615d2a40c0dc9c0a14ea47dcb69661d2f41811c870fa61c7e9b55475b51a500672823f2fc5c9d31a38918fb60f9c32414b64b7f878f4de9ac2364075c74d34debcc6c36d1ec42b9a84695bb8fc9428037b13565d7bbed4c16f7d80e774a48a9b0a2881f4c3d95c5c595b267248089d1eb97676b24fa3fdf0d637b288da8c310eab0c2e8277c1cf2092e3d8f7fc6abb9237b6712f74e7d9a181049ff55554cfe9c18cd09264064c6c8b564342bb328be8b228847eca327dcad6dfa746d7f8ca060b2424ee4cddaeccf62db9a1a6f67cf350910dd56d06e8edd33b683fabf5c73ade0ae2c86f8b8a282541592bd0e1880f7392bd5a14c3eb4ffd4f0409899f7464625bdb1ba5cc47587b6fcf4d0ee25ea4addc53ac61442085c0a3465bc8065eee8ba427bcd29d06442894448d1afdf05a91f4e5b1022e982b0e36dbff39faf24ee096b5ade3626372a29f58f9095f91ec60e3d0efbd5a4516c69f066137fe42f71ad329006154d7febd34a5d7cd0640c0ea0a48ca25002c7d539bc0555931720150da9691bc30c4ac20d1b95780f1b002659e3cfc4fdac9e6a1e719572ecf84190f811f70fd961a05d6861b46ac1f45fc747fc1a329327a198ed7c6bedebaecba92c9bd4c23d6ad6272b976bcb3275de1291613366a58950cd60ca65f4e944ea82e364b69d53a58dc4f30a1a34ee54ad145e831042a726ecfcb245ab8c72d9918eb4053585d3dc9aaa24fe8bc89324f5829bab1331f8e0124778f171fb9a16215810542a9ccc91339337c1850d89230bf03f54429663f95490dd85e3c88528037c5bb0f08ff45842e9b400cba4f4d10d36eea98bb99556418a0d3455b4e3278d9bcc52ceb533b10511b85b9a8088fc0cdc02d1a8f1c112030acd2007fab7ce26cbfc5a5b0fb526e6de5d682c5ee1977c34fb8ddc310a4089150f3e93397767fe42d98ac743dd9d348d83a6cbe3a4e9b92c0d7255928dd54f36dba45b08c5b8e5b2af9b09ddd7fcf4a0222aa47e2230bb3ba7670a2f86308e0ae0c726e90f186b593ac768a3387171f05149b8858a25b00832ebd606ff0c1b545c1c87ddaec0e621ece5b88f4139289f1b0b0d39b69908dee5587ba5b981c36e2c7a1e0e68c48fc9f599d6ac0e11021898b2f3e613f9a4af6cb73fe9453e5e75148c7dcbb0ba0bb08bfcf0730dd2251cb6c2418a2c85e7ae8775262e0e178a65b1a50e3b7455c500fef1211ac26cdad91037d68f0152e78152bbf0be53d270a37aa6ec770b8eac2ed030815590e1e330dae2efac4204fef186a9691aeb8f361f6ac42a1b3efd876b385b0828e988e773fc3ea0e1e7c27401e2e2027e767d0ce4082329d54209e9cec33152cf23fcee8944c8cd857044bb0b9c8ffea1f51bccb8575be777bb1bb91a4c06ab3c7babd353a48ac54493e964aab2b414cf2221cce62d0c1b7f294bd54ee92ce339ffd7473a1aa0d54332adfd76118d3ff00be509642d34aea6315bcc914887c33ae78d13618b337ea31534ba61a9f85a18c1ac158e17718da4bc2e61e1498fe962913a49809e7b7b88273db1291be5e76385dfc7e43c710a0b3403f9c92de0ece35940c3a4508b7858ddf006f11465f665d1e66b872a8e10d3adfd168eb9d2acc79d3638ae51cd9cb3444760e71e2c9b283dd5b9c182516e0476ae787ad106216e6ee4e9d867a2ddd3217ddb6b2ebcf7a5a10bead1256849ff0d65e266f52897727ce23dedbe032568684641a843b2614af4e4147b34927f871ef0a390671b167d854ed4910c9f74b858621ee55df2f387c8d2d198ede4a60f3d386235bf52bdf810762c3938bde704692a6fb4c3d3361c337a72043ac135048d20f301f4b3070babbc2810f862eacc4972fa6f4029ef1c6bfdaff70908521b607a7c5c4d00a1d00321824e47e746bca2bb62f14039cf04d590c6937b8b4951179e2a9db7f17360453de6e11298d0686321dccdd44ed488644f9716293682f47b7c83c3a9e20905fc1957d1a1bec1aa59f755173c68f286ce22c8b4a6bd84ea7ec9d75a7cdb14dcd5f8e6c5f5c27bfa1971017ee2a920a8362aa1e16af87348ee622a0f3042e219e4419a292eb1904ac3f7c07410c589dad5c96a9f9e376f95e90153169bce3ea3dcaebb49bee752f8d6a38976c4ec3bcc34e54fec291c64435f122c491d15ec5c6e397005227ac7e563b69cf48d728975dc001758d2da4a2d7ae320c771856382b3742356a61f276e1e2f8b0ad31dadaf97f7426b270c39b18d0fa92848242430f89d529016088b8c5410bcb58c70d8c45d8720ca7c4317153dc5bd1d396d660b9886cebba7f6537e80a77ec5171c19b5c12d32a0dfd27260c04542cb1fc9340ebae2ae65fcb054b6c121e4d7203fa79127618d583580b16b05056f79f591f38d51c81d5d7e588364fe3fffe9e71c221a192e986df6a1cadb7397b8f22e17ddfdd2cfb0850e700a0c0173340eb3d6c4a47640c5f99e1e07360813c1c4ad2365596a5a75444d3006b340efa284020a833099fec40ec3805b53720ce360f7bf3fe8c8a93d42662a8b11bddb9c93b029f9140b6a3dadd6e529197bafeeb1fd64a5b8da768ac8cb689bd58c93899159076025eeac0ad80d01063d87ab827ed46986647ca1bca9240addef273ffe2634bff6f2bf44df106857938f157892dd7a8ac50dacaa3f49460e061dbc4a8f212f9d75bccf3b99add0c7bb5af81c212687c4da39f3ceb044cdfc97d3c0f0445c72a799432164e1ab513b5ccd360e7fc56cbd8589ad6e6a7a332415bc3df9fab58823fbf541957089c06b3dde164c12aa4e304d83a9dab425b2be81eb512913e6b5ff551ce9c937b2a870e5f7134e5d169313649a64600a83565029e6e9ecc9ebf755ff19692ceff07fa23cbfde290c6d18ec63cc862c41f7d7a9069f13d8fe8c3f044c4ad0b4ab064b7cabf02e351569399091c14fe577f20d4d3cf8ee4d1fe1d7271940e4a8219f91a8cda9742c7b4768066f5b727b6ddc8992bc1bd806c3cb59248d882cd31efb32bcab0320a4cfa2b8c6563a89636efce16c9191c9ecb49edfb4f2b408f8e98d951a0a6143fb9558b42356ccee027ca8573eec66134f7d18167328dedded766776555fa9fdedfdc383e7daac510364ce4ffe0a550acacf6cd4c291671afb18f0b624fdf91a429d2dc3af73f0f047b94a233e0b91f9dc6dc45ff4a85e5463d5a0e0c12240e06937f48a89cfe4d9c6d71d55e191342272ff622409ed396c50591daf390ea1c8f9fcf335467143aa703fa47d9bbb102aad9ca3cadb991f82f12be56ca3ddfdee25c38805f43ca11a6a3d07c39479edc89f3d9fc81b9f3a774dec94caeb6ac035f9ff83ab5a5a9abfa2194e73f4fa86fba5fd3f7765ab83212cfc9b824cfeb5aae24881e39d690842b2272662a6bf48f14d63ebb616d6bfbe92718b40d6ab9de8cd06fa04ee4e067bc890badc3b286efd19bdae64db3d53ddd14fc882aa4f7e55f27962522e477bfcd72feea3817a8398d2f6c146538086ab5c4c17a766eb97afd201cd212457a753a7654b92896521b10d347fb149af10fc653287c24822eca724bb95b66815c2b71ea21bf7512c6cf758e320f4b50650a38ffeef0e43275f7b1d989af1b431006553b82b3a0e929cc3f39babd532e4967da46533db1e4b25185e3ba7d29d59051f518dddbe9dca6c8f3288c238a88d6cac30e6755f20edf752f436cf34c66e6cac6de28f8af3f1e55e57bfc03aa737dba841012c8771856f20cedc95647fea541af980c798231912452211080a7e164b10a5e165ff506c0aca0d33b9a200639b70d86ca6c7415d4ffb6b114e04bfe96e4756bc8c9a13fcf5e03569a89f47da2b025354a39776af9291d3fea69d404eae4a7be9b0914f123de772470fc13350ecf65067da36b83785bf10ecbed9a73907b0bd9c80ad75bab0ada19a449fde8e84fcd6064dd3866a11e3ab5318ad9e7e0110f1c5e84645229f190c675d5befc0670d9a6fe1ff07c7eb8e3d98","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
