<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3fc885dbf3fe938b296246f3a4e32b109c7ef722d7b37e2e5cb9bfdfb81d7349c567684e464cf0effee3ccdd7d754b2e1ae6fe0925c0580926e14c7ca146e32e2598c8db473ae3fc6f99a8873933bd8264b3480f02b72a112fd85b201dc64959e0237b7d5fd0bb6aefb7b2f4979103e33df2ec53b655bb92ab84ebe35dd22e18483bd292c7da94c837fd37974acea91e37802cc4ad7d277cc4f22efe4999c184fc92be8d84ab7bd57577b5b1c1ca9ea628c2036ebbf03030c71f2b7c02d8116414dd401a7ebdb5d3e1443e096d28642f3927e745016bbc8443e19b2a03cc340930de1c84f9ac5225ca6e86edd12d20aafc7a86a77d641888348c791d9f5e5e9c8a08440c9fc7c20f833a64a5a052f140e683b19ed1ea7452fb98240029756560ba634ec3c5b30bbd5b88d32be9390a485caf28984600645215a592063c3833b9807a955cffe8be0d86e7165b95e758669981df4f959135a5898701be7af28b2402155624dfd41fd09d6953a39ce4494f44d06e62bf0eba0eefb4cb5398b2d36bce0efda46fa28b052c4242347b05d89777d02185341c78491ccc6f90a2392e600ae844c6150c26139617ede79cb30992c7294d094f8d9db823ad65fd4e047c6bc73fba004d0b2c4927afedbb83b89f557af0179c11fdc62c2cc9d2b92623a5c98fc3e8b4e18e4ff0f62f33edf045a1378ce347e1ab7a484baab32c76048cc5879ef4c07539cc8f0de1b4398135d45c2f5645ee3654e76a79be29a9d0fe3421fffbc94b3d21bcd244955f05380593245d1282e0743388dd08200eb3b6832248fe6e38e9392b4cbb41b9822efd543d62b3bcadc2cc32e7521186973bd1b92e39ced966c4bd926f7bcbb49a86dc759fd849d985f0a4c646319ebd682c4009e153a6c95fa2340d6e898a3f5a81f2f925d67870a3cf6a9055ed2f61535d99d5d5d1181f68685a22d419e73aa6e1bc1098407fa1bf5bb5f8039dd4872a3fcaab27de6f27a4ef01ab59725a66da7c73612a2e79ce840be653ba4b719bf8d931787d195760b8d0e75ef311c5ea2faafa08d434455853b7274b8fc661ec0791b22dcd68931e5626e525f8448929a76046490ad5b32bdb188c85e0583f8e3e0450ee858b802c5063f6933803b48510bb57324ccb4dcbcf0ea3a65be61ca1d9b496cd21e4fd6e676de578bd80169ca8437ddc8803b8c5997ea4398d29d82ded6a4e8362276cda771de197c3433eaca93684a7b209763abbb92ca5958630a11407efeb513846d84e0cee13db09bba4ee7584d73ae9f5ab044ed3591ad88215b31fa4ae0f81fdde470a3d0e7e0f7c77b5a0f5f4a5ce11e6cf6472c75dc32de9012c2e346fb32e05ddf992e51da23553a607ec94753a9c78d7cc316a2b448abf8539b57e6763619889163add6a8b178ea53c817a6719be9c464de71ab0a0ab9f58583bd2b95877423ca711fde65ead968c73b1cea7742eb32c0d96feddc3879c1df7723f0cbd2d11d4ad773b7a98609ca56d5bfee4f885032e12cb2ed5d7c253bf2449760db7e670025201f408dc5d2bef25cbe1e1e359c47757ab9fa8fcd41f600b258e50a072438927ad8a1120a9c09be30bf4c2ca9b6cb705a7381daffe49c6bdf8428c15e35314972ca5ccdae9f2b1a79018ef1074cb8c0789bbc9ab571f5209d0e61efb60336321a4d1010bc27be13108d294ed32c950f78332eb54ba28811b2b7cc4d3ca96b5f729e5fc6e7ccdc6a682871fb0300cb72de5d5b2205cbbd77ae547864370aad8a56178d381c194e4a9b56e8767297f9c518607cd91ff3ad21e8ebe32c7dafcf08c481169e9c6d6cafe921f43b70ffb0f817600fb85bf94202310441e0e357a08c0cfcbc4aaad518201451fa6f40b5c5982d6cd850a445cc26b6fe127e926abe5437526086aae81e06d8a361a0b620c973d90d6d7140210719d0055314a9b0c02c64c289572ce87eb3dc25a39f8fa9ced537d219f184ec2f29ccd63666ea41baeaad2868c11c9bc035241635c06651aa4be3b6780203ec66c8032f892b521eeb77b382aa5d1c7e20a816e87406b368ffc917cb3f88815bc7f74f99998d662a5c990b220c66526b1522388d3f066ebe06b9270b9475c88cab5db760cf40bbfb0eb8a91eef326cc9cb2a1fa818edec1b6b3168204a8552bc98532f8c8e57e71c647cb68bae258d3d1b68fbc464681abe1592c17d52243fa069a3ff5b4165b948e31c787c44dcf5e0f365567f487f1f54f574708bf7e5d4174008d82365801a67a533aea4eed6c2ab6b226cba20340000e377d184035c57b15a500a90a17be33644e425cefeb26a0336c19041a7c529fbe19a253d0d49ac5ae5384ae36267d247d72fa64287c3ec2aeb710c6a26c88dbdd122b09057bcc14424cf604ee39ddb6949e0ac3794bf0c31c3267b87776439983c1fd645f985b5abcf9c447ce74e8309a49b4e349c008dcf55c43aca254a7d30a859e5effc8777b3354d480ac2784e2e61a05c502a277480feed10f62d8b1fc31f57eed8bab71845e0a7fa056ec810cea6e02cba1120c69e64607efe8b89cfda97cd7516d90ae8c844de9b3f73050705bfa11483bcba104d716779fa8fed0f39aa16f2cd12294a2b8c1ed355f72d767c8dd860866284038e760a661ea648a51f711d24f391b1a95fa7a74d7235893ad60a019bef3a0477b2dd1fdb943b91a9d76b1a20750962d43d75a5e39571deee6b9f5ba848b4e6c9892723aac3383164b7c376f8f3270cb609f905114066d51162bfe9f6c62ef48d8231075df0641263f58bf962856e40099ff619c7523d77634eadd1cb8d6ae1e4544f958dc53ccfeb261fd21b2880a43d4712e657063b5458751a185c76db7d74fe99f524d34464d4770dd41fa0bf9ac60a5c70a8ae261a7f44d4b6293704344a34ebbcafc182d35ee213be16090313ac467e12e095934136f6f4ff3b95102c7ebdac6b94ce598988a5e5d64f89da81555b062b4702969289853b48879c7e272350543cbd3758b8f953e6dd3a4877e02e3875b56dd66695e0643de92a273bab6bd5cee36255cfa0484140ac03cc39887c96596546696312487fe25f0a0d436c9f0de4c0f360b8703dab6f5608306a6d432182d7972961b48943cbdc83eaa9bef4f9b014169316745fed0e0b3f86183a96db20b8a7dbc2b73ae5405f4f8ab77bd1fcb695fcb43cb6c211387bf4d2225dfbb07aa1b64b5cb578126984c0d9dc210ffa356fb0b3bb30d89c8083466fe9b28bc636e8c1368e3a0abdc7232cd3ef6024ab14c8329004263f86d38a0e522927d1a177990be44ef7c5141f0ff2ee18dacfbb46ceef9cf2b568a74aa850ed18e57c82a0266d307bea42ed6c1be06cea68c293e29576f529a54e18624db051f9a9f9c451dc4e74fd8c9481a68ad00aa7ad8e5e181dff5fb6ee4502dad41f449952763ea6c3c9abc495abd64c9a8b91c722d50d22d52786340945f7ae547a3dc08bf43f1200e6861774f067d2ba6e953847a400d4491fe9f9d30eedb1a29a7e188fd65e7db54363e2b00a1e90f9c0e396ab04a4a27525b4e2d2d7c52026ea980f97c49a6dd6e487397b94e71ac7e9558889530922c5411f1e5f0caabb5b19f875a3e7ed7aa2075c527a21343c174f5663f63eb1c79ec0f8fe43abfbbaaccb2d6a690b36fccd06543676f6bced5997ac424ad07456547027906ea0f9ecf829484f2b703aba35645e8ecf385b46ec1310d17d7acabd66dc14978c4e47b7d1bf863ba59463d243586ad1d30242c448fab62a08b64995671d2c7a4fb692a64ec5f9c217f8031be2cd0738db76f97681c9996442870a07b0ee1a3a21f9c9f13b87e55600a43079f16f17c97f9848f54b2d2e5da641622514963dec9dcb54f43a1d33b211858e518df4431d03e3432905a48939a7339453d4cb5c4fbd58d0e078df89f091d65694072cce2c6a19efea85e03db79a0f87188c90b8228094c312bd4a8ee6a11494a90eaa6e13c324a88ecdc1cc213cb059707f1cad46638b6a3e3624c14e586493cfcbdfd21c9e770d0b102be0edfd3207269d65a722e2aaac8927cfaba5f25adb1d51252b93c92b4712debba7e181d00537fcfb34a7f4d042eac736cc513c94367268e465ec8c41c2db272efd1a012a2f7065a52ffa3e696ddfe3f583dada63caac2418997e1ad568ad7f791c18ca7db572e148f362bb53c6a81e325e80f19a0fab819f32e806b663ce2521d565aa57b4d3f6355607c13b2e7e21f1f3356cd49a5ee807299d71c25ac96cecf52594a8dd6562aa3c581d55c2c990dc77a457e77b64d7e6469860ae015b8c353bb15183dde3096ffbeb322f39d1c91292667f118d760614079a2017458ab30ba255d827b9030682f277a795f7c3257ed88d061d24b51e699e6cb46c13fae152ff9f5c88bf80cbae8478c392d04c9de397626e73748620a2d70f4d392b49e35a5228dafe526a389d3ed8a90cf46ec6012b98b0557fb9114998f59b38f7dd4805030649c6ac628355980b680e3a5fdb2290ad42bd72b13fe6f29ba264d55b5c83b820c3667576513eecdc877b654ef3dec5cfc1086ea56dd5da0bf49a3f5de4b146fa41c07bd5481bcc88199a6f5419169da3e7860baab64b8c3bb44c703dae82772154993ba954dc946355161046ee2abca965d17b7da345a4a0ebe6f266473f03935bd4d4a7614d71473b1288ce2a7b6c632071a0d1f640a864b64ff6fdc3ce4d42a7e5665786c54322fa4ae58b3790be9166b5bd7cd697f353370b3d6d84930dcd3950eb10c7cfa2b2e4d8c306056321119949fc39e1abf5d08ea65fa4991eeab038c64961b22fd64df1b805f6f4e55c91886ea4a2551379731435bad99d8358a8efb37cc281641c4fc7d5b97ece668ac6cab0ac1cab0b734fe6cb12c015e14cb97163fcd628e660adbb4078d3a2e97ec190be574ba1648f3e273e926fe67ff5a48ba21bb0025100b1ed2fba8d13d1d9ab33d6db84f9b02fd3c0b7ac3ac27178ea7a8e7c143d12ea7d51dc566e44d1b0cec297ca787c7d0f5a62f2f7b22bf2ae8fff97a09fe5b1982e84ca6cd5a58ef878b6f5e14ef9dd7813c6d5448ad439d21201b8fa0dfadab95b2910d21f205c0ae999bd3bb26aeba5f4bf116911b607fa5523ebbf425018f1bd0cb3392565d62260a584ecae99e0b318a76d9b3740fe2dc30ab903f52f80dc69c4716df1eee17c895bb323cc350f1fc47a2d5aae6dc84acf264a4c0b750ac79d676b846ff450ba7e38eb2fae8a36c85f099dc029044b2829e6d50912d5637ecdeda8048230a0edaa4049e445c2a980c5e5f59d1d0f967ae72992e089ec06246371eae6ef3ca3b55deff5d423f3c241c7c599e01cf2a6a4ef5b42a81fb98ac457fc634741acaf2f7050ff4139fd10b65bc7babc46de09c490c6490a4380cb48c1433817f0793e8536aba481ecdfc7d559f155504d85bfa246b1b2182cf5f21c5b8685a4b7ec8847bbf92f51dce2734d9a0c2e334cf1a3bb6bc0a1736e65ab30ca2e4bb833a1e6a61be7eee4ba9c03caa7981f8944852c0b560e6e0d4de87b44a943ce6cb19fbaff39ad33432935a1d174143c778846e3028524ecd81efa18e12456a034688ed9082945b2810b267ca4dad3e52d5b187ba49d38a3ea5232a478813d35e1e392896e3b3c31af531f5774d0bd8c806ef20f0c958b380254ebab4a292bd89d793dbd37a737202f255cd39afe5fa27dc244a61abf426f7f66f53f99844e2ba81ac1d949d87df515690cd4c941abd84ebbe6b9e35fb04830ac7ca944544b87054905b9d649b8d5265ef1b7bda126a430c1e99b8b73903f332fca3a399bc226c8bcc804826d72cfa9801ea3d9a035f80bc6f8970aacd57b142e0b7471749555e9b6b225b1e1f0cf9226dcc798be4243856b4881b03f4f4df9b6106c425acd977b53860bde3704156c058ac977cd7e159ff905ac46350e1eae8988cee60501dad7f7f0cc3c9dc19848cb15e7a35c9fdf5ea5232d80a76cf89cb1433c27b1a912f89be95c5154dea6a5d3d608d2d8be04a77f70f26dd30194bb473f1c9229c6d04ffcf87680cc6c64898628ae99860f198874529a274c413e668da39b9b25d88ca6d892344d3ed35df6521e5dd096b2b58f056e7b95c928032c20b9cc0957f1ba8590e0b775af1f61e93efafe9e16366debecc90e29a5bc884f59afcda9a445c9d3f34d5513253c154b61c6d0aa3d75bad65e945176e249052318d35e8f482e0c8e7fab8db0e8fcdebb9e5f3ac646ed748ca5a15eb622617729568d0c962782145721fb97ee368fd4cf5450c31e6b6ffa37e17219105366fe3be7141cbd7b7af2dcfcba45ce18f3c466f2af58ef86f52721b10d8474d9a68763ef590fb7dda2c2c9760c088dea0ca40ccd4fdd9a0faedc4bbf3889060d8f4920249f73f89cfd50a072ae50087f6600773780819e1fb344c12e00372c634c0f96cee52ff1d74816e860f2f60aaecee57103d16c80c285136d888bb42b005be82a47a42aab9a2cee5cfffdbefa2faac3c6434e476cd21a4513ce5e5f0b76825b8e792dbc50d8598c0ed0940cdd55883cc813b43050609b12c3925a20a37640fd96d57e759097eba60823d6add4382fa3bfc18450734645a886f183aa26d8fa3c9084195d5a4b7aaf6392024fae7b6bd543e80e53848c013135fb7ca2f79f1295ba429ab554b80de01e7d72777437b9a24e79ec5267129cc7591af0dcbbff97b34f24576bc3a38ba4aa17a40ba2688957c20fcdb5bb0f539f2a9d94c2aaae510274a6d8f56d9231196d553e661d34fc9fea47c6fbedf65bbb2fc2e71621406b266241ffed81e3b3b8a7203c7b0ecee2b03c1df544ee237d8ad9bd96fc80849b9a4653ea34f731c0d16c84c43a825896a088dee41248ae5720ec99b61dee2f2bbd0af9ea4b208e31e4827bf38597bd500ca9a9ef5a73a8f5738459a2f592902ad83aaafe55606cfbcfc15a03a2c14384256fa41dfee7141bd37b4434360cb528f2e7dbad5b131fb1b7c1dfc047ff104b3b0f2c33b957f94f76d407e9c11a8b1553b2fde8fb8106d3568fb509f578e7ddfb699994b64c8e92f6c2957932212a96fe60e6e39fa1fc64a9a57d2ba1dd13d8f1b2daf9c26fe1ffd41bd012581cdafbe4f3b9a0cc308af8dbb02c4c86e7c159bd7d93cf563ae48618b0b25e4a0c2a18de7f81c373fbf6ffd36c65586948e553c0142885ed41a472e71a329174b8799c8a3145f4d3ae7ede1cfb6fbb4aecc8343c1a149dcb72ed5f52bfe5de047723534edfd8f9bdf9889799e807b56017446441a888532f952e2e470bba6ac88d149c6e3f24bfa97b4980e29bf4b115a29ee208d044395dcc7b9e7a4478a447410aa2bf9adc2d7bc119480753f13a4f0b86a4af0b93340e9d189e0db3ad149f2a391ea90eab9c3966ff11872b0cddff6169ac90767c370ac90297d176d51894637ce181a0e882d873e0000193c35091a7363283371fc7896a3ffeb919303cab3c3090bdfa06d82bdc1eac1901dd4e03ff347a522c2043eb8666f6d3d0b6a400be9aa4cb9ee63bd0d013afb0d50b6a4975a7c522489b950682accba6b643b9ed37edd21d77132850a5b31135709c29c2fe60874b4e09a55007915599b91088fd0429a8f1226f2662b3d1e2634df796edaae05f5626e7e2f1d71b7f904ca08aec7cbdc2b48c9c0dbf59b5d98fb29670a9af68850e0ee38cee02de8518fc956bbe26b356f722c6a166dd8a65219959a41b207aca4c5950acb9b6e29ff03534dbdd809872b265fc9b653e1490326419e88cc29a79e0592b1ec7a5cc7024e68d8fa2f499fec0d0bbb82c373823d912e0b23697de37d74c37819b962cbe444d3c4e25dfdf14717bb3556a82e16afe78b75167e4a23d7bbc913e241915ab43d68d781c00f10f9c67aff0e59bf2f3039616e0195fdfeef25e4ac5a14bc382675121cbcc0e640a27bfe486cf7a60aba23dcd07e03396bb741e20552cb75ac4c1a58ffe4ad0e8df01b531059fe9dc9c69211fe0e0ed69defddf90d89d0f6af151f418f5c3523a611689a12e9e34014844882ccf78523acc08d5b62a12473678b8d0e62c5dee124184e38b0d9a0e8b1cd80e055b33a7d1fe6c3c91d056bf85c3121a1bbf20b9b98b8ea8c5d3ddf86fde5daf7bd09e72331aa13ab5c8eecef8d4b7c5bfe0dae9ad5aac50308add7553bc81cce63461d59df6da5e3c59a7f8968294e54f5471559147a6ef39a54903fa96d66d392a4f119d102a158208ebdcf5bd88a71cfe57a496f2e51d30ede81f42984dbc80b559fb6ad5792633842ff9d5a6c083c7e36fabe920d90ac968192d5dd6f54159b24f40643fa9d7f68cec8a1480e460408688acda4a0a463fb51f070590d96461a5bb233a6a0794e60103cb918704396425a1a5a8b84e558fbb593eafc94a12fdbe14efae1c6733fb53ba4dcbf20a634ef680e0b39d1db2ff320c6c907bddd306974fff668c9a269c87b250591cbb6926f44f61c9ce09d87b709608bc03ccdbad3aafd5a1df83c36ab44ccc254385ddd10f605d16ac8b3f29d038ddc00d8cfa37f45e77c0801225854adf3eab69993bc8fb24d1a7c6ae52803542a85702aeebd9a74d71a04e889df03f1fc61a7bfb03373079b3668644f2402109ba8b8d1d4e1d43f56570373c972e15195470f877cb9e5e323fe582b74369e4001a2d32381dc1ac273ecc3bed74ee30149f774921b7ee2b82104428bc45b48e79c5c940d2d2aa71cd7da25c7442bf4d086cc931a572488b0eb506e856e542fe3235cdd1e8ad7780e8f832413ddf98617f261351072ba99e5d02d00d44a2de7c3e01155af30e9a55ce7da1d7a3afc343faa915ce33599b2e84c730d743f8f0d82cf5224092fb3b476e4200217f03df56db35f3f200517738f0d239772d52f1fa36a9512d68d19c54ad6d907988cdaa827a3c8d9222cb5615e9249d1d376452bee4a28f7d3d306ce262457ce42f8c975575faf2d32aab8b8d800fb2b305b4fa4b270f9f32ca9d1342f19ed09071db0ebc88a9e81c8684bdd0a0a900955496114529ba7903ed450f62fa7ea900196dfa28b12ec33fc73db24cbfed11b939791d37e6b57bd1529ffdc3dfe3d45b226cd5c2cf8118ee5a056a121d3024a863b32e09013f487ce6c3bc4eca8a543ec68c85e00473fc91cdbbe5d2862f8e34165e70f353bb51e918c1b2e54df4ab32949b5470796fb37497077f83ab86c53323aa356429a87d1ebc90d8368c1c04d9460bb67943f8875ca04101cac0f9c8294962c356672171bf1f469825fe4d6303c49c3e0ed8c341913669a622fbed927925d4a6d30e6d872238168f74e4eee6e0439768166c57c00754b691b50a95ef795de844ff3eb272a0e04da9827f8ca8eaebb62f9e301721150b8dc98b941a859dd23a553184631db1b62476d6539b08a8bdc4beeb2a8702d19f3b7745c57c805c9b389f05472c198bae5315f8367c3dc403128b244e8017f87342e87c856c13e70b824686c356acceaee848991b43373557e32a582186c14ac4fe6dd3308160926a340bd733ce4d194c7b168e52637d9a9e19eafca5106dd48b2ab01ac02766f09f7cdce5fdce3c72b2aa78e6e9de4b9bbce2e1b2af3808e0ca3f70c73fd573405566456d1af24ee1a5871264d4bcb9868675754c95220ea35dabb88353fa2834497f4b393f1624e76bbaac46b34e56ceabd5eab92f205c6edb21449e83edb8842d69ce54be77e26c9ded63d50c2dc6670af4b7aaf0acb19d3ddf0ea7535568d71d9ca20ae163eb3b538253cbeff282a852ba92c33caa4d01b7751f0ac02bd48e4555f37aeab032ac7960b20e67835ca0cc6cfebefbf7321694e8152c2008a927afd4fdbdf583113764fdf3d7beafb632bd342949ba1fbb83cc638432d176a656b875a7627f6b0c4358839330929707b533183120d3befc64395383ef9488f0e8299ece630f464c2b3822475167b1b8ec022b441033ee3885bee13b9c34e3dfa7067cd3fb166af2c77d33424f21ef7c9e466b856d4eb84809945bd89f0443bc46f8207a3a9c97f5a517a51512f18c49787b93e990d3cebf6534cf51e23bf88680fbeeacc9f9306cd1b4e4b46098d374a193a3ffb000d2e39a7d0f1fc3c1436af32d27140f76d8dd1b0db7f0fb1eab9b699548b6184e101182593c301fa909f7cd49b6f490e34193fc0c3a1c3fd65e09ea93eb1442d6582249190a82ab2ba4afb584e160fac7d361159af106b2eb7db7de87be6fd5e36ceed2bcaf515358d4cb33b8059abf8094e434d43b590f97e909726fb32baf4d14a4e16ce8aeace3c98de8454328cb40dad3883a24867c9cc6f882958bcbb41cef76a4f689fd87dc4a162dfdf45cf33120a7914fdf0548a44b51119b969acd584fbf4ebfdfe2cdacb079000e10e1fea6574132c687f3dbcdeb0b8bea1a39cf99e5906f06e0a2e1084dbc62894cc70e9949335488ff5b84b16ba69e6c0460ea8bcdc7a310b38f28c1370be47f35db253652f7d26415067cbaa510ecc61ef1d5c9fed33a134f0cc638fceee0c1e7da6dd00b2d53924757f34af8f3a56bafcb454f412da324d172f6b2fed08dc8fea041f347f6b8f8d0b62962cd5d2c3c95a10ee56279bb83b2ebb423b288803af701002c2486bf4dc687cf37b844009eed4329a0f7011730712bfac658d274b47b2c37a2b004e0bf54648f136ffa618f545318ca725932f6cc11c88f8cc447fd90ed3e77a93e895d1717ff29b1a73e568bb0fcdeefb7b63163f5e10fb0c26685632bfec52cd3d691e1bdc092012a019a9ac12143e0312a10af86f24fddbe783eb6e9ca48b55356f1f9eb7dc21f23085256570bda5f5e9085c4c93fb4aca2c86f5fc90916d6347acc5cdddc9b089328918e61601318f1bd9b78b004b9df0e08e9e49799b09182312b9a2b386491854481e052abe816b16fdfb8df6a18b311641505ae33df75ba19c50743a83ab6b6b44f034ec02c03a33a6a3dd67e400c01cb4c8ce34c3bce0dad1cd1262dc20c46ee85407fd08952c6ecdb5a5c124bd63fbfa060a8e348958b804973493d3e3a19aee2799fec3b57cb7f2d76d7235dedbbb2f561631d9d7643eba27c8303bdaca2e379816162e07b912ce92c7f4902463a1f9591cfbf70b98d0284e6045259757bfecb1cd333b9468b36ba333c80fa07da2be40332d1a6393a11a2ab6f9b339f0dc468f7c25d9a8f5ff7b93ee68696104d67ba10a972ad4314f0a55b47fd61a8ba1e6612a3c51b47d9d9c1e9e32019a932006b58ecadabb91ce437824494b72ac372855355ddd6b2ffccce11d2d213bd98e08c3216b22c2e01bb66ab0a81171c693eba35ae8d374b1e1c7dc7330c2860885cb580f13820d54fb6eb060613c4029c2a0dc14db68e3c3b8125169070b71b4d14e76881e6a3dc1ff34b1ad46ba76d31e7a4ca12cad82b12569d51c2463a2112ba22d3b534c0a1db3e9c5b3999e87bff8d87407fe7ed99e8b4ba18ecdb6c560c94417326b04af27ac4a3cbc4051544ee2b661a05115ba3f3e98abdfd9f6a54d140bdb52b0cc945a9aba3fcf2895a40ef6331ab9ceca93a7f34d13cd387ff75250fb0f2f33fa6bacd32fb984a5b0113be2b9c79e2762a31380617a4f861c0a35845efb748529d469161b2e1afbe2fee8c86352ea84903956458d304e2f1c7a143186ca6990d7a75a06c2dd3c330acee06c429c76aaed597e70c756e8b1563cc844efc62acbcaae69adb2157ce01a53d637060aca6dd586e59c28380cbf2cbb549c0476e4bf5c215df28c4f86c5bbb85c548aa7b4ff24c5e0cd4834bcac7057e3884ed0c84b455d03e61984b8f88af6ee6a9b882c42993ab3fa1ceb9d9fc7aba81b2d4c908711cdd3edbef8b329860d408db34e2f8d5653752203b18b0448b1def5d7c9b78e2d0b8d3cddac630246d106f6a57b1737c7ea58b8e854b35fa742e5b8006138ff912ce8d558d1e6ebb6cf0a1f75193d263c6dcbb9a6b7becbbabd57e8db2918e7e1ccee0f1615bf4c18e87af14fad3c2ff062cabc549512b9555903f159b10892e0fa48ae72e062cb57ccf262f954d947349241cef007120c0df4334039b33fd06ebbcddc1bd62fd15afd4c913876981f2ed5fe3ce4a73388436223ebf6e4593178d42e7c5f48ddc0b8398581c20022f444f545e9ae09d4a355838dfa3bade1dc45d96be6d91dc1b71a22031edfb28a5e6667c5ea4607c746597699454ac68d7af4af78744f1a5ce8d5f352d42087fe8ff4ad266b054f9cc9869d8c087fd5a39c966c4aba2f467d672fb4cf16fb21d6ad54721b93c37e8ce4c48b66d3e4fe1efb36db187c015c78009bcebd9b83bbac26f608c0fadfce6c32b1375e580337064a10ca04ee9b734488aaccae74ee491785e527d6fa2e2ed67c9d6da71e1862c79cd5e8761ff9a008e846220ca02abb7827d568a15e28370563c337547e4560f332d888b3306f1de0cc618325ff3ac037c742e8cd0062b92812e783d8aa43c10e00bc80764d41d614b6968de5b3ef234f2f78a6a10f2f182f43b6cf4a671944c519a34c2c0fec44f664db53935cc7615f43e844372d015e07c4c3adfe2adb701102a843db7eb5487cad5d37b74b9a255a4624f42fd4b13e6ba3e532e75a9ebef853e88933a10cce6f6c00d329b42811018d20016e79973045ad49fe0cb816304f2ab27fdc701180e92c4b9b47ad2acb77dd05746b93c14c0ef72819b6edc9d5ed6cde4340c4d0dda0cc7d4ce39062f34e7f27f43046ef7a1b87898a445ca8bc85e862a68339bf8995e5ffde1cf52c4a66da90ab993dc2bf80fa6040222db68012dd454b00a54c538b47d26be7f41f030c06e5aa04a7c699419336fb93902164a71e853a63ebdda61bdff54c1ce34062db6c982730cfd767138235576d4c0ab043ef414fbd1090b7d661afc590a526d95b320e03a729839adb61087abe4ae678317b137a581f4c46cdee5b582d7eb15148982c50978b2708ab9b41ac29ddc76f28e502672ae257e0c661d42ff827085d0d68d92d81bd8e828e4a72d82323bd991000e769c19e565e5b293184b777b198a61f3bafc1511be6711aa622128ec0bb2a5070d0bdc23e159e423ebcd89879caa9861ed1a5a8054c64d5177727cbba208372cc3e5f57e9533e6e0b2ceb41e787d6181307fc34296204514d68e965d6c6966488e4116593e9555b459acaf63738fce8acdefb614d9a1936341c7aff1aee17b1b0b303c03e496a6b147dd2a62a8de3e44ed9d2a4fa89a51cd91229acb6ed61b7ae4003e8f6ef8e6beee115cf823693c816cbec34b1e88414f16a0aa61ad3954932f840e7cb8b3ab1c22bd09014201e6beda2506858c4ef310e314f6d2e1b2b483a73a390a87d4e05872cae248911a87e5f0426982279b586e430abfcb21f5f4ff23db939048a74708efbf1a5113b8020fff9cf9e913249382c2d796b70a654b5e15b44741deb8c57e24f382d88458f11f16d3da45a090e2b1bb51258ee1924e928978e784b596e04ba5d9e6e7bcc0dafc3f18ca24f921eb11e34064bd6a84a07ac64bf28c5683574fa279c14ae991332ba58ab3bd17471ba6a0e97e3dbc73b6a00e67eb949caeb80e339105361ec99b62db0de0ab4e3a16f6f9877dfddf8d0334b41a8d509b9a5f683f093db3675bfa7b2726f74539f1a1066082b172dacf99776d0a011b7ad756a8e4cf53f74f3ce1c17916d66a5a6b8ba139cef6fd80aaf49ada0d80409df996090a6cb9666c568ddbbf48fccb5996426d70a93f4b749a6447f0052f0530aad6bf63981c0e0100c9e1fae833ce43a1e681ef7cdd37f87b273684c63d0b095038ade3f0f4414094d1cb4ba351ed9faedab2b32c0c162730f42d71a56fab2000613f61aea9534406716497dee8596b5d8d4a6c4cd60a7ca9e7b52fa0e9d76e6cc721af86e32aa2143aabd33e6372792302f62914f9a7b6c4ea3619fe0914c37453caf2697864fae3e5f82fa1b1e371cd9014377d00f37304ee1cd134610cb9534aab62b15105470b3af55b3175721833c039d449a6ca90b4198ca04ba0029689e1434bd8b54e083e4cfbd34340d419c5b9ec7064ce600754f4be0dbb6b06573a6cce698445c72add8abda2cc24122c45de1f4d955516e1ece3c43d74b18109ec7cc07acc15e39aa18f52522d86295faf7d708f30ffe04659704b3615ea870d0768fce7721a8433447707953192201a77bdbaa237eda814de29b44eadc7bfe28fbabcceacfd13b31799ee00f0ae3f342b69ae9bf8e35c4afea60da7b7137dbefa0c1473510c482e3c3d1e3e9e86ada401104543929d5d75671f03f0249ea123d25532af57a5a54b8b1d31a9fdc74ff669b2b6d44f9cd873839cc915a7923c2a1cf947b732779a9f2e9ceee54f7157c77c25c9e33a54f2445471b0d0d1a02bfc6406c1eaedca0b2cb50329caf3bcbd5492f471af9ff99f0c4b2f891793ca23ab4890279cdb6ace4fcb6242a435e763b67f8d1dc2a312eb3400438c17c260bf551a02533d32ea6e9dacbd005421e8a087a70cd00261534e122b067d2a3911fea731adffaec49a558299d661a540a41d44b50330e68b5a0b8dd06baced84e841b5f5743653f16e918b5b7a7f1cc3b4d90b15ef483c139c8d0c02c03e37556624800b408fc5b3a2d74e5244bf92b56e11edd480f667310a661a3e093039268f3fe31b941bb2a517717180248b24fbf95c783bf2c25f3fd7a4fbb1dc2280a3bb5ea1fa0742bb7a3296d7e0b4b4047a5f109bfcf1200b6a447198cf8cacbe5a7b54e1adeb10bdd0fa26ded487df9dd44eebfe97826f046a7e04aadcebd6988c7cfd378a190fa5e68f9c224d580702f527e55fe7aba0546a6735b2c93cf29aa0e2b9316a632f1c4354de0774c15af46eb57680fdeb063f82619d48936830bdfc38cc561783c76e78c178b6b1e308ea81e71392970403a07a61ddba462df0d7016d26b06a68eeeed626e05eb6cefaf12c2ed9be22024767316c14f54597a4ed5c40161adb2d77732496020ffb43a6b6ef338340c37e39ba3321322d045dc73d908eb7953baf2bce8e8052f1117e0576c01e470a327933f4f35f57f42a81dd58bf8a7cf7f4bdcd6243c21e92f71f76c9d7bcf521cb48515df1d0fd7fca2a364b146181805c01ae91256b12d9b6cd1d0077299be568d65c2883d5704e66e6e6a1f22451cfce8d1e538b94a74f345c729071ce3347b50e943a506643383af2ad60df48bd9b59157e652ac950114a01ee3aceaaea5c0e0f68a8e3226fcd4d73369dc435cc3f53c2287e5e6f519e632789331f588fa75d5b37638d2ceb145a1d69c02de6b8c357662125371a91f8303ca7c08568c8a44d091406ec2f6311b8862a62a1c23c282d0de481f9a8416eba9f1a3748498d0e998f6b0f015a97940f14a6565066a3d9e38a764d2cffaff2ebb2b8d71b23371a287245d9058fc70ad6a37df4ffe4072f4858b94fc68fe605a8eb23373f43e3ee810aa2ee19facae77466e6232a5141141cb548c482273f701f347fbde6fdeb5e772536b1c84e55590296adbeaeaf7b180ea529c8af620bb72276501e4efbd925ebb98fd10f04524177bff969f74dc359f9436ebdc35180791f38d32c9248b0e93d18d0bac9a6d6c732981b5694ca0070ab66248107c9eb039c5a9fb004435d973cfebcc11f343b3d0161967a5171525bc57185bd4693b443e451ec503004fa568d7239392065ace81026962a8d3a6b817cedc7b90b65bf5ec8620cf252024ff370d31ea4847a309895fa6e39b60afe0e0f6b6f6cd6095af779974ec4705ccfe7606590f767ec30ddd62b30a44cf723a7aa406f5cf5d4c56b4ccb80f286b30555d0dfcdefe844993d329fbd00d2c04ce695cde92656f8c08633685c724567ea7da88afc4bdd3be848db9dcccb921c3dbabf6195a1a1c4fdbead14e9eea6efe242e7dbd368880583ca43b35b944f44918499945d98ffbcbf5bd8e50aa0cf901e6cd15ba31c993ecb89a9b2ce1bbc2bf3be988bfc653e54a94889700e10f53fb535b7a0e50626cf9d3dcadc261c0dd7bc55bcbe7a2c81a57617154318e24900914dfb6cfba9c0281173577d6c53158a70630709e8ebdb0d06517dfac1e07be70087a7c5fb7dc3554d98ea4864b5f5532283a9daa7b09bdc8aa51b1160b02f2e95b4ad9208b075529fdef7f7879def181386f18ce53604490db9712e9111b42b1b3a8ee76285feae76a774451dd182aaface6a71876c66271e1f3bef404780090baea1743e0dac41c537a2a7feed0460fe77b0c3949a6c58abb07bd946387c0062c6fe9b00e4236abf7be7bb14bf83353316df1b7233485c9ec128c065eacd946f26f78a797d2cf183c3480f0b76bfaf65d758e16ed026bbddba488e9d986f98c0a84af970ce7c67ada13fe96831141eeeb4d8b33b21acbb94b23cbcfd0d0115113cf15656a90e91cdf32f2727c5d3b22b037b42d38a9e6ef7359de0eb1b4e87668eaf487c1e7a4334379035cee98662f67a307290a82f030696df2c0e46a775fbc5d7e7b7e9bfa1187ae78baf30a62a4650e2b77cbcf058c9286e3f9cdc8d6de5b3553c46f10bc72f34bf2f48f3cc29b2cb9dd8d3c3bf3dcf7019132a1490928649ec96ae0f51fed927f69d2967a139fbdef47fce16bdccb1c660a514c576caeafd8583bc8fdf0c3b01dd2ab9930d5f4e228194c7b1525232ed19f7d768a0c24881f43e94bafd6b3ec5438920ab6444947e5126b054edfcf822fde02e76f22ead78e5e4e0fbda11149e633a517ff5f2f55e74acc4bc142190ba8dcca8bb42e2e4bc12ce746d07792f8cc0d6121f65a857a48e0a9ee854cdeeeaf2f6bbebb74ee137bbc3d9f883de7054eb097930f724452ed2f7cd77e6db51e7497a1ce8027f99ad6885a7027011bcc921abbb33a891703d183ccedfff8211e847ce143433a0a7c17867179599d39d9d5b45c3843617032802e2dfde81debc63cea60d1bb787d14e2d0b83af62b034f93edabf604c6f5880dae3b77ea9f072141fb942c2ac1df4cadc6cbbe3e4555f84c22471eea79fc9af9e90fad691aa122bf9253c773fa634d3a393c9d59d42ad8aab5cc5c6da2fc1cfad12f1430f415a6d63e79ae9efede8c07a30b11343bbd3b8ea65b2aefd9a3fd5bd6a6dee1db65613ed0247e40ea3b370309d1e7ddfe88326ae645e31838433613541ef87b9b560b7bf2bc7108e3faf751abae63ea4ff3cd7914fc2d804cd08af65c86dbde4e7ebdfb8636244f49de3f490c12ac34865e7db7a6b8eb6ecb34d3f307718529abd3b9426802a4024e9a56f8f1fd5b88bedf2e885783e44dcfd6efc855ff730fb8ab8d96371c2da74ff3d3b4b89ba9fa3a8626fde7a8d621723cc31e5ba3ff87925c89c50e1a348f947649ed3830dcf6bbda109686961df8dca0c237ca4d40279da2d0178d30e83afcdc33e2b1557be257cad843897a48c503ff0a966de36faaa68c04391e6408caa5114d306d174feea4633f9e2ec699867a510eb7042aa849f203e5cf4aee11a568592b698df9131d70ba20000eff6ade93c0f4a231217c5ea7e8a46fce6d275f6923c8197fe9b1b86a7aa4903b69ced0e4e6bd3690e4c6d6d8eb5cbf9ecc2dd673d39ea1daeb7017ecd83fc752ec970cb277a60d2311c14285005099144902a0b116d2d0b50e470bb1ea7102c2e472a5b6015b1cff70401473b2d4fb072256cef0a07bd967babaeb06d82e47aefbb1ffc47242398d907cb8e2590b80acf99166eb2724c9f76c8d61d93df7d22ea585071d4b747dbe60b8d0cada2be3cc862bc1ca6da767fc4c6910c41b7d095b048c0681aded78879e6375c248761a4a8ea81529068e7a279e03fa2e23423a18d537a291313e23810dd86019a9c6d2f4151655fc66bfca077542a5154ed093dfed963aa4ffde0fe4d5fc5ee78a6b8f48f029c2bf3184da9e9610c4c65e5054d41b0fcf296d6fdd03acf2b08feef77a8d065623dc2ea65c8ca7784fb689676c5143360b5dfbba4e628ed668b99063436e869c7c6314c779c299fa9ecf08dc5d70ede06ea67e4beb397b1d914775e9b5ddee1db9fa83d9244886f13b584601f5091ffe0821e162d540e50830c12b6cbe6672b9433c8c64ec8aca02d0d80e5169f2bebe8d37bfc86d9cab285aba756653f3fa41445d47bd8f3ee91122a8346e7da7306a6108ea2baa17ae0e9112c748620c5a03d894173600e9a565b46ab28d00ef007fea8c6a8f32fdbc7d002d705f1bf0af1599f7cafd9765d740ec8142012e9f22ec49effe04ebb880087bd4dd61f251f3741f7e6190bf6c91823cbfea52f8476f00e36de9be1fa1a0804e8a099e4381f8c4d6e91df3a9ac7a26c5cc45f7ba10565cbce17022259238b6b18a9ab223b16c958305682973c7c684ef39c5acd6f2532cdd6a95b644e5e1914ac49cf3209f12b84c2930020ad63f5e03126bdca7d7626f3ebb7d30ed9867f3bf0fff3c3e239075e12ed682d2f8f026519ecd83c1f896af947bea0fcd64cb114fa48c0cf791aa9cf5a3b06d09720ee7a298d9431417167ba77171d3811db21e3366389e36a7a06b5620ae906b59637a27bc19849d45e3389ee1b49dc6f2e6641cc9f3e16981e2e827aba23b700661bdb8690df7fe5466bf768016039205f7a61c0ca6a33549cd125ccd2916938ebb8c5bcca9001ac207e8b54f7f22ad02cebf6f74933c8bef76f52b228a342a83e9d9c0885ba7781344f90041bd4554dc8e7fb55211e4c93327a882ef600b03ecb0636e2fb7a4d5a4341b3dde3ed142bd329a412537b7f87faf3dcfb7393aa86d88f45d457ed4935c2187736a240d1f4549ac8987db1dab33afdd49b7902e8aa9bc6609a002a7c8858e24b65ad56e5029884bc13a9a6c11383fc134631d924be355161cecc204158bf5017f705e347221d6a7997601bbcff59693b745af232524081f2c6dac6a882344d4fd1ab903e45a69d47ec5a85798a25219068bf0d150439b3ea7d78e864ab705a42808f1c1e11062a413da0ee3dc93ebbac9688282ceeb25d3e966351db002d28644c78e6936efbda36dfa648c4b190d2b07208bbce6bb473f5899c9751d2592a3536c2d39221511ec6bd8572332d57557ebd79a142f0d3f4bf6b8e660182e9266093500bc99c74920c67680a9944092f485b6cd47b4f4faae3a8f77123e4f5683edf12d878cd8a9aef1e131f2fb090d889c606af8790bb2d23214d2c4cc5092438770f8c045cb2d5a190ea18075fb4f15f59e42c40a8a48e2a22506f95dffdeec8f3ce23523c91db39218a2267599cd7e338ab5423ff3fb1627679a2d726647a397e82f3b43b8e7f020aab9af13ccd57abfe25df7cc34a5a5b046458f63eeefcfa18e27b2ed203049278be7929f7ac9968b4b5daaa9ce9bf7cc7e30efb8b29eeaff0eb7061656dabfda88b23280b9c175b0fb0c43a62c69288e03a9dba4ded332683c730b7285750d4c0aa86e15b4e5c252404b5947f7bc9e68efc0251967582fd93ef754ed22d38cf4a8c67f083d7a0fa8f33dad1b3dc759e429ea131408c03d03f0e9ff68f57443e7d676b762f58319015acb6012f15fabf0c69d4d1a55bd6e92b9c506f7d7eec0a391605d7de74080dfc7fa638a2775faed94aab373720db6c3efac29c61f663ca3ac775b127ad7df1bf8de9535e351d951145456162f65a332562458f844e8bef2ea5ee30465acd05228d698dd6b010ea2e091336ec549e355310e9b190bbbe8f049074ffb245ec51d9247ea73791b60f7e40609914ef271a36d8f11cf33053d654f2e288906b224588b2e2d772c95eaad42fd360da7569a8fe5a6c35da3c3f79db9c90c5022a1ab913331a84a37b601247748a2bacb0bba6ac347db4c7356fed128d7a9de19bdcebe5409e834d7d6b56d7b88d6bc61eede5e8d4fb272aa5fde165a4115e37254d623c7509c1e4a0437b3263afd36b9a896bf27a0e280f0c24e31d327459bbc1958c66d093961b75577919c3d72f751390ce51b2c14be08ecc2e7d3087898057dd2d648dd331cb149ad824f1a4af3bf87deb2220d7048fa713443f917d210025bbcba0adceb1d465a436b4ec8a76f1327b52088ca8500efe499fd3800a5ae6ecb279e02b4a0c7659fcf14a991f43b029553b64c571e3f61bc7e7e6533ca3e3d58171e6d16f8a384dea190644a4a32dfbbd88cfebbd7cba2f58c293900b16cee1ddb3b55add2d29c93c3172d4c1fcf68d748db110628395ebf41caa73a2886b78c6594fe608a3eec58dd55171dbbe73c2c2b378ef8608c246cd6f865047e283e7f619edddeca74651f575b8e20d4a7cc074b39fa69e3960e827b6ee44deabdb66be33baa8ff6721ba335dbd3b0d359ca9ee8ec2e621901d4cb4e119eb3a5f332423513057cd417bdf41fb20c692427801fe9dd72d69672735b26932806d550b9b9401f2c583624289d38f507c9fd39733bd4f56a697769fe9964af30b4efd34c65b7a28b870db170825550098b912ae24750f11a0859dbe11ea6bbdf20af858d3087a4d3413ecb68910702ec4d3f2f09e4149a6e0a8baf343fe17effcd132bac45326a63f587bee71738fac4420d7519d7f201d256225f7a6352165da78fb9a7b9b94de46a24d5faabae65ec0f0febceedb7e678825448fcfe0e00839de94cf1121fef106c3bddd9434fe586f10ffcdaf50a033cf8db1e718fd5aed11f4b4b17145cfb5f077283fe5ed5e77acd17a72ab974ada658df3a0ba40ff584a8105be1605a33c0182d5c4e1b738454657cd4d220e6a2d150e5664f2bd054df89db69149529f1fc03a587f7d93168a779cc21f3574ae94adf24e0930664b9ed515adb787a4c8f7e2795e5a4740429d8eb429550e0d93153263707bfe3ba937d21ee6d6f8a45964ba6f9b14b5e7f4e918e89203c823bc5dd7a4c70beb5bee3d6ec593e80e46c7833e6e1ee196ce2153bcb05f6d55a69ce71859c2f7492ad34c6d741ea9bd2dac33aebe32ac8b1dc5d9cb3f5196119ed866bc4638720a108fe668e09d0550fcc35f4a486446d7cfe899859b31f765004fc18a1aff4e9e2338bed87eebf5aa30dc3a66ecbe741f48e59fc1e2ce410ac8d16b8ae459f9ae6c3b4a8cdeb8ac5883882bcea842255f9f157bb53f7e38a0934a9f0c0d170a29bc3f5153acbf25129848ff75f601dac1422f7c05d060b51f868b152d41ec0ca31b0d0b6d261f226de6a635e030a728f608910c006e44bb6549a337a89b710f0d0f9d657572d25a3ae4af996ea019ed86fa6e966365886e245a20e4687f293becd5c83133df5e7bdde7fee8fe549e5ca58e142d7ee133f7758e986248048a20f89135b0af2e8112681ea82c3d7c74bb6cdedfc7888ba5bd32e07865cb279446ff853d0654cec51514da2b45c9629566aa7b22033765e4e39f888f7625981ad95426712e3ff1152a376dd3fe00eb2aa1896dd5c6fc6802479cfd8ed1fd8d54c4d3a926c22439e50e252cb7a8ce925222417706d6bf3a733353f2d605dfa40b77a6e88382003706efa0d9c39c3b20e206c1ad39c23a9059e9f5f92f51d67032c533251ab63473aa2fc098c64e78a9db2588424aea7965308946f8975114a3ffe9ca41db983479365c802e9fe434cd2836e433ccdded2afc11fa667e1595e910dcc53c105716eb401148ef9009a5957821208aa505074067777d6b738a33632dcc126fe64a7810fcb7b6eceb105bfc3aece8d5cefafdad9afa14eb0f262d6454a5588e3694376424e47c2175d5c6c06fb613e75a899bc40a6c48ab56cf9f8d0f81cd7e497b61510cd9863e16ab31cff3cda53035be57c09e7125646590ebe9137570601924c278d8bf3c5f2d9a5284c802e4e4d4ce3144a9346086f288f4ac273131a32542a1fc4af7b271d8e0310578ba451addbd7446eb9334eb5249fd4ae6c20fd88227774849ce590bf9393b630373f4c2222308719e71aac6530ebcca5aa628a97093d581697db6361a5e36c5b84540440bf65d5d82df90de914029a4b2cd48a781938cf797a18170fddd2f021ae6fba8a7f9267dd6a9daaa0bb759e143a511b271b667eec823c7b2a6211ec20526060b974f78eeee194b9bb5aae90b70760967b288e42a930ca6e5fb322b580d87e1aecbbc0f5ae4fb80a54e17fcc2d7e919fd2ab5b4b12be78dc56693e969cf04d70ff0fbebb2d2a72204a10a3a6307fbb0a89b33aad8322e64539f3467ba98bd1480813980a57bb7f32d0403c86b21e54e4653052250b8ff60b333566a3a08b4000391afb49fe91033e77d6380795fe40316766889cfe8f524575e78eef97452cc274a95531ec41b649bd49a30d0b04715ba225732c3c71c014f88e6e44548a2ba3efa2dca0b8b4a12376bccce20f70c269cdc3089aa5029a4a579abf1dde05aaf0451c87d05d3ba899f25b49ce64ddb0cf8e62d583981476ab22e407bf000014f2927c1284a8e10a556d1aed8ad31f7a308806b5bf9a9660cd5b71b55260bb6ddec12de6cbd4c09bd345f233f3c6f1fbe15848af630d9a89abde7e97cb7c84ac4934b1a05453325efec344a63e238cf5a332f174af879ee04ff228dcd1e3918f67cf0bda71af3eb251399b27e03273f0b1f9d4b41af42a767b9216feac10f5cd2b004f183968a759fb0b1fad34f7a5cffdda3ece7daa7ee6fe859a3dde8839f203808132dcd1049559426658611f47a8e4daa464db57468e201c6195667cafc5ef1842a91df0132561cc5f804f2d79e420b02989fe872a9258c8e8d2e5f3519d493c9fcf8f7bc73c51b17b7ad32d1c13debd60ba05476df20393f080c2aa75137c2a540bd0e1d8579a76ccc4cd95e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
