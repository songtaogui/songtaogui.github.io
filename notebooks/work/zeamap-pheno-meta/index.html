<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7de75b619c9bf8bee7cb6e3214a141150021723b179587ea0df7befe48bd8e92dfdd1420f0467a0ce700718e8cbb029fa3426802fddd36bff2c90d8c60c98ce121a5d3f6c10ea21ea3fb34adac168609925dc908331e58600c1295c96831e716da2c702882e0c245c976c5c5ec5d88b27890af794478a67bf9eb0745bcb994a4bce31ede08249a111777cc1d378215c3706b61f1c2599ad2cc58ae20e53fd144ed4653f489b2eebef91bd54fef3b4531919a9ccd18463b66b18b71819e98cdaf3d104c73b1dd8973a2acfc8a19c820b82ca622e27d4debb89760d0ed5ef054bb43c16cf8a8f42a4ddd952db22037b87c634c7a2ddf3b547a41920a3716141d13d66b7788a9ac610bc3be15316014fecc716eb8d3aeb322a85efefe4238ebc4eb0ccaa76a95f358bde7dbf8aecb10e005cfc042a464be100908a52c58b18e5580bf74faed8349217cbdef53b03d62197eab8c5b3de7d7996cf6ba1e70fe098e671c4495120af9a0d3bc75b2e558782f6ce06074c03b370566522522459381bfddc788b218d42429bdaaf5f328ae045d076ee62d9a243532a126f2c9aa9b7df52aa39e82fee8a18877e10d05056beb034c58bf5d6c0a0bd0882f435aa7d18c7c65cb4fbede12ca75e7b098d899802c1f441358394af3bd58a6f90c21b5569d3c45944d3c183354266bf5e8cbd10caee5354275099a4b3b4d149259726caa0a0fd9e1988a8f5c921fe1c840a1909aff08681253477f51ae4e412ffdfc98011fa6ffc4c53c13dd41a0ee2b64b6c59437579d2b86f605b53b6e6bf5184b7b2aee32f96acf33f2e6c40618ada1aca7420df7b0df1bf306f2b01d01fd5c6f926fe48704d87b397586aa4072118c57bc9e4de7816af561c8e6afb14b53b985808f4c80c0c38a8f18ca61937b10bc840812ec901ceca2dc56ad3ff7a5f5e787650f58e260f48cecf0cb73815cfa016c356474894a65402f0568a12e0f49e3f5f01dfcb2e430eb6af131f252cb87bb33ee44871987a56b6cf257218cfd7330ff2c0fab6abc3fa02277b829904029587b36c1bdb867504573b6fbb071905c771c9e3bee5c96ba72c63a11f7861631d58c5e62ed98d2f4b5713afa6a1a70508313c92661f974987b40b8c0b07bd558cd84be9d685475daf46e32f3ec9d0f93e94e540f580cc76dfbb4312ff163da00745655cbf823abbd32063fbf56d67b0e5b0e72fb7f6df46b580c42ebb7d24168a5050c72ef4c7caa617a21ef84adbf4625758275e5abc82d59041fef933f234aa5e3fc4d8c592483446957c3a604f426136215b693a93c47d2693d1384ad1a363e887e28da847f75611ca0986a39bab28d6ac5ada7d358152820fbf6a464054d04f08805bd6fd44e64064fa8b9247bbd4f3f39b0c7ee0efa97cea16fe8e9f573f4c614acf53ac5ce1dec9975575e7ecf017bf9b6ddf84664cfb3522edc5d3f74073c98b15174a7c4d811e9584e1341ae67d9745a2e767aa8d8e3a0cfb4d244a992a9bc8c9e05e67bada290133d3d3c237b08c1807476090d9acdf3c0162f1932810b635598e45212ed885beea15b46f665b51d12e6a17467bed220ee26d700b2cf8bc22dd2ba863ea1186568fd47c197989fb28e33a96f9198843126355ad902b04e609b17f6694987c760732b80e9f5545955f0540ccf46f8a134f9c13dffbf1e51f188688b6bbb694f9ae73140fde8fea8181beec402667115ec7c1ed5d83ae38c06df32fcc112eb4de3dcc93b22ed26cbb048bf9f87458fb03bfc09db3212bc0eb3dc2e157386196ce77e27a7035068c27985d0f1255db964bb83244fc325587ca35dfccdccb4e48ed1e48f02ab89854fb8803e514d63337542c5cae7b8551b3b2b390d09404121f2f0bf5464e9f60037187b34d570a0871cb353780fbc8ab45bf0606134755229468286e1dc151ecb4fefe13f27efcaee8eab628feabe2dad1650d526b5501cfd0cbafd1dece7c64e1eb37c6580af317a311e070f8e3e76d95b111d57e6d75e7062f01b2591879e597f3a61afba8752b3473c45951960f511e1cf9788435013532bd6ccd6ad3473b9fb89aed0499d9c4d18d7d94f291b37433e16c894792e3b6ae5e81c8a2deb7f246e6e8b01ba3d9b1997e68f70df885a5910e0aa7dcc55681c5fcefd7368e05f2fc4f587abb8a02e1b2af416ed6c1cfa4fa31dda37d73e8129bfdd91ca0cdf908d6d57c48fe1898832fe4434c59c4f03f8c0b2eb679e4712a342afd971d7ab9e6a85417a7c61354de8b5519ee41f8715bebf70ab7fc6a83e533b00d1b346ff43c9c006314caba470124ba9575403c737a4160db4d750cd7144ea5163b326b8c8df397281b3ff6b20831379de1d270281ffc46bb5463563e8f3dc801eb0efe43f9786f82d30da8757a5e0203df0f69997a46513b5bf380864a11347db05dd12f189fb3469f854bb762a64091f1ec083d76e18154e0d076d403a863025a76fad0041991ec30da644077b7b268804287eabfea423a4e04789aa16f170570b493c07700ed3188834bbe89a02284b1a3ca27a14f92ece5839337fb595b62a647b0e2607375b0a751f73986523527ba30d9cbc52cdbae86e7a535bfcdc7744546b7779010125c4689fe115390af96f4dc9111cf6652fa5a400a058e7f407e8173bb849d53ac0e0f1ae6ba4a30f4afbe742d68d61b650acd04d48db23e5753c3bfc4acac4de0824e40c0bf100a38b1c8781f25dc87940d5f8c5f2306a3050a769e4a111b7027f4c3a86f650834be35dbb6dc1ea0b15406bf44f5726de0f770fa93d0cfa784444e2a88efe5766751131fd59b316b78203beeb93dcbcc50fe1b53691ec8e0ec414f5d346f1bc12c6d16fb3c5c2f1e02d2fe341c7f2dbc15b85dc7460a00dbf4fb29ee59c2fbefaa37115fae3a5f8bb009262b939377b1d9ffdbe24e144be4a8bf01ea939b0c6b9b7b55bd9245eb1cec896f0559ead85cbeb6bb0deb62315dafda53a8b0e2ad47b7c3b89b0122466ee54093cd06b7a0dfa6d246bf4411c05fcf41aa5ef66d364c2f255e40d0e0dec77bb51638675dd387ccd04f7e9f9d620d09475290096426ce6304a7131db5ada298014b6189ef739ba5998b99496042631527e926868453730b3470c37227ccbe983fbc5bda964ec440cf221155025cc0d7b1d89ad122a894acdb4b3679ee02826a6c30e616d39ba03fcc6aa79bf4c1d6bf1dca72d3869affa6fb735fa06cda728a14b47e15e3c2c295a3c2b658d900d3abd5e09700c3d4ce2af31e4aab73f5e75b76ba1c6ad2cdd028abe6e73b6254f843c0e30dff32adc378e25ce68cf36a396250348257157a8c5bcc251176f6378bd540ac3dfd10d7caae2f8e4f4d8687ea231f5ba7c0b8c42ee64c22cf796047cf46d4c8f3c9d95e54d7bda4bd94280c256840775b6612fc930b2883baa26a39f2117f1653dd974302faa0fb12d136c8547308a44908be3238912c9acaa52435f9fd4541ffac077b6c8b3f1931286da760aa33b66404192915eb25c4b6839b952283812389cddfe65ebc983d570a132a0043eb18cf481eabc689e406a60d3fd0cd7abc02d334faf9e857ad42a8e04ea350e3eac8255f746cf4ab360c6f97a5746b1198466fdc1dae506308c68275d29382ee8fa4239c6f5f2e401760a04e8af9eef91450d264c5b4675122936b98bf2bcc4cbad0c060a5f72735adf459b4e083ce53b190b82c6f6e6f43e8df5e1c50b11b27392ed9a8311db60f8ab99480a6c702a567441f433349f64c035e2b25d3db1d200fa6e2d1856d9edcbd3ba4dc568d7b89c2037855b3d806a6645e337bc1978ad79f0b8d6141c84ff1372a8ff0bacd3c3c3484149c9cf3f98f3db60858621ee1fe50e15480f3df46366022952653ece08266df7fcda644a1c5c0c1f4faf2c583f23abb32f42c4fca5dc1b330b28e6917cbed16e2524a084a93c9d98109167621d3177a62b2ea00abe5384fc806803c978eaba9054ba7d3c21615fcffefdfe165240047c4529fba7441c5ec67c2f31a36e317308be6b5a77d06a88ec456e09b76063181f5fd6451c1a3f0fc48c35aa2a4448a09bedf7a50d4d6fcfbeb7f9ac6f7af33ceb0ab2328bc9dd1d8394174dc99f860f25e6bacaef06a2c2ef4d6836b930ae83fc8361dfd47bc5c5227bb1f6c1f90a3caf6ce19d5e293fb22ff8c7d8af8ebdb2c5f586c5b487b97012fd7d7d292df4dd1965ef3dacade4fd817b1c7aba306ede839fc3c6f5ed117c8bd9dc4104abb91831d8e3c9d9234c89c9406bb6c204f71773fabc93d716c1790380e3468314ab685865e537a1b9a0f8f473e4259b9cbb7bc094f6246ac3d39b24facf832217332a126d7b4c54e63786a738c649826d83e293cd7eceab24267d2d8488602f368d19ca3249ec9f0b4014465f73e1a2593541fac37afd4aae156bacf52abda1dc09c22f236f2abc95ce2918a542d6170e88a95a1a58b1520c721bf735683eef1a2a90479116a227283d15a261b254b470d98c1b2f15ee17cf5883e2a5e7e61279751ef8155ff6f7511a2851e4eb961b12a57f9b718d582d72f2517a8b4d51d10fcc27fd4573d0713a42d1e48ea63a3d6174b313256fe89b1beb7f309b1e8ce255f28bea70d32e6ece447054a81c2f156372c4650ff2b5396a94bf905e3e011cfa2add5ac9d334b3d8d4be9934d780ac716c3b6c088f7172d829ea78fab724803537f8cd2256acad447d4c6553032d6e59fcce5cfacae91d2925461e10797158132b818c997e580b6da021e32a4c81353ebb4cafb46734f423ba931ae0b911168219a8c05d00d739f539e4d8e95745da71e1538942ce30f99de6f18dffa2728b950bc35ab36392c7b758571cb6f5e663ea7faa443371b1ae1dc4da5747949976726c4b8442d9cebf89aa08cb3f0e961bd3e965e1e9f2b913780961728e9c68069b1ba3aa4c32cb74bb322f4f589f678a584ea7f830f8768fb54790057a73d5bc5eb0bb4c9cc5545bb97fc00ec80f748e58d5d1fb79d0746918a46ce77c872e41f3f1818223368506272e028c08878986cc3788066bdc49d61cfb127e82ed210475640d6c0885937a7574a0f973eb622fef0a7c53eb873df0a992bfe26db756120edd5161ede64dab3efe4c363fc17f74a3129c883e6d1ef40feabe166e5dfd774cdc040bfe7bee82db5c02aff9d56137002db87c5a2d55d5808225678ef269d5880e679fbe50be838848b4d791d812f47828d3c6051f5518e92e19a8364264cbc7f141df72169a66fbba038751444be4e295562655b5d6c22b935cdff18ae61c7e9a48b32859eb1e312e1f57cbdc26d53e506e11b426f77a836c7ae3283ca4853203a22942274d932798f3b2e4e5d46d778643506e277f5b3dcecdaaaad523e652aee38d1fd4c583c55d049855295264520ec4e039b93c5316108f03af3dfa91f0184f1fb3c23ba993a95a32dc7513405b6d7e5d764e942bc43d221932d1561189c43458d094a779e25d6b3a3b6935eb6419c5962028464daa077abc8efa3764a4b6d3e184d440c5658d8f8d9601384d97e2fc2c8da173bc5cfdaa8abf1d6ac73ef1239dc23801bf2e78d82c9b714d1aa2c1fe76ff1e94e9ca0e12cb5580e6b7c42dfa9707af88698ab16e36e757d941530cd3c7fddc612a7b72b33f22a07603c5965035de35fd5c172e31b41c93d5dcab9ed4e924532d2bdcd9fd9331fd6d7871cfdfad30dbbe8e7e457afff6956d905a9022ccca0ff2aa112d2475c4335aa493035c841005ad0b56e9c02c25a8e10ef40f2c458d3b983fb824f349179a666e290ab9739802954e1d4b081596fb056f1123252694586143d03411a7a87e4a4e462649f52afbdbfcb7a74fcae6a7d2999b59b66d06945f27511ed3843e211ec8ffd400eac1796ff08d9fe7830efddafa5b71439f76823850255ab19c6391226a818b115bdb743d3ccfcdd287a649106beedc8b095fe9d6d268271df59e392f0444e9e229c327c5a0ff8b71b68a005aed545105500b19cb8f3e2bf835597f67d04d864b7217be965a225e4791d9fd4d47d541b2d998377897fb2f493a862537722aca1d4fe57be2462d858e27e7bf521c71f56d775dd48fbd0e0f04bee99f586e35990e0be26ac74e431b41402b919d832c0e9479d844c0e903badad113375e8e7b5e6075f28478c81ca49ed8c55fa98eb580cdff89522bc8bd8d53aa4b6fb16844d32c224c9df5a628179b05f757b75f96dbbbd3249915bc8b6692dd04e9146f2459cdeece7652932270e6d1e750f8ba775429ca2520d2bafe806f2925fe365e6a8e61cee5a57a0d3e3343d3e7ec5c03eff3f9dfc4d5dfd7796b24afd7e26f0495ffd510d3e95fee8ced8958b924a8e9e9adcd3a3fb89699ceffccf3ef6f509c67b44a2bea60748bbf47a3a540687c825a0ec380c614427317380c4c0bbc96bc9d93d31bf1d220df2a948d11617e80c0928db47263820282223bdf4d9784da2d624faa751ef0760e0f11ddc90962dc1a287c610e428db4f51f90c796a21a8b5a0ccc0c493dea53a557f651615ea92e0a9157a37d4cd2a124d0a5cb885cd9d1905f6b9e51ddcc8fd348d2f5b364eb2fcf8f3c48f80c3e3fa347473c7c270052d05e288e37f977cabdc79b515d5f8587be9f9dd39b1a56c5c6cf49f0f85f6630b43cb9432c4016cc2402f605666327f018fe36ddc52cc9e5c6234e0c34d4b1de359d77966ceed7592a886d9319d284e00ff60b8c37ea0bc221bf2cbda96be0b544c48af2aa67ff6367684a5ae01f475bd84a0c08e84ad05e147a05e10511ad63a98d5852e0dd0721cbccfa602bd02bae6ecee85418e72cea69bd15d59fb37274767190fd922995518b76919b158c389ab504b163e9b5e80c2b5c9720ea15619d1430bc4b6064d5cfbbf68439f593f5a49ab39af0522e255e96aec6eb15dac4e0c55972e622df6a10db9ddb4679cd8d812ccb478901b4311eb33530666467aa6e79afadba58942f6015ea3f1c7958efa417556bb3cae01c31152f8b39b502a4409c6c3dd6fdfe0de47c87f0dbb81fa61988fad62f18fba7cb34c8b3ccf35c5f6a310a8e4f42f8460c0d49a4440ae4b37cdb0f601b011e1c0f806c4726a7596d91321a826648e54d4560c2acee1f42e1b63210f3f79a6f96b96b3ec314ce85b9b1265c20741aa3d7f0b65318fa27133fe776a0383f914501bf170d339757f48a9306f219a9ac533d4c603cbdbcff5eeb0b8703e0573eb470e0f496e709f5d56229984aa530188c32beab82f2c2c115c823b5d9857e1c2f269062bb81173a5764071cae2fc120e4d5373c492125137fa45342d5357024a198393c140f29baade8b171cc45a21ff9d6a13c8a44b22bfe2c0d01d13185d2fb57ea86303af773f5a341770befb865db75e6e59296b67df2419fbc592ef4a94d9cef1f9e523c2f06ec2a28b49c41db179057bfa72e531fa7f4301cae52f853ad3677197611061659f29e7a54b4c88f0de3daff1ba22079f4596eb6de6d4c608c917bb0d62135f5cd9decb99bc935543a6dd28645f2c836972497dd8049260f6d242b02b403add5c169dfbd0800a46ad58f7d338f2831b579793ed312757994c589a0e78ea9b6e6c50afbaad050e0ccbcf1beb5a005cd8283d2dca9b3c8365653e5f74d80d799410062c3d1789410113df3a05a186914b5847b1222adcbb749572de98dbc996bfd236a2a6456efa66ee3e3bb77388c736d824222ca293baed212f786e7ed39f032c967426cb6dcfa66974319648988e3fbaee9727ef5b7b2abf60c4f632004b87517667d4530a5bbdfb5584abd17391d22b4ade0dd3dd2c45564afa4b3592b4a975b47123cb267ff1309baac1f8067724248e0e688784c3cab41147471a6a82f52049f67b6cd872d3001819b557c7d18a35d3a20e63a931ec31c258e71e03289ca987dfa99416c18252fe1a89e55f49ce16d260312b8c1e25e275184618353465c5414e7102964ad89c5513d8bc1c29337f4c13416e368be4c57d99f708b0cb8fa61de7d2d26560d58f1f91925b225b834867d33a36745414c6acf9b439ff4ffe6af3235cf446c32fb271999cc805c02c39f80ef001056462f7744f8627ce1908ae3c6f4b880499cdb2a8c6610c290ef7e52d1433cebe105f4852f61c8b2f6b2d15a5b84f1f109f968368c7a91fec5ba77736986be22d4971d5856efd0a29946773e9c9030c4b457f669513f4cbdc35dd9349926ca20d01bcb7f4424b87cd22679f6bb5b9d61e9093047e6e48bc4500d6b9a080a4e74f85771844d0df4ab744c194835e766c82ffb1b1dc43531226301150077283cb23c8ca7861cfe822284f3cc4aa69e56436366e4e8f83191dfce5772616c77770be7c751e3cbcbed930268b682132ace428b63705163aa353f40221d36ddf6c807369fad5b6bd31674bbae75328fd2cc461cfcc2c5981fb659d94f8ff7e06cb858387efd5c1553807c97a1bfa478a218aef94c31e139603cb94c4e96927d991bacff76b4a8e097cda33fb2a3aa40731a6c3a9a49780fff4bf27254aed62efd74b3cf123f1cbe0eed5226a702f9717b63d294ffe5fa33f15713f1782f9040d24c12218a64367029e43b07e538ec04e88d7935733724780679b566207aa4e523e9db1f3b2594bd752c3a7335906a2901c6a5a2d10d6bae368ed9c908dddc03a8508645490aad4cfc0e936e7e1c6db6bbbdd37d7466d2bbdc58e4de717e31b8e1ba27ec961afe63fd1a34b883b171a6661e49f44366e6c35969b4c996071ca004f382d56e34b8761446ef02653a1f890ee2dc475fa46315a6729be550306a4ab72a93387c3853928d0e5f0255129bd2c5facadbc173eb54b1a2d85a4876ce503707ed1db8318afad6daeb03bf7d27d6ce21ee770f942bb9b0dfb32fb3433e2528a95cafd875960e4e6592c366b39ed92fa214bec4521ca1a90c12110e91dc9afea3be173d48586ddf78f89cc8f07cc803fcefce0e4a2afaf6da4d6670f81fd3bd63f7a2f07360c67f3462bc6760c66c862c95e384809cc79c846a90591b36bb2efd5f5678606b767232d4919ddbfd7a863d7367f143bf342748afe10fb25b5a47edef2492c3d2721db39b337b7901f77da312956b788647e56f6254fcc36e25c2e8b2c7d64d5eee1656c77e8e9a24f3fe7e86d2449f411964f08da14bf8eccdeb64fd46c6c37feb8ff51c73352fb0f01705c5d6f0d117ff4fbe0a1e2eb23b21d2b9be9121b63d9c5c5a428eafb6d253b7f10a99825dfea5954c693bb0248840bd3db1d10163127b21308b4f92c74fd56da8012dee60b553aa00e2ac536c5d1c5e0e6a22fa8166325e685ba7b06b4706f51f82ed38f86c97c9ab0e305e18b1bdd2301b58926b4a9eb27b292a3fbd4e2d726bbb718e555eaf10bf1c0157d7c6107db3c3b9c8661b61af8c7037d9a1abc127c956417d69b129a97b635af7b850518830c9f1e0fea6ec162949e3c51c5feed24efe68584e4f6604d811512bee6f43544159891def43d1afbbf49e2d46eae888d81dfb7653211c01c3fb02083ef635e5c6e0cb12e0caeb899eed5397785ce523b3133ef5e35023e3e813b12b352a94f7224cec777e6979aec32ddbffbd087936998f2a70a8ddd7d81446dc69c597629d20db760f0d259892ac00d7442b9d1190ab04c53b61407554153b417c1523cd46f3e0063d885dd22318416fa797d1ac4cc775a22e2380ca14cbca1ae45ecab920e4222ad75ab19a815435a0579f47a770c42e65fe2cf50798e9919579081abaea6d42a66b14b4cc23f47397c710fb8f76efdfead56409a6d83ed3d568eb405e9685c7888dca884dadbdf915ad3cb27df488e4ce7b5c36ab93ed370ac75c2b3c4d7288d2f3d2118848127b55ef0d004164b05e6e79bae5f62fd3c65e0e69c08bdfc3953bdd5a2a8fbacc448713e5842d220518c345f5d48b9f9ad8d2c7ae873122836ad99547b1aa9699993b624753f68983650e05bd0bad0cddde3e0b4ac4220dd5c3ac1f589bc0e3162bb2a0c0e999b135e952fc1724db3e0b5bd3d0bf91aa48a987bc4ac0616b179a221cc04c404c8f69d710cdaa02ced1ad6efa82e47248ecd66956e88a7960cf12bb2013a171fce7c685a9c78cda683a0f2d628c4aa0d18cd7664b6af11d8d22ebc4e5f3bb285103c61ee5516b8faea711937d6b3260269e4240805b66a6e969cc336ba0c5250ed23446aaaf7f47c6eb5d5a275d1e2b8d6cc386aa6618355389425800406fb2524b1395318af1e49c70f1bda6b7dc337791d7522eac0715709bfaa315ffbf4db6940d676a7f3371d211af650f8050a6a69af271f63754dd43c0846bebd857c4060e014c551e5bd6e982f28f1ff8748aae2ec8858e9dec7f28a92e7ba9badc782203b38124fd511045f89b531ebb47498d7497f837385a43432449a7a2e84aaf412c66299eafbb538e44a93c24a942488a702226c9db45ad8f725c7bc8e71ea921447b6461aff6038cf131732ad5c6af072fbfc2fb93a186d67de9fee185ceeeab804fba49ecaffd97e531d646a591001d99a2faae321ca3c959fd73ed5f1490dbd6ea4ddfa08cdf421ea36fdbab96647c5257d53375b6734fb0bdc05a623a6da6cd4f1d71198494627ad412a9240884b98ec59e3408b42b3c2303d5e327e538f3a56ed7759f7fedc50c0e3d7654d9ed4c4a5e97108f4634c85785370033a02db43062f04205d5cdb9c3e88a4b76dc9a5a0c6e8f2027cb09e75ae697fd8dc848a34d310d4d34dab0e6a864fc73add19634c817dcd538c8159923d46c4291aee8409a6631e945bb81cce6ada4896cb7f610dfb20ad610f3abf9c40ee30090786fabae4d4603e4206205501f97b98ec966d19d8ad955b653ff7e06e927c160a4940620093ec7a748b21aae73be8729d4a510e90420c203ade9f48178bc769931598189167086665b23e2c4d447f9aefc4f1eaf96730ad184a9b9883c17fab7d425a9d09e04643a8dcbfbf490d63d4a92aa3737ac5e9bbf56eb7b0b00786ed77e0186334228cd99909f9e8c33ff341885ff24107877bf48c6733e87d2898bd9f415b9769a91b2daa8763157a903c6562f9b32a9998c106d9fa1f51a85cc82d5d77d109e64965bb592a687c99a1ea51bd9f879c21ae79e24f4579c575e5dc6260f643182246ece1895921ede55a9f9c4b2a0506af73d530bee1777714e413d17536aea1aadcf654002b8d0b10b9010d66042cc4ca46f69d3e09a10b3c94a102076967420524bc0c3107f836903fd633ca54840998b8efb3dbde08ef01b893f2a55b0d567e4585225dc86eb87915ebf02f71a3b494856c836762be694048a748d9794f4b2aa698d458e108802aa60861d81a0d765e626276293824f6ce99ada2fbef6b2bf55321f79795058aed69bb6be1b3d82708b966612127ef00a54a249886284a9e9bf87d17d4750a8952d29905b59523487502906bee4f0dddadd6225a4407b33822b61b89de6acf37f393fe759d2f9826a9f9387ac2b053873dbea8c6aff36c6550a5e39a767b98024ed77d8d0cc6007624708b74666542fbdf89ca1e56787ece93b1c522b4ac84739584d6624f2ba6fa2a403150aed7181ad9155091d1972116f659eb2bbc065f48d204bbb50d970caec90fa3c691891f44413a587f6f149dd0508ffe3bd557dab5ea68fe38f22cab3d0a3af3b59dd30c8367017d051d96f34d93d26b0bb21fcb7c9387a72bc7e6f22de467b37ab07ff5a95b00d67ebcc2bbe25dd76ad6445b25dfe31948ece600cd38cb9634405da92eb0f0d201907822c3fd5afc1f3712397cd3e59483aaa73e02310073f3972e9e7365ab23fbfda32c768c820a4db80fa7141f31ad63a9045e0828bc481f92b9ed43c75ab8b3d369fdb3149e9291c7fe573879436d4cccc7da56fa13df817278b1bc9d81a495b87f9531b3e64f5ff29e5598b233efe048188c01a1f015cc7c4d617d420793ba91168f133ae26b8add6f07257a4e1b07dbacd8c3110ffa7d1dd6a05bc34de05bb9c1b71e7c165b4fc0f467d1990f01e549d94163bdd24bb5afd1e7327b7123a69e312a2ac807ebd65ec10234c11520c5450e7ba01095024056a9de338b15fbb69ddb1f678bbc919f34bbe84b24c3fc88fe9466a271e6a1f67c213f3fa051bd390b89c53f6dd5f3a17724d4774e08c2e0c3903578a97228ed055cb9cf78a01f558208eab5a3b01fe8e36c35b38846a5acf784b1b4ffadb7a1563305edaa216ea8c0ca102218ff4273387af79ca38f4bca9287ac67cff093845882b743160cb85e2df81890fe55cc9927579a47bf211706e1c908df48f27dc1fa6aefaf4089d6140e49799de27ace8b4145775960b470ace301ea788b609fe08ac01900ad0b2da75fbcff6c1d418770fc01f612b61d6a8940c5e9fd62b8f3080605b67d4789f686fbffcd52865ab56617fc7541c848b4463d5fc51036d215b07e1b7001b865ad602677e0f77fc0f4ccbbe76f11c3fffe40e8ee2b651bc134f2cd66ec68bd31fe44a36ee98a429b8153f01a7a4a423999db702e9fd77568ac66d5df7ceffbd2f8a08d34ebd149a75ea48a46a5dcc3a265ab405febd5ba2ae42ab8f2e5907b7efe782ce1703ee6ba02b292872dacbac1a1788d320f87796ba996f232313a329db54744d697eea7ac088dae1d13a1ba7084ba13583e5298cee5e01d325dd7a8828dbf9d94e1e75c78709754253fce8400ca2b784726a343b79393f57fc194c60514cef9bcf29896db587e57b72c6e05ca2f28fde96afe4c13f75185be735ead9d8aaff82fc8ae73c2b5353524e8a42c8d97f4a445e6adeb2e20222098bd831a03d8ff2507067618189efa7c4b75d3b5fe9768e8b3671570b9e65e00316362d2502367b5ff4ce582fb29323dbec5463650f8e214efe2be976d08d8b473904531d5dff77b05e79ec3505fd5e0d9c84bd2f52e5078b431b92d2f9d82f58316e7e19ed04b94aa655c0452e59029e6ce57f30d8d5f4bc57ed21d4227810a51e77490a56ae5c28fedbe0130b656a48ce213bc68b8f12e9e268d665cf3b13a2c38b781586fdcce681d48baad0da8f42956be7c981fe6dd043a765061392a871ef948c0c3d81da0b77de6458b76789c4345e50a9a540b25caa0c5553aa171f7c4b1ad480a4da5f75ca70d05c439d374be454372fb2cbd976da1e47694746c49504a4708168f7a60178f970ad6c07f744647769f56c376d7c4e72e39ab94a9eb67489f50b38783a92f6f11996f189432e6344a09a29d82cc1f083c3cb8851b5906c9f165c572f857d7fdc7bc4d43f8b0b0316e3d9ae66ca61f48e47ca0a82fde68f6c86fa198ae3300e21b24da5a5d3b6f147f92f670c60c89a43c56b313924d8cb5dc4a95543da09e4d144d6e9528e1e6b364249de0e41b5de7d75a2ef1928709fc3dc575f4d6ef4051e240c920388c9a361e162b314c69fab6ee45c72f407f94c8d6fe49c1d73f7587b28c2df288fe31a3d04654f4799d56052f8884c1cbabc385d87b8098f4ab52fdb24aad592e215a64835309c0a253101938abe893e402510f8bbf2f253309633efffab00c0bb4dfa710c6b451c6b9d4a5f8fee7d862a287ce476a90b4fd2778ddef98ecbe1f318b1415c3f7ff700b5e80585eefe37c9c21b809870731fe1019df27cacd1959b891f5b9c3c714dec39aa02a8a3e31c6078a0f1316b9d94339155bd63c36f2127bc8663a0724400644a843d729820c113dc6367cd0d3b01713504feecb5f9cf612b9100ba25624fa3f38b21a6a53bf2ad3a745001f9f2cdf065d1b33c59252168adaeb00c560711a9a769e5457cd823cb89cc115c42c47d8af7cee1ac9fb812db537f7181707d905ca6f48bf2d78aa2c7d72bdbfd4be5a971546ca02a2f9c6abc2a46311d8bbc3464d3b3036068ef7b2a2e7e7cee4f203cdb03d2e5184ddfa4f6a72c75654d9442bb3cba5fabe6034e4e566cce7498cf476f8a4ef6a6d96ad9d9525b843c40340c6105dc1543249abbe20bb2d3350afbae8e0bf9a49e9f48b75cca8f086ca8a8df9f93d0b120bb3e9289cef9a3c6b8271a7a962672dcab24954ad877ad44f2c1e7ac0695b186fde9a67a2934e3753a7d9152e13d3942023ec5db6634eba8504b2c57e54261f0133c9c2a6babc25956e2178e2af5140a9425898da6a53ad38a42b1527d37e9e9bca5a44d2fda67d355970279d8ab1ce210a02463cfd0cbe55cd467ad6f1e89c5328630de2469236e44b020db3c21b7e56d1d9f5280f7c3c6b8921f0709e70d4e4d2fac52e64186d9197c8ca24d04612f17f24efa9b6bec0fe04b75b32b852a6ce0dc70d46f1e23567709c6adfb044cabbb61b52770e35fbc46782fbf62b2addecc719bd7be023acd42abd301bf85ac577579f08500cde0b0f7bf31cce2f18da7e11484625343e6e170c086ee99a212ae1972eb8ecd5eb7e5616b69b47404e94306fa23f4a925daaf8b0a64af909576cae554427514c9fa6750176a6557f9a97fb3ae977707e84de29ef48048dbfb9711b9e7061f86183b0d064516b4aa427210241f8354c2c4c944ef86f61624170e8ac8c7d0099247eb8c66a641ecb2bacad6396a7f772b1982e20bc0836756190be81b6a7abd28122fa6fa5165b145ce6c5c41d6f03c77c2f33080b484fe496503677040b02fe42c7e7323902e4cedb8e98237b2c1ffca3b5f823cf9eef9706fc7c73d80a876a7530e0f9835b0a7d508f8c1cec2f8a998db86a36da8db31547d4bacf9c42eff7003c2457eb481010b3363547ea488b4d90c2e3264102fdd2365cfe0b66def7b5b87b7bb0faed1e44b3ebecb242c4cf872a7f63fe76493b76ec74d8f4b4a441e368978eb089f836c6a4929b6721b7238fc6ace18aff30e42d67af45518aea4d644e99a667a379be9808198fa04e2d7b752f25f2baef296317d62a5a9a71bbcbaf37df35e10ae0f4e0fb04dc669721d4a9da88deac0dad84654ee24e3f38959049a9a589df505bd1b9c2665453f0dd279e8e238dde1c61df615e63355bd4000fd1889734180e2869f181e5a8c78042ace43d4a6533b1a7beb41888b1590b6d37a2ba8b0f53ea637835db1d2f427cebbc40ae955e1fc3110889d8e8dd8e398533873377fe0364bb8d68fab7473a7d4cd3bddb5ddf29e9683b62b6e85506de3fc72928511a2e598efaa3b5e7402a300fd90a08bf98bf78140eb2c06fc6f4ebf2a7a293a96cb1cf6b5220ec996855f17edb508aa0d72d0d8b1bc124ec9833d9eb21e94c326613b24aa8975b2b0fd36f37376485b163196ac16f5f0a15ef9732bb1313385c24fa9c8fb72b9abb1cedabf60b1e51d2a081592e6f9c85f4f74864bc6035aa9ee13c70d74deb979c24360fae81306c6df3ad1a520e517685e0b91e1ffbb032dc2c4cc9c7d2ae3530283f70075f60403759a2358c1d4a35e6517ae239ebfa4de22d1ed3a8f628618ee22515d30914244c12a5b228123cdceebe659c82557b6ce006198596da026a7d95d696ebe49605be5b316c5754a1f18d66b4097ada30b4015db01dd51fdd4edc5055579f675a79d49f447b58bd26078d616297eb8f51194c97f18dbe95619d7407056e0a937c48e6822b23912c964e9abaaf651d601c31969f8fa8a5526b8190d73a19d0c89d97f241188ad8eaaad1caad3963ecf79b5f64306a85d256f6ffe6ece1f71692f2fa18e1a910e9000632cca24f701734f3d31e337d10906d4fb48c57311dd55e24a135371c27dff1df510a387b94a808990a8391cd9d283629fc31da2599e8b1ee501fe16fc7b30108574e93a11bb66e53efdeed93d2bf05fd37cd0ea14490fac8196b9e40607bf109388eda4f83971fb7f84ed873b323525ffe9ac4659fe7eac4ec2ad711d3887cf06c42e1dda431d0276b20c9ece9f4a5da842bc8f670b486e3ec3f471c7ddc0da82f3ff6fc7e172243b355934165f722b4d6a03ddc087332bfa00f543f4c81b2e3d5a6b29daa45d0accc6e686c45e2b4324a60473a0240f084fa07c098f2dfb6610a66a6e701e4af9f7d8bf0d2a52bf9cf51bcb8363aa7e9c506751606d4eca610c8ed48c8ac8511eb06920405ad011304001718a6b863b329b3b79bed6be479a65bb11779bfe64c0799ac2494573920c55854cd564e197435e6a26b52cb90afb769f88a05968734254c48032c9aa680fbc768bab2e75e5e55e30f6247050290737e63d7693c17980693457c608317c52c2d816a77712064dcaba22ef15942d27ab50c4e848b7045c23572f3a3a9b241120b03f2f8046607c9fc940f186a61a701d54391d8839516eb170aa106ca2977375a445ba6f22d2c6fb77802dcf9a49cfb86963f8e5b1bddbfa9717bcf64fe5bc31b7b822d14e3b13714ef7b70c7024f460c688cf7c9222d9af7a24baad9acf6bebd1d00cea9266e217a5f1a9bbf19d71a3a85aea255484d0ead6147cae050ca97cf8bc369aa688715327713e1fe5dbec7f29b1fb28472007c95b5e0e1fe2d7acf9ebaf926aa2c7290dd4ee848a61ce1a68f6e31649c572feeab55f0ed923bd75f83f0bbe8d8e1bf95960cd83e7e034fbcba00fee3884d55bc9bc268de40f9aa3a12f10f626f388422bab00b62fe14afedf0deef784e639812bd48827e355ffbed971c52dbc22dd72daf7c42b267ec18cef1c30c6695890fbfc2060528d4cc16d813358fc8e1b90ca8e2544ac7a5e70d1a2aef35939fb7e06823a094cd088a32e8b649eacac30af6c5e4b5d511f136028d642bf888ec83dfb018acf1a8de1e16237ef2a6886cd813b68398d741151397ef77397f8b80ad2f073f137962fd9f1cfcf0e70ccea6736c84632bfa2078a80bbd9cb5e673a6ee089d64c720338ab65ffd1230170d18b60fa00ebe25a42e346f2e445aae5aa60db321577d6280147a594a6335048a93a506be37010a8e400a44e1187c42ddb8737ea741be472b63be2544540da94593bc77c6184bc1f972502c7f27e76aaed09b80b1479b6083e732bdc442cd06f3477763d617f7e9cfba0f7384cb77fff3a6e26ccd87bba5d9ed553e69df39bfde443ada3ab664620693df8dc57a658236d79f06c204d19a2424ebee05f02d5b87e34451c366fff17fbb35ba891bd44a47cea15b9ecc35a93a0d907e947aab4934f5bbd2370d7dd2c4eb05633b39b03655985e9b1891e80e8f181c97b39f897a7070c9ade98167d4838034b0125f0d1b298b31c351b9a0e931915a5563c1e177136a00188c486f40a0999029bd629813b585a5373c83b0c4079773a250b5529c6f8f4fa7ec16a8c07e78b8f64549be878289340ea0b0eb4d60d52189b2ba7c13bf7ae746b13ae7f46025e9a950e27d8c3a3d0c6829b8ba5462e59b5e2648bfdd4f4a068c690b5cd2180690fee820d7b7960d9c7041360bf42f8ea868fc99a400a674a0e70382198a117663f930193ef5975aa11a5a781416bfdc875b6081f20187c087d7896b563470c1c262c597c2807e3a3113fb8348b6ea6a8d6a160c7c802d98222fea3411a5cb8bd86f0c0b4595055a584665c7d749a8ad7bae25bdd9d845103f6fdc661dcedc804bdb10055769d32a0ee898bb8d07418ecda849e3a45bdf8f0d544a448c331bab1fa94a8b2036225ec7a640b73ab12ca9017a881bb6bbe74962f3b9c534a3a10ec058c5dd80d9d2cd5fd637b954b2b7e1f320d92a0fd39c6bef9166e366fb01aae52dd892515a4ecbe4dc1f4ab7cfa8fb62d6280761be3181cbf886205a26e354591db6838f81d32772377fad33bbef6e190db18d57a81453bd506ad69da817c14b54188508265c0bb72a8bb980f0fd6f541d8f02a25565a894537e2e0340a79e6d4a5c27c309e903bbe120aa1025e9761c680d1f02a6b5f43b7f5d3bf5a5efdd734bfea56ba3858e66de6104fe9f665aca0b06082b08b5a769a2930adaea182b1f453c9e637b1227faa12d94873ba28b1af85cbfa19a2fd20df1dad0e10534c5c6e668e3ac8b5c61b25019c1f75a13453197e5f817938359b27b2d07464df72968b4f5cb894bc700aa2be0fd1697b3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
