<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd464065cb926aa317a2aecd67fd32d675fecc97b7553e107947b57687d9f3436e44e149e76406db53594a023a7af6ca4751a72a0d4ef21d6200336291795f13a61162d16a4b5f7d4ebd2917fffa99da6f0512d53105e94ad93f7b4665dc486c6b14c5ddc357f78998034796ecc26b40dd91a7c087c91a6750abbc74d0a6b94d45f69f5c2a851bae3120294568e949d54cadac7ec5995b42de9f5e12b64b3d7391a8051f96bdba75182c11dd8ca0ae490a30c23869cb1b1ad71413e3a8b91d460035ee75271973ae9d1cb29ccdd117d15be2d7f150101cd79c3141ee14db458e3f17c58e3804ccc3ce5dbf62716ca1f578414c9f15da427e858653ed40ecda1e14835eeaf32520d212372186020d851ecba44ff9393806bd3a4eba2e71f4010f29c85d9fab5e1c518999cdf5f0085d346469bb04a2ea259c69e3b4a25d768e26b4c41db19e803a9c8419dc98069bbd3a8567d25699a093b2a7675d5d201dbc306b17518ac0619af0c4cb01460ba8851794cffd626a65fee0f3736ff2133a1c41780050f3c294e4a7c11cfa71476c750e7a940e907a697cd23acc16d2ffa5d666a24c4516590959514e38a305818923908f9b7e552a284114f7bc6878f3ee8f952b0256288c623d6a6e579d96b4443bc9a1af63252bb7605e9f1b1a0e1d55a3f1a898767fbe616bbf243fcb52fed7901e755c9f7ec25f9ef0c9d4824e0ddb97e8179a61c41d8a3d1a85e88fe6a12aa434680a7d6c5d1ed8abaa94316a57c3e99b1074491fcb8d1c48f3cbc9412d9d5ac150deca963ef6203dcead36b28f1feed0570767cd680c0efc7fadef06da52fb8f4c5391163e3665e2b71d8768e6d677b60f7358414bd82107e5e61be0f2bdb79d32499eda029442b741032546d11735de0a1bb6852f773849ba8c3839accc2996ae5694dd7ec27c3fb9f944a926dead32366f57c0aed825a7baeb03452dacab48276e63c129d4361c7046a194ea5bdf89238e333833de0e2b5dab63bd7bb740fb944558a0103ed24c3c7518ff1ef7db09617fd638710f7a02f8ad9145b2b00f472d418207f96c43aaefbfa4c9ec8e1da9a2670a1453b0f68579699042e6126e56d3b35c6a5269206aec0014c881b891b999d0b980e53a637227a31939e5fc2d1c76736cef74a373da84b2f29cad58368c9be4a73c20417a8e67c4876a5d29343799190866de2a9a57cc7bd36f555388ea31cf67527a95a4703fb8a5af21fac3621d9237cf6ae879f866f32b9408fd9146f98383abc22e54dc75272c1345a9e4a84cc60dbff3fe7e4981c8778da091a8d51b0460f17fb07496476df72f0bf59a3182e50031f71281bfb76f4c0d6b26e21ac796af7430ee921d66e559d853ff839b20837dc7f96573514e0b572abae66c89306baa0f40d2779de15b07ea6c4dcba07a77210157e519a3cf9135b532fa61702bc195c23aa3accc454b4b7e1cc99ad3f3b6577352eb58af139ef14feea379caebc94c9d24d66275a79e52b724b82ff572fe9377f0d978e39b66b98bc115607551c79039ce1f0c194d24a2980dc48a83a7702b6e11f3de61100445349254276613011cbdc3d99b78660fc1fcdd06f71e5701316e2558f81d5b9e2a3278084969fd8593869c147bd834f15bc77868b569547a1ef9bc9d9b1279e085a7aab947e52214a32f570735e1b3ee581099e1d89c8a02a20c1c46d32af3717e9e861a76c079a38bf4d8bdc0bd87c298932ba2d9fe76558f1a434f6fcf306b348972b41eed08b34572377144a9c3fd235c882551ac75ba234cd2232f5317bb63346f2be76b21d8a1c193163778e1114ea8e01477632f2b7e0728cb76101578ddbe8e5081f5f5d53c0ac0b0a6ba8d0cdf76ad9009a85056738c3dc556b73a51827a9e96c68a2a4471ab69432051a38af13bbc3f4a61514824cac5f81aaee30162bd04066dcdcb67fec1f1a1f416d1270b81ac541c3c9c5f7a8b29540a69f807b475b554d3a25620d7eef5ea4775c8cd95372bc0d499e544fad944234077ad4c21445725e3e30d9ab3bb8e11f448ebd83bb35d7494b95f2c341c48e1fc1a4f49902bfe9ae4bef71e8c5e08024b91b07da7dfeec13d3f1bd555407a04332e44ced955c559a77973ef0d14511ad4f139c95a3de8d2ea818c0a919f804fac13d259537aba664a5015e806fd867590cf45b398d374a813935aa01008091df4cc51d45b235081eeb29ed9704594df1c1b69930038d8c6b518262c4ca28f3b65743d0710bd28d4c16568c65d23e243f70bb78e6268105979d6b563c7b55419cf145e6d6dba30518f00079993066191a560078127eccb7676632deed1bb2f6ea1817430c240b6c3f4186b7ae1ed8cb08b98f93b65a72ec58142b1f74bae31bca1a90370db55b575529faa565fdc973519b0c9f1edc5b6ad79bd5f5490b6c1a56894f232114d0e8ef9034b03170290f2bc6d30e953b3fd8d117836b15027884b0c1c2f6f12fdf58a35db758a1c5ac9ce231f2e57f33c7439555fb646d578793bac1eabc819ecaa399930340ff2872a0b1a26a6c371c4bbbca9d9aad3f1cec63ab7ae9b5b75a144675530dcaba00ecc349b21a3f0e1e9ccb60643b637fa99f69e9f5ccc70b49bd03dc6429ab6e4eaf3e5277790ad441d412874306a6c9ad42db1bf54fabebde08b0173fbff4ad919238340cee4b002c6f2a7cb737506a2462cf9e8e2e5780c809a212de72203c83a850333650c7ba97f992b936007a97967d998a42d00c9edc70addafa9cce307d4668c12b1494e2a92c1cbd9cbc813b8229843e085b4de7cdfb65ae84343b4009e932cf4c387be4dbaa5e20fc71a7c27b3eb2cf70f6e97233152a57be29113b7ec2e2565a87fc1144672f049a84afb7fe7fcb554e3d7a9c01bdc7b4a12614df1415e291751f0fc8e8f316453bfdf9fcefe0a2d20b3d01fe5e77c5864d96a84ba698d9d4b401dcd350199119b1ad7163bbc12d03cd65c96b9f31e9c24d0cd11daf74f4e2de034c24760f3ecf15115964cfc2f9fd12608c96e325c4702e4958e4f4585aab356fc74689656b3c4998ec3e15af22fa621ba49ed44c673ebdc16959d18c8082f541b7da65239b64b9afbede53a738600c68695d2ff05a7fdad903572341fe093aa638337fc452683c4bd258ca31acb8cc2fece476080ab0a0eecab5b597ac61bc4f96678c730e1bf70bd5147c33fdc4394f318d9d29b7e12a03e2bc9605a1201be3d89b891f7916879a629a8df1ea09ce61e4e71d6e4bb43fc12b08b367b61ecb59eae086058787f0080cdd712be25eecc69746f10b4456b36650df3821ea985c5b2f689ef4197b6d8cb686ec5f0e3470b3276d770cbce1a7f05973f46c7e432a0f821c4b1bbae6c4ba220a48c6ffd7b81cc8f35c3aa235eedfbfdacf676e35c5c2a93b983e8f5b1c77949b40745d6c1e81e5a5c23aa907a46ae48eb53e364277279322f0153b70ccf514f4ce4dc0ab590197419469652f72f3dfa905e2d69b5a3f2ddaa356dc09f4c661066f053edc6c2b45e5afda61be628ac1c56c19ab8b0d5b7e1c9a95e5367b2fab8b73bc1c520befd76e35641880f8b74dbebfb04e0fef5315e5c82e474f03fd0a75b70927becb927c8470854c6f7a68194974cff9edbe5f3a2af85c5cbe0abc387be8bff96837682c2275da5c3b79cd253227f6a9f5b21e1ce90c7d85b81c98e8688050663e75a3301728641c2604d6cd9b5c607861ed092611abb3f0f6e4c7550ac405d110d6dc94c24f088b18985526f6811483fa9d28d0cd69f0f1b527d68c43a24720fd623bfce4e774cd49008ca2e069e853be9dc57c021d15c9e85943d9a6eba753b8773e5696be0ca7e67b67228917fc8f0269e0d235535f3d634613c680ce89e550db629b91df8a2bd4f00920d9fcb189f6287595b1e7bd48f4e7a6a6865a2622f31b2747e844eadee01e8b2f0744aca3f0682584d0528085c287b7d9661e9bf4e1b5d0fed2dc366b95a3aa72cf75e764b3994a44a5f4ce58254ce8360e4124be815a341ab1f56c0dc17d95cd1b39715ab6619c4e3a8884f57ecb90f3fb662dc7dc20d17214dc64f330b7ed42cf7d60a4e587dacf721283062c1bffc309791727c9f184d02cc16c73b96de5ef27579becc3b4b1570e1f60bf96d031e861b55102f851e0ef31448e4271ef8c1a03b84ec29aa45046ad8d7c93d94dfb4f69162a1fb8a19fe25818bffeab9c13558df794d79c498f235c95b7ba9e38d86cc0ab2402d791f9c15be4f3e4c4bdc914d71eeb90fb265ae0ab24f190b2f8621cc93120f1d627c376d9e6252b89c16f0815adae4ea4d2252d991357956373962f26844b8258f2a92248039716e925cee23b07389e2aeea1976aced472edab81f2f16bc5a625e5583da74f3983e2fe05ca61c725458984d148e2d396c6185025568f9e6331c9d8499ceec5abbfcccc010b1c190cc307ffc00983a6c4e5a6eaed5f827b76f98eb5a281e8fae718a0596a4f0744f343ab9c7914ef43d29aae221912e9f5aedf7cab678215af78a021c594c194239f42510cdb3eb874608a46d078d97827049ebed1cf244529b31d36c5775cb81482e4d375ab1f4373ee0c8213b476932432c882f20019d2118852e190ec616a5294f5f0f633085869228fdca6f4f0dc971fde17d07a56fff295145abdb9526f6996cfa56ffe1e2ab23da6656da48096fa24a717b67607c24e74ab065517e179de975e3b466e9f614497e5a250dc5382468b4552e9e944a9d8ae0639df0a458b9e91c588ba07071761bd66374ae6fe6c09464494627504ec5a80c3929605373e8c83588f32c70540824cbf1205cde8126967660655175efd9a56fcbe71f0de46458b04461e1e028ba0b79a6e4d1f3fc4576ceda9665a6e3ec0667577a6a6407e1797c8021ad4376a9e8422f8132702fd9741b739200f3d2d6a2d5e5cde4077eb4d9c11d0adcec5115afb60153f576a17cc326423f6bd70a7762b4c5a8b3924ffcd1d17dbf79f1945b32f754f3dd576ddf44b6bfca3141d42bba5de99bc6d8f94c58e7fea31b1008d412bd3857d924a8f4607100114be90a70e9eff3c2cb482ccc48a66383eff9a28a4cfb35dfca528135d74bb73598704988e9698e9712af2159d2c2b7b854f97cb11812e0869858d3e855ab124a41e5fe9a1caefda017059f55eb74fdee3d82506036f8c06b907bb42843ebf503e1f0a818590b5ffa4d262992c5373518b3b8d3c2b5a362921fbfedcbbf727997e3e063f58aade2f00235f5699133bc8ea89244068a9c8ee3bfbcbf1971f17402a2ec22e4e634e4ae4f84676a02c9931007975014909bab957090f307d86aa4b4e76ad6b5b5f663ac77bc1fdae604d3e9f9e1f984ab1ce49dbdbc05ed477ac2f3dc066f28c9231b695fa9e5ae7b49cee20f4bad7b4aef61243c674d114685e644c772f7c6fc83c64cb88e7467c75683411f9160d177b9ec170041665de8ad3bd1acaf36555d2e20bcd0dd4ed728a8e97c78385d8902549077226cd9e881ecb6d04b75ffc35fd4bd5bba7ca99797d5fd45d6ecd83578ace3be137596858c3bf40d1e3f2d47d2cb685dafbfc2f6858e293e0d3bc4a68cd8d1372ed0925e94865aef3ee4f0c46bbf61e1ee4e725b9be5ddbb191803f3dffa78906e6d1bf56a179fbe890fdcd3ee974d54cd38fe393a4061c1dc0888e7478e8295180f4a6d71990ff31893a21fe8be92e4edc710dc8e3acba4c32952e7ced5915836dba0d69c467349daf1d2897117a85b1078bd86fdea4d2f1e83fd1a8a8541cde890cc785ec943dae916ab06283ba287091b676d168ad74c5f535dd89b9fa54fc2fe94e6662728dac50a61771e48f8def4709058bf028da9c34c40c76e1c9593d89539d3604a87ab7a618b114a4d1435ed50369a412415f4da9c2c3fd10d1098370149d8b3822a54de57b81e6babe5245a6cf79b28cab5a0448e6f6848ebd17926afd744a70c6279d83a0cbc938a7ef7321154807dcca20d455b0e90bbde40985cbf9b9f0b309d576de042564de11208bf0dc62ea0c6b233f14227f753310007e9089d8e2f401867d9d0d05a8a03ca13a9be19467c9973e5718333c4ac1988411e50e40604f43cd091264557be3493a1221ccd07dc65036b94eb3cf274aa1da0784c3d9c9eaa249a8c30a576aaf7c15986207bf0ed35c0fcd7b44aca0cb357e127627e1ba0b4fdf14a18c07e1dc0b5043401494b2ace2b734a69909c2d5f0a4a28f5b8ed12d422e1444b55a3b1b6a88c2191a855a88635bbdde3b89c1ab05123ad4d15b26aed82425d55fef1fa2f38a063467c2072018a7bf3d61d54d5ed91c3fe323fb4f92a7a0b7123fc0900215c63a4a02aa1b33c873bd57ad0c6ca444c57ec615bebf245b8174d7854109d3f32c888ab4f0efab8821ac0519da60de6c417fbb6c3b2e6f4ec8d00d4236e66aa1584a3aed383cce64fdd54f7f7afed6b1fe1ff429c01a97d1dcba0fb8fac64b17d171381e7269b8597c78e648872b4cad9034949f1551b095076f1972003265e2b3597a9a25e0730e242d75f25ab7e0ccc7577f416dbbd752463084a6d92b95276d70a2ff80dfed3ef1ef046592a3c46674ff1c65b816907fd27c88b6c2e80c4bd5deb1d10344e40f35db912b32272ee4055971ca3d8ef68b4e3348d27a6ae7c344650705c4315417b1e0a9eb7f2c370dcba0cfb42f9f4df8958b0a801eb7c6516a24a430dc8c4000cfecf37bbba7700e350e9816cbe8b654ffff9d6084a270a627a4f086ab6290e0eb0c45c4096255fafa608747f2050acd7561755be186121a91e71defbf019fcba681d48f542cc4804e445b1f56f361bf289785596498538927da97317a73207c192b2200b08e7c58de320c63683267d140c4537536881ca47b23ad6ac49e199254b444e8dc4c65bbdb46a379f2d5ec99cc0859f6cff797c5f202d6420585237500e3f44179b06af63a553313a1d97ccc2d51ac590c49aa3a9cc2f5932ddcc40ac2a978a8afcecc3a9c22652e3df65d096e6440191ca349030ecfa8258ef5d31cfc8a98ba8dc634b34aba326c8c430949b425dba96a4013c21e757514b4f90ef425c2777f3fd0aea38843b7fe3236dd5358a797cf0d5cba380c91f610eee0a73ef1a147a87ca0b3d8a28016e1c6bcc2e21b1c5953daa65ec840476e10aaad1f0f82a3f7b1730a5bdf8876b1ba15e9f853b00df32cd0f7deaf3e01c2f7a4333eff981f5c034bde708bad7da46c20649ead0a4ce5126a10162788462b33f797309126bd831dddecef2bff67a06dc94f38268c0cd32192876fb25a6361bc2d9676bc2b000151f2d102df4ff683e16c2eb580b7d5e3ace3b0f7bba3c1247cea140442c932d75cd5bbfc82efc72b1cbd637bf234e7ba5534c7ce88a96e343acd4bc2b057239d3ceb6b772bb51117212471659fd14f5470f38eb8f99d02d21f120a251e8c868444f319a7bc0467f7a8ebe556a0e05bc7524364b7821a879ad53a9577fe899b7d7776420e66f9aadbf752d782140c73516ef1d9f3e6664dc080d3fe2f3ca25eabea5a25d5e12a7959bc0667a9f1de0091b32ed71bcc72834b477a7541571a7d50d4d101f42e3b2f681bd7752815110864d5995cb3117166bb3f985eb4e440d3f34956ef4a8736b9e64c5fe5d2e7607ad1fcf668af264c3d8f33f9edd087533e031947f751daa9c86bfffc2071daf6de3bb9fc524aa6882b473827d96ff92678c15fdd8129e65a1af8b68e7e74aab8735a27a969a6976ce38534d4d27135a6c6c87b5f24687471b492a4abae52d4eb0f4cd2b0c37c10271ed5e7fc3a1e05996c26a1c9142163ad51b9a6e85c9a93612ce3a1ed6ab0570a7bf55dabc74cda7e03609adc708cb17edaf166a80419e77dcd70ca099b59373a0f3ad3d4a1941c4c299431e6517707995c3629cc2b3ca2ebb78af447cd54f2dd7eb237197b3efd796b3a913cb72b0c1add3dc209c07eb28ada08387c205eeed43092ffe51b40c54eecd419e965dea65af80ce52023d156d9b399a4a3ad2bbc145e74eae6cbca1eac34926133cf42968e879e1022bae7c047b57d3aab72b3d1e19e006d9db187a3d648395ec664e983432c07b2be26504250336e75de8583713afd1ab73201ede0d08de8b37747dfdfa4f1de021b383e0260104351a33046b69f64bdc2580783b4781e53a72fce2b571b4ae37ca24c40ba78e8be01f960f3d543b0c6215d1ddecabf21354eed14f0229db236c2fa4d39adc9c65be17555533a21118f8ab54c84823769397124e155a251e9991c82fd95d5f4f70189b9fcdcaf29f0f7b612b30d28cc2da80b7d8f8f2478f90d73dd822c1e6ba96b9fc1fc0b6c3782c3fc8f80fb7430c33556e60067dd075cc076158d40a3f7cfbeb9ff87d340205aba9cc3963094c2ae02991095daaa3390b440a9b8aa1bb4651b476b843b526c955d753f85ed2d48da09e16b3b4e4f94149c9a3630ff46a2c150baace5c228b36f47c07390c2975f00739673139368c6cdc0fece0ac9c60ec9a2c76c9b76e39eab7160f2cde97abad3bf31f4155e24f5fa6ca4aa3f099305e49008119cc29e6242bbff34d60c1e42afa480e64a5fae82f19f9a69d4cb117f79689a1abdfeb9ec30c53dd2c6006ef6a17bca1ceae2a2d0b0d511b1dbc7d994109df7f6ac238e18fc67cd501b85587d016d5cb44ac0c5e1f049b614e398702c3744298125ad02ec7248f131bdf008857b3ba86c82febdb64ab1c2d0fbb5cb2f849ebeb80ebf6052542269186d56490bdef974c46d8f30522b5f22c0acb2079acc2f5ea8a4fd86dc458a09543086e211201d2dfc8398180684f0850e14b1ae055c7d52d0c47ea730599054a3439ae7af36ea9c7b923cba16673a81ab1688b2b9ce794b8311f7f4633183a155f87f7bbcbcd2b125d607360498c5fbaf6fe0d9c5f90698194ca7e9e74b2064b5faebad10fe4e26a14b440b82b8bdd2d086e84551e88022e8ff686bc859e5439806a184d6d20aaa03dfa43f6ecbb5477de4f860351690c0f72df03b0b659b71be42f519347f4f1c7b9a8886490d45d47f750e3cf7fde3db94b107f5ec7d5fff9e3d9b146f5ff169b72d9f8a5987c61202c99e176b4f9e3fd20cb6332c6f7e19fd17321d8eb0557396164294ab7f0279ee763c5056209a19d4f4e09f57b97999a56e8ddf36fd6ac7c898dcabfdceb1eb10034c7503b9984f694f2b071b594e32d5668c746acbab87b3f2bc16731d28543a61ceca63b642ccb1de9f19be0459951290cbc479f44fef2cadd788d4d1d698cc046d0cc2f4a95124f0cb96f884088871ab4bbb611a26c2eb5bd5838b79dc19c6d01952d6df080743e3ae1a1a36e81f80fd7f0bcb8d4ef5b8400cadb2d3cb1bace45f5510c98024c1a263c6c8cd9fa7f93d94e04916cc0974fcfb24ba6742ddd107047ad532154f59de5184d30224485fa39bfd47fe12813b69984b873c3d90eb224aad1eeba8563f0c2f1787d65d658837cfa4b1ca5804aa3dc5348e53a91f5158cda051647988a8994f5357208d3a265ead0365d059c64c3cc59645a2eb55590ab1f9d2b1225c9036c03cf5d8f84df0ade1805fa7318eb3e4d8f867c8f4a6930125848af0fd4fd6c1a0c08222291e735b2ef1f62c245c4ac79c8f343b55737b6a3b229064fba9d754d7180918d5069f1b889852f28769c2da8cdb703001832230fdb355d057bc02c489f2cc04b651dea606fe044b2eab325c8a24790cf72b4981d2c4f49c398af4ef65d0929d91238907dc89cafd9c10f3612be8c9155f77deff166a9d6ebfacdfaf216bdfdf2ca9fb76b3897ea68375441b3b70fef32f1ece1d1601257a0180424ea31889a27f13dd861cd10c193d4bf0af29a56180ab2f6138b7a4f064ec0ddba5622c32deba30a92ccb6e0969b9c02a70b8ca5a1ebefe202113ba701376f0f588ea96412197ce3329e3c5a9a3b50ac4e2399a8fc884a97e6f76e9defaaef616393d594c89129aa4684773fd6e8501de3ef75ac2037539ddfbacf26f5944b8f4c36290c0f7a5a5a01d2f3a353ca699d29ae2007ddd91afc17755bcea715a123cc4dd1b439207256fb89424048c53460a0a1836fde81f806fa5d18ee2fdc2652e52973d4ee4a22e8a5e1a757882c995bd965c2d6e6291c30bb4a773db810f44b9ebce495c3dc9d0769d683c9d497f5d2139e5779f52328bcac11985c1c76a8b32a5071a2bd53c509971375a0a6b68df96a633fd61b3093d267795730585f2adc05643443b9da6a45764c91e954405cb643eac29340e63eb0718f03c959971d226f089ae1d61a8cb19cd06bcbd80f383f8ef2ce884b591cb6a04394b762fd92b8ad6b1a0856fe648d1d2211cc5f703057c91567c242a67cc8382cb969be19ab57051176d5fd534c850754daefc128f8b8be5ea7cfdb9e79d47398db6834dc5c3e5d6b876e83d10986c9bbb47b46639df1eaac0b719b4fd1d124ed190b0425d8ad57eda609353032b69d3e4c01f858d605115765c4041140ac1cea10db499fbeb04d7426bbd819b94c1b266b91465988d91e09276e570f4d4511961b84297b2ec64b6301165d8a3526ebd3020eaf33b9d9f4a2af80764fa82abbd724bbec853d97ed296479d75d9df4b833b458f0798f7a4577c7004ddca2de34709efb0fc337c85f652f8caa972ce1ddc009c62250f08ac24bb44de5179beac286672b0361973969e8557087af690e89cb618cbc61b457cd48f126d715f52fb618c5c8aa6dc737b49f9707e1713c93a0cb6eecd4c7a68f504d791f088953f35b19b99e9561012ab61e5a8a1357e2048dfcb07794f9a65b7afb890b8d76650bce01d3bfa974407ab485737eb823926f6143d6689450f960708ea7c2fd0ceda18e8e05568b0bc26e2e1887063d5eb880935420a9557dbdecbe15ff17a3258a76e2ad5dc1476c70b5b518a20d4deac8e336b2982d0405352e52287f6c8726b60227aabf488a0de0aeb8d29d28cd4535d447d8beafb9a01ffaacc995780e878b025c1e97e926f3a7963a743f6c7a1784531ee5dd25d058bc4848dd69efa8cce44ea9d9c01d17eecf5a4ae245c267809be6266ff7d831996544d841dc77ab8e8a7da164ed0616b7c9b4c9e416e685b9df9c45eb36f9871f0931e30e748836aa7ad4cd18485325db45717e56a315aa58acea476f7a100ea63dcfe5fb8e86c721a2e6d0765c4959de64ad1a3c35d64725c32799aaf50f7acbdcdad64e45bce0c0b0ffbc14ed019ac0d1ef4dcca8c382745a8c1b72490e8de2c83c48c7822373c1dff2f76b7f8ce8c38698541831bb6bdad45aaf597c981d5803c285ef150429ac60e3bd64668f7eb5ad86a5332d69f6029e57d17e437b363d014db71aa53c7ed1079df027aae2e4c2919432118ed9ced58296e96e88018621560159f891b43cb91005723d09c931ee2272b7ae3018f0901031145a4312c574f1b9a97c10c6634a942a48d490dfd7213bf7a82c2e3909993f3f72cbab4435dae6a63336386d200d9c356b06fa4ea9f1e1836c8a042bb9456fd874b109d00af73847dc6dd40643836c5de695f6dff1f966b2e35b932367a73046d84eae8ef8646f46b863d0de333ce2204650299d65d290bba69ac951e5aa8844e21357cd81780b80aa06fe1f051e9106c926de58f2df5a148435fb718cf1f08a12c9f16f5e7f1badae08a6147b733ce8f04049200a006c3307f2c654b4097dfe4a3ca9a6b40fedc61e4ca05acd10f5f0ec34402d1bb25d3db59469932099a8ce8f86874a668fc4eb92a0d87af3dc78411bf1b540601b20a37d98f04b59a8b01cf1b211f85275ad1e6ca4314606ce829917eba40f7763d22ec88103e49f57eafc911537702465ea88fdcce5bbb6c3a45cacfb36daf17785401483eee1e7304dc636ec603deab2a55f3536276502bf616b2b6edafab30ac69204508b62b515eae6562e20adaa7f94763c7f6e8502fdc40af26dd7f95b384ab0941cd80fdf6b48c1be64b58f443214e84789c2306e9f87cba2339733cbf8b7c269250273c62a9325dcd5b26078ca054b9669222c4dd13afaab220f61ac10000bd3610a836cd82a676f4108df93028c971e56d76bd04a55d4b06e9c555ce51931d27b748e1585089dd183fe39fe8d84a9cd673cb975b932a8e6ce9f969495babaed736c204fc8d00d04b90c4ffc261cd99859267199648097d9ace6889b098a9f01807088637e3d81ff3599a2c60be8d1db195daac1e059bd0ca5771dff24ee56de9eeee37bb93660ef84a21b028049b8b5e02e99d3e4d307c7d2fd2601e2950b1949b5fbeea962a6ba057aa4aafed11433da046a63fe497cb143833f8708216e0c2222b91e67c8d06db1af0f9c69225447c444e2ff82d6cddf3adcce525ca8d3c37e73740970a6a20c6fb2bf1cfef4515dd19acbbdb220b1ab8f4ea69b41e7376b5c0179d0a8692ba7ae0632785a800d3345c4b16b3e5c5d66ae17bf8460737752a63e45b70890ae28ec8dff201f06762530d355dce2ce6cbb24daff18333411e0338b361a323acd62db9bc16daf4600ed5b59fe9bc66cc3531c22da0f38bae2537d91836cd6acbf6f0d53324dc7acbd15483b11df8d2fb77866135bd533577332117d553f9626c0c8ea9aeb36aeaaf29931d53932b7d051c8f6d59e60bacafdadbe6b1df98bb2c18b50e7ed6840b51c0d6b2de0196dc39ac0a92ba44270ebe8dc991458a9f1576693d08f28c38664385f81eb10e0131bf3cdf8e0afc41676c60ad4388fd3122095ef2df15b265c866bdd65f4c82d60da43bc1df3efd5227517620c7913a9e8afc5dd6a9fe8bf7be08159c19a0554af34eeb9d142dd34d82b065932b724cb5de601439e07bf9daef5c9b0f768f0973ad1c332e89fcd6a794531b0e7cd49c3521e36d07fc3939c3227e6c80be4885a99d3748469b31b3a601cc0f98f710efb6df8cffbbf37e1abf08748de66baf2045e11c03b4fc5da671cbc1f7f063b43a6854435a96fea9955cfc16ced6f4981d519f14f3595bea1a6fc569ec9599e5991d590b0f0caca6af72cad3164fe0c58a29de284f1c7f2b37d208945dea2b1685a1fd8a304233baae6738f2050a7756cb081427867c309109c85422d505ba87a56868e90c5e4f26b638317f97c2dd8169e4738048fdd3f83a5d1c0bfe6fc3bae8e592106c0850d8173bc98b91206aebfd5f599679fd314648457be97b9acf083dc3fce182a0d71b6b1a854e0f27019d92e1ba26cee88c485b930eb9d4f45cd8117bafacaadd9083664dbd76363aa84360a88b733017f74a62b846c01568ab1d989fa689fcc1bb793dc05801622bad2a046fe1dbdc62b2f40c0c2df8a62ac02f795bea20af06cb6b49b8afb1942bff100d03875da2ad90582ccca1e0a772e4d8d5a4d76b3d9c7cec128c8f102708c0d8818fdf3d5ae8daea40cfb30f590e6f913c4bb1e112e0ee2690e85f34cb9685c1a5d0d9ff377c5e81cfd06ea465c104c8c522b764dd629c68f171b316ed1b8b08453480d181357c36958ed7d6e477414e79c12ccc94996b9f8c4e8e321726584b3075d83bf0c7f7f6165eae84ad7da65101c5a45b4421084c5398779dcd137b9b311125f2e180eda2f6f074bcda3021ad72bb5b40f23509dce3b2374fd004acb89d4dd2b69998c0dd36023467da81a834b35893f627c983ca1225d82f2923b0f62bf9563460669f54bae00f0865bab65a49d3e2aa915721b7ca04958009b49817ef79c36bd232828c4c38127c899776e2fdc0c25ed750ac19dac72a43aabebd3742387b2eb8381d6c5b87c2881558de24185f5bcd867288dfc68f01857bc2cb01de57d529e39bb7da916dfc5a623738d7331b3a2f023caddd94e529780b7c4451fa5588ce82c1ef7b97cedf100a25a9677c9aeacd7acb1b7e483bc36312f02fe365a57005bb5687e225663f0f38ccfc84b97a1282358fe30964d553241cfdd51aa453b34b404b6cfdca8e6dc28d1017729263a1286e420d9edfc9e74f587b5296338057fb2d1c2af8da5594de5825a7c1811b2542cc00b4f49277f08ffebd0885bc47cb92ffc48cb2e24c2dc430e190ed22463b9ec332a1a8b1717103bfee9fd98d931587521dd431bda20406cfc4c5606acea0314ed239f836fe188596510b00d307eed3054ef17ba2ef34d55bc36d0fdcd4c25d87a358cd7718af12c507ae7b63e4e771cd77d4a50e1e46eefb30c67fb1debc5dbbbe56a9b0848a776b3d4130e917df3371ce3e231161d45cd36eb96823443ea602e9ba15836172994179fdfcc87cfc4319a0dcd3386277f9edb41469d40b6ab0ada8721eb2e000f9c46b3430ae6accee8fc74fb2d9a154da9e049c047d1711c5a4c3372e37de4bd21f75cc1749cff51e42e37f05311cf5c32ec57da4ccfddc8a60273f12acf966d7c3e10c011fe3fb18270020ccd3e395a9f13d28e06cd0b98b8aa8d25cd5cafca8460975e6039d9206399850fdcc71d1fab00be82ee72989ec52a090d882e6d58904a7158c6305c10289e1221e89561f428ee2d3d2a78bf51f12b173dba4a142a6c98edf458198c02c6b5112366e48f10009e1ddafc1220ee436e501d75d520edaf36d8c78f1e98da2a099794a45659c88d7ff6326d05325869e4e3a12f5aa81d24e33b8b103222b531a7306d160f9931a0296798a99d3616de6a195bbac07e2011e5533b67e88847523e1f0b3c4376a302aca37934695d833fc52f044b0c4b90d5bf9e8274b0404c45682daafca974dd290a4633ec41f2d6a16d693453c7dc1b42b625808b131e62ff2ab91c6a53b119d827be1aecc35bce186c94577200624c10a780798dd55ec6d45f0b019f5393f3e3fd9d067ab062cdc809502d1350da3d49651e6b4cf862f2adba5d1d74696be2cd123fe457654a2d2e794421401b79bc12ada374c035bc33e2f3ed1fc648b7e332d9d995a0fc6208c3ac13a26c2fba11f9ea6b6826d734f21555683ed232cf0d572c8c05cadbde793341bed14b1723bd7925f7a98c03f5aaebd1a5326d5d922d86cd9e70c43c1e56729125931872a3c9c8a15ff62f8fa77be0554e9a5d982e5cf694e8e865b11aaf11070f91fbe0cd886bad4efb25f8e97eda4f7e77bef72ba2a681888399b16c0ab59a78f86bf4a5649d10e439049c1e92301fbde9fa38ed3b727b9da7e44a60c6fc802eade311b98f6c0a14512413af21907282a32c2ef03ca9d5870eec7478ff39abea2a47ee7813d148e9df674c4ae5b4c1fe873b56a607a15f14e7a5dccc1faa35350bbffb8ea13f0ee24d691477a8241dd3468d54e42cb8976cfc7b26c513e4ce88c3d7e29052a76a46bc215550c81d70d63a01d0d8d4a4673e1d7000ea1fcef71b9255a329db699d19ba4b05fbcdd8c1b073eb6fac41e0fe1ae09b1116cdeeb7aeeeb2e87729e27245a029193adc0d0fc1f760e0ea1729bd8b2f904f592c5c171d9f4ee3417fd00fa5a78dfd987548bbe662113983090cd78af7c32ec7bb0f4fa0ebc2574b598d36b4ab0e7a0cbcc4aed00729edac7ef3f69635b55b417a51a7ceef176ceba32ad115378ea5b5514304a9c2fa670fde890eb48d0fa0cd88699a84b17baaca79b93029dc3be7a04099fbdd6d62c227e6e11a712d91b0b7ae63d2273bae5cf5660e67af6eefd7df1e6643e680edd15a5cb727399c7d7ec13179379d0bdf19de87a3708de7cc1e8ebaf30796dd024d740b300d743739c810e100e657274e02ba3c1f57016200e4ef4fb2608b8d06635fb6e49f3933a25610507d21a67f56c08c8f62d7aa5d34705c251bc767113de420cb959874b4de4921915ccfbf37e9449ac37033353545b81df98be52c28ba00932e7d7154bd52d9663d295021504d57df31e102c863f1921bc318b10568a7aead18f8dd7352499d89d7c2facb5407503777157f1823e45afd7572608f92d5b91fbc7a8d1c8c28e0e9ebd974885b9fb668fc4c5aef3934ab180c240dd034d06f97d819eb346c731c02fdf0dc03ec3a255f64ab66dd981a7162064e19de8f6509916951b8c7f80bbcb54c3fdadef2958733158950bf4575332f15f7e92ffe27e6b07b8d32ad96db594b4c551b2e682f3bb9c8b00183e24af11c5aeb50de2d8249599bc6d9a7ea44ecbd39f2e6d84f1eaed9dabf36507c4616487860575a63abd07131e565ff003e560f3c2e9e66c63d549fff9111eb044dfaaee90c5b4a48904e1c1480522cd999f946902dc3b4df9eecda5891b2d469d1122991ac15920228dd6bc6eeb83daa0c1a9866626d7e5c1362b921f5a2b080b72d042b46bb75d2e9164bb61fb08b4eb9969ac821f7d4efb52cf490cbbbab05902df239e0d80420baee8ebf10e2c502bd7a8204bcbc1a7e197677f5bfb7d2bec3934dd96d46c00c051aa9dd830ed98f10d1572773dc4ba46457cce118e1c70a225e935188dbab1a3c8326f22d548939be18ffc048303713fdade362966dcc7525cf9080eda1211964ee74c7813c25dbb0d425bfcf82b112fc23f3428452da7cefa4e49ff5aed992094a4fe821bec4d44824f2c357df7f4662c1bbdb97b9f93b89e210a65ce55e2177579ad0d24b87dbb3d205cccfdd464dd7d2d59dabfdfea2578b8ff9ef0fc60f6fcb7c7ce0edecbd2d06a83bfef5bc6af2f4dbef54007b5da9b643c2aaea8af52596fe6ceb153b351d891e30cf88d7182e7009437fb3c5a8fca1b3221e01fba20118f7e1ad8e79f86d784b48075f9c2cf5a65c54ec541c143ffec4d7e65b348d01339b82911d4b76d52b86fc625f106bd88a25361fd62041fb1fcf8ef74390604d3dc5479f68c83e54ba1a5f11caf7e26c629f1ce5567d271fbd7edeb53545fba81a63a99e5577ba4c0d1cadc7f38bfbd8e25a48878ec8d94f1192b170b54cbee4c51e99de99be4dcb17dc796880e2eb0ae7b8c7d4a0516faaaad9ce48a6ca9875a075a7ca61e4d13183b615e319829c80ff4cd22b6ebe3d4923067952dffb08a0a548c9827ea36e8cf5bc2c531b36c0817cbb2c474aa005ae7e2674430d7f029b072979836fc5f914d0b94b0d71df388de31e01a67d95cc77bddbc029f81bbc0b39519151079f92f0e8b261c7e4c804308e9d6d9a572965ee93beb069773c37d59d43bb977b44d78812a55f53c45639c5f6095015992de222814fc26a5d1947eff783eac181db522646d7d1cfba513ca83394aeb9911f3d4c1a6cfa2601fc0be707ca113b32519a6e2dbd341525f9801d0e6db6c7c6e82581711367fa412820abf331fe771e79480348a46c82205c527094bc2feded8e7ccac9c9e7e6f48c2c0989408c4845a76e344b10728230a45606b9e33b7515122b440fce1f4401cda2aa2424d5baa939ba7de65c0327dce496f3410bf7399aa5f553f906f41e356cb206fb51037ab9ad1fbb875f399bddbdd8bc922fd415f9e8a73b2e59a60f4efb80c6657387a0fd0147e713ae48eb57a0f2b49ce9fbbb9b3b7b4f3b63ad45edd748d50850fa85f1f0c343cdef763389062f9b71ddd5ad8014c14f24df9e78f3db8b9ee80bbe40c2239b047fdccceaa907cdf354b4a8ab9ee78f374d0d02a5ca2f2d3e9a1c8557166ec60adf948f0dd3880387ab78949ed7fd7e266eb0f66c1303fd58a177e29f1b178aa02504c72f6903ad5494c95c1537028b23e216a050fec3106dd9fc58ba96d629b218b5a2e1f7abb83af70a17dc8242fb34313c9affe124a9e63543911621b5d87e1a3f30d91830f78666dcb2c00d95e0988fc67e9b9b6679e1fb506e6d1cfe39220ddcf3ba156ef30cb580d8d437cf614d0d0404096b8a7010f1fca4b71e4923852a8b3906d3da448249876c3344467d1ea24ef06b7879e8e7e3c831f9e6f703477bd965cd0cc7c98ae08a26e6311e35c7a87e6ed9550288b52f077d0f6eff9d9e8e53664dc4c06c14d7c5e72437d1266f7bcbcecc62fff371c182bcc82ae7e94fe0a3cda00a4c749c776413fda627edfb571bb397f8dee25b2c19addbc934ed5b0a13c888879b0141b61c3154594e557c41b6076112c43ff02f00e9edd0d4debcfd02fa0d7282f5282ca45ddf69b281348cec4eaa327971d81e55649c73b2636c22ad79b7d604c384150fc0aff79358b06266ef1304fe8d570c9164d098a8335dde6716aef4daeb77af22c4d5afe7dbc128245da5fee4381ba84f1d3adc5b2df80e47e4d193bc5f0ea1302dc0778f03a1c38f2c4115957a74a8694fc5491f1eb7533b1d12ea832359c9121ce50f8eeaf39f1a04152201e32de8756561f73aa82fa93c7e5c0eebb8867179bb25d43476ab6df75118f33b9f06a10833d06da8231fb872417e48b0cdf455693c138bb10c91761cd98d6ebefdca501cb7f45f39c981f1dc01e88424f5179ad0a5e67754f675bc1f3a1ea65b02e675aa3bf1f9ecf867ea0b22496ac09c4674ec23b6d75e7576d86a1ec073964d94365f2aad4bfb3a25c6f09447c3cb130655547dc2d9870c334abfff0b1cdde89e16bfd0706bf67ea52f3d88eaf7aeb0ad29bff9dff3fb159374ac950a7cc41996d6ea2287baf99c215b42824ee9796d0ca4ebed50918d3ffd3ea5c08f0310ac8ee0f9f4417914e0e5e23f48df33d6888556bd1e2e48ca22394d3304e6e4e7761849d835440fce34c507152604655dd44e3f9c663ef02352d59135c95bb9a9fa80a059c6b4d3b817b3b2b38a23881536091dc1ee6cfdc3934a34ba139e5d8fed8f5a1bc47f2031a934f7bcf631e3f0b693e124cfdcf4aad74b95602c61cca4c7c23fc1c22e89dc42a139b10f85a89ab64010c85054c2e1f05eb8f0d0880ceac053e3f871f5fe1feec8730894708de1053f2d17c4e27be2e7c68f3c7a42437e5ba63832fd69bed8b9d7ddb99b4b135c1e66fc33bd37f15d5ccd2cb5bc3425bd32a8f800308a47278583596c8fafd2e1f8063a2a68f219eb48cfe286d26d97191b172e7d080261551562275a80ac4f464e251dc48a654576c76412d0b5b473ae58bcb388cebb7d22d46e3e856b17c973bb82ca86dd57c109bedbd81f0d3dca770b0990551255c6dee235ace39479c606981dc8c69826bb24c93b74267f6556b00c8d100d9a92278da2fbe5d395b538fb6c48907c444943e5b55e8dc681d01ae1e86a5a530f1cd66d7c8f01828bc920c54cd83ddca7caf8958fb31e293347e505e628c63165bdc6407bea82cbbc81f81d565c5853cda73e726e90192a58cd3d18b788ec2f1dc6654631a8d42e970ea68a08b9c330408280e5b35d0de015a72bfdb5f735e801c79b9411826f97b35e75f55b7b9455fc841cf44afd80aaaa88d10da51226b88772e01cf05fce4b1be6522fecc21efac8637e451a0296ea6742781a7557f8b6eb07a221c3a3244613faf38f35d2e6f603653709402f01db81ba8d95502aca031c3df7ba068ec2c3949acaa457ad8e2b25e69f3f49eca4d43138026d42170573660fd76c1c201b7426e80a7099383895624c2a810268ccc869f46b9dd92bdfc749f7570cc6fab67c245928fba92263bedffa975e384d212bb8256768cb890c3db768558de655d73d8a1f9cc06f7fe6db9549f87a49321b4dee7e4883566d992f2c4b2138f0ad83646ab779fb8c3938d83ef9c564045ab5b52c0c62ed89fd2be2e2bf8c6a9963318d8ad86bef0657c9121e12ef7ba31e265a9a18c9088f705c0d66e5263b4727c3098ac4baaba82a26958b88244e3ce0c920dd370c8dcb87fb55d00b1d413b9f3b56b58a350ba803e0844ec2d91ceea1094f7350d5d933580f6fbfad25c75bf8493db61618011581edb98d4fc2368de4a5a2d439320622b1945ff6bd801995abde63478b26da60fa1734166ba179886992005eb87d7392e563023a3814d76ca1a7dc3d01cae3d387beb50e18060e6a38d876b1b235830fcef250f2773b89f1db01d16f02193f7cdca95c21aeff2ba652a07fdbae7e5481a280d4b87356310a21deb8d970c9ba8ae6ffee441f47d2359335451ed13c417c30eac853582b8d30b8e5261eba3f750620e1632c9de217504a41548855c78e9bc625ad251d1269ddd6ad975b8fff1134f0ea79dbc81a3b09f58cc58a73818eb01ce4da47b666945591e5d7847e71eb3cd7837a7b957d932b7d7c9ee952ca5bc4c582444c5d23eaf9b3601c73c6b67e947cede0a88fbad93ea71e74a52d725d48dc8d08652a20e4f90473705ac7c3706810d3f7a90aa4da587985e81f5c866f32c623246c9777a07ea75ca4034a34981a89816ca42b70ef5de3d5a7fac61e4a015ea6ed1e0e2f4fe5628e4e55021ee63b5094a040d4ea2799d50e8b04bc94b155e2fb5cd2209f5a3776a006eec98501ab8a63e0eaec7fc516376ff7db46f757a28f311d0e32f0933caeec8f252f857f7e822faa7faeb29a11fd00b561d1299d544b9e5de5e545774d7f3169c563a71bcf47e8623e7867d98c6a2e0ea374918732c7f2d7894e9b845084659b45680c10e52bfb40439063fbe3811d71487a4dd38b93f76796ae75316b9d9e93bd756bee78909bed5a010f7d275f787f0f78e16f49fd70c235d556dcc88fbab07e3c601208c9a0111d7ab3487cebeb849541a163c32287c6eeda0cdf4e84ad62f22d3a80feaba773acad20e483b48a2abb5bdeb4d9d9745ab4fbfcba85e10574bd91c58be872ba71883218854d3fda613710a930609789039e94646eafd4dda719d49e0f883961fc1bcc6d2a47a9a3bc0e6d5bf030a5dcc97405b9e73e41919e29faa5c9df32979b42cc2eba01fcdf83dbc67aaccf77dea87138a4c08812dc36851b5b3bae6204ca5384733970bc471ad92764a81960b61d2a2157d6e21d71f0c89c20628f39901e6942b62030f9e1ec7ad712e9091d2ad3ff218ec3b868376a8799a81e53662c0e690366d228bedc14b4fcb0e78f7e3ab64231006ad15b89e3aba780f55057500e1abe9a0d9708d70be8042136b9025c2fa8fa4273beaa20834b8cb8a976679f2411a3ad3f91589b58c5056b3ea62be168875357627b8efaa675508807cd62f55fb298ec08a0763f49a144ae8baf7b2a3750a4db1f0bf2e6acee4abc8dc062444134ebef6504c957431853465e1ebf39d0c7d9515ecccb89b547c674bec5e8de58069f3832df3738619e3bf138b619a266def22c1d43e7c763d131554d42cda2eb77054e35be07be5a82a412dfa15593ceecaf29c550ee6c5394a693170942d1dd24495a3e9ac6a469771a47e345b2daf508b8cfff23dcbc765f3fc05e9db3c2eed7ffb17953a0db73231f8e189a91d719dccfcb8010f286ee00e4b3d7ecffd09fdf63f1c657348456eed1dabb30ddb9f9ba08a54140f3328666b32422b5920518e46352023b9d5dd6679529380aead6495c5f58074d84fd4c398586dcf7c9c581685c6ffd524dc997dee47505c2a064513e3287be749863be43ddb4c630c1d2867f1494689f4682eee78549a72b968bacc745f7b2173dff06","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
