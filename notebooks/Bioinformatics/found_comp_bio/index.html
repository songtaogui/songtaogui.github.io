<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54f79bbd74fe5d4ae9962fc0d75db3503342b68710947786c729063063b68dfb5e259f082f526e3561a8077251e3cd3e54e8ae55101eedb1465346430e237bd1529bbcf738c9a1cdd63ba898d87fbf36004cca850ffdf1dcc597274d0366f17b9c8d50d0c8fcad25e189e1868e36a0bba1579f3249757ef538e5d53ed85de3e2ad7b162cb3677084ca9baf31e617f014a6d6f20441be75c13e074d06525bc2ea893e45a6bfa37bf236d8dcba118a58acc6c46b25f5f56ba3d9591054c299402af99d9bd9929d07659c85b30b270de671351a4817f9045ceabe02b4717d6129fe704245dd2e44eec55cad22a22733767e555844d86fa41725f33d55f51535f3445a0383e83ce1ca09280b29ef10b9e8941a15b1a6374d30cd6c9223d3859105dc6f24befd49bda81a69664beffb857f3ac62f7501ffb0e8e7fa859d0b735ba62871bb2b374fd8c6866f851e7d0f1d15950e8d652599b4cf46559c2f6dc637747be3fe6f8bc0b0639665310db1202efd85e2c30d043dd11774d845df153b4acd18a1c2a91c27ab6ec0cbea70c9986c4bb8d30b308e7714ebf42e9e95fff38ee61262a99f528e12b170d35fbfce3c7d94564e953e22d441617c17a30a5131d8491ff655cd4fa96e01bf4f3292bde19aaeeda45f9483458afa796b31e04cdfd32815999ed694d582c764f412fad02939b577158d1b6bcddf0d04f7b93d0567dc3adfc63139200c8304f0b598ad87d05f2c84c6a11f6a4dfab5d6854ab481e919eedc4b9e913a1db5f746b026673aff70b5518b4fde5503a5aec02e416dffcf56f992a9543540601b99f28c71f2dea9b2ec3c78f2627b7111263323a8f3649a6746205429a2774c20196a5c0c3e69d97c01d5ff90308eb31136270b041d9fedb18e762f099086a49dfd62ba6eca7e34ba6c63d5c94bf46890f180f8fe67ccf8e9cd19bb40745cbfee51d950db9eac25aec0635463319d111c2d50a768c867238637dad93cfbd655fdaf764a98914c276468e52954add02e603e774d0ff6e9badd7ff0e9a7f8a301b09662e312e02cbfaa5ec45f385c8399ef13cb71873088dd221dc45682115c95201ca562a09e742f6eecca751b6c538da5fd264d952123c390d2f0110f9b5af728fa6b9ecde4418a2b8a29e0b853de0531673a2013ef996894b3bd242b9bee6f3c1516c6c3dd25681c2306069300465ff753c722630d757ce0ae38f8b9a26be122d989bc78a2c6bd4a83a30c78600918c5a64bde41c37d0744e414444414b2ef1452b7468ee62658e87fcb64d11bc059fc12c6766a366bc04e3050c6fcd1c57a6450a210a617dc766197299c7c048440978aacbb2921bb21dec86096db5a61d2b6e6540ade33d68766f0a0f98d505342d8e14f98d13d16b8c5964e63c6b37db41969a7efd88b7dd65c5a7903e0d1a5e1e003415653563ee2a4ae157f46469ab64e61727890408300f91779d7c1b64bc1bc31d8d6ff3c1b003fffdd4a1be1e90d488f864b9f1e4cdaf1adf874a9c2e11327ea328f9815ae268ef1813b287baea7031872f302c4783ba8fae0c639ce1fa0a16679142a276ab09bc973d74ff51c00ebb28076170bae2a71efba224aa5055b769d38b8d3612221e7f35a27ef6aa5dec7c713adcf88ac74852705beb1d5b603e3dc0be5f6ec80321363eb5466ee800af492e9f763b9e2df8c0e80e5399c8294b27d45458e75df479ef6105396dd1d96543e4b67fc20895ecc6bcec264fe3fb83e565ef5fe92fd244571ed926965305799004e3153254b3a1978793e929abbdb6da30eb8d9852875e98b05635bcc7df584eddae130fad57638b026226a8df2ff22e9ea4537ea24107ca9fbf49eaab8dde53b996d81a2df286e14ac1b222554b8111c46018f9c7ad51bf1f0b474540b938ebec37cce494f8f1323fa7cee849e793efdc0e4b9b7d4ef8620674863a7507460ba868e12c32a7cbae2566faef6a2b529fd337c76bb975e1beefe801191bb9742f75078da27e3b691c3c2825e46a88f6a065f64d19e30e522c9a983f04a2064e1f6677726777e8bd86bbbfd0768350ab0f21b1caaa5a6de0e7855cb027d656e8e4550323e9a21e9d7ff2af5789501f49eb195eea536cbb0a8b19c7f5204a16171b0e0676e418d313586204bc19ba77c95d4e914f0bcc6c888cbd75313d6fbb3e4d6d75dabe2d6a7602d6b6cdd1f17b9dc950c0988a3c75c232153c47b425ccdf582703a6c20d88b822c06f4427e33ec97e0706cfd0737af4e3fade7fdeddc2edfff231dc3be04932f3e4e600b786c759c16094169f6bcbf1205be0b924a685cde806df4a0a6f2746a0c58d8fe04f5ce020c1a0e0dc33a7ee1459b50c149b7b3197b43b16ea6fc58c3ccd11b3263647fef8d5d1b40d62b31af3b5157fc95b28b8d7c18a14b6d3a1b4b24195138f271fdaa3b7437c518db04aa762c9315b571c72cee8ed15ceefecca9f7a9e9d3fa8bc5ed5e6185d5eb3e013d7d4fd70b0dd05b779ef18ed600992540ac4400c7bd4c8c11c4bf7ba75ab73d77111a52570e80ae66e127a66208ef37580933bfecb994b2ffc86b1142c3aad867c8222614170c30bc4a31e9150bac457585b90272ef9acd4ad1f764352b7df5b746049714f5d15bdc276f14a70ccba9e3d708da719a0c696fe137c337a76be49567d4d5cdbd99349cf672a538f751629f7c633a6dce6a1a88978fa02f2d7360f0412ca32890c5783ce2b2e2f3ee6a8bc32e3e510aa18721a213506d79d9b90956b0dbe89bed975965a7b0fc8a0262d7edfcdd38f445d9df602f878d6ee37ece4917d994aa455f06c7157cf5feaa3c1487532c924f9095911ce2d8d246a4c9710676587203d2f38f3d6b8ff503e566b81f3c6cb6b6bb50151e8646e328cad0fb0b9346d14d2597f74da8510da5af4b39f1fd99665cb487d45768a815194d9943a981809e0819fe1ee49fce014412260e7357e94548c67ce8719b33bcc8095d63b9c6ccf879fe31455d497a79216e8b2c43652ac0a51703ea4116fed3a20b77bd2b7c0da5e09c15eecfe40ee37476d032038f2f4b9f3fd67df1e6b66fd85f226cbe58bf64c982d29f5c089399d40ba35bf160e98f6ef7613c6eece812eb34603335f1e3bc4d82509bc6077cd39bf381c0851eb4994c8106eeff56c03e8f1bbaec4fdaf49dd8a12989af26fe9d604a2ea7fd87536a24f3300c9427623edefb86787dde9243125c8f2198c9949c570b00ed887d327eca7070819f4a27b5b62f980823476349b3cf068182b492da717ab4d2f6745008841e8346eb2bf8afae5d79f11f3c70a64f9a12077ed9e0c008924e9ed753769a4d8948d7a80f11f23c5d27dc69af105f389f46338419a9dddfb78a7bd485cce2770d7060b5435b5801ebcf898f39261da01043ae27bc9b311497e3397a1c8730a425f7d7b0c7e76aeec9d96fa80c65a25645a43ce8ff90aba6c49e5381c3804ab74d80e9655aacee672856b7c735ecb3cdee9c8684960a57a8cae8b40762f6b295fd65765d9f1789a78e9020574b3368b2c8d7a8d3c22543010503b5deb9a4a9ab6c48760c6ad6592969ff5c3d486e58b12dc8f8d03c809ee8d4e0a5d24cc5ebfb1e60b993f770ceb8970187a8ac5d8ca4a9ac411b2fa7f4d6713c4ccdce2715914cfe8ba21a4a50605f06b4cd88e97647402e12b9bc83fcff2567188adb5d0f318dcc09b409886cea2f150e9af7eea0256c58405c74b5dccdec09f977767d51e63b477f79c0abf09acd45421e03130e3cf9719043dc7766aa849dd671bcbdbc14b0696deb64d5dd6cb1a78546df51f6383fb0870c6caa7cf65cd8f4ea6de9a595f4a6d6ecfaa1a532113ba836b3aa1821349b1b6ff2fd48c32bb4931a1fccf09494edefa0edd3e57c0b6a705876e1b433db3f1f943ef1332afd8005f95600fae241be58196c497f3126f506419421786935a88129ba80a3e584d0aa02783f76e4264e291a1202abf9a61e02ea312f9f905d4b36b19d3c6fa47d7af515d6dd632c091fcb6873d8968fc76d3ace354512e9bd9daf59b2173b63975edb4cb539852f8ccb2b43e3aa3cc7a699db326fd82a24b149d578d119275861b2c20d34593510178ee96faa46de36d669ba244d7317a8c425595312793a7126d228da69e01ebf7c5bc92648566ec49e878ad40a4df75a765c95f1b5d56142f48a91375238fd2b288158a922892e336bf1db0edac0a7050682fe939846358ddbecd7ebac8863f77f3f1934c8e3535ce2a392aeefa80593a1cf0da535fb67fdcf231b07275e5eb761b11e39cdae777cb3b9272373962426a630121382161ae4fc44ffbf5e719718cf1df6ca165e563ce0891c65fffa0121531308d3c3ce452dd0e539d69a53d85436b9136282395432ef3cedea854b4b2b1a93bdc8179b92e1d4422dede35342d84bcb31a26c01f86a6cf358e061d43b4919f4d3caab6fdd944a079b0056dceaf3f043caf536389c04d1b31c3a9cad76041d68e405dacf6f7520d0c47610772f78d0936357ab1f58e0404a413b43429ca4889461022c7dfb97a8e09b37d13e15956bc417a3915d9027c68698a6ef73067feb9a67c4d9e110b52cfa85be09cc5a4cc970e7affb3ae5bc8cf933f56f5b555911985939d7e5293dff909b186020771d71d937a59cb18e3b4d98c0e43992732184caeff9175839bf6e3d51f69c1c88285692fbd68df2014f4f2ad8ee29524bb05faedac7a66e28a0dc3a9dc1a868e32e545adcba0703d5ac00a06ad701a4de1a4bbf73a558900833215599e5bba7f54e36f275e29a7754c265ac5a4d55ee910462923f008747858fdbaff5a0076528fc8421e59a97ea9755b02051a3f04da9f7a7b95768fcf8e0ca0379cca29f48eaa944130aceef07eab404f964c1d22a288774c0832bdb088da726ffaaddc7b4e1090e03cbb8e2b220fb7cade9650f88342f73c22382cc99fe0a698f43ac96d101e68d8149925ced55b33a6ca4c0268dd21ecf2dababcd154426579c68dd37ee4960832b959fb5891cbff86d21087587e6b78d2e9f696a194f2943d9b5ade2f6f3acc0d89e3aac065bb4db02c37585b875251f6da939ef4c55f1fe255f734ff2b4b46337c534f51ac4311d32ffda505795b137fe1a7834683321b6a6b564bd58c488efadd570637a86aaf8c96921abcd793830cadb381a0e2f8cb9737d747eb3829598fd3b86cf3b1cb222f509587c268dbe31bcccc1168ffeb25ba2144a465d0cdf190aed19b3b9daa83b1ad8a18476c0c12dfca7265d8752e4d725f36b8234b376d6c68c7b7f09a9d892b82b42d76d438b967d12be618b684805fcc56d1e3036d18bf33adc54fa808bce9fe6dd00cbf740beda03651bfd5cd0a60a7debdc406bc04a5fd8b17c94da265426e64d26eec4de8e4331c7093c271fc9e13629a019505e9c1fea2f1f4252c491948ccd6dddf58b4bad0b185f5b41e1506c7ce715572f427a0c10098032cae8761b0847cad1ef5db552fabce95774c962053fb23438b18056749f42a21f69e3fd70ea94f6a6feabc850d0d5d9d0778f4072b97491924251ddfb202825d1d5e0d3971f79409d73b9689d69178cd167e120edf25c64a8e1c1aab60cf3ab0ac21c37392b1be826fcee09f2bc8e6249f81c94dd62ec2632c7c557f744da634fdee6d25f93bd3df72a4a339d1078abf970dd36b3309b9fa0eb2a170d633e15dc629a10771f3e468ed0e874e3a646db0d30b5088fff50361cbde1fde68b8da12229fe55b9ced4bbdb7a7cc4130de1e41d645859e23304003e5438eba55a696c726f8b46585460be3f4fe9908a41e560c23311dcc5e1e035df10b98cedfd9c8db73705ea4e8c41b4bf3ff0f2b99381c273f40f683e327e28e85e381feeb8d56d61955135a232cb7778d35be9b2ab1abc547b5975d05df02379f556be04cab1f3c3eb9030c5a55210b189932bc3fbdfb8fed227e1d4615dfd32f66d36b4c13db8eae18df987d3eef711c9f8a1667fb451c5f46a9eea12c064417988664ad4d28b262eedff6b1598a87da8504684345b32c75a7510f385c36e28fd9d880ed9b26b5e38386092243945dd2b3d0ce297c27da9d5ae84625cbd4c8c7e84ac764123431b6c0b07c5bffb4de55d7e9ba96e244122542c4f6d89d26b621d8ca0781d78c13cbfe012aa3f8b3db271e83fd53f82676c36cf81aa4666eee8d034e6834ebc07a11f2a763ca19563f3e3b4253edf64de5456ff6684570f5c41961ed46dd3d300f5a6ecbb8058352dce7f44298faa45a6dde4dc1f68fec2bbe6275e390bfad56de1d8edd3e5d2452d99cd698fc52576e89f114a0766d0fa21e5a510e36bb1b11127c37e33e202807b160f0c9f3c149606635731b49c446511c9607c04642195b989709a034767de10078477980b7c6355cd52efcb745a031337986904f33a41f26bc8e82d8d4c54a4efdf87451605ac65b2b2e68f41302487423d44ebac8fd58a910062da1061c02cf387dc85ff0ccd9da381ea6af0f68b0b21faebb9cf373d946ac43c387915b9b812c144610dcd821d1c278674ff27da3a362604359d8ae4caea57e07101e503ba1ce0c2e849bd3940a5523428df2dc0b59e2dd3940dc4ccb65487c03c7407b38af1b162f15ea008501c890239e50e6583f19c767ecb7c82cd852bd8e77ec7120321d6482baed1133509a6bb3eefb632ab062f99788bcff4609a50876b05e4a5f8030449f82c828786976a390e9e83aff60327c7255d952d8f03f11bdc275448c9139d7eb0360705ff76a30ab073a0e3b30191f3ba7d83888b421279c36dcf9769e8ff3fed804f7c5d5e814e8332fa465217ef5716e74ef961070d99fa6c799f0b0b7b8a306c0c332899d4e89499e6d2d64899f6d55416e488674d35e5c8470956bae3496c2d851aa3c33361408c88d96240ddd47ac61ad670eac100bc3e609157e927b554506fc546703ec2da5600bf928f658e80e9fa232639a039d5c29ae63bcaf669007ebb0633bb033e6359347e867263975ff938b3b56f1be134e39e557a008479798e7a7afc8332f3e03acd6b0db48806be18b2eaf08c356e65291ea0c0e50c50b76e0908d5eb86535a2e8733eb2fa71842c65b6683a9f8ce72da623c39f977716a276bb63b862e06541c76f6eb14540a0588cc612bc28fbe2cf8721ee53a7c8b4a782bc151d420f9b0b732d6e097ea4c6ee6e133a05d032b752e9faa923374b02b5895a577e0f732f28f8aa24964482cf391ca9f7014a6d7222c237508dd649873ed9f2522badc51462a504a45a69ab43f012bf30a19cff1112d496762de5467d0597f8883f92a4a8848a5f5834c87c2efeab8f564557b40e92836f5baf41b8dd2f88444822e15dda76eb72819f2d717d8ca3c77bfade4198e0e9a7bb6a59ce9feb32c8b608911913b405f0f934d6914a46e37fe909dafd5269f7094249df57bfbe4e4032368854caffbc5f0a0f486c3e73be5ce98396d41ba6c2b3f04660a489542b51682e48a6d3579c853f9c69721697243ac376018844c43532ed80f86cbbfe2631f367e18254e0476bff40e86d29ad1334a38d22d0ae861f045f3242f2d0a013aba1d21163a16610745ddb69b90b3cc144fac7dad2db374b9cd92077d5843b8c3a31c725006deec7f238566745c3f98c38d07b429a25ae7adbca5f13d06d675f85b8e651aa3c5642995da23c1563c25c4872106f16c9a5946278adfce90d1b0901f44f1a3c6af8b99a519ef2f5b0b5c7074f71b629eb6f7d34253d229369d335529c8bdc65d0ad55dec028879c6594d27838383951f8ce3c7e864af11107efb038bd83f6d81f15c0fe03fe9fe57d88d1765aee5aac6bb61e74e1ec50cd5e8b3412cb21c2bb8bda8e8843a263c95245c70964063a9e21e078aa9d6cecb4ee0fb1003c5ed39775d439ac36529faf591a71553943a158508d67df5028ba7361d957ffdd412bc8f47a4655e38b9af89a13f494f4fd007a5e9efa4b1dd3e41317ce5ff8c4461bd3361ce8b43d38b69b55e814aa64ec1f39472e66bcade0bf90850f87760ad7fed55798ab1d0f53e9a308b8f658fc3b2fc8b4e87780c0a10e5ec0b6d9a760ad77bcedb9610b0e71d22fc7840d8c68fe08430ec03c0e474a4b544011ea01a2d7328d3df46a2e3402f26c6d57210989a832c97968917a32a7dfc3454b3ebea62050d889eb02760f7255c57b66a576f1e181187333e747ff1c07de994bac11b869ed5e95c3d521d6ee6ad2e31eb97f068877009267ab05664af253109ed9160d0b99c12f35904ae43d1faf555a429d9ca90057e3e2e03be7eb43432850b6a74dac241256ce297225dcadcbeea10e39aed68c9b2d9ea0dd01275b826cf780727f29c84015d23c3ddf901b40139111b12a9087fbd91024dd5bd11fa30287412344377ec2b3167496f38b9cc5591d9faadaf9baec7d66cfb5eee3353762823b82c0c2b08bf4d8f2ee4d677e176ace461f58b0097a8dbfeb8854ab2148780dc87d38b9dc6c97544f803798ffd1a98f7ee3817d4b6aba023918bd47d09b605749b15633e9ea683dd712dfc25a71ba539eb5bc8b7c3525bac3337f941558a699abd618004b93d18c93dd765116206238d35cd7d345cf98110f56764e3bf48fb2a686c94757b9106e0c51b7d505c9cb3f3d25fd8237d79bbd33ef7895518903407d0c5a5483bbcd84bd82b8a0c8dde8aaf19f921260152f8fbfaae44293735baaeeeb41d94e8299ba9b4fe0789a51f47ea7bbcb04d6de53286684cb23e0d490ba2b4498da7ec56a0ef2acd4c1fc9e14edcf9da089ef645790e383dff55cea0b4ce339eb5df0951d3dafe2d0553a817f8f6b51c30f7ea58f909a93e41f43e6b69da50301ae9b824c0a81a753f8f662c5650d33b43b3722b99de10372f69a06d924a20666dfb3a25c8b35ff7ea0bc1a31b5645185d5081eabe017e0371ce1e0f2f80172badfd53c248b6f024a905eab58a11e641e75cefe4d915d8d9268f673ef3e657ef68879fa03c70ff2ce75d78089fe7abc4658ad8e9873c119fab9b7a0945c4d97dbb34c49196032589f564b0f36a5f845d5eeeb69114534699ea55956d96f65ee9c16b24ae0f21dc57927a5b9a84348393c1ebb924524ae948b68f710906939ca079f08615927bfe6d6419d00c1268ce6c66b8bb3ddf1bf640df18a6477ee1587ac0058c0b4ca16f5161ef669677a5930cecf3ffc7e14bfa9d14504d013bfb20c1121b4431b69f353467c868ebacd54f27917280cf8b5e746c3e31494f5ad8c7e0a8a09a436f01c27fd9ed302193b7b74a32346920cbca72bffe0da066d479b756f624e1e8fd9791949397ffae0a1c36109614cb9b959351753d0f81aab282d507fe417b1b583a503b05480ecd88ff057aa88d811f9f326fa4f9dd6c8adbac964f3a6be427371d68e5c7d95690ab9ad7f61822bf76b419ce05e506742b6b5fe5bc1144328921d54bfa2c872d70ecfb7278e0d99499f0e659a45aef0b1bd2a330c76b5ba3de4b7a02ded5a49773cff4705875b0f444fdf9551c79d3694a72319f84ce25b0ff07665693aae3263bc965e7b323db3e60d375133e75836c57ba4156fdf2512ba6cdc066957ed4a6f4861d512bc5e5f0eadcad64aa8ba824bcf42f1123d41b9ba64e015e20d6dc5fb742a920de7a967309231512bd08523e94b37b1d641f133b983e1730fbb0f1bde674d3b8de337e90602b47d0cd11337c919bcad1d8a8e5f52aee79f1b7d356aacbbcfed18c99fb1842b7eb37963468bc9410d3aaa8809a33b93f54b74c41df7d33049dd70ba15f841a308855c3190cb4f7e075f19d189e948411ccdf48dd4cb3645fcb9b227851fc4b2fa3da3dc24651ff7fba97915aa9c9bd90756d6334a416535474059c1b2d3ee15dea9afacad3a2c09faa2a0e5c41508b3ac63ce1569df53964b1290d7f0a431a33f83eb141a89f19bf927d9d65c2aa4bfedf747a7c158c50abec7dfdae1f3aa22f1a5e95e6bfb39c78bfa645708ce3873089f2bb1fe79df95ff73b68a56e17bf8260e9f71a0efa44b2d16c1b528b3cd7a1cc29bede7215f16def1ca377382e2e57b895011bf6ef74a353f18fae3dae5c7109ee7294bea5b61e7d4b36874ffaa425a5141c74e84f6da7a0b8108666f8919780aa12377588c36fe43eff253e7b32696a8d9084b5c705d633efa5a81cc367197d723b7603e41f26687bf9fb189aa7585e5670ad4630c5beb243395b21f0791c6df7b0ebd17be6a98f3244cd9bfd9c925b4a6f58e7aabe286c2f7a5640ed0c604097d394e34424788da1143f21a6fa0d2257fe21844e35774e463f0d986e51ebf8b5ab8879bc0195bc906ace6e8241a43c8776f1f704bc0c76efd34ca3e99c8840d39195938245c28e7d52161222354c8756463e8a16dea76fe3a1dec238eebee857ae271a18ee3878493bc2d402742e2f365eca9732f0e64c4b0e65335fa3d49ac2cfcb548a43af4a5f6f1d14331c7b3064c4dc2a0c37ddc2cb5660442146268e59bf6fb7d58a8857d8201d6287fcf224a9252aecf27aa9028a890c066587dac96ce93d50ffb7ca7df8cc9183380367427e46ebce5a9c6b48a437862fdae0eb89649a0a802b0c23423f5ff4520e65665307ec13379bca6de0b072141794f9a73c39886c17145c00f7aceffbdd6ef14402b2ec9e4f3526ef84ee18ca85838d4fe34dfb287c41aeaab164a5dc634f6a3481b7fcb0d57abb5f83bcd1ddea59639b7ed693e0f105390bc0daa8e025c1090db16cbaa45fbaeb6b9b6379652d0d6cf1ab930217f5205d0d6b1db5e6485635d7fb68b49465669032ede3918f3001338c1dc04d3857a7e9baa34422329db07bc68a18858f3d152c94038de071d8094fee41eae7849762ef2a3effa2e4070d0526214ede482dcbd81cd1f3844eaf2b5febc7db896aace0308717e81855cc1efa301190201cf677c306158da92aa4aaa56d1213b6232525ce1c7af96ff1d030c3e3b3b67cf21275a6b8e99ec6ab9a70db9f522c2f9e3ef3548efe04b6a44f8d3cf58f12ebb6e893a3b85403627d55837922c6ba5eca2c4b4d793c2e8c6e331a38cb122858e270fecdba708215e888978b594a25e5821cf2b4dcc2c2c0a4af537f3940605ed2f7fb57702ef831350a7d05a7e0c3728106a311c78f61485cdb1483cff597809fe102b0e1b0f6b5c13966c17d73e54c1635740a4bcf5beab48809379d6bcf47bfe1ee8f1a62ff321652a94a6a408d38461c625df6590452a96c606a8fc777da5b3a588a609e9d2c30f9844b87255ffadc4cc97c3e7ca32969f2500c8f05647d915ae972758a6b4c5cc2693950bd84c8773348bb588fd42e52bccd232c50b9236cf23f8a3cfa259821246445efce42dfacd90b1309fe5be72cde6c9ae2a36f6865578587881fe46196695d3f1dd39db4868e1ba6d3226782ee6af3b3f44a05c60ebe4d16ef5252aba0d30d17b3979523ce559542cd8871fcf9a705fc32fa3466ebdd0385f4896812151b8e60f91cc9075990d6e76a55dd2c0b48a6abc40cdca68de369098f9d2f6c83dca6ab1868bda74d1bd6c243accd1400385038ec2fb72dab2a5afda2aa15ed6a203c91294098ed133066a3252918eada63a9b053740c7e5c491e7269c6ee66eb918a7f5b74cac7baac2c466e99db9a130c86b5076ae926ef7ac692af0902347a7e8c9db9391c8347da2bce6e11321cd62576cfad6ca13e65878014431acbb452b1e240dfdc7729f5a5e697ebd7884a0ca3e92cdfc706383f3285c892412c81d9ff8d17693dc433483f378ba8fce940c91a9259ce0504f9b075b4a479da795d255204fecec5e5741f5078d908e43f672e09058d99d89ea0994a654609b6db6f9919a6eeb6cd43b479ee3a67fb3764ceb46a359c4edccc4509fd749a1b12b35904ee039e87712b3f37f0591e3c83a6f0630c3d103fefc6f1d994527ff8dd9db96cf11f5aad3ed4c768590caa2eebe33dd9c4cc77559fe3b1f7d081b257c862a11b4d4b1a55585b5f3de10f02fa288363bc7b34afb35c8e7c2efe1a43f57347a7b7bd670754d1e4b4939beb0f392f963c4e9eb86f691da79dcb227dced0eac46f7d44eb1fdbb84d4dd3b02ce05f8799a47275d72fda13d1b92d3d13e8c5ab1d3162ae947311e9618c600aa03238ac7242bc349f8728872fcb559c7eeda6634c2fd6bd4b316151679932b86bd01918e2fd24c717011b4ba62ebc695534b619a4bceb7cb67c1c0c83719b0a80dc652923edcc128419708663c7ff1e7d1f81108a6463f1df5070b0e5546d958adc2cfeb9375533241f6552c321c84f20b090b0338c78f3aac68c5518812114c67b63bcd6e2bee49177f7178632c9fbd561b07d14e7f147eb6b76532630266cf2296c479966ec579134d462eb45004443bfa951e87a07121727c390eabde965ee7d17fd6088b84b50d0487170a74441c1329c0cea5778f5804dcc7474627af21495d928465b21ef58015442df4ef522f9878bc4654a3c37d8dedad65cbf9b85e25fd5c2e4e064b05ce507801df89df9630ee826c8b40287f1c3e67bb2d9a2407348d9f78fd0a6b69975300aa3f0449f4855d9fc6e6887aefe71819a002b6c638f3085aabb1e5e156a8724b797819f19ab3385edb98777574a798c3686d7a8abe0b5e6ec6ea85f8226ef03e8ad2029219b41fe7032914eba77bc781531cd61765153f7552fbd255c7168dd66bd2167c1e44026baa6d4186aad3718205d490e8dc6a84257f01e6cc0d37a8be7aae6b3bb8980b534dcf2c11887b98758053bb19c7831eeb4b6f55fe016c8313f1fcc4fbcdc5030ec7affb46de9c0eb585ab77dacf8d283fa3abfdf2215501fb33b26333cb82e230eeda34daacaca26f8f37fb036597d21d4233f90edf740aa196ad6b4d23de7b7ecc0db92e20010bef5744dde338252a383235904faaccd88b69be4bc742bd0141ea1d89a255331af42f8a5b9f0c5aed5034d8f50c8790430ab62c14a0a81c5faa3fa85853517bac4e7f84d949dd7dd99fa80e0414b49f6811d494f5566719739b8e262f1b82d7e51d4d51673f6b12d89e1c653e6eb6eef209166aaf62fe62ff3662c345599f3498c5ea99716fdab5d36cae9fce9cd9bf00d121023259159a4da791f6a6491ccd7f4ea7b0b7c4c1de75d791cf31a59fa3d969c39ba0ab99752adaca2b11a4db9fa750880decbf09d0db6469e6e9070e5da4971c28ffaee4166abda80f034079088daad3bebd440145fe9c8dd1d8769e2af06102f5efee502f2b97518f8102e2b40c39cf56c0cab25bf380161ee2337bd09c1d16c21e15f52216f687359c42edcec73e892e786a068270c67c8113a714075582d4b1e262fcc4b30d0da36d8d44499f0f41a805bc2b70b50c0a87382b4d5b77079dca0d4291a50a9b813eb2464bf6914eb563bb5d18440c2839747982cd4f058848be6acce1d47dd57623cc64289cacaea46e66a2a5accfe48e1761db1e79a4b2ec628e106e25a005ea0743d14b0bd7ec45e7a7a176c7906618123e0a86462126ae1ad575be75ed04dec7f94a2fc7954ffbcae6a3ab4fd6137a968e78b84652771db5b6ad12edf0605bbb1ac56ee7953c923b6ebbe66dbcd492f2bd513be66e27ff7588994345816b858ab1dbf9e57170d611ea46d2e563be58533b50d79f4bf8738472973d676b5b1a59850adb898f1d99fb2c098ca51d73cbad16fe0ac95ed5f5c19529620966a49ee32523721c6634a8a2e0a4de2686a678b2cc5e25a3b6a682b0c617e3b5153d895c8ab88b561e956798fe68d55c75aabf42560cf0407a66c0f6545497b395f2772d42c12261b0e03299ca053fbbad374a576b3a3d70df3686d2fc0ce3df7ec51762ebdfd11cf0a4bb582f2e1654a025ed785cacbdcefdcb6bb892b00af8cc8ddab431ff1404518800fae41c50023e262bb76678d36ce851a05db334a81c6ff056491bcf36c5e0614458253d2ea794b36b070be20a0d1b7dc2b9b31321ccbd1f8bea02e89af3fdda82209b81ef6bdbe0d83b86bdcce60916d5dc78571587193a1f5abf3bf5f0be3359e19de82b66b350597446ae36fcb574297c49b5854cfd95c0d5fe46fa4091734241bd575811a0860467f71a692db33e879ff2976020cd2b7903ee207b4e59e2f59e10db7c5cc474838739d455b806578f54b634fad19ef2f6079b3df9db9845a5c2b59d2d1a3362d253891d5ddbd57a8abc841fb7a5fdd68d0fcec5753e2796f98993b8ccd277f3b928a2665e375ab19102adc0ec8c227f1c4c6163ed51b7671d9a8a90157bdf189cf4b9e472e8f4dbd1ebf1cf2188937277f9926f015f0a77c4bb4b1de7b7db862d26039018d25a026d3d1c9ba27b18e239c105dbeda66f08ff54cecb30ae50eaf6fb5d357d5c8fb01373449bb06ae0c5a73cefd91c11efb7a3d5a305737f0a3c608498e0ff48e9ee22c96a8de7240f4014c3b18d2c3260d14f8e47c5c38e8f0bd7138565d8613316015125c7437cca983a2fcea83a9b125318abb56a549b8371881a3303dce4ac829c8c5c4bf3b373790cbaeabf1bf5a8e16a3176bdf728668f3f25be6a6cd528bb926002eb4dd01a71a3e01a3090ff4eb08cbe03bb88e8bf539a23d0e7078c930669c2a5adba666c1273ebccfbcc88569dae278148b07deaf878e34e3016e9a90f63122bf37679186fad33240824eb688f2763aa2994647d512f45f00d838f0bfd1ba5594aa1c2ab2911d2facb6cfabac3cd183448dfd86e70e4a8b7d70bfd7aa452805c352d7397eaa03a1cd2f0be4880594ae41efebc42be455115c7717ddfcd3186921f5c8d3b75aa4b5f2af4b43d5f60ac43acf9e268b82f39ac8d043748ecd8c48bdd7bdf4d7862e15d7cf0571737183433aa666a321bc0d3317bf7d774dedaf2b052e50ae851302607e77ddcc7267362f19ed6b5e9d9758711b05e39acead0719c2aa38d54427780405e45a651e735ce7a7754761b890bb88bbf689534347a95fcd1acbb9eec14e393ba1df021fedd338b66b9a8c26f80c34cde7d569a59d1f2f99e5d32e2b77c3ee2409f7dfa8fac431858e7bb512eed7416fe4bea2efacda89d951ac63a82ac74ee32b9eda1d6b72794ebc3f02cbfae7e7180388a1ce0d9080e39de6fa088a1ed440149abb7b4b038ea300b2e6e3a1df53ab1bf6c685f7328479d552914d841660416ca8bbdefb2e2e0faac8101ab06fbd579b7ffe88b6dcb6ec0f096653bec6cb2cec36a28845f0928d2c197c9bb46e993cdcf3319d0775fd6156367e89f5b0d10d83a6f6861433b6f950088168e798765dccd0b7be2516fb1f49f1d44b375f217ba1b85f83e7aa03e8a160ffecf879dd688285dfbac0b0518a7d5a9146ad8b0066bf2938ec348b55b3a69acb7ba6a453e533211ae0d669c9d6b9ec59cd47e88cf6fef7d1a82d4f1a8b827178c4cbde6aaded0f7486f7e3df4219daaeef12be64ffdd20720f3211c2b89e8ae37741be1cfbd55db708b263fe6304e212b347d82aa173ef0e13656e7224311d497903b5d45c212cd6e911f8edcd53296e776ac9f70dc1c86332da45d306bc347e96865e58ee764ca8ca223fed654069e5c4895a91a9e5fb0372b14aaf9b54f289e959961d92e6444cf52e155fb53c604e61ae57945916371c0f0a36da571b5d6dab3d2590acd8a87e0a124951095164db94e69f077e4538c99829874dd581a79ac735d67c9842ceb669f6a06a50f16f22e80b1d8353f22c777a15838c977ed0771ba2484c9599a06a9c05e705ec8fb1bdc5d128f6e760b6d4abb1c6689e20c1b103d24511b74c09c35f66c0bb04a6941199b75937a4251037e6d8c4f8a00c546bd4cca3294ae60a4e8b18cc79d8e904323f7cd615e05cbf1148fc37813ac7550bef6d338fc29cbd354b875a86c2f8f1bd61117235ba14599d5171f5d480c6164baf450743a4fc5be5f6cc36b98296d47df4d1bdebb1310fc6638db0ab24209f6b79a8b68fe6ac4ed8fef2e1d38bda5f78169671eebc23c4a0c4ba193a0af1d00817b6e0b3972538f3f0a8b69e444b2a05fff6afd744a39a341d1e65085466c32a81adef0aeefbcf139a0d03413f9a81981316952561738c9a70c7971d00217b348acfcf3a6ff41755ecb060059f6ddc7c038a00cbf4a7ae4dec4d62effd98717030c89a8325f473f0705d50c77e76595f2e073206863572a29c30c3ad3306eaf1279fbb152eec3388586c4add14d59226a0155f0ace40a76026c6474aec91b48cd6c4c854ee1329b0db4a9cb9360315547c87d5fb445697904d248f5a37e2bb46551b95b6fab870e71e3fb9eb9615922665b64f60738a6958bd0541e58afba78e437b615f829827debe8986ff87613d63294f525c2acded98f2faedcbee610691fa5fb8412ff8ef52ead353a35c602e9f59fe9e3e77539a801818941a765c6f2147583bdb85a342e82dfdd0fd8b35e0b575fd17c982550d23513e43ab695e78d573b4a90449f83e6c39f7b65c011d6551554beff19627d7964fbe8856e8a89260c951f2bf6ac336805c03f4dfc41c8261450b41686794483dbfd4ad6ef4e924e917a55551f0668b5a347d93b7b8d9b7ebdd220a0e20314a5adafbf658d63ff31888cd5ac838e4304a85bff528537758302dcce1265462abf70b23436c8993c8459b8edd5f99f83c32fd879d03435ba55d396adbc138a7f9b62c19e3218dbb6231841adffa9b7f6bcdb32b4454948d3e1fe07ea3ee5496424efd2f319b381fa750076e1d7f4df3626e912bb95568837b56f5cb6abd169ff3c4b98ab50b08415ffac9645d78da0778af8c881377fbfdc20f4f84e99eb45ea698a05d02f45123383a6f7175ff0e58f4eb1efeda8bfeb433738045c2087f8a45a966cddb31025f22b4855b8a917590a35bf1a58cf5a31e211b3986847d63909f9f365b9ab2c9919e648c779c66ef5d84f2aa8c880158640713b75bbc0d0042546b888203b6e175c5d4e67e242f859d75db988a5dde1f2663b7e43a0d202994e4019eae09d326948d52d2b3320b8265fd4e68a28c51b09952702cba0d287806945d9b2e55d6d0bbfb1968006b6eab1eb37f385d23b2d3af353cedc1befc8de3668346567479cb051e7f6c5caeb8cda37f778807c333be320b948fb5a214e20d02793c9bbffbb8bdd5b1f118c110563a43fb7f8b0f6df96723c762fb3ad776fd0686a90993a1ba3ba16cfed844a0f6e2a47edd9db647e247e80a138b5b135cfe5ebe703aaabef30ea7604be7645335429f4703d6f6944fe5a3929b93c67e13d864e709d326322838c49896b67c0ce34e5de568e86aef8175285f5de4609794ce69186ba8010855cfe228c9edaa4428e1a0110239c1c91756d0ba8e41fc3a682ef01d51b66816e6ebb8833768b8e5bd2444769593518ae544885b761ca74c447318484bef5842287916d55335ad8b90ed1826860deaf78c92f934192c2a73c5142246f5b79231f18251029f258c071060557de1b507800b9a5fab4ae48290b7a8c119c06f8df5c3e91b8a9932b64b80f8e502553045f8528b325a566b8355d8934c2aaaeefe9bd0407603c1ac0cf56b79bb2e11469a4d20050650fb7a959cf1c49a1f927f58cb664c2f9d7ea2caf209ca5af490a22884e967ce13dab3a53e294a761d8b0158382f0b74962e5e077c64c4151089d04814f85048f127fee41c41905402f777ffcac249b6d3aedf011971b3d8dac1f2abc431fb4244bf24377285b04acd1c300e3c8787c2975e21bd1f232d69969f2c2bc756d8c1f8c5216854e865852d7d239b1c3eed724695cc29856ed485a55899d033f1555e1dd1a322aa1657f7486c2e27803e18ac8425588ca98f82cd7e2f161f8abe751d40ea803cca96b340867b5da5db87daba59861d92846d85935ca1661146fef74d3546d5750d062c9979c08d4cf394806e763693241fb6fdf4f2e333f8543d2e5c3b85058a5ab6747527088a00c609d5f5d866e35cbe6b13222f2c7da5037393a90e71b02bc27bb329aad42d15b1a0145ddb7c246a361f86219b6b2f03494a95840d12e550f0cc6236db803e654150633e912c7494e3fe68356a723415d6c05109e4c638bc06f161d467947675d2faaf4e40265511f6009cbc9b5fa01a21434906a579211eaa6c6e9b1cc31d53be28edda036140928753b671d68aa55fef0ae11771b4532dce81039bd931aaff9a86e8d48ec96c965f21d71a840c6b2dc949aae90866b33a4fe3db04dfe451a862784ed00467f8275d0329d6a6001851dcb4d4f85f1e0d92a16901b2787808269cd226b7b00b4e20d60b54666d0480bf737060a8d78f8f408a7f647928d3ad911ad8f7a0abf8eb9fc3c36a6867ffb21f51f39192bd412a6df01cc3e3c59aeddb956435","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
