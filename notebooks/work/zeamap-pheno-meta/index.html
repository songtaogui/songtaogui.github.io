<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a87999691db40b9519b81752626011b25ef336f9dcda64306f4b613aff4d07cbb06babcf50cc78362c538cc08126407c2a07b13802c382ef9056ea06a7d021e708c8c578e9f620d36ea6458e3dcbdd0603c8a2c530cacea7706a5f36f3eb2a1c552947ffe00d14a22bee7e2f18d83be478a76cbb101f4f67625fd229ca5b24f0f797d3263a7ae850a069ff459c6ce42d72eb9b81de0bbba11646862f3219f9e401b4f0bad279e029f83a31d431746da95f4ae6f17b7acee6964e73d5c82664a0b9cd2f5e96726e1043ff3b455b7d75e593d373d6307a0ae6bad7704ed75984a92da07a9c1e786fe520b8339a065fe5fa2b6fe9cbea741eb3d7e19530fd47097fa7001e5ead4f622ae7ea1ebe4fb9d44c149ad733d708307b41c92c60b75a97f262aa9e61ea12cde09f5c0156b2f6a935875d5a50457626aa6dbb6976597248dfb9339fcdbf7313c76a6aecd23672101fe32248924d29bcd95b72ee002b2f0d3825bededd1358ee1aa54b9e130cafdeb77836344b43d0f73199ff76344c85b984c2f588843c549fef73cde1153ac24001ae7c401449219a02e51e509b0656574f84b7375c559abdf68a2a62e8b9dedbd367b0c33d613c74c1f471dfc2cd7e9cc327cb1df32fe05950d7b2f141a7c3b0e589e61a8c4d4132058ba8571023907abc3f256b6269d3b5e2884361070021334f98efb1467c8c08b317623fa4c5787e6934c58b2d244d2797dcdef7df9e3236a590a9a43beb018fdf9abce0293b43ada8fac317cc47b7f054e2a38f1fe46ff8d4dfb766c8e2fded429c99530f02b7ab3eda29f483d7f9f9a6c292cb32fc3384566602eff874ffcd328d30686718e98a77afe7af657550dd8e60dba2a1c02b861384db65944435f476029c6c78ad41cb5d1fde9af08c7bbc451a5aaf8d1f463eb35835bb6173c6245868a6dd691bd3f4b804baca54fc3439e62d2d8491b862570b93fc6f5ccf5027b8bd285001077b36832933ec648154de8277d7d77af2cfd93d15c77de7109eb48745a766a2eaa29c2d0bbf04a7928f531b845b3be462e36afa10401a5bc9fe81194b1cada29bfd827628a5a8c10ba477978655ce1fc01971116a95b3f69f5559b086e5e367f74e6b9ab91a067bfd17b32728d48f272ea436f33d10e7e4ee6dbc57e3e780d76d038facb2168075b3da8d7267883bf96fa5c3c01626626c27d000a1a22255f240a2a744f09e5fdbd7ed2b73614723bb4febd623cedb71e6aaa3b25479c861bfe68c4b2c94381627ee1017d57d8f40a0acc1b5e9b117dcce550ff071d6e08f16613aa6d233433eb688dd83d97c5045c7c091c6293e362db210f942a8dbcd0ad0e250a1e7852e106be328e296a41938512f589678e90968ac4df26338c8e62f5a5221fbbf45b61f9ebfe1fc38633211e5d5033d67ab08a6b9df97398b96cb107415990b6a260ce31adf1864648320d9d59f7741d3440495960a6e2ee6c5cf514a5aa22c56464036cba915e1f94e78361efddb1c63f49a372fed4860ac69155a6c24df9326acfba51f149bd0629a2b5ad6324bb5d91954df592b0cdec031ebf1c30826fc940ca6304b2fd6ae27c28289d236f785315543e253032a0b2f62bbafac4c4943762a62ec3c51718b41268fb66c38a40539f95f737a15a21d02379df20847497bc1f64a84b021cd99e3d54e61e55fd7370f080dafc112f49914dbc76b06af811de122c2e0c095b5e078049909ea56445ae8b668f509cae33a219cf73534bbe0e5aea591fa6bf22bbc837e45a964f59fa0feab358ff52e65234a4dbe2d52826b4f41908f460fdfd89e838d00cd14d167b360de86fff169b6d48200f2f843cbd89218794c6a976ca4270139be1cb018b86e17b6f3ada11e9c2bed5f4a3f96025d351334754c404d56339a9b342b42706a694a5068614ac15e782843b768d25e1e8f8ff694881c13aebaa92ac18c02dbba84b1490dbc0022188aed320fb6184e8da0aa863c430d1b6751573158fd3b2a026af1ca302b579230be17793775d6a55540237504eb4e33c8c476d35d454c44d736e4e8704ee8b85a5478ed3ad0c63a0173e5254f01ef621c5329f7511b2496c85c565148c4945b56293c4481e14e97a2d321b49c990b5ea0dd185204c6298db1dd9016012cf04134bc33023b3e51aac961e26d994699eff747097be88fcbee55ac2ffae382b83db8ec96526c06a861d0942dae246a3ab2ef8855505ff3ecee1b15a946d181496033002b24c62b0b7932c5ad42715825fd13d818db564b0424fa473a0a8c787833def019874a27d1a320cb483817951fbc2d5fe50c0cb34289be572a738ba391f87295be5bd13bf670ced663c072c7fc8866160503bc934d260b77901e6052852b8b5040c9cc7bcd582629e1b1e8dc95948ad9d68a9f5192982a190d3a576ceb41945289e5a23b8991c9aed3003ea448801d851e56078200c9a68bfbca93d9890f3c759cb65a20884cadb6fdaf4729f70e64e76147d010b35131bd606e7c12e91367a4113f810c299dd32e1e3fba2a27906a29327aecdca58ce4d3bfc9e0f7cf6d31f96341579f1f973cde390daf54a082fea62663495a1b584dab7d1efaed40227556779f702bf946710bef379506763187f7f081fa0678fa28e8e3820128dba4acb8ea1c36907d1f680941f5b9780a119e859d77a4d34f15b2a054e5e222f49ac8a584a9fa4c279e0e43e46690c81e8114c3576c7fd53535ff4feb3807dcbb228d59c7454fdb96c97617f57de5f27aeb987e58e043e2069215be817b1fc96889502db46ea601d9bff732ae389fc7a53771f7f1a62d7e3c4beaf4812cef0adc2e8940082ed848a8e8bb6c1c2101767574cef706660fbb67a3ad7df5b66cd1cc9323e70775729aedf8c511ef75dc8a5588132141f692f3adf9f6d40522af175499d6912cee13e20bfb737c7758048396805ba57d5048fb2d7bc8e7b2efc8c3e08a63e81cadd439a183df246dba7d82b90ceda49a0052464e55b76126ad64697b5666a19914c0ad7528c9ce0540e048f6115ddc2f62a5388fe298a805626718bf3422636f41ff91c51aa65cdea12de63120f518eaa110a9aa4fd935286e19b12109b3ae674a7c6803711cdf1df3e031c983e5c54f20779db22d1731755f4c275d6507b88bfccfd221807e1e4ab730d99382072b5737b3e18aca59034cfb78f760880baba1b9637153eabfc183afbb47e48ffdcb4e40c5ffedfa72e8f781829bc684a7ac8af42b56611b73dc2f7ea95e05c3d82165970aa2262e045748ea075140e4201f47be92a8b67ab34c4b7b4c948efead938e5ea72876b8db6a35be7f86ff4077881eb1030e5e7feae721f7bbd33f6b67975f73f43c889f0601d403d5682b308266f9314c7270e8f127e5846333f93eb76ee22550ee9f4606c0e889d5bc18aada05aa0596b0a1b859a4f04549b046008b125f0034778d00c4f4cf8eb72f4877695d75a1e3c6ab28e93e41799079af9b94698fe0581444b5397bc56cd32464568508fc9c323f4f05e899fbf7b71798f3ded77bf29863a3a581499adc7a65e855404b2fd804446318e280eb5e43a1cc0b59fac962c39d8368c8cc648b919027f7247907b0dcb8517c51e4d35173129103fb48258dec12203a96b30c2e076109f799986a51c872697aa8b18c2c816b3abf25a2ea297d46494bd9445611e5c157e666fd79f7bc7640a5c577948ad893c55b67c55369f98705e77eab3c9c3aadf9be982508196b1553e3971c01468f331269755902b07ee57f17f6ed7fbd764b8fbe688e56a2be004b8ec9fab0c4b9550723ad56fda35d77828514d7d2a35902390b1d2cdefa5a2d68cf2ec9b66034c22953d8618395c2c46fe6071ce4e2e28f3ec8beadec54efc5296a50bf0737aa4a5b77a7b43c4314f3b35046da737f5e998e2fb912a1c81010413cb933b5360c46051e672e459caaa242f216e874d1bce9ae92e1657c3e82b78b7de8225464f97c8e98635830b306875c345e252e50320facab85a2f3500defc01cb519ff4b5ddba3794d90ccb604a5614a67e2bf4d4b853f55bf4e774d1ec66bf9ad8c1015ee2f6d5af553da7c190f3f56bb3bcc8d227454fddb3ec5e325f20417896fb73d7b11d28035025266b092f8ee9b1b99b3bd0ad1eacadfaf115189187e289279451f11f0b478392e0b80ff6adca4bdb60b4ad44b86995a7a7bd91f000c2fb1fd208304f7c773ebb65293a7d08883e76ef549d1faeca97749dc75c3514162fb4ed5214780f405c09ab449a0a905b7d4c24b899c603bae007f38ff4895394a49c7fc2491487b24c0e1e6279a81aae5d01f4f5866e5e98f56848c53c456d1c5eacb3adab0a8ddc39e76a1e23340291538e9156379298be319566111c5af963690de4a44a42f6fa66a2e277564295494e50a8184c98cbb9ab6f300011635419a5c21571fdc40bba57c9a0de6b2f06a43b8b883c4929ab0146a8c9c974405c79d4d52684c733035a69da46127c4e2274ee3c346f844dc82c9dc4bc8ae824591aa781a6964eb832e7577f9cb5fefdcdbda4430b7febb69d45af23c6cff74ed53d77a593b3df7dc1d5a244ae65a5b63824eca85687f77a8627c9219ef1ea09eee640dc22192546ea1c250154a4b603fc8f7c9a950c6769a1e66f949e4cd4fa041385f46d092ee257797765fbe0286dce7c88533f8b38e13c027814e6e903880b29f5700c5793dddac1f85a78f7b9e6884ddcff882b17413c4631055b96bbc2c1778d1c8d968f87aa56ddb61659176728e89ffd4453d310ccac2e857b6a7843208745f9397c452ca4209fb0e11bb547dd9b1a0d69d90fcd5e6048d734b37de4fee82ea02560a30b86c01a60c6776cf980f447c42105dbfe3363c433e45f9260a4e69b1068de22fe81ec17d70cf30bf6900f2e81044ec3cad606c70fcf8dafeab0ea8c8cbdc4e14941a1619e98b87373bd61336481a80f69f9115c716e43d71547be6d49ff56cbb0c6536880962fd59d371103c8bcd2a8fd93aff5a926317d3e9a7aa52a21f01f9ede41c9349011648669a0cc45c23ba8962b40b7c599b720bb9f01ef5bf7648d5a9e8648c6a669b3b53e5e4864e5c6d6bf56aedb1cbdf06e635e37439b5e8ba597d7b0fcd94d14d956d16fac5af41a9280adddd3b7a0c6bb35d578c84254117f35e98c572424429d68fe9d2c5dfee1256e74c65a2f3e15da162aebe72a72b7023da06897bb190993c242bcaed0ed9a90b9afc7554df4ceb518b5e001583b4e57e2491abf02346f136616b8ea806c7622bae13087846a3f71218bae3311489ee2f724817670b5f1a18e16be27e2c036e9ef613842ed93b8c73628863517289482c4c512509e6fe00ccbac4481dad69bca9cb45999f32a6cf1530af19f104fd6443c97c9533c1f87640939df8b706393797656577c6f2d94e9c24ea04ee3304c0aa03552514207b67111b72b24499e857d4b63163e798bc575f9360e758304994be122103acd56a15376e7e313cb497dcbac7d8ae1ef1a6d11c70708bd09745b893c01dce5122ebc2f4757fff9200ba68d8bb577a9552a62788351f2de8f39c076632344e32275907226d1acb3eed14057b0680394e85378e147001646da700b5e1823bd2a37373a119030b96a2d82b3d408924c5356d856685f921f004fe5a5aa8c2951cbd699b8375b5beaef9e2e44bbc302dc9f196b1ffef6d35c5d1266b16b1cc774d6b541a274133d039471603e4f55cd5e056d22f286240225ef1f05c6242db43706408d66d31c6d2dda9e0c7f3bb079153dd1fa782370017658f95ea40909e4e2785e025e2e288e24f0d040f9977cebd41c9e2e5b9f7bcc6ed972401f3d43ad54fa5f60bcd3d0b63859ddcfed61b91eeec3cabe370289dc169176bd3752e640b3f56a2fadafc121989580d685918546a7d49b658bff22ce28703353319fbc656b07fe136e41a32cd0de8d979a5d4750c957272b834de05ba7a4fa04f52a9cb01ffa49357bfe7bfc6245284d47842042b25f8fcc6dcd0a449ad31515c13cda3eb6d455f579a3645474cec1809c89627bcbcf8d6b152c65f50dedeb8f0a25e51d332a6d2a28bbe1a9687543ee9908c6ceaa942ebdf367944e5e14555b86a7c9b53a4587df92b801d27a6fb9bf5dfcc1a3174af9a5ebfa02ddd97270c56dcb0fd5614a25e47dc57e9926b13daa2555cc01ca5a6c263c4d45d426a23c641e286b12b01bc5dfe77eaa5003e1073308b675cab549f0c97464bb2fa7d0c02d3da19ba7987b962ff413cea42a582222ab50df41c95e4fd70d3df09fb62b313f1308852496c2401cdd282c96a212496ff61916361c349fca8f829279e4b08ab7519e55dbf9c9222f3945afdcce3e5f1278a501fa1cda9305f3dfef98111fbec1000b59110d532e404cc350d88f82f6b8af93b362b5e2626be2e99578edfdf07f13b41f41f7b3140c1ba2b53fafd8bab6155b3e9e49cea8c22474de446f3084ec1ba777cee3b90d0199d877e925dab58fdaf8c3be8f295acd76c338cd8d96b91ba6092aa37d9ca1ababc4fead113c697fc4697e5d0240fe52f6657a3646e2e450bc5c2911d116a1814ec9f0579bd13b889c21f29cd5f101b108a8ca54afb71fc472b0058c9c68ac93e0d231eeebee4779b15414c077fefd8b5ea546651f62f304d54f9bb90a68a169954ae23e5436679c80bf6bbdc4018c8fd58496fcbf5bca82ac8c7ae9565b6cd09f80655406ea45257af91b60702afbd1a2711b99cb9d969b7e74b87192e0bd98eae46649c07267bd9e2826d446c23c24f9c2893558a60daf93e042abf6aa6fb2c43b88f236316fe9c06503e5ea000e3fd869f5208db713639e2ed8cd14bd8a648e13df3e16d01fa0986b697b197a5747c067fe10c6fe3bf53c88ebba17fe6df5a8570d379fec862bc71a8dcbd2f58caf639ddf917650d6f3a6cb36682e178d0c59e7f464893839f4fbd04db61c6fa43a7d8e3bb4c41bf3a3a4559f15800732a1430105901da170bfe8b2cb9a4fd55bf691db874830ecb8481eeb2ab1788e36f90d3ae3ddd69569a6ba97e8d681c924deb919cd55816c11057bd5bc5f3e6fb0d890da64cbc21137e74cbf475ce8e2c63309a902291d6500756ce05693daf960ee1268ab0c621c43f12691f6e3d55967e752f07d4c9c650b35caaa7bc9d4f514818b6ce8b92ccce8ea45f7b22ee870de6903b3d75d68a7f255a8d769124b3ef0c49292b433e41e5e421b37c69e7e5af78a330e96a5dd311528eb9b08e3ab0ae2208ef3c6213b6c69dc70a2818c4855520608791edb882adbd3b53c2d256b92694ce13b1fd0c1cf85f479e9588ac790e7386b76ecccf7708d899b1a3a2a30430607fb9d92f9aa9a5bd223dc5a46df10c2cb783c4f0869c8bf1119cda7e230e0d8b4aa2c92021c5d5ef8b56a1e59a5c83f667ab4e94b0df38b5200684bf9d4e4b0c785a34c764a6f013a5b8071789102fcfb6f031e33c9efc07a9dfbd37484f14306d19c8ae7d31faad50d288c2fd3326b9f11ba2911e13f5e3c78bfc48cc4b28be799382bf1384c5532663976e050c528d2c16a20c8823c5f6d9a801c9756a81e630224039f95f97c7f33c06c39938f44120b9e9d4abdec543eb152f1d2be537708b5a6733135ddc3fe5e4837458079c58882fa7c9f31ab0e30644500a543d109416549dbe4dfa363a65364b3eb97c30b1867f2cfa84b248e3391a5f69f7adec6d056905b716d1699597b49423428ea87f11bcd334409e9f589686c600969d72137edbec33d42cbd71b1d95701a237a7123848e42708920626bc47f89a8f755d6e20443422b8377af4e0c8c2f2db155405c6bd25345985696d541cfd0afa5baa53ce00fbed7de1d903835843cf3b9d5ac3b0e61eaad52662a6f50272404cc020c96cf6f13311d87def7ed4e2abe7c961a551e7d71b2a2ff01d095f73ef04751d7d7f974cae05fc27716f461d3e9a928e176a61ac63a86e48d5e5071a719a89e6de951d8430d73165c83e20799dd8a71a0cf1b323439721da29dec79e1ce01f3d858f9c4e9fa562f3312eed819541c5c281608db55765a9da43eea08464b4c8a8015a9ff5582892b5347f46f5bf68273e60a14257cd5effed7e93bc96dd787c8225f878e00ab3bd1564f8d33031cdb27bb6dc3eafa68cfe253e82c01f4cabd89e876c5f150b253b46bcfc9f9241bf73b94be72a0dafa07eff76e910b87d206d5a35446606263c31330ba8a878de613a5269b0f6df885c57318ca1b8e2e5d8decc6b6237545e705a3e2e26d2b2791f34f8b8d71ee5527b2482612747e53a72ec3c39e409e04ef35c656a3ec9cc88138e1ef3029d9f85289c4dc44332a3318886fa0d42dafa4691ed07c8d03a499d6930180f45595961b241be901a9d31a5460842141017a592ea0674ff21e5e0d45fc687b0bea43235d046d4d3ee61effdb1a0682482610f71caefed6de26db60db1c1edd82b4808ade3c81dddade03c72a68af317cdc1a648a82dbfdbec13adc283d23f47fb201f213d6dc77799dddaa8b0f2202d800377748bf801597bd35593feda2a7d5fb6d5035452bb5b4bc369a575778f14744d7339614bd9ef9938f52c87100d80386fbf473aa66c4fd07150904cb0c0c00579b3e9cb4787d125d23dc34936405b38ad2691e30ba813ebfb809544bd234d99d7b16fc3d833e0c0e0376ea5d5495e4ec70c33951b46dec358ed2da78ab199c014fd0cf84017869ceb27050abfae4bb1cc24ccf3bf893ef74454279d9e65f3501551bb466bd68fb28297388b5a64759e7a777fefe0677045e953725f3b8ac09bd9d870d710a35fab98ccdb5d42029a0421ced5ab07e9e2af59ce7a5785b32eb69e3972d2a90442738e9422a0cc57c2d065acddc340d8db9ee143773f9b7d0d93dcb0978bdfa510ad9aa5e2e879591cef62c2991e9bfa838f75c6ca0ffdb227effe7f909b5287866719ee013820b5d73bb017d273e880dced90f4bfc8e4a61d7a39b00bdd7fbde7e55a4a98cac50e2ea2b5be638a25d602829d3d64f4801b6589372b4ab26adf901e1b6382d433d643f6bbc831f82517c9488dc849075b5dba4b11dd848346af938ec03385e080ad51432d96d4c2dadd78cf366e3c8d7f938113086b2dca62f3cdb7f7c28ad51c84e310f4d178ad2252713fee35afcef2e5a3bf249c5d46221a2eeb4b5df95b89cae04b8e2a64e91fc901b37811e9208206aa282cd3b28e76ef64a975ff2b4177b8d6649719e79c5222b08fc8cb1ace063104416f53f723b3854c3d3c6248b52c294952aa45453cc183dbeef5cb891ec3076c04ca39b8e73c25162558ddf1f2a529501e8fdb3114d666ceea28a274669dc01ca114dd252006f39ce8d832bb99729f7fd6e398c1edb7872e3ba52cefe5a41f7caa55eb62f8a29704cde6985fad868ace3508edbc3b8760670d5dd14db6b712efef84df8e3c9d8c081171a3902ed8990670c612a9a210e60d5f145c9b272436fe3836184c587fe9c9ed146f78a386a8c54c3e39cdd191d878cb0f290ac55d55d26539ba1ed1f6b52c570bb1ceafc4025d95d6f080ea71e32f5e2fec0fe06a68797fbbaf85ceebba6ccff20ffe6e500687efed5a218d1eb40c29f79f690c278bb83be974fc77fa945080a7043444ad23cff6b6faa834eece4da80e1c0f83a7722c3bafae1d0d90a434be59c5866210db47ba3aa94aa7e0932de100305a31e55168213e3540558bb8e45686d56d6f4fda92e7f74f24f8252f180e686a0a54ec2b55f0dfaa7bcaea977cb295ed78bef1793d1271c4fa1398767f715eb1166e5708ed32d0f058651e970ba34242884858a47adbd39a9d6ca9cc14f827ef2934a96a249b4f66c63dc46d181641cf7cae6b04e0fb9e4e0e48bbe96f7b17b5c14e7c5e62c7585740463011709f27618807ef635c70287599aa39697f07b7aebbc9b824553d08c2bb322f5cf7f0ad50326920be761d2472ca65d1a307f9033aa144703fc633efe61d10632627725b2b8f52c9e7d93a014793cebb5071d4621094a976678d9746bfcaaf5ff9e0a552ec364c044edb4ca3f4626eb29f3bc32b03b582f9a31affa4e25cf1c2da5fcb1dbe5c5eee81f02fb0e3bb2bc5d1f31ccefac7986912663e56d0f440673a6b986abce74d600ce8d172c9100ed7362d9089aaf4923230c70c1c4c51fa8db2358b625627b7f54c35de10f336c25fd5e332cf1f761fd5f4e440445e6656ca21cdeae961ca9af742c93b4d568f01901328508d6effd7fb0ec29e04c039e0db2e5de965229dc106005db3ce5668ca63712ae30d265683f8c278a53a8999f393044ec51e2682585c0190140cb3c2ab50028f86c020c759e7b165fe029024e4f060d24dd2c7fc9c3518ecb8e29e199c0e912bfebeb08ee8a4767dfca183cba301e3a6c8ec18e3cb008fbca4aa7430c152fa1dce7deaf4b291953569f55afa2d36006ada91adfbee57cad753d17b543091d80f238fc442233a289e43c09db95a2bd7bc0bd5de63d6b7e8b28629b2f4ba43654aad533f7e5e06cd29b39bd9c437e31522bb9ecd0a70a000b7edda2969550edb56fd51fbb94dfb04ff3937845273f6c9935e7c50ac65d4456a5a1274a11bd72e089ddae37075969d85cfdba0072ae91877e5ada66b23a997ba6ab6e86100cb2cdeca5e56866d4a4a4916006b2b06ebc33b0d3378dc743a0da8f9cefa25df7fd20575cba6653261fd629cb3c0ec41df6ba5f1f2a555620103465ca5d79fa7073c7c7e25e2356a9a79a5dc55a4cb509367b6c8e405d5f07b9783d4ebcc4cec671921b2fb2bdea413c32135629f7f3ebb34f250fa8eaa8ee3bd03cbd4e41cee3ebb26a33464a9c9d8a43e13bb9e79cac46a7c91f6a07a339707b5563af54966f2d3d569f9529824fc32f5d5fdb09350c750cfce320aa8026e0dcf37599ac3dfabba0706e981a2361d2b1c500bef7b031355dc361981366839a4080c65366ec5f075ebb300abc9acccf5067ba351bf3e693dd6bb8691a6d703f96715a94ac7bc30cb387a7921c721c22cd36633a3a24507f049ad6799388ea48060967a7d70914928b6780fd380f12edcb5da30053ccf5361de141e00ffe977fd0d7d36a6a55d5369a09a6ecb1d8a72504fad7dcb6c7848a2ec9cbe9716d0296a7ef7b4c2b023ec83dbdb83b8aa467a26e90cd85ed05958418b5868234b817ee00f8c4471f5bde44b3f8b9426471dcb81cd1e73f911e5bd3cadd0dd815e5ebe685ce3a02aa03a5638b6ef63f5c8c62268817f87066dd160edf9afa1499536308a37767a2f4abd1e4a660ab725bf2ba04610fda828105e239e61deb4587b7ae998cc891dda6f941b7028e3545e44bda71ecfd55b99b04dd0bc177bb9b7b6c8078084ffc0fab61a03c05e3272dde6eb08b3b179b8c7ff95df079f758e269a04f616bd37e0421e0379cf9051d8319c69027ef503655e56fd5bfba12d53aae52f73302e90381315516147ec0db08bfec1966a041530a0d1bca85cce0fe8c4f61eeb8127b103b1de1508a7f8a0688f2df7e95f0b05e080a1d559ea2aadd1cfc0b36ff960357a5887727adf0c0897ff94ecaf8c1143ffd3db8a01569fb26dfcd3dbcfa475a8d0bbf68e97a69a41192f7008f94e235b21f01cbf665ff8f063752e1785a6fdc948f3ff9b79fa64d2aeede150ebce728430264301da84fd498040bc303827871df4be7259769365cd783750618531a1f19681b1d0986075282b7027ce8bff800503fb1f54fe166d25f843adbeb13fb6f4e311882b9670bb825c994e4f711f49668baaf026305f6743d0ea2d81c5ce948c5f399d43fe3ee85d20b135a9e185eb8d2c1f7ed23a840430871c4fbdac37ecf55713f48988cac0825db9217935b7495780c029220aceafa7cfef75b73111887f0137c9a602c49acb12ae7fa560a4e02faf28f8d844c29aa397b542efbb1b26753c2ebbd87e73e789df01626f9de1aef9f62c83cd8d086b32e1e3142eacc6aae777cf8028d52982d47350c682cb87477177256fced8b20bf9383fc35bfe363828754f2b27195eda625d92562ae9c112ac8f80e16ca4ac9b3e799be5d118e99eb249232cce4d992503a3c70d19e46ca8c3af4ed8076f273617531a0a90865a161427fd96af81c151d6e770722b7d780f79d87f618c57472ab4b323f18caa15289056a3ed8f11a35ff7dcfdf0434602cda6097a26ea8ef42c1dc91b013c3b2c61e659fb985ea6fab7fb6e775f8bc08d3ffecd935c258afd4edd3536bcebc5b40b9c16aafe0fcd72126a27914d75512e2e7c82098454f482f419f21b909523f7b598758dec03755e164d40e17424ced2fe4a93f6772dc3324456db1db046e363abe9a1a35473b399a8d0d1ddab7a2d3c0312ed9520d79ab419f35a02593068639106a421ec8878405443d427abf28e672506b8f72511a4e26382b3e4e9cf6f2ead2c319667e3a27be5f60bff99f78c78de4ea73267b2ac32be79954b2cdbc3dc6e1b76a6734409ac7961595516ae517ee950755408d7c41fb96f17826278795f1c673c1a7114135989c505ffa50f8d8802429e96358b49319c055668add5eed926fabc9afad6ede171eb3b5b5007bca729a7fe4ca459b60c008aa09ab9a89bcb4d55bf21085b1a3d86c1516c041189ffd9b9a5deb8b03b6911f24d6951b7dfcd260c8c5a8bc5500c3952d64853cb909c41638ac11555ef373db55c7df3f6ed17680bb49a39f80fea8869ec9e50e8d952c6ff7763af4aee11ba5f061e8e24fc72811fd5aee6f747cc469cb18a6fbecb1242c0eb80845e8a28caadc8ac5232aad3f9eccd173011ca54e45898ede37ec891de9b380cd72733a20feee8a846708583096f2f288826e255e22f0002c626176a391cbc3e1e8629b3925d51f5cb15b5017749051a6a5a31a18b85af7f0bcb986b08421880a9b556f9bbae67adafba00b8458fbf39ae187ff97675e9c38b9e7927f76f8993b64de4c0611596d16ee84b029538db5b214ddceb0c196774a3d518a6420495854bd4259734ee5b4639d6924f097cda055febec5b8b8846bfe273728a7477c2ee124131a1b3257f1258112763e1a0de2580cc4cf14e046382a3b3a3c3feca4089ba7b29ceb6ddd62247b7bfbb9d249c1a8844658593d44bbf511391fd78703b8db308e16b50d489d981560f94cf7e66fbaf58a9b6bebb2e6b54dea2d493b819ca090b53ebb58748bfd76cf148375361e3be6789a2ee36db038e95c5adc5511f1dfb5b4382d866181f18204aefe1ffbe3a469e057b805ec33aae94e6fa37ecab5a4a331fcfc01375eb3cb87e33b70c67121309dbdb2f3973cc6ef201fa7c50d044c2cfae73384f16d93229bb2407022ba12776b755d540e7d13a28bca53bfd9d0a53bfbe372bcc39b3a2af9fbc15d7f10763af04cc71eef8e29863ee47c6ff5de8dfdb9068b1031f1c8f43ee90f17182d432bfe991a52ca1408d14e4084997a2f3d0af9973a3915cbb0730d024fb69c74fa8b64b6f68dfef31b1ae54f12b610c54f4be00a95067f6e48a0a2b694ebd88fc4a363b36af88bd36ea3d2834e89fa50bdbc98f1c95709de904224bb06f2a69c1b3d7555263acb8783945ea135cb3e8de3112f7a8fd15e0927b697378338a3e2c6e783c0f3aa417a2a5730bddc55013ccba9209e6b4fa5cc963274219275dc7c9f40926baef2dcd9ad52b83a4c8316428ebf7d9126c0c29022853ac99fc3437731bc4633e883dc94855dc5b94ddf5a6ee029f949eb9eda1d5629d400900df2c03d88dc7b4123f0ab2a40bb220db2808de19f6092ed23f0c71a1f995961da6d71553fdeb4284d1d2e39f6b740d4a0b4c6cf282a81c101d844c135bf0534123686e2a2294d0b2f8e5a21c21bfe7a9231e01c71b3c273bef2b6465b8b6d44d6c4a4e8043573346e5ae23089672e20b6859736fd49bc47a2417f7d654883b50a21ecfa90e94b115ab098cecf95578a9e2b2ff1c81306dc8763ad31c8889f639f162810d34f21bec495da1e6298ec73a1375d808489ddf96a9ca36c046679711ca3818c55372545e090d8abd96e65ca30d80ab39e0f8fb6c34cdd501a9c82a44477c4042dcb676a7fbc56ce42d9fb8600b7756957ca37b6fbc6d23e08b929739b22eec1e7ee5b2febe1c7761dcd981d8be209c7411e9d3ed51c64e7963198a2efb87cf182994f1791e3c7040d416155ee995acd8a814b077dc735a2da17ed027069e362d4b31a6c62d1c14627deba68972b3d801748a0008e340e5b7a1496cba12a438b7ced37fe4f5871ae47bf811e20a0f86d2ff5a6a78da5ddd8ae4fc359a749c5607faacfd3e234ad4803ba190672ea1f09104d0ec69e19ec87085cf6f0c27c28d85cbbccaa1dba3396e9c22704f8fea1288baffac98e4d64364f3f736455fb01881a38096bf65156f4995486c9bb3131709d431d091a871d7273f3b83f9571d2e4906f190c7e29c550c74cb6819884bb17db7595d1e0df06a4781a87cc6dab416b1e5d6fdbe7eb55f816cd6c242903df31744aea6c05a949e31e36beddc21d2d4b0df26ee920aedec71f3dc79e125ba04f172a6f51f77a9d548f68fa184a5a17d5ea336a017bdd4d778fe925dce9ad088fbc0c61d88248cb32d67bc62a1fac32d120c56cdf5600f2c444d3f3a4c43d76fbea74ab1880666d2d1ab3bc4b5b74b306a97d5d19b84173b3ac960b2656eb8a053bb85ba390f1dde722aaacf311458ed069c278e8771e5aee4c8836349f9966c5a5b1d5d3216a7863f16b4eb1cba79fc87f6351f202985654fc098eb5612e3715af24a22939fc5f72c63a6bbef4c60f7efeeb534f6dc0be3c52151d84c83dc9495dee22cc9f0676777c945dc9ff2f3ceea4f9d48f5addbac58022ce42c119b56c8a6ed499ae08da182a6813ec7c235b396fd44b5343646533f4cd9f4367075aaec9763cbcfdcb3d15186b141b99cf5c35aaa599776725074cd7decd82b3a69c75bd541a52edd4035e16fd310366daa8904bab55d1a8d8f572215af4427ccf0d2dbe06f6d68fbbc5a24abf7fe9454c2a930ab4f6187569a016eb8985929e8a0662ccc7037e47e78ccd52863a750133009c46d7ca78a7c4e24363004f15cb9f45189b8a9d0920b678b3157f6c59dec7d38f184db05b658a2cba8502112cde0c294306553cb9d3903d4ec0f8af2b822934ff78e52758025ec42bd724ff0616476145de0988f48ee1cedbf66b832983c929ca1c45ab376334d3622e32473331995dabe8e4f11e5895ec8eced6e841183b1ce6f0e2451b7c5b7b206b9b967b20d57cc4b3880379875e6fbeca09eef55de7786c7df12f07c5dd9a348ff4334728b9813973a3f7f1bd58898408a077c6dfb71d9b8260093d0dccb05927f65e52121f96b690ddfb5fcc0ad1e2f95dcaa794621d292cecf66623fbc7e101193fdaa5294e39ca333dc63e94b9bb32d07082e4dac1810dab4fea34489989969178f9cf3e7e23dc3ac237d7a01802adb4d4ee540f0c5b273c8dde8cb6dcb569d7dc5d4defa6e7f8f4481b75d2bb39d166b14d1074e8c77ee5734db02a8f305aed27859ab9332e7a7a5ad3b09c1ddfc5e955bb4f8764e03513a59eaa69fbeb9417ac7396e0cc830c3d32a8a9749297906df38c2dde4bf13460a0df9db932b8ce698ebfeb8c626c47edc32aceabc3c5bc1102482e8bb3733ba76b5efb1686405e8fd9c8b6fe0bd9142e1401cf526cdea1e0bcb4d54d8f10260a6e2725bbda571f1d7d2698905b7ffdaee9851393ef06a24f06dcba8e58d3c465cd89c1a24a63b1bad9ab9bc3899d708e8da5443d5c52ebd4ae4c8790578d7b741ea49e797330604de528ae51bcd068f408d58a78620f3e85691317a847990ec8d6ade1e3ac5a95b05ce1b725973a8e21cd4bc3d5a6be47302859c192811caee408504cf54831dc6ff76c2d154f93467ef08c9137b0cd7933d5f535f29165bc5116cfce31d8e76113074a77d53d1f34b3cacbf7aebb356be22f67401b4226cd9bf1773e2cd59f31a5c40f4df0c9db781ec642e5fd75fb4db431faaadcd2700a44ec15370041476718d9f73f34d1ce53dd62771a1f8f8aa7f6f77c3b056eb5e17df54024a02aacca765f239e6ddf7176780dd81d117396d4f2d55d1f953e3c121a99a5010ed4efdbe970d9ef67d97d33e83a1ae623f4ac534151662fe4a7afacb7ec1e8e212ec254ae0c61da38ab84fd932fef4582401bb12d946f6decee19560e69b8dbc8ae8cc220977e97218fac6ec241bf31afad5b330e483ede5cf704a0d393e399ba43dc5cf221510cb17ad51433cc3c5434d28503592b716342a84bfa0376fcd1bdbb7a889037f39713eca7149ca61d498e67ebd96eff3037b16307f2d511b78a5e2ee2d222af1c3b1653f37e9b62ad88c27dec34a85dde48a772f80e6fabf23a18e19ffa941f66ddaf35fdfb844b2df6329f5d60928252f51e5d415a682de883b65dc0dee3d96c3dc602c715c8fd5aaf71f0209ee670a169032bdc29c4c81bd85fdc5febc613274e8aa890df80c0af62f03ce75a390f995d02004966a93bead62cbb9425d6d488a8fd12d524a203b12e4e0713ca5954494b5695fddafabcf1f101c41f48dff570eb7e3a53fda135c134b71d627a5b6bfd377f5c92e516723e8f49f88fa6acabb1f2ce06a2bf496a1af99f85ad3cd1e0b958622dc272581004f1e323bc4b5cf06ae048b32f15fd03ddbd2580e300aa761125e8e68f655d99eeccf6aff5c263e4d08533c829b26d54627ab584caa13478657ade61670ad3f0592f717760062221b003ddae2d4b4239d65ae9170d23b7f64e3bc66ef32cbd79af5eec64ed87b46040ee9123c9f63232cc9783d9cd721db8c365438a57b8d8cc551d4551f0afaed9eea19043e312dba9f862afaff279f9bc3703eccb7890ee6822dc7f87f331f30224177bd1d6d58ba7dc06bd312ea1a283234f4e1dae827ae0481f7221632f696d9e0ebfabf56a6d5c813edbd99e42b8461b2cde94a7505173f164b98cd898d3d319b106c27e80dd931f27f674c96a39e8f5681c09c5e99d68691d48d922a14a9a4ee01b380f1e26c06c1cf726166ebc7254e247e83575358ec4664af0da495804d84c78976e611518c4fd2425a9baec8f0c15016e9c89475c99c5a7c7691c9231ee9270e235c5488010e504f7465f439b0fcae636b0623cdc505c4e863b2ee7f5b733cccb549e32e5031742a2dfb1636499e68d8acdd969d1cc5e20dea600385187b59e3c54443de8bdcccc280980cf7801afaaac23f40744fd4b4e0f7c73b70fd3cb2aa57a3b6cb1f5855deb4858e2ca1baf183c68f51e64431661ac757fe4f1577f9107c43f083fcb0c73b2e8a5c045c3aa9b5d22656c92bce8a72bed1ed2df1e63767bbe33133f05cce6613073d225421d550f168c309fce6c18184001e5d5d6faa9a97cc472474f28d70a6a930cebd2cb801e97bc820007e599efabea9bf132cbe180647c469be7b784f77bc30e547e0ca4c87f2517e334ce7610d8cbbcbb2e06d0877a227ab5e53cf560849ca74b83fba54ede3ebba70dd09525553f64f5ac5883cb5bda1d8d50259f56ddd1ea1510f2d11936e72961539c4339c86f3e111e7432af4d664139114ce65266acbf24769162d257c2020ebbdf3672d0540fb6f57d17a8c4d66a7d91379d06cd27ddd8c568ee5793784059ff21cd6187466b189e4afea0a5bcb09b85c40eca1fd2a08b607f1517fb9488826d1ad9fbe4e8996044b1ccc599f6f77de6dd957c92eaee36965c6a8535adadcb220a70f70acfd1ffa20efceeab2d1fa0c7c2745d9ae22ee2a3f374102376b18506bdbfe9e7f9b8930cc15c708c929e0c1737c61168068278705e8bdc713afcc241106bb62ca7d4864ac528d670310b1266973cb32e704ea73a23e10e39621d183a95aaa0b51a0d507352fb367fcafde2558c35a4f19651915869c8f21447b74d99a53780df6bb3110a1eb00c74340ee9fc383c83a772557d4f4a0b4e486fea392f7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
