<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a791e448e0bd1d2f1b8ca91c9cdd8a5745d321233b793d98f046320e861f38d5bb50fbd1db0f4318b3f454e9040671265715a883cfabd0aced18868d1fc63758883eaf338bc49cc33872561ef4a15ee29f1eea91546d6b942ce654439a809238e250d08ca28d6ceb317b72fbfb5ac28ac60d741f50292b9514b7665c4cf37818d018a6d777cb2d50104cd8b283b685ee7d9c9f8db7b6fb699d84955c7844b487c1d0a0025308395eb22ef512147b597393348f74a481e42aaa66216a9d920e99d7c47b1f4aa8cfcfe85c522bd7743aca675290057a1f45c9af1f60aecf70dd4e84bfe601affc1fbf3724483495e9bb8fb30a1cc5432c0fe5d3c771663126f288419d561e568813b04d19f4abe7732b8ff458868d1838ed17cb0cd351ba662794be00aca8890c74c6ef6d551ef91538cc3ba949c7b1f8b663f2becdb1529778cacc41ee7245880bf0e39e14a42d66c7391d092dd90599c9d5546bbd210bd34c25ba552e8457018e1abd66035b3bade3c402d4e8f9952dcbee8a6763757637eeb80dd76d65bc07c8f70724f897234922d42b2d6bb84190e37736b4e670542c8450aa45e1c5a4ad5f2ecd7fd766ac67e111a6697928d740503b2691f91ebbd65543d19f25768c02d35b4642ec6b1e384d203e39ef043203325054966a9a9f60409a3f54bee916a44dcd454d6e19cc0fe3525c71c628b8a03261853eefdbf730c382f632bf782fbbfb674cf096cdd3bb445af54b35f84229204992ac99f15d6a6a09a2748422d297e326091bbd6ed791a9bcffd67bff8bc37de401569022c37fd7c794443736a0ebcd81cd1b8d4fec45dbaea3c4d112b3ce381ded126ee0d67dc95e3f929febc83f4dac1b3cd39258e84ed07fb9cdfd3606e452d41e374acf154b4574c34de24d6d0845ebd4312247b579d330667cbcbe69fd56d93f901223e19eaec3cf1c06300d5b7f9903c1c5af3061578d90be4b6f2d93ad9ca0fd6705e5aecbc50503e41af9c8c592092993c141650fa9531c492c85f1c7d73e9f5af41cae9fdbd0b052c377c9849036188519a9475af9edac58be16ece2030ccd9f395bfb427be5d891a69084d7a7f6238344919f8ae5c127d0295cbba2e3b74e6e7ecd22c293e320457ef27e27ccb229dd469b01585a97dce7c68ca369b32295dea1817c7e403e6a9f4f7f44f8787b997502f03a33ad0fec45820e5ce03b5239eea5926d25e9f850e900878ff2872715a7fd594921ab55a3083ebef7be9e29be53d92258983f6d0dab7028e174ebf669604127bef3ea9d77911cb6c1cb96408d20a7f0201730d95e083ce0035654d985b4bab50b5d0a31776113989725d3e1e6757cd06f64dd01d3dea7e8fedc4434e51a224936897535d3e3e417f829d16f227af2648ff950d79a076e493c318261f66d1d18e7873103d8859c96e704fb6cff4a2fd8dfd2e7b08c01ec651d2a17b54566135a992711357839de2f64f28422032addab4870158f6b282db98035b030b2a744b740573ab4bf547bc973650d66769f1c417429528b419c2d8fbb23d830dab8bf0ca9961bea6b6dbbc8a686b171b5bc8b09e070e4b7a480846ad169884bc02dd61d83f008044558387000faf64e59599ab6d76d5aecce8de789acdc35e335c9f125638f2fe2205c0ac0b42d1bf3e7275bcea9f6e3dec754159ead93eec6d5beedd58c8040a45f8a66f57d67403f7d6194b74c110e5bb95cb8b138d0f2bbf39d26ef8d067bd3c9079e23a4c13801469bd2bcf77fc98efbd458cf1e78c1cdeb2c44d9e7f4b263e975f0e5f5a74f7d326f8e065077cc9e2f741066d28d3d8c05856b5c9c71dce8fdfb267b6e2333f2e28b9b57dccdaa9c9a4720825ffb8d548b4e3afc0c7e0033622c68adcd1bfb624f68033ef90a3a615706a753ab8d26781812f03d7120b4f06857ffffc0137d11cbb48f282ddfd6d6cef1fc862e06324157df53eb1af80a860eec1413453bb0dce1dc2ba901cd787c5601c5df0cc288d6c7554921b163c050dc65bb03cf46314e37ee836ba52d73d33c5e34b8a5587e5d2796ff6a4d81ac751521199177e97afdf918d3d032ff8f68c78364f750e0a1424e14a9290edbf01e5394ee79d7cad9dcd3fcc46990b79fc902b5aba30ce0447b2cdf902bcacdbe59ccae6bac88a59f0af0ea1889600be7a0eca487d3f1fd19dc181ae7f3d078bb92d5847bf3ad8d29c129a6b9572e6aab689cb2e19d2f0dff1e5751b034129d2b1b862011ad15f017c4640256df613c7bdcd311cadd59700b9df17e0771d6944214416975731ed2aa8f54994fcf4a269817818846a6eb5b70f649be02c98e9b086934785064d531e5626e783dbc78d4e0db876b7321b192ac58050dc74f35a4bdc440e67eb5c09f165752959b9627098241f7ea8a630d5af5addd281d5333572ab9a7f2440d6b1b19cb62ad7e7136a9a54761f9da3a2ebc4f7948c48acf1a93ae977ca625f23bf56f5f043233ac9c97880907dbefad03bcf469a1e1c55e6e37e8fe23ff8bf3aa1418d7950c2470427fc2fe5d3b39c61639d0c5ae9bb0306c6069ef657c678bf7ea2d532b91e79c40660fc795d97b74434c626477b9c1248ef75db0795c3d7369ae3d292b48cf4e242969c4b17ae9e3b48c2049d9ff9da28c816bd00a0deefb85a9abd2dd3ff8a8eef3d73983ab51817ac8e44e49e8c034ab3489370f33d751c3360035170ee5beedabd9235832b408242f47a066e36d2aa3f64670a73fdc55bf5feb99c2cf1ec7df0a5f2731769c38c6ef50bcf45d33862afbb0ab6d1cd9b5f9d520668ee48a78f0034441a38f7d098f4d09b3bc37a6bdfea8d145b37ce5a8976667c0d816687b41aea8a3fa7027408850be7ab2acfa0fbdf3db189423a4a2f4e229503bc11a1e1fa5463b16338ed673213f3a6de657f473e0b99bacc42a97352c9ac1213d7a374b3c68d9418ec30752502c5858dadf14141a636527d07ed68c66feafb0e248fea43987e94508525c070cbbd31fb7884ddd376ed4f51741332592dbb166234b0b347960715c0987bc7b53a4844bc2cac0c51c1e28eecd822b2c8ee540ce643bd6253f0b9b6c4c148555ec40c9240804f45f45b63c5b76ed13017f09dfaab8907c3fb1abe58f1a7abf773eb7160f04b52beb82ae04b641c98c1ae8c5f2f51c709fcde0b70a66258cfc773ebfb5702e24799335d7a0301d84ae98c544563ae331119800099b2dbe8b27459b585cbc4287d3273ec9baba5895447ec16671ed3970a1e59964ee0b143a50b93def9dced27d514fff66af85e64705ab5f8b392e5db695b06ac1f39e40093e106ef022871a49cd6265bd0fd51eefd7359628509a60403c3dad894c8d94d5e40527b2e716d2295420a7f5dc779226d33b3385a5455c17df6e4ca28e430a7f4e0a36837b3824bc85c25fc71535e3d446710f6ad9a5a9f2bb38b11aa901c781235a61ec398a11f2f6a1129f6138ddb2f428d768b89776fc4bc097f7c17f2ccd331bfa8c35b5a36b08cb51520abe750cf8aa1b933ee0d6be1f1df936fdb135ec3e0d0313043f7d60349ad7aff8c0c6f593e99dd38f92f21e50d50754f35f026880557a24399e69173b7d682cc7ff5cfdd9bb2283c7bc688f0a52d90779ebc359fc43ff8d80bf6a5c6ffdb28eb79d6b82bd3cae9486d7d33c2d43423a6339566468a699ccaf17c8dd45ae534ac2376300360a4cbd9025ba4b66771bead131576f475d5c91c42bf8298966f726e56790a7373d78e8b9a57f580c409a92a3ddd24f6560a9a8c53a4ec2c3d7836cbe2b667268069f490a68f1174f7b8e8ec9256b2803751c7cf539df87b372942730a16beccb664e2852af2fa1d2be50dbc8d33209723096961ed020b06870d33f9a7f2241521bd08ff8529f1a69b6e286d77d4c79ce19803463b173e0e2aa2d28875eb75f26d8db4410938cfcf429fe8bd79965d13962430915b2b3dfe3574f69ef4b9ffd081eab8df7b7a13ea4f3bd87bcf007947536b832f487a91874ac10ef89f47bab8e6966067066806f72fa3381b3b375592ffbc8f874de70953e96ba7f3d2f2a23a97ec76dd8451866a5dd49879e37e7bdd004fdcdfaaa4226d20a7fbe181da5b4347ef8204302b4ca7e5c9369db7e7f40ee4e7710ae2626de50a73e194ef18d5ef3e9ee04057f74499ba5a8852f1e985b60eb78c17a4e172c3dcd4eb0899652624b994c05c63859e63dace1d0e6bb7e7fa42d2cf541da898f604d3f13272d19bf1f0e8e29b1f656b7107b6ef72387429cf66715798d1e64c63cd0f54c603623d1ce97f152eff200ba014c7f79c24cb36cfff9cc9e29a362844bc2536b5d7036085984260517cb151005bbfb0f5602c16eea1a45f36ded45eadb7949a097cc44a852a92d13cc8d5867b045e966e69fad78a9c00cbae36746e9794544adfffff73993db31d78e61ee69b68c501b4b0cb63709b7b3da7d6ab6aa3ef1e7095777d1657b6cfa9d9b5a05095c49d416efc2424679798a86369960726ca32f3651b8ba3ae077abf94e28ee0e716af30157c6370f8f0753126a88f61da9b7d0fd5853a2debadcbc2cf9a06450ab599cfe26ee232b29dc00b53e836fdd0b8f002b31f48cabe57f35745ccbe711cb5496ce9a08bb8ae19e90b796b1c57ab525d0d36e926d82c0e3cacb8a9432442bfde6295398197a463820fd0683bb81d744ff7b43c95ffd3ebc1db0c4fd786b81cc64b9646b9144d4efa510becf7e252c992a5ea80ef64736ac75d501aa372533c5a4faf1ab2020a2523b43ebf9b6ae56011cb34099a7d6eae8c39557a43725f004009970968dcfbbe1fdeb2a42bbfeff2151ce59a8abf2b33827cd8e8f14a10a1b04d4d3433b76a2102b6e077fc8310a1ddc5d041d336e5c00b19d61105b786af7174592ac6b836b474a4b4cea5cdf6edad6bab5249e254c1247f25e3fb73b8afe57619ee84cdd5660935a7738e745e14eeec05830dc93ae7875acd3fcada760240b3637ad1e2812883b181141774eabed610b1a622af16076555c6eea4a1ef8b885bbd9ad2e1e71537ba32ae9cb2dd851be0f9e275d81441827374063cdf6ac1d852fec7894bf9388d686d95bbb47dea51b80e1a4f32f0fd75b69d5bc70ec3ba22f55d4ef420cf65fc70203560d718312f4db9e78ae380e81a228ccbde46a04bca777b5168216a52cbf074326c2548a354cdc206d2ee800bae54177283ed0470d2e62986ce39a018069a94afc6a1c797383e43831e3488ae1aebef86e18910443a4bfbc6404f9cb7c33f40ddca4585effd191f70d8e1da238a20055937b5a728b824873c9ceb6e5bbf892c4d6ebab2061fcd11b1521089640a877c6926b0f85cd3f4dddb1090f41f70476659f9dbee8829cc59e7d582592996614f2fc3dc6fd05a7c8bae71019ff9e0164a704be8f275c1fcd09512c5d0c3dc7d30393d6a32093a26c600a288e3677ce7f55f707420f008853638a00c24c9e5e929f1357e1f4364e399d5f700fc625ca733e05fa7dc1793fab9a487e8f0f289d85c34815332bf78f57df5605f42b2bf66acb4ddbfd99cb0bf6e1b7f93b6c9fbbc0ba97bace96cb82e8c3c5dc6567a2a3c94815772a687144c18e09be3bedf2a4f167ae4464e72acf3e48b5bd6205dde0737cb2f84d1ea3945dd5a4bc5e76017d21ae6ffa6c0e5257c08bd71057d17b76fec29f63a8c7c801b05ef22ff7ab4d9ff5fe5636e408861707a562450f8cfe544b3bbac910529c3f0b3b0c4f4b77441e714d1957e7d2e6dde8872b4c224f70e88662e11c1bc91f5ab1272f829f6fffdedf5f2d50b7de9c7b27cbed721248396b860a0c847953242eb90573a6bb4f7b81f6a0f944349766e82d7b5898828c4bd6487f6bb2075e51d70bfe8ec9f7cec4316e5037add894db522b222ca90c58850a1cfcb4f34917eef34738b2790a6409d65c0dc59d6df6b0b2cbd0c6b101f2379c5f949d23157bf678492198f117754476aed9f4435378d2921ad0da2f87552f8e38b1e039293e376168c2f0a1b770385a3133400df1a8891620789086696dd0f5a6aef9035e4d1b1860bdef99586aef592112ee73bae820b1f4123e9cfeb9fab7efe2bbd3c034f138a60e921fad1ef438e77539df7788460a88562eb0e1d8700cf6051c1c0dc080c37d850c6560338988d1cd21949023d4167814a6d688707e33e95f499b76e883915629eb4d062834c3ca6a460d9bd020fce0976bfee234caa576a0e41fe28bb3ebad0ec67548a6b754a3ffdedb0e862c8a0c217f03b45f8412e255548fa80f2c8a91cd5b627d9ff38df38a751f462f1698bdbf23baf01e3bea63708132fd65045574e16eb300c948a86f92ece941b1473c580572d2cb475c408f7bfb0469fe9eaacc620eb27f12469baebd92490c07ad6db0b3b386468bc5041376c48fc1cb7ab0caa6a1019b52104a8c51fd4008b90534f32f34a73b53505d9dd2fa3d02fc1b99c48651cecf640273fa386065c376f3316b30dd9f1138f5e5976bc35dbb65caba9eac5e345cb1d905f0af6e135e9db0f21f386875e8d5497e45e8a02437d3746b1745d72d093268ff310a3400bff162b333a4a7e3bc8b7d20e5d5204ad09fee5fe7dc60035f07f0db544dc3473e4c66969c89e8adbe9de59bf57ee0f406c2ae6ad8bb641e1c45719735a53e13a47fd82912f7b9a08c2bbf074eb0a18a4937191f308f1a96c3019dec04f90526d29c780271c36a9fa48a37a140b077d519503f70901728f9b39287f401d1936bddd477bcb7cab26a82810c047f9883fa1610d13f5b91d9784ff0d604324580f79eda06b87ccfaf58f01822b2e505a7f1b9ed37a1f544b25ae5aa99ebecb6f0634c11634c7390e8fb2873478e44a42eeb26ae9ad9371174836c21a2f585290ebcf258240ba8eb252acb301993aab305544429933a0b581c06d66cbd119c1ede4e8247fc501be55b5215437f19853a126bc213fb0205be70be24f29fbe93f702f7fd2bb3d844b213f25c10511899341ae0063e705232c6bfe98e84a93b923f77333a1c893ff64dca111ab1ba22a5b3a714dc68fae018b89183106c9a195ffe9bb8a9d6a640bff969a8d270acf7808dc1affe87120b1b381d1e08e432b1a1b02cd87b9283bf4b52cb16ea70ba22c9fc189d2f679c49a85a79a4242427f4c98621d4672dd95ac85d5c30a2b04eb35326d3b162469da9f03e0be62c8cda4afd0a7de363a164bbd5a335a02522df6f80fc41f8fecbc503c7f4d667c957a6f19ec4561df75ed938dc4bd595ca7e6b7fd2168e1f7acb64a0c71938741a0a1a01d7da2ad4c21eb74eb633cb78e772477f627ffb6b9d6c4b9f21fcf9fd4453b31b25e3b6dbcf6b480f8816e25d6ca88e27cc7b7b24a8f515bf63a99c45a8bbbab8881302e808576e5ebb2a3bd394f0e4f7c9d92085c8df987c6e8417f5787f1f24472fa3b191bdda6921c6c96888c0b1e175621fcae4d8a664ff3c11a17f751fecc7978b9a935b6790d40fc9156d1ce6f6b011131302f6f2d860145510153c560fd048cb63033fce6b87a1b8f7cec012c8fc981d06893647a3924d0546b029f3f33d1860cfb8e20592d4eb8305de39567453d5b271080f11c2b9c4977b916ed70ca969e013251129f8504fd9c249ebd64dd5087e6da5e87197455e7b3c9d0554d6b1bc8136466e4be11ff6d013165d7f3d6490ee691a6a5e510027f12e1f6a268487bb3a48131460e1fe659476957a9ee809e8f61dc6c26609ab5ebd9da59680363decbd4ce4635c78849f7ba5223fa307dec383acfe96ea0674a277c4717529f40517ec39f7c7c35a99acc0e3a4417d20c20e5d64bd7dc9b7b5f3a9c641fa7acd72a9e85495a724d2148a72f4d9d4981d51d3c01073ad87bde55e294a33e8fa4b7817a443ba3a4663fe9fa3af4615293350626f2bb826ce595f4564f93fbebb6373c17055d4ee2b48f00ea2f18e8c1a3b26c287a6bc0fc197b80f2ea68f985e70fd6c37427e61882832a1a8ea7e1ef8c84a061633ad21f2868f7d804882521a27d0b8bdfde950594d3e01db8886a173ace36c6a6719e06f704ab86568e1bb2a4e0c2e734f7db9d6f8e7e8ba9046df9a1d3b7b273efacfec8d9ce0a44fdcf1b82a79b234c7a3ac31683408d7f749ce936e0234e94f13f0dcf8bede2fee4912330a76c9cbeb3750f98fb0c25f9c1d65839b1739b08a74acf5b826711ef420cc3a9651b81a37ce09d1399c3f1779c457c787eb9540e0bad5f3a2aa9ed73473c3aa83db15b90a77ce50267e779fa96552182be646fe97741edadc667f0d3c4017cc50e1c2f64fdfd68d15cc2484e97aebf28f6cbad88cc6a3756678d404ae0a688e87e7358c2973503ec0af6e7cd735657e23bc69e08b374363bfc45a4b3cb07c79438948b4bbe8cdafa995f15f3c17be122f7a7264ab9069918b14c79780e63d1822e51247219a95fd1f07f0c9f98f5854b14cacb03588a03c39f76b9a5b7f159a8d58e73f75d90b87dfb10672525716f1e670f0abf969ce107bbbad51744a512b11b056da08d4aaa2843e7f204b2bbd3834d09a07db5ab621c4209553b69a3c6e9a9a498da095536872dcf89ca6bb9fa42f61d5046ac9d616f96b8d930b458275a528a1730ec74a9a2446aa4787c2b8a4f56a18e803517350ffdbe09d4a1198c3e7d6e84d7b0209b084a8429b73edf333e9724fd8292ec97019ad62b8673a29cf9d553dad7f3852ec3ae2f2a74c96041a89696fcd2f666fa74e8f3a3906ced30d7b4bc4ba2cdac545565a95aaf2ca158496028752147d19b62ab2fd018815bb1fd5f9c892dc53c3ab99594af898aeffc5824507b2c0ea960dfdfedab4e913b536259206ed97339a3d08e06e42389dc152d8f8a323616a4f3a6167f9a3dd1a18a7148f4eae36a8d5360c5900794110da4ef6f98a3b141a1d934b227e3c52a6cce3e4809e844295326c51fb5f5a3a1c4eda7e6a0f1ed06808d3f6feac6dad011a38c6a5a49c870af8faf45489324a61a6c2fd7066203c9db7d66fe3496f10f8d07cd1c9e00f655ca4a5c07174ddade65ef166502aae942b430788e8386cd7d4dc6515bb7120acdba67f777cb47f23dc6a5124beb14f8afbb93c2cec6068ac9734f249027da704af6e1ac6fe4746e59c5ab139daa8b51c7413fa5b00a6bb78b8bc727631806064290cc7a936237c06d760bafac0807cc8a1537eb6b5078ccc0fdd8511abd5426270cab81455df7f04438ab6f74b840f02534524a7d649d074fb26c61bca4557c1282616c44cc941cbdf3953822518073881991d3b62f7d98f60aebd9b7ba1b5119cb7834dd2657346e23893715ff68eaac3ee84a4f6daa9694800b6f264d53446be9eb5704c171a3146def539906faf22b65d0a477ccc1d426a8200d3eff89e4f9e85aa39cf7a6dbd8d30f15e66cd2e4bacbc93ac86d3ba0b067e47b004dfca7e0b7fd250df366fa6765a49a99357efa10d353e448bd38c304acc74819ab6f59eca1247273cb7a1c79eeaf2628cc3643d6db1ad67dbcc25ade63b94ddb4d65aa7533b66da53c41296a0e488c7e9f18e23373b3a72ba1ea3d840db1e9afdf66c9259049f98616d6c6ded827bc2a87158747f55093d14948a078cdf6f5713449a1dd38a54d5e36810d812e50b4529f121a573fb92ab4cd9be215f15cd1a1978b62e8069dd6761224d1ada211334a04dacea3144382ac306e3a2a8dcdc3e4bfd15ba3ac35e0d670c9e2886b4d85b49166a00510d1fc284ab5bc6be2f424b9cbace2ee17d0bce98b704c0f5acda6fb6b99ef3d1bb96a5d791483250cf4b9fd23bebaead13c885a9f7e6a2c45a1be8cfdf823c994978c672ad201f38235f98fcb3f444453b5378e262bc442192b65dcd916a0ddc76f69b832eeca4ce9736f5771bf0f08840c28267fa23491f1c0b2d3b935feb922b9720196105b71c2b3f901efa2fe217af6cbf69ea4b6b46d5733a42efe71a7931f9203a6c7e93b0c62ed334cb1a186ed05ab0b21cbcee672afe84d106725c539b97d229a74154e92c1eab41158fcc4ae27f1a4269e8d48b7d30177bea2092da23c62cc413e1d26cc26ddfcd646966736e08966bb1ee8762fdaa99d4e2f490b60d93e337cd85f04fcf29e8b807599bc3b7bc01187bb3deed1ffba786d52b51cf10480c2219a1abf6affdc0e5d7f33841d73e0dfd52f76422d6d789cb730de6d4c0de3f1f606118652015c471860b273e9ec2a69c194a0ca364b792203fd700117dc40efe32b34ba780d5481786b97873aab0b62ced2d00187e40b109165a58098f7cfb36ea081b6bd55126fc3f495b520259ebbf3322654ea8080e1b1fc2ea84cc28a9ce43c941d21b66d17fabc0e22b643a148d23b2f1274b3c798a0f4b77c67864685a0cc9a895a1f5dac1d6c3966f3c3c459eba74a11a663f08e7931ce9c84bda03bdc1f892e21e88123e15748b26e87b826c9d09f4dc1d405f9a3d3d4c8378c2a631ebbbd5f81594df9b5a9ad61966801d26afd62dd6fb77c60935dfc0b175addad365fa873729342bbce6aeb4ba38fa192cbab7860ab2aa2c038ea5f7400cd4b94da432c9d825809c66d917174669d3622e9994c09d84b0ff037369a1e3bbeada7fdc4f6e4eec22d83c0631ed01f87d9aa360087c94417d4d7b53bdd4b199173bd6210f2deefb85982828b5e634c753cb64ea4ae2c102fbdfc3056fc25f9b80a65de2b27660d23613a6f06935d7fae14d7df7ddf7f9c0e89562a4c13bad0819fe21a4a11b950da20585c259ebc6d54b6439b1ad65f72e6b64869000206c00ee197774f088f653fb6ae17d81ff2a7711dc046949512118d0bb5a21c36f8ce5e5da052e8496d1e5c0e633a3a94de3e72650426e16344e8cfe397223fc6f753c39b1036e92cd61c16c4a3279c39d612e391b20af2bdde877c17e6f022d72a8281512ad0f9bddcf8b6fc67a2ca4ce21bc289b88e58202c77e6a806d832e1014078501cf9c646a769afd05f1a9c8450b1fa782dc3317e95ca4ccb490509e530d79eaeecc013d328edd5d92391a5f7fad187e548a891dc6699278a6bdff8ceab9e27cdab301197f5626edc2d63ae516fd4f3fd7bb3ee8ef1f18bcd84f4a578e6abb68f4385981357f4130aee7fcdeb47d0329f2dc379c1884c8e2dd98e5a5d187b8726c6b03c72c67910bf8ff9a8fba7190b159ec2d04ffcc076499ed22edd6a4aa287f5b4d5af8e5f09baa1e251341ee922d6b27934d4d31c5e79dd935f238a859e174bf4cd85b8eef5bd89efa61d3459cd330bb78755917e0321fe7fc14f4fedcc1c609e66f106eabefc23621fa0a7c3fbd1a723b8b4bc55f70581aae8cebb05a31c3b6c2079cc6bd1de97e3e88ac3198530257c5293fb79c7db4408835fa9a044da9ecebf5cb85258b7d26ee2087faf7a03cbe9b830affdc9129f5f03eab55728f87f58850dc63fad3fc24e7d0a62aaa0505dce6fa7cab5791d2b0e5ef11410878698eb152656b65b61a08aa21a1939252abdb786d5e6bede6de83f9b38de0e6e0fd5611d663ba58dd52ee6a35e85478c198b633d769b20c7bce176b48e5689d2f2598835c639d65898dcd0a2cbb844cca311d92a70144ec5a22b2c8138af5c509fe4b2ac4173338579fc29be66b397ab75624552cda1355a58bc404ac868cdb3667eb17901c41bf47242614c9575ab3e2bafdac6101abbaf477d4e9d7cb805f3d1674362de3bef8b3d2f197946d12f44ca42411234cad16b1827c4c49a19a60daa9d88a33d59a2df2e9c100b081614cf7bdf1b62c84d98059ac054a96bb821cc86632c1aadf4d009787a903e51942a4e7b1b025c26a6abf9dc0e5638172accef1dad9df17bcc80249bcfd9da2170f83946b96f30c577d02c5afa4f7eb5bd23db601ef2b5df780f42fbc01be1434a3bbb2956c62d060452628d470bbd82f68c75acf05586ddf0e4d078bedf6b07119058b55450e4b88d650916f1898cae8411cc869b0a2d371f6702b015724b12ebcdb102fd750b8ca31d55d8e8968d83f01161870a8f815b46d656ba56e2039e2e1a6f93677f28ac333e1dc0a2205d4b03425ec28005479322563d6fc65c657bf39f4167e256c70fd7c7b0d263dc69caccc58bfd703ab4014e027b17a9851c00d05016916371521ce70fdd8a9c213decdcd7441d27567312fc63da87de23478e97d7ad19884bf7670426d5b5dc69da244d254021ad7dfee79a3f80a1d3b5ad17aedc592e827b4b093ea87a876142835ceb3a84e628647c9251612a739bf27f9556b45404395e9611f3e74783a2429a98abef713c96141c07ce58605b83d7a1f2f1907f21f7293b37377502544d55a6b38eca1be1e3483c27ef1570b45cc5e98b1abcfaf630fdad127ba6851ca82066777b1698b99a40f642583a7bbefa3a68d6348b60702747f48184bfda14df2e7fe5b091a56dec426cbf8a53b50249d8489ee20708fbe72d6cce6c6db482d65dc5ed5deac70ee34bb970dc2f52ee4e7a70e6d333ecd72b8bc0a91dc372c17e1c5a49f9609903241c588ea79ec5fea587c4517c3474d1a935f7fc1d857b13bd5350ce5e7eda35fc57011b3e59fa3c2aa1361b6fa5f91abea6a43bbfd88bf06e10a60c14194a63c1414ab39cbeaf9e4e55ee8699c14029e8c3258923e88f4f6352e496d36928484736ce54719cea5a41db8ce44d1ed18199beb5e2d1ffd6bf3b27682b16146f04b8dc5635a6519f21041f83ad57ef3d437cb269d7f98fd5f15c560573ce0cd29459abdd37ad794dff8cb42451eb9d471ca67e4995b397e776294b86df6a4f18c8d8325dee24b5754096bdad6dcb225eab5826b379a1ae9cf36522f12ae23aca692a4572045b49bd9cd246dfd920016abe02c0ae4072668713b7c6f7cd99fd3a815fa7ba304b92fcce8c797030190aef05a469eab445d38929b755a694a5f68a4497cd8d329ab48a28e1bd37262e41d8d749da037cc0913616e0a96dd6caf8d0f59e9378da80a1f99dc7775dc99987c17c9b46e222fb75b36fbd00a04358f2e663d8533f8307db48c28e1151545c6b5609f06e2df90c606b5f07d21c1a7d5579a238c8744ebf2f137254755c91fe21cf6972135357429ca31e564daaddb472d34cc5902fbccca911e43b3f7d58bead09528822bc3acbee6bfce26fc98466c4d0c523ca8838f0baf976c116891a2d770dd498f2a6a6be0c8d43fc5b5eec9a76780990bcf67dc84c7f9832dee7b2c160dc19abb4c7f7d0c28d9ea598f6f4fb86de0c757ddbdda680dd52226896532965d451e6febb53517518c6b39033bf7885a744f4d95da544194f4809ec436854cf08d5fd38e39d794a760db3da0a1bcfb59296fa77aabe636dff25881bf850f3c5b13eb17b045a1168a79c69c686aa979d2b55f3cb287291f6c753f80f5f184de483641d1b57ba13c186839df924b9573ada1e65ef19aa756b6039b82228be48aa19700d04bea983707caa5b86b11868816194bf8ba1e8ccd437f98acacc1c0c14660607c9abef5a20ca66329bb91c504e4c34ef08dc36aa7fdaa7d6d4d2b3056a6d16e014f26971f56dcd00175bd5f42fea653c1a62b6cae9aa682524c9cd57b61d686535fe33e687d4c5f64d64edbbde6544ec8736f879077475f7bd89815ef65f25eb0044a409699128491ba40d721855536957f47fcf1cf74694fb5057b732f37ec0a75404b8a621e85dc97e3263f33e86b80996a0bf43507018f02ecc4191ba8d035c4dd33af83b960ba778e15c202004f2a8d11b0c66044675ca4bf84072a82b69531c8b54fb3c8cfcfa8741cf16da14610c547f0a85857ff05bb4381e6e554879c0059010f6773009121b45509d6ed60d5e83efbeb8b19cb06939c49cc6d8ab976e7c95d130699060dd2fb326549baf3969fcbfa49e76aa8a5a03ee365d2c69f91309476fed8d536c268d28db1ccf8616eb1e42e2f716a7608024964b40e7350fcaef6eaa33831e2f5663042fe67ce2258131deb3c24e6ebe726e6561ee11acb8ca879e44e0e24d0d358c8afd7a9cdaa94b61ebac5a9e4e5b63ea100956e439b15fabf31eed03a159cbbba610f4107131b4c7fdd1485901ad1d334f66e778fd99c219a822581c3e672e9be12a9c91eac52db9942a3e3d0fcc6569a59016646742e1b9e0557271c9805dd991788cbe872d89839f1d2cad0314142d314fbed0f1d86be22f1c1c336bde9c3709dae325357921a546308185b7bb0bc3b3f895615c3de89f8c4cf7c08f87d48f4b9baf79675784ae239c30cd51922e876c65a5417b924a5fd7fab988709fb168a188b6e5b8d75ed1ecb9cb83d172729920e3bdd84fb9957b916392658ab9a7e6e69e06f982aec74e889c192a932371306d324a9c5b9255256d3d5883816ee013a8a9cb15a65a7d426a330e15ecd9eb3537c04a827d8f080786c40ab53a4d760e8034e94e589f0a0c60a276dfd9aad163c26b04838813427a6b01b7af6a15b93d80f3ff280c3faf731963b047a5e2ef8018009d309fa48cfaddcffcc9a8e1e875f5831d87f49c2f98ea389efe1a51f35ba2e903c9a1633aff0d40e9c8e003377d27ad44d79c7a87012a7b3bdd065ae7f6ccaffa258bf841a53c77e71bfcf450cc2d5cf6ae7c19fcd840a3733c416cef7925a43d66bca67c8e3e0674c803647c6ba80156fd8c951d7e5d6b2d59e49464bf015e25332123dc26fa55b3082cb5052fad173a8df21c1bc50aaed250f74b59676e7bf1d15b3755ad57a70d97f211d3b00fbf3bde73b23184f736c481ec287cbe228cba52754fcd2b31faa69cb83f1919464781ed4f519429239530d7e1a105992e54a633ab2be665b306480ef43dc3f956da4b0ddd0fedf1261ae007cf1ce877ac8a127bec9134b835a8f516bf3e45731a06892c230d2e3ca931823e36e63c4f101c50625b149f5d7572219941258b800bae3537a2359487fda3def58ded3194842ffa35fd0454f4fef52319a42d5ecb15812c01580cca76223ef0cea0c434a7ff447a6154a963b277030d438ed05df09dbd7df9074a39858bfcd7cee8cadf1df53769bc6dbe2eaa7bd3beb7f489ca5beef00b96d70bbfb46b971dbf7380ad7a325ac8c464c215ec7600da9b0b21932b6f0a5ff7fef96ec738de46a6fcc0eba3e9b5687f6801e1e904acf2c445f7ed6aaf69e41d95a7791ecbbceb5173fb8bf9f84b4c16d952193f3e2d9345c336ec7b8cd08739a21aa78b32c3508856083651ffe33914412451e361d77d38b0183cd6fe2a07b007bee7461f346d0c1d70443717da318b61bf4de033dbf0782c2e64ddc583b455d0ab723591cb2907d04d09d36618da49138342ea0f8c03bb63454048f518225cd5a1edf2a83367b6a6d0897dd39e0d7e7473b27d9afd8a6c303bb1d6225c67ed8bf6fb701325defa8e1ca5fdafd5c7dddbb3221c72b08d2885c4e7cc23ec1b340e84508a2042b2f6e164697209a3acc2051fd3e1ca95878572a390e76a335e699326b24fda4ae8290d92f64d65909de7c88564688b768c74f119610d2e33438c89ab8b09a38b4b52dc813a02389fc9db56e8a1a917799c326122f52fc9aa6bc9af6ec800659e7f5dae2b68ce7733500d1d236677c9026b1039df8bcf65eec8c6854371e400115c50c3c09c40479c3e2373cd6602c749a6c465f9416f0d743bd582f7a41f4a176d4e038a0989b070faaf58871992303ab730b4c92abaa217719d8746c94af9d4d8211a3079e3362700eb3f734d24e16ac420f439af650d7ea1f46bb16d7a0a31d50b5c881109f02b61fa7461e16d7b951a92f5f977a9455583db3191092061d7efda17a9656ec2dd3f2fd02b46696afd825bbde7eb3561a213c4483dde6d0919693ceb385eb18117b2941779c0ff54fda59e9567a78fcf35e9a0c7c8b9ce4cac793a979b2d6eaefca0a0e7e7591fb74239cb3530305ed18ff4bd24a121094bd6afa34f5d7b943595a9123a7eb7a90188eb66f6cca143cde67021bbe52787352a6d2d2c55a4fa4415a54bfea9c687d908ef3c8458a644b07334fb15e93ac6be21fb7147d95c715d2a3b53ee18059d94e6e2ea9db86e34f7874605f23b1eccfec3980fc27d09851c30298033736e54635ad4e3481a5243d6f640f209a9563153b7767ad7c8f7d2228cdbad02252b65ba6478d62a0c118dc9c85499867609e88071c897300ccbce6b7a7561b9d725c9984823100122218d95496f6041c7e2a3cec83e73e4e3117ff1834f86dd54372c3b3544b498b330c0e3f15d68131872cae428576fecf5fe399e0c305c3df3a404edfbf773ec5ca4a993c8967bdc18132b0ff0c08482a21b36308856ae2625d9185b965d229d3ff0854f219ebe3cfe28dc0555d384c5e6cdfae4c59315c220e015c1971a8cc63d6cebe41712710ac1b2de3962b4e138d65db6d53e0f92e7d85f85e063239401d4149fa235a29a8ff5a55b295468ba30d3d58ac254ef3dcc282f0bf6f4218e6459978f87ba37ed995f15ab3a4e18cb1e369c381e26ef2eb7e09b67535613695c1bace517e2e7a9731b46e9862b96b6e56759e13dace7edc5509c1c283e62efea57e75d9a75da49f24b2d02665e24df4a7458adcd5cf41ccce59305d33a1e23fbf624aa15c5c75cd2f3c3ce8d9e66179023e31b4d0f9fba9b68cee612b864b114eb619a41a6754f6f2815c7968a0c582e848668a1a0a7d673c4a5d9546be9016f554bad65a1d50382f7dea50a6320b01a364f000d60caec8bfa861c79b6f273c852cb8b77df58e7f6784e710754bdaa7cb2b86d3b403ccc57946d42d068610634c1622673dbcba12bbc53a5b2a7d0bc078bd9f203698af3ae4d94db4727141ab9adc7b66bb87a9a90e60e94c3f4a169c2c39d8bf5a787c43b598b61e7e4ab08da758606a1152766eff46e50eab503aeed3a8d59b374d35fa891b9e8c130386dc00e1bde9f42b581d08723dd7458da35a3b12052ba10b74ac490c49d02aaba3d1dde81751c3ed5c38d305f18e1ceb8e71b7b421b85f8379ed89c0987a29aeb5d394fe8e36f35f1cf78de1aad1d90d1e45be58e2f0c395b06106a6a2e7ae660b73232829b766e83c40bce0893d1dc6260341f3bd2646a163d990f2234bcee8d81ac62f7467647c5db64524a2e0a01f842ae88279d097bc7c587c190c499214d261d2a7e6239759d135052b1bacc54ec93a068b5809d38a38625deda7acda9b0cb726a93f435751e02ae46d13e22bbd9cfcd0720a04216f02888da01cf69d1dc27f476320feee1b087c7768fb68c9e1e117dcc17ae2220a0aeaf21ccce745c0f4a62eeb0e8196087bef7dbf28bf698912280cde544d2d679f080963b9bc6164f0dca0a828b44dd475d70ae924ffed11649e2358ba128b757e30d205b8f2a87fdb31bb2587c80a5b81812138580e43148e17071a2a4e8cbfa598a1811ea599207ea264fe6f96908d1d1f7af50f322275b96c58628bd12c98618a01f4d0e9f854cb62bf36fa15fa566f853dcb45aec499d45e02aa4bb3a0abe8a04a7db31f031f62bb4e6b7d6ebb773ba53bc7dc78baf3e4c5e8aeee4e6db91fa46902de29e6cbcbf45fd6a8d5bc0758082eec32fcd8ccc77d1aa0804a6f6fef81dc18264a7e76a886ee7e0cf6eb798d03f73c6a4202dd51e74195b16aa18a9ae4b42ffec7a69adba138a10a58261d22322872fcdaf05541fd420dade4c24a8fd4f00138ff30b212dcd08807a4aa569b4f47b81baea31e58c291fa3382db8b19a3de63710ae40aec4ef22fe8d685ec0b891abff1023d6fc2222c26284ef3f92a65d6c50a9e4052b4f89953f894499a2d8e64d4a589de508321c9063eb4d01706f42769542f6d0edf378cdcdcc159a6adc468dea104c7150a7011744a9fb70b12492215d10d6b6efd4e6b71bd97a6ae6369700a6399798a2e8cca494e667fb5cbcafe0c300790bf8e7b688b7dbfb049acbd3e83943ee0c8074d9cf5182ae4c96efe987737131c9390257ccc780356176e28e06adcd6358e1d1cd4b5e2c29acae33b4ffbd20df6ac0e099f67d4ce843c74b678106905adab1882db950a411123619df8daa1e11440f8e63abd4fd8426de413851c223b1c2cb4d0b446ed8ac52ef9c1ab322ce0e7fbd83f25af308b79a982c58c86d3009a837a539069c35e129afe6921a6566437ed163c84228ffa51cdedfc6c861a681a169dd32258cd5df5c3af0362d13bdc1453b7345517b3a772342fd45c12de7c4e1a32ea43021ed16579fa2a073a259d375d45ee6b33e2681c8121fa15fb8b1ed08185315ba77b00371469eacf0ee829206023d8108c8e451ba1ab351acefbac437ac088e58beedc076590e3058f508fd4ea1447868697b78600cee05a325e47b2b2cdbb09ae5585422f3b86a936e9e48c23bbcc722c743551cbde79a0f5b30ee2d4083aecad45a7ab4040cd0f6aa9d2943019d13b35b66c441c8f27f520b60c4b7d03e8096519e0d0aa1d687fa43eb05817b074a32504d8507ed0a078412f1b3c01704cabc635587c677593e1deb3e2c52e78352193c4c7f055c31b25a3082d32d83079b0e8388b84fe43fcf7404acdef5f743145449b1fbd43406f18c6918232a26ab4f0963197b0f2faf4e1286f47637cc865cc32866eb67e9416d76a5a6d0dbd28bcba3ea7dd0e1c7d2bc358bebcd46b253f8870162d4d3ee9fd52c14f3379da6adf5251ebd27ffc434300cd2338cfdc6504238e8d57c0541ba6d4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
