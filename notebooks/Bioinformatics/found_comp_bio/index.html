<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c513c644169d663e49b925909f2b46c45c4e9a0113708895e70dc3f08f6ac7a1eeb284cee3762706afb567b23fb3629133f66d19a656eedbe207bbb9c33b00a7c835b064a2b054527fdb8dc89aad724df6e533ac63423463232ad821761e2673b2e7b7c35a276aef219db9e664b5fde0e68ee9771f3ee9b62c53822d47a51aab49489a6814d27ef309940b035d2bfc401a814d4962e30ac30b5afca7336c1c5718520bf59f74f26f3fd9f9e96289ab86e48e26c4a0a20952a928eecb83693910cb496ad0c9846571533da1273ffee8530959d49ae5da913f91c7fa91fac5b6897e144ed419ea44ca74ea21d96e4f1d1d3fda6f4878a314d3e453071b8c1ea96c6509513c447c53f0618712e08a99edc8e84e43f98254a1bfffdbfd147152e96b3eb1f3a3f3187023286eec50bfdd4baa5b6edb9dd1f3d22205f7f2270dca9167f262962ce6e804e1f8ff6371451f8c36db67154bd9088af7d4d9a6c15ee6bdbcaccb146f2f4d700ec44b2fd4db9e9af2e48689b5714dae84a58ac8e39a496886b1649a1cd47da10cae4feb8f7471a5818b73d796c643952372350b3fd5d90d4cd9a91703d02a38b12b02e9b4abb91a3b77f085bab4a1e3a07b6f5f64c61e350b70550a12feab9c40fd72cb75e723f2d2d10ef1bc18e5b8e20711fc6ad8241b1f56b48b6dae7c1b70f53ed0f6efeb555d2625dee9a81bb56d3f86b1e01e9c5ad2c243415efe770dbe93d351696d8e178d5676eff41a51c8602022c7c6af38aba182c080da81d2486929a47a3d2f2b59a37c322c8efa532ccfa4fdbcbf0a314245d463856cbd4c9493efb689a7438de67a5e855ebc1b777d914592fe1654b786ea06032249b5d3b207b47fa6d10306e7a7f8ec24031f265d5d4d00879f62d14e1dbdc31694e3d7c61424377b426d548c725b0a9252de239cd0cabb4e80d77a41db783f4fcb28478a625b85ca8645237976561cb1aa1249bac1602cd816c61a2b709a32daecf26646f1220f9df15083ffe0a99112eb653941439c8305a931e9c0166c8ac3921c46cb9c7d14257b4e4c2194bad92c7021542d711a9ce8754643b4aa9adcf95a039de6719b3fb27eee6ff3c8690b3f960c37ca4c9eba62b4725d96745ec324406c71aed2faea91228f5811c9218e95b05430a575b14f1fff88b5a398de9c387c6519b8a99844916cb1764f314958a36a07298703c2c6651f9ed2ae9324a8cc5e6f8ced4d6689e06212427b7d442e0160715ce0a76b15229d6606c02cfc6be8577c486de6f0958609cd467bfda0bcd9989c0ceed9eaec2b22522f030e173357754590d6772d75f9ae66ed4c1a61a1c390adf6912584f25d381a8bef0ffb93d71f389ae85e5c39e2fde61c52148ea704e501106fd40d89a056866ea37d4613e4ffd15f053e41c2406bd8b506ad0fe035f0c291183b7c1676e5a8f23734096b3b333a0a9f2c5f2f1be63f66bf3c0394d20dfc5e0b81ecddcc7d765f444c4faffa15e7b50f285dbaf4baa56b9b442193650aeec1deebef10020b1380fa54ed4c15655dddee23af67bd5d136c2702cbcba8040eaf945494a05df478994e65d13a6d3029f9d623784bd34a21fd921eb1755599cfe5c33ed754001a187ff131444afca553f639d031930feb37d0cb83713d2f3327913ade72078c2de8a05553fa9d125aba18aa1507e22962814aac3ec0280c192dae6a66209a79f46b9aa301e2cdf88ed58dfaee7374ae32a7f81bd9073a9a6b6970a4b3a3d6f4501bbe8ba1c7eed6a5b80a762aabb6046c7da84960c00efa4d8ce3b82c852d30ecc80e0b0e433120854907a93fe95ee01310825bb2a9be647f31afd402011688af0175873e9e3b0aab672bcc1c05daf15a16c869fc7ad715a29c3d9c43cd854375a94c18179f7f5e70f8e63a2a10625ce8a0b025596be6b0b426da31c1242c1d770f31a9cfe33ed7620f4c6729139de917f7f5bdc991c8318e18e234d688eefd52e879361f1b3b22c4c24eda29aafa263efb4881d6c568bd0dbe0d7d396c36d47aefccc489cc3eb2fe4827322980d90e6488078e347a32fef15354cd1ff5352218fecc583f0be0953c72ab05ec5b1ae60ca2739631bac951daabd55a8940facda8b1cd873e2451d1c2ec1eda4213ec6b943a3011ebedb6fb1e444bc531575b827849eaa58c09aa2de5112a9d769739748ad1a7cc4f6519867f6d650750580fb7e5f1c4e28b4ff624e17e32897b443d42c55ab764768de74221341ae5adcf2c9ffecb1c23421877f56e6dc745e60dbfa5dbd8429cf04d06a5805a80f377639313c8d28c368d545c99ff1b16621d371957d27783ab8ab7d6ea8d31eb713eea3caf2efc3cf0316fbf12293815815e8094540a238936fb7c274fd6b0ba055de045dee4c85944f7a727643443cba59af7cdb7e7ff4a4b1c973cfa724c1d03089558557f99ecc057c26bfd8a6ae81eed614a9e88b55fb9c105d988eb98d5e15563f197ad5003b4efaab7c3d7123e4d11c500415a33d4f524e9d664c4d9622d73924b6d4e54ad35ad1e02c41a1dde0015e82b4d53e46b543742ae99f587bc3e6167f1c4b130c23abf8908eaef15bfd871a85752fab91a939f8cf8a93bf9a65ab9f246806e5f7c9c74cef761d4b7595929160deb2d9ec49d0d2e29cfafaf8719e34653ae638ab5a4b262e34d72f57086b06ce0f48cf51ef74dba3ed4b4ad10fac81dc7794a0035302355b6177a2acceefcf17297248d402459c1e018b45c9c4441d479ca84ae34e395041542313e5bde3926c26df1420470717e5283e76d021214693d270b1a5059295840c46cf8eb9792560f96dd24f0e57250bf19ad6e76bbecdabda5d59a316a4f6b68b9d30c60c04472148d811ff9f669c489e541e69af662c5e5946ccf03da5dbfb566e4afac8916950e1cd26fad3fdbc3051593c0b1b18b9d63ce1f70cf39a695ae2a3549d08b817a75eaca5f744244fcd299f6f48138f793d53ae847047d2855ba1e7d2062d6bd78c8c540b4fdb6382ab9c7ebfbc66299007a2b5133903cd998497528e526bbc5ee3211292ebe532ab74d491fd5ed18622a4e62ab14d1b680b80cd5972b25f51751918188a93de29cec3031ae3740cbf0534a6e2b7b9a28a2b4eacee0eeda9452e0fa9cf2cab55e713e092524b70c451c5ea48ebf5c66895c212372a613dda269b4ce9d8f951d08dd466d75c47cfccb7ac4a72afd6a43053a52be7f9e78109c8674b7685f52330d7610318d5b2835bfadc8e970464c539ae038d40ad95d841d235f238c67f48c90e1d054375a3af444aa6c972e84e7dbebe3bb38df7c884a634df6d79fd7a8cb5020d168406cbabcb00f17c25a6275f74256469faf2a71a375b330fbc26afb28adfcc43134861cfd19524ebb91c295233b49de48a63de30304fd8818eb40ca7233594770f68176e452fa9dc18c58a5e2c5526babcfac52d796da26aafd2761f6b53b649ba1075ec37f9b6a33be3efdece306c81b8e55a9a0d0e1d54300f62b53c1bd318f7ba729199652f37f6928274ffc7fe37ade4110ba93c4e2dad2fa3e232de1660bbb7a347e912e5f6e2d9120c5800f4f41e11309ef4624c88460e856e1e898ab14642c23405c4a51da15689f68194c78d6d2a2dd42d9e856280556e0d749950799ba08aa0b357d8cf2d72b37f76135cd15a6df2c18b31322ac1754ea54026f4fa345278b8154436691f8125a2fe95de835da2e84bacdeb7e8a7ca8b59dc2dd68c270303fc451e02cee3a09795498fa086e76eec50892b7b89cb416ad9b57b4601c550d849a0f7a01ee224782a88dc3622c2e9083a18d04967b49c117985426fded921f5d9364907a3aee762d35a0e3e351d669c6b73910ddec9ffe68b018a2b094a60ecc91c1f7269ef7644ea5cecb2bc080b5e172e63ebfd19f3486f0b9ee2294fdce0461e391076827935152506e72e3144b1a89e9a77c095252a51c056cfc4f3d3bb64a187183a23314e641e00ed3bad927bae93c6a5fa5c946595e5e4f8a9fdc4aa2c7c98de73b9956216b354a7fe33ada9e6fd2a38333d2468f66365a2377a7566d463314d9b9bfd8f6370f4549f6f7811209a9c71b5041b2475a0f116a24c02fea887d412b772c5f6ea94fbe52c780f396289d5804a7cb815b489c47dedd6fc269c8a517fc8d303e2c356b101ee65680ec778e4299dc364c14aba8c1cd89943e28b9201d2e8d1153e1209a7432dcc9d864a6220c61174fc962d769868245b7d32005ca2d80c018d6371f0d89db15b67872c986a8c9a440aa2cabf0144cc92322f2480eaf9f58b407768eb40afe400864202b7c9435c00d95cc1948e5f73f8e18386daf23d1f44174366328b673f7b6107ed56873a1af5a8540764e602e5d84168ff257eb828aed4b88c4e3201fb93c6916efe05f2075be0ccd95216b3e1315e0166cce4a18d6d5afe2d74050498a9e4636f0a5b9fdcac226872284206df94793753c50d13cf566de1ae3f77517bb05dec62051e4b96dfde067fe2c89d5ea81ce6c130797cb128e8a43edb81c12b5811cb34f63976b93ec330c2ed18a7d5142b888b8b9d9b60ffc90e1d15666ac9e4a8451600bda48cd832b3f7bcfe4568c8d6357f5b311f641b8c2fc1c5d732cf13bb3332a9605935634a4b88c58125b86b0b1f24d0d2d07251d0525b7e12bf95dcb45d900b6bd37a696115dc2acce19bf5140c6db86051071ed9a5ac87b86013a23c61b80bceafd9aa9b83035e404802fbc1af68379048eca7265e23731548594fba37bf56da078390c7ae464b8a032a1b2ae45f26a1b1ba2423ff15d95cf2d8e1870904c0f51f21af1c9fc51a2333405e1177c804f912904ae2e98e5ca84159b010c66d8c8fd0f4efd8bd51509949b310b040c51a671f9f25c288a353ff42bad6fb8c50adfd236e9dd29080c468da57e1e0086eb0d1a9e2413d7a74c4bc332a69cef623e675dce6650e367ec312e60bb372251f82399ec93ec11396d50eaa01976698466e0cf371ad869f16fc617ad72b00e08026b9eb7ab5122f241f1d48f615dc00fd84f4ca534c977d7d006141513a6c41b6c979d108c9ea20d6f586bbac638a5ae444b7e10cee2f57a3ccc73b4515f47a6cc643f1c455213852b5c050fafcddbf8d1812245492744515911aac64e0cfef07de1e7ab3c20f00b43f74c98617af840cbbea361e924602d8cab01ca49b64be9eeb05f1809de5ffc649bd919ec478ecc0eb7496b3e840fad72e0033e00c72a8045cf518c73672a61dd6b99bb2b9ff6e4ce15988e6c1318d1b164a5f31cb02d8a1218965f73bc6298802d5fcbfceae755f55ed7e14c0c85cc98d524e65a71751f3278f00449df3f7717fd0d4707a83fc4d78c51705443451c1ab6bbbc9567519447ec38d8c84806849951793525627cac8e3bea1d59fde4f8cd2fe832efb903e42d6698b13ac68ab168869f7916df6a3f53a0d5107de6a84f5627db9f270a0b923ca84f2747e1c3e48eb3170e0b7bc25ab15ffce7b064ae58658791f3b1c7169ed1610d5791e7de097a4e3ba94592fae0bbb4cbb7c427c85ae8e40a904a7510614cbe2fab68e0201f8835967b57df84a20341d4fde226df7fc4c2e2fafab02ed8f21ea654713e742ab87a512756ec303b0022a0d78b88cb9d7e6de14d5375ceaf49d0ba14f2529b1bdd3126bc54010d04d18e7da6d5652759695590e3a802c1c263f89802a97bbe880c8ce9b09dee7f5cf2cb2bad752d66b8cbc1ab874864c4ccf8aa7d9c9e1316eb677aa06781fe3d442ff657e24a26241265a44eed8e34b690cfd3376de2270f47108680e41ea657ff4fe027cfa0011753abb530946b151619cc8ee761928e11fe2527292dd6a2efc9d8729e8c3da8cf5de580419c9021e0c71098925107777c987ae3aab3cd20b7639e54c034e35097e78076b6f5015eba18534f53e4d86cd7b3efcdfc58cd1ab992f00319ac88ffc1cd2cc0ece2e43ea495d1dd3efae50b89903de75c8e3965620750ab5daab7dcfef35602b998091cad468837dfced60b4b385188988f8f4268d9ab4c2cfe80288ad75bf24ac15b16861847061f5664dc8ccc2a69028277d14688e8172ecbf1d49ec0a9866922cf0c3e4f6360a193e7e5eb2970fd61ba9a19304768bebabe577945340887175b03d9e81ead44f7abe6c79ed36b441d966bb2731a744562b1040a2af6044ff6e23374cf29f7f3d1b3bbfd4ee89a86000658bfac189413edbd774492911df714fb1d9064cdccda913c7e4d574735264c0520ba06aa2325da5cd37f306ccfe410c3b139738bfc0dab2134df18e9e9d63366efb43e61c42887c78c9da8345b4c7f6708f9b6535827d913e4f13ae85c4e919878092ebab1437b8744385b32a36f7efe8e78756897e8543f4ad9611c1efcf7b7af05244a5881439f013eb54228058b583ce994a8ec8232d6d3bf6201a6786fd44cf69e919feb701752df9b77fee3ae02f82e9afc9353f200a2e7ca2a44bcfbeb057d3b2d47856b1c8b9857ec17d7fbe8063f5d20da93bacd1e044a2d0f6df733be329e7e00c88d0dccb1d42d713b146cc9a76dd78f63f2e868a5cd6ed70e45f0bc2a120510309d6173f9880219bf7002e0d89b7ae6d41c490cd6397297f0de76af9a10295c50b6bc0abe99a654d3b48a1c70f886a12e5c4e33af96fbb71512b01eb443bf8157adeacb8d41a80ec972555721ddea07e7a961a68579f188112b6584df5b2104c29e5b5c9af9673b8a79c9a4c4212c01da4a7a82ee78070c989c9f095ba14eee3f1ac120deac9072a6fbf5a113dfd23c296931e4d78f611ffdd41ed617a646edfb7ced3c695f6de2e1bd6af5bada3234adc1c922a0a94f4c67dca773629218e6fdcb6f11d26291a06f1003010617d5625c41fcd9d738848d04307a3f648467c83fa0bb2b1e6a39b43d6cc630b63b737011200226bbf87674f3d62fa6898f3f4e1a8e835479f948ab2ecc395638306c1d7c7e6aacc5687e11fea2c68d2bb7fa30242075364fd3f3aebe0618be50ef9111eda06d8af4514d445cf3b9e08fed07352f40550d936ca0ab637acd768e5019eb28f080b52b044b6be7d0861019e246ddad4100ab69e3d34f56a45c18893e078eb04486047d32706b60b4000855821fc88158ffb4eab731145f29f211b2b8f25fc5cc76310296a878d951823811bf7a4a7f6559342541f94cea1d66a88d73db4bc80c7b40c82fb8ba3b7757c26f8650c628681e8deeb6aafaac1a4834bef5b09ebf93d7e05ef12dac443bdadace3183fa2cbded500769ed13e996a0a7f8c2f73c0cedcb404f44f20ea1d9eae68aebd121aef96ff238866a3a9df0eab00dddc4d826c29295b9513ce0c65e1abb1516273bcd5d34ad2a7f631e17f2dbb9e5e47f9694874cc1bb6e11ef97945927cb56d95748ed4a0a640447cc5a2c377f148ef01dfb9e0bb9b15fad12afe9e791d270afacac5078b7b33b6672cc3ff339bdda2eb5ff2e71f44406b0fa72e81a7db6b7cdb3d818ef28df388eb5a49f2fa81a77f815fa271740362f80f46849c8ebe7606a015b4bfb1ab72fdb011ee872816a9b58db365eada297280b786e6b23c1242d66a01b8010bed685c76a5252e3e63c33dd5520b66cb4d4b967686fe4c4f7ada7647cfbb32e50432813e021667be2e55b3cf9b7be1418247446614d4340afc8914543cf97565c5f3dafad3d281f577c5cadc800b18128b3d0f894f3ee96ca7a352e0962149c7f0de3cc2b0543f5ba5d83f780b345359f9802f7ec50587d3ee9133516c336f70e88d958df930644fa7abc4df98398e106cdeb1ce09b32f1e6761768292d4a9ceed5929c0887be15e142913b478d413cbd606dc995396cfdeeb907d9f750178f0ade92535c718704fd9d6391857bbe7dadd1f1c25d6149763f45b8e25ced800e11ccb38ff2b4e2f384ef3d85bd7fa5d7310d164c1d6421dabe314157204027ca3b1f34a318877c240b2da046acc6388e2787f034d6082d614c6e82f90b308d6e5055db450c61b4bb203da8e84adad71095d7abf0aa0a41e0e59e5609cb9e9d2f99f6cb9a9b12c5c51e16850d2d2ea867e3707ccf4482c1a82290e7a9308fd9c37362af2d0116761fa9f2e9bdb30998ae4e2017a19e15180382c287b5dab86be69da1e8e8b0b58a93c222495d6bc321e9818fc355432cc9c7a60b436be15c4e8415e351bd29aee009fec028253e9039eff74aabcf7a891844462045b4b3d98218ae933acf161a8c15b17b6b36620838c97f90be5c63a2388bf34357eb5e65d5d27d18ba520f70f09445807af509ea50259a5a55096b5697509244cee6b740b6aca6eed57726cf490f287ca2da00515fd44abb18f284c044671a0facb9982dd2654028d0d5ad476f668bc7af543e869eb467f78725f4d552a4e96a558b544af2b9a548d8b5364b9ab26d8210975ea393b42ad4ed793eb669afc8cb3ce0baf9d968b9fab31926c717fcdc5ad408e1ff93ed64a465287f24e00f91fe5cd225469edba3af2d13cbe177056c588b43be6f3cd2a146b70b5aafe48c5a4338f81cdbf16985a35addb9727350a5e3897c93aa6617a771e6faa5d2c157f4ba9a295af709f657922f275247be58d2f3fa745e223cc1617be1b60b45d6a35d2278beff0361b1efb805452f4bad79665f570387f8771c9ca1b30ad99c0f47f706861213f4f424db37a70173f6297fc3874975964ce7a72767207aa57dd76c7082f4cb35af71cbc7a2f9c3b9ebe47648c5a9a59594d46568732feec84a06749152dd37be2e6fdfe63cdb88a1ebf84cba73168275e94a3b78e9c31c3b7b50b8f53dec566a5ff523bdf6ba381b7ae9facfa75b8994d407ba659ffc49be7b18379e08884429f0f9a35f705c437920479e04d96d54d72c973951ec106ab95a536844c6746cab2febf646777e5660a8c3713a25d194f6223ab5f494ff96c0709b331c3c8a431cec23c1fc55e95386897b3e83f6954114835efcfcfa57868d0de90de855999b2ce8a6503fd46fd8622d6f75bfc871cd7cbce0ed7b0a29bb64576857df3c9f8b473658631ee97a839d95a38ff687696232ef727808fe87e81b1c188fb8724b2870530cd5e177b587cfcb3f66707ce4e07fd0b2940fffd6b495d570c7bd6417f3fa834b065146228a4ffed24a740c3ba13841d2664ed31c815c86f336d945a3921772678198198987a092ab397c1f9d6c55e098f856d10ea881e66029b9aeb0729844874a976d3bdbe3662b9be297038058c9ea2b1ba95fe5a99c82dba81395f8a0991a786eccf2f064cce46ba9f48841f879e8dda0761c68a1ee3ef4eeb8b003f6ac775929ec6118ae2c4fdb5096cd15dfb3a095381b8138d436f141274bb02c63235935909a274843daf7c6f1605cc5370f6df728b7e8b909f3b0575ee9b185c2b28e33556349af313cf631160b1691deeb34bc26602b507514549b6acbf33c2c876827df7e6d1ec786a42f717f855ecc7596c729c9f684dcf47edccae12a43d7d9db5a9f4b0f2fe77d241bcf52115f213d4daebf7d80ebdba4ebe78d70e58973c2830c47148895ea987de8c19d9f97258ae530a93e8e5b3809ae229744633481fe924daf7495656b8e429f53e4a00f77bd17bfdc1369cdb4d15b317530710cbdc8117ccc1051f15b96f1bfbb3add77dfed24b603dc240fce483220c700a20a55580bcf573a3222b7dcebb0fb358f67dcf66fe22ff46c4743d88c26477b7c64b5c36b1af6082be0fabe5862d57f879d524c3dbd117f38bbbd1703efb721d0755cc848b5b6fc1830b13f160aee535ae9e4068c2b3e9f89656f9ac8ca51d40929608bc9076dc6062d9dbb2164b01f28b1498889a4b85be82217bd39bb2916ad0e73faa0d7bc94d3439926b79deb1e0ed49e5bf5daa1fbb5f86b9d3405affcf4777a24fd103fb7d7a8f20ecb4d53ba0619a738aaa8ec814d0a45d78c17a021afe795651014790577677e7da24a634c71b6644627299bb55d40666cd3f01de3531827dca67780be2f92ebb4bce895a15a1610aa941ae8589ad5f93472f23dd6a8e51fc327052370f7cbe925add442193bb12af1b505cc57030a5b157f171fd5c4a346624db3d4b92e2a59da01382305d163daed6760f8d4f020c6ad0ff4e51139f0774c1af6e3d92bcb9504f8f32c510b774fa7b8234e3e72d7fb50dc1b3f85b8e7650c6ddd738d535e16e15415fc2268ade7b59fa7faf6a8a35c6d7014415cd650fbae6056eb92332f8c49b9e81c047abf5fbddccceb0f135e21164430f3442f0891f94a4c732f838a00e1ff7dc8605090636375abd8af1dc345f0c8a3da7d4868bdabf21f28a5d51fd428dcb9654e3f6681f7d0e9b8af45e0e7d78c83830f08f079e893689c64f10eb377d88d2c058997109f7644f0730a11c6c0e321c490dd56d6609f227e591f5141650437a1079ffe9fc9a620cb3abbb62c31fc91ec2e8f6e4c0284cfa7d9715b17db481a1dc23fd27cde9b47e184fd37f20474d7bfcda00c841d9e417f6ef9e92fb5fc2752ad7564bf923a1a90cf187bf6098950c81d641dc13dc6456414f9062abd61dee9ea6fcc6ffbaad67493f2439d9fc9185ef44f6bef747781b3a101e98505dfa42b7a968af0d76966521783ddeb8946751690d0d3802cc00828a72a8830b3c2e5b5cb7cac56dbbfff169a704608d78bb707322b3452088298307000e1e9d586bd3c68db81547c36c01bdfcd65b2d75b2a425356defebc9eaaaf3b7b09e63ef67f8a193a312a476f63d907bae5802d9a4163c1e7585fc594891c468c39f7a26381632d182aa678aad68f8d44d3f8b3169cec1759137bbe9a827376e3179422de3e026db6bcd33f38eab8ae2da0572713d869ba18be8c346cd09bf26d68360c5c150851a1c625a8e50245532db16493c016ecec6e6969cbc4226450193e0e61fe09de85bbaf5419652c735081fe74da90bbb6c56f7d6decb0fc7249bdbd5352fe0333c9dde3a08afd43fff409abac31a50cd053934d58e1bd7f31ffc4eb95f21688a8169bfb0456ebe4a4541d2882bbb1b42242a435b01cb80c551fc7b3ad3896d40a55d610ebb18e18d778f0b299d83d3acf8423356a2b0324a9a916b3d8076df1239c935107ff38028fed8bb077058a9ad6c07dacc8680fa3820d9c10beecaedaae7acdf0ba03f87f99b81f80bd0ab3a14b1aa88859770e653d862664470486f6f5958c278addd13324791c2850acea097b3af4f5640b7625c6555914798e2e1ab0a0b3d02b1eb37b56ba211162161dceab6456f70468996436705b7a7001fb3b3e44a3df3f3afb71aa612bd404f3864380786cec54c32f1178095d488c3821365a381950394bd534308415385f40ccd3a7fab12767dd3aaadaf5491b2f0c4dd2c7ede327741d1d692fa399062dede543883d79cd52ec242c0675fa5d78eb9e698cf6e11c9f8c8be2a38412780e0e9eccf2a2e2c36b5ac4489d13f43a977800c41905026b3758d108b4ba3c96d7c068ed30bbae8b4d68c7a44bdc42ae279fae32a8355cc48fb01ceb10bef1eae627aa37ff6d6addcaad2aa2e8c9a1fee7cd6777ac1635f26a0fd281d665a4801365858fc47f47caf9301ee2802f4ebd35d34852cda5c69bfca96cd8d8da3bd22b0e7a052698f12e9602b1481b1668806edb115daec963464dfd79e95f1ed77d8dfaf6407891af9e0119883d8210c7bf8ce076f7b6392bf9a8593493471c76d0b76104c627cca2b82d5991c38a0b45c9133e139cc2cdf6d4069249f0dbac2b2bdde7dba801c0f814a201992b7dadf4f9e446aeb221daafba27482d722593ec980708bcdf2bdd3cb1b0dc040b10c409aa73a9ea414c90f92d0af4fb61e33f6bfb1910f39ccf54c35caa591a99104cd280f77d3c0ce9b0db58e2770e726302b1ce561ed53af2a41dc8f3d4ac6af270829b2b240da66f18ac883b5e95ccb68f09bf27afb0dd6957e41a83e018546bb1f6e3f98290a85013746f1399aef0d2dccefa7e0e20ab7084f876fc83e3baf900f88b6675e14e18e1c7a34f0558acc6386c25012dcc33d48868db542e2e3a4f89eef34d2d663e8fa73643a7aac82a30edf20df7f17dd8b0c8c7e8b1fcd0bbfdc5e93bfea63984a7beadf303e0b621f554a5948a964b220967d4e7baf2f1dc3d494bd12d0ff2cdbd4e47c1dc0562aff0cf886dfc94c83f074953ed394b169af0b7ce9e041d74cb2f99bbd18117c07cb0f777b0d5bcd0e4e0ba590581cae6d3e7bdeef90a707f37c9abed585fa3cee4fe881f8491cc500b8ee795257daea47718750c326c1755db62fb7cadba888c472b29cfa9c0d7d50804bd9a9429e4a61ab56bc41d0e5037a1977c7634df6315f9d55f4e61d92c6421407e9c8135fece35d38a093d42f2494e5d3d32a2839d58449310b50ac0eebc2965d7f0b15c1b1cb84af2a6ed2839ca6a506a26a2f3e111fcec923fb48a6ee2538c291448a859936afed1881e60fac00c173de130d34b5a379ed98d8a1629a70678e41d7b911b22df8ef431f96f13a7205a1c413514fdc785a5fd32246f72d89d659ecfdd73a33a46b922ff168edb238afacc1091c3e6e9949244f834bbba86bde019e0667aa28776c0a6f24ab5e3e9e588a29779b72c552f2c12678540eff696fc4acafa57bf712475309f34c8021cb875921942a6b06cb48aaab0f2b7e0487d1e1e9dbffc3963afea4739cc3e2fb3d7e28c799d5d6b81520ed233b4b220c93bab753e1609c89ec3b20b7897a932d264172a4f990de55bd43d79f046cd4325671eb6a6d86bab9ac2043ce14a450e33232227f40593f7f0a9ecc511f4c3bc39312b1f864d50f94c2886a65e7a16e2affc757203c3e0a9afc45aa6f9a03a9b033e3238143f2a2e5ecd1b43f2dd603552c579c5381e3f8771c58cd1ed23bcdc7b90ea1eef1bb477abcd3c335a1bbac4350453e979bea47f4fd9ddfc570eb394e0f5720b27773cab63d02bb15b9fc8e5e8aee791f5fd5572c084dd31400490cd5c7743e6bf3df57aa180fbe014f303cf4036f6e31468066421437cad2d935e506dd63c33bd88318b1cf4c6edbb6c1334c7fc16930e4a01c069709e79e9a6219efb512065a9cf36258c526795af1c4150ca02f7cc1d8563e2dffe91932dc00a09ad8a5bc3e91390a438e5371c6001ca67a1885efc6cd9e594e4da0c1d9a9ea531bacaec312c9f0a320d58e7d9291addd143d1284c081ffb85ce29328e4abd36cb1cd00efee4f9f1c2178ea3744fffb9ad1cf100a9580fa36975043bc6f97dcc4ef8fd71097a54ab6882ff2d02549ed088e75771bbcdd4d757c0fe1a1ab6af6e6ad2a3794c552670c244917099fb8601b66b0a0ea0148a680057150ca20add42b25f9907f86851bcaf4ead8ae71b0fb7fa02461e75e41686f581a2ea7cdd8ed0f7d767ced508efd1ed5aeb0b70e31fc4010898c21210f04200bdc3788a29631dc684f7d766b8e31c2873db56cc1e167a251188238cd4a7938aa3c46e027eac6618f1e91ef08bad3e54646ab664de70e2c65fda363e23cf4390d0ed1ef698b816839de00efdea06260e34f33076afd7fe1dbf0e1520687774d41bca7c31048b45048fc3d920a55065ff381881d28550bafe386fdb4dea13b95c2e64215dd592839bb3e20830a58b39b17548e849c04619cecf80ca248f90a58696a88a10a5b47fab098f6e95153947578bd5f07691fe4964c453dc2ef111cb68583be6a8646165980881d58d97f5ba453d960d39f3a780fec0fad592a880d2558c8e03d222e46812bea82a6f0ff8d4b567d37df37f19482b590335d463d49d3d692f65813f8adc6606ada018b52a143ef0a0743e13b81791e9d7020638e571cae90dd91df9813ca8f4ddc51d75c96dcd4135e9293b6d454acc69bd5d43e7a046470d5ccb4fb6a6187f3ce871d6c1b4bce2d0b5eb9beb675653123c3e5a53f1c1652fa0a24a8d5cc99963b441d217f4a6c6ab4f24adf0b455709bc657886cf9dedc1f47471cb3892a25c32ce7b79b7e867f5a3a993267e40355a14e0602258dfa7d6422ad860e67327106b05f519661ec6c33cbefbae8d91042f016caa590cc9adb7c72e85351d13fca22eb4d3532598fce9cb22c37658f6e23325a665f82947b6c8e15537f38241206ac7f455a15fc88abac68f5033194dd0a1e1e5718f15a188ec46322a2d14943bd7b885adec0f007a5d9ba81848cb054f79472a06caa26e28ec0539a3c2a14f9dc2d98a764e2e201fce3c0d08b6e1da9296b625ada278be7c6ad51114f9ba91f2ed2d0c93d28cf61660e5d57ad38d48464350e021f4edb73af46a225c639441aaf465e822ef5e3d7074fba28341771369db22b64c39f3852623bdd11752227128029c7b87b72f67d94d55674df9ed84f653c323c9521d3f93a0752b48b25f5d218503061ac910c36fba132930d64b4cf4d50079b84ae36dd15836c36d5dcef34514282fb63272ba8f00e1c8759ac53dcb46e517b4e417250e946120ef7948741c0a4b536987f0a8429a9197652b676bfe23db1fb946971c779b6caeccd789f6aa5271f768169f5f1e1c365488bb783aa0abc755a308ff0941fd9224b403777efe491d09595bc14043921f98a11cd17afb8156967b5788a114d28dc56a8118a2d462459b066db14e7673cafcd26805deddb5474ab068c393a7cf28596d61ac187097e6f34aae6179ee7159eeb7e5278a563d162c6cf80bb4b9021042deeae5ea19c1cc9c096c3f30dacd2aaa7d9b177b9d4fdb3205a1f7990d8deef7ab2cbcd8f319f7cad136c253fc08ec878f63708680f1e3cae82eb1cb27daf2219e8b8d5f85b2c5500cb0a531088db1dc96a72273eafe24933e38d36e05147c29024c30c304933bdad4184a0b1f24bc0d7ea3f2b53b1d3bd459df22bfc7ac1cd322f19da7913e0a756692eeb005f239880f9d2fec46979f57d652615ac0926c89fea479398d7e6292425480b41d083214d1ac624dd916161dcc5d2a12d99a60cffdfb32bb3fee077444ca335a403ac842fd368e63c05614a0eb2fcbacc9f4fcdab5038bb58cdee475e5cf0b2dc4e11fabadc980a821af18d2cabc00da76cfe104cb058e698426c2d87576ff6aabaf224617cc116b7ad6e8ab8cf43954df7c70c8756fbcc28699c9c2c381047927d07b576ccf47fcfd3d816382ef134c751e061e961cfffb568398b4457496be4ba406eb2587b906467ccb58cf2084eb995f415c6f5ab16dd70584143fc7c7aaec766fca0db4bf1268f00fec181f335ecd9f63eaf315ef02867ed0a60e645dad014682a3a106dce8f447b7d1cbf1821a5464eb399a8084ebfce1cb95f1fb5242e0b4aea5bccc372b96890e6d983166ca65d3b35fc8e2d931a03249250b9d97fed2d5471015c9b7e8639401a81ff74904feeacc131ee2966ccbf389be3f2d44c15484f64c22c3e6b87344be557db37d8ca721b6612f496886f6177bcbe88305411e0d773319fa1a15ae0b9223b306e8fa3f2c07725d1fe63db005d62d68e093282a136da19a37aba38d766736a523c39fe2d8bdd3cddcc143feb1597c638f704a306396c54fa5493bcb1b0d06a01afe037e9be5a910fd59bef767dd6db7c230ecc12ef65d6e8350e8b540318fb1e197a4952dbf07b6f4232222a3c9ab457ff6398cc1701f4eff790a8910e4aeaca1ecfbf5cf360811490e056599b63792cd5c6fffe04a2c3bbf25546e1ed3bccdddeb0f6c4ca20cbe6ede279c8bdfc9227ab6e2c8fa06740db48f3fcb0d0ee4603d29efcf092f4e364de61b17ae622f1455b7411688112e2588272be92de75efbe3424bd99488269b43f2e66b73661dfb932ca37aef5c445ddfc27b0ab147f30627600e64e9a190ca3294bace263f17e99084391485e9bb4358d6cd47d40de4de7ba327b5ec85f52711fc98ef84abe96f24c2039849be6fa00b36d1825198335514d05606b799fd37d3fd7aeba0c97c3cb86a9b9b4a3c2b3abd899bed7083a0d00c86e49ce9efb00ab7cb26af50972045a3acb5106b105012833bd9eaa747fc3bb75917c6224f1bad454bf0d61b44d30d3053f4cba4bd3d4bff60d513bb2979611355bf0765c5a1b7d2ec92010e4f0c3539bcb94403fe88d6d14f4bf8b734c50cc2b58905d3c2bf08510bc104a063b2aba0b3d78c7bff761b01d04874c6279991900fee6ea31fe033553f68547a88da1e4540c9d9c9779cbf0d9a6b91d94749a00c2cada6f57f020112021718935af2b8755de43b98fc1415268a34ef93b94861b666730312e88ad168d9d2b7c51f9c89c31a622b61b150dc55601f993f0d30c37ba817ed75ac598366bc4d8d2c1c78bc975abb981c5935b8f0b026fa9182f352a02e4e8d283162cf94a5220d94e91400995e5dae45121490be57fa5668ce6ffb7026c3754dd5315325ef50445cabc6bf3b7cbe228b0c6ae2da0dec12bd40004c36aaf721d46185bcbd3309bb24630d73a2cae9484eb9195e6d7a51f89f25797e2254b61c2a6c1e999508373591b317f8e36edc64a9c826db85b9f2caa589453daf3b47c059a6bb7070e911eeffb298da2d58a8f4a075f12bf9c09da472c7c439fe8550930560b41cc828c0516115bd805b093987f50baba8ebcb749b772c85c670d0743ec32d7fb9855be2fa62f110064ba654d805be600b6448031b87aa69d311350cbcf6f1ad100cae723b9a4cd2ca74f380410f03f4311cee5c64c7b40709f02c88368ff3b12213eb226385ea06b4bca5dcb79fcbf503ac0f563521a071cb84dfaa9ad79c5030d808cf0fbeac604d10da9739a17d9baf664878b54fbb82501f6cc69e400ba1f33ab239057b5cb1370cf7309239e9858a5a47b5ad1b45e222b6077c3000e94fc885536a4673b0a3d896322e97db1f4326afa8d39480cadca60c6d5a8d88e9d4a2323bbe7be507cf7fa4b642e0b21a60bac23070fccdeee31994423b8b139bcd82f300d9970597af204694f9551249df51b71a15dd037ba4c86d6f2f7444a4476ec3a65ea505cd0030e2212e73d2838d676cbb213e74d5c7501bbc5e9619a7ae8731e5ad41a30b13ae33ac1f4af434df3dabb40fa3b480aba72738e7539810b1d6563a7b2f94e8c294e052f6283730eed8dd873c43ace64a72dbf3348a3a12d5b9039b7cfd720ff350ca87b31017b93024fbc83eb592da34d5378ae59617d5dc7b966dff8541a824ea97ab8a10752ad68d97f8806ea0c7759106f24f3743e89dd8ea5c194cc8383665c1c543d1f21d0d3eeaa1d1229c46e362f208547754929c27367bbea8b0082245bcc7d48a577db2386741f82e8ee72faa8ee66b0055b38f4a7f5e08c578b0af7d9051513be6430817e963625c5ff9505c5ffb3beb56355c0e99418399de6e8099f73b23303bab320b03aee6130e18e1b5427e4229a001fa6258796c344114e08c7440f62d6f29e5e9e6520f02ac7c85a58155489116ba39fb20e9259167808afcbbd02d7c55c7bb82a5b8d10244879474c463f27c6bc0693449d2bebec1234d354fe7db79209d342a5f56940e6fd2619df5feb2ad9a5b7dac69298432a9c765b964d2492bb75eeb0e0683d3cec0a338f2f35b0a6b8e60143eeb77864ce2855a8202ea683b89f8c195107edd4b647aabc000ea504138538ef9b393af830e071e1237f794f158956281bf264a75760caae13b208f5796cf932fbf07fc43c7500f343ddbd34aab7f8ea35fb925f8f5e136da736a17e5704cda230ae6aa88741149b64b0f55ef93076802a95d8d09c88b57a009b7eea6e07ce7bb664ceff5680dea70a52e2691f3416abe691616c1b1f677e538a27ab721b2848be6c17e4ce0dce90218145fc45d774a33770e8f253a684b5fc739f72e142d2139e3fc0dcf27d00aaeeb7711fdb346982be1fe5079671e11b52bcb178e755b0560f28b7d25413b704a7947ccb372a076627c003674ed77df8ab38f6dfb0a4ba16fb260c85b6a22663ceb5e29ddb34add79f515ec99d55ee6f0676bfd75ecf7984fb3491e068b7fe8a75bc8609fb308710b97ddecb30e83e074ca01ce34cd89c66ecfea9053ec4684e4d72182a479f308bf113829b960d6d0f264afa5c10c1060ebfd4b84aed60b1f00b7dd537f379a2a22c14868ef595659a135ddda2087884f6f4982598b8716a1830740814be7d56ee47a00cd9e78a33178ee95f5843aca0eabddb213f347a856a13598168c899c6f9694ecaae087fc3b47188dcc4e4db8488c814338673293b48005f6caf6b9fb7158cbd391f3d45e7f4b2354b40ba856bde9a321811afc77eaccf69b60dc987dafaa2dcf0bf2edede81868445ffcc2c68f47a659e07e5d047bcb22de0c6722fdeece2d0ca660e5a2f2b991f840c9256eac5fd881614b4d1b3df50f022764645fc6dd7fe59e4f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
