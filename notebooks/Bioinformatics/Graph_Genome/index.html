<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b96e7e584a5e9ca3e674d1f3a25660de1a7d0e72477c2fab7111cecd66f919c10aa2c8d25b7277596172d3ffe3c9c8ab3a0a6b7152e82f3723bc38f1acc8839e969efb338782ca7834b543cafbeea5f36b37ddbde5a99845c15916206ce117f29c5d2801f0d3c7467048fa5cc1673377629b477d3fdf073fad87d61cfb13f7a5fc0bb38beb64deb8634303668524b6060bc4b2022775556a3c7b2229ad618d8b68307d17d58b80bd99f359ba602152bea976643c029adb195b7f29b904bc0e54dee035473fcd210a97bccd085fa1bbb8dd220c85b655b0651b2f35ad7955b366e88d7acfeaac772b21f8a811eeaaccbf4eef20f9ef13c075f1d8b8cdb715c42e959b86c22c0e01b1bc72be64e337649839eb258ef5a98be70813cd766d29ad342d181eaac587f8ca06ac35d445340d403ae0038a38f25e63772e7c3f372f3da74b3520bb6e1f6194aa4347050960aa92c254ceb7db29d46e97a8a7ce1fa87ed07d334d54c27c9f3bd3abfb7a20ad4cadd4fbfbee8750cd909fb4748daf3250f02db23817eda78abd2bd58d414f8049192993477870a28a6a31864b892ea7de71443887610728ee13da6aea6ff7eacaab6766dbc5386d378a3e6e233597f8ef66cd619653118c1ed4f8c8c5ee497219cf29e440a4c91e065d31d96293daa8c0a72b2627eee1f34a0ef8f6cdd5b7a28b967c43529c3e3ad0fc4b8a3c9201962eee656ea92953754355ef0fb140ec5050558e807d6065c66140280a2b8f5f7411796dce9d2b0bf243cd9e347655bfaf1285f5e269241ca10439bf95f96772a34748b2433599018c9bdc9d44cfb9f24a612ace53126ca9b12713639873c6810fc8d3b1cb26e5005ab2958f3189d647343961281755a9e15f30728b685389078c51ab5e4c6563c72dae8aa8de6a936ea01887001d24cb7a629ffa6cfc9b1c6827ac3cc54d401a8723d40aa1ab399fde0e189c2191e6ff425e88d130b0ee5f8ea1938fea5b898be428d57c4ef38776306e3468c13a162649fa16c5330316565b6ed940b698a7b075f0975d492d3a3280a97a4e0c98729b458cf592880577d5ab2491d6bbf74fdcd0269302082c8f9c4c152d23cc9bdd2d1da94853623f35bfb54804d2173ebdcb5c9f4cef4fc1c0d66365b859bce5a2d099f1c94bebdeab5d8c9e101fe1164b3eea1e4dfce65e9ef1e16b9d796d6fc2a92257f3708ed1a917164a35608e7c19c6be08a901a586b972a964556d52576a1b0b60489ad279418bc5eb8d98840ae102a07bf28eac4b92284990d18d6a3024700afb8855488e2b04e08bc6e71d5cd9e616dbe7c52fa443f4b4188833b7d3eee035c33e5de27c92561418417e58365b80b5e21b1332456d6d8b24d7d5863eec8d4191a41d854192487897387ec0093c19f72997328503f83b310e6a0e7480f416dec1fa9ba30c3e8eaaf438414edf2e082a52cf4d7fcecbf0f161ef0137b749799b56a4d4b6451f8bf1aa9c4f70a1d702c28e42bd4da7aa2ed7a1bcd2ec9ef056274c735e032335ad9717a0f1ccfef5704702e0bc54545f4e8c749bf3d82ce8458c0a80fca1f6d377a4d97f38ecc8b1f7991814e14af4b564f3b806975d86fe00581468d27d5303bd2513663c7afb42c8fa7bc292c11898186ada515e491b60b5fc177ac90c90baf0c322971ad96e0334fa2278b3bac51f61c5405eafccd735455238d75a25fb02805589f23d075a2fdb1f10a1ae3e6a843acf9ae0f4be55c3912343247fb3909e2ef2dfff1a89208d84777e7f907a55fe84a9f85b33e3ccfe3e73b98a54520a686bce922d9bb5ec76bcb4621080db1b63c8f6d614e0666b4433cf1d8c5957dffe9bba02b02f15823632f9bbf5d1e87ab8d62affdc8eb02cd817fa31d9b9516cd2db4febfdd6544cbd03ca82536920432a5e696eda97ac1ee78525d15309918b9ce6613a06d986b6063761a69504262de8545345945bf1910cc939d099f1273f66c802d8088ea9969b25dc98d91ad3e3ae0e12597791a8cf4c9282faec67dc5f983e0bed1ee83a9d1432778600833a09419d1d6599bb0207940e93a56ecefcefb8c38f3936443213ff0fb0d30eff2bba78b9c8b1943f407bd33f89f89efcd0c6b96b44cace8fe5519deff11aac32bdc6e6be49dfe7e2fcedf26ff000ca6469aa3f80a9ace1995049703621afb2af5e268bddf775aa7c45cedc58fbd6f254f6da2257542205d2f349bcf2e54c347790bead4716d6aaf47783c52ded7716e85777ad5322efc569da08472e1eb9ab00b8cb8e4c7068a6ff4f51a10086040e3129a18612272cab0c9bd03e6a2775d938c8dd4029c1b482d303e1d3e64a1cdf21d6e9fa2a4d79bf31ebd66dcf78a9e750436655f68ad70ad6ef45374feb2e86b077da989e1bd91f7978122276cbfa42aab8d4774d59a6ed2672fb8c8ed1ddc02c5326b70cae7f23656e3b1bcdb5b2a94d66b05330c96716436d1bd43a9065c33102f44442e4907683453e05bfa3f4caab9defcb18460a78e8c4b7eb4d29c0f5ec4418eeeb744af198cf4db50dfe3786d4d22c5f676412edf8f1030a3c8c695c9e524799e1fdca783ff87381edb505cfcbe106152244364b54cb4c195325986edd68d2f590dd10eab5324b02a448944e42f3a90b5ed1cb8c244f0e1a8977c91305ea345a80c88da724e393cc43c2416c6acc2746b8e676a4279438a2ae84a08ea1f501aca2e54a98fa73ac948e173d2a5e330cbcb81f5bb574f0ab63e4be60eea0781156f907e13e11955f8cff927d8dbe7adaab1fe85aa924d4824d729eeed6c85b05c3d85c03cfc140af4d4f6ffc47fc56759879a83b99c3fecfc160c30855e7e8c1adf77eba0ead6913bac78a2d0018adee7c81dfa2184e46ea72efa0d9cce8fb87c8c6d1b6b35905ad6e5b2db8531ea52401c18c21f41a1c588e18ecdfa8293a65e3bd1935fb59a02feddddb9aedeab43254f21c602cc6b8dc1056b3747dfc04dfe5f56de22eaa55d8c19d43fa1299808edf8f9a4c72f96e71b3a3595d562d60da4e9d37be2d187fd81350af8c0f1794d1c1d01db2012a5643275da785d16b79cea416b502022bdd1759c68a05d7a68df9f9b127832b07e16a02e9aca529a9959cb657402129272ca3dbf9c6d5e6c71e98adba0f86f62e9ed9c0183f569538e5af5650548de162c8ad283f98789f0d053c1fa1dd543efec53dd9ec58f40f51bd8d9be2e878b67f18241a42b4876f9af60edd2c95b650fb0aa02a6f4438b7b7768763e65f2542bd70d71f9b4b4b61fd2172944c7744f85359080043f3106b6056fc606ae44a9124c349512dcd534b70cd44a2a13b0a168d2d2c2810e44e39220410e600023638273e820067edfffc40d5388a72262923d28e6e390765b06215bc8c4c5309442babe14263c00471facfcb97117e1f09234896bb27a356944e06a224f7d4f17e2350308ea086e0407e460286f93d03c72d0b89bef1ea51f488a44e0a85e49f60ad503f472fa0a70f6d2f01f822343031e961724cb542d9bb10587a9f09007142e6077d4f1dd66659dec9a911e1f790ef001de9e05c97ad58913560c6aa86ca72088f7cc00a590182422957b046e449e11ee2d7013b954e60f22e643e5aa57d320a3330e08c7c7dc0150818eb11901cb3d195af2c8f4cec37d2bde20a0388526274a3bd9acc0eae5c92782558feeae4144226daa0595f0083deba27e80e707ec8a53afc63cfe543d16441a4fc9169c52f2fa7798c7237825d870d5f86cb187f9c62d4abbbb9940e784166642a790122f59e240b280a98e5e2240f9271170c5449792571ed2ab1362d60897428f83f50655bf007e20e1ce897bf627e8d5a83874c887d7fa70bee0803904bfd02da0f3d9a2cfb312109f780956993a5025db05efecfa63376b1f107e9b358c733235981c0873c85e8f45e040230bc9456bfbf59190c45342cfa8e25986e3c88b31998c40ceff00b5c254c4417f535a87e9d9efc239e8b8ad806eaa515b6a60308f1db9d8e2a75beb451c28e295cb4ee7de39e9c75f69e0a3081ac97c4bf606d12a20d050a4f88b69b1432ad54949998e37e4a03c3dbbb997ac8455318f4946c7b71fda26731c2a59e5183b34206788b0eff16029a41794229ae657304f1597e1283ba2eb8b83b1fb5f18f65eb3e2d103b0e06b99636749b7acfb05fe9a2508193989ee37374edbd809654fe1a5cca427fc7ca4f2b7679306ff11991f65857d5b35a02251641112aed2a25ac2b019f5b21c8045f114f931f70bb64a82fd60c4c3a305532f1ae222fb8b1aeba6c9ff5337ff3200206ddbc75603eba33bc7a70f66f25d3c3e3bf465ebd8987d77147270c195081349bcedf158fe9952bbea35a011191466ecf3d778cae09067e70422515c4fc974d2f42ef1d16d732282649fcce01e37c7675bfb594090530490f33ad561c46771ef1aa768850cf0db52ead9f584c5830edb32e9208d4e8113ec8431c63a5d1a9429f700f35b37ff6dcca1db99f83b9a515ab620b3a3c593845e0b74c02cba76346562b2c2772e49f0f62a403c8da46cf1d820c5f81edb0b11f3436499d611fff18645640aadcd6c69308342a745653557873af2f4869b37ab9f539d2171c7fc10f33cdc92e2d30bd3a89e2e51590c7e82aa880d0e18e7f1bc0dabf02278138cdc9de006a3d2feb10880d44566c1cf1fde4078ddcc85acdf8135bfc7fe4e531d6b02396560ac97737d997ac9ad97ebdde851d80778fc982d2fd8c5011905514705ef81223651c87990777c260e31fdc9b0567294e435abc8f9282c004ee809874a8de9f6fa36006c543407467cade4a02fffdcfd09bfd93dc43ba6d0661b9c87212f71812f39d924f478aaf98f57d969a6459fe08775c9e1edc6475c3ec3f3f1052f958f7237c55747ed385e95bc617b711d75f19e9ed7c1dc817727d7ad6d625476e8c6a8e43379915a97e88837838be59915011915b41e5bf26b933e5ac059adee3e3c638afec668d826cafc25ee58912d927b03171adc6aafc740b1926dc26af6d7a09e828b6c1353f467aed39a8adb27e11eb4cbb09347f4fca0136c0b63b2878df67f414de653875a6504353234dd755c084d076a744b9e66ffe75876221fa0265bc60a473ea03ad8bf83d82796d302098b0f4a1d4524825f886836083463b743e25901d4d66f28f34b5d2f7d39149084b70884eebe7ca87e86458a39b60ad8b6b606bbd28196c00515bcb3e5480fa329a1fa39295a06f0e5d27f034709add23cfa09963e5bf1c704415a0bb96bd0810e2ec249f377bc40f100d9b6a11ed9495ddd23649542787dd32551b6db9d3f3748eabb85802da47f4787418f4788ee8e98ae5d5b3aed0e89688e5080cd6ff189e71456dc83cfdee0e41448eabf556530242c2c56c7766eca25b3675aaa5e42d130156fb21cac23b4fe8d2a9b3fb359b2f76bdabb1dc9320810ddae7af0e6ee357ae6153a407c8fbd8957e45accb6f36b64a977fd59cd047e4fc64121e7ee535a3e25d0cbba25e80662f962366e4042a678db5d4e0b18f42685705cf98792a30ccfecf931d9f5e15f1e21c21154464c85cffff02b3421aed5b42f4961bc081d53fcc88ca3a1a45032330867633f5bd29daf375ef11cd8499eb06a2c3ea167476b589805d228c785551b7cd62b8e063eee2c2450b5606782314fb973a47b1f3c07449df62aa35d59ed99aa09b91ad7bd84b10fb8164a1c17019c560c04117c5efb8a1a370f4413e69ca6a61832d0c8161a113b1c4b576bee6df207a787a45c86afae17c87037f53ef2614f4241c9d621834bedcf6af1e6d73a4e81fba5adccb53f1c5facd2ec8b0257220d028121ac7bb84a7ba4d2a14798e0ce4e17aef679f4d8037d5ed270502f80f647f788f9fa006cca3c65925cbac3e4390046357a57152a447f31a1f732f967daf3f62469fd529521a4266f008721f7209c762982a8ffd0530d12085ac79ec6da3dd1bc1fb642e3e16eab44630add28f625ffdcfeb65dafd8639ad8ea80470a71f5fb477c9a6359d2a553a4c3704ef13277670e4075c20f8069b3dfe48a34d453533c2d563892fa652dd0ab5b42209ef18ff4f73c8049bdf6663b400a8cac62aadd99fb3223587bc81a4cc6805e161eab4402995039a29fe79e6872252590f4ff63dcac91c389a9d32f283838375ade13e72302a60a68f40f5d83474811534aceecbfdd9f5a4669dde21bd82ddc7d4511290c7a25d057bef411d604ecdb901ca45223442e9c4fbc7d0edeb56b86876a62719a2ca3de2576a350e6fe45053bf90001d100d680dfb3b5f10b0849e9a6992ba352311c3d580705d9e35ad54164f7a4e67c836c68050fc637e2c095f7a90fd95166907520f9ecfc5e20c410cde05aeb2b564ac2fd73342f5f9323202c6c97cd11c729ee0a558124446c35af3612f37519b23d13ea153b5ffd687a64ed34e945e30494b2dddd4ec2e7eef552f5283be2361db42389d252294511cae043a2c28be5ae1b0d81ac84fac1fb001743f0fb9e4706830ee5223d4b7503c9ff1ee3403af12909a7416c6322dc7972a55b083e41e5d2c708d424c5ce7b5fb02606e1572a86a542d9c8ea948a151f643300d7100511787bd30482055d68fb7dc3aa943f838ffa40478bad9d1abbc9ccd3658b22e003b7b43cc38e7e2cdb701c6059a692e4fa8c00d404d35b17cf98b63bb0701815ef00dc0dc460224501124596843010493f43e807a7e83f8dd7b4aceb8c4f19618cf087b89a552f573cb41923fbaf4ad3db79808bdeef1b96e23406c92cadcb4ee6c3a3d8fbb030cba43b6b032ddeeb2603b791b3550b4b35d3be90f6538875c56bf371be056442cf97e4b8bb4777920b1af272502f3983bd9a01be1c7d2cf4fbe9d17a90d60d664e0defc1b7c749786659f0dde6424b2ad2393d364407b389ceddc0e8fd50151260b5a5e66981ae66236012c116c5f433b853da95c10e49f49980dd00a19faa3ae6edc40e8ad164f99494bdee795e51981f195ff8da92c680cbb3283057786634115a8d79d2037b87e67ce1b023a575ea68785d264efe7ddc9006b004699941f4da818b369164952cd2991c692c5db61259b02a492069da856dbfaff8f250993f8c8055d77e02445f2cefd5c205b1592560b4d5e375656266b246e86c90ebdc7f463bbb1adb6f1aca9d3a781f706871c740dc075773fe65c199b8ac2489539fa6f59e972b99d820bee625ac2cb69709180aea1162bb9f0c9ba575c81d4f15354309695dc66ea0f3ead45df7c42aec0ea95a3555ad5917874fe91428219375c49827a6d4ca4bfe81f22294cc02aa8b24262424a005b91d9ff6989582e1ff71bbb9226c90a245c90d2eb2dad3a95b2dd5b6f662107ddd1267825c0fd740b6caade8932a4c973da277d0dfdec13283871298466ce2ec8afbc877c529c95739f404a0b397f6ecd649cda2d423a57f516e32cf1efadc9a38fc5d37844fd818a680da414b5b68f3cd7af507d468c79e65569e4fd59440ced238d18d0d6c15b756bdfcdbe368ccafa78bd454f3cfd3b4ded5daea3e4591adba040e937b859ac895146f734128435c506d5f03fc401355fc18843577662dda838067093aeccd8fb35bec4a0a0bab08ca2e4cf7607eeb552ce64bdc73d6dac211d6219b1d9dbcd1cb2faae5b31b40dbc48e20a3c189a19c7e0b80c7d761052893fff6e26d4415edd6587c9de0dcefbd45b699f80a0fbd4e384b259377cd1037db90e2ad7900fd784fd9c45697e94e82c1599240d873ef9bed86377cca517619a6f91ff45a2e35a34677b4d86fa76d798bc19354eff7becee5edc594ad21ea61ad6624b561b28fab164aa3b3cdadc9f95e528d28a68113fe625bbc45ed3d77b1c66ca97aeb8a022417eeccf6150e152f8af24172bb50bc601889b015b157f4723e6bbaf94485a5c2d0f2e7043efdfc7ba46fd7184df71ffb473b72827ab799d0414d1d7a281c9da8eae1e48b455edcc0de8251278cf2b853efc4ccbebb2b1e57af75651b68a1b7a772055e0bfdd70563901b522051d1d236f36af2575cdfa1b1e1bc1b5122715d09a094463ce95922734ddf301daf45751464034ce940543978808e3fea1ed4042365735932a54d77f30e7aa1d50c70edc16edf28c2659b546b96b34cd3c678a6443f5044f24d89cdd27668b12378b9dc779610784cfc9580aae7395470a757b1ac7e46f60cb7c995a12bee76448c97647427fb60d741ccdc2030b81ee451416effe8722593c1c23aa06d175ec3283e7b38e9ad7b90c07ada1ed5780fcddeb303b7f00e9745a0e64e8b7be5d2673cf676746c33b635cf8c450a5585700c16aefb92fae7c105bd4ef3597396b4c1d81c4085a3f53a5352c60cf17b851332bef69425787fdfa83589663199e005338b06df31fd1c62239850c185d5cef9854f467568a1b177bba1ea535dc89babb0354c968ac3c6bb5e47a233d9eeb9df4d12cfb77e57c59da0939b8b762616bf6e69c34bc06116a929da3878b17b558114650272ea15946c51b9bf0339ed7f8d1e79448d0ae10e94da5f578ec28f908f1589ca51d3138ef90c54156bb91de18ac505757f4df9f653643b8fff4e000dc1dcc2a4975817a1e3a6b0f4d23d8225fdb4d36ea73c18273c858b2a60304636387e2ecf37ffa0d9ab72a7267f1d42bf82a7c7ef28b33468e3fe691df2581ef3ac0e14957a6688623070401f1b3e77c5f1ce02f3ec6c484c36e78f199416afc276a123fa94ee16d94db193974995b0cf4cffdfa2bd100e80e67eb76cd31be910771ee80cf85feee24897d633750e968929db783e2023fd89772420cc63987f901624c1cabda1dbfb6fa42f7dc405afae40193bb9a547e6fc16ea8ae6a11038162713cf8f6fbc03234851579a21ddda11373cf9c6491b0c23279361ce7e6331ae427b0385f1929dfb84e7c4900b30d24303a8f0ac3dc9f584bd5600a800b18cfacf2061a3a2782e54977923fc350bdff6ae12b001d7f4f36192e384b6a32e410c49bd5ea6e5e02353d202b2812ed50c831b68fefd9384def47d34731f5ab261818829ed8d0e48b0abd9c6e4a0d213d8ad3279d41fe0f7d0116861045a10b8117768f80c8f64a50b19ed08d2b3803adaef1a75e734d41314f1efb1ec5f7de02a8d5f428e955c33b3b603f9cf51053fdcec99b694f1b1cd6161460898e363e4890b5f507de9762bfc3ab2ab9e3fbc33fd3653f2ac3ba4e9faa53b6d38907a42ce08aaebb5acee248872738b4c30bc8507c4d0f43a82361a56209ea3fca0edcf58420b1a5469751118548aee8b6e7b44d96a2802e251e9797c7c10147e6b8f0694f69a4bdcb85df59b211feb40d1e00db144effa51e546007d67c2ad810a4baa322c321e3342f4b7d919dcf0f10577cfd3b7af4f9a02ad5dbbe34c97a3654e7d5b62c9fa15ea656aa0db23450b797a47e78a8d2e4634f33fbe8aeb8aff0b58b86646427ef524353462b11941f291000b58479cbaacb4a9b94c39f2ae80aa9a63cac05e411415f6c4e75a40f253801587316699d35e65e3099d7ec87c2fa1e4f74b6644236df3725d353fe6bf40017cc5ba604b6f354e837e99900087249ab897a358ff70b5984b3bca4f7888a9d9ab21be463bdd82c0ee344f4ccd2088bd3a7fd918360974d3c408c019b28349c28907752caa250ea2ffa982265ab2b0219a56f5678ab4551454bdeaa3282be0fa4334b1bc8d56a02e1486c4a76cdf4bef9146d27befa4b4f20d2a863cc4887adcc17ef6b469c5d65223032260a4cc824dff38d067851aee9edae969fb35beca79558583159e4ca2653362b1a4a10993238dfa17427cfa7f7708e4fb08a762ed65a4d4af24ef819fd86287a192170f6c1b5cc8c2371ed02dc8edbd57347214cd451fdb25592fc43ab57a947c416548a2dab76a372af90e486269c314945bd312af4eb909c604abfcf1478b26ca76d66fea2e8133bb1ec21566103edf658aabd7cd8f95d1b3892ca2b5500a88e234e535ad49c3226e04f291cf4ab8f20b3821282bba1b6f30f9e23ca384655c178c7099817702d98b58276d5173a3adae0c3943bf0655a81b49235c54259704bc00e90fbec18cef18d826a0ea22f7bf234cf3292dde2154f5c23c15561648e79c424521793a5704ffd9ff6a2e3370a86c74459cea061dd4d54dc6131f5a5acdca769e1d86b90b94add5193a495799e6b944591a304dbd54ce3167935fcb0c98e0f4bfe4233e527c87b75639dc1f3745d5ee072f63752d3ae62771cd0eeb21353baf6866d6b05a6357732507dcc7dd2c96f87be8cc16eefa8a0045d1c99ca2d52195c3b4c03c73acb3cfedc48b7dc233006c3ce6dabe95ba8de951fc6c8df0ee3c151b08c623aafaf959bac3a404f0d860dc4ae5f9cdaaa5f37d8fe10d0bfd884ad8bac673ab53509cac8d086ba754eac3208f5f84d07f9be64e153c7b9e42fee504c229ceefa54349ba8ccaf3c4cda431c540d725d0c47632aedb675b9ab71c74d50b8e56e6ba22a2489f0ed81319bd79e12664410d9297678d6fef4bf98f781dae4880cb141770388fff00e40bf156b41212db8444747ee6f1a9710b6de924ad072dc4519b5c4d7f55ce3446024c7c8447ac4de5c641691f22f34b5dff56043ee76a4234b923d7d905cc6bf882e5b7dedba06328be3c4ea89b71adeace0e60b9b6a2ddf0918ba473a1c81b857f68a1e852f697c5828aa84e49b83a8e152d85dbd9884216a5f70147cd9a539663ba20c4aec901255feea925a95a47a4db8933a504425f5e76057eac7da7766a859d1e0082fb7e61aa762a5c6418e4a580b77a797793f5d8847ac9881afa97bd73dda5e299273457e93315038b3fac4502fe8cbb25d88c4db1bcdb6360441767e86eddd4c5fa19fae61d8b4dd30071119eb50a7804ee0eb40d83bfb50d852eb252124c7c2065a329c4ad5b0b34dcb5a9c85de1e8befa0b53e89487b7bafdf331e25d2609835660f46b5368cc5b2823daf88df95e6943a9babde60929511a7e093a6c620325125f65dba3abc27cb1fd375db41aca4c53c5ad253bdc7ff3ded70e01495692759b433cab98dc9516da57ce065f5b0a7fb4382e4d95f1e487f66fc397dca2f479bed84affd3ad23b8a4d9b95d1672ed3e307dad686a7c4f2b7d8127800448aa905974a53fb600c8f9d4604b250926266f53110d3a7dd14eb006e6cadad93257893432c3cb5cf673f59f8aee7ffe65aa0d777c2ced38a9058c7e66e7840f659131cb555724bc0805c7742c08641a50cfdcc9d33a7407fc4747ae508772d05c6263b0f5222ee7b0104b432a6a33ad78de4ef1db5af01c2edd1897cc6fd54602fd47199970991a52047977f41da234db1aad29cd0f7fb2c991b17730cbd400adbd42a10786ec8bdec0c00b1c1b4f6a38c29b82833d4b8014b8541964a06627474774cf640422cc8e41b94b95393268a723f701d7be57f05231974d9b0b7137a172491b5a23f58d9b1a4a4dc56480b45a0d0f0a74c61cfcab0d193af590fb1338d50eed797037ed7d5a0bffd34c2fd7c30badce1457b9ea25b3990a85c83b9011522bdde51322f38bd0205ea16dae785aafbb376554cdd63124282434297d9ba74c881277d84f57fa44109da0ba6b26c88f40f184da5b4a8149edb92366e63ccd33d34bf976804e0d9ce9f44df900d9157d87acc18be0d0bfb2841d62b40c66c448c12460664fd29e28f754675d710097dd92a40861254beeef35eac016d7a6456bfdf3e80b7adc39a31927083830a416d6a6ec5f2e6ffbed88f28a7ef631747bdf14f42e481f2c7335a775ca1658120f1e4ab13bba58aace23cdfd00f751f4806f0020455ac40a753447a5d60db835fe823bfda1e4cf3b13751e7888e9524a73faec52b3cf6035531f1ddd7b3363456e19a0f080b8b6ed148a6e8029eabaf99b0eb0957d4759ba367decef649afec22185fa3f3df6cae961fb39451b5e926e7444288c4655271897bacbae46193fd9f6057923f03941febe166ca96e7ef9f3078602adf06e05ea20a831fefdbcbb0041a3cf414b2566e16aa3752cdbe82182c0911becc717dd45594aff57173eb9c943ab2d7304a5c1db09a4e549bbb80154722d76dfad713e246257858a0553d6cfb1f9d3cf6cd5999aa3a588e587a40e834cdf2a63a918e55dd60f1103bdfce7374bd77f91ef2911dcee4cb9b22554f5b0f8abb5c78aa502e6c3fcefc1a768fdb776ac0e3d9e32389150dd20218e880120a7a70703612ac325a2af8194ed3a6040abf43d3e9ddbc8c4e00bc69db69f950f8b43f65eb4cb4417f1310ba466cf707384ad6c146e9b246b7d0444572cda47c4f2fc987bdc2922ddf7496269f61bf07c451f3ef308e11fa7a96a4fe6a837f11d7c798a1ea5b0d588e8bc4ff1d8a634ed17cc832ef62c07af49cdcd6c3e76ef9f6003220b1d02189b62fad5a0924c87beb715436cf9ae413ef24277d83a1b74bd4ae42243cab8c5c28a3c3a2d6da77efd0bf6bf057a1c651103529b9e2ac4503a06d3716af69866a47f8a3d311012ee00fe71641882de9a67362e2385b7e5315ba78c029634080d2237cc6e4607a07f2bc18cc7b363a2c9e1eea11551d805dd9be2ee0feb81b4d10f70c419a74de47a8b11e902d7fac0244b69ff7a57b2cb0b13ed9bddc1ad63edfd1417de2c0d8eda3605475dea523b166d11fa70043d5632858c38ff6c31539939f3ed64c6798c1dc7835d43a65b5f50ed6ae22b914829a37893e37bcebd990bc9376e3187583d2b2850f198137cabe04b5fde2b53da349a6585e706c134500ac4092dfa462d9225ca0512706d2f304f49be1ced8686c2ef78456086e537e9507ecfdfc10096891d9e2e8e1673ec5ff1fef9df4d0f0a9d8e8d969324c4585fda7544dc7a2d7549dfaf08b441c83786bcca22d9fa6ab5e9585f1ab191185e9f243653f3693b7d92f4f97890b5e90cb62599baf1947840235bdabeb0532e22f1a15ff3d35e5c93ee356d6d6d7ebad180b2d8c0aa63c70f48d59f2d06bfc58aeba6b659f5d7dfbd0c969535b4b07bad41c476e1c7e59b8d2ada134d0f9f5314b7322863d44bdd732be234e0cf1f1d94968c1578cda0bf3fe98b19de7be32228d82d5f8d24229b94c5de6bb9836bb43dfb581300d611f65bfad483609e148ee7f1e85c557151cde2417f81c772508156a8d9da7c7e747eb40cf048e315a06b740e4c5d8a849457388a6ef16bd95540670948a07ab0a86b1f0ce47bd59f498fcd7294e6a0d733ae36051e97eeba947e21977b849fc8067e7ab877457dbe08f1702a7c287af6ddbd53cba3d981884f5fbf955eedb6b1f048b402da007c93be882fdeedc1b4ace40e67fb64a5d996b0ca053a6f664a6670e93fe20be75c2dae8006e7988d98e327be7fa6a993d4fb9ff7fb3c41dc408399f4fb4ba147c21d73a470449dd63816eed3f4cc4bf6c387f441d24763cd3ef8beaf06776f05e2a5db3babc835318651063557a7d35a55e9ae18467cc66c15838c3f75fd31b603766397f404acc7f1198cafc43dd3efd72671abf1951e2f1b4a95bd1eaa682f55d07802446b7390a1f2f5542136ffddb30dceb8ff7068a43f32b43b6dba92b56cf65f6fd30e6924f0699b51d53b8beaaeead416225f7a08e0464ee625319ed82f3a97110ef356808c430e6ccaac076d13cef4486fe7d647395b6d5141c029e9e58b92d7c42ecf69ac59dc42b1702a61632ced1991952344226244fa778ed9e36f2e5b04673d20661cda1e5411262e8ef96bb0b73a58c1c372c1e63130fea07542adf806ea5c624853aa32af1db2adfd1ef2763f204cf791e25195a5910e5d7d063145cc4ff92d469b9667e19339832c9e6478af6a256428ed1224e7b2f4b3131adf86d045d315ddad7f02940635c04fe97ab6351bf556ca6c96c42027ccb9b3afbd4c4fe8545b5a752310674c2c850bfdfed2b3dcb1079ab1856cb2428af688be51f3e0b58124f87db9a8879e63986a16a731b8e49427d4fcd18957a564f69163de3f8607e22b852c2a6afb9a92f30324a03f5077d708a3452303160bb1d281e669a50634c3aa9fcc3861c19cca7afe76a5505124ddf2a8a0d588e5a5cadf58ebfc3e4875faefd0b57243bf63e1dfd4d9d9add97eac7e0543d0f0cdb9436bc1d9385613df99bab484c72a44763a36c8181eaaa0fd8cb4203db24654d85509803c07b4c8f5ed12a29d679e9ff510f481ae373fb9614c2302e219075f398df767621855294c41377c5dc033d7ea62e6ebe21415d07a95d47143a5e1dcff51acb6d030e6a9ebba1125d05e3456140f7893c50a531397e3f485b69cc9fdd19b755ff27bfff6c28b41105e827b88d2b18a3484f9854f8ecb4b7e64fd82190df5045b74711aa23f13a9f290cb506b60db84a51a841144df5bcf1b3b2ba68b84833cbc1ba9c58634fb81a696a2791d9acd22f230083c97e40444a089ff7fd171c78283caeae30f1253a98c8d1e4bbe77397f9ef6656a50116c5bae0ebaa913cb1e5da84d80e5f11c83371bcb5423a204ec595e57ed306d3d464b2a47437fd2c7b248bd6bc822fd1d701c950ad1cf62c1ffb879961ada24e764652e0cf4945a3da183f1faf472a249211b1e5223fb4f447d5a8d59bbbedaeced9405327b2468db778a155647214a8634709832d5b8006237bcd5d8e759fb801b3902687ba9f8a28608ab8efa64e47c2967bfa0a1fcb7c74adf896997e22514188007bd19177bccea681867ef8cfe6c04549c4cf3e45059190e14bb2185fade8b9a764431e4059046922d1d2e6e28dc19a16cfcbd11993dfdb7ecfcdc6705dd5790b2c94499c0746f80c4463d0a032938ef27f3dec7ebc69ad008eba11a8561cf76f474ec6bbe25ab3ab52bfbe06b9f5e9c77980a49f9292a8def2172f6cdbb92985b40f478b4ba716265a5a21a1369dfecc79554a9a6ffb4e2f9b215224993945ebdb92258a46609ce260ec3a5fa75d73a81cbbd92ecf25e30227c79326356389ff402e752ce001e60054e5629ec41f1a9d335c83d53255037dce7b65d590ec581cfe7a7cf4e2b8041fa1a8f7823bdc59f3ea8fe8729ddee0ce4393193ba6effdd798669a94a5ff3004791735f28b061a104665646f73fb1bd67dabe6aecafd30d9746b750369a7180e7b0770564160639cfd86e3eae137e2d3003e2e9d8582b2bbeadc70b11aab027cb293078b32975fedbee3c93518896d034bb79f7ef82458be22d2749065840edb516dec81ec7e4b63c357530d114c5fb92ee1862fa485f9d1313713351a6be0aae6b406a02416580594126dcbc3d3ce378daa9c5131ccf0e951a83e31916d47023c51ebc0141d2536fae077f5ff173d869e88cacbc12b7c23fc173731eddffce07e905befcadce06df68ab08a2a5a88d22bbbf846db6860f4352e6ed6d014b420f62d1069f3d356c239a3829f59b26f0c38405df02cc88a056d9ea7ba4531b16de7de5c46e8d1ccc2a7f4e9abd2d23f613a0afe7c284e091304ce1a3e5d02662bb8b8910dddceba4b7d4e7553521cd35e9557f0122f34af928fd6813e86b18a450437543e2011cb114b977c162390adca1b8a413ca99263c21179c4a5f2a81f8b0a16c6411fd2423fe56bbf38a1c6b2696475f7bfa5200c4e6f334323a349c7e441d9c60575e1ae033fb66b63c315b82f841b3afe668e9651f9eab90e03187dbac9dc0cf2b18b059742bfd00e965e28d5aaf429d6c68ac6f8ffc87466306aa6fd3b50463d3b5177d3d828de42d7cbb7b04a21890b5c5b6e00bfdbce343cb5ee8a8527a5229ba7633619763a247ba800fbdcb03074a81f3339ca1e9b7fcddb7adcc2952e836493a04bb2757fceb0653a3151c41fa98bdd26f61e680118a03023ba8558b1bb5e10781e0c1cb5688cc79c22e0f200ebc95c5ba39253ea33b3b3211d3ce721226cd7d10bb26f1dc3562f19dfc7099a8456bfbdf4936b878b6973a1d4b78d9f558ca00fcc6a4c6efff37337f727187ee527575131557c2772b1b44eaa87fe9d98eca2e46cc42e5c978353c8a70cd7244faa2c54698ceffbee6ee2596ba2c61f5ec0f445fa8bb8f48b889db13c9b46f91a2a981db17591dc71978fe9f7862e971cbca23ea00bf4c1d756c28b33313462968d7ca7f77ce7ff210b860459f075ade6ac3d54249071b4901303783f78694598a8c7343118ea8a64ee5c4f5dc9989c3811e34775abb1e9196181d343bc009bf4e5a1ba749a35ab2cb4962bd2f97cb57a4b372de2052b595e8a1d8dcef77d4669811cc7c292a7e50567b5f9082093022b8cdf6b3d67086952421f46cecd2c6996e07ae62b7058bcb1f0f877da36026c5150636ab4b6b4756e405b423a7d1a99b7f724886410c6b770b91f8b59ad5d909ebd56311c2a3c59c496f6979d17ace26df79cf5d920ceccc4755c924ce90823520999050c7c8aea6c50ea5a3241b56258490a9126d92317eb686267bfdb8089832fb66fa7101b61eecd2dae46bd8e78b6f699cb8c4f386f2dd5b30a530a14944b125a5acc5265618b6910ca2ed1f45e04e5e2a525a00beb445bc8b555ce14168951a2946f9f26dde8c6ea46ccc140b56149a7201499be86378ee8b966690c2834ef5fa7f1ed1192734ddcb72d9f05e45557dae8188d70944d8f3a24550e9a5516419444459ea997f384044148c3e0797b0b0a5d69599c45e6bc07058eba57c62bf782819c85137471c34fe10a69b73a9327c870b17ac514ce51baf5a5380bc9930df68a3ed8294a40bdc9395f3a82c4adb25f3993bbb4c4fecf6028075fdcd88547e12b7cd4f400b7fcb33deffb38028f7ed4074b2852c2a275a464cc6fe7a68677abd35ae5c966ae1b24fce8ff492f4e68d44c9afb454a46e5a50f3c12165cec042b96f9b53b80c7691960c8a1d81e225153f8c016f229bcac19e892f4bfd04667e26f8270977504472e8c21a121de0710d2f7f9954b1bc5b8f623805a1352ed0d4494e31e04269e0d39c4eaea6d236f252871e3bf360184c97eaad162e5dcf155a38a118fe8c24d444243377066a5606254fdbb4799dcb241b4e57a83d11f297480dd7ef789125481e3a7152acc4e273c577fb19323d2755193ed49e9763a5dee540b72af5885342912fb6559f0082550b3a920547cc39ab0f18ef01b760b8a08166bf766dbdc0a2d1951d38d2074b7fb60936cf60070c220c379a4c5a6aca7d0ab113403d661539e392ae05c74c62f319b6ba4f51421dd96cae9427964cef360f26e9ddadf95d48bd5f85ae4c3b64298da685998b45deb6aa2c09ffa0d7aa6dfb9f0230000e0cbcca987f339c114fa4e3a2360ecf2e2c5909b8f56f4e7b3c653b46d43cb441f5e2c889252a2ea9fd5b0feb8dc052cdc1191c4550df7cd1a3d9fcbafd092f6be150e1dc8fb178b67677cf0ccb695d945cf9addf2e1e9f0e1d26868b932eceea145a6afac26d37b80ef965376e7849bcedbde6186f7b514b1f89e7eb9f5161474d0724cd4c3261a6f588821fa6cfad3ee5e593d248dfe89673a19f334c2d74afa724ee24d79882868aafccb76d873aa2c1eb8f83760518829536db85109a1910cda4e03fb5253a4db1720bd4c45a7f2d5d1803d01f5744ecff15d669d11e75122facefc8f28b6e38823acdd417144ddb66c5aa7b27fdb302b2b2a0b28cdc70011421e519a0c836a5a639e993b2482ea7df5c0996def413b13701684950ec47476fcd93b42e35b47bcc34011f54929ec2b3baec7085c80b6e3a37b2c61e0b55b635133e88fbb7b73112efc2e8ea8838256606ca910fb64f3a191dc0c8586d2068e9e293a78bc867b7b5abbdee22a70e666d9f83f2a85495f4d3d914fd9dfbb8f3dcd461dcbeec959ea574c3cf9901edc1def2a02daf0a80d99ab0dfd9b54e9b5d70b159baef2d443fd85777ef5b04b23324ea986d41c6b95e1e72f46c1e8c5b8d879ea27acee7ae7edef02c2773bbbb71a2f8ee59789a94d7643e054f460f05c07038b394db6adf6a1484bdd51b1799bfd4b625d055b944cc2045dbf1b5f4bd5b509a78027d3379360150820aef2ab5d140c7bc4f21df99d328a33e7e2ca487751f63cf6536ca347cefc6154eb82b4b3eee79e8e4aa739a6c5132cfa081d3bf42091be7cc80481c75301d0e18ea0d50af29d707c606beacac7b7119216704537c8301eb526cabc77ff23f42db5e7bcd4e58b573a554477abfbc3ef652be194a56487e7fc2a973b47ca70e966aa04b96fcd53d1b58589c001de10d1db6bee9928f80e3fb8fbb2b6d125c69ac3135277cdc856f48ddc57c5d658a30fe069c20631caec9897031f4788c29073e89621717e7e80e196f81e675019e754100754222c311104a5c0dbb7c9f075885f1b438f4cc0941bbf9b85315f9601863b5aa960927c4ad7f6427281eaf39bb7b89dac7d95992df14fdbfe2916a706290c6497a7018393cc4422f502ade73f9172094e1f696a8b9d463a1579dbd6b2d78b55ba1c1a25081d97397e85647b73fc9bf250e421a765545b73c649719745519a8e5259291a94c7a40e0e24245dc016424f07630e68fe97cb24d0e3c45827c4a65ce41b76428570a7f1d0618124681b9a8d5617a78fe23b9014522030d951a94e0225b861e95317f7de6c66dd026bd94e75bb587bce654cef6f45c9b9d80d37168025d469da924bb7e5d908672053a6e076","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
