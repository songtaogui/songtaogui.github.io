<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb9c5cf1e029e52d95bbb6eee6af8991b33f6f0c0623b17f07ad0c0cf0e16b8a681a4bea548fad232c0cd5ab0bd54334ebbdcb96ba3b3444a8a895d665c9db809de937ac35ef556960128165828c7cbbbf94e378fa93cf30a1e4d50b6a9a7caad04b662b116996fca20f778e0eebf215ed51dd8804860e51a48f5364940dd39a2db4c73e61cf8ad54f7a5ca592bc85c42728ba1ee7d1f6ccbcd2a61fbadb409a3c16ca172c5402381d51e3db0b3d8e08ce3aa412489772756e4dec9254a5ef64d05bb161028aec694998f88133e01f4c8f08143a836a211e4d8ef95d648ea6bb0d83d984ecaeb98f520f5855ae6576d5f7570c367d5d82ba3b52066dde4569fdb147e1bb752beee9e4a8c31e4b2939e2d6c117fb123dd456f981141b030fb0950e61a81f32640fb2532ca1936bcc027221187bab1e6533298fb0dcd151b0e25856cf975d5a790a70a0d84b5c001ec744b0cb11b62560d047f4762dd0c430ffe2e703c9e647f3b9acfcf01b0666a02d6c9d1ac591336c008e37570e1d716e259f23a29a352dda60a87cd4b6bc2e8f3a6e1a4947217cc99eb2b01ae2886de582948579440caa84fde78f43be057c4b13391251dc47a2b630d0b669336fe4a2dff8214f6ebeb7c42dba476c737192ec4fee6b8c13250d82e79e1e2bcdf7fbeb8c4978a291871e041d13a13fc305262b487a1795fc742a204c33dc427a4a3f72799125a9dd1609bec6fc7e2617732734e5140fc1dfe34bdb3eaf8401bdf702cbcae971ad9882836e66d55d012fa6598298fa8c86f909fb66f632c6013a740b632d1303bdb2081c054a31c00bac9042ff69e0d80d4234b284f551ffdc8e9ab418cb5532592c4c9b84d7688f2e8db55e0d1d3bc8dbac8c65a74f7e015deb2679024a7737f022b7eb1e4bd01ec5c7f032c410e7d18e2b12cb8a91d9883468bce37295d271b31d7da675aa7c8d27fa36b67b8ae4182118490fecab9c56ba46529489dc4b03774a32cad665d808856406ed9e5782cc77de65fb7eb4a4bd101af17ca3e8f7c73ee652d9915c6f4e92eae32d9717c9a4f6cef6c73a6567eca677744f2bd19f8fd122d061505364ccf8ca990bb45c7d9c844f800886b806ec8128358ac7ed222c2d01646aa435f4aaf6473a35dc69f5cb40b73d5ee4ff62a972892ec9bf1e0f5d5b7bde3ee10ffd0c3663aa80e6a289251c9a0daa6f15f62b37daa06b8cf6f81897d16738a5273b756892f62767c84629f03977fade5f2e1f2b5058047111fdd7bb90978212bd61d3d20662b66670d049758beb562a19c4f6fee22e1c7bfced5f0f4ec32ae379bdb12bfc312d8dcfb7d41be9aa00cad1c273be6056aa70762b5559680e286c536391f7d58f80d1eea436647c8732c07707d3f9a3f40b0619103c6a66d945aee59e6ed1b66c7544f774eb91ca5d72c782fc53c05dd82b5d7dd52455106c04d548bb0a3c29706fea7439e952c99d5aedeae29e1938b87715577fa662af06f47ce167efc1bcad1ed36e2fd2b43cf27f5886e6b9becd193c4d5329551c9a4a24780403384007595108ce174f542b1bcd5fdab7369212d5a801819eb9a91802d2e9f9264a4c582082eb639d9ab2368ed1ba24faee4bdcce8b912cafa919d09b8ed831e1e56fafe3dde3e6f3d26b7ab2b66d0d332e37aefb7c6c4ee45f03c1e51ae9f44ed44ee2c08d4a67b16618e016639db2fa1a18f180237a3e998633dbe760bb4105a303a3653d7ea2eab989c6d1804ba21bcd6861bc7eb550e68f93d4c06e3c6dbc2c6623abd7e5a28a7fd4d6e9c95845bb6cbe3b82507db71e48f8ce172a6da0ea0c15357d7b8530b391a522f0a9d3a6f500a9dbe418ec1f64f9d5a81ed0d278d62c33ddf4a7a758791e95586ea019fa43f2d885e7ca30efad8ec8c644a6cdcd3c6def0411e5feb0581761ae5d87b9805e740a2d88234f2a9a7c27c5be887ab9cf31381b310d49a7ab05f166f29e2f9dfd7ef034faa271365f9e63c42ced5b3e406f109f6e2b36690e1492d0780bb6a22f166d7e204ac67fb36bc4a12ac5bdaaa73baaaa1b03e0ba0184be256b14643ffe7ecf27e1520e93cf982db4f65a363845b7cb0026f2d77ccb86a6561b8e43ba643ed0153914da255e4d5e84acce615043dcd0d6b0274e955abfe1ded19002a6208492f413c5fb0162e4b00b92297418af7593c9dc5f5b65b39ba2096c511275cc52421eb5ce0c9b88fb3e523b74e36690fd63abef096c8c7e92151b49e3c572d7d78c88644c406dae82d2c8d353667a33bfd6fb42dc379b27c5688e7cf6d2006c398178af60d5921c96d4329dfda361c793e7dcf2775952d64cf2e38e5d300f0965b3219d2f51a4bc2e326cb1dee4176bc203d49616c4032a0cc325507c96743090ca7a33192cb41c22f698d6d226b72183f71591f57fdfe2a0806d6d3d2fad1278bfa17f63a7ce738f9cee2304e0a799326e38b764a356d208eaf83632f77cf54896fc54585d1a1def1b23fcd0a4dd04b1b8e1c4fb0429d7c40e1ef01dfb41fc5120648097e8ca011b4436e76285cad2dff96caa51e73ba6323c6eb61972e35a3db625adfcf3021e4bca1c56bb28534ce456da06e986f498e4ee9c35de0ae0652032207512cc547c50d4a56322538e4c7beb8053c406809703afd393ef41b0ad9a5d8149402177b6d5af9aab74418f7fcdb296b8fd5ca589fd89693a7e8688db60d829546de5c9ff947f10c8ab957eceaa0c94c4fd354d3832b6736f4f7c7e182e812da37d254f6cfd0639d015a99973c22bc28828632bd9014d8000223c92c21b832fb98f019c2f71562809a5d54b2e30714e33b66d91d3861040ec2fd5046b9cb0b3aac2c0ca8499841b189c35072b22f2d11520adf662d5dc3031fc45199a2384ca84babd067b0502e782dfd9926731414c693aa4cd834f457086e1390487fa1308ac8586c8160b52d2cb68869221a582b9099d8691a130c19eaf47bd71a81335c36be2c6c2ca6b4ed014d8101d6ac77b1285bfa98e7432ed3d06eafdefb1e87c282a050249f2db91ecf0b5a216127631847f686cd08c1bdb29b1741e39218a0882e5c86d6ce3a44685b45d50cfd133ca230c9137be95a016e8c78d65d4e67b34d8cf120d00567cced290aed82473259f2d4434dc6db5ecf6a1f76c0c6f2b4d069d9cae661015d6a860e90ff80138ac5c854aff17da4f78a5a207a478ebfbe7387ac3236acb326bd37fc6601a1a6cb9a47f3ae2c04b4e4bf58397e610d0c715500e85606a89dc4e2854fc55d64fe45a23ad0f5e3d1d80e65ea1f22be9c01b69e105fc8def8dc73cea905f4b549798a1a72acfadef6eefd4d2eefbd100ed81fe73394606ab2da8d48b35eb66505d440f29cbf4a3ebaf822d1ff24863f41b794022ad37aca6cb1c6e5c1ec0a9610fa4b5513d5ddac74985ab572e5ae921f9a97f5a2b496ed060b37c5988168e5c783c3ca10864eee57d125fc3c4bf01a2e2383cfb26fe64ebbc975ce56f410cf16093406c573e12fb6323d44066622e57ccf2bd9c4d6b00f342acc7e1c10a5d99c0f82141e597ada40b4b49e74237cf66343ba14f91d6c6d8992f85a7613bfd79824ccba2c50f43e73b10078bec534523b4bd6258e6e8f8fa7f1148f9a8e9f1f72c59cbf6d297b5af07ed7823488fc1b24cfa590c476871d07ff24ecd8f4fb6e16d203e450d6ed309cf849acf3c730f295e037cf7d0be2a01aa43a2ce65376f527440cef4576aee8fbf847853467226f826715ba1140264b589a4fdaae92e7ca28e1cbd06e0d1430dbba80b2dffe4e02d248d2df091d85a0940738d780ca8440d78eb3a6d1aa307c2f128eae0e8cd939d1779b3de9f22ade819bbadf252cb5bc3a3ff271ef07bfefa54ca3cf78f03968839151bf46ad6d0a5368de9532f5c1525b057b812e48799245bd0444938ab35054f0743e409e7ea23ac307ee4a03fdb8c8cc9ced4268b59f1b868774f77d4385aff147c9a8ae002416c5de616eda252bbbdbfb732b3edd1640d67fa0f21463cb66e533172129172401ec9b25ef2cbff1194166025ef7ec8112d7b6da455e4e786c1334c96732463861185e33da77c71de079dca1403f289df1a649d7c26e515af1699bff76b45e0aa7a7f255bfe5dc514ae23c2bed14b69a53c79c364c7b59d0e934787bb5b58822c736cc799219a2257855095253fbf0811b46ba490fb719c96b065268ce83133973ea5f82e732fb118c8013f5941fe22d4e67c1f31f1fd1e9b2cbf0a6770d205fe8219526c9729c95fcba7bd244adf4e59abd983ccd21ace176ea32945e569a3442f821584d5a18fe85f22a9e0e6a8ccdc868f12c40f7986637b69fd505306a688d12478c4f01826cf1a572b8b87cc2b017e14b34e398d4dccbfe7a975a6987e2daaa0fb90db94d710b0988716303f2a630985e961801885234023a8d4d3ca91ec5acf0e37dec5920c546de138ea4be310fbb42c1b9c83941c16063b62244db7bb11e3f6c7d3ba73e9b2ee0b1dcea7fa7f02bf8fc948d221fb1119ebdf02e85eaae91ff0f91fd57d927dc048acd0f39525416afd84f5987faa5d685ecf8ac9c3ca171d4d379678742ad9688920bb3a477ce3404499da9ceb594364774fb44dbb7ec8d7ceacbe3f9b49532b48dfb2efb58da038801e638df7f326a569358243dd16b9f901997ded62d6a511eef2291b2f3e1daf4cc65e96993159de3c3ae024edd4d14416630f30bd5ac552c25c601bfaa40938c5d1b1a2e78ac284377e4f8f99b689d26ac74a6125c8da10b46af33e720b809e41637eb4dce59022fec1eb842bb47e310b9416ceb06ed1595f98d76db8acfce9c56fbabf652147785241bc4c35985354ca32355be679cbc3dde36f5ebccfbe11a1a405631537c091d032767aab20079cb0f5f21b4b3fa3748894c1787254258719083e02199d38bcd4b3ce27fa29a16bfc46f78a4a95ae567e146e2d7a6d21a36c2116a0ee2d6f2af9f46915b25a8736bfcb74d3facdf64afa1e5f294ab891a51e584cf3db3ba68988f244e9d23a57825277fe784bbef9be26236b6f7a66d34e5ccc269efecb4fcf8c75db6af6df8bce239829f7feabe644c33a8ff792540cb2a747889195f2fb74dbf73e7e06125d6774ec540892205289cd1d7c92fd94f067f37a8478e330e5f230688d79ae9077751a123e5642782a6debf807b6f260dd274b6ccdc5894dbce34200deef42bb469ae138e381ff53c9f8443922524f5daedf6b288da0702a6dda261e80514c41f70e4c1585a3471774f71115bb8a93a9923cea9dfa808e675c7393cc750753948a634539e760b9a78bfc426d52514d10a14c3eacd2afde07d2200b7a9cf98f57482ec5cce782acc3103aa18c9a74535eea13f869cf0f4f5fa4ec15c1d430d59f6c090fa9396d738a7e228bb165bc0ffab48d6e56d34de7237140c834691ed263417825ef502f1fc7824295f3fe876471374be3a211b797db6359b9eabe79659546b9e063339c80047da1f3abcbbf0893944b51bbcbb98d96099cee945d02cc4d9fad154d0afc08d21d108bbdbde087d0f430944a09a8c7b707e3c99605c3628e56106dc674828b260300f80925f4c8b679f0806dc2df85eb22f3b1c12c502d51395ed8d7d96bdc613777952450d9d60f4de1850fc6f1d5db0bd41cd9b07e85f66cf1c70815c74931652b88a84525e01cbd86aad64249654e5f4c25da58ce98435b058523f2e97242501b75d89329c707fb36b86f6ddb68642a71424a0a52b94cac8f758561ce24fe58eb6830085c7da875faab69c18c1c1c6e133d0a7aaefb0d4a0e89c0d03cd703510f862f4a21dc3834bfbfe10336029ee9163301c7da23654e361ce3ac36e86f1c47c96fa0e3c93e67f14b7420d362c992a8031193d214f59f3ca6649590446f126a9eff08457c5c2dce59dcae35f81624edaa07b0ae85beb891dfa0cefab6a3089a4e2c3b9701a2025f09291979a01e90e698afdf0c36d11c688f1c1258d7808b57faedc34577538c03396bf868950ec68fa87d420ab764b99271739a957c11f8d7c85ae15ef555bde660cf150b75d80a20a3178141b11541dfa8837f70ade58d77601eb017f54d787ab4d2e8c2559d198a627637aa9ae8f73e0b83bf9649cd4e422c74cc9c5d1c79440707411e111e2888e70993d79a593b63ca57af9738dfd8588da41990cf832372464fa268bd6559bab8b6a064b788968fa849f5f8ad6a38758b2f8ab44dcca0b96516aefcddcf234bdd1c0491df6d8e81fb78bc0378c6055bf5d20215f047445626d3b4b7eccfda94f68a975f926d8743c72710ddbbfc27ac5b0465d56b87b70f56a709122392ddec50dda756f789556a75fcd291c56639700b4ffa7420537be47d795e0170b8922281ab17c527caa1aa3d589d541844cda013b7f92b4e9f1ef08ab71cceabae9cb428f4c5663900f4a7fe4efb99daccef28cfb557aacddda38e1e9e57fa0378dbae52d7a5c9f80e3d0492295323ded828adc5d5c074807dc3f8505bd1d5d5aff6a6304f24faf7d67ef5c19ceef254fd28521db8f752b014e7889828d2021a032dc523e8285edd5dfcf314cacaf6a30e6a74b4c99a4f947423efd0ed5fa9c23916251c77dd0938c9ddfa8e3e3422c33b3ca75421bcfbeda5e8607153a8f4e23d7b29b9de17ac83c64b28028d82ad3937763b1af5bef39f32b8a692700a9a6427cf67bdedd4555573fb3cd5aafea41632e3c4a3ee216400f32e74e1af3557e3573031b7cf8e4e45adc5222a53126a726f4eb748fe9da74f526456a067fbce0f09018fec7a2368df3cef24d6318b95f2fe76bab94984df2982910188ff585c9e9feab0c103ed09d1d8ba05aff1e68a9db87f8bef7acdbae38a8481a79fd48949cd356c580badfd7c033d7890dd200663e8e1b4dd10e5eb02500fb855ac6010bc94dbeff1215cc9b62302cd280fdb61836e3f95f2ce3275e21d9cb1ecd33b982b69c068f50f8e07fcc42e4024ad971dcf2df87516cc792716a8f3625ae4df80a7ec579a1775c9bceb8e152c61324a3146c4e63764da9e173eea6fec9915b693c4662084e6db67a51bae3fa1a063b9173d33de1ca0c0983ab06446446c6124d635fbfb6eecc69d226d2bf96aa4dac230d00c5e873df7c2e9eee5f2d236316da16d9be3e820a5aecd86254dd617188d092133a9164f2eb6d75cfae89266e0dd5243f3e28cea7a70dd37e6305adac9a58dfa69a0a933d8c469327a2ae6e5a32a641d4b78845c252780dda7ca0514e848eaf3aa1d9d874cdbedd4b97272425cfa8007b6e44d557516f17e1e43e83018dc718e0615b567d2c1ab2df9555e3f60882f2deddace3b478adca77d834ce3016710bfa0fcc6eda5906a74e024e8640d214dad1cf648070b89b022bf54aeaf48211e275a4befb176de29831cbf688541c826f3cd5258e38e97462eb54eade54fd34aaa005bfb8975f7ce330c5dded6ff7ab93f1b072e3d8ffffff0c89027219216173c52546440680ad94dda365f730af8d77aedd8fcb5297065ec1ad8ab433b689fb9b9c21df07466807c52c14738e139fb41a85a34ced5ebcfa4c2ebed8641be4eaef92a593029145702a220d19245885f809f61836b798d5b3d8ccdfe3d19baea8f7258bcf2b6eb0945f8fbc4d6604953f242fcd99c625d173137f38bb48da4603cafc02d6a80da790c92aa55eef473bb3c085718b617af06f2710c2c656bd8c4e500488295c71825f3dcbf933a4548f4fc412d4fa35c7cc983848538d6c43a52a2b7405de3432eabf8a97b19f2113ce9433bd3b4ab64cc4f2e080f3f0b1ad7aca3ac4f378984e09ef8f5b56d5222dc8056db7a96c8f426e5a32391ced365a9b24106909f59a4ee539755bd30f421e89be96726098d0a015b17297a4f21992d398388526bde4b287b6048b6a40e61107782dead5c63ba5c78811afa75a7e08823989d8ba0e2944e6ccc8289f63b86f4c01856f9b46134ddcac999bd71e1c9679b6024813c54bf3b6d84050f544ff4164dc0c88105fa793c392d5841979e74b7546c625968dd0381a075f5297c477542bae5adfc35b3cdc81fd5f5381bf58930266199f5c63b7ed695a4b144e658fe8ae02c968c8de604f0d64422e482a1af8ad55d4a4a5990c0a938624f9996d5556282770b2b901061306792bfe7ca53c8f96d69da8c725dda5fe6ccf3b5100871751547ebf99abf29697c66d87e41354b20cb978133ad63cc62dfe02df02874f139d0c05ec039cf4c2cdccf6a991e9d5a7eb9bb303712f0d1c9034ed2d043e4ab8d7f6da8e9de641750a02d75d80dea89415f57042b4c4cd3a6af9a6c2c51e0f157aa46d613ec61f7d9752d19130b512e52213acee9ea03072f05083e4fdc6dfb6d6c33caa7845240611e78eee19c21be2d482e40741bda7370eb8be329f89027c091e969280ccb6d4630810c89078a38f6880f6c84ab2275e028f0d454fc169c7a9c98526a031acda000150b1a0c22a1516478597831d04270c9703a2475c5435a10de1b573bf33bf5f6dd90c21a5aab51c1d7517aea8264a0bf2ec1c6522a3740265bda33904cb256cb31c6f0b640a6300b2f2fe4c0edd067c65e38ee9c61ad2442c6e27bd418c5f613967af1befeb839cba39e21eae40a61cabfe4e3f605ab88436affa04b8e507dd1d3977042639a641322bd41043d223fe6e89f851514586369b00aeb8d634f17ccbad26da6270e6d8cdf709198d1f614d2e1e3c61a1219f6c730e7f8b96dd00d5cfd8b9cb324ad9663ef7ec28102c8c86ccd45cabcaab99cb6f0b7d1e198b40e6c827af4dd9f7859e2dc94d5499d459cf2b90e2c5c8b83f09a553535a2b43bc30a8b1b14755d54c0cf9b8a40492be036a4eb8683655e9ba4b1e8c9e5c412d1deb91678019f197345355991c118d7af62d59a8c97169169155646bc6fd2177ff3e9b1e6fa8c5f5fb46522a48a8fd70e44c36bab24076c6a55bf3ea5d7576750d70f6df132c3d8cb16bba45a5bd8e2f28a3a883069bdf1100c1b7a49fffb1362565a1afb037f683ae820853b26558d33a943ead2391d24ed5486ad3fe8f1fd07b85ffa64203059c300254a8fb8fa00429981a94589aa8e71a0cc440f4ee9e4a91c64386a276f3467572f4942625471208b6736d7513584a660aaf3bc63f205f1ba61bb8afcce0d7cfbeba07b22123f38f466f7f10967741634ae4d13c8e55e40b0944feac3a7f2aa28d2d4a8f0b346e668ac89cb1c23665b0b949f034ebc14fcda699f2cfe5732f992dcec57eaf00fbfcea259ec5aae293f12f00ac0774036f9b5e7d16afe98cf4f7f90d93baec396ea75e6769537198570b326bf5f89e14e67cfd0deee4029b5ca153bc0093f89cb07d82645acd0dc8839d3afa811a48baa02920a4141f81cf1d179b95f725ce1f9f689d7350b297ccce00d631e738865ba56b73651f45d15244951f5191dcd9821b2a186b2957bb6dc2bc24ebb4f9d491cfaf63f740d5886b804b0dd6c88cad39036f061ab019b36e6b32fc7e257d3e373961f35f5a19e0db7d8275637c49acffb7a945d56b93e3af8a144ee0460030ed1bc6c355fc871825ad2b9255cae47d674c4842fe9cb9a2f0e281dbb7e612719438660f081039baa6d0b438a3941b0f70437d037a05d91cf9beb0c32ad1663a5d3be476cbcc5e448963291fbfca2a4f1d0619d76a93dd47ab68024ae9b1e6ce08dc14475049d872bfc593d9d32c8edb59f609b6372673ee53093d3f51c019de831cdad2f42a70de91944b58d3d0e20d0fece46273facb364a5c72e9d0969f7d088b5b73d01a3eab3f8fd0c8e346434ff886ea3d8681b07d292b2e348ae3ca6c9c514087bfea9280c82e0fafe530533be13550e4d8bb35feb0521888ec96fa95781e7e3a5949e017bcb472432aaa4976349ba40a488164dd975a73160bf784f4def546daca20a32632bbcd966d01afaf75cdc8988d11024a6275f60a2e5a07cacd27d0a867a59ea5e0348f3fc12df90fe8dfe0c086847d4195889aee8636cfc35acb043e88c0a37dd7031a2e167aeafa8b5b35d2a93778ded62acfc8d761653486a65a8bd4f275dfb0bfcbf37b390928eed2169b8a96df2c5b1f821b6c600fb301f6c009a0219e247bd8a17672d9e96bc715814788c0aa613bff196b1946db8c52a38d74eaa56bd9e054af392a566271fcdb592d04cffd598af32fc22b4fd028266aaadf9d4fe3af576d90c82c123b0c8f946a1d099aaddf2ebfb8d48f0008b01483e7705b14029cf5d469a4a82f25b384248c23bc52299e85e9b86edeb0ebebaaaca919a6978e0b932cc66137fc1eb20953d7b714e46fec4b4beb9c7a70e7fe46ebbfc9c74e4c3a8326f8c0ed4ed38d4ad47c624f83722d2eeb80ae66167b6933e38f7eadfad9311fbd454d6ff3a62da066aff8aa85f0dc33f413ea867b1bf6bbb7554358b08e497acb4a9b6cde80e5b6832ffbf1e5bcef3d5de54e21035cb982406b0fe570b4d6c38cc646e16b8a46a6bd1e8ee7dd48c783d45ac35bb3d95a241bc2596ffd0a75509bdab01ce095ef8ded5fac94709b225cd74719fefecc8aa187f1bb76fdfd901f9d0c4a42d16be1c978b68cb56d1037a12a8feb89e0e754d96ec92ff0008a4a4e282305655c940b6cb6cb8bad4a2430686ae930b1028926c0bd575085ec4fec82a9950e81dca31336f05d0f3e2481e66aca455e905e5d63f391f098416a3df8c1d26e8bdbcbac54be75964c0619fe64321964d6920584881c5ac0176705472a4065849d4f0f6500c238d53f0db0a7bd6359b6bd1cc05276ae9b162d0b5c5d58b55b5a9e2f8d530874af5e92f22fedebadecba3ee1cda84b614c3f419959f881b0c6a9230c8f73330b10967032b25d1a85695f321847bf392ded5953bc03e695c9403f327d0e621afc6b8b5313f101f39d83f5e2779e6ab92f57240a288075bdf2ddc47071a0716ef245c6e071a7c4345be7c70d42678804d6493ee0542149b18abde977dc143a395bfd54fd8a9fc2af5848f1a76c6f1e46c4e2d74168708212dacb4ac42e67a943bd94ed74aa5e82498d9d90022c1cfd613d71cbcf1f5b3b333ba312745540129d95d9396541b30411424a491d66d9bd6aacf34aff3065b2ee1eb7e81909f952eb35b4bfed256518897befc65468647c92fc091f8d04f9aacbd65f38461daaf2daab5a3b2ad5f5dacffe3dcb14455c0900dd74ed0de59c5bd8c47e393990665fd665d91990985f03b64252af1419d1f9fdbce07d2f10d29b26b93cf6b692776484623e1ade7e1cf727316f00a9d5acd2299654aa79733accf93c4393fe1a57b76ff1ee7afd647c56fabc2be4f3393f625ce0f77bd25121a713ee04b88cecdbe6bf30f8c1b450c1fb5d4c39ad367fd7e6bc093602ace4aa47de9889e0a2dd1e7e8c2dd3935a125bd4a3545dd9bd72a31c2b1f509e8dc2b6d70f84d339d74fb3f70e4efa46db77a90cc5b2159b8e65a77830163f1381d5cf1ad0c17b762c30321f438f1ef7f595967e3ce834d18a17975b7019b8db72c37d67f82d5eafed6c80ea99d7e0448107c3a89288c721eb80d10c60d5c205f0d56ab61b5dd531e59f9a236c421f941a2e45190143e7c5cefd267a474283884e656b9035db41a6b20caca41e4c28e6358667de79ddd872cb3c123e66ef401dae6b9d071d9853be66e2a9020ec6230c00e09bf92c6714df4cb1b49003e9a69f3b11c9135730775111e5c3bf5d1cb65c878e9c36ebad76521d62e3734016bfb35e0e0b5573e62340b141c10b288075566547854db7021b0ecff9cf22fc84651561139d3260caa0dd7b1a209a1cd48549ceb6dc157d2fed51223e408a96af5ec9c90a0299ca6b5f4b975a6618edb6e50082840798a866775d9ea991cf9e2097fb08fad9458eb09e20c6f2c11ebd996b702afdef896bb46a83c074fb6c71058255d83f6c10ce08b83cfa2c91929ce7c82033a7b5b8bac55e024020bb87f69c5e40e809d2c1cdb80aa0704c6759c7b899bf558da52d30aeeef5af6b21d95e35f25cc068eaf72d9f1351c5e9a0b54b260e65a5e2a0abf68396e5f8cfaf9887e0dd8bca643fdb047f7533b9c2609aab8d11742e9d6da54552d4222d4cc7e82fa892148091e14b5828d820af6d61813f6376fa57e5ccf07d08631aa3dfc45bf425709a03297ab27117cf9e19f3cbdf840ea1fbdfbcbd5d1e4570ba64c0dd179db91e3a4ae0db3dde41c9f981d325b76ee25032fad6ed784cd26665412c044f4848fc0228f9344245a404fcb4192a7f48aba83fda21f8154903fa4301a8b4ef74223bca4dac0682932974370f8f4995f083c464094e2f25fbbbebba3ce961bedf23aba10c3a7ade12533154f66aaaf33f6c49d1d9815c897669409590dc718a11fc9f6a2d0b9c0b4d90e5e16967f913fc524fdfb17a7d52feecb8fa80648a4d47a7406750e9ad2d3307977757fdd3fce7d0f795b3f39b7990e10da3236c1aa240e94782659f9900ff0f14777964d8c423dcda40e3fc8e0248460f5069e9a3c0818ba61ca19f5391b9d68a16067485b63964befc7cec3521b04e8b6240a5548c85106870e1d651340129f4c96582cbb27539d75d94194fc6f3687fad076c755e1534158e57d9758b19da9fc3bb97bb5f38a03c15c4b60e82ff54fd0ce243f68f34c2d156352aadd4813360bb83cdb01396489c6595b928e59c89f1f445a6a4c7ac2437fe671830e4a03ebaef3ecba5eff0a5f07678124a6eb16a771635443af521308c84dd592b50653b53fd3f2e580c21cf5eddcf175e4dabd5f15768f22feef782c1f42dda146a2757c7cafc51e1be757853d47c215c1853374088ae16271c20792675f9b0bc00fb6ffef41e9cc33748dc7bceee45ab7c3d44b8e5119a0d3f8618f4aa8ab5bf75b3bfe1f0c27ddd4a9c89cf15c6c2b5db357587c8a17e25d7bf32b316acd48ea74ce6e1ebe4f4f9d59286c08c58639f015d2b06572efcc7f43d6ab25cb779ade4fe13fedaa250b4d021462dcc23749c76ce9cebc8131bed62b3cab2453fa3cbb93bf7cf0970c488c38a81433f12d93c9b29cf24f8dd5bea1c24068df1d1d13244bfd33e4d68262db455c9ce4acde24a47a562799c5611ed4edf4dccdc28c84598a39ee1c1c800fa591093364956894c9b525fa6dc1baeb779b7740ad80d346c5f7502fdbb74cb0080db42e50f3f04a4d1f74113b7853d9a4ef1d7c713ed97a6a2dbdc7e66b3870b9815fc42e742f6696361195818faeaa51c8b273ce05e101d913c57f84a3e2c5618a678dbbe6e2a0b7e4e811fb576752447201e5e9f482078285f07fec306e0d24a28416285d7f03e613adc12c3a51cd77c1ec13dcacf17ce45de8df349c7620718b1dc48252662d0f1fed56b59a2a1891de1b97b65d5d40d6b65fa8b36a056a69dc0e047e76631bc4add882e759f7d92905de0bda9da5731f930bdabd27658899910083f4eb85af4a59d7ac8557802577fbbb4ef188d8ca841137327a2314e66ac27a41cffb744338b1d94d3183fe2d5fc6a48201713afa3803b0c7d901b1c385e79b5c0a1db6dc76b5c7ea33fa1c447aab3ec6bee1feea8e5d5b7f6ef58184245fcc75f73cd0b733f45b7fec073bfb1a15f0c43210c756fd92e5186ed4ab68364ab223dd00cf7e5c85a1a21e2a6bc25722277ac054ef3ecb525bbb1cb9a2b72c66182a1d2e625e0dba0b945f48d604feb645dda5c8cec61f17e9706681b48b6bb1b9ac812a4a23cb4dc0f42a4861ee612704a7a69a96820efce817d30126b81127e0d90be86f43ee706b70afd5f0c79465c7b15967a1402b872cceeb5c3ba8bee39446595eb1608413c2bc65272ff7a7dc2eb595d6bb7c9151351480cc75e55d239f0c203fcf9f629f3c0368cb9bfc5d5af49c5b46f75bd946cf871ff212a80fc1d4755c892dc499387cf281be3b51806b6d1115bfe9c0cfdc3dc87fa94de2a12fa5ebc216fc1c0507ec6e95c2fc50591639ec755d53771d37a865ba68c73e3029288c5a6f5a4efd56b35094c24b8aad889142759c4803b9121ea38d5643b860b99e4152bc30bbdeb6d88b6ee7fcb8d684c23ffd292db725278db45800771e8d02c8ecb6f7df30a8de8c066fbb408013c0fc7f3a67540676745fe6eec7f2914517bb340bb1823b12e48cd996b22525adb690c55b603e62f2b81ff79cbb9b32e928f2332f111bf3420eea565f9bd1ac39220d13a94b649d4a256a7f40db0948c61170d700c418aea7c23be86652cccbe3f2a6149395bb046d794b0f5aa03b3e6924d704a3e0ed4365540ca1852f359d4d896227774d242ef54de43fb8f7e1489ef0f916e2e860594d3b3b203a99c28bd5e7782354f67e2db13878a7a5ea4ad17c220f3757c6ea8c8258584e465df562c70a782e9511d72d6fbfe5bf9afa5c79c3e62238b0c4d8146e2d8cd46fad7632516c8df45e47a1415dfa4d1820fa1e3089debe20146426f5e0da008932c195ebd17643d1b02416211dd9c3714a6b6c03628c3eb0ea56a4c1e61b910598767761634f7f8d2e28862acc0720ff5413b3595bd91f810026de35ac0cb8eab80b0f2561649a390c5741e5471c35243046f66875c60fdbf7153117ceaf00785b5d11dc8af0d8881de8a278f875f402e0979a293ea07d98a8c69fe00ffcef5c3a69fdab8d1c084768d32740a4a259c4ee258c906f957b14c04511586aebe49dc0586e2fb26849371a560fb25a22785a8278aac2f9125280c280ab89b2bad32b21a68e8190ade48bc9883aa06c982f9be3b5b18cc3a2c6f115e35c588a0962886a03fb8b8b61d17b71be571435baaea520a1bc5f93a3bb6a79bd49248715e2e569e2215661a3b85c6f7fa0405a40a22d84b747c2927c64b5e0e3189aed17b69383288cdfbb47e17038544b6443d5e4528803f76f0bf9e38d275d35503827c67e0a1bed5614a2764024c0b1e0757d327a58171ce95ceedc76e4545fe3698112ffb12094e27a1a7b434d9f8b772ce5b080d9b86785d70c8b9503d3a0f1d8b3454ab709032172bc2464754ee777c38575a8317d76795c904b32fcc8714aace72d8b371c67d9bb619cb247fd1fbf1c0b1a223cbddf532449296c12ea82420df52956bf9f1ec89fde937c92d7ad7ee19888723127b744516a57c724af670751fd85b518f03edf5f5c83a23498f8deb60296aa0a42e1077ae7c32a32fbb0f22b7be63a4cc294cf991c1b9870a15fdc9df8259f2eed61fceb25f7721aec278b26544e09f4814f2ad7b98425c5e119e537f0d45c0e34ac604bf5b85e296f8c28fcd0035d725850ce4d577c739e15b0e1cbd19aa896e79d48de4c8a7601bcb3e66d17434b8796583be9dea9cb78e135943f7eb8295c7a9f1e3a45b4b83687fcc2466c26276f0421347a7a72e4b337342d2683ae512c59480701f0590423383e08cf668acc3bb8a4f14697aa45e5a975b5547c7e5d49b32523f57f0bebc1f1af04457170023d42ff7666860f0f73284f250d80aa2ee3a1bdef74f2e290a8487481a4ba55607fe1a9e090e5f0d98754511599d80bfd2e0eb02cd2dba4ebab26e236e0c9b4f7fc99548f7bb9acc7bacbb0de154503c7f8fec335864ce284b6937209a92f8e243d654deb74d47bef81f7e6121697aeef15bb72e3fb91ff17925d66a536bdcc245028eab412337a140c4a8c3de629e8ccffe377ab42485017eaf3b5cd4951cacc598a97d26855cc66705e4ca0f74d5bc34a61f6e48676b3b349e801e212f5ecb4a859b85a17662c864c63a490d0c38e3789f678d2a783852bbf32071812822c6216f5ca9f4362756d2dbbec6cee3d38a3ca4aab76f01356b6d7fab74c63a1585208f5b63d1f1780c6caa4cefcef55f931aa9015dd175f9e41739823bb6ec1a2bd2628f9df78c79da9b9ec9faa8ce69c1db54952d54bbff9d0e4f7e5ea485df0130039eb6672a2855f315a8b48cb0b15d921d0549cd0d70938fa537a0194b52468d5570800fde3bfb7d92e7a9c71ec2283e4a619a00931904643406fe378d29f941f0dd9a2f078657ce0673ec2fe098d22f489e6f9cff0e2c4bc0bbe6ff75c7b08cee27e4fbb8a079ea97449306cf3fbfb51aef55b0b710811fba097eb1ebe5c5b2949b6afbdc43e0796191149f4d7e506ba4212edcda9bb1b96b416806a9b5d190a74531dd7b40552630e6ed87181e1bdec4011c0e589f63d300e5b4b3c1a247128feb02748f3c5f0e4360b85c6c72ddb71986b858bc43bcf3b5b966cb42c9f10814ce73d38867402c3af2f5155e3d6c6739cbd1e4cb1827d11c309ead873b49e5c2b1df040347f0abcac75c19d20b28f335d42987e270bb8aad0d474290d31aec215f5d4ddef9078cdda682676d280ea87107178b277ad3c628a3f44fa856795279db46bc093aa4b49678966310b864055d92059bdf9346b116a83ebeeb44410da2008ad4b1acce760db842bfaa09f79609085b89884c4ea1c48a230caf1ec5f9774f2c5b83a7f93dcd8238908174325e1adc0140cd2ee4663ee1abaa880db31896113d692c261763203dcf43ecd8072a3830788ab5fe1bb8bbe5efba79a0d57e7d6d62ff235196560044c02f9e23af45d2f5dbaff04456380f2ebfea8af3d55e36881d65b0ade7cb617c398fe79329ce989db63c709e130121bdee5172077b9d6d18955df1eb583319d8a3f46e6f27bc6a6665621a2bb40c112a550d02aaaf4729d539de79d9b406948683ca51dce7fa1260305feab18cf2283958e4c24013f3c6a96cfe95b4c0dc170a0027131f314c8acd9a21472c94b2e8a29bdfef6b1d7624be33c764ac6dc620c56f9012c7174144ed2dd1516664cefcfc3e9ecbd719426acd5e7f0127ac6113315f03842f7c4a68f40f3f46dffebb8167918da9428074b4a5309dd85649903e39c9624f23bd0097f375b26a352a23fb5347d4b75ebabeba2b87cb65dcc5c8d85f10c23c783174ebce4222519d1b9098699e111bc9a8e1372a88776fb59281a81eb31cfddebda22ead56a6075f0f38c2ba5de3e3894564951f053b93b5bb20caa5754a0d7c0abf040e82d3c6ce0199b202c7b9f9e629652055fd38e7e69547e949f9295495e462024b868aa7b56b5f4bddd42888e5fdb15ed0e3e19da69463560afddd01398c550da3e20f8dc7ac04a391bc88993c487c27b68aeb75e2a864cd55baa386bcbcc6e844db044a540555ffd2e62b78b9142ff69519fce662fc39e61e1a74b26446e8b6a96b0c8fc5480146407697f61f0fc42af374a27f06380c1c07de8212d35d6f658023df73db6be1cbc75aac57b280a7d2f4bbfba506f8973d6dbc27087be3ef360ede8edb6d6215400f112dc4111436470d1b6ed9917e8a6f42e0553f62a6a874268d32bebe0876b084926ea69974efbea23b0c1bca6ee00fbc1ef3563ecc5041e648b0774e4797e1357833ffd50b4237c50da928f6da511aa4fd5b6cb407a4fabd33a1b831cf33b228ae8ac7211a65bb37dfb23b49cfcaebea996604be2eaf272cf307bea6308384e5db49fc6ac224f4de5cb5581e2574e2ee5b65648e8a92937c351b7370662210694d2c843e28734273f37c46d3663bd21cc7e2ed161aa15c9550bed5c826c5d0857feb253506c3cbd7e08bd739a2dfacb89205dc33042f919cc23efe850555f0e81ac35c965c71149bc143d6bba120964ab9bd4b3c753604ecf45a59ed3b31b8bf85ba5468c6617aa54a4c1dfa297d02ff2c9c23f96de5372551863686356edd83bc65d57c29d3d574e258cc0d1347c840bd881b79292c5db19fdede769907eaea8abbd61ba58e1c45ee24d6bc9e8440e730842af22ebc6ec798c5af5157cc106b73dfc6a100d21d452023f75ff1f5d58029924ac75d97df3cbfd688d2bd0cf9e46d2de2b7cea0e37678d5f249f8e72208d653332f3b9600013fb14c8702a30846e4836ece2fd72855ec859a5ae6362f1e261f0a929b341b4d3e81155dbb4757261b85bb359401040581efb6e8d9b25616de6bd0f191ffd32c1142e26837e4d9b30e3f32b51b5faba6940e0054183e05848f2a22813635950648c0319faf0c8450f8768e3f57b80fd00c62b7b3931ba7d1247d513777b9ff25c292b38143a7c21c788161cda7caf5516f04d26951a7d7c1441bf2570f7e2989a9b5a06a58a3fc95fee3c261a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
