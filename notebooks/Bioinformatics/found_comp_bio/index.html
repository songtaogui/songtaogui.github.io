<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd09bf2911df2eb9c3016c3ff767364d78eec79ac0bab185e01d94dc80854a31299919c12bdf02089d9fc735a98e06cb0807e695900744c33129c8b7e523ec3e40855d06d91d4068f8e79248c91fe93ce0ecfbde3561d55f0380ace62390772ccd3e52363278af3fbc13ccb1a08a05f5c5e73d752b4180d150e09f7c0b581a3ec0a4c4f53c3e1421a762dd8fbc6464958c1dd5585c24df0471d7b3216fa3e5a42fa4535693038a11d9df447dd1285220850ff0b3d72eee62eb1e86c12d4ed06719231717583cb2f9e88b075a2264b86c11ecb37e8d58763f6d538cb24e6eb113d8ff8922a2afc22b17c0d87482f804371c18f66b011be2a11ea3db62f185526b7d4fbf86f47778eda6911ba8f965dc9113c08ab72b3fb89f152a9776c70b92c31625c757ffede9b66770d08394b32de3bfe1d8abd4e2a308cd1d1ea9ef32d863c522da29a99c37577e5feef579e30bb983baaca8303e28fc38ecbdfb298a0b00f0da763aad692e5d0b564f174833ed41899be09d802294a75ec2625e70d7597e700b50596c58eaaee486ea5cd1ce31c72173d577dc265a571044c275c43d1107302edd4ab08b7277fc3843dacee51df4350bc38757a0a46bd932085a6b306c62eba0ff061413e955334b118a12e1ff64f0a96c7696d510ad8c13505323e1da1f15684c84ef0a73b3bb4155406f53bc45aa4c41fb3b30e3a80890075df070243b22843acd5fe1dd0943cf55b57486aa55a0b38959f4a1a6bb4ee50048dc0fc3bf2a27ac46da8bd5ab3a382f41d9d496119d8c5c6ef0bba2cdbf70f7c957dbbd2aa71112335aa146637d3992ff82396795111120a1ccda822ba2dcaa1e8e02e4da09eee52f7b9c9ce09b440a42fd6824ae31cc6360af6aaf2daa175dbfd95a124d687bd36f10334527da65c383d008f7a5892b0065725950f23b2939affb69143c1c03af1eb0da5ecd88a4138bff2d80ea32d30906313d9816d11ff0b4fe7981a687ccdf914174a6651a25bcae63f39c8b0b900f5761f383551fd68ddb3ebdda8daa157fa3843ca8d9eb35932a3ff596835af934d5a875b03f393053bb847e85b5dd2c8da2cae20009de179aa110ac0d14622580a46efdc5b1c0b34b618895cfc66b28a8342489c55eb47eeb374019c3474fdfe07aac622ed9f252c363e308f714f89f637ecd2fe56f28d13b50d2586706692e6ccdc57052d8870c1108093d0a704d0bd06ace4ecc50d5ebb6baa62f5e66451107ebdc9dac9bf9e0b77d760ce73a6b315c22e464f79e147c400cbcd3601d3842b98db1c3d3f979caa4f96fe3e8281c6ac79585332130f4cb816046c898f0c193cafe659a4362f5ff51a6dd27503db2b885732ef4c119a776d69296a6bfa489131f830f892a848b36125d83719ed1103e79cb0c6c31a694010130298e11b937ded4485f053ea99e54c3d6276f7423b8747e7fba6bd40108d8e0b42aae18267bb0bd9c63a7c0c0ed73ce9ec7b8df654a41a5a33e9f15c02bd9590fcefa92bdfe6741f56fa10b73684108955505d1cdeff2d04381645113fdf58489880a380232b360bc1b1ed69fb15059fc0bfac6fb1b040674fbeb5b1ed23ad8b3c09a0a9e53639b1028130e03359b7f2795b1760ccfea2ae8243714de2f84b92079fd6a4261a65cf645950ade6dfb4bc392210cc5dd33f59f953ed1057fe27282c5eef2c9bc59692a5368b8e809fae17aea8ac21aaf981de7c7aa11744e1e047b0d6a1cf62eb3de72418481a515df929b7498fc3b5ceed66bb6e2d1a5ed43b2c9f95fe20954a87a2abb28c5521b1093a4c0de746d78798c884540e64e0982ae69208f3900ec78895727eb1009bdaeb21991126148ff7216c554db453a6f98c4907c8706ea359dc7e6332cc0a8fdc2bc2c1707f5eb452119bd3707c6e2effe02dc3b2d277bef3d4310f2ab1c1b5ff5d5704cb7231542b8ad43ce1cc4400cc93639eff2a2a823175ed5f4322ea3b74faaff23e48148e23c98a35f6a2dffdcc9f0c6be034431f0396a065b134d9175735e105f4b17933de8881dff8c94d103d7bbbd89e501aee75d87d3120a120f62baab673974a66b893fd6042d12b22e14c5acefc982466aca3dd287ced76d0aa2b9eeb8653c350e3d4a8ec6434f574738316e2c9e1082307e63daae3709787948a7da9cf0d500aaa85da8c547234729ccfbec6c948672f41bcc79842c9c745df51fcc06956276abad42daee016c9b653bef3a1f2cbc53ecadcbc74aa35cbfe57f8bca700004150f8a0e6f639597f4953ba7906306ae8e5a2599668190b10e5dc6b3506b4eb114969a7a602f5cc36733afd60cbb52ce47554153a7e8e5d627e1330a1ed1f01c139994b9659d3ee3309da1408bfdf127b017c712b7d40d79f151b1495fc905e11715c247d16c2d45a6c384fa674e9bb62075c78d600b28fbaa99864586d479aa55b19fbf39aee5b2f9998fa34bd7bf739d76b846bb48400a037640e073a8d726b4f69a5774a07ab74ba19dec25d6daf42c3c80ada102f143b580f6ca0f7dff5c16245062e09d8351eed1c8956c982d8c1d9f5dcc7e5f4abc581815037d4abe802ba722ed533b4ad5106d8be883e1e7269849d3c748cf95ca967e6fc2bce80b054fac48bb28f0f3c1c51ff7c6721f6a1c84bcb75ceaf3482eec40d5e35f7a50fa4df0d73b57aa814da67d3d37dd92fb15c09b7cff63a012977da5aa72620b3eb642359356fa062f7348e4bba8430d7ec10ca3160e3cccffb478bf00ca7c3d417db9a29f22a4fa3a659080ab222f4e82e0862d26c66aae14958461d13939665af07b64833bf88081a60be16eec6d028dd0f320cb87bbe7ecb1c1b41244734e2001ebe1991745e96feeb55507ad2d56dc6b55a978bdc74a5f7b7ce33c012f427c6e927043d2960f30b72db2d9d7aedf62b0ee6ffc4f502dd82b79ff581f3afb9d0e59b7a33cbc05daffd3e41f4ca558f58db1a6e7e8611055efd8d7e0c694b1074c0207569f6746dec10df9253804590b1f86a0d74de9e3a451af6344a7de964cdc36a4d501b33b83d294867a21d155da58a1282078366a5e79354c8d0e3f540c444f659410ae9d194fd85925186c677c182a591f05056594db12450294ae06666d96200161ed09ef551da4e60ac877ba7bcfcc1c3cb5106c6df3433a05d4af92b4b56d8433afd10baaf8e6aca29f9a50c811a2bbf4a7d98feb91faf68c8f04ca2668d20dc3abd3210dac1a4dad429e4f937c69d17273cbb9892fc1976d5774180a299cfbf9aa99ac4ebefef145b903d15da6369db140d984dd2271782f16f2b7d15662de37f8d6f4f41eae701f26d89d0acfce756578f4ebe3e3322109234db376d3c376e4ddfd6baca9dee634a8ce9888f867e611abc596fcde49f3ec5233e558dc49b5ba06102073255847c2f5baeea967226d56e116c164215a7605ad335cfc2e60c6a37a3fa2fb4529e5f91aa2ff8c4367a774e9cdf4402135bc018389fe5f8c839dd7b80370bba3b9eb6b67ff593cbc1693613ed0d7ba005eb610c69cf9bfdaa19172cedcb7b793a4698fde9848a86fa7a2c11928885f028ef50d89902392d5818a772f43a905925f055d0469e6724846ac85f292d6d72b5e2f5b152a60566a967d737cea937d847b4c2c22eb80225c71c4d5c180c2ac296fd5cdfb75ab88f6cf972e8a659f3fe7aec9eee3192fbce22571a3cba3d09d5637828571ae850ab5badbe8e85e900512d9c37def74d7dc8a720673893bebd7cd72a6d871f766bb3497a16b94a9c30b13247cf26c540bfe97e54eaa60d82c32858451f3c1a567400bd031cee4ce93c8f7b40a3e00ba5c3f6179ff3e8e961a57440b9e9af3c261b2a5768c47733af1767887559431c73d0cc659305e321f7e3befbe8662d59833bc0424f64fe104ff699a510743b30bc70d76374c08dd3d4e31885e3ead0ce710eb54ec94a34e539f84e941dec6b329a434b0d540e33b921b486c851049fedefab748461b9cfb6139bd31ccdfc27ebe3c504fa4b2599eca79ffeb632d53132d20226c0a355c28122208be9c85ecab76512653ce101f78ac5c2128678edac1b84c4e0f3753efd7643ae1bb86737cb3caec80df89f5bd45ce659c5176704ce7b0ead1b1bd5ecec6f7028621ac03f4ee3f99d30ec04a4059a0826d8d93ef5cea0ad06e6cf46fa91f6aeeffb3df6c6ae87a13ca666c77d75b0e978328a896c891acfd92072fef3d7dad5ba83efde1ee8c5bc348b220626b962616d374c58ed8e6ae4887bac45d4aa814c8b9acf9164d0e7bfa335dd43e6b0ddab4d247156cbbe11f2a6491494b970468fce0b2d6acd2ebceff62be2fd65ffe7dccf0e4925113e2b09ce8ed3fefc34d4c47a5a3e833d6cf4ded912df555bb17df33c965ba4189887ebda3261450b44e5a4784fa1bce57d4fbe3c9fe7d52bbb315ee40215eb327ad4c76022d55b28929c28509f1f99fc8f4aa18d57b6075f3f23a17b5c6d0f1f19a98038a9fcefc9f5370cddaebc5dd5682460284cd93823785a527d21384e64804316c989dfb12f8d7bcc48a228cf55b7b3135392a73e63a3b61c94f5c185f28d53d6e8120c0d535815b9a23a2955b91a1803395e187ac7868713a55cfc202e9fb7efe61967e4b2f6801b128c2c01310cf53d7b5142e49439d3b74dba16aebcc27cf06e0cc9ef838b1ce088c6f14745186e62e7a012f7d6d9ead0f8f27e5ae0147f4edcdc183ec55d8b0beb906f2ab4a33186b4accd80223ff814c0fef87cd22c11deb3708c871fe93989de037a0881719b42d1e977d61f3faf31609833b40006f4601bc8bd6b5e8461f5383bf95d5911e126730e7047c7aeb15afc980662f722d81de9062a02818c5cb6fbc8bd02f9423815783d377795a51ca2ff88b2978cac3a05787ce0385068da1666f1e384f929a8684e47d92ca8b69caba0cf341dd444df0108c952f243e0d4d8118626149c7f4d8e8ad2ed180dfb01251a835ec76fa5c2fd13abc3c2b2fa9ed9ef0348c6e01808b0e8aa2e5a54c58dbbb2949f238f972cbc029ab1d00256a3503f82cbf36015cb3505481bd7636d26ea740c24421b35d3e49959c6ef0cc44e08124d0fee04ad12aa33d362c64279990917fbfe1fbf8e845206b6c80ab88c3e0e93a742ef11749a4a8de24e53a593d43e0c6f86631eaa7cc36cda17f54250310b7149702c7759d936a02303a704211ecd92d1cb5d38f1742af9fbd5c54ec5eb79c0c10638c903d21501f4641424f8cf946f812204431597d51d301412548c114ef3ef342fb1423b5354d5f7f232ace4cef5b3339cc7c43d4f0d137f9b944d9f7e899539b6e3043e323dae556a0aeacd2173aee4dd124cbd827f48628544efb79f2de497be37b4aab1b5f4fe05af497783264cfb46f2145f94f0a8f896bcbe16be19ab9eaaecbef6a77c4ddad7aa1a2dc3c5e6df2e091000f69346457d074fb490e7b56e73d29020d5a576f752f32957897a38eab9e817d312e0ab2db167dc58b5f7aaa2304ff85b8699de8e57744c72c4f005433f07b8872a71172cda202e76ff8fc802858c576c13894fab4f98604a945f63f117505d93237a7d77be6ae4e6cd86d153a7f92cb283f8802b7dbd9f70e46a9a1e9b0b2515fd5867b159a67fa0652b7beabe2fe9b7f5750e6c6eb05ce608edf343ec98268c2968e1c8ade8cfc4a89b7a317845f42bcfe96da4c38acd7fd3ecd1c8f930f5a557c3cb2ecf05bd398778bfa35ecb95d6f481b464a24298b43c4bae859a870c63470141241c2968e64adb695a0e529ee4879f43cb03185c300163be7bdc648784eec6ed4c59b390ac0a5285dc0862f18d1a2638c1a8c8e7b26a7207e6f3eeea3a854d5ec3b2f8033ed315b73c787a0f5dc305d3c3c45467a13dea20d084dad9e88ac75f891a1b3b4eaca5e0b3d46931bb659927c92281c6b63b471a79220bdd697991a4debc084b82e63a458abd58b4a5b8b2dc43fa4dde2d4785fd88e665cb110b9137923836fc20ef07e7624b1a3a616b036f41117960646c6bdd8507e61724e5b1979e9a2ad80070eabde7a5bd9402a91107bec7a8196c2771938daacbfff16738f83af55f937f80883607f81e866a859d4c6d1bab145a8fb1c99ee71cce643bc69cc7ae8ae14d8593a3b50ed6234e978bbd322bbe445f0fe91dc3732f36fdcfbab2b8b75a8312dda53fd90301ec03855cb8993c354f07bc555a0667eb9a0cb1d1d629b79dc453b7e0ed413783d5a70661134ea92ec982d6bab5c31bdfcaf0651608e58ae8dc591c4b2d3acf254b3305f86da577510c7fc4eb107e017045d03062845d0b65b3f13e88455fd1260a01b332af77bf6e6471a264dbebabea3703a1231be7a83926a541cb9c063309be0eb2747788d250615013adb61b5fa2c83f450007a7fc2e55baebcab07ef9d6dfdd5cb7648cfb4a004cc7ff20b237ed9d6d430d31b16fa8f358a2e493cac6ecbc9455d632271139c9f1c1b61cddb331e0937e1c9081a493da8f32ae843cddf7e939d726cf2dfdf23b37a8d9fcbcb20ccb4462dd60ef4372b83e80e4df7acb0891b53060873fca3bb8353c536aba5ffe79130a3ed47574f8c7e7848af7799356039eb32460c32f3493e3c2be13dda6e836f3b4c128cad0e2d3294d10d61b0f855438d568e6087b775a5d1d7f1f407dbc381f3ab545f725adae149eae65baa3fcd7b3fa13618b1a95c2a2769e1ae5dad04bde19004866b19d2dd900c28b9aaaf7ce2395b250c33f92a844ae51aa741da6174e106e0e86ee235610e802e43064cfd408142d54e5f173b5de5492329d934f93f4b6b5c4b40d1ebcf48644e4bfa8f73a5ffec2508b51cb6d9b90f1f98cbea9d81afc6d3f982c7388d0e411098beb377f66212153d99f40e5c40c78d068aad044007071814089f3a6733f9b041f6eeae3474e33e406645fa0ba9746d5ff97e6e69a12abfec912e44837ba787b63393c8583bc2c882bcbd08787a20427aa1ef96fcfe9cac86d61a5dc80e94a0188fb2520647382ebdd8b4d81d33b604a79e269347e7d64e5f694a8864734602bb272ed8d8b08ec68242a1ad1aec80f264e92cd116cc387adbb2fecf523adf0bcf22ca533d6e4c4cf2b3a4f0c93ddd8d4bad0b741a13568120b7f22557ee42822a3a72346118d4f63672b671ae21734c969349ee44b3bdbc40d538948b2ce524c51be4164343d82967ae8f7f7e074d01eaafd2de3b7ae68e714d33d96962a22998fe89418fb298c782d28dd1001be3acd62914187917b2927a1cc6e670fff9ecab703d1ee98c047c27714d9f58270348887c5e9bfc70bed6716e956d53d4a410d4b2ff574c9447666b58bf602be581e7b127ae06f8a7360b2076d81e02de88a93520b2859d451fa137fe7f5c0184750a3ccebd02ab6994d5a89f168cd28264039a59a03427e74b6b52d6b7d3bb37f2f7f9988b10c47dbc3e33563b4f77f73ed01ee8c7416b0f5abfa904c4c6fbda8913780edcac77089a53f15aea8e7e59b7e315905d5fe6959c662817c49e5abe7d78b2db461adb8fb5e655203486acdb399e6d7aa6c1aa8b892db0285821312f7096ca41e1a0c0e523168dc75dca722320340e7edad382af0cbf063e8bfeb516b2740ab9d342ea97a3d34783f8ba0d6408ce5af40163c539efa738a2c8a85531c1832355f16324a4c0d51b7179178431627a55133cc425b1db91ac38466af1a2ca89999ee6f841ad103b420f9ad41b547c92d290516a9793bf765e9a1ba05cf4ca87098965b87600a572d30109b4467e6830065e13a84f6936d2827620d309451b0dff2d7ec055a6d8475777641605cf017a6210361d4c769504b733e73838fda4587392d1d9903567b59e5e0813001ce19427cae881ed16cfea5c42058214539ee2cf2245c0f3358c457ac069e563687b75ee9cc6be32e93ab2a64f6ec4b79e8ed50a07ddbe84990da883a48dd8f5f982019a83fc3f430b5b8b069b3cf9624456775d9d56ba3f6d2e57fa09df4e009aeab0081f179642a1b13592f52aea1987586dc52bd57f0085297348034a4bc0f49500b27b18796e18c0efd784f8f055db03198ec960ae15bd7583279b7245a9c9385a12ddb1e478ba52335c4ca7549d264f6b0d2886881cac0f2182bb34269a10f4908ef2239d0c652fd30cf9a13d6dd6be9a604394b2ac10c9451e1c310355f741a99fc72b507cb395954cb67590b342fa15b2f68b6b32a9ac8b918b9d4d8a41dc15a7a2992c111ee2419daf3ca32a15ff568ecbc5aa99b38fcd27ba8f5608abd18d09442a6f3303b66efd6b42e96e6d6b3576e71a84ea448deeac21552890dc1607beb18b0098a639d0742b124b0f7d37bfd8a626b53935b2ce6c9153a1339c14144adef97431b43085137d9b72e640ccf5831debe8a8792baaa9b3c576e1544d07711a6f82aee40838efeefd20c032d0a659a0d25c49fe5a6f5e6d9e39937241489db2584b8dee3b858de2d1a484fcab6d72df88cbad44ffc83ba814abbd29c98ca79e27fecf1303e32de620c889db704c2503677f67fc519ce8ffa9fb80fd0a801f45703e6b17fe31897bbf46fd68729582701d44b01fd66214fe5974396982b7fe98360f9054148daaca8f33d40c3d7672efa6a563e9a295cae609ce54aa1e0da8bc738b3ab394372cbc8a488de4839e661cf2b7d61c7b43fd2195371269421029e8d46e01198f9ef662ec9c43810b864d05d77c78a6193818b3aab903a511fe758371e8bff8e5e85b962841136186e33f6facaaa8eb99de29263d68fe95f69dd0402e1a8a49dbaa7074a92612409c2d2f0899e7ffa282e5ed9362cd9b0b7d2c1b0ddb198994c25264b196f8ad809c2f176dc722e975310642b6a950e6dc2957fe8bb208dedb4031c5e946a69870efdd7cd48212d55252c50c4fa6bb1b69ef388b6d65eaec2608736004b0a3666a909468b04acbced17f31609d1f1d5add9a931d39fdf021588ddc63359ae9e8d38249019ba98afa3db8047dd762ed0a0a7fe6f1aa7cb8d953bd4085d0210b4276132d23d42a8a39af918278cd9606cf4a98ef0ce86037a5c28ab1abb32b6c4a95890f77e66c4d3b05fb8d58b801c178a03a88b1a6e8cdb1d65c92fa8720a3b132a0baddc34df57d28c7925cc6c45ef1942ca4205d823dd95d1cff7369e0d7f25aaf0312161496ba99a25e50b78742df6e92336505776af3e45728f31b84e3469337253c38c606713a89e5c336b0a2c55150aa95feb998f3c412c8d75e055d4f01f26076927b9fc0ce1f82eb4ff833b674e93e135ca3b3ff27b13df209ddf0d5956b624774a1a31f7739bf22cc17cd7562b2d067d610d23b10833d1f8adf184036e9db47d1b340834a6ee1751038cb4a844da63b806701147468a35260fc7dc9e06ed112dc9d3180649395faf0c340c83c3d80541de0ac20bdd2e40aec3f0679e7f0950e814e0ee8c725e012d0e3baf14a7bd3a06334cce5278f56b0482ef3dbad4aad5b43839d05b0beb8091fe871ed8c9b30494527d7024bbefd6be115b457991b2e9be07c12116d873f4a713813fedb39f6134482a11cc9b93f4af5db1514b58f59992ab3f0c037200a53e27223eb7062e15f6401ff771f8652b1cfa70836d7e133ab28ad8ecbd190667ed4e3830f3730fa951a023a5e9bc53ca1580a56afcd170161fa8a38eb86fe40766aaa4411001844a76fd6310fa5a082e6f46f50a06da27e431d9bc923d06705a89ec603d34bf88dab0e34b64b7e988a03dc17ee3038adfc9b7513414f0f32b059c1591bddbe1b8294fccbf4e812023ebd354632f85d8d4e8326f24cd3917eab4c379571c788982ce96ddc9866be50886f8a306cb591b78af1191b4399bc51b54b93ae4cc574e9ffef99d70f02588aaecaf8f750787cd2e8b50b1a25485bdb7371bb8828d6f1c1fe0473d3baac3b61f577a54cb7e59ebe079d41c93f2f58f726ee4ac96921164d2c60b115838bc0a4a1ea06042dbf0251b444061ffb198769bed35c55dbb1efceeb0fcd80cd17494eff36a24e73bd98eb16d9e8f37db4201435184cd55125dc1e35dbfe1945d6369b5cc5b69ab57f552a6480c94e06f023c69f8b4418e56bdafb83cf94d633e8230c606cefd930447ae2c006f53be3ab342b1bb9286933c8b683f890aee57634ae7750cba8a185e8b5ef2e972ce7d8088e50bc84092fe20fd29fc927c924b57d0ac9e6c5c2b9fb6eb3ae8d84f9dd11124b7ebc87645c6511ec7cbbf7029e310f91dfdf621f56b8308ea224b042a98d4b0a8aa3cd8dfe3e3441edcfe777161762c7a3b846bf6ccaac5fd99bb4f0a08c07453deed4d4200459936b247b41ad5aafb785701dfe7121314d0e23606a4839f1d7a91c56d497073196755d61774f427742e6f792d4687d65b29deb3ae0d4c7909c47f2bcd0635116d33850fe44eafd9122f9bf57f66ddbd69509a7824cc6c2a5215f064cd8fc8734f625f9bfcd4abda3a7db3a308158bd93e3358be350997f35de8655a07585af355caad885162a376ff797a828fc1edbcf801f1eceaa9fe4a1f368dd054a16b916b4cf2bd4b751c0daeea1e8d428d84984139e1cba473d5742ce1c332db54388d1989554b33170f44e51dcfa0457902767a9dfbe65df70cc40d9e2aa7ad6ae22fffd5181ffdf0b989c1cdbf7b8cde2ba02b90591ba9d81328e917249dfec77dc098f37b60edbf27cbc8e86d096cec06c8875ac511df6f271960373a846bae1a079c7e51daad5e3be3593abb4d177a66335852917c7b4ebb554d036383c38b96062a07fe27589622ee3a8a4fb4c79a66714c659cca8db5132b83f6c7c34a1059759425e90ef1a41c02c62e09f099d4a97551d3118b044ec47d9ddb267729d59a0125027359ef5aa11f5d04995ffcef321136214dd683e1173cb9d0c688d0ab2e5fe403a68f8c0ed37c9f6e6e1c48b5c046ecc60ce2fc2cd0dc7741074e2a49fd29c7810fc26037738ccc7084cf823b9bfa44d0ea3afa09f7ead4c4dc1b9f776450046c5f71ca25115a48491cf405d25d284257715032d2542520d8af9dbfbd1804ae3d921d30763c74262df94839abfd7c30a1c8c556ea1ddbe9d00e077153336496111dd544ba480122d742bfe3166a749b7550fc6ac05ab698f89ebb17e43c660c5036b8d5d176f52c0121045300e3568003d4b3b2717a1bc24ceec9492db7fb9960a5797f6ae6b9e3827ae9efdae7fbc1a2f963c17ce518f039a94de5382351c06aed638ab621c72131775e66f5c411490f6f87cb78a7ba6db6f6f2f76ca44684dc70cac25a0c851326fa35fb35a4ea7b2e65d9f57755961807d88d7b2177a08065a7a3f255b65751a5bcea30a97c97b5cf033818beabd53c583f04f33a59243e92cb6e26b53058c5e53bea19b0c73d378c40b56f5e234abff294e588eb8405c9c4d2119d830a4e2057aed7ef605e15e7fd64774e88e4c139ffe80236ee58615644660c4225abf87d727802cab22cebd0422018a015acebbda36839c0576b37b23ca743a154869a7c09886a44a6b1a8d59fe97999ffd57b48a92e351ed2d414b3557a56ae9f90a35530e0cd5568c9a7fd24137da6b3a790a78a37943f6a4c58db2e71aef36cbb3efce014ea1956b227183a841932b7d1d949a932d2acb856922c7eeaaf226cbf66c3dad3052ae52cd104ed8a713b26a03321d7930a515bdc78a5998d69505157aa777b69a9b07a289837ff7dbe378273ca342add81d1d5cc694c73ba0887d2aa1c6a81dc92ecba87e647cf603e01b5b5a70cc2576123d50257f1bfe01dab9b95b2d0e0a6fe339705fc186a9fd718d0b3590e32efce4ff355e4bec8aa88b3b20ff507bedd29b8e174ddd2c4d534b7f75820fa40d7e52752b5190b61d25c2bd53dba375a594ee1d331293e80648b6c89642b0822d64a428cb18fb342e358e04c19853b25d7f03bbf256bb3038f82036ebab0edc5289dfca27cb40583fd0f081cd5575df23d75829f8a1241474b0a17cc6e5613660ec739ca115629436bc2933be14b537b2879680d86c2bb0a0dd7c9303a8bc782152e8049a2cb3a27b6a2f5fc3e54b528bac8306a1b6da56a108d486db734acb3eab71fbb3f009eb5cd26effc51178eb63ad027557d311de87c40347376aed9250f5fd108c0ea9130e6b14f8bc3d973a094d7982709ed104a7fd42f9757fded6b1f0b9e6a2ec077bf57734b8a92b00679e2fe947ef1f853e3ea29af2d52c806d76bf67b310234052a2ce6bc782c8862600337949435e568823e3121915fe4d7b2a40e4fc00d3c89473a62c33498bf0daa013e41e01d0882f18f3b6060cba8d57f3036780dadf40e0de21d79696f42c66cda9fd16a6fc7d792f7f967b2c34a651a3a8c1a29ece8a3863817c1e6a0e6e0384fec20863af826ef6f4724233515ac038fdc346a760d1bce5e1c5d9f8af43fa39aac9693df6ac5e705007fc630745619a155eb66589b45782e4bf77031f9b63f81756133b066c1546690dcf0a36eb18da333036bb1570d44d42b46263e8a0ceb7190e66b4ee608f917b26faa116cb4b67794bbc1983c14cec193a623a7a6c38a3ee753f430b733b3b565b7a5d0e3319e01648ebdcbbfe7123028d77e0e599821308df2eb6dd800050275ae41612a30449be17ca1bc2d0570d11ca5d187ae01baae68efd71c581a35911062e7dcea4fbaf00e5bf37bc9ad1bf078d5ca66e07f73328fdca3b0583167db3ffee7a2a4fbcfa43b21262556007e229e0557659c0845fa9d5ee5722c3a849350bc60db41e891d1f07b92b3bfe6df6dc358d033a142b1edca145aeaf2b2d98fcdab45ced28dc62ba21f31acbfdfcd92918dee10cb244f12189443da7b97bba046cb8b16d4bd75785f37f591ecd503e4754f0e7ba38385944c5d53daa25b072d9ba52a309388b82c9706791cf6df5c353fbbb402d95ae92cd426c0d55e8ef118bea08d2c704dae58027a716a9feb383ca89e3543e5095a0d9adc7b51f33cc9823357ca1f6efb71811db27990a6179010094c9d6d05dd6054ee8f1b8ddb031826f7a40a1817f75841cdeeadf3fa759ab12450a864ba5cd7243810cb7203db6f76f8a6697774a0f71347c62c283b69a4780db7c2426dac8593b8b02173b7614261a4f727ae714c56bad8efbb5fb0e49dd96cc8e7b9f69e235e0ebea98e44c2a171d0e5ba63381c168f6a62db959961b8b8e909d37daec01d618540ef6254742391d140c894e457b7b4e3dd0d9113b533f5653527695c1095448b8dc08ec3609b79aa2a189f24ddf7f83465e082d24792aba581f299ac77f8f979045ff20e1245523994ce811818f50b98a87c49e38e20488b6f545c20cd89d9f975eb4918f17e2fe99c4ca9b4562fdbed71c04172686583aa0928bf09f1e36d89c31d6fc777a2bd8b4c15f5baee39044e2dd3fb173ddf81fd2992983528cd65b34b200c633e0f619236778eced60ef41dbf8d08d87aac10e9c66879b14bd9110eafb54c55b9fba31e3b77911c3870d93b2a9e650cc9f868be8eed949764a3a72ae6d82a18ddd5dbab3d541369bd5bc5285c518b2af535bf77f326185b51a6d3908d7b3503e2edd6beb911f29697095ccc871de2eed14447af2f8fa6ee7373662908bf23d950d06c9b50c4590ffb6284f71f71a9c63d5c69ff10f68fc82ae6f277f06c3d5c3829791a1eca7775a48a74eff756263a0730102f90641789e45eebbf27fba039b175d73ec6a7c2c05165e0a57876d475195b005e2522d754ddcb82712cf6bc04497bca09304cdd28e6968c5b08282365e8f4c3deb3c296e268af9ecbfdccb34c359ea428e07e95aafc77577b9126645f229ce8eda4bdc75b32291ee0b6a69372b73b3d8430e4e1da60c751c799ea097020bc0cdb7dda9e2375f3a269683f61a4ba70afafd1b4d902f230ab9bf47daf5400e6c3243275dc5a3f9a03416293c4fa83b3f89489f27b2beb8ba13d2615a652417840bcbc8a3d19a31cd260626116c7c05e61101f78225538a8d1b9a3e6947f9dedc6cf3897e677610bb5be6ede18c222ece47c339559d436c5c56511d83e313bdf1b87a0423de38b71d9202f3d6664697e8b50b4c2d571c6b0041eae9039b23bae4251b1d30c9613124fe6bf6cbe68a8718cdbfaebec8e0b1852c0e78cd92d8e47707dcd5360040d62eb13f4d80b8be06e47fb8e88ad42413f51d2cee59d3052c807d668bf6eb903965b590c117922026fd5704f2d9ff19639b8380ff6c128b09e0d469c63e12b1367f869ee35aba6e43f6f53afc0262c992166b8cd7b9d3d3969ea95c81724b41e249f5e621937179e358917a3cab22ef46150faf397cc7601b52c862157952f5c2071090bef6e9d1e6717854834f8d6b4f89add9f32f547a96bfab45de4046c58177566a80c955026317b8b21dea59bee6a0f862ffb7af062810116f609564229536cd47eeaeed4d0ef11606f8112a8dc94a6d546b893e3db9aa959ecac199068d31020f8df7dd213e0a020e61669c03fdcbb8188bb4d83e9ef1a59d9009701f38f7e14e42c0127aa81d6fc493257bf588963dc65e9946ea29a56d4dca5a80c376d490f0b4e1efeed31357f0558ae3db2dec3003a89f7c9ee90b6d90c48149f11c90264d1d28e44d13e61bd0b0c5fb4bbfd844f240840670f34b98569d0c29fffc8392142528d891e5deb07843fcb696a5628af59258bffe9802098e5d0650dfce60acc2a68aa06c3055dafd0437a5b78dd884d20c1c09d9243175a564d8af92f543f62fa3f8d7f22cf3e74f27de27fb3c96a5f9d5dbe57f17d73d523aa89d7ae7f6d2eaeefa056dec94c9ebdd9d4cb8f317d95953ff06c003f8112c6f927ccd9241b51236952d689c699265d1e75d36ba94356fc46b8f37be5152b50d548a1828fc9a89eb2fce7cc6aa772b2000f760ad6ae30295e2f53810367c4be65812d2335a081ac5c7194bb374356da8f55eeac0ea41f1b2926a2f01a81e0e3cc0227132dc608d009ffed1272d798ddfc10987547c22f38f24d2bc9424867952ce78a2ea096ae564ae343dd709cc551f211ec01fe73825e2d99ce887606e7b43e78f057e09e83ef73df29095712003c6b311c66812d76cd3b65e9a3c34911096325297363860e1436a137b9a20d27116287eca089e78f560df5dcaba1dc9d346e8124f44f9f470b62d9683fef1c47ac3a114c619a6991b1c65559c031e97c2cfddcb67419935d73cb06f4fb953e71be54db2814115bf1b3067de73d947682eb97bab246d11afd0a8f10b59213db03b80839e11feb6a27ea5c582c8d7b430e30ebe7d748919d618c07c5be2f88dc1356be3cafc3ee12c3c7531242d2e2e995144e0ca2d606ac5e86ae60a27e100467175ef926eee0d6f8d354882aec175aaee460cd538966172336b504efc50575648d050313067ea3ec9d088debc3ebd182bfa0944e9c24a5150490b9cd283248decc2cd199c209280080d71e7a1df606048bbc43ed7697d24709eee388f699714b8d15aefbbe47a076c31e2492fce6e1ae9c8736a244edd88e16d416aecea79fe51046e4f0eb8267418963abe12804354f4bc34c624b3ff5d7894bdc93c12f704342226280c6ffc0089206a418a1facf17c39963ebcb004f0e6021e1eafd2dfba8c889170c27e362bfb9387a709f9a13f351e4e0773529df0a70ca36f96c90571486806f7da7dd0d811101b6f85231100ec49de600bd1e884001144e70f68c0adff529b908f1a0e49e265f71b50e64ac8e4e6c28665244527eac3ce5a1fe81086322098e816a3d01a4b31cdfe9d7a6f79d88d2815c4f8b8691af8ef64682de362c96b38bcba0588c55dba162c700158b3230d4e520990d3628fa4140c08263e8a7df3a9b99c77eab87d3c20a7dcfb6ed22372abc1198b1b6cf61631c9ddee1d763ad917b414a0f63a777ba30a5e132b470f74eeb1e0c36fb02075c722bec2fed78171ae91329ddfd9c6a44100be9ec4f7d2a8acef1362b44811425683e0af9fd4b1853f9a365a020526e089b6ef2aef5ff491a148cc3025b859c857055be9e1e624cd164b280732e49a44cd6b3480cde01cd9b24c9a26b650b5c0f401a5e8f8d9c0f81cc03e00674b22ee034a59c84fcae26c11571639cb09334a3d9a1ccea71ea93dab84d78d99c583d293fe1d639eb8af0403714057bf48e5eb22a360c4e57f18c788d39850d08bae352527bda64502ecbc2d8286e50f312e845144aa829f518b77480e7a4e70c7c6ca2bb56557ace8ce572320585e046f33f251cee171a5631d6a7711245e4b772324c38c79658429b90546492087595ed4ef88b4204f17365fe2063a6a16f0cc96cc84cf8d6527dff516742914643812c16131a51d5900e49c29ceccdf13c02d6ba2a0996ad6a4d3fca18938ef93b7e021199b82645bcd5a35846c6cf3df3be26a2ee0dc27aa81c066265f65ea3581f6bf02dd7e73e8d7620234ae38ae07dc8efc7db0cdb5f039bb32ed5309def171aaf5bb07c5f34987a9c8a5ae53f55cb1c3cecfbb3d759b8e0898969047214dbba62689c1502cd4c3e5c064994d4ac5d228d37335d406f642f621b7fe869bfa0e337c8076344eb281d87168bd8f55a5e08520ad361b8d8d33ffacfb13cc823bd9e9c2711ee46b3dc7fa4f286d143e3d7dfe97b396be27db172fb6162f690b72f3c605358c4a0a5b79fc52d7bf689b4d04a07f688f50f50f793610ed4065d5532367f5723b027e2269afb987ba638baa5fb61bede992595c4c9130df8854904f74d3ee784f8873444ed507744a0a9f9d0def36a11e9e674f19a1bf43b6d40f68846e5a04fa1bd8af95c87898f9efcad97cc522839de1a06d7779ce9722355449e331dacd17e1daaebd3d41282de6693c8c380a310792f89050438cbe0e00fa567850f6da7520e5371383a711d7e9ddaaed0423ee262ecbc2efceb3edb6ec03600b9039a34930797bb599d6cfc449f9dbd67f514a2fc746e756dc23c981a8c02022a185d3b2a3c4d1303864d8b29ffb5af105f0675496e804ef2deae4422b93bce8b82ef3bdc5083b56b5c9c873e7c96d99cde1e07291b7fa29e518c474c68f80ee72d24c4c55d4beaa13598623221b53a627b0c0381294b1377a4b265440461b7ce82520269ea5f2eda146c1af5b27b384428d4684bb68c205602b1d615b3717803266817f972d398bdfa63a47284c19d911752b7000a2f7c3cde986f56baae8a7ecd62f27818e3c3afff6c55938495d03a58cbb36766d8123317d44cf3641732f4e5ac582cfd0215786cefed94afe0eb01c038a9f5de9f4e54c12283994e7d78fc31bfeaf1575f9b2a9e1b614c1797b1c87ea1833a70fa5accb8ddfc027b3df2c5a60295e90e9790a11ac2bee25635983d33cae6b18556e40def2ddb2bbc4225b59562d9c940cba164324e08d848b0252a80aaa49a95fadba6bfbd7c44f2db6f86b44d77b452262060d409c79cbd7980924490e89484a4e75ff6cf26684a6056f62eb44dc870d73ac3a303f4e183fb391d436e7dc82030673a4700ef643fcfe3d9300456cd83f8eafb26afcfb2cd6c739d09843e283f8402c0b63471b6dfaf60e4d1d2689887b16cabb623badb5d8d61fa4988450a34b2f85d553e10c7210bdb535e78d55c9026806c7e3b53879d0e0361f3598af9e399fcbbe5b584193f359c120f6b2a6277d76ed3bb9e1c564e2c4e93057be2d8b62c58ab15b9e389e7da27b248a3f6b7ed894ba7055818aff18e91d61685dddb48a6ad5a56c24697c9037a9952e258967411cb681552c027683e3552a4174dd4246309c852db98f8a9ef2b0b534108b40201dec287f3a6eb2d643f0a1d4d461c5924a4e385a7f85dd371111d134530c515545001e5b4aa69228e582bc0e371b37a2539fe41744faa0781d29f28d54738cc3b0892d8257ec186ca64342358d89b800b57cdaab12c172c5423d5f38ca5f837bbcf18c2171830d9bfd3bd4c191057b058d5c939b46a66530bfcd31f1085d07e627c448bfccf02614b4e8d80baec85fdf6af8d390432dcc7a448bb01768137d1ed6dcf7841b3acc716aea7c3ae2b1ce22ac5480fb96f7f952bc40854a18f1207225ac88c0a79ef6a721eb1bdc1fecfa1ae6d05a0b5b23b08134561977744f41b7689f83f82ced01e77dca6a5e5b149602567ad1992aea8b2077e68424c7b565936fb4186de21479506acb8e6737fa5e822f5b414e347fd074e4ec196ce7bc4fc088edcbefa020a8e1b8204b03c3a5921eac0f339f0e8694898d57dbac7bb00e7c1e533a8df4bfd0f6466f19d7648f7e3b3fdad705329a87d5df956fb45de72d70f6d61e1bc7f0480cd73bd754ecdc0645a3a891c1bc113bade02c9c22145ca676a9011c7a5ef19990d7b1bfa8eeee9cafe9c526603584e9dfeca214c7a0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
