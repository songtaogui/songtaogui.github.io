<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ced3ff7aa09ffd7389d859bdc6c5c31754bf25c86054b44863e546d06cad3af8306fddd6f5be341dacb5f01ad3e39e18680fbc66b224ed858c5a0b7d15e2c8bd34ae180f6b8d4b0c44e6f0bc7baf3832d8026e0de8e10defbed2d13b35bdd2387df4f9ebaefd28047aa0a14785e85f887ca42436dd2b1881ec27717133557caf01d7f08080f96240eea91df3388485eee4aae2540587320d629fb34f9ba0230bfac226d3d7343050f02751fdff4e79e343c42a565c01cf37232a874dd5b086d925c94807abdb83994a9a55564fdbda3e7f8e452c7f44d6acf15ba7e9fb011ac5b4210855574e5d779588757ba9ef0965bad0c2af22cf6fe7cf42da151e0d5672d97d2c3fa446b529beb4e69ab2a777ef9c3eefb6f6497252105c56095ca237844f8dc9aae97a440afdd72c4ff03023422b010a676f9cc7efff9f3232e549e859d29e92de61a308db6b94a24f3209fdb9349ffcd100b70f9f659ee94384c2f33b49c042975cc595edaaad986668d53639790abf00a26281f8fbaa584214086509946cbfd0f0c0c63f178d49dad5c9bcad471ab8e8fd1af01b05387db97630eb2e62e2aed2b303746042865eeabdc1180c78ec327ffe3bd6e126d945a51463d48c5eda3b309b92c7b0d273016a34c13b6808edab7ea01cf7e6d5c9658a8553702625ab61ae9dbe1f4156a7b77fe6335cab40265e9116351af4c94634ac4bcdf94225b607a0026ea332165cbb98f441fdb3b6e11858db8275c1e15265de3007289f1aa90c6dc625b311a2b3a249f73d0ad8e5acfbbf4c095f694ffc8ac4857c1489faef6df4e12ad22a83cee1b0a82c602a5e6b1d6396f76b7537bf47d449dee58735ca9d0520c3c795b1e538916397faadc6789aa07983da5fb1e4b94cf8a8fbc51482a90fe34d349d7da701a5c2c48377ebaf4e02a0433cc5bad41672e116561d1f6d17794a278c9a76ff721b4b880b4b7affc3d30d4a3e8479152641ce4efc726c1c6f6d63c57b0760bc0c7cdf86e8e36c2bb32af7cf64c6b199f722aed3bcf6fc4e9314717e0a0474b238a376980c390259b9f8c746733d96ab62e330bcb618584aa9ee4d66708ab0a53397a1b33710329134fff868c5cddef290757efba76517d813f16fbad7231aa412422d997a78041c5c61b3885a476c3e9e572d12878360c48879e9f893d5e94a4355bbcbe9e5a7fba3c11501922c2ee384e06e41deda9c7666bc5c6d420009d1cafc72feac06773100290991c85acdd852b7e299557b39c9b4222e5aa929ce8bb56353f44ed9c8d4089131b95062c5ff9f6a0329c30558c4e91334fd2788ab3caeca03fe98ebe12163d1cc8627553d0e17ae82f325a0900575a85b9e7a23badd071749d6c89e1cb32c3d61751f4a84bd35d0507d9f66ed991787055edac32f88a6f171813850b0e2f152047867556cd4e97a459f12f2dbf1b6fecb3cc34233c261fbe6541021534cd6f1324f5af8bf00e5dadc61caec920869f86f49f6c836918c8f3efa49338f16695a5132cd58e4e95ecbb7d5099b83cb548dfd4e816fb3457ecdee44bc81f1615b8ecdc02de0789eeadef7c094319ab50f924333c9cd69f68cc90cc7832bd5566e60ca38fa4aa087fa44e72bc2772abe4f795e28938dd5292894c7cef2d048c7b204769eee7b1327fa451e9b53dca68c7057b4ad365113a96f169a533498d0485c5f2b2d1a4d5e2f822efbeae5d5eae4966508d660ce9687b4e0687c8ef20e18ca4437a89eb47824ae5a554a7f682e8f8ae4be6a799940d13464aa9a31e94883e71018c89361448803d3ca708f690ae7935626872d659c8c3921ff59551e7ef087f344f021bbd729974dc87325b495e9f6efcd292a9ccd8a15bc354504c54debe32de3c3c08e1806cb69591c52f4d381b8a6e9c645480bff3364134e66a22ba719f4a0009ab2c3b24fc7f554f53a7f40fcbe60a188e5df0b6c92d3c9dd4a266cc0b16f3391dce4c06f95f9d8550555669870d0f1e3acb731427fa4cc099f2a1efeab0176404da54f60b22a9f3518312974102c18b9ce561d83ff512307e967b37f92debe827b97249bf118f644a7794c2961497e6dc9f39bb74ac3303f651c8bfd25cd30a68ed0191694fc32a11e8c4a6c785797c47e606a359c9c2cc75afebf9d782741f662f55db515520f77b20798bdffc2faf07ca2764927c520b21645fbba3d179b2cc98d0230660d2873b59940dc0ca2e50dcde23e5dac06c1e2d955752d5ee04dcf55129e13b04bf4ea089746017717347a66a2c6a4daa527b5ab41cf16a872aaf9bf863946ebf4ee682a44f853190cda6debe2b5ab905cf2e86538f9489e7f05010ede7d74e41e56cb81ab0eeced5ebda2eb743f9ae8c62752ea8db1559da7f268cb2f170d604e3e4154b1385104cfb0a9155aab53604d6f19726cd1847f754010e7dd15bbb11bfec8aca85697974fbd2ba970eff64246014022cd790c530fea24e7e761bce059beedaad4127be994d10f8bdb5b9dd55963cd2657d4b96a73a2f57035f8aab5c5903c92cf8bcd2e426643c21416e81c3547704a679a44c3c86d213cf0b237538f66f41de01c7f76ebf46d6cd671f72c1a5068d2177690e0947f8cc5d4342cddc892d056e22485dcca457648050f6511cb15e4060562670945ea7b02715168cf72b8e5659b2bca1b4fc3e97f6693206ffb798e0f09e8f1d32721f55b25a7264aa19522b4db39a00d795b66584595076e08c505fad12a24d83606b30d03aafcb74d19b6500f97ea57e968d044a7e6b2d7611bf25a1d5ac2957a2bc934b1c436faf098e42078002179cee7e093cef7ca7c19878a4e35f8d3c38bc2301ec7aa122f2f1fc195c7ba18d8fe20a54e2f5b10fabfedfe295b33ed062a7e8b52c5842c902f36001d37172241dfad3c3ba01257c1af9b459262276489239d7927acc8395b549a53659f5853b6fb353db1e697b6e3be575b8876ba6416934118bc1474429cf95e0893e97567e8cd59dac30c574888c907e1bdc381c7d0cadef4d285ce2aa5a96d8067acbf750f45011cce985f4d49ba49856b35589112ec90517bbe174decea917c99e9847ad45b54275c49986fb21bef4a801673fa5848270b7754dfb00d9db231d9944a193eb43bce0d2cfedfc07c986b8b9253e7f05221df7dfe1d647c9822830a4cb1b433321e4446862e9236bb81d8acf8d893e21aed230ea75db3da3dd8866e3184b281cb3dc509f4a6eb128199e0e5d49a17b2c4f09d71cf2059b5328a131f6893dbcfaf2cc520d100f07f73ed9753f53dd8a0b13cd58ef4eae4e8b63858b0644c2ee88355412910e4ea33d7025955866a819e593de1ce93a50c952b8911d85b2f1497b4f0650cfdf39331a1daed7484c37c1affb4d011bede94e9d98f6a1ba8c4c08071794529931998a737a9c4f9d29b8e440a1a5c36c8a78f11946843c994f8492683bc21b973d1c630720ce9e5c6ee01c745d07a50116664c8ccedc054b461002f011d006a35a36edfac16c3fd33660cdcdf1190522f4064c7a0ddd4c57fd8143b3885ba9f9c71f4a6e4d49df9f06fa2af85172aa5daf334f73508dd68d4847662b53e8fa693db3b646d2b3191143f84169d48039b72cf2167615c5b0c792f5710fd21d1121a1d47b6b0be667ce68eca0caf4031495c19cf51ccb3dc39543ae30ff9ff93424524bbe7a44d560bb61a40522430b6a8b80e18d03ca380e01866e085d837a384aa98f7d4718c6a05c16b331a5d93147512af2809e671e0c1e15c3b48e316b780a5c712c80078d82b649597b31531dc9542e5603ca4adb7f75988486ce814df77c900be11fff6e42b3eb3a75435c90efa387fa9cbcc4f53a22d10bd0c0d69618cece814ee8a82e56dba7a468936ac4ac4e2aae3a7d4cbd5a021ff9ce8eb4d895ae0b1a62bdf2f187098a32dba4a9ed2c86ab9ce605b80785413b0ce73252a55121168226b037d626b233d5d8fc3cef3a25bc04ff49d15b2bd1d34eba6536ac34321cc742fc5e5f765de14d903c76b1be914732a02194b0a7fc35f3de465aece886a0e70b809c82ad1e72a4a633a00b9c2e2b5ae5609eeb1d8332b22246ff7a331f54d1fb3f7e519dc8aa1900a2fe10fe694772732d5d7b3209f4ab6ea0c7a5fd5d09b269f40a5b6143cd917c7cf8c82ee08df2a7d25e45e55eddd6189fa5a945bf4a8079364cb4ab974e84d4b14a166529acd78fb7d705138fd0f027017bea6478cbbf922dab5e4d667101f72b969fc18e27896712eb75c9b9839f4d78e39ce32ac369ecd69814b3f85e1cbed7433c9a3c7055403a3fc4f745a883f0a783b01281ec02bd6951b4c21b08a41c5073ef83dbd0b457d1c332077c8b17cdc79edbb98b65d92fb7ef78b7135ef705637cc2ed8e549cd749880f82381f9e1b00224ad86ca4d260f9135fa3bcbb9e6b6398b26e055bfc0660f2e86c8e247bc55fdeabce5a2b3b2d85d286eacce3b886385fe9140cdbf889d209dd7d5ac6f3b8a3ea4a2fe0cd6c11152448add413baf7e56f3566d4ddcbbd2996429ebccc02fc7b609d2cb164728841e4004d1bc49c1ae9b514df2f7bbe264627c6f13e865a2d93db6c106e783fd60eaca77267f35986a0d0f17469e763bd9d5dfc032ea97ddc47870a0be79110390b3b90ca818c8af67f07bb6dc3bda8445db16cca2e966406142c4d9bef8f1c74e8e7d2508eca5ca0736eaea36f3143951c36f182358c2421ccf27979072d132fc326e42f0a55b138446cf18f2b34377b4418b6561f902c0be57a4b25b1dfbc27a77dfad34ab3e93ab34b6df384f2aa8ae178cb54e28cf72993a40b8416254e83825d4596fc353d2ddb68635dcf96fba968fc13b33d22c55acb24cf112a542ffd90d0f39000420ac514cfc85e9529f5eff86d6caf703625678d7a1f20b01f660bf981602b833d839ce7d1fa4a3c98cadcf8a6585d528ba98b93aef639c56e0eb48162a0afd01cf51b6967fdf1d6b548969d33678b22019343300bdaf55834abfb7f5fc36eed768f665cf8c5dfd6ba5ce2783eae3b82da0f5a718b32d37735e1c4580318add715259538dc68929a33b911d1298f72308bbaf40daefda510f31c118cf14decc278903f717f48f9f26fc9a95e9d490a3b1d5191591967823d7234a56767c59653d8658abe97bee88dbd2394ae2672640f42a0f7642d20cdafe8b717d12bce791a589dd00713831edb861e3e7022b665ac229e7f0ec50bb70e74c8d0b3e356e2263502a9d90b5c5034dbaa08fc73af8dbc79ada153259fb4e7578b805b02812eccc71c0c3994d677a8f04c8968255c823ccb8b166e409790fd19ca39cbee6e02c96020cffc0e100f5d1761a80f1da28c649166802cd2e80a211672b3a737b984fd59b8e3a577e9b719d198e7bd54d437c4bae17980363051b3952920e887047ed5650d0729b7c4cde6c2f257baaf0ef2330f5923acc47809b436528d63ca14bd1a84a5470415195a3556a288cae48e24a6697689a5c8a849c7eeaf7cfd3cdaa29474d85a82e70ef393ebd7655e6bdd9149dfa820055ae5aef9f3b54f7f18104e470ce817e0dc2696e9575d039260b90fe5101b2f64a140bd332f3be84d97cecee3934cf5489edc80f4330e4c53a0c538a4de7fb2f626b589bf068172897d4c4b71bd9f0f1946bb78f51292263208ae03f310870aca9aecbb7eaaaa05d8035130ce13e71ad0e230dcee3a7ae76be8d86811de4fe23e66f38c17dffce161edab372a7de7a44b56213e3306428d76cc0a3fc79795a4aeb7591ef40425a4d2048d0f9a20a285dd6f29ff3fcef6f2cca232b904ad3b29b94f3eaeaa1e3b6c4294fa6d7eb203872fce049e6086d5c99d209373bb4c857c6c9a6cb99056ebd1fbcb1e5f041b44f01b5e9127c41fcb823a31e28c252fb923f8f8a3039afca06d5acb409ca9f0ea1d6bbb94bc537a34f27104275c9062276ae0571610e84c00b8469eea338ce0f5d356f09b649cd7df93ce08914dfb340b5d49ac6e8c812157c76e14de5b271dbeb29eb6d6c60fd1e65974c5eac2407958894722334b79d37039c6a5a8debe9c75659453c5cadc984bf08183863438a85bc8ca3a7374d03c71525585b50811989e888da514b9a60765b8f352fef3f62ff7d05fe251f8f7e4273a01737f82f93275bbde4598da686e3c5bb5738d0af2d834e530824d00518bfc5036421bf5976939b8f3396d040af3bf26f0dc9f3d0e3ce822c70772d81ae6039ba82111e08e5fb6eca6fcf1fb3374b979dab645fd221e06b2b359d699b59adb5fad6c45366620e6ba33acff52e088544572ab1fe8040c0bbe0cd32c590340b2392ebb28faa75ca9a2e004b6fdef4be79b6e13cbb62d901a9a42d2f89cc2bc176c92cc3f76253035a38357080a0ea6b94b05ac24fda78277a344ca4cbd63c0bedc063f2ad0b571f12a04f6fa7dfdbc991434ae377e91366f037057b77a8c7f76ba32267a0df6ff58b6f46598931c4fbbc5b767c5f0dafcf5d1c9c17fcd68283d21c85eb3b4bcf319c0a8c24159df1f534e5460b266fe9c6644d856d394ea72a53cdc8377977b78275fb0ebe77e69b152729c40cb5ba453bcc915364ac0645ad8a37f408cf4257deedd7b263db4cbcf954bb0894d13dc8e5f038a245e469f65531a4c8e5b988132958b44e4e2903a43c13e0be221bf5bf110e583bced95e67ee5f2c8428e2200ed30230ece6b660a78e180e147d4fca6666691abe93c002f7743e4b14a68849de98c7f81c43dfdb0a380418d73aa84406616c8ada558121e549f32b63d03bbea2380f0b9ee4026a40fc792cd6d5553814812753c9805c35a650ff8c3573afaf8d0cd2e1a4d507ba064abac24a1d9a3687aa54d0f4fe86eb1ad5eb79a886e5cb03286208b5eb16a883382dc9a2eaed66d6fe52c92c52ede3847cdba5bf5ee229c06e5ab9f448e2a40e431a7854a87f8d9f803160ef28a005f5e5d498fea86357d3e53759d55e11f44380626d6964d6b1e69be244223ed8cafd71b318af06a1a325f3c5e921ceef113ecb50a40992794bc263476f20c4c177ed067e16caa241a2f9ec49222ac6341ebf980334b5a12ea9cb00f010b9a34dc63e2ff26d81049ec45725132117c39de91a6aa0c1689af05a30e261da7c6b046c878647e634821fe2b8bcce74552fef7eb774498dd7e4e54f76c4334f987e5e350e659ad611286e885074eb2a1f4240125acab81af21250d892690f6d5acf769fb4e291dc8437de0e38ddc7ba1794e68cceb678ee0ca443087e016f48c02b2f1284a64727593044a71a41000f4541648f54d867cbf18c7b2923504476c3dc4b4f41a7a0b542913046dccb55f83f0523ff6da1ba85c9ad97a2c908e2ef86433cc9cf57365d7fbe7b57dce050067fc6b3b6a5aab35c474cc0609a4c95b583113c0b469275236c830b289359d5fc9dfad722f95c6497fc986c908c620c9485222fc06256fd990f61a426d2784e5b0ea5561fb11bac69c796021e7ffd6e867ae77ae952875cc5abeb0d701fb986b3b556f8052120234020041323ab56d79989c929c5cf7bb8fe0caf5745cb8920cedc34f4aad55044a7415abfa39b3cf964b0d910baa958092d597ff9a0a3210f9052ae51d0c4a1cd971c1becbad684755d761ebc36cb5dc2ba17084e9f7fe213826cdc01cec043561038fbafc200b8831959617c2ac8fccc4e9bd748aa5c1aa3ac52c78bd4a501e3b3848b1cb2f9779759f2a8a7e9fc502da35886a78c691564fffa33e71f87cdbad8d6c70772077ba7477c701c0d55af27083af32bdd6e39b70897492b97b76e96e2a3835e383f26ad42e553682a8b7f7b9aa051eaa008c9ac470509f85660cf762950eaf0f471abf1c89642d2e5e5dfc10f303ef04f6bedf88a1829cbe8dae1612b14c16c55abedd44215970a2f512e8a6618af7a13a80e1617045fc1cf5f3b7eec70e1302273c721c828f1aac6f67cae30265545035e635796694f60e7730b19abd80bd769fe94995bdce9e2a07c8e5c93d7144a3e87bf5aca083e6b7b759901d696673a305f3bce7bda995c9a5d65f7a51f7dba2dd4287716e203dcda2d134430203ae0f5dca6cf8a12f3faba55359f34d07607f18a0155ea5a28b852673fb3838fdd0e42fbe71f56745d77543ac180f9df257cb9219528bb77e190204a146ec184c74b41d71e0331e32626d4ed284fbb6b64aca59a47d4f6888de5e272ff2ad7bb25fcf251cde96e915eb0af76352c345b28cfa23f460d11f9b31f13794c25920014bd95cc02b9ad599466e2f127b8c7ccf8a36bb013e1e476fd1bd6afc3f429ffdbce691ebd08644c11960389a5fc22e2d2b03e6dba39e7ebc3ecf9197109b1400ed0f9d7ae0d099d463e55429cd080989125b1966215a9ba6522cfab91f9cb1e68900542bf59cdf0d5a630077b84b652cb408ed910ce7f1846894349d37dd4ab8bde4e6a5abacc5e8af9436a361289b156b6d3f0548e255a2aa3e914b1cbc369fc1e47cd8988ade2504290041c8d0efe3c4d5185d6d09c70771f033a0db92f02245a13fa6307a2ecb85b44266b93801cbc866e5aa0de5f522f5788b02bb9e0c29330106e6589ac4eb1a2d41a436c54b6788c03fb7a1f9f93cc4341319a1ad684f9cfa72865267dfe1c259155bf4946a294b9cfbf2b307d36d5f3ee812376c8a7b9e80092951fa6edabd64939872c7cae8f53030c315d04f41bed8ae5c41c03bd5db174e183018a538a35c1e49a4bfa5322e1217c7d274cb04a138c318c800ee6cf959e7872c827ebe77c3b5378360287d2d9394b1d8857ac51976505ccbb9ca160abc8034c8956d0ac32cd49dce51fa31d36b1d9427de929f102de6a6aa511fcfc822b76831ee7449255417056487c52b09ba85be3a3bfe283279599be8588214c809a38b63a355dfc5af1c900d1b7c56056e22c5f301428525bc961b255a4928f2f58a4028d8a4ae69849e3425bb2134b4ab3d5a7360c0226f933343141b65a39002498c22780be2fdb62183976fa33a4941e452f5ea7366a28dcd2eec62754ee45bc39ed4f69fbc334914b8c750463d217c45569050e9e9f321783417978f068435c66e22853175c702c8145455f8f09b3ca8173afac772bbecd87d4e87cf9938a7e4c3573d203b284f6290000253a2598d7dcde314420b9f8ad47590eb86f0d1adcc0b4a45b4a8089a2e97329bd5e4b3bde4dd6e5067b247731814135a544634541e120c142a837b09630742c687fabdcdc72f4fc17c737f78b447e0a2d6edd859233b71b2c0944681e5b3658560e05ebc26d5397603ed4c02c8ea50174ec2c3dd708efa6d4ced40341b5a6fb6d8f1a27036aa776a6c71c78199d94c00e3a763aef29064a9344803668e8574d49d3c18c2c4417968cdf34f527369308dce492f142e30c98e055b33e7b765f93676d9d0a2085b0a45326ef46f6e32a64f1e14b177dfd238377a0622cc5f9e0dbd531190713611c9c09472b1990ba7647f06e4eb341c468e17b4fdac574c434eaa4a50707c7369cb8747f5a399792b199b36ad75c4411253c23a85076b793d4cb0c376a4b634b6c1b2af4c282e0d6e524c253481d147ee6ccd5222dab8b45b7fbd50e5c95b9907d78adcda94fa7ab053cfb7049d2b768f5a8cbcb35484b1e236f64cf91bb2467f5bcf957e916fc93a02d5acc66ed306a5fca3470650dc0bd07d55aac3b95063aac7d062ee3f3bb745c1178fe150c083c4e211a8644b705ea65fd269d088bd93bfe16bb8e74d756fa24a1c4bdf70a0ca3a5d67a759cefaec6c1542af8d574afc5e02251df86e7fb78159494923c6d66be5854fe75d52ef4d6533728937ef68044016554dc1928802ff2c3ae0de5984540a549e996225330adf77601827c5acb6082defebda805b7c66314eccd58658aafb190a7422a364d64ff83177d49a74bdd29e5c84b7ab873f6d071557151ebf839ae8f3fc63ac11d04acd02d1192b6f8202790ea3e9bebe8f2cf9b92e2d5136d18fbefe6e0c9ac14d524e882d088f31736eb3b2ff24cc8439b6dc449c4b298f59ec4df048a9eeacf37cdfbb9cce9a2b749fcbfa8917e54cac6e6d91e80c94345f476f2d273b6b602adc34f8851ff9e80504ac253f54c12e693b9469c54d2ebffeca4a51456200c09f0c0fc6fc31bcd514ff577493cba761e36aa28d9a7bd805f51512c2bbd1a94ea32122d1bf70fca7cd8baadab31628ec27b0f385114688e8c864542b778c54ee809b36eff3c418410981f84b4de40dc79f1eeb50368a8a439fda94d587fd2ab2a138012c00bc35a78440a862ccabf359ae50528f66e564ebfeb7df9f3627d994cc3e4fbc389a27e29a44f71ef04213eca21a4bbad88dc55619b0ec5bc9d11eb2307c140903b798c37a00c8f540b4cc59ca5e8036a3b1ac7a14d922081086216098d35580e8b73386ab42282d60f9d7a9685d8d78101899f7e5e20545cdd98dd62eca323fe7da4026c170b312cdede5dc9bc0a44d4749966e1c700e40f8ed2251a1e4de7765ad47f5b383b20f570218a55fd1ce52debda3de38c6cab2761ad54d1bb6c1b72d730a62d18956b41d63989b44aabdd70ce68ff681fdba5a727f6b2c00953d824a73f7d1cf4ad85c8cff314087b30c475e1a199a7345ce053d09d8b5502efb057e96d1ae2c592274c7014a40a5c5b0767e58d18015ef77427f76833b7223b64d432946fbfab654748f0cb5ad9fb32486785ee645805af6a2865ee560b0b8353ca51940753e4b4be91581270e0f188209c20c500fad565bf9ba068c915aa1e87b821094cf2c4d03d705fcf690f7744ba49d95c1241266c09791d34fee77ce9837dcb3abc8362dc3f02c2f501f7195489706e726c0b78d991569de934890db9123f634b62ce4abf279459b990f976bc8e6f61730f9a9e88b970b702b0e95f02c9e2a118265ee6357945b8da62cfa6c253e02293e35fc8b6f5435655c23141517d3c60f3811a1e241f03fbbd756f8ef22998133f393315dd1acb3c330cfb26372c5781e655cd0c69b13026ed0585317a8c2cbc25723aca201a9876b638527d0dbfad3a613ded500154572df10c8bba35d247efe5f2450027dc8dc0a22b5327a31ccfde5c7e504fe959f916738eebb3c724b75b14dab273ec2fa2f76006944c04ecb3f8b20d8468cadff335b36f1eb285c68b95823fbf26052937de8a8d7876b7e481e2cc16f0e44aae5e0e9de53c5ffa683bae0df0836097baa28abfe6a4b22f3d791233e5bea82775f7ff99d43e9b8ac08e3bcbbba0f7ce0282638701680cf515f49a8cc897ebfd24af7bcf471468184d23465ee4756710681a26f78ee2fcda2a991e0403e849cc71a31b6d249d7a60cc6445f76f645a0d992aa2958a0fbe84780686e6a130470f539e1b611f6ce3da8bb68ec1b9f506909e31d924702bbbb076d01626025bd4d8543aeb460c49b929cd2d215b4ea8047fcc320c66b8b6c2006d65ab528e144233a8ef77cc6d4006ecce825b02a84b13914695a7c9ed388b1d05309af50e2f662646eb958a14b6c2301c26de77a29a525b1c688a1f66e821e8d271108470c1bd7ed3fcde9e3f9dadcfebe767b0ab926c7f677ea8a3ea7d1defd5e0598a7d04cb737e05801266a8cf6f2027cbdbc8e7e6c00d7bb4a8f04a9d0559b086af1f32454de96058031629676433dd17f38b7c9756da22a1b00f4b08e992b4736b56a2cc0978af5194199be8a968909986bed3db9cb234430ed655cedca7666cb8aaf819c50c332c255f91cb58fcdc3e8428cb40ca3cab50e00c6dacd0afe7e59c88151b7fe4db97c7edd5c80881451597010e806c2bfbf376934098aad3def2b597b97f406b8f07b502d99ef23ce936ca03eb1d6895622004e7d8c4978c7b9be1295adc986f38b43c8884a829c953d5a637908e6915093de7d8096c1989648b965e632d5b3a66f676acd3760633d906ae5192dd28801f638aad5a0b6357fdcd4f1ca5e78988472e83632d12d681fdf36c6a473c1d0015b2197787b1147b4b7be28d81780463250ebc038037bf801b04bf2f1658b599b971da83ce9ca169022fe13efcf75dc8b78781881bacf606285edfa186d7efc28b211280d6bf068a05f2e25e0511ae52c640237b55d07718032a539156fb0021126bf8b7972b7f07c177efb2e65c5e973c2acec9be170aedc863dbcd165ee4b04684ad3831e2ac8466ec45c3a4f60be19b8e55c08fc6f2314a4614ca0873fa5a46daa477f812ec2df9c2b5323d6d51f43597fbfa1ddde095460820aa1d3be1742ee4e747e4a0aa6fbf28e1cd0f0aa5dfcb9d3eb524f95eb49c295b763f1f6301da001bb7d5419c8d6c771ee0fb77e24a546d688c8c379f864ff24865e04e66997cbeb21df0463c9275b6ad3a2196e4859941383b60abc2dbc41a7e03df03d54ae614da7ed0bd5f76dde17574ee226a165e3c9bb7603d6a5a3f7fbdc8af1d26c33e73de193c85c5415474c49e9b0654c66b82313e4f94f4ad033eab1cce1081a5420d1762e9f5537663a83c54e8d58844490dda06d5f8240f0b74a1aa905a1d427ced6216aaaf0c82e74730ecb5d6b916a0d2ca65fabaf9dbf5c4c0ef515fc12ca2b34c6a34a6a08ff802c058740f52a9af7517bff6fce2d0b10c88f9fd2f32e7884a948f07a95d4330988150ec5020dfacc15120421386ea55f157dce5194dc4f17edc2b371ea7a12911310b234b10f66c7ca32bd6b10e9bdfa3fab2cd53b5b7d0497217aa5d37ff87b0aa979d21513d14f0f112feef971a76bb558f2648a624907381d003aae5fc75d36a6a25b0e9d5b9ffe903682bf33b1ae792c46bc24d186a7721fddf7131c867280cec71813c626c3923210b0c2b0ec9ff190c50e2e12a1e0dfa6cf077813eac24c11e9c25a69fb03d85405a60f4933e583af80b926ed16f5663c1d7071cdcd42e56ed3ffb6ce0f84d2a6cba1df1cce20a1bc807f599e6a8cf31d5c2485ab303398aed42819b13bc8815b93214b84c2d838502dd22c95b3e5a9653151b72fe931ed79fcb3486bde0d4fd46efe77bfef92165648f2753d808676733103b18fd1fed530afda30d832f0e515b939957e3d998fd6e5a03f51f9eb5860440d8d2a77d22ec86be0b492576f8bcb83ffe940d89f15bded27b68714619efda8746120b16650d909d3e7f72dcce58f5bef6074150c7b3ef3b66cea746f373a243d75f70bf33e741fc67aa17e96c38fc228b5761f567b6ff7603a53b5a4d72b29ed5505e2bdde7ecef18dc29c69e7f51824ad1c9e274cb5eba5de8f01ee63c4f75e3cf97c73c6a88f7a037223eb3ffd9aded33e3884444f103abe5108d2694be4204c5e72a8f006bd3a46698d3549a0f21cda0659805af46bca00034e56498bc56333ebfa5bc11949fdec50e646335378a782d8a6a213be21963cce619ad722813733319ab9ebd9fc74f3522d4673cf1294ee06fea8dba5fcbcfdd23de729492a986c59b52c00f64d8cad028e784ec3207e757fbe1e12c99fbe0c0cfc0428e8ebabdb9ed693d47c00929766633555e13cb62a185a1a87103c4d8433d038f0628b0c14f323f57854d70459a3cd55e0d2839ebf47ef8da0eb8849ef9fce142e8b50dda44b012739c9df346e4c5a37d29bbe439f264c6a84b9faa99aaca09d69809d0e7fa38bc7fcd6217c056d8e0ba9374a67a5904ad483c32256915dd4c38e091e2653ba88b6dbc87eb413db1f99c0748af3a887efe1128167bba0f00720279a4b5b04062a97c8e656f4473cbec8b23a13d86b9de7da4e77e6abb486e01097a74ea2d84203945c331dc5133d0cdfa260bdf3bce9c68592b2c807dd23a5900dd91484b68fe3168f2a1768781124d2e55c2fc8d4732fc0f3c74b8dfbabb9eeb1f3f53b5e07a06314894decfb9055dbcc1511fe1ebf37cb8ec2215e34a3c51559f6f91cf6c46cb7752cfeedb51f8f32fbc968d07b77a44eefdcd172830c512c71642c0610bf343463d05731b9f181012e68d7d854ece7f73b94caf9ee3fb101ac5e2a1c4b035c8f87987215736a4e1941a30de9321a7af3fd1c9fae7c056ee0cb0a99ba19db9fd7ebb0afb196226c8efbb8d75518d0bd1290d979263fc56db99d497aec03fe6810ba0bf73738a374a26b3ec83be0fc7e58cbb1d0b3c52e92e61d7c0a053660a44b23bf50e6196200a0ecb6c38a536f99d699429e9c7158cc2a29e850b129fa62f3980a3b6989c47e480d100a54bfeb6471ea8802ddc188d7e3ae37e42b5c3f97f7f68637ee80edd05fbcac781adfc681a49175fff542346d3b56d72e40215bb162db2321ca172078b85575c2539e828546e51d2f3818181df3d47f22f06a7abf7bc879f8104b68e80bf1359f473f3aabd088b8d9c8b2439f6574d7a65c27058f50e2b163d5c809d4e47e5804d62335ea93ddc78289c5ab399ae9222fc2fb30fb6827ae7478fc3168cb2569f119bdcf30b7e47d6915e4d066cc6a303c040d5a56afb394f44e580d13707bd1a8c7370d8d5dcf4efb9a2b90290d2e7bfee87e7bac50fa9d4323afd48d8de8d6ec36308324349e094ca8876e34fd32c94ec0530250a0009702e05a131e3057deaeae46eaf6b1be56926b146404ed33389ebc43f7fafcdb02817708516720a5a91c65203bd856bb5c4ea1e2159a030be6b5fa1349bf4827bc8daf81bdd6c719dcac488703cbf7e2d18dc4ee9a60b18e30f6c567d8767b03187e1f6532f1425e8f100391de06adf9935c23576d3f24db1de629433b8b8e16bc9e321bbedf2d8e9b348a0e0aedfd0dda0388d58c4a0acaf61ecdc8d29a88c52fd7969185943182bd7bc5387daca0711edcaa6a78e624957e3f7ed9975adddff0a51297448ae94c9c63e261d496980a519387101877702fad7bff3dc7de83ce97aeeddd5aa86852dd3aad73181aba858ac95f80a9d5e020a21fb0850a25b39d5513707b0683515e0b864f69c6113a55ffeb548058da0071328f815237155dece744d62ba607bbd9bbf5907ef3d3720e41f4487d6e9532f97345d9599a65f89e26ffbc3a1f8ebd4609e2ceecf42c5aec1d7f43481cebf8e32fd50f849d4c7122d66c3ad4efe1781d7a9f357c6a9dec5e53a7a32041dac45501425e3c46fffbe405896f1f9ccb4b080910e12a54c1e8fdf4a0759ff583df3ad675a48dc033033b68ad1336757993bf06791ad52dafc6714cbbd826e6217569fad4746df8f4286e66b1fae9daaf5beffcc2c7cd9cb965b6fa3147531dad8e83ea287f7de322823d20a4e92c2ab71e8e9098923a06b87aa0bba6cd49998645ed8c8875fd701834fc54b33e854b2540dde495ba002e30c06f75210fea1165d83353578ec9527c8ccb48f066b13fe29aee1d7b44ac4f55065041a3d1f3a86490a210dc87847e45893cb78893f1e544e3a43fe8c1654cef6960ece46461dc26c159425e175bb3baa15ebf4a19f555e6590e263a2c0ee99bc563befbb3988ce26068e44e6e651f32bc8bac808ed71c879e34ce69a403ab99da8d8c4debf04a0370635b7914c0e1e7e58a1fc2a3ca8cb6c3088c77171f6a2104ee3c79977102bdd3ce229aaf024650bbfffcc5a81f2458a736462de2f3b6b7c5d639508cb80f2e2800bb3da5e9bd32f6eead6e5b57d24bb149a13d8187d3102d09cb3f7d3d2a510be4428688c789af74da4ed2ac9b7fd906c7817f72e51982d95853e7a853a8c83844436bd5e177ff2ac893c13ddefa4c2e23947d229603d6cb240c1cf2a665befcc8005cb0cbd73f55c30e5cb7de579f539409699f4b13f764d34f3ed18904c84ef38a869b14c62808c32d6add791056e4031ee603951aaf3db16cb377aa7de1a959529046767586dbef8b164067506024989eb49b201de7a737398298879277bc76fcea1026d9331e33c6d8b4eb77090c994261f2682620e0e791f134b9221ba32a1c82ce442757bf5c87cc746017bf7d18c2cbf3aa297e7bff22ba3f7f6191f64ffa46ca518035d575b50f3ecea1ad6ce0d68c90756101f2769b10f6d75cbe5e20c4fff16ac79aeac36134c33323ef20e20132d7eb08168b690deafffd393287494d9d57f0055839f05236b4c44e9f35c20f2b85160357d607af2751ebb6d920e29217e21c320a01c4cdc074e7d18468802614fdbe48bfc0238cd592ebd836b5df21e1750c61cb8d64e1d4e073696b34bb5c9ddde4831db47e2c14ac0e77e939dbadb3bf528be7f45750857174bd94d7518db386e60a8b1d551d8c98aed7914d9e1c376bd8ab3a022640d5164f8eb5fe4380a8a68f3899c9b7c07fff23934c91903b8aaa6f789db2f2113684e55bf09ce43e802892c32397017c8c255ce6cad56dc60386a8b5278c960041e8fc7937f920b482ee2682bf766441a35709882a502a4b140d1d4fba3a050eb28dcb1432dff11da3833c31792af28a84a03103b794f274db1a0a3c1e52f7013cfff5399f0c4a78600a0e15d98f96046641440ca9af668ec73252ad011d5f38a78c281ee30b7f67831917dd6a46d9eeb65ede62f3bef41500ba0b009c5ba00209f4c99f194887dfb8f9f4d8ebb61860bb554a181ad5f8f38a7cb0e3dcee4fadc20c74712321acb3205fe85a01b18bcb4606a2a568ff6fac7f62edbb779c88517daf5cd83d08806336ff8f685678fae48e84fbf0e1397e30dcb7d3ca15c9529aa0bb6c39e557cc2ffab6e53c894f67e4a77a8cf8f1e533103732b63d779adced8c66987a9de59b37c77c376552031672fb333e446890e8a0fc447bf5f5c02e420b9f2575b74b19ff94b5eb00dcab90ac00fbf7952e4c978b5b9c3cf1b3329e0771ec5d8eb81479dad3e0d685ed94ea3a59b2114d799d0f34341d46b8d306fae6198e4976baa80608382379631d45f56b6f42138a23bdc93ca5866360469a93970a009a05c3df2567532cd2de1549ecf23b182ab2ff1dd6f88c1bb7d3ca46ee07c4cb54f06999e40776403ec55f2a3023457a9984c49598f4d1050e256aec2893f3c4b93c09f8f8940c692c0d1cb903110777506d06ffc44af2eaf58aa36453907da76113622e5a015a9ba64996299d75ae9dbf1873d1fe2b8f4b7dd162bc59a277f77ae7318cd9e3d89830265cd8af537934bf4a092b7b934f0eb867bf29c86cf070bcedb538c714b8ad55fa5bd309c18ab9bcbdc36f89b483b56dce5c1ffdf4e3b54cbd47455b5e01bb8dee3a04de407dbe50ee53d41695fba3c78aa2e90808e975ba6a7187b294cf5388cb17241a15d8e8d814c1fc2221198df77836a94153f4820ca3c56f3b5ff475152f3a7e2e94247fc5514974f128bfa9243beecdbfb85d8f08bafbea5533b7ed4d7ad687c86eeed45ad767170f45781c33529cb4e17eca00bd757a59e6fd900bff9c32d7afbda3b64b15cfd9d5e48f7320dd28bcfadca14cb04a524cdfc492fbc59f5fc96d8433e93dc2bca85801b51c90b00fef4e0306e370ca471100f73109837f3af6b325c23539bd3d114f4db2bf113f2c8d71f0aa8570872d91b5eda6f22b4e4f52780554a9b628584be7cf0e1106367a0ba02cbc926282ffb0776363543e814f3bb56704f07a43d72e5b0a93771f34cd36df0923453e9703f79d9a20d18fa018b042c8a94383958b7f89550988d7bdd99a83b58203cba08e81aa13b8867e2b3b9924d993a128a055c2aeab2018475524fa65b5f458ecde7132ba484d3d5e2ac75192347d578a03c6b481b2e5c90a545d2cca9ba5164f2ee1c246dc6e4aab36af2b3b625ce12bd774c4c3a0b464dfa4b4ddcfe0c4c303e625a14c21493408ad75c4601f110e9deb4a4d7c55b1c846d44c446681a6f2a5130bea580af9811b2289924a606708288cdc5f748378e703aee94f80edeb802925eb019049e9f1db891e5a9d1a6f74eaa13c638fa0f334a26f9baf15d78ed19b305b8503cd7797dd644b6e24b216c98488bd2fb3f420e7dc97417be85d8ec5f55c547ea2cf65100e5988f44dd198c8c43c1071538d6bce731f33e41014fa25cf5c7463c58564a3bf0e654f596e545e85f6c72abefd84bc9b0751341576d7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
