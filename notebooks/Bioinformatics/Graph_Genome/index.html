<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df35d3f47931e04dc72718f094dfa34742f0a46efb6d114b581e5b3cac52088c264214ac0dd25aaf91149374db1d3ecc4f402bdb8064dc18429ab50d164b8686ee687539c5064e35c3101cfb4987be891d72ae426e8ee931c96982c71646934c62a6197a3b2336e4ace078647fb7fa637bc9a61a431d261c94073626d2d38d90d3356f944e9867abe73a439d9124139729ec2918c871db43085832b30024ea4bd2161e67c70a0796bf5473c2daa0c41e9033a2f5b0f87683df4ebce96051f60e15f930cd015c4d809c8144cee839a8379bdc323627601398bed306bd7bc7427482052f556b1f50141179f1df0778e1b32af345e64eaf8d93965ae2f37bbc55959508f5b8d7fcb3d6ce6586bc9387480497d5e9a9f030045a20c0413daecb21f5527f8baeaaaf24ac9801cc264a53992097caac58609bc0f79b76bd7c8c64aac9aeaf1306b8400b20132e3c41283798fb82db5c46bd7736d0340bcb77265b91699cf5ce26ac9a000a8e532953f387201981a690ed5c990292847f1e74e87c6ffdda0fee00d199ef08a3022806a6ea43e9a7d06d319cf317f8755ab35047e6bb353e4fea20a3a5d41ae92255ed43fe6155a8f1b862c392103c0933ac1c28fd8defa7e1d27b2d5d4b67e573623e009be1cfce475e3421adb39e3601228b29c444386e15361164851f97e819a6161c2168bdc3f4a32e8bc2495870ba9597f3b092bab4132f6c846cca98540babd923521682b82b73710c7033c87850fbf4ab85bcdfd77b9f812b3869e3e1521a923591399e6bdd0bd19a8d3fe80676ccac364e9486622943d4b7bdafea4103ea09212485a87daa998c0821a74d60d9224d972d7183968ce2fe76b21357e99ba189be55e5ec97ac831b32136fb0039019b74172412492f31ec2ab72775196a2a6aa6ddfece8d1cef8ecb9515f5a2a1986a55b295d45e6e865794084cb03c82e9d7fe4e01bcc01e94fe5304c7978926ebc311f3d8c70bab1a7d28f22ba73e9d3e354da1188980bf6a6656889669f546c996a64e900576e29781c13e0a8a48ccfc9371edc35aa1d1b8dfc02337b59a66dc74c55ea5e69008faf7184d708a1707fbfab90fbd3bdc3bc2f356b27b14d56ec950195083c1ff4ef409db3bf7bd76c6f888647296fa08056e10b3e0c6e793ab32d5b9fae81ecb26ccd9149cbded024bdf5a35630cf160a2e4d4db1710e116f3e06f3658126a9484995fd14d655664c8867610be20a80d34b4fdcc48092f30a58a0e7d0c74fd68659b78197b7ed719acf93e3291907505fc20d6972a6da1fa079e9fc4b69d92ee665cb02ed51779778ea81cd5469c2c6d3bd3029e6e39a15a71a61685c43b2c71535aa9cac8df06326f620fb023e269a45871c4ddbb336951abf7aa0667e775201bcdd9b24cac6b89dc6db98562603980e148d4599c7b9d2c960c423a3f467e52fbf64cd7531b1e705941ee45045e064868508ab0f47c6ee08b185966c7da915b3cfb69cf4471391bde911fc7c2f3b43ab66de4a71e18bee384ba9967e44eb02828dacd84b020ccffeeae5de787270b771be809601fe8fa73ce88837f8a17686dca6efed6bc42fd87114367dce2860c3b6bac77fb184e18770e04dbf5e8e6882c3a5f6df8191af615b26ee0e48847c75e88133815d384f6559f9c2a72df7df04dadb260a6cfcbddfd66a635e50e10cf354d0c286e3cbe3ef349f34f0f5b087d094998054a3ff5603b90e99f340f035c22f3a53cb938a966f34cffa5b267bec0a5e2992925c00a88e85518450853dbb2a1114e25a17630fd10a176bdfbeb1b3d0b3db35df42d834438278c20088891c976de23665804b6a4b3b16b5d006371cb32612cedf7c909f75e8d9ffc50b0c68390e188960695a9de2242860250820288a735648f9c4279b746e4807ca924160936b26263022ff2386000826f96f7dcb4ed3b92dbbb000a765cd8db08948df4c28be93d5868ccc0e71676bd41058cbef96b290617e5ac682791d76330ab7434683f2859f2337385c2b3167f16716a88333b1288028f378cb0cc7b44f39e21b467faa8089b9d7dc03ab365177cdf30539d6d408a093aa8e29c3bbb2c65024fe9e24beab73779acb789bf44f594322e8b77b9a06b54becaf513a8cc111b69953d5229148efb425f4e7bfa83b582112415064f127d0814853bf0b646576d9cee3bb593ae7f8702908f73994fc8bea727d3d24bbbb5ed9a96103070d2251cc3ea28e0afa656f1e342a88254f6e1e26c26c0d3bea9cf25ccba801e175c3af9c5d68e9b499e1dcd58d5e036beb31bdd14a7895520c1aaee6561d7c7999916673727b2bb30dd6e4520163fade102f740bc63462774a289c9fac2b6e63b9cc19a429e064ad2c8abbc11d9804e56c1d0c0b9308ec791bab60d9a94c5a46e736fcc582390e1f857789634888a6645ccfa451117c9888c3a8cbe4f7b37c8ca4e2dd644f282c4e8bdb703f680408c57b5e373a4facb1e73ad5134c3d5737f3c03516fc86e01b5483c45c63f4dba65a6ea8ac2f6eed2b95bc89f5484bfaadaa68e3b8c257ca17e062409d6225b69b7ba109d061be35041dc5296e3ec45e2d749931972f6d3d1089c020d36da2604329c2fea6f455d869f237931ba2fa5d2b20f8a6bf8bded788ed51e0c510ddcd46e7bfdc01d22f9e0a766fb934f7c05865f328e5f5385b3eb082e6aa8ad2b41e59b9030c50006f66ce47ca5bae181572a06ea94b906bce764bcd5e9bdd77c683724a24f9a26318660b806b75abdf15be8d6e96487e6744e364cd3d565e588ab3adf6a4326f794a49786ff6cf0c21c9af917fe2dde844894210b19cb5f51b06070f8d91c98e54172ef5468b3af6ec12fd026fa4336e3a483a0bddd306e17fe56162d69080db61cbbc7d215fa4d27c10b70a07494d9331043eb52f2320b210f9c2bb20b596c4b7515edf8284ff327f00de50dc67b2460c2ae3cae6c03ff7a84d945fc26c054c235ec48cb9e7323be9a7c83d8e6d40f6251268e745b8c8c4b8076f51a3f7ea6dc12602b7e2847008e53dc594b1b1e21995ad1be7c9c92ab54ccd1c8e0255c7c8faab7564636d8c17f48567a54d7592737cb5ae9fa4d5c2eab1fcedf03c91a7f2e3af72e4bd159a025c88e1369c259ebf087ab22f3766290378185210c6499b66e0f8f40e5031e79905e634a8c5cc8537a1a2588a4b0eeebb59e05fe57e12e1d9011d27188f6c8a098b9aca788b6afff81a27535057ade85859ef3e2e533e3ff795dc5f8d8cb824052d438e45bd627e82a19056e3695042f8aed3bb10a6f2f4177927ad9da58a0b3db64e4323729961ebc14c4cbc2a5fa9e7e454809b01b2f4bb96e1f1b7119f28c8e00d725eaea57e0aa1600317ece1d0d7324e30091f41c2d49a6dec33520c29245a9e1b823a7a93cf8c89ac1d626dab92667e65a6645526f2582b2994c3a310e0c6f8791e9223ad8aa2bebe9635bb4cc6cb97e19576bcc73ec3e56ab7952fe1079a5a8bc5e71f8c468759d09f2a88c95c091f8a265630107484e236d99c950eac0ecec1186027ff17c35c1fa6ac6f1aa5ed570e4321e214f1531133345c5d82ad8d5803668703f64488c0de50f7db792fe21cdffce2a551ea0454c7d02c046636e886ee24ec042af50bd3411e332b41ece857a549ba46a79dffcdce593913abd21b8af4160c7a69aad2590a3b0945228c25c0fa32c1b1f0078aa3b3ee2d2a6c6546c9ed3bc82b46f534772c138c0ef638deb51208f023c5bdab05efbb27f77eea655ec79fbce1798360fb05e3152a4fe2dc85699112b1fc1586115aaebe22f73057e9e6d5e7391ce147319f80f50634847623e45820f921017a0ca690a14d64d8397d9d7f9c6aa290df158144722bc58a94a3f7010e9ba3dacd2deaaa5d47a61b0b584125daabbf2713289add06477dc29d7189899a98d8074d753c6c623592f899aaf49eb53003a55e61a653d08848ee2467301b6ad7a7ca049749b37ebb29088335664ae0e2be517a871bddd40899551d9d1f36e66222f7bae90a47f0680f70274b81e58c2b5f9d48d3e996a5ad481a5bf0a2d776096c05e16dbd8e92299a1278eda490c4b1ec909180e3c5c0c8ea592bf43512b8e62b41ac57e3c9dee8206d37f79acd2e1635688c78906b944d061b487c17f2978b56a32fb56c10eb7dcdde0e7ed2d9ed994f372a192c571fbc68df60114a834b0e483d14d481fdd061d997a44bf4aa1d2c76e55388403ca072bdf65cd8de5ba4a4b440bf51153386d3f40991db04d3068c8e14df64dcc5dfaa76381b32d250f7b5b9637aee956fb82c77f02a9476529c10e6d5c8b7172cc87f3bce4763993c50e321723f0686ca569aaf0f170940d0a0fdb1fd44382189b79cd09a79f896ff85ef4b7bef8e694b52dfe5dccca41f5afd7f59716e1c4dc651e4d423a0448893714fee930b9a5a9c39c920707cbc00246816ccdb1fd9c06d2efcba7b40fafe070cdbaac144aea422388ae594d4259f058c548fbece03712eb97669a180b98a3b6f0fc3c0adf548f2aa68422e76668ef37ead1fbc9c602eccc50ae16153b5b9ffbf609ba05e5b1cda696c0c0f9a7b1e8f30f12a3e39fb3ba4852c52418498bd93cd268412c7ae0cf6be1d35ee588dc5697ea718a3de9d17710915db2b0395870757add18891a95d97e197659ac4d6b992b2c2041ddae02ed63fabf4e658c6591fda3ee4573da2ae2d92c2d2b161754429298352724e7b52075b98d04752faa9573294d69a6a0712b332a4b6754162b8d36bb2a42ef5d60f22307130c5f2f32953b83c65bbd178efa548d67b22006324ddf06ca0e394f29abcb9fba895d37229ae4b1bf9bcfcb8605ca7fe652f7903eb68d2f0d1024cf3ee385e83e37430327a0e36f3e73d47babd741f25219bc1ac4379e5dc26554addf16d20fcecca170c39709dd6c75991ca890969bb15ef9d7da4a033151d8f429e71f17553f83a8316577c62bc78d2ba3249cb9948d73868350e86aa95aa6641c873d3cde9f2046886c141452472e4dd061062b31c047afebba99fae5b11006ee80b8b54e2b6232535dad4db81697cd711438082469002a3f9b6667a6b978f6a38500a30387914e219b8e539e510896db657ff31f135c3c5cb58127f71f459ede11345bb8ef495d3cf99bc7836e84dc87b97d81afd58fecb5278e5b4b059cff773f89a757a326e72725127a5a7c8f581f9d3c18ced63ed8b4b54b5c13f4066654faf8db336b14e326862bc46f923bf3230f3cf58cc1b79495dbd991e350e0fea961f537a78a47d9d3d4ec679554eeb111fb37972f80f34b676521be776c95b5738571d9245778cf6a68a4fb90c5300547a81e9d49605ff6b3b7109aea4f2a44b87ea9c5448386198845fbad482c5c0f8c2bce35a0b0672bb0d521b6eecb15d68183d7f0e5c3b128b94c0e8e0eca13e1df404b754bbc7263310aa2c35bab1a6d020ee60139d416ae21dbbcad1f583d904734bb4820b10170f8104d60066d0c81c2c2312ac937cbafb495d9d5feecaf4e04456211b873838ea3bd6bad97eaeef243cb68474f83bbf88e2b15ea6fa354c17463eeeba0dd925ea31edd650f0d54cd6d108c78dc9938deac868eaca0abe65f4726157b1067ae6a4951ea8c3b15140970b2494d7f010ca8da50dd196d47b23e1eaf0f9ce61d46962e53306b7ce849f36b1b98b4f5495d8562ae5eeebd0ffe7fe294cda09fbe57b1b4f4371d0cc244a08d57f77d804e848774f0b83baca5be83b5abdae2782c6e2a4f0991aafa73a30836ea7d092856501703d03be325e85521ffaa9b1543a1803a6b9366cb24bcd5ffae38c4dda1665f2d7cefffc3b378e12c45a6d56a031faad384e10d3ae44825b6bda44849a1a49caa0e25188dbfc41b13d6696d1db28306e2d658dd764cb1a9555296f9d3b1707a0b188c1098d542f884d9fe7586e51eecb9b1e8b33896cd6b47f7b95921eb1ba37858876ea6b9d12c308890ff668fff75f38cba6ceb363b260f3a4aad3323c3bf981c74883b471254f831a90d3e720aa40d59f65eb19739b09539ba4042076377a00bb2d63751664b5092c38bd7b610c7ceb81693d01e300aa9752db3f56c19d5ac23c5dae43a7819b35749c1d64b12273ea0d95db4b47a4aec4cde8385fda985ed74182b638c49d717a6f34aab1407f72d0b9dc6061ac0e8f3c858c32a44114d880309cb34a337a52ac60bdadb4e7968087d703119c32c1f887f03139cc8c71b2d44ab9386aaa57d6f875789b2f6c08b442a5d82a761f441036085dfce36786e37507b132ef15ddd77ac83b7ca8585d5d2452fc46d38ce50f4a5e65a0fccee71c606df09b7b7cf14b61f5294ab43642ee188e9c224585e9fadb8b0f0d8cf2bc9fb813ae0f78160b5b3a3bd92ba02534c83311581597a35036aacf6ba16256b5458c07a81fbb4dc07094622a32cec09fe09589874c15c4c87a1f11f5fd6a9a2382ad7065c8dd23d08e4b01d44e032d1adf31f9f9ba4431a7fb2330f68055e1071eb2caf24b18462008568437d21b676300c8af601d843b355a27558dc4c11cf503b0152b481d31d6b4c11433c428d8daf0b0b9954445cdbbc44b7df723f31acc89b26d8bdfb627054a6015c77adb02d80d5b267b94d2fa005bc009f93e812c6089e7d9aa7064100b4536c8e8087f52ec7796e81eab639c48f13fe0c839aae1ea73dcda4cd3481421f3105d2b84f4b1388d479663f26acf040ccbe4e3e4c2a724183afb5c6bcbf4bc27ad4a59a6194f9dada6c1c0ecd8ddcca4c37cc60e0976464aefd25d062490a78bc9424e200cf163b406f69af82fcbc5fe8398859cf561fe9dd667ec9f37ab7b20d65b2651c86a71b4884e59a4ff18b2fc4fb834383db3b02abea996a3c2521939630e56a3eafd609dd4398cef72f49462988fa77cf04b0b66e71eb68fa03bd035e37dea6d4ad3c1026f88c9c36ffdb47eb4c75fc40e27fee5cebb46d9819850cc7e7bad1b1819527cc7ad8c034216cc139a1130e6b42c545fecb9e576bae2248c938a26ff156b49f9624e436b15360f6aa360dc56c6ab1691d7b4fc4fc209af656fdd43cf250055204a6c912f8dcf91abf6c4eeff1239083fa5615aee7624d9d466704087f0ccd8f8873cfef1da46b27b14c17a94ae6e0c8ebe81cbc64378ede35dd2b778c9aeff05136ae6f7583a815b2d515b2adf573ffd42b7cda602e4d09170e1427f358fc028209735ac22c1341184ed1b537d8d9e8250de345093df213bbb8254217ecee4afc3a694b0cd1a5fb55bdebabf7ad1de69cdbb864e29469480ff990fa01c3b2f9f0d9c464950c563a61c34814be1cd6408ecf1706bc72447309c63bd35e557425038d4e2c6ec8cc6acf38e296e1df85b6e19bf58571e70eb0307e1a2fa1ebeb0d0cac120d42fca27e1fe5fb6b1d9618c127f4fc90d1038c985f7dd5825a9ffd151aab64dc589322a2f1d5af43b90521faabb2395003ec6d7e5f8c359c9126b4dfe84dee03b5b05944f5d22242bf0600b974d35aa483eb984976162ccc9a15820388369b8a52687f75ed1b625070cd7eb8f474fb2bf9d413d06bc8a145252243013a9c306e01f1394e01c7d60c8db8584686174be6c0acc31011e428ae1c56c76b1d683c9047ad7b47e9ec2e81b204530d91eb8f20392ca4559f692fa83b9a9a24fd551e6a2090cbd23bb7e65d188ccba6862fa962504ba6561cb2719d6cb240410578ded664a3b6f625b4fe76c6bf47701c9154f3a596d8d42caace43878e44f7f9e9b02baa3841ebe715cb78a90dec748e4b7d9bd3a7bd1f2276f1b324f86a6585c0a41a384d09a13d4e09c62a8f1b0784cd4bc4a8c043b1e9ef9446ff3c02644347daf88096c9b8dc409c2e54a4aafde84bdb8381e91931f10e0dc82f73483c64af736094a68aab8cd2f1ea968f1f31bfdd9455eeca7aab5d1183abc574e15312341f54c55c53b046c9788f94ce3f3fc3fd5a4a898692586b8d4337901135480ddda180ee08aa94cfb3390917c28618555c75ec816872d323cbfbeef5f7b322638071d562cc1748bb078af07965b88bcdc37e429077e8def8087f6e3e888c6e16e462bb46c393417d601c27f793286cceff4945887474fe676c13fd2b432ecff1c6fb797cf553b6383f33209494d42fa5e03607e25cb54009a03e6533cfb3887db9248fe9efa7727d02a4901d4f7c9bbf52d94f8c4f9ccc7eb1adf767351cdefc1bc09c4a6b6116c08ef4a558a8c0a96fe2af5f7af0a58cd6ba8bdfb285677dda1936ad4c83e2469cc58dd1072b46c70450964ef7bfc7b51a10cfb59fac39d90855f71fd5af1addfc3c533b2b45793815365445bc7381d76c638bcb14bdd9037e1babe2495d4b17d0115f07e5be2c86c5e874af0e6576f2f53f911ee39393c181bbf621b0fc53b21108c657b628bbdf7e15faf3d6ae440d031ba8e8b45d574f831aeaee6f6d7f97e20a1feb043b51312525915df2f1e9ba100a6e35a20ee61c14dffa196a2d3a9a10e57244ea60319ee60abd166b0b260df682abf6abd2de6a92ea426afb2029d532d31c51e4084cddb89cd64327cbe80578848f56b6fcf4825d27fa7d4269efb4b89a06146849b73e3acb6ceeb2e6d9ebe20d11dec1542d9fc828e9dee780a1667c26f0639a936dc87835d9c96b970e9f2bab1dd399e64a77bb9d8c476e16e96c911c2928ed7b1bb34184826132a31d785b696315cc914d685fd68fa534648101a552c076e9ec71dbd58e39dd1f3f9920245b44b16af4539c3aec31b1183ff266282792f2234b501a8c08d60f8b49c0a52e48f21fd2893e54e292d922d60a8421797bd8ff447fb8c095e2df769741d0ee30a93bc499356a9bb457e7c2f7d7d29863b30ca3a830cd409d4ca19f217f2d8a92d2ac1be1604f71c619669dfcd28cba44ce55d7e10f26982d1dc22600e0735889566a87403968a8d42b87a2245e577c9c99d3b0b3442e5997b8583083a5c01800b04a964d4db6ee1a8be49da79e51c98696cbcc47f923e2c182da092d6b7b1bab76c7056afc17d846efce7eac64a64843cc415207cbde51b98a2fa8c5412417c305fd7096e12d7697e84ffe4592f6899786994ea811f2f2c83beb7caffcb926ad7b7251e407bc1784e2c4ebbb999e146bfca1730bf32c43d951540bf2d3e69b5cfee810b4707326438428cf7632b8594b10931831f338dbbb720c2c3dca7a6463429a0647f7a02921080a888d5b1660943e5771a002a9a85908722389edeb4d2c0e257d258e0179c2fe80580f8991556afc00cfa9abcc9a40dbc76a4e939fc89ab63bf9c9e6954bcaa4fa91644854141d3028bb7e41a0fa0fc93e414e12f7bf1da3eb843a767a2a768daffc7184484323bbec977906f6fd7d2098c09afd69485a146e61dcc35e77ab7fdfc33864c18b36bca280edaf1b7c15186368d6c4bec533df2e1bcab2c81985bac5dd48d44cdf06011b242a9f92c4cd65af87f2df422a95e35b4b3e7f32221c1240785a032f813452f280058731be710b07b6db733aa161cf0d4dfb563f256e277aa482af9c974bae8f61ed1e8ab47671dd215df95c8f4af13b95579f1c2bb523f87321b527b37ace0babc33880183aad613aa25fafc6dc942d4dee5797aad94416804857f77c6084cf4d01832f67df519b7be4d69eec983732f007bc6a2947bb29de66927a8c91855393be92e5dc7ccf27481f9611263cf4f12d199473b77d232c12f220dadfabb04807d2d5fe6f14f9c13e0bcfbc887ebf888daeea8de61e2c78000f3cc6cce3fed81db3d59404395eecf3cab0b7bb064539c9ca29fef1cdc00398a911866ce5c1336df08d70fc8dfb3dc375bbc3d3918257b8cada0f4f441d7a6ff1f57d83a743704dcafb2c26685f8443fb48b2962ed1e63d62b0040f937767b4d103aa83afb3d36bfde39d1be00e696a2ac299dbac79df1be2d608123fa2a57e025345d7a9dd29960432d8dc565bd07fc472ff1595eeb1aa4a44a18b5965a2962231097cbd05e58b2b00ca31a8b9e7c79ebb96842e5229e91921f6b9a3c1c030efc0351d4036d6811c62207068529c726bac51b84eae7fbff73c9d8c34827c839ad794af270e069d4d527a11f484fc41260c4e6d1ddcc4fdce16a07b431ded738c44adee557bf98827e5796efac7b8d8fd6226cfcb9fc529b03d021621652a380b3b99280417cea8221c91a22929fc6fbe581dc99c7b642ae5ce50ade975ecb5f3c5515a4339819dd970baef9536d29eb71e42231bbd617d50dbc8fd78ded80ad24dd38d1076a5844326bbce6377bbc9cafb3817ab48d63ac02627b667f1f146104e3604f9e02149461bb2e8cf43d82a66decd0e781a7a46f90962e9da0dfb7413172e40b6c0b5804b731c26d9c1c1df4e0f6328f09d0e0d8bbd2d25b67f7bda36599785337c93986c4b050a5809a67c94eb43c26ad45072e11333714e2d5b57e9a72ef6c4e204cae44865e91456a69e88530a1e81a878207ff568f741959396b21596ad4f4c4cf7e79c7e3a5b7641e8d3aa6d6b41f5e1a2569ccbc7fe7a4cc13fc25aecae64afab5c8abd6186d38f7ffce71db548b958db165f53c72127d24f87b1adaa0ddbf8a16f5b6a663eba0c6a608ac740cbfa138182928a965029c38ab5e1427bd1121abb8b384361cce424c56992d3191a8f02cd26a6a872569a5f5307076c20de1acda8ed8813f8cb0d34019f10b554dfb9b7c88ad07b7bd6801b7694a1459b495d3d94c62f1278e1d3361c488c2881a8547ba9f91d5dd0249af0401e1426fe26f1fe4236178510cceb351ea0f64c466f8d35957ee9f85afb425f6a78f25d9ceb155e1d4d655442ce80784a93c3e07e8b376e0c48c0bf1d12ecbc36147a5bfb038d5b56c9a9941e3b441475fa06f3b7188b0e476106fbc0a86c12d3e411e9ec56371f93d6c037a9f303dd324dbb4e7d1b218dcf1b31902b97420d41a88721757761164362785591e4b038c4dc89cb16d90d61329ec0b1b9cedcb522bfb0524996414cc4a481f496b44d257f148a0eb84b013a58aeb044527899be896b1c05c6e0ecc9fbf7a3c1b4d4d8f9211795499eba6c6423c169fdff6423437bf003d7fb9fcfcd5955fe9d4aa687ee29bdd270f35dcc6ea22c506e7a8ab33e422df8d3012ce964f4bda90aa5b9fb925da83d934a5c0957100e24511bf4774f884a76d0034beb14ce5dd4c9c1c44f949b22de4c28ad56d65cb842b574c666dfaf19d61864b3f071f3c4913a72e80737598ae8c4be0a5953a8723b66e318aff66d3cce77f6b6239104289e76f78bd900b5a6a71aa4aedb10ef556b68c17eb67f602908a9664eda9d37921bec1bbc904da06d8cf26d4526aec9a2a7442da9743373d87c78e7875ecccadcc38f897fdaddc0abd963b9115eaffe1c64c82057aff9960ad06a8ca789c43c2f409943b23c5a69c3540560221139ae1890a5b41b89ec51fe67cfaad4cf4a6a76dcde4de4cf81d3d65c027ba0e36dbc50cf1486a47b2e1f45e01d21b02e7dd1b27ff02538e9c4f4e0aab8da985f2e5b73d38e8856c7e93507e4b9fe2813b5e71812d04e6bd5133b4b488714c7dc63fd44c37a7057fb4a88c62e9b55ef0ab0af152240ce8d2750e7345fa350e22e50f74b52db6abf8f34e20d2973e45f2176312f21ce80b1474afb8af98e68144796a88b8a32316f12652465bf592fdfeffca02ea2802aa67293575d51aa42f81d03b38ff3bcd235dfa39e58ad99d165e07172f74113278ad82989b4590a699d55084d635f4ccab331fdaae059183060b5937a3fb9a58fd7126d1aa5b02abe14fc02583986cdbe319a8fc34838b2c81300afc8d1a6808d1f4a379833568f424fce8c85551ebe86a203ee8f776971b333a709bf845571f4a9a967625ca5b5ac8abc82e99088e9edec6511986d022279e50ff76b17f2fdd87345d45110726c916074b9f0b0336531d940f86affaa3de26cafc6fb0bdb7e6ca4348d687302049568b2f09f7f1f9a53716eee6cc521f14a6763d3b57637522ca49239761ee1cf58b97754aaab8c1a5552d9a9cb3306773b0ca594f126210efa37187bb23a51d228823bfeb3135acace696534762a114d8823eaecaa7c917a94f64f1cfb0ee567c6305d7d289b9a1c86845dfdf769e0237f4d44ad3f49321cea477344987772cd09a886aef7dec9a15d736ca42d7c88c968970bffb07f83b3d6cf91f96869b2963d32f399a5489394e231140bf347e5b268ee5179e7eacb72d9578eba009ee61a0f6c2fe6244018627027141ba723bde5460dbc2809afc7176c7ae4c8370be217be6129de5ee6d35dfdf590f77b8111e608acf9aa79a485db58a0e5fab6d29edaa1b145ce041ec22d7b7c520da681686f593dea6e83cd71d65a945868a67ae11452930d3bd4cd807361a36a11831a1dfef9586841cbdec2686b8fe86aeefada2ddb53181422dd45be30c53083faf0a57661938f5ee0d324ade5d78de4a43e2784ca4258cd231da0a4b8175a440415f4210b46711a7a29e9e4e2f1e473b0557181fd9b7b744470025b54686f005ac15a7b680ca906e9e370c6a03ed702ad713868163696186b41157b5e375ca72a80f1ec0df1cbcd860427e685d77b3a84c932702e190c78e1dbb1cee688de7112da3410d3f389c1de84186adb3b1fd16406270d80ede0680ae7a23c58bae33fd32dc26d90e18052ae4377589473ee3bfaf6123fb845f1ac1fac6c801e3deb052cec2e60c1aa72ce25e17c013d7f442431ae429b02521bbdc4367639bcc228e15c172ced9a1d159e5c8fdad76554710c4e766e444f03c99e5ff042ade7711b0d4cd8a5b00bc029bf3e9d6dae943cb73919898ecc2f83dfe7c5dcb8fcbf5192bfa2d34d44745c012e3cde9cbf8a3c26a72dd39b680381f696411dcba08642b65811a0c94712b844ec5387a0affe2ea2ec76947489a369e3e979af2d0d7681e9d23b03b9939cef7beced7539c8a654b7d6130a64def185fb1d045ec4d1dd7e1bda32358d6d7ff0d09769d6f1c9a7e65802daebb351f84f89cf4d48326a6f4674401b25c146437e88ad806052c2a430d08a7955c34af7f8bc4a4c68fad86f7cc3c6b22f1c3a5a03464f6e05d48f568c656d1a0a58d16e2dab9d3537c9416306c28894cc11f8ac703921bf459476e6af169532ee03f598606b461ed3d57479131aac7080b9efab171cd87835a9f4257b04b31981246883306921a690967eb3ca50e36e7fc9aee566f3803c10309f8bd933d648b6602da9afe106a2814a69a53c310cee64e951665e937eb02407b627342d6b3eed546ca3fc0913e3527eea69e0d22c0980124b76bd24785c6390eb7c5fc35082abcf81fe1506487643d2ab7202ef7bf63e8f04054002b5ad9ea28df87ca149223dc1b0ee9f29b366dfb19bf5d4241a91dfe4215e3e6a1ed4de6f4926b4c5f72ec1757d3f3705d42c659a3dab2973c9f4c13604c086a9097ade413e7176b760bd07d67057006cb2f2c02a56dec840f18a33e2b0e16ad5f7ba8db9b70d190b0a858d524ee0b31bb0eb16ea57540562492ae00832cfdb749220e9d84e76b4701095e8a951f4852eee6b03f4e7be605296529b61a45b3ec65de9e0f2b32c28eac19fb721ccf5fee313abe585e9e58e4b613895a0a272686631987d1e947f22ae8432dd0d802567bcf3cb9157074cddf2c8e0b43fbbf99b8c4a1dcce7439272eaa4f11d9d6dde9be0667335e371d5dd266673d888e6cc57ab51ace10b920557194b96dd5ec6a172f8c537f6f3706c5aeae225c1ef5c6de6817bb66714680ab98ebcfd83bafb460a29b83a26951b57c49d4a776b22c8e961ae2b78866a4653702f1069adcbb312b7b9aa957b22d7d7dc27380c613c209d122cfadfc57818208d803ab447d79ae38959de21aa35e2d8ab346dc1d481afd147e5c8694a80ce07f3daef78f76d2e59493a30e83b3e3cde9765f232ce16eda0821f8f3556cc20345868b348aff1aa48a8af9e67a3e2a59073d35ee811b6bfcf20ccade4ad5ca0f6c0a5f7e0fa670d76762d2b1be02417e67cf66ed1fd235d6e69baeb388c7b5ff4ff242d73bd1887c393d733b0f5fa02756e13230a65a54d46a18cfab8eb8fdebd1503c255dc5f96212f7f342d185805dcaa509c9f52822355882f85e31a5aa4140e844b338a39de92b86b7656eaf8350bac8b8ba736d110c487eaffdc7fa0e755fc391ad01f9fc5179f647fe4b54fddc905979d9d5b1bb9030f4c945bfcf82344aebc63411082482dd514eb0e1735c9b7953984fe2a5874bb768da93ec654f6574d7deebf5474e3b4c665ad1313e6154eb90fcac2bd58edb6a074ecda0c14201c125222395dfc25484b2320eab30561eeb751b2c46023ea8f9b819ba6a8d0c8cb2d46b0c4a6f0c6bff99c39567b27d55a2ad4768e28ac26886d82f09b0cf52a22a08a1b183d2edd9b431470ddeca51b4e27ca8303874bccb5f8a38a548b9d5b737f2c8ea1c6e79ed309b7c1948bab86ade9816362cbfd4791e657203fcc0b83c5ae77f138e5da7ba8ac0f9faccbc1b5030131e08a7fa241f84adab7fedeb530770da0f06e5a38dd4e9f1c786df84b36c483accde7c28d8d1a700a06787744abcc9d787b534143d3d0730365111f3f533f08b64343df198b5b4d67d2d06e0d3a9326c6f3c17f96f6f994669d114dff7968cc6c0a564accac0f6dac79b9bc917ecaeb1395c329c1f4047abc3d489dd645b58c507954141d9d2de466d3c86dd39c0953267b22ca53521e5745f3a326c610f2b0cbdaf6aef0c4244b04d3302be800b585d60f4239d697ec2c93e57e90f7a5dea8627ac24bb1d0bedbfc97664dff36d6514526367703988f9e60b149893cc56cdcb16624801f3289c7b34818507c498d1a3269cb4ee673416093ad102fc8332557781a61835e977908ca1e146bdd81909ad21110b1ec6eef3580ee660dfbf86dfab14c9772fa7285abdac3cafcfdb0a1b2ab5ae455c62c9faea8672ccf1a8f3e53172acdc85e37785cc3a86a9ee7159b7101eda997ccb5fdc65d1dcac3cfd80e47b7d6b6d4271954c6d4ec78803480056a4b44b9b9b41aefcd48028bd4c5b33bfae468f16fd9b1d3a50d7ba689f47fe1dce36840f34bfd8e76db8e7029e3ed7b5f8e631847341edebc465fa507b4a73a88f714c22a24ae66d3bbb8647dcfee9d63dd0d58c6a1e28dfafa68e735cc55c864473018ec728dea3231004e01de3c09e4562b54ea6181b5a4b050985fbc6387f2fde774d8de72fb73e8e1c5ca455a65f889573425a37a652190cc68ce8ae1e1ffd4f8d9726b9e2728e56ad26c1aa2b2f94237e911b3d66de0f2d02db0b0ba1d8aed94771b087ba37600edd99c77dee388505754d681d46ec3bda504760ac6525ffb8fe310df5eb51fa896b50a65e2dfddbc03037c24c34c2c225b23aaf52db1333f35f19ca82546b762514c718775b424c195860c4405f2a038a147ecc083d1e8b6b22e48f988aff9daadb0d765cb4a5a900883da4e881026f0f932a12c09dd10b7c90e032a05d94f3ffe7139cf4c502ac203a7bbccb9c09b41f51d0acc31965bf54880ef5d4e4e5f7f24ba1ae2a0e9efe2944268de017fe077ed5b0137465411b4d41ae3613369e262d648d449f5f5d617638a31069496eaa9823d37f31a9ccedbae127cac4d326f45eb5e4d29db5300aef172c257cdb0b1f3e1083a546e8f01cb2b24132d6ce2a247d4889fd8825085d3e87ee10d6073b9fc93767e15079806c67b34ad4d5cfdad043260ed2addd8e2a75cf5ef28205219b26d1ed267e45b1f0ae2662c73b5d31d15afbc5f376a504879986c9c9072af661840f6ced7ea19303dd9367222a5285456cc7d3da97c16833fdda3a1f60455fc08d53b9e5462e5aff5510990c006d9f02195318622ced52f5279ac50f04d1c03df73c125a852941b27c475a0b12658ec3728c982b54d47e38ac5f321d5ba392a8bd6a6edf06897ecb94c4fb2cde91e551b2540b30ee55ffe23feb271ee3b5064ce09f429c63fe7683ef531cc7c590c8bf9ac562d0e15a5e67077045772289efabddc920deb88d4bf939a8965c468d24ce44944b05274f0a8fd7df8d0267ffb69c8e0497d54083089f3b2d2b2802796dfd99ce677f1c3a4c62feeca50643f00efe30fd9695d59243c259e1dc0c4384285749784b165399c908540d75b75968b044b890cc69af65ec2688bd39e2eac96110ebb8e7d28eab0c6db8041721a222b5266ae85bdd90635f87754dc74643a6b33510842ec3cbf06a7ea61cfa5d3334da82e30666ee76d01bc7f1f033046651857af4a6c8b12e1eddf0884cf1cf7d99cb38b39e8fcb026568622462350692fd94dd50fd9d1b62894f7cb27f00b7f00bb0c0b9615af73ce8ff715be05a5544a1952a6723c7ee86153b738741d1d1a3093e48cc8936e32a9070d4a21c7defbb7e4d381b98fc697d3d41c15b4bf997ff812bc8c1b8809d0b840e1d3ec64821ad19b71c264ae16b7fea384ec00fa58015f9590f477ca4ba1a5f8e7cb608a4062f8677ec2cbddf29f39775dac040f6edc5724f449bea4e115e3a333d8ea4a81db8cbefd7326bd6fba5f090c2ef3817c78203a03f38602b15729ed0518dfb6b6051476e58f1781eb35818241bc8fb6c8f5820939970e778c0dafb30f1d71ed89c78e8e389f8c1c190d12665b1be9dc143f3f8fdb51b7947305bde67024d7590c724e953a2d7475fd4515b8bbeb128b610b76173d3cb84bf257002e4ec51e1f1c99dbaad31124851ec4ae48791c6f03ba32ab6b69f2a2078e94aa69690774de3e9a11c16a0f50902f8b81129fae18ce256ece96ab3be04cab5532570a4d07d6d9867ee55c14746ff84e9b6e4b3951ea73e7427c774742ce76244d027420336d3b346fde645728db4987ab452d125187df54c6aa0f8b684e649953f8e7dae229da426d089ee54084a6581fdb83608bd69afc5048de5e648f22072b097ab1dded61ce9d5d5c4988687e0afdbe7b19ea703bded4ff29617c6559e0da4659ca925cd7019c235fdd7b442ed39430d3e3d94b395e5767e450f70199d108423af303dde061f54a4600db13ed4858e4d0aa9620fb04905b01714beb0438e9e632fda3e601f962a3101d3025e0afceba410534f4da63656c3c5fe7748d040c42236d2cbbf669d91fc7f5be9ab303a09e817587ecb45321c9f063c14cfa0598f09a9acdcdd5ce49c8b1f29291a6ccc65b2274975587f57c70e57fc53708e7a21a1f1dfb7be60d3c0a92deb513eeff6fbae57c481ca8af224cd023dda2fc129560978e69ebf5568c0b852b91a8b1b01fbf9b9feeca35d3d1aa8e886fbbda1f9d1226c37c5829f35fc02bc28e9c4717234bb21153cb8186632bad10624d333eb2ac7c1c34d0093b6445cd92a32fa2b79978fed87242fa942f766317f2f1bd79fe3c05894fdcb8a5fc9712c318e5996a57dc62fe2bf0888c6c0d4686ab61a835d05ff09dd24d7efab5a43cff098e358539de6b1aef292de293e8101af8a5f0550257de14ba2c016ee8ba6677cf30228ec43b14d69a1a409d47161befcc25352916d79c5fe4081a59bf9aaf0352ccf17f848f5fa027cbe91b4c31b798b8315784d6e976492dd08dc32b97aa18d4f47a3ab99a90227d79c09facc21d4d47252081c4187aea3edb396a68f5530eff28b2cc8c2da045f15f1527b5078f2d0ac482782a72f1738e45c63598d2ef73a733ee3b84af8c17c749c4e37665c894267e2c6ee26304150d835be43ba3934a192c165327193c73f91f79b8106a2c63ffc8871c6018540b688cd45e7c318998aa9edb41fa7c5d9a600de73a5be56c2b12636305a7c8ecc4c6993afe760ce8359beddddbb41b09ac68ae6723ef1ab8c2d5c5c46224fefb815a9c3f4efe22ae768c99dcc9762d325ab84b5963faaf2633d64c282b4fa5df502c9158b7213fcb08a69ee0ef9a2f44de623a7db4751d8a5bb9d43b106ec33988c975816202f794531ae857dd08073150b528fe36ce24f3e3b58d8e47def236d31eef8138ea524254df213ab1bd387df8e5fce25ba12e1a87bfeb64aba318f5c4c181a023df58aed4745085e922205091b45cc8ae8c2ba760428ac2d0f6a96c92da5eb21480c1f0ad30a335e1d78692ecc8381d5d13194b26acd71428578f7d02e940747a13e3fc9a7708600029c136d4f59f22502b93e79068e5e1075cb0899989a1039001a49b3f4f8602e3eab89e63f0f6584a2346408037b0d57270d67b4d77a5e28ec9219f211a79972e2d25aab54c68d6eb170e1461af977fcd3e0f08919f45a645d24eeec31cff07025499c3af1d30db2a0d90f9e0bfb278e06441830853a31ca4329e17248b793fd58c953482a465073e0e2ff083572815031bc976e9539955da2d4afffdb525b855d21173cc87f146ac48a1d31f992e2fd1bdae0e22fbb4d6e8baa75a8f243792c6410bf8c5f5d2b5bb4cebd09764215fd4c6bd94294ba80d4d1749bb91502d0a2dd610430d37b25411ce5c4c5a89192e971f2e1cd082333e46856464874d463997aadfa9b9cfe608cdbd4e0b344e10ce5ede6b5018f4b57e93c6c39f63f7cb5ce5efcfca4352a2b8bb6bed090a06cd5da886f230f015bdf200360cf085648cbe4170cd75b4ea6b393e044175cb5e6661d55250431702be086400bc92d4ee6127ff6d67362126d4b4d8c36a1d40d020d08","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
