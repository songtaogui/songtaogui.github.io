
<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="sKCEBeALSs13uui0cWMviq9hlm0rPByKQKNHnOdq-d0" />
    <meta name="baidu-site-verification" content="code-MBwKQgVpns" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Songtao Gui">

    
    <meta name="description" content="Julia数据科学系列-DataFrames包用法。
">
    

    
    
    <meta name="keywords" content="Julia数据科学系列-DataFrames包">
    <title>Julia数据科学系列-DataFrames包</title>
    

    <link rel="icon" href="/assets/favicon.svg">

    
<link rel=preconnect href="https://fonts.gstatic.com" crossorigin=anonymous>
<link rel=stylesheet href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
    crossorigin=anonymous>
<link rel=stylesheet href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"
    crossorigin=anonymous>
<link rel=stylesheet href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" crossorigin=anonymous>
<link rel=stylesheet
    href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap"
    crossorigin=anonymous>
<!-- locally served -->
<link rel="stylesheet" href="/css/pure.css">
<link rel=stylesheet href="/libs/academic/academic.min.css">
<link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/extra.css">
<link rel=stylesheet href="/css/codeset.css">
<link rel=stylesheet href="/css/admonition.css">
<link rel=stylesheet href="/css/cv.css">
<link rel=stylesheet href="/css/search-box.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
<link rel=stylesheet href="/css/vega.css">
<!-- <link rel=stylesheet href="/css/font-awesome.css"> -->

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- nutshell + highlight + katex + plotly -->
<script src="/libs/nutshell/nutshell.js"></script>
<link rel=stylesheet href="/libs/highlight/styles/atom-one-light.min.css">






    <!-- Vega -->
    <script src="https://cdn.jsdelivr.net/npm/vega@5.22.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@5.5.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.21.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>
    <style media="screen">
        /* Add space between Vega-Embed links  */
        .vega-actions a {
          margin-right: 5px;
        }
    </style>
    <!-- end Vega -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js"
        integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin=anonymous async></script>
</head>

<body id=top data-spy="scroll" data-offset="70" data-target=#navbar-main>
    <!-- Swiftype -->
    <script type="text/javascript">
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
        
        _st('install','J57vdqtTa8oYL-ikpKNG','2.0.0');
    </script>
    
     <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main>
    <div class=container>
        <!-- Main name -->
        <div class="d-none d-lg-inline-flex">
            <a class=navbar-brand href="/">Songtao Gui</a>
        </div>
        <!-- Button for narrow mode -->
        <button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar
            aria-expanded=false aria-label="Toggle navigation">
            <span><i class="fas fa-bars"></i></span>
        </button>
        <!-- Main name for mobile mode -->
        <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
            <a class=navbar-brand href="/">Songtao Gui</a>
        </div>
        <!-- Menu items -->
        <div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content>
            <ul class="navbar-nav d-md-inline-flex">
                <li class=nav-item><a class=nav-link href="/posts/"><span>Posts</span></a></li>
                <li class=nav-item><a class=nav-link href="/courses/"><span>Courses</span></a></li>
                <li class=nav-item><a class=nav-link href="/notebooks/"><span>Notebooks</span></a></li>
                <li class=nav-item><a class=nav-link href="/cv/"><span>CurriculumVitae</span></a></li>
                <li class=nav-item><a class=nav-link href="/tag/"><span>Tags</span></a></li>
            </ul>
        </div>
        <!-- <div class="nav-linksmall d-none d-lg-inline-flex inputBox">
                <input type="text" class="st-default-search-input" placeholder="Input then press ENTER" value="" required>
                <div class="search"></div>
            <script>
                var searchForm = document.getElementById('searchForm');
                searchForm.onsubmit = function () {
                    var url = this.action;
                    var q = this.children['q'].value;
                    var q = 'site:songtaogui.github.io+' + q
                    // var site = this.children['site'].value;
                    var url = url + '?q=' + q;
                    window.open(url,'__blank');
                    return false;
                };
            </script>
        </div> -->
        <!-- 基于bing site搜索: -->
        <div class="nav-linksmall d-none d-lg-inline-flex inputBox">
            <form action="https://bing.com/search" id="searchForm">
                <input type="text" name="q" value="" placeholder="Input then press ENTER" value="" required>
                <div class="search"></div>
            </form>
            <script>
                var searchForm = document.getElementById('searchForm');
                searchForm.onsubmit = function () {
                    var url = this.action;
                    var q = this.children['q'].value;
                    var q = 'site:songtaogui.github.io+' + q
                    // var site = this.children['site'].value;
                    var url = url + '?q=' + q;
                    window.open(url,'__blank');
                    return false;
                };
            </script>
        </div>
        <!-- <div class="nav-icon d-none d-lg-inline-flex"> -->
        <div class="nav-icon">
            <a class=nav-linksmall href="/giants" target="_blank"><span><img class="nav-img"
                src="/assets/img/giant.svg"></span></a>
            <a class=nav-linksmall href="/achievements/" target="_blank"><span><img class="nav-img"
                        src="/assets/img/achievement.svg"></span></a>
            <a class=nav-linksmall href="/feed.xml" target="_blank"><span><img class="nav-img"
                        src="/assets/img/rss.svg"></span></a>
            <a class=nav-linksmall href="/musics" target="_blank"><span><img class="nav-img"
                        src="/assets/img/music.svg"></span></a>
        </div>

    </div>
</nav> 

    <span class="js-widget-page d-none"></span>

    
    <article class=article>
        <div class="article-container pt-3">
             <h1>Julia数据科学系列-DataFrames包</h1> 
        </div>
        
        <div class="article-container">
            <!-- 关闭article-style, 不然跟nutshell不兼容 -->
            <!-- <div class="gst-style"> -->
            <div class="layout-main">
                <!-- <div class="article-style"> -->
                
                
                <div class="franklin-content">
<div class="tags"><a href="/tag/" id="tag-icon"><svg width="20" height="20" viewBox="0 0 512 512"><defs><style>.cls-1{fill:#141f38}</style></defs><path class="cls-1" d="M215.8 512a76.1 76.1 0 0 1-54.17-22.44L22.44 350.37a76.59 76.59 0 0 1 0-108.32L242 22.44A76.11 76.11 0 0 1 296.2 0h139.2A76.69 76.69 0 0 1 512 76.6v139.19A76.08 76.08 0 0 1 489.56 270L270 489.56A76.09 76.09 0 0 1 215.8 512zm80.4-486.4a50.69 50.69 0 0 0-36.06 14.94l-219.6 219.6a51 51 0 0 0 0 72.13l139.19 139.19a51 51 0 0 0 72.13 0l219.6-219.61a50.67 50.67 0 0 0 14.94-36.06V76.6a51.06 51.06 0 0 0-51-51zm126.44 102.08A38.32 38.32 0 1 1 461 89.36a38.37 38.37 0 0 1-38.36 38.32zm0-51a12.72 12.72 0 1 0 12.72 12.72 12.73 12.73 0 0 0-12.72-12.76z"/><path class="cls-1" d="M217.56 422.4a44.61 44.61 0 0 1-31.76-13.16l-83-83a45 45 0 0 1 0-63.52L211.49 154a44.91 44.91 0 0 1 63.51 0l83 83a45 45 0 0 1 0 63.52L249.31 409.24a44.59 44.59 0 0 1-31.75 13.16zm-96.7-141.61a19.34 19.34 0 0 0 0 27.32l83 83a19.77 19.77 0 0 0 27.31 0l108.77-108.7a19.34 19.34 0 0 0 0-27.32l-83-83a19.77 19.77 0 0 0-27.31 0l-108.77 108.7z"/><path class="cls-1" d="M294.4 281.6a12.75 12.75 0 0 1-9-3.75l-51.2-51.2a12.8 12.8 0 0 1 18.1-18.1l51.2 51.2a12.8 12.8 0 0 1-9.05 21.85zM256 320a12.75 12.75 0 0 1-9.05-3.75l-51.2-51.2a12.8 12.8 0 0 1 18.1-18.1l51.2 51.2A12.8 12.8 0 0 1 256 320zM217.6 358.4a12.75 12.75 0 0 1-9-3.75l-51.2-51.2a12.8 12.8 0 1 1 18.1-18.1l51.2 51.2a12.8 12.8 0 0 1-9.05 21.85z"/></svg></a><a href="/tag/julia/">julia</a>, <a href="/tag/statistics/">statistics</a>&nbsp;&nbsp;&nbsp;&nbsp;<a id="tag-icon"><svg width="20" height="20" class="icon" viewBox="0 0 1024 1024" version="1.1" p-id="3825" width="64" height="64"><path d="M512 416a96 96 0 1 0 0 192 96 96 0 0 0 0-192z m511.952 102.064c-0.016-0.448-0.064-0.864-0.096-1.296a8.16 8.16 0 0 0-0.08-0.656c0-0.32-0.064-0.624-0.128-0.928-0.032-0.368-0.064-0.736-0.128-1.088-0.032-0.048-0.032-0.096-0.032-0.144a39.488 39.488 0 0 0-10.704-21.536c-32.672-39.616-71.536-74.88-111.04-107.072-85.088-69.392-182.432-127.424-289.856-150.8-62.112-13.504-124.576-14.064-187.008-2.64-56.784 10.384-111.504 32-162.72 58.784-80.176 41.92-153.392 99.696-217.184 164.48-11.808 11.984-23.552 24.224-34.288 37.248-14.288 17.328-14.288 37.872 0 55.216 32.672 39.616 71.52 74.848 111.04 107.056 85.12 69.392 182.448 127.408 289.888 150.784 62.096 13.504 124.608 14.096 187.008 2.656 56.768-10.4 111.488-32 162.736-58.768 80.176-41.936 153.376-99.696 217.184-164.48 11.792-12 23.536-24.224 34.288-37.248 5.712-5.872 9.456-13.44 10.704-21.568l0.032-0.128a12.592 12.592 0 0 0 0.128-1.088c0.064-0.304 0.096-0.624 0.128-0.928l0.08-0.656 0.096-1.28c0.032-0.656 0.048-1.296 0.048-1.952l-0.096-1.968zM512 704c-106.032 0-192-85.952-192-192s85.952-192 192-192 192 85.968 192 192c0 106.048-85.968 192-192 192z" p-id="3826"></path></svg></a><span id="busuanzi_value_page_pv"></span></div>
<div class="franklin-toc"><ol><li><a href="#dataframesjl">DataFrames.jl</a><ol><li><a href="#快速开始">快速开始</a><ol><li><a href="#构建">构建</a></li><li><a href="#基本操作">基本操作</a></li></ol></li><li><a href="#取子集">取子集</a><ol><li><a href="#subset和subset_操作行"><code>subset</code>和<code>subset&#33;</code>: 操作行</a></li><li><a href="#selectselect和transformtransform_操作列"><code>select/select&#33;</code>和<code>transform/transform&#33;</code>: 操作列</a></li><li><a href="#transform和transform"><code>transform</code>和<code>transform&#33;</code></a></li></ol></li><li><a href="#数据统计_describe和combine">数据统计: <code>describe</code>和<code>combine</code></a></li><li><a href="#数据替换">数据替换</a></li><li><a href="#输入输出">输入输出</a></li><li><a href="#join操作"><code>Join</code>操作</a></li><li><a href="#split-apply-combine数据操作策略"><code>Split-Apply-Combine</code>数据操作策略</a></li><li><a href="#reshaping和pivoting_长宽表转换"><code>Reshaping</code>和<code>Pivoting</code>: 长宽表转换</a></li><li><a href="#排序">排序</a></li><li><a href="#分组数据">分组数据</a></li><li><a href="#缺失值_missing">缺失值: Missing</a></li><li><a href="#扩展包_dataframesmetajl">扩展包: DataFramesMeta.jl</a><ol><li><a href="#select"><code>@select&#91;&#33;&#93;</code></a></li><li><a href="#transform"><code>@transform&#91;&#33;&#93;</code></a></li><li><a href="#subset"><code>@subset&#91;&#33;&#93;</code></a></li><li><a href="#combine"><code>@combine</code></a></li><li><a href="#orderby"><code>@orderby</code></a></li><li><a href="#with"><code>@with</code></a></li><li><a href="#eachrow"><code>@eachrow&#91;&#33;&#93;</code></a></li><li><a href="#byrow和r_逐行数据转换"><code>@byrow</code>和<code>@r...</code>: 逐行数据转换</a></li><li><a href="#用passmissing广播missing">用<code>@passmissing</code>广播missing</a></li><li><a href="#astable和astable同时创建多列"><code>@astable</code>和<code>AsTable</code>同时创建多列</a></li><li><a href="#用转义">用<code>&#36;</code>转义</a></li><li><a href="#用忽略把对应的symbol解析成列名">用<code>^</code>忽略把对应的<code>Symbol</code>解析成列名</a></li><li><a href="#用chain宏管道操作">用<code>@chain</code>宏管道操作</a></li></ol></li></ol></li></ol></div>
<h2 id="dataframesjl"><a href="#dataframesjl" class="header-anchor">DataFrames.jl</a></h2>
<blockquote>
<p><a href="https://dataframes.juliadata.org/stable/">官方Document</a></p>
</blockquote>
<h3 id="快速开始"><a href="#快速开始" class="header-anchor">快速开始</a></h3>
<h4 id="构建"><a href="#构建" class="header-anchor">构建</a></h4>
<p><code>DataFrame</code>类型</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia"># 手动构造: 单个元素的列会广播
DataFrame&#40;A&#61;1:3, B&#61;5:7, fied&#61;1&#41;
# 用 &#61;&gt; 进行复杂列名DF的构造:
DataFrame&#40;&quot;customer age&quot; &#61;&gt; &#91;15, 20, 25&#93;,
          &quot;first name&quot; &#61;&gt; &#91;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#93;&#41;

# 也可从&quot;列名&quot;&#61;&gt;&quot;列值&quot;字典/具名元组中构造DF

# 当列名时, Symbols 快过 Strings

# 从矩阵构造DF:
DataFrame&#40;matrix, names&#41; # names 可以设成&#96;:auto&#96;, 则自动分配列名x1, x2 ..., 或者设成与数据列数相同的数组。

# 按列构造:
df &#61; DataFrame&#40;&#41;
df.A &#61; 1:8
df.B &#61; &#91;&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;&#93;

# 按行构造:
df &#61; DataFrame&#40;A&#61;Int&#91;&#93;, B&#61;String&#91;&#93;&#41;
push&#33;&#40;df, &#40;1, &quot;M&quot;&#41;&#41;
push&#33;&#40;df, &#40;2, &quot;N&quot;&#41;&#41;

# 从其他&#96;Table.jl&#96;的具象格式中转成DF:
df &#61; sqltable |&gt; DataFrame
df &#61; &#91;&#40;a&#61;1, b&#61;2&#41;, &#40;a&#61;3, b&#61;4&#41;&#93; |&gt; DataFrame

# 从CSV文件中读取DF:
using CSV
data &#61; CSV.read&#40;path, DataFrame&#41;

# copy
data2 &#61; copy&#40;data1&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="基本操作"><a href="#基本操作" class="header-anchor">基本操作</a></h4>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia"># 列
german.Sex
german.&quot;Sex&quot;
german&#91;&#33;, :Sex&#93;
german&#91;&#33;, &quot;Sex&quot;&#93;
name&#40;german&#41;
name&#40;german, AbstractString&#41; # 获取指定类型列的名字
propertynames&#40;german&#41; # 获取Symbols格式的名字
eachcol&#40;german&#41; # 按列迭代
empty, empty&#33;   # 删除行, 但保留列数&#40;维度&#41;

# DataFrame基本信息
size&#40;df&#41;   # &#40;行, 列&#41;
size&#40;df,1&#41; # 第一维的大小&#40;行数&#41;
size&#40;df,2&#41; # 第二维的大小&#40;列数&#41;
nrow&#40;df&#41;, ncol&#40;df&#41;
describe&#40;df&#41; # 基本统计信息mean, min, max, median, nmissing, elementType
describe&#40;df, cols&#61;1:3&#41; # 只统计前三列
show&#40;df, allcols&#61;true&#41;
show&#40;df, allrows&#61;true&#41;

mapcols&#40;func, df&#41; # 按列应用func, 返回新df
mapcols&#40;id -&gt; id .^ 2, german&#41;

first&#40;df, n&#41;, last&#40;df, n&#41; # n默认是1</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h3 id="取子集"><a href="#取子集" class="header-anchor">取子集</a></h3>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df&#91;1:3, :&#93;
df&#91;:, &#91;:A, :B&#93;&#93;
df&#91;&#33;, &#91;:A&#93;&#93; # 返回一个df
df&#91;&#33;, :A&#93; # 返回一个Vector

# 正则; Not; Between; All; Cols
df&#91;&#33;, r&quot;x&quot;&#93; # 取出列名包含x的列
df&#91;&#33;, Not&#40;:x1&#41;&#93; # 取出除了&#96;x1&#96;之外的列
df&#91;&#33;, Between&#40;:x1, :x4&#41;&#93;
df&#91;:, All&#40;&#41;&#93;
df&#91;:, Cols&#40;x -&gt; startswith&#40;x, &quot;x&quot;&#41;&#41;&#93;
# Cols 还可用于给列重排序:
df&#91;:, Cols&#40;r&quot;x&quot;, :&#41;&#93; # 把所有包含x的列排在前面, 其他列排在后边
df&#91;:, Cols&#40;Not&#40;r&quot;x&quot;&#41;, :&#41;&#93; # 把所有包含x的列排在后面, 其他列排在前边

# 按照数值过滤
df&#91;df.A .&gt; 500, :&#93; #取出所有A列数值大于 500 的行
df&#91;&#40;df.A .&gt; 500&#41; .&amp; &#40;300 .&lt; df.C .&lt; 400&#41;, :&#93;
df&#91;in.&#40;df.A, Ref&#40;&#91;1, 5, 601&#93;&#41;&#41;, :&#93;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="subset和subset_操作行"><a href="#subset和subset_操作行" class="header-anchor"><code>subset</code>和<code>subset&#33;</code>: 操作行</a></h4>
<pre><code class="language-julia">subset&#40;df::AbstractDataFrame, args...; skipmissing::Bool&#61;false, view::Bool&#61;false&#41;
subset&#40;gdf::GroupedDataFrame, args...; skipmissing::Bool&#61;false, view::Bool&#61;false,
       ungroup::Bool&#61;true&#41;</code></pre>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">subset&#40;df, :A &#61;&gt; a -&gt; a .&lt; 10, :C &#61;&gt; c -&gt; isodd.&#40;c&#41;&#41;

# 用coalesce函数跳过包含missing的行
# coalesce&#40;x...&#41; 返回第一个非missing的值
subset&#40;df, :x &#61;&gt; x -&gt; coalesce.&#40;iseven.&#40;x&#41;, false&#41;&#41; # 如果是missing, 过滤条件就返回false
# 等价于
subset&#40;df, :x &#61;&gt; x -&gt; iseven.&#40;x&#41;, skipmissing&#61;true&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="selectselect和transformtransform_操作列"><a href="#selectselect和transformtransform_操作列" class="header-anchor"><code>select/select&#33;</code>和<code>transform/transform&#33;</code>: 操作列</a></h4>
<ul>
<li><p>复杂的按列过滤函数</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">select&#40;df, Not&#40;:x1&#41;&#41;
select&#40;df, r&quot;x&quot;&#41;
select&#40;df, :x1 &#61;&gt; :a1, :x2 &#61;&gt; :a2&#41; # 重命名列
select&#40;df, :x1, :x2 &#61;&gt; &#40;x -&gt; x .- minimum&#40;x&#41;&#41; &#61;&gt; :x2&#41; # 更改x2的数值
select&#40;df, :x2, :x2 &#61;&gt; ByRow&#40;sqrt&#41;&#41; # 生成新的名为:x2_sqrt的列, 存放x2列的开平方值
select&#40;df, AsTable&#40;:&#41; &#61;&gt; ByRow&#40;extrema&#41; &#61;&gt;  &#91;:lo, :hi&#93;&#41; # 逐行计算所有列的极值, 存到:lo :hi两列中</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<ul>
<li><p>永远返回DataFrame</p>
</li>
<li><p>默认会从原始df中拷贝一份选择的列, 可以用<code>copycols&#61;false</code>参数关闭copy</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important">  df2 &#61; select&#40;df, :x1&#41; df2.x1 &#61;&#61;&#61; df.x1 # false, 默认是copy了一份新的 df2 &#61; select&#40;df, :x1, copycols&#61;false&#41; df2.x1 &#61;&#61;&#61; df.x1 # true </div>
<h4 id="transform和transform"><a href="#transform和transform" class="header-anchor"><code>transform</code>和<code>transform&#33;</code></a></h4>
<p>和<code>select</code>的用法基本一样, 唯一区别是<span class="cadmon sadmon-note"><code>transform/transform&#33;</code>会同时返回原始df中的所有列</span>。</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">julia&gt; df &#61; DataFrame&#40;x1&#61;&#91;1, 2&#93;, x2&#61;&#91;3, 4&#93;, y&#61;&#91;5, 6&#93;&#41;
2×3 DataFrame
 Row │ x1     x2     y
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     1      3      5
   2 │     2      4      6

julia&gt; transform&#40;df, All&#40;&#41; &#61;&gt; &#43;&#41;
2×4 DataFrame
 Row │ x1     x2     y      x1_x2_y_&#43;
     │ Int64  Int64  Int64  Int64
─────┼────────────────────────────────
   1 │     1      3      5          9
   2 │     2      4      6         12</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<p>一个复杂的例子, 按行计算<code>sum</code>, <code>num of elements</code>, <code>mean</code>, 同时忽略<code>missing</code>.</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">julia&gt; using Statistics

julia&gt; df &#61; DataFrame&#40;x&#61;&#91;1, 2, missing&#93;, y&#61;&#91;1, missing, missing&#93;&#41;
3×2 DataFrame
 Row │ x        y
     │ Int64    Int64 
─────┼──────────────────
   1 │       1        1
   2 │       2  missing
   3 │ missing  missing

julia&gt; transform&#40;df, AsTable&#40;:&#41; .&#61;&gt;
                    ByRow.&#40;&#91;sum∘skipmissing,
                            x -&gt; count&#40;&#33;ismissing, x&#41;,
                            mean∘skipmissing&#93;&#41; .&#61;&gt;
                    &#91;:sum, :n, :mean&#93;&#41;
3×5 DataFrame
 Row │ x        y        sum    n      mean
     │ Int64    Int64    Int64  Int64  Float64
─────┼─────────────────────────────────────────
   1 │       1        1      2      2      1.0
   2 │       2  missing      2      1      2.0
   3 │ missing  missing      0      0      NaN</code></pre>
<p><div class="code-lag">julia</div></fieldset>

<fieldset class="admon admon-todo">
<legend class="admon-legend admon-legend-todo"> Todo</legend>
  <a href="https://juliadata.github.io/DataFramesMeta.jl/stable/">DataFramesMeta.jl</a> 模块中有更多好用的数据处理工具, 需要一起记录。 
</fieldset>

<h3 id="数据统计_describe和combine"><a href="#数据统计_describe和combine" class="header-anchor">数据统计: <code>describe</code>和<code>combine</code></a></h3>
<ul>
<li><p><code>describe</code>: 返回一个df, 记录表格每列基本统计信息<code>mean, min, median, max, nmissing, eltype</code></p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">describe&#40;df&#41;
describe&#40;df&#91;&#33;, &#91;:A&#93;&#93;&#41; # 只对特定列统计</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<ul>
<li><p><code>combine</code>: 应用统计函数</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">combine&#40;df, names&#40;df&#41; .&#61;&gt; sum&#41;
combine&#40;df, names&#40;df&#41; .&#61;&gt; sum, names&#40;df&#41; .&#61;&gt; prod&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<h3 id="数据替换"><a href="#数据替换" class="header-anchor">数据替换</a></h3>
<ul>
<li><p><code>replace&#33;</code>: 对单列进行替换</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">julia&gt; df &#61; DataFrame&#40;a&#61;&#91;&quot;a&quot;, &quot;None&quot;, &quot;b&quot;, &quot;None&quot;&#93;, b&#61;1:4,
                      c&#61;&#91;&quot;None&quot;, &quot;j&quot;, &quot;k&quot;, &quot;h&quot;&#93;, d&#61;&#91;&quot;x&quot;, &quot;y&quot;, &quot;None&quot;, &quot;z&quot;&#93;&#41;
4×4 DataFrame
 Row │ a       b      c       d
     │ String  Int64  String  String
─────┼───────────────────────────────
   1 │ a           1  None    x
   2 │ None        2  j       y
   3 │ b           3  k       None
   4 │ None        4  h       z

julia&gt; replace&#33;&#40;df.a, &quot;None&quot; &#61;&gt; &quot;c&quot;&#41;
4-element Vector&#123;String&#125;:
 &quot;a&quot;
 &quot;c&quot;
 &quot;b&quot;
 &quot;c&quot;

julia&gt; df
4×4 DataFrame
 Row │ a       b      c       d
     │ String  Int64  String  String
─────┼───────────────────────────────
   1 │ a           1  None    x
   2 │ c           2  j       y
   3 │ b           3  k       None
   4 │ c           4  h       z</code></pre>
<p><div class="code-lag">julia</div></fieldset></p>
<p>以上操作等价于<code>df.a &#61; replace&#40;df.a, &quot;None&quot; &#61;&gt; &quot;c&quot;&#41;</code>, 但是是<code>in-place</code>的操作, 不需要重新分配内存。</p>
<p>如果需要对多列进行<code>in-place</code>的替换操作, 则可以用<code>广播</code>来实现:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia"># replacement on a subset of columns &#91;:c, :d&#93;
julia&gt; df&#91;:, &#91;:c, :d&#93;&#93; .&#61; ifelse.&#40;df&#91;&#33;, &#91;:c, :d&#93;&#93; .&#61;&#61; &quot;None&quot;, &quot;c&quot;, df&#91;&#33;, &#91;:c, :d&#93;&#93;&#41;;

julia&gt; df
4×4 DataFrame
 Row │ a       b      c       d
     │ String  Int64  String  String
─────┼───────────────────────────────
   1 │ a           1  c       x
   2 │ c           2  j       y
   3 │ b           3  k       c
   4 │ c           4  h       z

julia&gt; df .&#61; ifelse.&#40;df .&#61;&#61; &quot;c&quot;, &quot;None&quot;, df&#41; # replacement on entire data frame
4×4 DataFrame
 Row │ a       b      c       d
     │ String  Int64  String  String
─────┼───────────────────────────────
   1 │ a           1  None    x
   2 │ None        2  j       y
   3 │ b           3  k       None
   4 │ None        4  h       z</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<p>最后一句如果把<code>.&#61;</code>换成<code>&#61;</code>, 则不会执行<code>in-place</code>操作, 会额外分配内存: <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">julia&gt; @time dfx &#61; ifelse.&#40;df&#91;&#33;, &#91;:c, :d&#93;&#93; .&#61;&#61; &quot;NA&quot;, &quot;c&quot;, df&#91;&#33;, &#91;:c, :d&#93;&#93;&#41;;
  0.000104 seconds &#40;92 allocations: 6.781 KiB&#41;

julia&gt; @time dfx .&#61; ifelse.&#40;df&#91;&#33;, &#91;:c, :d&#93;&#93; .&#61;&#61; &quot;NA&quot;, &quot;c&quot;, df&#91;&#33;, &#91;:c, :d&#93;&#93;&#41;;
  0.000073 seconds &#40;81 allocations: 5.484 KiB&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset></p>
<p>
<fieldset class="admon admon-warn">
<legend class="admon-legend admon-legend-warn"> Warn</legend>
  如果原本的列格式并不支持<code>missing</code>, 然后需要把某些值替换成<code>missing</code>, 这种情况下<code>in-place</code>操作是不支持的。要么用<code>&#61;</code>, 要么就提前执行<code>allowmissing&#33;</code>:</p>
<p><fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">julia&gt; df2 &#61; ifelse.&#40;df .&#61;&#61; &quot;None&quot;, missing, df&#41; # 注意这里的df是不支持missing的, 所以用.&#61;会报错, 只能用&#61;
4×4 DataFrame
 Row │ a        b      c        d
     │ String?  Int64  String?  String?
─────┼──────────────────────────────────
   1 │ a            1  missing  x
   2 │ missing      2  j        y
   3 │ b            3  k        missing
   4 │ missing      4  h        z

julia&gt; allowmissing&#33;&#40;df&#41; # 或者提前把df转成支持missing的
4×4 DataFrame
 Row │ a        b       c        d
     │ String?  Int64?  String?  String?
─────┼───────────────────────────────────
   1 │ a             1  None     x
   2 │ None          2  j        y
   3 │ b             3  k        None
   4 │ None          4  h        z

julia&gt; df .&#61; ifelse.&#40;df .&#61;&#61; &quot;None&quot;, missing, df&#41;
4×4 DataFrame
 Row │ a        b       c        d
     │ String?  Int64?  String?  String?
─────┼───────────────────────────────────
   1 │ a             1  missing  x
   2 │ missing       2  j        y
   3 │ b             3  k        missing
   4 │ missing       4  h        z</code></pre>
<p><div class="code-lag">julia</div></fieldset> 
</fieldset>
 </div>
<h3 id="输入输出"><a href="#输入输出" class="header-anchor">输入输出</a></h3>
<ul>
<li><p>用<a href="https://github.com/JuliaData/CSV.jl">CSV.jl</a>读写各种分隔文本格式: <code>CSV.File</code>, <code>CSV.read</code>, <code>CSV.write</code></p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">using CSV

df &#61; DataFrame&#40;CSV.File&#40;&quot;input.csv&quot;&#41;&#41; # 读
CSV.write&#40;&quot;output.csv&quot;, df&#41; # 写</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<ul>
<li><p>Julia标准库中的<code>DelimitedFiles</code>也可以用来读写DataFrame:</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">using DelimitedFiles, DataFrames

data, header &#61; readdlm&#40;&quot;in.csv&quot;, &#39;,&#39;, header&#61;true&#41;;
df_raw &#61; DataFrame&#40;data, vec&#40;header&#41;&#41;
df &#61; identity.&#40;df_raw&#41;
#写:
writedlm&#40;&quot;test.csv&quot;, Iterators.flatten&#40;&#40;&#91;names&#40;df&#41;&#93;, eachrow&#40;df&#41;&#41;&#41;, &#39;,&#39;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset></p>

<fieldset class="admon admon-note">
<legend class="admon-legend admon-legend-note"> Note</legend>
</p>
<ul>
<li><p>header 是一个一维矩阵Matrix, 需要转成Vector;</p>
</li>
<li><p>df_raw中每列的类型都是<code>Any</code>, 用identity缩小每列的类型, 这是因为<code>data</code>是一个<code>Matrix</code>, 内部元素应该是同一种类型&#40;在这个例子中是<code>Any</code>&#41;, 所以转成的DF类型是<code>Any</code>;</p>
</li>
<li><p>以上这些操作, 在<code>CSV.jl</code>中都是自动执行的, 所以<span class="sadmon sadmon-tip">还是用<code>CSV.jl</code>方便啊</span>;</p>
</li>
</ul>
<p>
</fieldset>

<p>
<fieldset class="hadmon admon-info"><legend class="hadmon-legend admon-legend-info"> 疑问</legend>
  所以<code>DataFrame</code>的广播操作是按列的咯? 
</fieldset>
 </div>
<ul>
<li><p>用<code>JSONTables.jl</code>读写JSON</p>
</li>
<li><p>用<code>XLSX.jl</code>读写XLSX</p>
</li>
<li><p>其他格式平时不常用, 就不列举了, 用时自搜</p>
</li>
</ul>
<h3 id="join操作"><a href="#join操作" class="header-anchor"><code>Join</code>操作</a></h3>
<blockquote>
<p>功能与<a href="https://en.wikipedia.org/wiki/Join_&#40;SQL&#41;">SQL Join</a>类似</p>
</blockquote>
<ul>
<li><p><code>innerjoin</code></p>
</li>
<li><p><code>leftjoin</code></p>
</li>
<li><p><code>rightjoin</code></p>
</li>
<li><p><code>outerjoin</code></p>
</li>
<li><p><code>semijoin</code>: 类似<code>innerjoin</code>, 但是输出是以第一个df为参照</p>
</li>
<li><p><code>antijoin</code>: 输出第一个df有,第二个df中没有的</p>
</li>
<li><p><code>crossjoin</code>: 输出是所有df的列的笛卡尔积</p>
</li>
</ul>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">innerjoin&#40;df1, df2, on &#61; :ID&#41; # 大部分join都用同一种语法
innerjoin&#40;df1, df2, on &#61; :ID_df1 &#61;&gt; :ID_df2&#41; # 如果要合并的列名字不一样, 用&#96;&#61;&gt;&#96;指示对应关系
crossjoin&#40;df1, df2, makeunique &#61; true&#41; # crossjoin不使用&#96;on&#96;关键词</code></pre>
<p><div class="code-lag">julia</div></fieldset>

<fieldset class="admon admon-note">
<legend class="admon-legend admon-legend-note"> Note</legend>
</p>
<ul>
<li><p>如果参考列有重复值, <code>inner|outer|left|right</code>会把所有排列组合都输出;</p>
</li>
<li><p>可以用<code>validate&#61;&#40;true,true&#41;</code>来指示对哪些参考列对进行检查, 如果这些列对有重复值, 会报错;</p>
</li>
</ul>
<p>
</fieldset>

<ul>
<li><p><code>source</code>关键词可以用来指示参考列在两个输入df中是不是共有的:</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">julia&gt; outerjoin&#40;df1, df2, on&#61;:ID, validate&#61;&#40;true, true&#41;, source&#61;:source&#41;
3×4 DataFrame
 Row │ ID     Name     Job      source
     │ Int64  String?  String?  String
─────┼─────────────────────────────────────
   1 │    20  John     Lawyer   both
   2 │    40  Jane     missing  left_only
   3 │    60  missing  Doctor   right_only</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<h3 id="split-apply-combine数据操作策略"><a href="#split-apply-combine数据操作策略" class="header-anchor"><code>Split-Apply-Combine</code>数据操作策略</a></h3>

<fieldset class="hadmon admon-note"><legend class="hadmon-legend admon-legend-note"> `Split-Apply-Combine`</legend>
  数据分析中的经典策略:</p>
<ol>
<li><p>把数据集拆分成不同的分组;</p>
</li>
<li><p>对某些分组应用特定的方法;</p>
</li>
<li><p>合并结果成新的数据集;</p>
</li>
</ol>
<p>
</fieldset>

<p>DataFrame中实现的方式是利用<code>groupby</code>创建<code>GroupedDataFrame</code>数据类型, 然后结合<code>combine</code>, <code>select</code>, <code>transform</code>等操作对齐进行数据处理。</p>
<ul>
<li><p><code>groupby</code>: 对DataFrame进行分组</p>
</li>
<li><p><code>combine</code>: 不限制返回行数, 行的顺序取决于group的顺序, 很适合分组计算统计信息</p>
</li>
<li><p><code>select</code>: 返回跟原始df一样的行数和顺序的新列</p>
</li>
<li><p><code>transform</code>: 返回原始df以及追加的新的列</p>
</li>
</ul>
<p>支持的处理函数可以是:</p>
<ol>
<li><p>标准的列指示信息: <code>Integers</code>, <code>Symbols</code>, <code>Vector&#123;Integers|Symbols&#125;</code>,<code>Strings</code>, <code>All</code>, <code>Cols</code>, <code>:</code>, <code>Between</code>, <code>Not</code>, Regex</p>
</li>
<li><p><code>cols &#61;&gt; function</code>键值对: 这种方法调用时, 会<span class="cadmon sadmon-warn">自动生成结果列的名字</span>:默认是拼接输入列的名字和函数的名字, <code>function</code>需要返回一个值或者一个向量</p>
</li>
<li><p><code>cols &#61;&gt; function &#61;&gt; target_cols</code>方式: 显式地声明输出列的名字, 可以是单个值, 向量, 或者是<code>AsTable</code>, 也可以是一个<span class="cadmon sadmon-warn">以<code>cols</code>中的名字为参数, 返回目标列名字的<strong>函数</strong></span></p>
</li>
<li><p><code>cols &#61;&gt; target_cols</code>方式: 重命名</p>
</li>
<li><p><code>nrow</code>或<code>nrow &#61;&gt; target_cols</code>: 快速统计行数, 不显式声明名字的话, 输出名字默认是<code>:nrow</code></p>
</li>
<li><p><span class="Sadmon Sadmon-note">2</span>和<span class="Sadmon Sadmon-note">5</span>中键值对组成的向量或矩阵</p>
</li>
<li><p><code>SubDataFrame</code>类型支持的函数: 不太推荐, 因为表现力不行</p>
</li>
</ol>

<fieldset class="admon admon-note">
<legend class="admon-legend admon-legend-note"> Note</legend>
</p>
<ul>
<li><p>当出现<code>x &#61;&gt; y</code>这种用法时, 会先检查是不是<code>nrow &#61;&gt; target_cols</code>, 如果不是, 则一律按照<code>cols &#61;&gt; function</code>的逻辑去处理</p>
</li>
<li><p>如果<code>cols</code>或者<code>target_cols</code>中是<code>All</code>, <code>Cols</code>, <code>Between</code> 或者 <code>Not</code>这几个特定方法时, 可以用<code>.&#61;&gt;</code>进行<strong>广播</strong>, 等同于广播<code>names&#40;df, cols&#41;</code>或者<code>names&#40;df, cols&#41;</code> <span class="Sadmon Sadmon-todo">这解答了我之前的疑惑: 就是按列广播, 实际上是按列名广播</span></p>
</li>
<li><p><code>cols &#61;&gt; function &#91;&#61;&gt; target_cols&#93;</code>这种用法中, 如果<code>cols</code>是<code>AsTable</code>对象, 则会把一个由<code>cols</code>当名字的具名元组传递给<code>function</code></p>
</li>
</ul>
<p>
</fieldset>


<fieldset class="hadmon admon-note"><legend class="hadmon-legend admon-legend-note"> function的返回值</legend>
</p>
<ol>
<li><p>如果<code>cols</code>和<code>target_cols</code>都没有指定, 只传递了<code>function</code>, 则应该返回<code>DataFrame, Matrix, NamedTuple, DataFrameRow</code>中的一种, 返回其他类型都只会存成一列</p>
</li>
<li><p>如果<code>target_cols</code>是<code>Symbol</code>或<code>String</code>, <code>function</code>应该只返回一列, 这时返回<code>DataFrame, Matrix, NamedTuple, DataFrameRow</code>的函数会报错</p>
</li>
<li><p>如果<code>target_cols</code>是<code>Vector&#123;Symbol&#125;</code>或<code>Vector&#123;String&#125;</code>或<code>AsTable</code>, <code>function</code>应该返回多列, 如果<code>function</code>返回值是<code>AbstractVector</code>, 则其每个元素都得支持<code>keys</code>方法, 而且<code>keys</code>方法必须得返回<code>Symbol, String, Integer</code>, 如果返回<code>Integer</code>, 则输出列名默认是<code>x</code>开头&#40;<code>x1, x2 ...</code>&#41;</p>
</li>
<li><p>如果<code>function</code>的返回值是其他类型, 会被认为是<code>Table.jl</code>支持的表格类型, 然后尝试利用<code>Tables.columntable</code>方法获取其名字</p>
</li>
<li><p><code>function</code>的返回值中, 如果是<code>Ref</code>或者零维向量&#40;<span class="cadmon sadmon-todo">就是空向量?</span>&#41;会被当作是单独的一行</p>
</li>
</ol>
<p>
</fieldset>

<p>当julia多核启动时, 对DataFrame调用转换函数, 会自动对每个转换事件进行并行&#40;除非一些专门优化过的计算, 比如<code>sum</code>, 会把所有分组的计算单线程串行&#41;, 因此调用的函数应该是<code>干净的</code>&#40;即不能修改全局变量&#41;, 或者用进程锁&#40;太高端了暂时用不上&#41;</p>
<p>可以用<code>ByRow</code>结构表明函数是按行执行, 而不是按列执行。</p>

<fieldset class="hadmon admon-note"><legend class="hadmon-legend admon-legend-note"> 一些关键词</legend>
</p>
<ul>
<li><p><code>keepkeys</code>: 分组的列是否要在结果DF中保留</p>
</li>
<li><p><code>ungroup</code>: 输出<code>DataFrame</code>还是<code>GroupedDataFrame</code></p>
</li>
<li><p><code>copycols</code>: 原始DF中没被操作的列, 是否要copy</p>
</li>
<li><p><code>renamecols</code>: <code>cols &#61;&gt; functions</code>形式中,自动生成的结果列名字是否要加上原始列的名字</p>
</li>
</ul>
<p>
</fieldset>

<p>例子: <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">using DataFras, CSV, Statistics

fpath &#61; joinpath&#40;dirname&#40;pathof&#40;DataFrames&#41;&#41;, &quot;..&quot;, &quot;docs&quot;, &quot;src&quot;, &quot;assets&quot;, &quot;iris.csv&quot;&#41;;
iris &#61; CSV.read&#40;fpath, DataFrame&#41;
gdf &#61; groupby&#40;iris, :Species&#41;

combine&#40;gdf, :PetalLength &#61;&gt; mean&#41;
combine&#40;gdf, nrow&#41;
combine&#40;gdf, nrow, :PetalLength &#61;&gt; mean &#61;&gt; :mean&#41;
combine&#40;gdf, &#91;:PetalLength, :SepalLength&#93; &#61;&gt; &#40;&#40;p, s&#41; -&gt; &#40;a&#61;mean&#40;p&#41;/mean&#40;s&#41;, b&#61;sum&#40;p&#41;&#41;&#41;,
        AsTable&#41;
combine&#40;gdf, AsTable&#40;&#91;:PetalLength, :SepalLength&#93;&#41; &#61;&gt;
        x -&gt; std&#40;x.PetalLength&#41;/std&#40;x.SepalLength&#41;&#41;
combine&#40;x -&gt; std&#40;x.PetalLength&#41; / std&#40;x.SepalLength&#41;, gdf&#41;
combine&#40;gdf, 1:2 &#61;&gt; cor, nrow&#41;
combine&#40;gdf, :PetalLength &#61;&gt; &#40;x -&gt; &#91;extrema&#40;x&#41;&#93;&#41; &#61;&gt; &#91;:min, :max&#93;&#41;

select&#40;gdf, 1:2 &#61;&gt; cor&#41;
transform&#40;gdf, :Species &#61;&gt; x -&gt; chop.&#40;x, head&#61;5, tail&#61;0&#41;&#41;

# do block is supported, but sould be avoided because it is slow:
combine&#40;gdf&#41; do df
   &#40;m &#61; mean&#40;df.PetalLength&#41;, s² &#61; var&#40;df.PetalLength&#41;&#41;
end

for subdf in groupby&#40;iris, :Species&#41;
    println&#40;size&#40;subdf, 1&#41;&#41;
end

for &#40;key, subdf&#41; in pairs&#40;groupby&#40;iris, :Species&#41;&#41;
    println&#40;&quot;Number of data points for &#36;&#40;key.Species&#41;: &#36;&#40;nrow&#40;subdf&#41;&#41;&quot;&#41;
end</code></pre>
<p><div class="code-lag">julia</div></fieldset></p>
<ul>
<li><p>groupby结果的key是<code>DataFrames.GroupKey</code>类型, 可以当作是一种<code>NamedTuple</code></p>
</li>
<li><p>groupby可以当作对DataFrame添加了查找索引, 可以通过<code>Tuple</code>或者<code>NamedTuple</code>来快速跳到指定索引:</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;g&#61;repeat&#40;1:1000, inner&#61;5&#41;, x&#61;1:5000&#41;;
gdf &#61; groupby&#40;df, :g&#41;
gdf&#91;&#40;g&#61;500,&#41;&#93; # 用一个元素的NamedTuple, 获取分组是500的行
gdf&#91;&#91;&#40;500,&#41;, &#40;501,&#41;&#93;&#93; # 用Vector&#123;NamedTuple&#125;, 获取两个分组</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<ul>
<li><p>用<code>valuecols</code>获取所有没分组的列:</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">combine&#40;gdf, valuecols&#40;gdf&#41; .&#61;&gt; mean&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<ul>
<li><p><code>GroupedDataFrame</code>不是copy, 而是view, 所以其父DF的对应列不能改变, 也不能改变行数, 否则调用子gdf时会报错</p>
</li>
<li><p>如果想父DF的改动不影响子GDF, 则要用父df的view创建gdf:<code>gdf &#61; groupby&#40;view&#40;df, :, :&#41;, :id&#41;</code></p>
</li>
<li><p><code>SubDataFrames</code>类型可以让我们快速获得df的子集, 实现类似SQL的<code>where</code>功能:</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;a&#61;1:5&#41;
sdf &#61; @view df&#91;2:3, :&#93; # SubDataFrame type
transform&#40;sdf, :a &#61;&gt; ByRow&#40;string&#41;&#41; # 创建新的DataFrame
transform&#33;&#40;sdf, :a &#61;&gt; ByRow&#40;string&#41;&#41; # 本地更改sdf, 类型还是SubDataFrame
df # 更改SubDataFrame, 会对父df也一样更改, 这里df中没操作的行, 对应列填充missing
select&#33;&#40;sdf, :a &#61;&gt; -, renamecols&#61;false&#41; # 再操作, 这里原地操作
df</code></pre>
<p><div class="code-lag">julia</div></fieldset> 也可以对sdf进行分组。 </div>
<h3 id="reshaping和pivoting_长宽表转换"><a href="#reshaping和pivoting_长宽表转换" class="header-anchor"><code>Reshaping</code>和<code>Pivoting</code>: 长宽表转换</a></h3>
<ul>
<li><p><code>stack</code>: 宽表变长表, 会自动进行类型提升</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"> <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">stack&#40;iris, 1:4&#41; # 把1-4列当成variable
stack&#40;iris, &#91;:SepalLength, :SepalWidth, :PetalLength, :PetalWidth&#93;&#41;
stack&#40;iris, Not&#40;:Species&#41;&#41;
# stack的第三个参数指定需要重复的列&#40;指示列&#41;
stack&#40;iris, &#91;:SepalLength, :SepalWidth&#93;, :Species&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<ul>
<li><p><code>unstack</code>: 长表转宽表</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important"></p>
<pre><code class="language-julia">unstack&#40;df::AbstractDataFrame, rowkeys, colkey, value; renamecols::Function&#61;identity,
        allowmissing::Bool&#61;false, allowduplicates::Bool&#61;false, fill&#61;missing&#41;
unstack&#40;df::AbstractDataFrame, colkey, value; renamecols::Function&#61;identity,
        allowmissing::Bool&#61;false, allowduplicates::Bool&#61;false, fill&#61;missing&#41;
unstack&#40;df::AbstractDataFrame; renamecols::Function&#61;identity,
        allowmissing::Bool&#61;false, allowduplicates::Bool&#61;false, fill&#61;missing&#41;</code></pre>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">iris.id &#61; 1:size&#40;iris, 1&#41;
longdf &#61; stack&#40;iris, Not&#40;&#91;:Species, :id&#93;&#41;&#41;
unstack&#40;longdf, :id, :variable, :value&#41;
# 如果剩下的col是unique的, 可以不提供id variable:
unstack&#40;longdf, :variable, :value&#41;
# 甚至可以不提供variable和value:
unstack&#40;longdf&#41;
# 添加view&#61;true, 不copy新数据, 而是创建原数据的view, 会节省内存
stack&#40;iris, view&#61;true&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<ul>
<li><p><code>view&#61;true</code>时, 会创建几个向量: <code>EachRepeatedVector</code>对应<code>:variable</code>; <code>StackedVector</code>对应<code>:value</code>; <code>Repeatedvector</code> 对应<code>ID cols</code></p>
</li>
</ul>
<p></div>
<ul>
<li><p><code>permnutedims</code>: 反转df <code>permutedims&#40;df, 1&#41;</code></p>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="header-anchor">排序</a></h3>
<p>直接调用<code>sort/sort&#33;</code>, 可配合<code>ref</code>,<code>by</code>关键词和<code>order</code>方法使用</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">sort&#33;&#40;iris&#41; # 每列都逐级参与排序
sort&#33;&#40;iris, rev &#61; true&#41;
sort&#33;&#40;iris, &#91;:Species, :SepalWidth&#93;&#41; # 指定排序的列
sort&#33;&#40;iris, &#91;order&#40;:Species, by&#61;length&#41;, order&#40;:SepalLength, rev&#61;true&#41;&#93;&#41; # 指定排序方式
sort&#33;&#40;iris, &#91;:Species, :PetalLength&#93;, rev&#61;&#91;true, false&#93;&#41; # 另一种指定排序方式的语法</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h3 id="分组数据"><a href="#分组数据" class="header-anchor">分组数据</a></h3>

<fieldset class="hadmon admon-note"><legend class="hadmon-legend admon-legend-note"> 分组数据的存储</legend>
  在数据分析中, 我们经常会需要对某列数据进行分组, 分组数据通常是一些字符串, 分组数目通常不会太多 这种时候, 我们可以对分组数据进行重新编码&#40;把string替换成一堆level&#41;, 这样的好处是<strong>减少内存</strong>且 <strong>更容易用<code>groupby</code>操作</strong>, 目前有两种类型帮助实现:</p>
<ul>
<li><p>来自PooledArrays.jl包中的<code>PooledVector</code>, 只是用来减少存储</p>
</li>
<li><p>来自CategoricalArrays.jl包中的<code>CategoricalVector</code>, 还提供函数取回分组顺序, 在分析和画图中很有用 <span class="cadmon sadmon-tip">这个更活跃一点, 应用范围也更广</span></p>
</li>
</ul>
<p>
<fieldset class="admon admon-todo">
<legend class="admon-legend admon-legend-todo"> Todo</legend>
  拓展学习<a href="https://categoricalarrays.juliadata.org/stable/">CategoricalArrays.jl</a> 
</fieldset>
 
</fieldset>

<h3 id="缺失值_missing"><a href="#缺失值_missing" class="header-anchor">缺失值: Missing</a></h3>
<ul>
<li><p><code>Missing</code>类型的唯一实例是<code>missing</code></p>
</li>
<li><p><code>skipmissing&#40;x&#41;</code>方法可以过滤掉x中missing的值, 返回的是一个迭代器</p>
</li>
<li><p><code>coalesce</code>可以用来替换missing为其他值: <code>coalesce.&#40;x, 0&#41;</code>, 该方法是针对指定值的, 所以对向量要广播</p>
</li>
<li><p><code>dropmissing/dropmissing&#33;</code>: 去掉df中有missing的行, <code>dropmissing&#40;df, :x&#41;</code>指定行, 设置<code>disallowmissing&#61;true</code>参数让输出的df不支持missing</p>
</li>
<li><p><code>allowmissing&#91;&#33;&#93;</code>和<code>disallowmissing&#91;&#33;&#93;</code>: 把指定df&#40;的指定列&#41;改成支持/不支持<code>missing</code></p>
</li>
<li><p><strong>Missings.jl</strong>包提供了一堆专门处理缺失值的函数, 其中一个<code>passmissing&#40;func&#41;</code>可以跳过用missing执行<code>func</code>, 还有<code>Missing.replace</code>, <code>nonmissingtype</code>, <code>missings&#40;N&#41;</code>等, 这里不展开了</p>
</li>
</ul>
<h3 id="扩展包_dataframesmetajl"><a href="#扩展包_dataframesmetajl" class="header-anchor">扩展包: DataFramesMeta.jl</a></h3>
<blockquote>
<p>官方文档 <a href="https://juliadata.github.io/DataFramesMeta.jl/stable/">HERE</a></p>
</blockquote>

<fieldset class="hadmon admon-hack"><legend class="hadmon-legend admon-legend-hack"> 拓展DataFrames.jl</legend>
 <code>DataFrames.jl</code>中的<code>select</code>, <code>transform</code>和<code>combine</code>等方法很强, 但是逻辑上有时候略显繁琐, 受R中<code>dplyr</code>和C#中<code>LINQ</code>的启发, <code>DataFramesMeta.jl</code>提供了这些方法的镜像宏, 可以用更简洁的语法来操作。除此之外, <code>DataFramesMeta.jl</code>还提供了其他宏操作, 如<code>@orderby, @subset&#91;&#33;&#93;, @r&#91;transform,select,orderby,subset&#93;, @by, @with, @eachrow, @byrow, @passmissing, @astable, @chain</code>等。</p>
<p><div class="aadmon aadmon-todo"> 最新版的<code>DataFrames.jl</code>中提供了<code>Between, All, Cols, Not</code>等列操作, 这些在<code>DataFramesMeta.jl</code>中暂不支持。</div> 
</fieldset>

<h4 id="select"><a href="#select" class="header-anchor"><code>@select&#91;&#33;&#93;</code></a></h4>
<ul>
<li><p><code>@select</code>返回新的DF, 每列都是重新分配内存的</p>
</li>
<li><p><code>@select&#33;</code>直接操作原DF</p>
</li>
<li><p>相比<code>select</code>, 采用了更简洁的语法: <code>:y &#61; f&#40;:x&#41;</code></p>
</li>
</ul>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;x &#61; &#91;1, 1, 2, 2&#93;, y &#61; &#91;1, 2, 101, 102&#93;&#41;;
gdf &#61; groupby&#40;df, :x&#41;;
@select&#40;df, :x, :y&#41;
@select&#40;df, :x2 &#61; 2 * :x, :y&#41;
@select&#40;gdf, :x2 &#61; 2 .* :y .* first&#40;:y&#41;&#41;
@select&#33;&#40;df, :x, :y&#41;
@select&#33;&#40;df, :x &#61; 2 * :x, :y&#41;
@select&#33;&#40;gdf, :y &#61; 2 .* :y .* first&#40;:y&#41;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="transform"><a href="#transform" class="header-anchor"><code>@transform&#91;&#33;&#93;</code></a></h4>
<p>逻辑与<code>@select</code>类似:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">@transform&#40;df, :x2 &#61; 2 * :x, :y&#41;
@transform&#40;gdf, :x2 &#61; 2 .* :y .* first&#40;:y&#41;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="subset"><a href="#subset" class="header-anchor"><code>@subset&#91;&#33;&#93;</code></a></h4>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">using Statistics
outside_var &#61; 1;
@subset&#40;df, :x .&gt; 1&#41;
@subset&#40;df, :x .&gt; outside_var&#41;
@subset&#40;df, :x .&gt; outside_var, :y .&lt; 102&#41; # 两个条件是 and 的关系
@subset&#40;gdf, :x .&gt; mean&#40;:x&#41;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="combine"><a href="#combine" class="header-anchor"><code>@combine</code></a></h4>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">@combine&#40;gdf, :x2 &#61; sum&#40;:y&#41;&#41;
@combine&#40;gd, :x2 &#61; :y .- sum&#40;:y&#41;&#41;
@combine&#40;gd, &#36;AsTable &#61; &#40;n1 &#61; sum&#40;:y&#41;, n2 &#61; first&#40;:y&#41;&#41;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<p>注意最后一个例子中用<code>&#36;</code>转义表明输出是一个<code>Table</code>格式, <code>&#36;</code>转义的具体用法将在<a href="#<code>&#36;</code>转义">下文</a>说明。</p>

<fieldset class="admon admon-note">
<legend class="admon-legend admon-legend-note"> Note</legend>
 <code>@combine</code>的第一个参数需要是DF或GDF, 而<code>combine</code>可以把函数作为第一个参数, 而把GDF当作第二个参数:</p>
<p><fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia"># 不支持的:
@combine&#40;&#40;a&#61;sum&#40;:x&#41;, b&#61;sum&#40;:y&#41;&#41;, gdf&#41;
# 支持:
@combine&#40;gdf, &#36;AsTable &#61; &#40;a &#61; sum&#40;:x&#41;, b &#61; sum&#40;:y&#41;&#41;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset> 
</fieldset>

<h4 id="orderby"><a href="#orderby" class="header-anchor"><code>@orderby</code></a></h4>
<p><code>@orderby</code>对DF的多列进行排序, <span class="cadmon sadmon-error">只支持<code>DataFrame</code>, 不支持<code>GroupedDataFrame</code></span>。</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">@orderby&#40;df, -1 .* :x&#41;
@orderby&#40;df, :x, :y .- mean&#40;:y&#41;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="with"><a href="#with" class="header-anchor"><code>@with</code></a></h4>
<p><code>@with df</code> 后边跟着的代码块中出现的所有<code>Symbol</code>类型都会被解析成是df对应列的数组, 这样需要对一个df的很多列做一系列下游计算的时候, 就可以不用重复写<code>df.colname</code>了, 很方便:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;x &#61; 1:3, y &#61; &#91;2, 1, 2&#93;&#41;
x &#61; &#91;2, 1, 0&#93;

@with&#40;df, :y .&#43; 1&#41;
@with&#40;df, :x &#43; x&#41;

x &#61; @with df begin
    res &#61; 0.0
    for i in 1:length&#40;:x&#41;
        res &#43;&#61; :x&#91;i&#93; * :y&#91;i&#93;
    end
    res
end

# 用^&#40;&#41;包裹的Symbols不会被展开成数组
@with&#40;df, df&#91;:x .&gt; 1, ^&#40;:y&#41;&#93;&#41;
# 上边这个结果等价于:
df&#91;&#91;1,2,3&#93; .&gt; 1, :y&#93;
# :x 被展开了, :y 没有</code></pre>
<p><div class="code-lag">julia</div></fieldset>

<fieldset class="admon admon-note">
<legend class="admon-legend admon-legend-note"> Note</legend>
 <code>@with</code>会生成一个函数, 所以<code>@with</code>内部定义的变量是<strong>局部变量</strong>. 在<code>@with</code>代码块内部给其外部变量赋值时, 需不需要添加<code>global</code>关键字取决于其外部代码块的属性:</p>
<ul>
<li><p>如果外部代码块是<strong>全局</strong>的, 则<code>@with</code>内部<strong>需要</strong>添加<code>global</code>关键字才能使用该变量;</p>
</li>
<li><p>如果外部代码块是<strong>局部</strong>的&#40;函数内或者<code>let</code>语句块内&#41;, 则<strong>不需要</strong>添加<code>global</code>;</p>
</li>
</ul>
<p>
</fieldset>


<fieldset class="admon admon-warn">
<legend class="admon-legend admon-legend-warn"> Warn</legend>
  因为<code>@with</code>会生成函数, 所以在使用<code>return</code>的时候要小心: <fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">function data_transform&#40;df; returnearly &#61; true&#41;
    if returnearly
        @with df begin
            z &#61; :x &#43; :y
            return z
        end
    else
        return &#91;1, 2, 3&#93;
    end

    return &#91;4, 5, 6&#93;
end</code></pre>
<p><div class="code-lag">julia</div></fieldset> 以上函数会返回<code>&#91;4, 5, 6&#93;</code>, 因为<code>@with</code>内部的<code>return</code>是属于<code>@with</code>生成的匿名函数的, 不是<code>data_transform</code>的。接下来将要介绍的<code>@eachrow</code>是基于<code>@with</code>实现的, 所以也同样需要注意这个问题。 
</fieldset>

<h4 id="eachrow"><a href="#eachrow" class="header-anchor"><code>@eachrow&#91;&#33;&#93;</code></a></h4>
<p>逐行操作DF并返回操作后的DF的每行, 支持控制流和<code>begin end</code>代码块。</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;A &#61; 1:3, B &#61; &#91;2, 1, 2&#93;&#41;
df2 &#61; @eachrow df begin
    :A &#61; :B &#43; 1
end</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<p>类似<code>@with</code>, 由于<code>@eachrow</code>生成一个函数代码块, 所以要引用外部变量时, 需要用<code>let</code>代码块包裹, 或者用<code>global</code>关键字&#40;推荐用<code>let</code>, 更易懂&#41;:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;A &#61; 1:3, B &#61; &#91;2, 1, 2&#93;, C &#61; &#91;-4,2,1&#93;&#41;

# 用let包裹, 让x成为局部变量
let x &#61; 0.0
    @eachrow df begin
        if :A &lt; :B
            x &#43;&#61; :A * :C
        end
    end
    x
end # x &#61; -4.0

# y是全局变量, 在@eachrow内要用global关键字
y &#61; 0.0
@eachrow df begin
    if :A &lt; :B
        global y &#43;&#61; :A * :C
    end
end;
y # y &#61; -4.0</code></pre>
<p><div class="code-lag">julia</div></fieldset>

<fieldset class="hadmon admon-hack"><legend class="hadmon-legend admon-legend-hack"> @eachrow的特殊用法:@newcol</legend>
  在<code>@echorow</code>中, 可以用<code>@newcol</code>宏&#40;语法:<code>@newcol :x::Vector&#123;T&#125;</code>&#41;来分配新的类型为<code>T</code>的列:</p>
<p><fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;A &#61; 1:3, B &#61; &#91;2, 1, 2&#93;&#41;
df2 &#61; @eachrow df begin
    @newcol :colX::Vector&#123;Float64&#125;
    @newcol :colY::Vector&#123;Union&#123;Int, Missing&#125;&#125;
    @newcol :colZ::Vector&#123;String&#125;
    :colX &#61; :B &#61;&#61; 2 ? pi * :A : :B
    if :A &gt; 1
        :colY &#61; :A * :B
    else
        :colY &#61; missing
    end
    :colZ &#61; string&#40;:A&#41;
end</code></pre>
<p><div class="code-lag">julia</div></fieldset> 
</fieldset>

<h4 id="byrow和r_逐行数据转换"><a href="#byrow和r_逐行数据转换" class="header-anchor"><code>@byrow</code>和<code>@r...</code>: 逐行数据转换</a></h4>
<p><code>@byrow</code>可以方便地对df逐行操作, <code>DataFramesMeta.jl</code>中一系列的行操作宏都是基于<code>@byrow</code>的:</p>
<ul>
<li><p><code>@rtransform</code>, <code>@rtransform&#33;</code></p>
</li>
<li><p><code>@rselect</code>, <code>@rselect&#33;</code></p>
</li>
<li><p><code>@rorderby</code></p>
</li>
<li><p><code>@rsubset</code>, <code>@rsubset&#33;</code></p>
</li>
</ul>
<p>在<code>DataFram.jl</code>中, 有<code>ByRow</code>函数, 可以当作是按行广播操作: <code>ByRow&#40;f&#41;&#40;x, y&#41;</code> ≈ <code>f.&#40;x, y&#41;</code>。<code>@byrow</code>可以理解成在<code>DataFramesMeta.jl</code>的宏中使用的<code>ByRow</code>。</p>
<div class="aadmon aadmon-warn"> <code>@byrow</code>不是真正的宏, 不能用于<code>DataFramesMeta.jl</code>的宏之外。</p>
<p><fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">#以下两行代码是等价的:
@transform&#40;df, @byrow :y &#61; :x &#61;&#61; 1 ? true : false&#41;
transform&#40;df, :x &#61;&gt; ByRow&#40;x -&gt; x &#61;&#61; 1 ? true : false&#41; &#61;&gt; :y&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset></div>
<p>为了避免多次操作时重复写<code>@byrow</code>, 可以把<code>@byrow</code>写在代码块的开头, 则代码块中的所有操作都是逐行的了:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">@subset df @byrow begin
    :a &gt; 1 
    :b &lt; 5
end</code></pre>
<p><div class="code-lag">julia</div></fieldset>

<fieldset class="admon admon-note">
<legend class="admon-legend admon-legend-note"> Note</legend>
 <code>@byrow</code>也可以用于<code>GroupedDataFrame</code>, 但是与<code>ByRow</code>类似, 在用给GDF中, 分组信息是不会被考虑的:</p>
<pre><code class="language-julia"># 以下代码是等价的:
@transform&#40;df, @byrow :y &#61; f&#40;:x&#41;&#41;
@transform&#40;groupby&#40;df, :g&#41;, @byrow :y &#61; f&#40;:x&#41;&#41;</code></pre>
<p>
</fieldset>

<h4 id="用passmissing广播missing"><a href="#用passmissing广播missing" class="header-anchor">用<code>@passmissing</code>广播missing</a></h4>
<p>很多Julia中的函数是不支持missing的广播的&#40;如<code>parse&#40;Int, missing&#41;</code>会报错&#41;。 <code>Missing.jl</code>包中提供了<code>passmissing</code>函数来处理missing。相应地, <code>DataFramesMeta.jl</code>中提供了<code>@passmissing</code>宏来在其他宏操作中支持missing。</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">#以下代码是等价的:
@transform df @byrow @passmissing :c &#61; f&#40;:a, :b&#41;
transform&#40;df, &#91;:a, :b&#93; &#61;&gt; ByRow&#40;passmissing&#40;f&#41;&#41; &#61;&gt; :c&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<p>更具体的例子:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">julia&gt; no_missing&#40;x::Int, y::Int&#41; &#61; x &#43; y;

julia&gt; df &#61; DataFrame&#40;a &#61; &#91;1, 2, missing&#93;, b &#61; &#91;4, 5, 6&#93;&#41;
3×2 DataFrame
 Row │ a        b
     │ Int64?   Int64
─────┼────────────────
   1 │       1      4
   2 │       2      5
   3 │ missing      6

julia&gt; @transform df @passmissing @byrow :c &#61; no_missing&#40;:a, :b&#41;
3×3 DataFrame
 Row │ a        b      c
     │ Int64?   Int64  Int64?
─────┼─────────────────────────
   1 │       1      4        5
   2 │       2      5        7
   3 │ missing      6  missing

julia&gt; df &#61; DataFrame&#40;x_str &#61; &#91;&quot;1&quot;, &quot;2&quot;, missing&#93;&#41;
3×1 DataFrame
 Row │ x_str
     │ String?
─────┼─────────
   1 │ 1
   2 │ 2
   3 │ missing

julia&gt; @rtransform df @passmissing :x &#61; parse&#40;Int, :x_str&#41;
3×2 DataFrame
 Row │ x_str    x
     │ String?  Int64?
─────┼──────────────────
   1 │ 1              1
   2 │ 2              2
   3 │ missing  missing</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="astable和astable同时创建多列"><a href="#astable和astable同时创建多列" class="header-anchor"><code>@astable</code>和<code>AsTable</code>同时创建多列</a></h4>
<ul>
<li><p><code>@astable</code></p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important">  在需要用<span class="cadmon sadmon-tip">同一套操作逻辑生成多列变量</span>的场景, 可以用<code>@astable</code>:</p>
<p><fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">julia&gt; df &#61; DataFrame&#40;a &#61; &#91;1, 2, 3&#93;, b &#61; &#91;400, 500, 600&#93;&#41;;

julia&gt; @transform df @astable begin 
           ex &#61; extrema&#40;:b&#41;
           :b_first &#61; :b .- first&#40;ex&#41;
           :b_last &#61; :b .- last&#40;ex&#41;
       end
3×4 DataFrame
 Row │ a      b      b_first  b_last 
     │ Int64  Int64  Int64    Int64  
─────┼───────────────────────────────
   1 │     1    400        0    -200
   2 │     2    500      100    -100
   3 │     3    600      200       0</code></pre>
<p><div class="code-lag">julia</div></fieldset> </div>
<ul>
<li><p><code>AsTable</code>在表达式右侧的操作</p>
</li>
</ul>
<div class="indent-block" style="margin-left: 2em !important">  也可以用<code>AsTable&#40;cols&#41;</code>同时对多列操作, 当把AsTable用在表达式右边的时候:</p>
<ul>
<li><p><span class="cadmon sadmon-warn">如果使用了<code>AsTable&#40;cols&#41;</code>, 就不要在代码块中再引用其他列了</span></p>
</li>
<li><p><code>AsTable</code>支持配合<code>Not, Between, r&quot;&quot;</code>等使用</p>
</li>
<li><p><code>AsTable</code>内部的东西都是被强制转义的, 所以不需要在其内部使用用<code>&#36;</code></p>
</li>
</ul>
<pre><code class="language-julia">df &#61; DataFrame&#40;a &#61; &#91;11, 14&#93;, b &#61; &#91;17, 10&#93;, c &#61; &#91;12, 5&#93;&#41;;
vars &#61; &#91;&quot;a&quot;, &quot;b&quot;&#93;;

@rtransform df :y &#61; sum&#40;AsTable&#40;vars&#41;&#41;
@rtransform df :y &#61; sum&#40;AsTable&#40;&#91;:a, :b&#93;&#41;&#41;

# AsTable还支持用变量的名字进行操作
function fun_with_new_name&#40;x::NamedTuple&#41;
    nms &#61; string.&#40;propertynames&#40;x&#41;&#41;
    new_name &#61; Symbol&#40;join&#40;nms, &quot;_&quot;&#41;, &quot;_sum&quot;&#41;
    s &#61; sum&#40;x&#41;
    &#40;; new_name &#61;&gt; s&#41; # &#40;; &#41; &#61;&gt; 定义具名元组
end

@rtransform df &#36;AsTable &#61; fun_with_new_name&#40;AsTable&#40;&#91;:a, :b&#93;&#41;&#41;

@rsubset df sum&#40;AsTable&#40;vars&#41;&#41; &gt; 25

:y &#61; first&#40;AsTable&#40;&quot;a&quot;&#41;&#41; # AsTable内部强制转义</code></pre>
<p>
<fieldset class="hadmon admon-note"><legend class="hadmon-legend admon-legend-note"> 如何理解AsTable的工作原理?</legend>
  上边介绍了<code>DataFrames.jl</code>中可以当作<code>source</code>, 进行<code>source &#61;&gt; fun &#61;&gt; dest</code>这种操作。<br>在<code>DataFramesMeta.jl</code>中, <code>:y &#61; f&#40;AsTable&#40;cols&#41;&#41;</code>会被翻译成<code>AsTable&#40;cols&#41; &#61;&gt; f &#61;&gt; :y</code>, 所以, 在用<code>:y &#61; fun</code>的操作时, 不能混用<code>AsTable</code>和<code>:col_id</code>:<br> <code>:y &#61; sum&#40;AsTable&#40;cols&#41;&#41; &#43; :d</code> 会报错。 
</fieldset>
 </div>

<fieldset class="admon admon-note">
<legend class="admon-legend admon-legend-note"> 📘 `AsTable` 和 `@astable`</legend>
  目前为止, 我们看到<code>AsTable</code>和<code>@astable</code>出现的三种场合:</p>
<ol>
<li><p>表达式左边: <code>&#36;AsTable &#61; f&#40;:a, :b&#41;</code></p>
</li>
<li><p>在表达式内用<code>@astable</code></p>
</li>
<li><p>表达式右边: <code>AsTable&#40;cols&#41;</code></p>
</li>
</ol>
<p>这三种用法的区别总结如下:</p>
<table><tr><th align="right">操作</th><th align="left">目的</th><th align="right">注意</th></tr><tr><td align="right">左侧的<code>&#36;AsTable</code></td><td align="left">批量<strong>创建</strong>多列, 这些列的名字是根据脚本生成的&#40;不提前知道&#41;</td><td align="right">需要<code>&#36;</code>转移</td></tr><tr><td align="right"><code>@astable</code></td><td align="left">批量<strong>创建</strong>多列, 这些列名字提前已知</td><td align="right"></td></tr><tr><td align="right">右侧的<code>AsTable</code></td><td align="left">同时<strong>处理</strong>多列</td><td align="right">需要输入列名</td></tr></table>
<p>
</fieldset>

<h4 id="用转义"><a href="#用转义" class="header-anchor">用<code>&#36;</code>转义</a></h4>
<p>在<code>DataFrameMeta.jl</code>中, 用<code>&#36;</code>充当DF的列名变量的转义符, 变量存储的值可以是<code>Symbol</code>或<code>String</code><span class="cadmon sadmon-todo">或<code>Int</code>表示列号&#40;有限制&#41;</span>, 也可以直接对字面量进行转义。</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;A &#61; 1:3, B &#61; &#91;2, 1, 2&#93;&#41;

nameA &#61; :A
nameA_string &#61; &quot;A&quot;
df2 &#61; @transform&#40;df, :C &#61; :B - &#36;nameA&#41;
df2 &#61; @transform&#40;df, :C &#61; :B - &#36;nameA_string&#41;
df2 &#61; @transform&#40;df, :C &#61; :B - &#36;&quot;A&quot;&#41;
df2 &#61; @transform&#40;df, :C &#61; :B - &#36;:A&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<p><code>&#36;</code>也可以用于创建新列:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61; DataFrame&#40;A &#61; 1:3, B &#61; &#91;2, 1, 2&#93;&#41;

newcol &#61; &quot;C&quot;
@select&#40;df, &#36;newcol &#61; :A &#43; :B&#41;

@by&#40;df, :B, &#36;&#40;&quot;A complicated&quot; * &quot; new name&quot;&#41; &#61; first&#40;:A&#41;&#41;

nameC &#61; &quot;C&quot;
df3 &#61; @eachrow df begin
    @newcol &#36;nameC::Vector&#123;Int&#125;
    &#36;nameC &#61; :A
end</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<p>当用<code>&#36;</code>转义<code>Int</code>时, 有限制: <span class="cadmon sadmon-todo">不允许混合使用<code>Int</code>的转义和其他类型的列名表示</span>:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">@transform&#40;df, :y &#61; &#36;1 &#43; &#36;2&#41; # 正常
@transform&#40;df, :y &#61; :A &#43; &#36;2&#41; # 报错

# 本质上是因为DataFrame在&#96;source &#61;&gt; fun &#61;&gt; dest&#96;表达式中, 要求&#96;source&#96;必须是同一种类型:
transform&#40;df, &#91;:A, :B&#93; &#61;&gt; &#40;&#43;&#41; &#61;&gt; :y&#41;  # 正常
transform&#40;df, &#91;:A, &quot;B&quot;&#93; &#61;&gt; &#40;&#43;&#41; &#61;&gt; :y&#41; # 报错</code></pre>
<p><div class="code-lag">julia</div></fieldset>

<fieldset class="admon admon-note">
<legend class="admon-legend admon-legend-note"> Note</legend>
  为了保持一致, <code>@with</code>和<code>@eachrow</code>也有这种限制: 整数引用<code>&#36;1, &#36;2</code>不能与<code>Symbol</code>或者<code>String</code>类型的列引用共同使用。 
</fieldset>

<p>被<code>&#36;&#40;&#41;</code>包裹的函数会<span class="sadmon sadmon-warn">绕过</span>DataFramesMeta.jl的匿名函数, 直接传递给<code>DataFrames.jl</code>的函数。这个特性使得<code>src &#61;&gt; func &#61;&gt; dest</code>可以通过<code>&#36;&#40;&#41;</code>包裹, 用在<code>DataFramesMeta.jl</code>的宏操作中:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">using Statistics

df &#61; DataFrame&#40;a &#61; &#91;1, 2&#93;, b &#61; &#91;30, 40&#93;&#41;;
@transform df &#36;&#40;&#91;:a, :b&#93; .&#61;&gt; &#91;sum mean&#93;&#41;

# 也可以通过变量传递:
my_transformation &#61; :a &#61;&gt; &#40;t -&gt; t .&#43; 100&#41; &#61;&gt; :c;
@transform df begin
    &#36;my_transformation
    :d &#61; :b .&#43; 200
end</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<p>利用<code>&#36;</code>可以在宏操作中方便地选择多列:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">select&#40;df, &#91;:a, :b&#93;&#41;
@select df &#36;&#91;:a, :b&#93;

select&#40;df, r&quot;^a&quot;&#41;
@select df &#36;&#40;r&quot;^a&quot;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>

<fieldset class="admon admon-warn">
<legend class="admon-legend admon-legend-warn"> Warn</legend>
</p>
<ul>
<li><p>用<code>&#36;&#40;&#41;</code>进行多参数选择的时候, 必须保证所有的参数都被<code>&#36;&#40;&#41;</code>包裹: <code>@select df :y &#61; f&#40;&#36;&#91;:a, :b&#93;&#41;</code>会报错。</p>
</li>
<li><p><code>DataFrame.jl</code>中不支持多列选择的函数, 其对应的宏也不支持: </p>
</li>
</ul>
<p><div class="indent-block" style="margin-left: 2em !important"></p>
<pre><code class="language-julia">subset&#40;df, &#91;:a, :b&#93;&#41; # error
@subset df &#36;&#91;:a, :b&#93; # error</code></pre>
<p>支持多列选择的宏有:</p>
<ul>
<li><p>@select</p>
</li>
<li><p>@transform</p>
</li>
<li><p>@combine</p>
</li>
<li><p>@by</p>
</li>
</ul>
<p></div> 
</fieldset>


<fieldset class="admon admon-warn">
<legend class="admon-legend admon-legend-warn"> Warn</legend>
 <code>@orderby</code>和<code>@with</code>没有对应的<code>DataFrames.jl</code>中的函数, 所以尽量不要在这两个宏中用<code>&#36;</code>转义, 以后很有可能会有变动。 
</fieldset>


<fieldset class="hadmon admon-tip"><legend class="hadmon-legend admon-legend-tip"> 总结</legend>
</p>
<ul>
<li><p>所有不被<code>&#36;&#40;&#41;</code>转义的参数, 都会被宏用于构建匿名函数, 且在这些表达式中, 只支持单列选择;</p>
</li>
<li><p>被<code>&#36;&#40;&#41;</code>包裹的参数会被<strong>直接传给</strong><code>DataFrames.jl</code>中的对应函数, 所以可以允许多列选择, 包括:</p>
<ul>
<li><p><code>&#36;&#91;:x, :y&#93;</code>, <code>&#36;&#91;&quot;x&quot;, &quot;y&quot;&#93;</code>, <code>&#36;&#91;1, 2&#93;</code></p>
</li>
<li><p>正则表达式<code>&#36;&#40;r&quot;^a&quot;&#41;</code></p>
</li>
<li><p>过滤方法: <code>&#36;&#40;Not&#40;:x&#41;&#41;</code>, <code>&#36;&#40;Between&#40;:a, :z&#41;&#41;</code></p>
</li>
</ul>
</li>
<li><p><code>@with</code>, <code>@subset</code>, <code>@orderby</code>不支持多列选择;</p>
</li>
<li><p>可以用<code>&#36;&#40;&#41;</code>包裹<code>src &#61;&gt; fun &#61;&gt; dest</code>进行操作, 但是不建议这么操作</p>
</li>
</ul>
<p>
</fieldset>

<h4 id="用忽略把对应的symbol解析成列名"><a href="#用忽略把对应的symbol解析成列名" class="header-anchor">用<code>^</code>忽略把对应的<code>Symbol</code>解析成列名</a></h4>
<p>这个规则对所有<code>DataFramesMeta</code>中的宏都适用。</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">df &#61;DataFrame&#40;x &#61; &#91;1, 1, 2, 2&#93;, y &#61; &#91;1, 2, 101, 102&#93;&#41;;
@select&#40;df, :x2 &#61; :x, :x3 &#61; ^&#40;:x&#41;&#41;</code></pre>
<p><div class="code-lag">julia</div></fieldset>
<h4 id="用chain宏管道操作"><a href="#用chain宏管道操作" class="header-anchor">用<code>@chain</code>宏管道操作</a></h4>
<p><code>@chain</code>宏是来自<code>Chain.jl</code>包的, <code>DataFramesMeta</code>包重载了这个宏, 让其可以支持管道DF的宏操作:</p>
<fieldset class="code code-julia"><legend class="code-legend code-legend-julia">julia</legend></p>
<pre><code class="language-julia">using Statistics 

df &#61; DataFrame&#40;a &#61; repeat&#40;1:5, outer &#61; 20&#41;,
               b &#61; repeat&#40;&#91;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#93;, inner &#61; 25&#41;,
               x &#61; repeat&#40;1:20, inner &#61; 5&#41;&#41;

x_thread &#61; @chain df begin
    @transform&#40;:y &#61; 10 * :x&#41;
    @subset&#40;:a .&gt; 2&#41;
    @by&#40;:b, :meanX &#61; mean&#40;:x&#41;, :meanY &#61; mean&#40;:y&#41;&#41;
    @orderby&#40;:meanX&#41;
    @select&#40;:meanX, :meanY, :var &#61; :b&#41;
end

# Get the sum of all columns after 
# a few transformations
@chain df begin 
    @transform&#40;:y &#61; 10 .* :x&#41;
    @subset&#40;:a .&gt; 2&#41;
    @select&#40;:a, :y, :x&#41;
    reduce&#40;&#43;, eachcol&#40;_&#41;&#41;
end

# @aside 宏用以临时跳出管道, 也是Chain.jl中的
@chain df begin 
    @transform :y &#61; 10 .* :x
    @aside y_mean &#61; mean&#40;_.y&#41;
    @select :y_standardize &#61; :y .- y_mean
end</code></pre>
<p><div class="code-lag">julia</div></fieldset>


</div>
<!-- article style -->


 <hr>

<script src="https://utteranc.es/client.js"
    repo="songtaogui/blog_comments"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>


<hr> 

<div class="container">
    
    <footer class="site-footer">
        <p class="powered-by">
          <script type="text/javascript" src="//rf.revolvermaps.com/0/0/4.js?i=5jnkqismgmy&amp;m=5&amp;h=128&amp;c=baff00&amp;r=0" async="async"></script><br>
            Total visits: <span id="busuanzi_value_site_pv"></span>.<br>
            Built with <a href="https://franklinjl.org" target="_blank" rel="noopener">Franklin.jl</a> and <a
                href="https://julialang.org" target="_blank" rel="noopener">Julia</a>.<br>
            Texts are licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.<br>
            Codes are licensed under the <a href="https://mit-license.org/">MIT License</a>.<br>
            <strong>&copy; Songtao Gui</strong>. Last modified: April 29, 2023.
          </p>
    </footer>
    
</div>
</div>


</div>
<!--article container -->
</article>


<!-- CONTENT ENDS HERE -->

 <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>
 

<script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js
    integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js
    integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js
    integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script>
<script src="/libs/academic/academic.min.js"></script>
<script src="/libs/pure/ui.js"></script>

</body>


 <a class="js-back-to-top back-to-top-button" href="#">
    <img src="/assets/img/up.svg" style="width: 100px;">
</a>
<!-- <button class="js-back-to-top back-to-top-button" title="BackToTop">︽</button> -->
<script src="https://cdn.staticfile.org/jquery/2.2.4/jquery.min.js"></script>
<script>
    $(function () {
        var $win = $(window);
        var $backToTop = $('.js-back-to-top');
        // 当用户滚动到离顶部100像素时，展示回到顶部按钮
        $win.scroll(function () {
            if ($win.scrollTop() > 100) {
                $backToTop.show();
            } else {
                $backToTop.hide();
            }
        });
        // 当用户点击按钮时，通过动画效果返回头部
        $backToTop.click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 200);
        });
    });
</script>
<style>
    /* back to top button */
    .back-to-top-button {
        display: none;
        position: fixed;
        width: 50px;
        bottom: 3%;
        right: 3%;
        z-index: 99;
        font-size: 15px;
        border: 0px solid #696969;
        background-color: #fff;
        color: #222222;
        outline: none;
        cursor: pointer;
        padding: 7px;
        border-radius: 40px;
    }

    .back-to-top-button:hover {
        background-color: #c0dbf5;
        color: #fff;
    }
</style> 


<!-- PJAX配置: 先不搞了! -->
<!--   
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  
  <script>
    var pjax = new Pjax({
      elements: "a",
      selectors: [
        "title",
        "meta[name=description]",
        ".the-header",
        ".the-content",
        ".the-sidebar",
      ]
    })
  </script> -->

</html>



