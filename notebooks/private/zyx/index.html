<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6320268aa5237eefb688008a47a4e267c66871c30fe25c1af7950bfbc0b8a7bc8e7d9042cdffd644615a8811ea0edb85af8e4a374786f3ddfe78b72026b608362dc6edb8623111bcb26340a30121ee49c2757521a944a3f7a21827e88bfb4695cb4a2182ef8a7c3c82870986741ac4544202db9ec73b2000ba73a301a146a912b2de21a1d677235ec010d8e446dfe50b1b14d89ddbb1fe9c8985321fdee3f1a7e463611e093f1af70e22399c8f6391ba4b0c89f867652870b3d65e42071e186b51554c1bdd30074b6a9f39b40d4e1170f38ed75913ef6fcccbd7a24f4b024a51bcb2f437457b394d0702f45513b98e35ceed65886f4d63a1a2c2e26f8f0ba30dc97b6e86027a4715f16920d9e1877594ee3e64881c9f91d20aa216f7d967c73a9002550c8583facb1bb4d1927d28c4614d90442b1358685220293f4133872e5061d9a58f5d77a1be042afbeb0e193b433adb9ad0e1d348916f814eef5e4deec533ce436036194ac715ed3be9a776414f50a0c06d20ca78efa730fa7404a52e7b80ed110bbcb182fc65b08443136afce30236211c9aaa9cd8c7b5a2b0391dfe54643ed0d14fe7ee343ba24091a8f13ec248c0c4a02011b8544c67d89d8cbc57478ef7a5ccbfa189207ac4b34f612a2279c5e83ddd4df43734d7691ee8741d9548854c3fb49592fb566db9bb3a440bcb7686df1fa6bfa888f2b7ddcb0f5bf85b94748146071817ce1f1ac391fea36d8fb18bfd94bfd7d3585aa443f0452252d4102361ae0cb98ebb372dbdf4e76360d90026d7e0ba548260ea89a08d8660d73258d9891eafefcddc0fe2f83744bdb6b56b8b7dbad792d1c4ae26f8156e903119832811e7e05b53231e5025aa857912518074daa8983b957a99f4e06d89f652d8431f6529a553ba57ce950f50923581d24556f3dd99f8ab2f681a5136a7e4c39aea83f1fc906c80cb276cc7b2d163962f1c5d15bf713757b5e7865f5a8254de71fa2cf78edb0f57bd55d4040929ed9c1050c24ced42d81b6a4886355482d3395ef6e489a155f567423d0b31f8b8cd9e9e824651f09547657f37917baf362251ea15e0cb065a71b86ad858d2057c893f4dd7cbaa9e2cc434a69e37b11ffc42fb46f35195f81ee15e9e11635e8c74ab7184873bbd25a44500323a579a0343493ee3503184caefe975d8236beeabc0c376302c2838e0efad3b32c3b847c76c64617ba1f51499b525b1a7a2011abb772a7d700db2f39857507e347139f309485b1d1b25b50b20c49bd473adfc3ef3879ec1f5e33fbd77933f55728c34d1015b42c5b32c14559935662bfdc16fd8614a01791cdcfbfe03dbc1073737d268041e7063f00d6265d67d932fbd7e1598b8f3e1853c4c10150e19b4e663a8222edfa11882c719c2e30b836ccb09b3299391caf66629c802bdbac293d0daf0fe0a22dd657dddf0d6a758fed0664ea3a1cdb4139620d6a291477f98be26a927e5bfea87587fd6e58d2af17622cc76a617c423271c3a235b375d35e7c12c5fab1ce793de6be211acadc8a99fcc2af8a8b1b1d277e5b38e8138ba4a36b7ee75d9aae4b1889376be76b41151688a47302a350618dd7cbf9c6477fa8ab54e4623e7f7292f04e354dc6ed46016032049432146d5faa01485d844109d605aefbd8ced823450e5c9a5fafb7b2ad45bd58a71ae3b05b76914216609205eff7949a986f249a37e7a6bc0bc3309d0ec19bd7cec44a4106c46839d11617853caaa5cc81826dfc1ebc4ceca7ada7e8ef90f3933d56d2bc4f6a9ec73f528d57f891af356ef7c4e3fea57074b5ac058100669cfe43204baa824bb429195e1425bac878d60222bb7cb72aa5a909e1daad7e0a02cd5883cc6012d4bec03cc96a51f64b0b66876089040f5c2fab4f327a386eac1cc3a0dcee2737c936732eb59671fcc09eec663a56425b6127d356ffc2124a1a8d2b02905886043dc2f3e9449db848101204ccb7a6e2019f5282d8fcbd26b0ea1ee35cb6b0c6d5500713506c565b0b8d821c827992b14cbab6ebb87024925da338241f78ac8517287c46d75fa7b33e9384ebd7f78e8a117b44adb4c07ee757c9c464335dcb7e284a33f735ce5aa4eb458d363d9c58a1b29845fe10fdb71aede240566ea4f5725b1103a553ab7af59cda99a46418c6785248d0ee1c59a89fb2fb1fe893dd39adb0ee5e401c095cb664999a94b615a61b44c51818297619b5afed07c9294c0c0315063208b6162f46d1aabf43ffd74d3036d5fb91802261a16527d68f0dd8c726a1fe27e8b553d99a4103e67b9a1a899fba767209350d4faf4db3fce3c5b27641b0ba77d3dc15633f1dcb05c9de92570adbf1879d388c7d67cc7831cad171d8d8d2b8d201fff3164ea0e25b2c5ecd2f3c443f7499c39b58649585cc32d7f587d99c8c42ea933423b0f5000ade4974613fada710d9fc87cf6112daf482ea29aab056484c658261a66a635aff1b4466c8adbd9a6d59d93c8826d1d98c6ed699623763de5da347f71b95e0d28161068d00faee12dbde64abd6f1c0842f103441c2be8eab13fe6af3b198af9b0f3f4806fbfbd3057f67d38bb1843ffdf5202e224625e73728db9c6616e145b1c182795a3665f178307397152d8a9d2bac65d92678f4bc1052cf46a47829a2dc92b9e793aec6e034d756b59df99ac624269136f6c81dd412b7b3337b4899437738e583f7e963bb304c0e3478d18da87d5bcc012838da2d88ce3c6d358b88f379ecd8abfda4638cff40ee1e7ea0c8f8bc748ab0c7ee6d636eea60fe8ee845ed1b0d4ae7bfffcb99d0492fc9ee3ecde4b17faa8e42687ab5f110389b31831d53c2d36736cdd40d4ce68880345d428d6cb5f39cf802d2cc88201c100eba6e47a62cbc4275d4457dfac458d50b544177d7c56a0cfb9b8eaf2130d5b09a84b695a5d358248d785534500fcd210c83ac4ea08e29b0ef4aa07a9cfa9327bff4b9f244e3b6f89866e07df44bd5ca9c817f467663ddf9df57817cadfcff2b944d0c48d7caa1c07d92544edb2e0c8a55158f9c8a1a71c032471f40ef717beb4409e58eacc69b103ace5cd94a4ba96c92caa6ac68293ce306e0f330cc0fe8092d81fe84504899cdf31566c1016c2371269fdbc0fa1bee9fdcd8a802ab4a82a023edd98d060fb6e9166cdab86ec3f82b6b044da6ce2adecc3cbbaafd185948c6404e92984efa030504b9a20386a884b8fe25a66546a55d4bc63a2b11e4802856391ba9d6d9ebf6f85e3190d35f97b2a7477be8a043af65a4fe82e2d5a28c04f850bf696def639ac667bd1f5da339ed19220bae1341648d250eeaa110e55e36941a326317632d996bcad79d208aefd3a408146161e3b2b86b32150ada1598c20aefed580d190a7618399ba1da55dec843b8c92a6bafbea56272dab829753326332a928ed38d13fbf89ebed3d0453e4d285df0f4c4b154d6d1d322e67db7a061eb1606b135ab6c4df8109e265b7e828e305b4e44744c9b4598e7dcbd7f3eb0ecc20be3656d1a9bfa0f8995a69b8d7bb8087943375dd3c75985947bd007fa67857747a6eecfb0e0da59a94efc02988a1006011ac4c319d96a9a201545314445773e92b9701fa6d708f718a09ffe249a1834ef684e08f05cf8de8e16676ee7a72f11d9291da3fbb564c64674e42100074c130a10b6531061ddafd9011d4eb276ee0dc280d9521fedfb0dda8d4fcc761a320991fcfcb65b58351bcdafb839b3563f44c456aea959c9f070926b6fa83e127dd34305ba702de1aaa1d63cf85740e5713a390ca794abea3b0df87e74b60f59c44035a8899a4c56796f41d4530c6466f6537fabb4c29f47f3d8d63e569dc1999c050f31e84b12d681442e76b82ef6bee2763986a711e1fc7fe6b556696bcd2273db2b20c00365ade5fd37f455b07defbc9c95e7ee48b5224007f123188e419e84a2d427c0d74bc1a4818282fa421cbd0ffd9b621544639bc0d4b68785672f729768e2b59a303fae95f5f3e52e5172a8c9f0580e1de8d7186b3344d84acabc4ae3e5e4feac7701f49494c5be81c993dca7e7ae4455f0c2c68aceb94a840bdeea96070c547dc8b90a5f04aaf7130c5df4308028f239a63d3a57ec7bee5f13eeb0ba2fdd3f1e13a07c858ab785caada9ac799a621d63c86612cd4e98160b6b0fc7fd482602c7671299c7050909224c26e4fb5c33483d2d29dd15ab601024d27dccf4edd5622c9206c3a716ec1637a90410cdccbe9a230264d7ff718aa88c69fb71c3afd45a90b59f177f15855bf86c6d3fde8e30d82b030158a234d7c6ab7705efb511d1bd380d496424700de6d16d931fb507e497985169ef5c5a3eea87e6c908f96d3723ca42ac6224a137eee70760132b0bef3a80ffe1f66e608851b04e2ff1f31690461e219493d27598f1a211baf73b758471eb2e3227d77fed742daf8c487ca1589de23f4bfe3cfc4373cc42acfcfa65fbfc64eab81825186c720e594b9bed90a404270729208eea604041ec90a087e3ad329713c1aaffea4053b774cbfc0626f47f793753177791105d652d5179659a460a75ae141b989c7d4d239d5924ba178a736db27497b56b3a864c4b2f7c7f8bf9f5db992edc7e0c2f8d1a0eec6d95dd5ebd72c826bf52e16d99913d62166aafad8f5142bee6873139a5b775e39e7b0992a9e193ad9a4beb10ec74c6757f6e93d83f9854cfb6d6e383011f8018a704278dff519d4a7b4a96a616b74a47fa9572c4cd5fb1ed7e3c3dc6ee07c51e9737fb9a134ee77b9c898695ef8310599aa08deb7a35e4ca070722a4d8fc8290427ac7009a3bf761ae686b0a14ede739fe8e2d9d4b327c66c6f0b65bd983ae3163ebe1d6aac0236abc759bb27b3d201a80c13cf3c91cd2fd670e31ecc636ade5cccdd46e9e2066736b586f535a4d46c9082bf1bcfb5e81886c991c2fabcaaa2e135ab71d05ec1d0fb9e1845bcdaf5847ebe2f1bd38a9ace838744b52f9aa749a4b55b0f9eb14f05e0618ae5484fe7829636d922aef69117845e16f60ceb99ef509845daf9d3ffaa5014e88c88f51505b24877678aeb0745e10b8757af6219ede49f631265deed032fc7c432e9acc7e74bcc5ccd3126851e3b3ebab8e4a1fdcefbd23cce76d3aaa3aefbcdcdf5dab4fe3196fbfcb6d4e0f4a49ac9211c2cbbeb771d6d0a636334e197923c793d8e4b1959b573a5053751658181e2b2a185640559f6ff16073c9a3d9888db79fb96940438e438b9b0f008ef82cf5616a17a180e89b041dc855b68f12583f451154e93242b18ae29468f1e2545c63a852551c0f2d6f8e6aef4107a7e662c58d0b3e2a66e7997142cada3a5cc8cf7fc4e12f6ab3565b4082efb20061f2d7990e0d28006a257bfc4866e081ef8f502f1e2d1575984848dff59602e5db24ba53748662f3408fda7faf8663b81d8bf699137a7b114a6b0c963f476999a1f07943044b28fd52e9642618ce20e0ebb7fa0b63ee580ba423441a68e01b50d916b5deada1e357702d9addf8e6951ee54fa8b85c048b2b5cefd31da178f58b68c928a9e6f04086f11bdcebf76dfd33ee6fa0ff0e3bef28670a8e96eeb84ed8e9cf8ef9cf9d1b02d6fe8c938514a8539bf2663a41cea096b4d3b4faccf19327459c5e997672227d0a784da0f3aecf5b4b94567c3a482612d02e8f034f857645ab452a3cb4913c70482f0c30b7c57420123a5f473c59f22a90ed19bb6339b7a992f781eb1c79955b86c5397516ea48a9db8719ea7af2ac0ebfd58c04a983daba820bcfaa81233e3ea6d34cc41df8f7ea1aa8cecf1e7d76b3dcdb627b66b36ebfbcc226661c81660926749d97366f483caec3336eafffcd3b721bfc74483f0a522b37eb81607f6a19f38bd9bc8402bde8281185e3314131ca13bcd7355d4ba669be59f1eb3a13856fb223bda23643dcdd3db12a685b29ba168aab50d55d51ea621164e92fa9fdd055a6fbe7e71eaaee1240e32b937542e15b39a305e19013902cffa47ae43aae574d29f8feeec3858439c53236419d93dbdc2bc2ade291d47effe4e30f5a6e64e60f8de5a7968484b1c13b807f55d0987e400b6eb8bafbd6a792379b9ec86dbeb08ca10d0f9ab27232c256fe73980482a0810a0968b0875edd571a76ec824539d2ac62c51f34b7874746d5ce76d9d67ceec12905846e17a5a9833870dbd0c7edbf6b64679984df473c1a600620be6119f960a1d4c3d7d4c20b9821ce687236fa2b79817b2af4f78824055b83f022261c49e277f2de4107cabb8fd7537ee8a7d941cc9242a88e958643d68f6a22f5cf3f71110cd582217a38d519ce987694c4e4ebd5fc1ca9747042eb16dfdbc4586da68b12bbc632747537f05e19175d22c9ea7621b71ba46c25b78fa1f47e8e0799cf5a0ff51588fdffae0404b12d3395ce63676ca967d0a94086649322a950f4fa9efa628e83b2bcedb73e81e46f3b9db2f942692218c624e30696a299435eee5cc9f807b24eea32f3bbb95abe1f44a99746f2cef86e8a9301cb009796a26fdf1569b25106e912c19f01bd6d879e415e9830389a4557b525fb03601662cf30ec1a6c185d113ddc781ef2e685585fc75cd5184c89010ae810af3bd1b9aedbf9ee64032f0251bd9a955fa5b61cd73505d279bbcefb51ba4d0943a592c206fe6487986ae0119e988995e1c06a2a8d678a591d549396ce5f4bf0ad96ec55e1c06a0278beb42ed934257aab05a27545d5615467ebe33a629c20e43545e0bd7ef644979da7aa811ba25ff1fcf150200518f1bda706353d3f43e35cdca9c44a99e52b49956ec5166826ffeb681bf3126f98ef09e58b2512734e7b865b5bb65a850b300cdd202c577950f815c90701749240242503ce3dd916407c7cd34da41cdf20be811708b23e253e75add08cba718a38b1fb75988f6e845e4993da2db192f90f643cbcee4b6af88e81559ae46813e11eeed0510c42ad7566d8120c04c9ef7d312b64882c9fc505839ff1a6fffc91e8a990a13656a86b57d60750aa2fd7d9fbea7492f7c1ed370be804fbcddaef16f1e817f289b06ec5951c723208a723c07bc055b2a3e00079a9c5117edb4fe5a727be56ac842c705ba641c035d72c546aa8ab24aa4116c551d93c0a540367b845a5ad52b2c063864ceae4955031d59633d1d0b3eb954292ebec21da09521c60f6e1ff27fa31477383787d92099b9c06d63e0b46508cb91fe5096bee46becd0c2d750c35d393a46297069a2ccdb29cbb8ec4d960cd13aa3f83a04bb90a3d03c76fb7c5d12551d9e8a7e6402bd23e3195050a9771d4c60641ef6c74fdd489ddbe838ad6b43147c565d911cc3bd809c6e7d0fa2fb23c9a2a6bbf7b023c551bf543d34fc8bd766a567cdb57d371791d7f39571c8e75352e468e15e4128e3eab6a1012525d9e65104186e29a1ca15715b39d4aa47f305ec35270640d9a2d1e0ad52c897bd01243119d5311483bc2857c70559c52adad79667468b3074252a78e058ede07684c63f80e57f21c1a7171442af0e7224e3adf1c3247e93671fb3337f992452a379144bd7a8ced046af186241c103f2441d4155720c6618b5b5f11734062453b6af0308345ec9fe075ba3e5e18244a3785e53ed8c4ed26be334d824885d5f46627f53998a7d13cc01797f507aabe0222db03e70a6ef88b3be09a83ea14338fc14cc90116280f220e695eae6782acbc1123b5d2f1200c0a0a36af0a0b9ef2abeb2003b352104e66fec918f2d74f0b836b959bd5eb164304835246a6bb418aa2cae960f38c403083dea94945f5a6fd6280210e1cee46dab3244c083cc43a27f94b1a48a7b24433a2e726fd30efac1407c7531711e0cbc0d574ecf156c6b037c91b1f555a4283c60eff7ab1e71212853c3631738c86547d645eba37350b2e3c56ed5534e1d9614c3d25cf3624dc4023c57e26cabec09cdf5ac2a74a7f127ddec5f769c9a380c226a899c81dbda600d2a6e4f1d18158273d0ab6e15dfafba05cc812ba2f336bd61fd49649f28ed0ee48142a3ddde0caca176c1e89f53ca6d4b8dfbbe7015675421822d8585b10788f7444a41699e18f1a0e14916cc05ae145f6f9c4f550ecbb910375f71b17b96c6f1d9fa13fad8ba6351d82c371c2bc2d6a7885b11be60bd1e4440b80b3e2f75eff640a92bd2ae76a28bdf0ba3a07f02aaf139012031b0eba9002a9d54e9d8ff696819f52dc08727297f7eca761797e53937cc6b832ace551919d7d99058baa2e26a50d929421d099ee0b3f8e3ba1ddfd5d6e26a3ff4ce85b66d5c9d5ded2f8d47ac73d8aeabc599039a9be78e0b9ce1b8d2b20c55ceb937647c6f63289cd5cecc0e3fd67b4c348572a62cef7f26d2481d008014a0074b71096eead350fc998bb74beae34b3a3f481481ea22c96a2ae49fd9c0df463d485f75e4f886a309dc1da1defb3886193368429222458b162670d0fb8f77ca411c6e61e43a64db7c5e035baf6650edb4b374af22cb355c2575c4b3cf7e89042264d381ddd3f5613da70076ff260104dcbd70943f2a5763947e2d1b70a18b2be1f6d50cca00ea3691cccd07c25fa06d2f40563ed487ca527a7b2af0fea7e737f4915717e8848c71bab4d87d5fef836438d11471240aa12119bb38e3b80a62d34f3324f62c7c65fc757341a3ff88bbcdb668a5f4622bd77e9feb58bed88ba8350f1d9c3ceffdbb747cc7e2eecee0bf77adaacaea8e1c7145059889ed94fe6fec7976b45c1140002589154b04058dbd4f56e7c628bd9ee601d77923bb1e46e700f8b002a7213afe8264bcbe1041b3c8d1fa64819b5a9a68421d4c9f7187059eff98fb8c786a74daab7492a458d133c0c1b3e7291f1d146e66e0f0fda259900e387eb575c7fc03a2704f8f5ad8328acc09ce3db590e8b9df1a616a478cc18d87dd19a155680152feae8497733452b87279bc7873cfdaffab6bd243c40efa5677788402664dafe17dcf7aba51c787461cb952bc46ba49343ef0c4d2590456e11752828682fce154076399cccade36320d1b1285c7c95c36b5b9e59d388d107b588812e2a86e57944446ecc3f7f90558613f5eced991e9c53aa773059e9b22db4ec5dd27c79f4715b2f25f98fe775339c8fd7401eaf4cd7d258cc33ff95ef2562ea4df804b168dcdf29d4d60dfc97b44e184d0db97decefc863e688c584557d6e791c8441facff42c84b978afa5d2aaf8339eedadfb8814c0bea3d41fbd6fae9914d50b9e95274add47709b4c9f905b701559b86549c9211e988dfe7ec9e1cfa1730361125e9603ee48abdce9d9712135a3800e19c4abb7e15ddc8821df59e4f94d42e59820eb4b0fa301387f2a9ceea3d1c84320a7ae0c20c12a9dcb667f56d931748977c72ce9942c9a759c3fc8c407af7b2340c054af24a47c176f9ce9eead89f609ce208b18275e3b017205bc7731998faf0410cb60fa589693c69dec399e24f4c436d95039f34938681402bf4648912a6fc69790ebe663f6e8beaf90eb52110f93c424cf1d26185d5fe8e1e9018f98c2e87a16ef88f08f88f52a0ef3a06f3cc826532d49b8be687b15500e6eb70fc6513bd10849858390f6a7e77a47a9c766403edac4c3c9071d1020752a94ea7f6b319bfa77a7d972437e0dc1d980a79157eed7121339551f0d8b817158bb570feb69505e5a6bc17ad690c6d6a00e5e046d1fc50f8be885e74ec0dbf1e613ee9e9cd02a6e31526ac65dc1d6385090f9da11678a1980c7c387494bcc3d223055be7d6203783a118d6bdfba567b8c110da0da4a5cbcffda3c0df5d7eeb896cd044cccf4ddca2293bba3364291001abeaeed8a985d750c8cea665d31d2d61cafd4c9103db8828e9525d77c9474fceabb44016832183387ced7a1e0e409ddb41bfed22af945ec6b4ed9227ea6565fb05605f2a7dd7bb0cd0aa3a42691a78650aa5e851b2cd9a97dd78df2bd9590682c567aa1b09d8c598d221c18c177d75e000dc5ec40bb9279452c41fd292463973cf2e0e5cf14a2413a9a074f60478f30405dd3383c0969047c7d0fe45da9ec3da3d011d215ae05c17d8a4d2668c486d20a26e0e29c0e9242effd035c7f06f88730a1dbd93c7f267047d0ff3447da91bcd447b7d31c70b6337f5dbfccf15aaff621f31d7defd536f2c6b9cb19f414724f3fa74f39b94f72b61a827d48b3acc04476e99844810f6ff0d7c5bf8bcf2545efc5c06ea9c44144b1c67a734656132c6a07a88ddb4b649748b79d588d78f8524a2195dae14736a0a831da780138848ffc657a2dd0fef6618b21aef230c7f02be6e7b602f2998ade9718c0d9cc330a46b7df9415429a856d1a2573269552beb6969001a91e37993b483705a72294386782fcc9e6a1bed6878fd5a7203616301bedc0a6721b81061515096d20b33d1215aeb7c48e8f4b9284f752e4df12f715068b13a6402adafd3b351ec81cb6c63a4084c6b3c6f4aba52d870b0fc1472d859a3b87e04c0ab4bd1f987da640c9cd5be7ab62c0ab3858b6cee35761063ee3fc1c8f770a27d3008b2818c058f09bff5ef9a693712dc76952cfb9fe009204fadef9b88a179880cb6dbd3b530ade8a89954ab60da2cb8f148d4716fe183e10bf55ad6e1d8524e7f0691af4a276dec9f0910df25d188ded1b413493f49b53583eef6cdd70e0c5392d8ae755c31b95c707543e164771bcd630c32423099c323cf78c6c4c1878d8e8590f6fce0e954e900c635647aac09166de6a189be499feadd4f178e16d47c5253240a7c5ff20003a5c627eb41321c310635c049ceab63cc8e1bad85ae813bea5d4b4beb2f46329d100d8944b5d8571b52845945f7bf15eba62c262e99a87300c1acae7973b3ac413d7024c69d185bd3560a060763a861e6459278e0b0df9e10ec32e1eaa2f92364a03488f746e6afc90ebf6d849a1669dd2693db70886ef488a54ed28ba568d82d58fa48bc4b20323ff38cd097ebde118ba328b46c8880427f100fd771d2a3100df40a01e1ea44406be7281a183024b48fcc99ba8345dbbcd5b00afe4259dd0effa834c22b0fd8f3bb77f7002993891927f19fc8f1bd1ba55edfa2910099fb853b1b74ecc62f81a4b357ad71ed18644cd73d0ae4681877dbdc60bc1faaf775da7eaa72c27698d5a79f2d69c1f9c79d99d90769d3119bb0f6ddb19d6c71ea157a85e1b481e20d9e737093aab5eb8b51b37d74674eb362be5e0e6cb6490f0afe3c2f9f0e5c47d78fbff81178030abb2548f5454b984354a7974703547e074b6c71ba34e89de25fbdab784fa7dc8218eab62cb9c67ed4b97230e047988af777cf74a5b73304a0a627be7904446326e5291330c3a9df8b28eb438bff21597e809e5de7ab5097485f2c02376c488b1323ac0b771dd816b15ef28fdafac281eca7aa302196f0edd9458eb2150760ecd3bf9de716435ca449de730c197d156591a1bcd6be7f5a6479710f21473b079604a7d488aeaf226f5cc02f8a92cb34e7297ec541a971a3d76d7dad993d7f910dd4b1026d7c17b544c5c6233430c3003410703b8e9b38adeea5533f3eb5706abbe0de3e13470f902de98f23e9b4c50185b3ffe418111834f9815b8ef09a93fd256da104f53366f10cc7b4cd51a2c0f5f718b82214a46343dddff5a65ae06a07c53d0551f43c376ef380c66ed1504067f0cc0dae44f8ff432169173534571ae69780bff84841cc562c4e6e189c428cbfe964d6e48a38568058b2a870be204f11ecbd7812ce3b81e0e8ddd4f7a7eed3d6bfce55cc5691c98de151b05417b9afb9c559171f134e22892dde67350a76d84eedf9a02302edf59011e34794b490979286c43818b5910e9f0a5d9c0022e21747818b2a53423874000573a8ff1bf4d041fd8d100bdeb9fba3c214fa9f1ba258e478760784d840c6e2769a2713e8b5050c5e61b36a5755d21da86ef41c3d78c8c51f40fcac5daec6e49ac4524d73ed2691f6b8369868ae0eeedfed6f68098360352699f86abd3622c74340299becfba1baf01f11942595d1b58b1216b8bdefec6453295b11130b17b016d050d03a40183af8b109da7af3d102626a03ba279e60cb35a6e4dfea90772ce5c3cfc977da23d1166d329e0e3adc4a9dfc1644d9b219eab0da7c8585cd225aae0987adbdc188f7c571b6e0703ae1d7440381dc2f41a81b6deedac8c2bac9c32e850154eb24c82c2b410eaaadcfbc9dd5f552bc113aff35a5d9385fe45fd1d63c1cf846b8a369a46379c7224a71aadcbfb4737257953d67f085368ae678e3374c3a3bd1c7bcfe076fb6e3b0d2c4513fc8a2556678f1f56da6fd6f4824f00c2103542e1d7947ffd8de87a183eedd61b301ecd45031b908d4e19464fc9761c5addb74e30f0c76bfd69c483498d855f3b83002280ae007064841f3cb19d452bd1ba844de66f37a6bb0d91db851b7ca75ae172d833451c5c2e4daca6ed6bffa1c30bb0b7896409d52704aab3d554bfcbd609400d806b5fa0272784c9882d01572011ffc85564bf0ef94a4bc3e65ae129393b9942a040cf44486a457956e2dce8213a119f6008860ba45eb4666f56e9fb313bb1a67b23a7be4dfe19aa3bcaf05d2b3c0fc11b91252152c8e18a41cde842bdae235fd3c078e6fffa6c4dbc31da1625dbf9d1eaeafe5adf37b55d17ed180de8529207bcdd948be93ed5bf61b7f890983dcef3ccbb6b9f4a0b78748e464c72061928bf7d797dc51fd88ce312e531b824afb9fb7b97fe6d464bde80dbaf3e8afc072eebcddd32d90d700da6f3e223d428d35ba95ef1ecf27c65b66131209074488b6c4af6e60dd7e3a04added79b6eabc3c2511a7a7bf51fd1befa8ebc1acad348a637f29fd3954e95891a597538e77d747a9c6211744b0db297be33884dcd6291aace7cafb24ffaf749118aa297072f3819df1ef475e987c359fae53999fe05350010b2fdc6c5a0dd80cbc5d6839a8ecf5508a0eb07de49d8924df65b5d5e8087185903a7125009a700dae7d7684f21ba32d6043e9b6ae66f309ccdbdbd9e0fbcb5bc5b4e1d29e41b807df7f66941364238aa6fffe96c4cde9532c718acaced19145ed6c04f302a96c83615e7e5a1f144b71b58115bdc919fdbc0f364668b4a07997a1a7ce5b61b2730eb4d6a98624d9de1a043835e2bd7dc18735e934357529546aa045abc1ebeb6cfc92c097760bbeb7814dd444c5d6933f7981c4aed4fd6fb74e5a6b5129ca31d0d573ee81be49c8af344a5c0a9f09d1ab3b85d838450dab7b6e2521ed851791d1ade8e892c5e229b4a7fd2e4d5ef1c388c6363a42d9ebdfdc3a7faf7a0a5489e113bd09b21ad9cba4abfb86134294655c2b707509feb30b14e6aa410a30edc4a8d8d66572a55ad42f11e49322b90361383abddb769ea97c9a34cf47b09139490c19d26806976d02372173ed9f68dd473f70a298b84a5380f341d978e858a408c2bc5eb87107e67c11bc08983f58e761c0c2561ab4877f945234035abeeab4ac19a6abf42cc8868bacd325393897ae066db8a16770e8e9cf3f1b2593231e6d989ed77e8de40720366587d9ec134a8f409010fb9d3f3938cbde019941ea35e02c1ad3ed0bf3bd8e3730912e6a83f07c40d19a652c27924725069d7968a5697e37dfa9f97a74d6dc0864e220df8d21602842b798060cd33b243e2324b6d4a0ec76b815e17fffc38489f5675cbb04700a4d6be64458937fee6d656591bc239e8c371feb167bc17381213ffa0f1e5bc0b96f30b1cb85acc2052b6ae2ecd331dffe53cf8e07d1209b52827a96679077a5e959f546adfca7e31417fb4876248450aef21095567171f2052c8062ea3c39bc3cfae79f1a2f362e9d2dd33088235e2b2c2bac3ac1d2bd65bbeff56236de0f4e504502073cb983b9ae3dee421275af3d86761bc367c78fe471a5d1ba7065ab713b60a7990d2489dfc385c4d03563a8778fbffac3f340c259f2b273946c67b6780fcfa6a133f1a71df6a2dff7457ebb8a96d5bc825d270fb59cf33e3b27d9278c2c18ff5dbee528f28791000b824b661d34a4f616cb88a6760e7603c4f3b9da3ad3e9a9d2334a0ccb4414273d21733925c98ef6ba686dfde016960fcbe65784412b9af7bde8209badf68a809222d4394006e78ab0f47cfbc82018bd383bd45709f3cfbbc51352a56f43a997150eaf3d668c6d0dc77625f25ce26b0824c223533add361d5f4b72a5e6c8c145412c0a8a8b708dbe4c71faa19df98deeaa120cd59767d9fabf85e4c63069674e14ee21ad06cbb67cb1c578370926d6d1696d592b38a6d2984474d6e6b891438251184e8bceeb5814e9f8cb6f282084fb215c14cf3083f9c89b42b94283f051474d5d430c13f91cbfde6db6e7ba39314429e388ab4a103a0ab34af42c84d8fe532e522c1efb1150f903182664c3c19905ce2afa09d7924d864e1be27989d9214dd4c5924f34da3ab6d387bf090e84fa8b651eb11e2f13108e2af4b5357dc122fe66a2177927b2d01e20e4fa3748cd9d5ad1a424f02b29753e73eb2a59a2f85deba60b5ddedd6f1683d640fc26ce1409097979479f1a9f1fb7e3c4cb9060361513cdf7fc29cfe936881ff289e21bb0445e91e380701c227fc3e4ff62e4d415168f0b2a9f61d55a7d5e4e5d165254875365bfb613e958576661151ed670d781a82e0e641a5bf5cc674bdd743db9d2d37138633aad785252c177df6210f1026b329b13f9d3f35515f0449e19e3d244984c5a18f7e436b5abe5682798750c32aa9f942ff2b34bca77ca90693ad58996d792de33bfbb2fc666a4f776a2fe2e2a1d07ee9541af929c385d9353da92824c2712bd5e528dffaa66fe5d463c4e391e0ed7634a0473af897c6d1d470e7025f9d5b678b73def5efea5b3bdddf95162b44ceb74afe191ff835a764739e30d57610db7dabd2083e9aac8a4c28a0180c1c8dd9f087895c8c1aaf51d54c3b57bd7f7264f84ed2a1133f1b8a4ea3d5cb9ab9cfcb77ba5bc90199b82ad5dd08dfcc0e7627abd74d146bac8ab09e3e294742165afdcb1e448d8caf6dea577c6b394450cb1118cb15b93a933b2fb63719b38be30aabf7ab5fc44e6a1df607891aee6f5b52c6a57699e0107535d539919d0671b5251bb26ca7cc938fb0938e479fafa8b412a6300c0fb31a478c745df972eadfa31bba0a1b99edf67841d12c106cf16bbefe27ce1e5357ede5224b61b350d5b1a5fab0e566fefd70277b49a5216a1e8c3bcb1bdf5545ad8364e9fabf229fd5d7d0bbb6070951ce864c1f96ad418f8435c96cb9df0767b4fbf22a059bc09e71051d746914e31f6e4509f5aa67e76575e8cc74d399149c90c87222baf119e463e15da75d1016caf039490d6b83a7c913bacf80104ac173f3457756651c46a04f9f13d6f6d08c521a4bab81608abecfe9124d231320834bc32bfff8901044a3afadf4d8eabb1a3509c029e8d1bf3845e901d6400db41731667297f205b5d2ae646cffdeb7b35a1565b9b34faad8852e1c57b8c9d222de30ba8e232c5c6b44ede77a2b14a042f103b4370917ffcb7d3483b157b0f7aed3c05eaf86b4bd50f61c7dba25528ae9128c72187ba3898dd33c58fafaea14a4e1e7ac688410577d7892fe8674e5e9f48f13f187847127924b3fec90230af73e63356e6fdd154f6532cd009c398d855d15c9e0ee6fed3a2021bf306925ea974d3c75dd317593755e595d4f49060f3ff2cfc056f9bac94d33e4140ae3db856b35f181b22945824cab8ec81730fdcde881b7d489d85c2e740fe4689eb78b255a8752d94e26723c00fafca5445ab23074b8b4005cb81395b864569c6c6e65ac0260e25899fbbd58249400d6df673ba3ab7de8b4ea6285cddf429e7b9a3836d096e433cfd0b64d2a03b14e891f1814ae4075f4923369025bf1a9591b866a09c458e9caf7a324f980d93b5d534d3b1e83bb9e8bb6c705417f9da45d218632a4b965e76ccf5a61bc78a5132d2c9f840ad17bcdce8376d47368568e8ceb28afa7ecf21ed25a156aebfcea32a027a9d82dd3a58a7910a1551dfc849d8b06ad6e65e8b664c4af4c2088c6c983de1b9dde38cbad17cabf57ee16b4a61d8d3c3d729aad582d8586be15f984b2a834323feb965226c1229a77615e200e70cc9f25f6b5ec63dc9825250420f0c4b0f8e9a065884360f358712bc06059c8d4b112b09582959022babbc2652b04f811efd097b3bef6b6ce694d5809b16ea8a055a9acc8435e31d9de2a942a3f4c2b4e5f627be131a0281e0aa84f183fee0d92253725af08c7fc2fe76e75c4e6c596af957967a16bcea25e889f67a3e1e621847bf8c51cd1a2bf8eed96b8f8a8bcb39b13554e3c38bbf5520ce0f91403e07ccc2a50e3371d07fada380c05d982a232c7505119cc7c08ab9a27dc14bc26d399a9faab47f2a6254d45be18fd5d30e401130244329f7985f29d8c211ced3a0f3dbd2c0c94c8e030cc01fcd145f183b44965d37b643b2ddd39f37e488abed60042f47ea1e01d377ab4dadd44548f66fb001d4e74d3da751ac8605abe35eb9392dcef9ce39109f95df248d02e181e22b3162619ace3a394f40d4485b9a2f5a4ea9a9a433ffe5ca4278669d89b76a38a14a188892ddaec1655580b5dc0ae66464cc05568109c2106e655186597da17a94d2b0acfb9fa6246a4e1ce3cca50aac2fb3e2761baa079efbdbbc0c965d3764d3ead14da49861be7641f7394a7cbd3086021fcdd43d45a31b3c5ada7ef45e9c40d5db3f5065a6cc27200ad58153322b38a571bec5bfa50d168d22ce6fe6a658afc6718ef5415372efb7831730103a501a9e8db7d56ffd09abcbe5359283f1f2ff59c0043404ac2ed0dc6cc8f18486670a16eaf24b94dea7c78a48197d42b87458bcc830c09c86d9129d8aca37743947abb7fca424b9a9461b9e9b91c9767b172833c35d39cab2ac040c894af0e708f2d1d3432bfb6c18cf5a93f404fa8a7985c487537cc479cdd83dc01b2574994712e8835a53c8ddabbd3321e8c813d703424d64c5877100eb1f4df26890db10115571df724d769920b5a66b967cfe4c39a30462e8f71ce271f9f3d6d42c1957609415fb8a5ef50fc764509d9154ca3fce4d528240f34f05d60f369f55a6b6a46e7f14ca25628e0cd11d78e3df13694e889c22ff06517a2cb3e705452db634e7b78aa5a97e58e81a8d47f9a1d546c16c72e12f20853cee69abfabf67e8d54739f7c0337d76cfe3a15c9e363eb3ec88a41e0fb90f64b267edab3ca6a2b0246c4e18096aba811e5743cdbc855ddca6c7376fd0c367ce7ce41a4913ad9df7b1bd23a2a276088fc3b1e4feb70921364388771a56fb32c764a590fdd00cdc54dc639475d47cdd9c3725ce9630bdc7218f42e189397ded5ee8599767b92ca576f2491964b9b1dc20c38d267a2de8416af0f3368bc0669b71fa607a74a54f9eb3f35a05886fae668602d688337b9c1afe1f25c9c7f286c1e3803cdc9afd5f4b0341947457178bbb9239436bf5e895933d7ac5b0776857e4ee5cd2f7c995bf52ef0313abed83c153af7d278fb38a2ca8aee5c66664c0e20bb08638d116b97b1c6164dc86bca70e05cb69a2e4cf5ceb92cf079fbccbb94ef349dbb69161a55615fef979e69b81304fe94fdfa719263a23b24c260c7b3344675bb3e4e71017a2a84aea2b4865c85df5e65a67ade8943602ef5dfe8030111c66a6a179e1ac4f8a1167a1e1fbf1615e99fbf277c18123665c598553b4c197608acad5e09765c73f1df89885cc44fecd59788926bce994045e6e7ae2c28d7a542d3b7490d909fd264dfd7d0eb8666b8d0d839eaacb44c5aafb1b5484fed0af2fd6ed446d34184e9577fa3d62dda9c80190b3279a637d7ab40a295445a7bb58f49f5d568f16fc3136f3b84e3f04a161a9ea206c57013b487e2d3ec83f47372f979409edfa187f785159e924da9a0d77ab288f661a38467a5cd81af9adee2572a4ba5bab9ab53c1c105dc0d3c94d06a12e1a6c248b885c1f65b80e5a2a5a4ad971275e7cae8919e0136c9dd38a83736f8a0b66268d256c581a0701ff1b2dba2d2d6799f4e587b2fcc80224f1e2ed3ee09c1019a22c0fae3835940e033ed96739a7966031bb2aa96b310ef7e0bf2c1365b067eed145fc35a4c93fe36c36236ae1bfba437cbc17d35c7fc606c914f3a0d731dfc4e2fed47dfc5e498722b5ecf6389dc24a3100e41fb58ef91feaceb7ef448b903cf8e336146ca38587a4c1c14b65aa4c3138645be9f41e29c5ccd9706a0db6c55d9f63a5f0f795264deafda42cea1e6cbd6120343fd2b6ed3d47e108015ebeb6a4e9714197e71d50559283a7ce8612549ebf51d23285db7ebfc4d7fe9455bcac7b8c07a629de42a26cc83df52fb163e261223f4b654a880f8639aff2a1e756ea4ac4e57eea92ad7a7e0d24b19db223775ad9708c9ba78f9d382cb08d77e694832e5e2174885bf1cfa63eede2c28fc2c3d95d09581ba4d27fc333716e75db0cfe3eb91861512af31aadc7f0c2a1a68945fbf50f2836860430d46db602d80ddce558d4a3ca8c3bdd93560bfd69795e90c9c7e74cefefc2abc5034c2816489d75cc667a9c5c19efc64ce8cc9fcc05bf4c58e29e0eb68b0bcd355e9416ded677377889ae1bea0bb12be6774002de3e23ed3f38249c9f43c5b7568939bd96b90bf1a73abb89b82160c10c971f1ede19840c22595fbdb1d91e45304de0867640e1276ad5d4d19464156ba419bef5b366264a149f83748040d1353be9aab35d5559e3f120d907b81624fb7446bfeb4d4d92f1ab1f3e5d859b3d6507312d2a966b03d48ba60fe8e790d84413789c6744e4bfc2842e05c25d745fc3c301beaff874f4874f35f1ebc53bf307372ff427b70ef416b2b53313471687c1c3d5c443003665e1cfacde246a0630f38bd30889405392f8a78eea49db849de4b0135cbacdbe67923b02ce20294f8cbe8f6690563a71d6644a8c4aa878af221c143dbbd3f5095083e9d7273073df8fe382156b6a8f68ed43bad0b7fb323ef3999b43f32f6aafeb2d1e78347329cd0bcd851ea7354a9cea35433bdf100547b5499af24d4f0b186ae0270c778708dbdc97a679cf0312d8cd79ff1521281921e7d678af6c30d00d2d867f571025abbf5bc4cfde54c8b89cb58553853c5128a279fd31e51823cc49f33837419fde67435c64e8f365cdd16017c271b1b04212b185ab585e04c65a976959da333cdc87d745851eafc1998eccb37dc10ae15a752cf3a250a2c56999bf4405e53e9712794dbdf644257603cafb7b4080ba9ff08ff9808cace214324de64695b87a1727dcd8713babcee4cca75e8c6880f5f4537e23053dab243b38d7abdc0989588acfa0c275b9744905547b354a27e6d0c1854749cd24ae7c329c01707d67fb75fa1515a790ac02f469ee1ced3483106e0ef0f5b6851fc4c004455f10a4db468f3071e2b6a725ff7d6e979dca30d8a3064f12e92e132be8f631fc6a5550bae25081896fc47c65f0903f8c6d514e6edb68b9fc1ec435d57d8ccfb30e1e8e389bf27d274ea7f6ca105c1e4e39b4f46a6b152814e0c8cd30c3f4a88502d7057ec77ce52a74d837d439af4c3ad44c204ab3af4b07e2c155800d654959fda54e7a4e74a6e097dd52e7d1fd1c09049629cc7b965948568e266f5d4459b2f41ee074571a0ee66b6567b74f78d7e869ffce8d5cbf3854c32c152b732aef7df991289df1e8edaa554b8e19e22ad974147db9d05c621d8769a5519f4aecdb6b7f658b644ce14e9ee51b136e0df3a5e1bc5e3f599981f56d930a0abae42e77150787614ea5789812a207b5af44bb640b01adfbbc0d75a09ebc431d61ee26489135aa426dadfee087dd10d5dfb60ced6cdb184520f061939d98d8e475765fdb3b65eb6a3a6d76a9c8b724c9798555b047955bc936e95a7f8b733a3f46ee427b2b2a2fdb9528aae7de2d696ed617e107bc5a7d662a9c2f76785da1145a812a138947c4fc8ca3d0edcfea7588817475477467ef45ec7193725d3e367cbadb4e4492b6540d1005d60618697b9f87cac962019f0282ac2a56146ba04bce446b328ccbc6c463a3f92cb1e79f565e0ee418a94884766570888d9dfcd50fe681b31a608fea0a29886963f171c6dfb1c77af29f0e1b3e3d79f57d967af9210c4a94608e0946ec5081b02b096305796d867b4cfffc0c416d7aea9ff22585f2830a27b236d33ef6726ff3f7b3e6da5c576a30de8af2cb1c358bdab2e6d8a33d629dc54bf955ce767895044b9431b1ac729e42c3f6cf51be2f1e4ac3c04e5507ac5b3d98f83970e48cea2afa0d9c674cd6056915276f0c6ae844fac2faf72e27937333097f4f465412e01fc1deac47a5473f966c61a1e14b5daf82a6182f1aec70d5dfa722ee5b8e73d5e097c407a125da8237b4278aa78a325032261e7671e2d9e98516b60c073a64398dfa01c11a5a7481ac6df13de1f9e18eae3447f9c8ee280dcf6997c5da1687588f2f7f0a2aa3bc3fdbc52cbe6675a454829ce5ce0520e4086a4835d731fa6d142f2eba8b95c0707217969b83fb8c474248f235c344f014ab9529f5e41c9135b569853952d68bfa6bdf2f968255e7351c3377f0bc8d49e6f6ddd9eed5be598a3c8aee4fdb1d9160b475afea4f46ad8bfa500b8c3dd622de45aff92d4181a9ecfccb4eb1a1ccdb0347d2b9b2a4577bdd9388a30f656d3de5ec7b4ca81c93a68ee5f2fbf56128f0784db55c968143cfaa1badd4f692deb54f000090dabee6f7a8d13c42f53e52f16090cf020af3be0236d4ab2417fa8cfbf21fe55a0be7817df2b2c94792aa7202c6bab6cdcfcc8b68c981ca7f322ef394876708ba47be31dd5cd7af6f97763085df3f65ec11b264a72f0ebd98e40651320ce3af717c2cbbe5b38579b7c5eb50625d7801d426fe730b098c2ada301f9eb1a49c8faede4d13f5a74d780b4232c0fc3dd4dc7e09b7f694f72b2a995c7ab7bf0f523073803828c401ccfd2bb921af79b2b236d69aa68719b6d82830e48fe941bef7cbc51e999f22b7e09eecf524cd97afccdb63d8a8b886d20eb1f89563148225b0faba20574e297c0bce56d2516f75758d98bb6a5f3c567512d4fd1ff8eeef5b58bc234dbeb022f78a4a7c5371a7a4a1e8dd1c43c63efd2043c8aefa63e3ebf3b6d8f7f8f5947561f61c8cbb9c17f3b0251d836b48448fec3e3aa831b5db66944472d9fa6af0b4f0956cad55ae6759c21783cbe482cb2c6cd611e27133a74d6a153f3830d3c01d095167e87af1fae5380c6a8c7c3d6a5847b9ba3b7734ba0ab7796d5fc37d234d23bd339f063aea21b533f4632bc9314ef38ec84aafb82f600fb8e8d90ebacb1dc0239234fe87f2c0df7936252e8de029455f139cc79dfe89730ba00ea588dbe2df61a541099b074bed3d62d3d1e9056b427323ecf84537f23727f4b215a4902ce2e567cc429cc1f7893200f4e1a0572c4f0b1b4f59f2dba9994e6a745c630c819481cfce7a7f2a7db42abba4754266f08fa5a73a37955e0597d1488c64037e98fbcba8e28c356648be9c8aa3fd189d819b034c31a64f6f1bc7cb39b85ddcc88d4b8377b186dd46ae04d6d8cd3b55862055cb2ae1341d6426260ff2edd89f4a5a13f2ae53bfe7d1def7dd684e81583a0cb59a728bffbcc83e5fad0969b73009cdef2d36c3ed8049dd5c881acdaf43e16e8f420662a97fb8c8e520fff537220a6531b662ef95e10c1c8dabc9d14d5d179e1fcf330fc7f8f467dd0d3a5462f95b326a29892482740336efe6c017293f2fd9810897a25b74dcf8fcb11ce3027db26fc6e86c949266ff307d5083a06246f097fa37d84235e736766ce9ffdbbfa030fe05758fe433ae7c204060bd9a7f43c99af2ac86f7429741507f2b8805e92355a70bed35c113276586ac3e1f40ca56066745be0b0c6f65a5e17e6c21a984c623bbda5166a474e39dd18f86f9acfc787bbbd643904c3dcaa0c6f91ede8fe4cfdba058309f02d1271af5f45a0cb156ade72be758f05ad6356fd44f10654b451aba300ca6efe4c22af49eb1cf7481b4a4c57a7bcfa48992ff0b8267d84ff8f2b515403312ad26f2595e9fd180c823bfb1b672ebbca8ddf64faca6429c465e6b25cf944374c24b6f73610942ed36b417305546947101d5ffa96088add055807bb62bc469ca6c57155a53a15a8b3d8e54e5135bdc18b1e2f50e00c4d9671e2d7ff352e1812ad2328ac511c76e4178dfae2424cf0885bf09317423e3c1a57e1c01eb6044c95a0e7e9d2963e0000863ce11c635e32ab9d42d56fb98cea8cbabe368f95de5308c97176fc24d7d3b4221c52906533627bf3cd31bd6c47f4d0170b7eeba688b5c0fb3cb03b5171e366d8bf189450ad05f1e66f7189a055980e82a0058ae844544af1d97a4849772a2ebcf6256003a3042fbca683ffc20bd570ee7537ff23d25f80c60e6eeb115fb2a6d8bfbb1463fed159d723118427e250a4a515e24cf6ba409f6338b62d61c06aa1dd3b81670928871d1e4050cd6221d68020fe86c08744a99988f4b6bf1179ef36f20406e3c3c83cf7074cc06bad11e38da45e1911c1a8c6788f6db5bffa91c52fd7fcf9c759d01cf03f7a7c0e6a2150c4de36449b26dc8d8b479b8571f029f30ccca85fd7dd37eb549d8a1ca808e4dfec44644f9dbc120f09ff4f451831aeb6546c6f8fa979b06c015a37732220191a7e9fd42f99ac24622163e5e3ca3586bdd528a5b3f8cc6b79f1976e4005f8da079ec6ff645701c5105d3cab69795e2da41c22761a4606c5fa20daca7cd5cf7e0aba0f76893f8d8bd2baabfa1b664a80faabcae398c43d99c3ca2934192e108782fa9636346e56c69f80af","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
