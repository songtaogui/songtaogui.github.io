<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d625cd82b066b964e2104566c8c0e5047eca82d6130d011cb0c6cf5da222704cc5baecb7fe10e8c69e9e1b85dadc7a682442981b3d7b8ddf20ce974bfd37142455d728cde7592d5ed873ef250f938cd43aa50839457ae13131d79d88c095c639999dff666a1cfabd608289d1da30d00bf52d178af154a328e0474188f4bae3d28d40b1a05b69fd09a78dc9333987df63c6b0fdf8374706a4307c392c0136a1457ecfe2ebb6a394091580530fa9cc95bb8a6c2b122e4b6d8f78c9c4151b38b1390640e56bff86b24c63979483c0fc31c8315e1e412a3626eb1981751dbd52945e0083ed6eb5f1051df51467502aa2f18f1fcb03bb7144c931fe6671509bd135421f990b191bc8c5ec00150234194246492e1327293b72561c6db0effe858295c62fbe95177f7e965151c01af83e07b3346e273d5e11e9ca45658cc53487a3369e3ff22511df3bb2d21aa37479fbd5aec2d77be1270039d935ce4ec568d784d20735475831b304567b0c50d45c0b5e2f1b045466f09795c442d5251468d1b4d2bbfa4061313a12d568e2f02bd1fce2368e4cfa820470f313eaa19f2553c94a7348daddf1ac54bf912e556a9ae47ad6208b5f11e95ef77357e923bfde7d211d4bdaf5544d96739da1f21518b1084468e491fe20c0448ae1cabd961796495a6bc2161f49b0617bb3e04a169290946082e801cb959ac8b1d7f06aace3fe50e06d72847a35edf8529e078ece81faea84aec9a61439824e4ca4e24351f85cbe26aa4a5fb2552a04cb1295f6ea4a82ee902c9512e18458d30ae0e388ce0f19a689aad06a931349ad06b338372a0e559c574e388c04191dd7845f071e998540fb4b1aa6c84aeeab6d390f5c048df84a57e8d974878a02de37d4560fb4deac8902a10f09f8a7e17e007c7917b1f56a04603c4a0a50204319aa6baa485a0338dd41cb9aebfd25d86c511487368a6c6fac8be9840b05ea679812858c72f5445d408050d18e0c4ea0a6906d75016b279853d0fb114e7d5d2a04e767c373528a8267f877d017cad23366ec5264fe83a09e8d13c3034404efc5067db3aceadf591c76776ca5e0164ba19145b0bc4a9b1be48e790e394d51812b9821e6b4024afd976a71dc3374148b9a27dd287a3374a3ff96650b7cbeda615342e413e27f04f3c48f58a188cc04b55b48a9b10a42b6927eec66d1c0cc86e7b663ec37672388eb93d269167ca15c1af82aca656b292f6f966ef412dcf17406f3ad42a7c6797f137457c444d227d7e7eb586038b4d08d4c2057b90f21d7fb01d2f05d67441a285697de6d4dc6d7749ec16a019e8253d81741d340ea2ebbf98a685306c786ca1a433a478f3cdd66f64ef0c7507647e95604118e42efa94e246b66397f0f0f663b1e0bc2b5a544e39ec50339a261e8770387095f4f471d7e9762b561e41df65c7f2e965962de68bef2ec459af848bbb62d576be3e944651b8f6cee536c0fc9695202704d036963b55efb86b0ad6462bcd25aad91c9b0d76d3441fb0d25557284d1af8d252716ab8948cef908652a7ab85ebb966c923bcf9bc1d5c308f59516c55d60c489a7a4a5ad97fa173d3009a92339ac161469e3db1278d1c635a4c60e8e6c91dec8525a9698dbf125ac7997a181563ec029924f63d063b5edcd7f12bb2d196e17798a2243aca33dc263e851e558c6f071a642efb935bc94b3a1694ac609dc2a48273222fef61c40b134a80b293b88ab7ca5ffa5404f7887836bebb2fcc51d96ea29559ee3e9b555ed6727c93d0558ecf92c1c32cfbe74bd6cc8b311d25eab2c1c8b019ca858e137e63b3a54df7fa1036e4bb80c57b8cc8a36a285176137ecdaa190257542ab24423e28d1359936b95c2b69f44fbaf3d6e04cd28afa7322f79605029f52d563ba72e90bcaa1e0cf80d7060c2bdaa987afd228da339ddbb3afdaf3ab3f46c8f1c854bb1e67f933aa820ddbf2d6c90ea99cbfe2db03f272fa4b938d392d062ba3e49f1cf77263b7994515946a9762089b536c481bddd7877d9d794f4bb6717fed9fdcc3220772f507f2f311897f7ab1f7eb43a5f507b4a8e879ef84b42fbb8ad9f8a4a48c7442c919ac53ba3af97ef888a60feba30511aeb9376090c81cdbf28d0d072c837f6c4f707af52a7e1a4bf163ac347acdd29f3866176e3ab3d149b2eeaa08342c38a81fb398f4fbe159f6e1a1e41ba8ef9596bf48c543477131faeff46f7b1b51657e238953670303584ba0321c47d0f93a541a96b9d6d5a31c2a96b3bbe2b39893a03ca39afb3b1cf3c16775adf9e81ddd36b764a279e3e16b59af0ffdec8e03e6f3b6db37f3508e1cc609c7a6a58953b0aa8ac171fda0e63e345db141fdca482af135a979b01fdc00fa7cf13ac56d8540f7ede11ad57388038cc80e836c4921c3b5661945db16a49ff1e695c4872fe4b1d85a955185f0089b18e330d69055742baf51bcee543f7189f525ae298c6e9925e098ae7f3309406e77094340e6d80767efb2c135172225dcfb0405753cebada5e1d9703c578a9e12e3e01e9e2292e4b546f14c17582c8f8b6789152d42690e63fd44e0131255cefed1f38417207084abcbcc46bf62e64fad73cac21aa8d9083da94d6e58f65c59dd21b8fa4c1af9d98c099e75700b0550febe322ac91f1a08c5490b6c1e682d255602d39b81bd4745be93160174a3df06536f2f5c4ee5cf790a0555670e002e3bf60447b86f43f3cb07d0f634da57e30f7441093e8e0c97eb8468e72682ef3f810b241b1b37e626b808757bcecd406f28fab8190abe441e0c7a4d8952cfd39a184d79ea701412abc75ef3fe88ec8f17e413387002c836312125fd06b7ba40ef2f62074438ed5dc009a4a32188d7b884b76c69ae1410f3fb7e355d502cb809a270f4c0036d27719af8a03b7e99a5cabd179dd34106ea2111cd9cbdda04b6102d76c392729e620110eec913f0ea43f1eefe351325eeccf6f9ff9f5c75b463a1bcd5ca455c80fda82b9ae594c9228e1686c809d4ff84e27dabca5001a3ade3db8293b2e6b39edef50fae2d5b9ad50af96c3d0d407527b42eac7fd24b3f0e6242e4ddf9cc33ff52ff1724ed4ed1cd75363293907ee16a046d15dc70df13b0a3675fcc1d8b59374dfceea32914481d305805385626f44648b037f07b0026da7ff2c46c72bf4f97f68f85a9ae8b51da65c0543cc6d582c8de705276130d6708c6a65e3c8e5025b1cf56d70d470bf601f7ba4186eb5630e09b7786ce0ce021991edd0234eec948f3f8c7a37c5f4ebbaed3f3eeb9bc5b8d2f481eac0ca4e6b02a34772d126e6fa34c0ec4a4125bc7c5913d6d58ee52a0ec72836ae2462f731fac9a41392248f233cb9e732a7048c08a808f2e5f5bda8b00b327e3fddd53b0e0e4e276bcc2ba67f0d7bbbf9f562fb7a56702118792191771ef725de5b59cfd8fd73f9051d3c2a237cc273df37f83ddf6a723cc587852dbe62b82cb95db098bdaea14e6b34bbe464beab13d6f29cc0993da78b63b56cfc52ae12c2f3be2b5c48dfecc21cdf1b2ed541e0ed39e37bcd8ab00c9edaf8e9f32cbae77bedef3cc9aee274ea4733b0219d94a19588d1c90b3e5d4404412c8954212fa9c4c95f90f688549287c5e7226851e552835b75238363959e6d6da80ab823f3ca75e208a6768fb80777a522e2848451c273949508e4c58ae69f3499f17d2495d0c9afac16420042911210483313e5a0eb35ed2f22782b4090d40f10c4c1a8d3a2cab74a26f3cb22f4cdd186e7d8a504e2e27f217010f9282762e44a8d4d7cccc5d0a5ad5510c934f7e3912545e65992c414729219bb12b04f9ae2953da732871777d858d6c53287df73b66aae8bb67406ce4ed7d0411df9e8510b0a8a1b4248638ece7a52b61b3c3b7c2c24d99db9bac328afa443bf4133b03c3e4d2a442d8e33f9526ed11ec2e456e870154520a16b083640976799c25e1acbb85ffd9fe5cf94052c6904a1122b9fa69ada13c2cc4e888d4709020777aa1f144e8c297d6a70a8efcc323461ae102dcc1c0c58568c78a1cfd9def40f900e34f4acb5b9bcd2811b8ea1d7503a407b4937baa4748a2502adf90ef5ee55d6669011d47faa9c752700104ebcc93bc82d29d964f39d65111ceb3e47b42a3e12147ba3882d49a35e2894c8f751f0bec14a00f73d6871917fa0bf41b64397d03901ab975919d561b45a86db4638d1887105b7d138710f96df11776fdbf26a0b42710e260d7fbc69135227a3ce2ad9df65c96fe0fda9c7def5301c1dd6679bee498943b1c0fcaaba46ad34550a11f092745aee867c8f289cb4e6d773031b1814bb5e42ede7e4a19d8334b47c7177414ccdb03000479e816f3d8c3a457cb606e5e4a4aeae870132e0235dced40f763b1d62b3f7cfdad20422d39be17f8a1b194690e6877be8fd4bc6f79a7ae925c30e3244781ac471c82d6e044396edc66c860ec4802d74ad753947980be93e5521cb4a93177afd41a1834b9426b7e611fdbc75ef1db73d16d364df310004784a8fcbbd81fb19241991d35ef1e2ce029c6be5bd1aff0a90a4c613dc1e2a674134c1c55c646d4ab3093be126534654b248640181c3d182db2ae83d11d15851b44bc2b6c801c169341edb6c0c517090cf47925cf25de8a8660eb2649e049611067b8b4f0164ae02637c1f366c320afd02562d1c842b181f1e99516b4c1f1d6817399914b276513fb09a5e1483bbe29b90446b672fbae0e6b376bc3cace09c030098dc4c1ea5efbc1d05b175ea19fb1f2a80983f945116456433f8a27a8f464dcdd7e1a53140cac418ed8303a2b36b3fa99b4aade2e1fbee64b1868021bbd9b0c79ef554b42a22eacf7c2ee621187c3e216b7074eb956092fd62833b83d967e8dc4c083bcb5e35bbe25fe61dafd19bb11860e0accfe940707f581d392a895abbb571563a92adbe57ff06a16aa8b7848540501e1f3fde10c2120b300d912c85bc138925324dc088166378893efccab3a06e5ddf4f80333ff26d743cd904d6b846c1fc4451ff0b8909b7afef6330f47dcf3a6289525d8ec2d3064508c5d68a5174af247b8d38ffcc826c02b42af47cf08614e9856add5abae00b7495869d13586355166f665720905c57cddf26ab840ca1e0d2e7d6937bf0c9f1a98ca6f4286f4f862ac00f9a75595db0b9fd9e48a8c326258eecbea2a203c15d00b11332c49bfd242d4e3828c3d94120f8df0a005611d5d420e8c381df313ad26f841688e292f62107568437ee5c56796cbdc2cd07ffe79d40b1b4fd5d1cc97063965e8f0884a39c7d02c21443a6a1f3b9cf35d041ea9752ef8609b16aaab8c5b3f258bd47a3e88ba01532d2ffa8ca1c1bae7b991cf469d3c91a323f86aa4f4d9cf538f4409c69dd2b87a74eb0a7ba8aa446786a9628f0e99df20955f2e764b6b8a2c9190f4adabf0dbce6763597e681291be958fffcc14ccdd625e3d71ec30d4e4e3a759a9bc282ed00f88b301d8efacf0cd713d9e7fe5b933820b73589aaba4dc2ef1d8c7a3ce79ccd8c6fb06406329bc723951edd65c27a8bcdc5875fee7b7ca4f80f32230e58c98e243f5dc0952f6d10a687cc4098bdd3f656675553e0e6202c55f6a75493addf17fd84964f910190f874aa989c873db35eb323af5b5b6dd5b5ed25b601cafb31bbebd5a63c03cac20014efddbcc9e5efada78a06246fee6190e3705c3744e322600cc4b9056aedc355cca53239ba8be8f02266de915ef67236673be6d952c6d5290902656351f860ac74e77f775e4b210720765112e13560517b97dfd92caf48ba09261bef86b090771de2f7db3326e777e64d71786e1f28417ae4bb18afe5c2b25846708b5d25e6121fc7fda8476485f663b8ad3a2070cdf0a2c60fe7141a3bdd66246807ce980bee44400dac900a1ee9a94b965bbdef8c0f72f0aa1973fb94c91d1227df7b68e57b1a74a45ca0979a62fbedca212e548e6362bcbce3f0e7564ad6c4247d3885a53e2bd39ea679243398ccd656c0002e3797c4dcc653592d4d381195a7bf74ecb46231fb43f9eb06537d7d78179641e38051b4cad76fc323304edf8bf7d602cc0cf531cece5020039ee913fe4a8344bf88d94c8f61cc19baf4b902291dc2cffd91e9baa3b24d0e9722e373f1ce85aa29fefe9d4b24694f87ae3857845ba7e753ecac470e970224b515a10f91d36317ab915633336b874ceaef3fb50dfe900522eca306a083b99b8516fb9a32adbf01e5c525d2c49c61ec0c29ab272a8188039850fa292ee20655a7736775014fdb48c580a2f546af9090f1c1bfc5d116c94d99e907a283e2fe44ae6045f4465e3db45865606f3d3a88affef162d0eb4d0663e2adffa42b1e64848114abc57fe5f6ff78ee0715230f945e370bf3ac015bf9554d27c9bf9d4115f01956721e4c37ee3f697028d63b3f068e27f26d3e723ac5cf9cff782c5a6ca06270affb32fd684a7f183c4633598622b95de6d42d2d185b54d3a142619cdccbb083b8702db21b02f2c4ccdb55ad583292d4099fbc9aebb60b6cc53f32afa82d63e3b031fc7e7a65bc54ad2cae3c6be2714d8047b3830342ea3ee44007212f927213f0df038e89e5208cd867b8fbe70f4ae2beb4e39738e68d9a74ceb112fafbee390e091787855f6b4e1bc7fe42489153353eeebf7ffe566bbd55922b175dc3ae6b87d09838f9328a9cdead53e9e3ab38ae9695e50c2c34f9419930b4bf13e3bf183ed300276625a1e4a49d430b67eef7f066cfaf9b0a2cb2200e7b4f4ae3c917cb2644a3aaf4c9fd0289b806bf4c9f0644df76913489754258d8eb7bf848fed399a0764c75ac06c7b4a1da2a5f23a3de3281bbaf50b1562b6cf096c840c9cbc6eb5f85217780f850287d6201ad134850a4cbd44202ca3c34239ace18f684a78f05c80bee8688e93dedd66e879821dab9150000b34601d9130549535efe7b017b5866bd9817d6b5f346ee5cff1508f630374655a1e924331f0bc4aa6901f93568eaa2c67171d5d30043e9510a682fb22c2552bb3c4fea70dee7b73820e7da65989630a358377044ff8d205b268be4cc9ca237e273f01ec5acfcd6d14f44f5feb53a2504d634a7207cba841ddae7e631de5c2b5bfd4d79bb16139f016cec18771a0faccd157da4edb3ab51826ed751ead9b639a1dcb21352aa4c4c41d73ec0c5019ecd107fa0f45f1b491a80ce84a6271d080ed2779a6686e2d8f993c28f93bd9c896d017a6f83f090ee3805678db7d310b388b0b6bcc0edb355e2a211dd54183167a415c846e41b3dd57f0be9b1bc3ef8db45fed095aa6b332ad2af31e79299979e272401d64b63817c4b724e2b8ebb61b3baad784aa2132c7af25544a33b3b849c503f5c65362b000131f9f31f551609cd5716c3dfdd138955d71da1382e8f15bdf0fae342397525eac29ab8e64c0b1a51a78953d55d0364f1d497b9597b5626f7a216738f54705a03f444c7cdc791a54fa7c31d4b63f593222d67ee85740ae7a14eda80de399f6b6b35f43dac94077841a4383b22b84db25193bf4e59098c5ee97c91e4da2c473ca867a677ac99aefa6344ee68a7d25d21eb0584c54663fef13dce2bf85200c3b7fe80c5e369d1cd580cc9ea1f10be685454a1392450c25c41a19cbd0df0f2ac4e4dbebd8e3861b358f721fe08e29313dca27ed300b350038e0073f66a47180c1d3c8ff9efefde361fcd3c02218759d4a92521e8cf7e3818482629f2aaa2fa90710667b7fb782ce209372c04d5868ceb604aecdf38ce043466db88a11498c4026516f38a80974e23ae70f36764f7d9cdc688f010cf4672c17fc305f704058ed7c6a1e1527c07decabdb7baaa92104779b81849661f2a6f147bd87ecda339ad061eb0bf2d05119a90b851c8155332781b047b204359ed96ea7af94960e4b25431a0ca34b34ae4bb0031ac4d118aa9b2077eda7fb25bdd6465644f97299779bdf904bf93183aafdc488a6c4a36c998197c3567c7ad2978e147fcb814ac57796879e8f12ace8c69a5beda23419cf34ddf93d7b9b2892abe147c32d23374fa92a5776e45e3c113c7b8cfde191ededa4dc1b07399da492dd3267a1c597b975e7e888f0f3b6e7516df18e194a8c3020f326fa45ab6c57c93d61027239c3aac5152b45c834f93be26e10823386ed54dcc13aabcd97e0443cbb5f487e76c8d3142d7e29beb061bc433cd74332db144d97c3d445795fd26052a910cd9fa8172fdd68bee84d3f07818319479e2a1dd028c401253c67a6dd8f1950795ebefca9290d8adc4cc0d7df8c40ededb2e830bf7a2aaaca0fc7207c8a3e3c87f4fd8f534c8b9849674acc342a764974cadd18f55371d8849508d05fbae71abfad382cd36e6ae7ef80fe0bb613351dc9a7da8bbca87e97d5b8b925c01ef69e230e15a4a03da8fa27f11fa2aca5660c4bbea49e8bcc2453d0e6db963c55f6ed104d5bbe7cb901b2123038ba7c95c62b38371726eddc5fc5d07df7f2aa7c91efb984ffd2ce0518c22f1d020f765ca5889908925a202d651349c274ec641a7d0ea3e485be88f4f9bcf6c400936dbc26caf06dbb07a699eede6b43a767e800fc92f2671af83a955c2ea620e3c40aeed9b6bc34983c5b15880d86c432342e9a4da941103427d88b76d321bf0941cd6e7a9b80fde441f1a5d78dffde418a7b47b4a4d706c3762c00b245c26f2e62447e8c8cfac8ee917812659be96608f1cd16c86185c7ac237346ad323dd0cfcc1c9946150993761860eea5f4fef11a9fb4e0e59a25b4c8b6fbbeee295056dc4cb251aa09e98a398294c1ea8f283c81e3cebd0262ab2dea892536545ba9cd978c3de3afae07f1ae0cbfe414c50643949c0a441ffd29b7482b97d0c6a595b85079fdcdc5d89343df7dea3997781bb2063ec5aff495e8debf357da5ef98014dd21ea2d2672b5153efe422c100e66095277fbed57cc53cd31670282210885f83566de3b3e8bdb36fb9819f75e8bc73bd6891b00a781fe7c8b101832d8d61e1bcb0199b4ff8578fab86a78aeb40a703df12a33e0ed5cd8894aea727ba7c1cf669855475726892887e140ea163f42165befdb1f7e9083bdcaa48d1d4d3a05e278c5bc5876f2478f879410ee806b1f3af596ee545982339f97f07393ff98ca03b1aa22ab50b33eaf07df3fa9ee44b04918fdc04c7fc2d2d3ada2f75e16dc0417b4c482161618d6021c34de83cc3aad5ffb67a1a6dfc217d215b6f474cd1b1f265f6306846a7e232c240e1c09c0f6c38356e1b4a2b329b8e3f24d45974c1abd2bbd829a4ae44d00eef111365c30cddc7a4f4e0c5f1bde30aca5f2125dd853624411785515772bd027a97a1b88d91fce1b88a125f30ded80ffe0864ac6a5a9701f51c895946a8fd80e86fc970472845eae5751b0f9730446496c91fa9bd8eff68f7ba3e40ce05635e4cf5c2488521498b346122afea13185c0526f1d88dd32bb8981d7623b50065fce62f3eb384a90330b6085ea676574c359d44d18983b92c0a2e269b38cf8a9099d899a2e7a542077d6ccea5254b8e8753b93b1d90041b2b89152e6cc1462c71bffbb3e64be06b25b32934a446df2d849770c86dae77f7556452293ea8b4ff0bc950bd3e05ce04b0f98ba1eba6a02c5912ba5f3cd7c2800bcc7e29126e7fab1136d18fe305e4d06a7a2b82ca8555683dd5d9ba8e5cfddb872153f4e7bd3881ba290bca03834bf5d43f1936c2e6a80364ee48fed53c5d5d96342cfbc2583f587215002b379eaf7663f4aff3d03f2fb67ea42d5f42b068028d5d3c9c47f501fdbcb58ebf3deda90cb45196a9819826feb7b8d108886ec9ee8571f242d84663b4331c055e4f6adb76fd5d5382c03d7d7637c7fe81f92a6f69ac634494b479d1cb160c83ed124e7abe503e5a85802b09e10a42584c159fd968921f2700beef312e2b4107e11826b911a6c43dab47f6cc954eafc817ce494f8ea22e456a690ee631cb89bf01c230cfd29401b2f3e73eebb4741950a9338b0738712003a21202d75514790ace8b6c2901224d8cb6122433b69a7e466cfb66c108da258e81ab6c26cf7f97f762ec850fc78c708ea7110bce7926e0e083428b59bcaae49267c24ff4fe24f676afbfda4d41c4346166384da0db5713ee4b92db4730da1d762f425aed99814b40fa081d75d81800a0db6aee90c468d004838fb85ee237eaf00a07e13ec7c8bdd8bd648d8a03fbabfbdec29be139fa95d6f85fd92fa6f46ba4edcfcca7d3faa08c5f22756463a6369718867386dd1830132b5784905bf526359fedcc5b63fb2ad0b1d24d19805d836e2ecfe66c2bf1a0f7b2bf4581f172271f5029ffb6f9aa871a05b395816249f7557c915915a93cb816f7d146862949e1f3e14a579bc21fb968e00888177d368a9e07357a4a8a4788f7d1d4114d3701012489962a49c2c8fd1f1700d5b933b45f7094294faad91b5e0a7cdd2d8f27ad6728635fa6546df5c008a7093f349c3aaf4425dc281869d0887deec0b330aad2d8be61e4ad826c8b28d713abba7685dbb9729c55fd6fa1157ec3598169c2f3b740946470753e5aeb90d8f2c08b71a52f0e5fbe1d69f14e0d5724ee6031ceeb77beb23108efebf77d3f2181904253420148ab8f9842999c697cf3f7a061591e34a8677dee57f5d33c1f18c62632398f6e3ec063b98f448224948ba36436c7ff211f9361c95e4bba4d05440bde670f05096bafdac968bd7bce9bda312cea1aacd0ba3004b75c579ff291820d0b9088a338565beef523906b111a36a5745932134eee66e7fbb9bba5101eae34665a289632d6e82fe5307aa5504f910642e679a157c6906d414f3ec717c3d46694361d2ef4b3e3a1d3616efb5049dafb071c968e8accf7851e16ff3c8dc9a65e1f1d2733dcc348903aa4ba2be9aa4b942ede54bca6221e72da1c02aa845b1eb840d4b5bdb42098dc14bc88c38410cd847396948f19f88c32b2dc393fe32abce3c9537ae1db34240f5b4f0fea464826140df67bb23e8bc98af9644dfd8217698e92969a5f8f1345b467774c156c4fc4c201322a5bab660600efd321e38f70b45c967edbfcc4615c91b4441d9f6b45c5b0c9301d66c6e86efc64dba458c8b269a8e18861b74291076f481245f11440d0ffe87b0f1ec02ad2c61f620cf4a34a1be139c270aab97522c264e07f33204c3e6feec2c170e4a58f61866903bcfd2a39c3120aa73ac6e56d33f76261a520fb5e24d0ba274eacf00312b5a496d347b62d9d7a7e2803c5a3c99da606d1926af6a2db5a8d71cf5604acbccee06f57a8984a7682893528b7cd801ee3083a48954cb4682e7f60acd70ee83b28e9371ea021f44e2924d99aab1682838cdce44520306edca41bcee3582f51fb6c14304710d7baecc39c5b0b4041c442bb00856e33eb7a306e0dd0841c21dc8b6d3da6fbfad09ce8e8544ec5428ed630d5bec8956501f8ee76b643768b0d801d271bbda8d66765db4f98fcab621e4d16f753e43c79e6065fbefdd05ec1f37d0cdff5ce729b685e30c57525b0a31abfded016267be00d4f71a506638b171fe16135d02c86dc23d3723f75c465e505c17288dc8827e5aa8671a29b928312f3efd9e63f474d3965e41825e48d3ac35e239c8da75ec4b6bf12d7a095aa268c9aaec293b674877bcb8bc7a685ede8e53a24eb1f3a357d0685737843d75a089e4f7a501fe1a33ca4be602010b37ea687cca298cda9b009fd20e990f535769f635727d07b09174d96291c5643d853351fd08ad48148e36a39871e20840153f2302034c715b36f4b9430d2aab4f5e03ed11ae46b0ccc6224746c08d1d88cfc2771d37d096270b22394883fd1e1974d462e00b861fe552c1dce724a2244b543ab03ef42f9188df6c854bd143cdbc61d7133004c4de0faac8378facd8f7d78e54a5e89428e468771132263e250f9b303801aaae68b806d6299751c4b93fecebb40ae673096bb5f58bacfd7b632740b4e47381a892611575e484776552bd97a03aaceba3ab3c9e0554586c4b8a6f1376fbcc183d7a724db580e5df0779a3a33a5911a34704ef6e6ef2c6320b825617fc89f320ba39710cbf2a929cc31c5760b3e175169c61e7fce4cca31c6e3c301ad557729334b770f65c72b2fb2981198894da6859fdea33fe735f1f635856b60c96e4e95923c5887d64df1b72a2acedc12c9ba036a19425ca06df60d4e78b8a602e2792a955d42f96c22f403980d16feffb25daa4294298693d11e5ff6a1efbec954c2c55cac4c72c676242eccf71dd4193cf928853ecd7d731f6369e58b976d4b121b6ded05b72e486390a61141a4fb39331c5dc4b6f654d87d371dfc307a20b417696c629656bc2c76913ed207028c923d9535b2dafd97b42a36a456c5cc9ce711ba7a1260f0ca669e0105ad053d60c64ff14962c2bdee9dffe351c7dda7ba92162eec12c3257904832cf69c385177c6b7ab7712c12245e892c9fa7b9bbf100c3e049ac3ec2cf3921e3345d9a7ac96f3642b1db79cde06e454916d027d68af87278c46602f4ba45766dbf6d8806877ff35a99c70f0fe5bb3fd101ccd986e1e96bedb57a07741297328539613dfceceddedb907c021d80032306276501c5bee39059f7121eebc171812a1411d1028fec0d3849441c9c81a393815cd01b70b720cfacfac0881b21560a91d2ccfeda38a7e03969b94c1fc7625f4490335c539f2ad18ed46fdf8d463cd7cb795bfbee99170cd0aea3c5690920e6ad00ab04e26068d3f9e8098586e11de9210ef6b299faa265fa5a3637ca11c386ca6874babb1e0affcd4180d99c20a03795c68da704dba345511c98ace81ff91565ea94a3eba452dd09dad1339ac8c80e1a02c7e7bcb618ca2e5f5f26cccf5a23da65aa4c1b8df4de43147a9a377d2d0fbe5f6961c8ff9515deed876b5bc0a6cb3fb1a959bd8db74d8cc80ed005d7190aa0b1a907ad5c4c082eca643946b1642ddd1df902d8b4e6f93b95e35d57cbc9a0c5d02a00971669fb84f260a57e9185c938f95de9ff265a10d396c37e369097e1090a3505ee6a70ce4f5c61f6d5fc8598d10d58b2174883411ac9ef3ab64e668b7176a3a53e1bd3bd909b4a111793b50296f84832ebfe4929ecd01588c49b343244d604fc7ae09cfb348bd0255dee602298817842e8999ad8afecdfe9d2ca13118c93d5b3b1e9adfbc1a3ecbbc718e479ff3fb7711c57b3473228e70d4747759b2076f1424cb52bd76193dd9f8e947ec1381f1e27c3d7565fb3e26a8a83cc4160681c5a1da5efa70789d59578bebcd2a4d545099037dadc61ca7380f4222c3e5c8b064aa3b18998f19f31305e31b712424f16ec1fcc848c655b563182ae3c8a386bf43d5565548a745be2697f9291e834c765606348fced8f0767e1983208813189d4725046148530fa6249cba55e35dfe1dfce820c21dd4dba3ee5310279100fb6c0bcb7d9dbbb10d31105003fefde52654dfa2408ad6e087521b6f149860370c53b5b54a503f0fc2a25b6948f5b9f70114aa510793b90c8f8321a4ee05637502f6415160c477357206c255f7000722f8d6b04eaa3c055e6bd32324a3b9b65e862aa8423be94c1c30707eadd88ec5ab9c8482e8c05515d4e5d74b39bcf4ba15a058d8d38347a339f4af4117c9f64f8a05af5f893348f7923ac348803b40cc2d8e1bb37e341475b5f6f7ff66aadbb4cada022ba666ae2cd129f14e99b4a0b75033b7b98712a9595bdbd5f40213ed51f7fbfb372f22a273934fdaef8163c44450afb34c22187ae3f84e05e58dd2a8cef6b6d9df44c2287c03b6042129d1b55b1e44e02cfeb163af692ee256834058ce7eb079d4a8e48fe16e7d24d5cca247472e2114781cad42c96d2208296c6daf2de98bb3b4edc75b5f061e356d2f05e758ac06ec3d7e5a88bfdc02e64557f1345751b36fcebe5d088947ae7ed9283cbf1616845d63bea47e5fe6a3ff4c7ee6115bf9b1264f8be17b8c378aa506638b3c03fc4a03046aef44c2a12e57e8cbc978a0225cbf409ab085b3fd350d6f156747174c645537c61291fa298fa33d805a853566d477a5ca79d3b48d0dc2c11741eec74e5aa92c4a37d20daf5133cff6eb1b52b0f393b3425bccf6c1f1374b202c3eae88d198de9dac3f856958ed9624b0d588f7462835c7421839fc21d16f7a5b0fcf65ffc0de0a7113530785935d1afe61a59208cb72a6e71c998a61fa1d3e2df40be9d21a8c2d955d9532e441247f05b889ed51fe3946989679e2010aaf7397f9d9ed7b7da0c7d4de5d7d5919c746ceecb88c925d427f02e4e61e14e8c84ae8fe506cf051e22cd397a8d6904ec4062429f445c1edc3929b4ca47669046ddca69e469b247442b3f39a571a95d25648d182c87983be87ed7051d623beb8d893cecd508b630f486c6b811e0b83d4254673e765972e716b562810d84fbf7d5601d25393d9e1afd32d30b77d6bfc318c5150a4177c0c32287578483d3ab25df1e415c51723ecbe55b0691b905157b7b1d67a7330f3a4cc5ee9757b3f0e24b6070b379cf1d7c8c2ef87472968be7fabd77656d86ff57967461f7b8f7ba5a98a9d39e61c307609341e7e4cd8951d85fc39256addc244ddd8af334cc1d2cbc5bf4add60eebe593e4cb7b587dca9d34c6ef4c1761009f1745c18b7371fe7439a63e6974ed8eebeffc5194bde12196d43255062d6f665cff11f9592e244c3b0f526e42324ae7a5bc18d3959cd81a439fa7902fa780c7d5c57fd6d8ccc56657c772cd999990c82254d380037b50000264dc05b022b811b27f061383ca39e106923cfda34ccfd8fd8c521886c0cc6fd6aacffaaac286bf015ee736b82d0372b68a09c114c54504ca2fb2fd13333c7ac44ec021f08e511fe5becc9d03b355536259c788b31a7e22b82a244ed66844dfc19aa37cceb1f61c0f016c085b50ad92fef3036e92aa7826bbe22d8fa75a264d98b3e7614b3556074b39ddbffa3134e42c7e03c24a3bc5f3ffc7ec78b1b6bc84c8f2d865af4dfd44152e476036170c2b5ca2377a1842890290365ea35393ed8b36d5f35ed5d6782c59d561593dc485743241f53a21b038c30bfeb77b21705cbabc525b9827d6bc7441ba74552eaf0d591efe120fe20735cc1dfb315bd85ec7babde27dd41a93da6c524a4b60399b3e54d0394750da339bcddf217c65797f14e4369dcef6cb16b436bef66711a97a6464b493e05b5df5093f17a77474357614c1162fdccbfa6c8c1f0d38860de1a2a76aa96d4cae241020d8437aa9598ce265de635e36f6617e1615bb3e9355532ae43f73036e852c2783d51bfdf083436885c9d26f93f4faac99312b03c5d341e9df2a7980c507d42322424b116e8797d428d80732bebeb94c4c5f0c69d13b38dfcd502489443fea8b6732d7dd7d5dc3136128a2227f5b6d79817ce0743e7a6e3c6f061b703c4891ce58ae11c4e713459440b17e60b242426b2f17dbd5fd5043a5bb08bb81e8c288889948e7ad18cd9dbc5ccc383bf9b6bc0445cf8d40ae558e49148c8ea7cd8419d6c180be8622099b12e97a2c54f7860411274ca3dec8c9fa0f93ee801309bd3355bd4ee939550b70194aca9c425f7d0d32435f3c0d57722af5a8ffdb4538663f6620f1b481cca7516974d9176a25c2681f18869b3a1f12874239b9b80917193376855cf81a5972f463c0a4f9fb14709c0961eb5b36a39cb507d139ea712ed1995b206f94d0074ed8663e8a67e2ece9579402c4cc088de7c280eb1c49ef2392ae8a7fb48d2753f876e018cff995dae953fbe8a7c82c4ba47617529b4d12e5bbb63a0175feec12cdb471ed4c0f18e0400a754c66ca660784e180130ca290d12b9782c60207c16f787677a9ac122f23bbd1e735ca714344f927a5ae573fd9504f5dba749e83750bde2bafd65cc4ee628a24aa45896d025f9c27dd647a37e2f636cfb153708aa846782cad2b49bc5a8b2e7388f00a9fec193e67bb36f293a8cb136fdd8360c80b63b1d72b030ce55f0e8312eeb7515b2d3854375856135fe8a1db7472177e9f479917fec0d8b39993843d7e81a5ce0929bca172265bad3fe4fa2878a432505c9bc652e826b87d943a1b4cfaf8d810b5e4a25b85c0b0ebde159cb8d461df6b1fc855cfb7be303667811b9b5938d684af2b7028f2e75cb9e00fc9b620ac4cbe555f5f6095f4a67a651a2bd71165154b3a84fd1b4e394e429cda3ca61a4d7d3a659de70b831f9da02409556a0cf75822aeb8f22a7874c1ff5ce8756a5e0b3edbb13fa5fe42a1c6d482eb27db8147fa5cf695b5f56485920cf7509727811b6fb33bc14ed21ef70fb304d5cb72a492a56fc620b06334948854d9d09fedf01117502a7fa0524181118b21e073ed32d40ac756cc74fbc329385a6eb2237f61ae1282922c9aaf7b48cbe363a911f2a26aa9dcc09bbedf6b54616daecd31ce0807f95950c9f17a605a8ca15d064f35fc8c3aa37d2077dfa80f91bcdd1e547f83d5e199856a02a508ee2800be0a7a6a11c95a6ba18fffae181bf71d6871d4518ab74badea85314dae5c783138bd11e0000df25da30b8b258a0261200c8deccf21d0db7c9c45d7e5b7b6016eac3fe2c150f97e93dfb0e80244fadd99c38fbbeec4c3b69071502e8533ee8cf86065b333503e3dbecee12dc85679fbfb3c6413a7190eefbb3cb321a51d95ac0965df1d2ab84ef8feb895d14d2b81a5951f0c5be315d6658072ae815da86997049e63a3564e341567c59e8f1b790d743800e62bedb62d3d556fd2c4bb659ddf6cb7723ad768314adb61778a39d9212134c6bec7520b4429282e6bb57d380949a17dc835d5bb6f5afb4aabdd3f10007b4a0c0ad083bdd5cfe3586d291b459c96197ec191d252d779471b992a1fbbaa4b3a934692da43f147b46d1f8edd21215321202105ae4d38dbc3ed10ea22d22f66442ae075dcbec61f894f1d0c4c2151bae94c9cd76693bedd98f1b0ddf5f133790a4c92de571bc482e11ce28c4fccbe8bc780f14ebb821bb318e85709f63b90529b429f3f74e410a5d2b81a72ee2e8ac9c13d10700b8d694c393a5e1fce4ea6a40174e9e4732a9c7d9e3447217869ef01140b6b728d7d28d164bcdc2f1347ad88797fd1015a0a626ad04c3f1dc22f15a6ab50ecd2ec737c60ca417158911c73969e1259a1dc1901fbe0953b4cf373ad67cf286f9df6447599e06786c598d5f70eebbc32f0d5b952586ae04e38668a1e07cb6c2402507e89a3ca7db08164ad9066c0e0e5fcba8cb9fec32652950ca19269cb994221a669dd5850d57b5e60ac2730d639591a9977223c20b5fe36d2189c09e6ab35d07b8ff0f9919322eb3c00d18487688b2cee888866b3b8490f4594310e386d43d739f6eecb01031d8df27e715d22dbbb131c19dca03dd4b4754563ee6db2392c5d6db5a94f6225be5135d5b2d7266dfe44d26ed489232adcadb9cc913ca065be998d712fb6c9a02a5ca81cdd2f54ee0fd568e7c390713d16905c64e016f25abf8ffdb72105da37ba53f67bc5e9aa28c5b58ec4ed4035f2c35a90085f0aa5c2650201c07b33eaa8b34e6ac1aa33e115fd549d2473c579ab2cc77f57fa1973febecc15b23a4a545d5fc378b5915c4bdb5f39191b2e15a1a2a655c89427227c3956cfb26854f3c983abbe4385197f319e8a77eb1b5d6a1e21c357b525be8b8197a2af298874b1791568ad6acc34d2b9d5b9f7cc4c480faa5f9c9d53e602f664916c9156eb9da804e65a41fa141b9102efcdfa441b7eadc749559dfb0e15bb829fb9f3ef66969bdcd3027c2e17a92afad8c266f7c7b1c861e14e9d576d7520512e1b1a7f4e0058d5c5c8c98904b9efb38fa55049edc1a07ba9e7aba6b5baddc9f04d076e295c1a045b3a04b416d9a8ab431723a07e517fe3e9df144530c49a3b57d25ba829b37157b73ac74b76d2616ef55ebd12d778fe2295aad602b415e58d21fc2b7be9acd0209a833c6c25fdc0aa39814eb2f7f1702d73450e206a2a6271c7f6ad3860662ab4ba3e0ebdad8a36a3e26a46ef77d01b882129854ccce440e95131adec23009cee40c967f8828b8dd89bee3fb1dac243da2bf1ff232465afab785f483203358eb017016a01bdb784899ee49550ff5056f8c01aec7d8a7601d5136f1dc6c88b28afcc78eff7de72661d4fd492028c49425bca6aea8b74a4fe1be477cd49ff102bc02252cc90bda6beaffecdc81b0de246230abeb47b588317f0e717315d5bdfa9f3420d6bc6b592ea9821ce42adb060ef56a5080d02f8091bcabded5f18878769ad84a0c6a4a2059361702c819bd92db6576b64b3206e7b8d3c89e4e8ec2df594fb3768efa180216cf6337f7ae6394059da78ea17c3d29dfce6de","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
