<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ece565efbe0ea7fe0e266ee03079b8bc90cfd2538341c3de6e52ae625f9ea2823e76cb60e0b4319b117936f83356017c0be3e04d63611054cd132b4c4fc64b117b7e9201bfe9a6250f819025e8baf385c45739c4cbcd1c3eb04586e53cf0519e20d934ffbafa2a683df5bd4d81a7b46c5b8525ad3a011d8459311eca52c6d19f5d2d2f7312e302b8c56a9e7b7e42c6b776d32a50757b97bc910be327877770846fd6d441d3b26466204eef764af3e3675a7160077279bb6cb9b4a228e19be2af6f7c53573225278fbf9a11c953a3149b1ae5334b0cb054431a334088910217ac0c8a6eb09803065644a436e5e836a1f20beafc7a612280370d31053c229b262d5a7302b54d5bbbdd6dbf3e0815b57a4f82ace1d8b052923bd26163f1213265e57e163d06de6e591dbf2bf1db909b9c1a6ba1f0726ddd12cf43c724d8d34e35187ec07e3a792d472155752aa071bed5f893d64efa67bab33fb0d4d9cb9a6b5006daa833900be468c565bb8bf1c45599ed7af71beb52c946c2ed497e832dc16bbbe3689016bbf57ea306e829136e9eb680214d1c97081a16edafe90ab68b24b17926a2c06f8b319b8906a4a3346f1954f06ff40c97ed9f93c9003c10b5bda3aead1d071b5d1886921bc64d79e834579c220bf4edd011e9caccaa5b55d20bb80f1a2118f27e32cf5d6f3c0eb2a76f882eaa569cc24ead00f0254ee454e06796f3f0763c5346a5d9d19accda6db286828a8ad4efca3b09de953aa649b9fcdb9e1f2098ef4471fdb08ccdf59b88b492a568b5cd8c1b7c6914e621ab2eb8a99d01680b8fd2602db88d1ecbbc5e0409aeb219af2b23f31ab9971d78a3821e68c9bd81bdf1a1094cb8e71b06b219f3fbc5bc00fc6882b64fe80d6b9eb58e6b7d89b9e70c1ec8593ee479dd063e65e1cc0db58841abea5062b6fe1ccb1212eb00bb26c005088d520268893881de565f81478fabdcb35477e43fd69b48cefccbecdeb4ae2a2ab3fc5189562bbe4fe15e0c42d313b0fe52aa2127ed669b9960434c3482c8760ed4220ca3953fedb360c278c2722f82b9c9acfa86e1338904dc04b3f92f02bb7951af38d5f3c176476c01f1bdd843b85ab55596c6a7e2e22472dd1409c71947a3a78d997b58bb9f37346adf55b486339abf6ea4688485d6317ff9d2e4fb72168aa88f3a1857c56d87a0375c6fcb9bc505b45a8590c97799ff6d0a3ee66cd6cd6107737da26318e0f70461ca2a20170c07dff8a3cb6109de321a4abd147843d8551c5c9eaad8bdd95ef90ea5764ee20eba3801037832362074bc3d0efe6bbe8414b6a19ae9ee98582a70a91b5efb58ce25f4a4788b05db79a902c92eff06537822a38568e0a7489019549a735a01773c9b1ef64737552ae58bfb39bafd780a261a2d70f6cfcd31a3bdbe4ccd9b37255920b0bbdd1b44484cfb85fce021c1448abb6369f47dc82a03032c730484b8a864ff40bcf0987053bb536206164aef3aa6a355b3576224cfc49efcb24002394fd3e972db0a3f66ce5c460c2b862af5c6b7d550a215a6fa4cd1b264798d111e412f9d6fa734d7b2a71084775f939ff174663406b19acaafc877e79e60299d2b7a73f4c5ab6cb7b7f0515f660773b13257f01e6e845d7d52514bba7443e2affe834326d78c4462e909773d92943ebdf6266c41623a1a41705535ad79ebd7463a140c2f6f796c83cdfeecfdf131ab1b9a9090bdda17da723025b7c2d02681d69014d039bdae4d56fc5d4d9ba415d089be7744b61a506c4a561852716a33578b38b61f32d1b0f4c2219df36515f60322e4be994d204e1897219d2d2486529d32c46a529899fc12ad5a890d3134c661e3de87891c85760465224c877ad813e8c4a8cfd549d2f614c77dcc13c64845cda2e94bd57fba971d84c2bfc27fbfeecb104d4873e44a24d054ab16bd29c38be5b44f3048c4f8f6652897c8267ca847fada2c1c56d71338b0aeb94afa4cad8250ea42b27f7e5d0feb1b235c0c51167051227bece23263610c1d98987d1e9eea40da8d8ccc085a9c796ccd9c4f8b8f9e3a7ee3f7f657f0b154f219a551dce4ca2ccd008c722d8b1ee195ba2b63af863aa307d710f430acaa3f6138d23b821a3e9cf9e2af90077321437fab39bb1112c09a9817c7158ab112b580ce53e80afdaf93bbf11296846ae580a90249511c97e27ad3a9e311d9b88c7af06eab012e5f6833c2d7b8a5697a99fe7f3ff6017993e40c0e1b99d9c2182a7062a4562797f5543f94591b212384b2d9c49d1ef3d5eb5734579b2481ba23da952023d215ef78016e517c46ddce3ce4da5e1c8d00b353be70cf75c4f395e922275cf4555f76fe8ad8c36715b7a69100393e807704d840d20c7ca06921ad7b4dcc7602e1eb254aa41c11da27ed1fe63043aaafaa5474e1cd353e46c9a270e614456e06489e305379d8b53fcac9ad25f51f9c0e4556d4e2f490ad42ded0976539f503f4c5fed66c914c491de42ae211abdd63840cd2ed6b6545c8188f79d72c8763d7ec7e506b07f78af9d5664dde4279e9b272e8ca37c4a62bfbdf8c7bd72c62a62b8a8f7fc4c6bd0f97e12e41567471f43c24d8a9b00dc72932a924219eca38606eca9c38e2bd09069908f1548831013bb267603d2c66a4300a9fb2fe243607359bb470f4427a0f06c6ec642bea6c68a855c08a4d47151546c847feecb15cbd3f5194e9191065d3f19f007dfc83ae83b9bbc005ef61db2ad3ee0ae3b13855e157f25b586dee12ab22e78ed57fc81c25b3e8013b11c4dbefef3ad9d08c009cc8366f43eb5a087421c545273990a82baa43cf00d656c28d658d0c1033825b0d70b222ccb896d5dcbeeddf76f16daaa4c6278ee1fe4bdf1c4647f542878555a58769520e33440f5b12d666fcc4167d340ca9a599258dea239b01fb6a22c2c2c6dec73e7ff893882497738890871a4e6b86cac19820e806e755a4da84f911b7f078a299311c1313ad0ba4ee9588ff1430eff16eb6064970d342be7adacbfccfb5396723700290b5e31f899824895a3f39d72c037a7f4378607e2249768e1ae1ae3414e0b3990be7f5be9a9f37ffe030a588cd60d39b84abb47a55f895316187984700009582303ab99fa455c527d08ceb5c687791f2f21f949d789c7d8bca404067e504596ccf198bdd909f15cb91ffe98b2ace1f7d7f1d8a859ea7cec1d81276548edb075e1f84a21e490d15086bb36d62f8ed4bc5b8aaf061ee0846aef80f2bdfc8f8c9b54114bebf0ede7fdb85b5432845812758fa42a5569f9f8c231baed781685ac656f00caf0accc6fa99eb0fbd79e9200c18a760d13f6da19b6e96bb3c4af67a4789ae3f75b28985b181ae7917067c83f312602e77183a7f3027a9f26e39320b193da17e45905bc3c5232775e278ef086ef51f19633fbc2c25afff4628285dc993c782f6d61bd469979dd6a33ad43630c780727903f8218bf4512f7212df9dcfd8a0dad4b423100429489b00002099e950b981088a8525c3602e7d4a9f551c65df36af05ab47ec6e0bf2287cd6f475d2f5fee284d9c8ca6c957bed6f297fbb3c22a59921bfd3c934764552fd7c98aa124bc7d01d7d9bed2dffc2841bf3962d4368037dea3580a5fead4b96b58defac65961846dfea6c0d108481e4de7a46cb86c8a4e0382431639e95f0f805a3c07e279b91c5800600f09c2261460847c6378af3cabb46fe0ab1ce34154750b346b34af8d7e183dc2331d89ec126209400834bfd98b05d6bbeb7e8d58688d6275e964593e3c4d3881304aea5c0a3d5a1ba430d218f46cab6abb3a3dba8d21ca11e9cb8b42946d6ed1b6c8eac982c8e708dbdbdd559b5e0a3228ae9bd410537c0fff7a7fba07d4a2b780f5370c17fbcb303fbae5120c852268aa6edddaace5ec68e90aa4ed23dea145ba8f5e27d61885563deba0bf7fe12868cebf9fac1c091bf6b03e0f317246d8e13b508c97a68b3ec5fec1f6caa834c5b7fee14428cba9b916c689811bd4a437a4905e82381794b4d8c7d801b47c6cae5f88f78662f82d386b5e8f58082905cce331ce8b93a4654927eecc3d151342413e9182c544813f010116e2181e1fb5c9a4d8596d262230a8188988d4c1f8901b945273efadad1573c2b4c67cac31266a4c2e3581b6b51db82315ecbca22a304873c2deb35f24a0532cdccca64ef7a6bcdded2c5d7dd2bf7638f26a586172325f6cf73e949cf8e26d33f2883e654f317d9c1a4d56c8913476ca0c56604c565e724ea34eb517a12ea33760e9a7781f0e2ba0d6a01278bdc07edf280fcab2abcd195a038640ed0df6dc2b509de16e4299fc960427a8322eee12de5bed74e94e1687c8bd852b8cd08e050fa61f64e40e5efff51a732d927f69350d65e9d0109c68e8a84ec265853f378676c8649be1958f9f030e89ed9dd9267f85953966482a55028108f23e504a2e28a4fd9960087f1fed161accbe75d622fdc439a887fa5caa8db6d81fc2ff607439267f6e78ac026ad2d54a0e915068e50c38f54ca65d3bfb7c7207dbc734bdb619f13062442a2a592f3d87592b819412c856ad4471e14b9b2260c0590acc1bb81e4c5fbf7bfe7e6dec2a53decbd08ad4497035b4e6996c5a70051ca6be7a264b5d8b3170742545a9eb071b10708dfa61933806cb0b888fac9c0621d5230e666865ad772c47cc92fb1cca85500c5a44e41a505a612da15f7d68b09d74117e4d3d17b683a5c56de7faa4cabcf7fdc95769880f6b71a93a72e8472a07343f8936c226dfbdd4e3d02b4f0aa719e887072cbc0eea0c50e5134c6442762b6044ff56840055a14b219a89902c58991c9e459a2d85e3ceb9dcc5ee84139ab20d20c100cbd3ab7ec71f51c3e46f8d91148cc621b898bc6be8249967c561afb55fc8977f539a6ccdc04afbfd10d094c390fb169f9b4bbc43499ab7ba3fc6dd145a3915eb6b38998c1776fe16700ff5d8b696134f0ceeca9f33bfe72bf5fd9c3b1ba35226bb7c1ce2863e01fbe52ae7e35ecd7392c42d3eec6ceb97ba312808b42ca58c6cc375bddf03bb9b2c5458c512177aae7d65b3c374bfc20cfccfbe8091c65d6d13b123e8d2d2170c86875ede8aaaba28dd0d0fcaef2b56b7430f2a3ac27699e4cc6824f3037f3aae0f62041c6e1d83b731662cb95523dae48ace5bd915008251224a923a6aa235ea7e5e21ebf36d41ecb618b50dc2959b572f6f9b081c547b2e0917ef6368cf23ab3ecb9ca11ed5202d59df975f2a4dd5130590776f1e3a8839fc44a2abac47228850787bc16ae3743770e27407be63e24385c3aa4deb57f64ab00c1cec77f2ffd5b6be008a26d5a109b64309a8ba253fed3dd1bfb771fb0d320809260bd8191310927e721e78f14bdb3dd1db9c46c6c81148419f9a228a0d391a1c4c7992a6acc9d5fc4ac2c5ab605fbc7c181dcdfd09fef5e8b5f90dfe7cec5062370ec564406f7c8ef105737c95e4d68cf89c6ac6d8b15980a3c0f589acc439a44dfb74f18b07aa5d32f8991b65d9ee2f5e8068a7c8917a51ba80be8641baa27b3960a9c36133bc9a0f6b872a6e91781092581f409948fa87670ca535c7a2e8780a903a288c73d8b1e67764bd5239590338c39f1d66a702611fe23dd122475fd1bd11823609153a2c154162fc6dc42f363da921dbf792f67dc73278e00a7cd26ada06c24c88cb35061ee5d7b5649dfec99bbab919185989df2e8118f54d9aefc51c4ae7b59b6c13520793a19bcf8aa71dfd3b4b273e699a37e975c0ef9d597c8f752fdb9bac1b9bd46a814a0c02fa7dc69ae17d1a0cd9a2b86a0e2761c86cb36cfe5289eaf48acf8470bb6adb2acf98075b6e68fb3f6fad49fe3beb700939f25b2ccabdb39a065fdd9528983e324e62b6d1c40eb4fac662f95c75505bfcaf9006a805e353c98ad61aed717efacc306cd5583d1fafab4898a395acec2fd7e8f1fb042eb095423d926236b7cb126e87c1d29a7b639563223134892aa42ad49d48681d569ded8943bc1086aaac21d9880c3fe2681442aa9d556451b89de602b18f579f38f167c0d985d0e1ab7f37dd1f3af30629095f0b9b9045a5e139f3735ebe048ef09f2b7f1cd1d184082ec78a538e330b1748fbae8df42ca91180255c1f5498dcf2f273b15476e8974763cb62675dfd1aa623444b51b56d24ec355e9145849c71c2ca17a4ea9505db3becbd3d24857584e90b234ed2e0bb30b58123887354fb4680b8297bca25821d727ff8474b665c71de8a9b6eea26f43474e47b0eefa0b14b1cc04c8c18bbe9f51c32c4a19c821df62040feb1a0b4ef9237bda4958313835432aabecc657ef1019caaff59721d1cf02e15a3e31efad702f6103cef889d136d8ca92f7ae43d9a4cb27cbff3dd1576e08a1be0e69921bce3d0a31ed6e0f04328853d61d7e9354d4a5e4e029c1bf688e90bd4b597780794e5658564ad3774c46b2f3a670feb5faf895b8b6dd0c785970605fffda4d006396aedb948321356643fa616256203ad9e992b3f6889d62658373c6d9024b124f8038742e67194a74d1c08386c5fc13da14e1d6b47e18bcaa460f0771aa0b83bc6e272b1f857cd9a4b4deb5848f52cc314147c55fa42fd159d03b7f929911a12d106121325de6ad50d2a28df4f9b7c1f80a23a02d230f0eb180f0b2e4cd6aa84a5855938023c87faff65c7b45886e590dfa9b3ee595d03ecc7bd3a4a321a1bad079fc6b28e1e688113321ba75f8292e0c74b7bc0d4cacc6414ad632e692871c7de43f3731e68df596d2c57fba3c416aa0de57b1564363e8b925056cdf7c9cfd549125d8b6286161e27e41be103d731dee33f3b6be506a08707584306ab0107c35b3d3ec5146e4fbb15e5769a35fd56238a6734c54498ebac168ba311614b8956f12983f4e32c18020ddeab677eb9cc44c87bd2c861e48b14448fcac770126d40ece7776b92da0e9b534831c0a48fe93077b7111faa933e997c34f3586a82779949a9e67124797c46188fe0caab16600afb25abf2f416409fd6b4e45ee6b484962f7cdcf0434fa2dca64faabe8c11ba55f542ec3df962d71f84197f441045f2bc87a056861e2573bbf12760de9787e777ac6ef43a8a710b207bc1d135057d46a70352f605d7741441391b779f82562a9df8c350147dc7b074b77922b66c3023d42550964efc7c63faa5ae507b1847dd14a15e8dd3dc9687088b9b56ef134c7f1ef904bf3e9d0a49dc583edca1c97b31204f23b3e3c38f6f5117a2e6013c7d3264c781c46a55c5269f1ee7195ea22d6153b0120b405b2c6933badef38e180496683a1e2025781d473e6b8437872c6b3082bc0186f3eb38a1b7965e4d6996a177f489c9f9f76922d8305e12afc96a309f1a2c5483a12ec614cfbf2a9d13c621b861b66f790ac06fcd7962c3897c9e9c0c47873788d198192fa0f53b16b3113175e2b9e9bff212191302f1adc645f8838b1b4721e4818c75acfcd0e1ef0b639a1dff50a5e987af9c6095d5a4921f5ad6870d6cb02dd47ae61f91e9ed1782f0f4b66659d3ba3d9b86fae13b85b08211d7259f06b0f2596958b7ef5b33348bf22a21d037abf2b7264c2a8fcdf0865cd0c12337b5a77253c73aea33d77e87d6b59c286d019528aefd1fc3cb6df2ee7a844f62637eddf9d1e3deb3a7e9c37b12f1a3a8cc8ec13e6f161b32466dbacbd43dfb389f61faa80f3ddbbf968630ca07d144b575e98fc98902287846a98ebc27cb2060e65654797342474421f00a5ac059104a4b22b0fe60230c09ef23428f9624be37e688b5cae9c39378b127cd9452cf161abd6198eca5e3dd7d58c3e02735322a1f52dfcff7ed45398f44d10a4bfa4069944be1270b2a15c62284892928638ee8df6c04d01d9f64a8aa260185c0c3a1f9de19cb8ecaf3042ed4eb9eb480a07a1edccabd1d1198f297d5bd8e4752ce1f02bcd7cda181e45d508d5029c4c6175698c4d2eeb3ef2aa60164f9925b3631ccf3d7104704882863a218c9eadc11563761183d082993774391f5a301383c71e9c7d0d6a4a7dbe6590d11e2193691d09a0912b6d65dc3fc6ddf6ad0c8a8985cb2ef51fa8539c7b0bc65c0324eb5d0445e5fc94a79c88cc53865102722bd0d7799cac855ecfee8f425edea000af72be65cfd009d4deb8dc9e2c8ef579b0b5ef6105b53d5ac4ac09d200885bba0ceb1df88bbb09e50df28a074e17e189415b5a3efb413c07fe16197ccccb51c4b032ee5747e55d604014ec7fa8d20c5e8be0412272219621907e2c7facaa8250576d7d94edb631ee95466cf679fa0c173b8afca6bbb3bd6b5420b255c3bb6c4a51dbd73e8fce42d71670a973cf4b2cfc6c96570f28b362ff9cba6b20367a2df34125ff7f52aef310e8d6032cb5bf51cadc3c6216178569d47d23e8fe33b7e0c97f3d5cc15b4471e7bf21d7aa95cd18c9056c915b1b56e7c94eb567584e420a7bd2d21c95099fd36e24af66bae919125e5c3045c4a47ffb7e1973c0fb717c876008c0dbec0a77413419b6f474aee517f0b5b6a23ca7ad8d35f3365c177eb85282fb5e114883ea05df38b13778c8598617c4182bb04e23d9bba6398102db6461950903870ccf60514f221ef0895929ad167beb66c0692af51c715a1fdb9b561b9b6a5b6c70be67c19c8abc5ada93c306d16fa533acc642507abffa95ced0c7ba647747d748001e65a75ac0c49c8c2323309b6b109fb7090e8658764a143b08f6c050f92eca6105eee3ce7a9a4ad7f43deb3febecad0b76e37f86fb925a000cb4e37a4e49325e072228f598033b1319ae636f35f67fde3fd520ed14f62b192ce6c57f9b7fc3d002e6bf1e3d10098640de2ade5eeb80990c8f3d7c2078f6b1e817f0195260b5d9751b64026e971fe15b6c706d372e525d6afb2e0bfea1a31133a941a0ee2e9163a0a8d1aadce3a260b029e7240d357ec77bca841588ddb49990c86e2812d1f60d3be665e1c62d517b5c5d00f65dfcbe54fb960a40a64ba833661959c53d1353381b7a71d2a2ca9544388b705fe0fd9433c49380c08379bd5cf1bb22ad12faa98e6d0505b248189199e460f472814de2697ade5f0c8be23ae225648d33cf57ab190e36abaf66804d224f14a3947115637573213354400c040828cdda7e5374458b2e6cc6016c65ab2b57eb34640fcdffdd049ecc890a6be99da0c745e98138d7238c2ea08ef0703f254617877b3a99c0c66a9f0ddc900e23ac0c53e02d83937d069bc07919d88be9e193cc655431f12a3dc545eac61691cb799c10d3c9bf30dd2efc7c3340d7f9b5dfab6c2a93f5f89eecdf999af363b8cbe22c48c26bfa1f7e81dc7b5ae50ca06254f49b21bde4c40d3d9fb4939336affdce89b69b23a1f1c22e0620681133c99d49649bc1caed73ba489659f849f25814ba1d806d779fcd2f72dd0b03b3fc82438478a34102074dcc6383d1a2983a83ddda234bc4dbed8d141676611d617e696032cb789dfeb849330674713a34c184e24ae12db6429e16be84f6469de24bcd5e3cf9290187f59e4dffafa132b6cc6d0c0f5769a8780602ab855916672496080a2e684ca4d4ee0209241c2eea8b743c57ff6dcd10394779e4b0224a36924a6b16969d8d1dc9aeeaa470180faa1d87e561822a14b28da08d4084a6790a3cce95db536d8a08afa206d5da6d7cfe5418d65b3c96d099c73b949d59446a9e28f74617b49d9bac74a9ee19ac3b87d1a3426dcce4a7a1ff1f2756f4e245eca964e5dcb107971a0e504cd1aa4b19b091990f1ef78dce2b315dd0676d57fb864aef430990542309f41abe8c4bd3e57714100864db970504ba21e9feeef6dbfdde5badad1d1275b417ced3a73744f18ecc29cc8fd554fcd5019702ae28b44582a1919f47665e86654f91c54aa8f6553ecfbcf5b1a647964a5567364b0ebd1c1e0e8b0ccf77542dc5a3d9bd25c93e51c49849e26120bf906517cda046f5c1430fcc0ed7120fa17b5c83be5f3866b450068877637716f84d5c77a7bdad545103f39163bf49d5b7faca295937406e2043ea924c4ac87fa34e4dbd5fe04efa652982b14f973f0dee4a0fbf20c77a37b3dac5ff1092a9be0c4fced8a6abeadc6029625cd07ca8c1d0e331d91e46e57eae7c33486c3d34d7b8bd5ee52c341b325fb4227a7d491a9d1d93b7e85033524b8adcb8e5a65197ceaeab056c5800889dbc86aafd37fee17091973311d82469b60add0293c34caa15c12cbabee97bed8a7f73b8fe9f8f251bcd963815c02370c0238a19a4c0694ae3001ca45a819648830b04ed647e469888c70167c48397b6e69f0371a303284005ca34cb1f17369fac1b320d0e115fa8b9b3caacee2d9c8dcbe69b80141205e46be5a0a2df97832fcdd3a0fde998a6cd8a1c62e487b9bdd702094e4169fd16b25b22d42ff50f03a8bd88bbac3e55fbab8fca27932470712999f5052887f7f733eb6f5936d5aca1ed9b3e58123ddbf77f4e39e005c5c94e65450647d80783cd95f66cc4a2abc463be2d3eef25530d0a0a51ccc2384f7b364cbd8dea7472ed855087474dbd4af78247715dfa2221ea95abd06b72ce68b8bd7983b0d9cf08a31971fe23b6f2c2f0f996d76a1e2b1b7bbedf1cac6a1cb0de1bde5f33659dffdbfbbf05a2669101087be31fdb2db01e2c54b994222c7ba41bafc75115fb974b99905fc0df820302c71db2e0599bba9dc79e89f80991d82cc974ef229337f61c892d30513e1007ce71e7b6ff86d99429330384d7eb3555a985da3ed836074a3447575f5a038de467a33e26af13544c2fce57d3e82a93bc0ab24832196da5120fa3198291a217d3b3c6cdcaf5757ebd91e380e38950272c678228aa224d7097b9f08fab884c4fcb688a4cc768aa969c82dc8bbd0aa4b831cfdf2b63eddafca5fb71c5710bbd63a96fa0f341e1f5fdfe4ca3c260b5e89582d22f599cbb0d911a4b3407bc6a7e80692c6d0eabd7fa6526e2df54e696eca74fb2992c582c845201df85a160dfd1781906e8063dfb12480ae7d6161981530efa30f3d16ac1163964701459d5e70a046aa9aafa29371b518b2268d128ba2c1f3584ead983d2c844f52161ef9894699a54aeb0b29e72332b843f0066d9174483243140c4b01fd9a33c42931e3fa8580377106ae1ddea69fadc63a86d4dfedcf89d0ed4259edf745d1f185a69f7ad6f21ec63caf7efe138a00c5c441ab4e6405d8aaadbf5bc43a40dc075db7aae956300648c164cd15c068374ad8f3bb17f34a169b40623bce8228140819551adeb8ac30c6df360f350d1d508036f3f556dc05cb3f7e665219b3bea190a4cc8f421da4388175311771479b1eb369e52dbd47a86608eb1a794491d9bbee2e4d513fb369248b13cda1db289257f79a5bd488a62a5ad43e8cba7eb901ab6f2bf81557edd723edc0f353c60b21db0a7797da6e31b3b3ddbdfa2eb52ee8dd9d1ecf149fbd884c608b82b133f1c963e6f4c388255b98ddbe8a95e9e34c26debe96aff25316a883ac8fed9da424c34a5ed0b6648faf61af80e7930bf09aba72733452b4168b18c488e3e6b0f2b0d1ea0301c4668947a55aec0a99cbcb0b60f7390f071589905efea3a6858344da1d3870abf0e4f80500173a918d0b34fc84c971ebd4890aed8890c10906f61148c43807879833764aaeafe5660274c3de38731f79be2914125051ecf0fb6ef78f4baab02e995f0f05bc8ae5dc5b91e33b6c87f87d4ba89ed2fc345f286b2ba972b10fe1ee3461223a2e6647232da627422a9a14341b0cc2ccb1ff0a3878f7c3c92b74021ab6275374e65efccce862ae8637d9e8d115027b4e6460d31654a17b46ee3457d72a91b6cb149c3bcee3db8bae98d4537225fddc24183081d05c6cdd6b23bd893b01a5a7c4d3070f3d33dd0527e27f248e249768737927f258fb0f4258e200c41a27ac0299d7b672b33ef67ae75110e965cb7511fab872861e2ba9d30dc239bc649d695496e65a0f70a4b9648173dfde4911a51eeeb2bb091804b59d42dba3c92b1fd15d319e8a9de37d7b604b22f820bbb2f304692fc8b6e03f83149c231d6ff6b620e0d2a7ccde9d758d5c5fe89dc981d8bc41cb71014832f5f0ca6fdcd1676a365e61e56a150c10b85df7fc3962587a129d517b8e530613df928b38501e8bb572b9e8bbf9f01f2ebe65990fb23ece3e1130403ea20df99fc738b5c503a02b3cb3847df9021af8d57af38be2e1827eeb33c31ce79eb4e975d30a70b81f9ec4146337f5bbc8017132b984e6186efd6f0fd961cd5df500cec56a634fef6071ddee5f11ec51eb133d6e1f98716afe1e64b1a5f0e1ef7b2c2913097bd0d951adc189ffce7924a9103b1854910f69302e903162b1cb6be4f01bdfadc60daafdb11e9a7766d5dedc78cc3673399623b48b251698eece6201f30d3ee72bbb1626afce28dd8232fc02e631d5c64a0a22d0986a8a81620f20669d9262f7f00a3d0b03eacf31d0d2e6b12048e8dabe4d4ba65c331405dbc6d1e986134e7eea712551df92f1c0ef0a56e13e40b12ec5b958d4a772ed8ca870abb5cb60f2b409be4e3c5d0487ac8be4dda1ad1f8ed072c1e8f2d817b87e2d9150038a4a3c8a9592225772f7e7a249dd17fdd736b0a1c8abf9af2c2c625de42c0901b033fd9553cedc4558b9fe3ba589089e1ad3bbaf58f8a254249970e5e29391f0fd9bf313e14c597571ea8e4db0c6c16b37d59a5bf1955d03f4d141a0e4df1e1f6df4a26cc8d9cbd20d9a7d6c0955c55f1d48b00c6f225dfe9521bf855eecf0d70b4ee35412a2905c91cedb58c0e29d629d90958659bf6c143b2e03dd9837f9e87e96d5845726ee90a161cd943c12efd5824bd9b0348f55e634bc966ee583d5eec75a25bfef6ccaf43a8d644dcfe0b0832456255747617d645f974063d0740742b7d1a30428f484f00d0c4f6513ab29fce22d0cf8368a8116a2f54f2577580b3766f4e79f2416c8c6f8fa7f6d6610b5b814d15eabb9c52c41145246cc55f88e84b32e97e5709e3225f833bd843cd0f329b276bc1ed61ad32440df932a027c3f39d8aeb4abd02eb5b6bee43fdd0684cd7180461bd4e21a771b035cc15386b1f41b6ac068a5da660e7b6b9601526f2ca24fdc65dd4803c2fc44b863038e66a66f5383ab364383d956634a3ff253ebfaa2ce0c26d6265d701cdd841bfadc62fa30ebbc864692555968512f3f87c63f77d880a352fbdc72835a3c675913a46881c4414f75987e7330ca2d4ed7da3a3ad6a8dc48013234deb15d1b5ac1f210f9409c2955c2cd77ed58aece03a36fa76b0e5d137528f119b42e397b86917f4ccc817bf486ae8c8c49c0854485b016206accb3ab99ad6dd247e00e9fcef5b54ffa4ba31925f3fde4183ed9b3e6bfca102233cd57fd245bc201c31d9d704bbff2e8c775fd88961af64462301977df3f53da23a373ea4daf701dc4b127d44edd7a0f9a30fa1cecf216ecd0cbe437a3b966b3361fb394727c159e03395280115bf4b9da69d1131255ae7513708b7ec15d13e30bb3da0a6d1debd4caa2bafa42da7621dae7507655d3e67c7ab292490b7234e33a0c15d547389654218d425962d6ff935291b8d4bcdca34fb81ad025b40e8d8df088b60ff0b00293c4bb0f188665414c6c7abb3042d067fc73b5e84403e2ce5e6f67c9528da3b16f60a708edbfdafd937821d052ff0a6046f3d2ce5d172f2eba5dbf327806210673354caf870945a4e790f1541944a054b39c38eddcf0a7034def7d6177f059a9da74a962ed58b8243de8b2a5cf396d302be51cff88a89d2f6c952bec8d899da2aba6b6557aeddab88d76af943132bbc22d0bd6ec3463be122a25066135eaa83051a534e7dccf96a24b90b39a13a61da53b1138840ac4c234cf5a4d4e3810642a0c054240cfc1574dbec096d56ab320bfccb1693c95688da88eb514fc72a843d96333ea4bd3ec88bcb1911580743369691e5d4a5450e0917921c01fdb30a95b59aa0ffeb7b8ef3d8a24f2960c2cc5bf04dfbb8605d8c4e13e1947ed6397533dd39ccf4dabb128e612bc3c213d3b58f53ed1840af47019e225bce19713adb127a821d182b2e6f52f1d383acfa86de06b582713fd84fd98fc02dc0b5cbe344df41d56dab98f227367f6af7795dfbcc890cfe5e7ce9d224e1d6656b876d3018298996c54a8295041301c6cdc04404fe191dd5d86b89840e2c358c93195489201a5efda7770b7191f7f5a3ca07a55235e6b5d9a0f83c90fb4954dd5ce2aa7dc7ec093f71e5df2a1746cf60b47fbb71b21d8b1b308c324008b32529c979701cf4817590ac7dde1eba1e584b8a2dbea40c9a69110eb14f99bebe3cdf7732d15b9217c67d07024b6b51fae4e71e95641316101f9c5b96e28195ea6e341ca42e80e4c8f5def8a9915a15155dff13b03c46f88fe0781e02f6b0f88257fb72fba63f1afd4af9e8bf356dec6f51d86943864e9bcfeb0b5a01fac51e8b0f3582cf24bf2c360c12bb7c2e50a85ed552b7afb3ee828e11a6ec00a54dc88754ed209f86e71cb7fb855ae3834fa00adf96791846e137f15b9f8264737539da95b57f295e286b65825cb9d936b0565979e9f5cb3fd475fddb96646e5d63104160161091b1298b2c018de133d0d6c66fdb9c88381bab42dc2cc029fec546c5dffd0463203e33fb258b6d576a338f025f56cad25358c4b31a419b9b62b5050bf1ae23ba4188691cdb17a084599f5c566542057c6da731da421022faa0901b6964bf39d24b2553fa8e864aa64e405fb3656d4f07d3da65249500edd3c0041aec8cf0f2ab49b8fbd80c5c7ffb4260160162e34e107a8a524b4dd2a8e7e71686de0f6373188cfdcf2c2c38bba220c3762894ac5a8063288cc471e83118d98cad643c35f98ac1657e98f7154f4840858ba6eda76a0b6aa6cdb30f54091764b0ba0f8af7b2be3d7c02b29cb00c504498c298b5ff98bd0c86e5d681ee5339f59ae2f61f737a3426ea9c2bd0f2ad333762f8db3bb5c181c82c8aa9379e4e49cda73301a39b02b26b78d9ed39ebe3c9bdfdf5e508cdf75d66b0c35c92e91a759eeface36b4c02b060b5226aba74c5d23358efa59220ee8980c48945a13f951c20e15b80a2075bf61860119403f3d93a4a3e7b86ff58b435e0acfdca22407ab43e086ceeac48dc89fd0e109440c73f8f4d776db7b66e36ae4a89a003737f0973c2214a24c77f279bfd44322e42189749e0c9ca0157fa4c0de774d5263b094638e2c03cf81a3f4b6491f716c9db587e94bf72d834d9a2f229359039c73aec01d6f3ddc4ae497d79b0e5c52e1d8ead8f3494988c6c446fcb28646081761660ec05a7b703f155ebec3aa7b05950387ba73231cefd58df5b72e34dd3a846d5adbf656d85eef5bada3af94ccb1fe6509996f39ebf748f09e6103670629fe18c5803b037bcf4c630adf1442246c61d8408fb6a25acb88d29fba183fc9f45bcf24a25d5c637b051ebe685755a4a0968f73b71a5fc62b11f35380e5310455e96b75db5fa776baafcaeada90abc875f00438d0475ddfe87ef77256a6cd4df6dba019ba66e4d4b1c2be88b4542dd90526d1847cf2549c1d509088fa3ad2e138f825e42ce928ebdb668d548c46b39890ef287211ca64aa42738543e1a685d6b51854f8e44215eca7a21fec11f801013ad7c8a059435e0e52ff4aa599d883fb3d3258ad9e953364dcf10df39216ed452411e1a8e8084745a968b6eca88eca5b763e04bad27c17c0f883feee7596fe835b298dade26d4df340a44fccbe0cd3ab18a55fdfc9deeba9ea31c7f6e1c59a0372a886a25eed2802e8db5cca6d216f6353983c2d9440eafad2b364f84e6af991de1ead6695a0bc4a7df2f6b6bfec05e30536f9519fee3d8396e4c964fa160d83fb91babec2886c9251ed39592991531c6804282f14603a5a7fc90b7a7eeacd6bf3eca1e6912c133a286dce84986a4f897e0825920d684e743a1b246b190424a362a18187b7cc2fb2c129d57f9cb5da7a31e985fd3870fb4d1ae886a10d93ad1081a74da4d318ce25f6caded1d5590a4b2ef2f1dd324a17f219e72800ab1711d33df47b853be1f8fd6b7633b36dd140d64e69e495774ccbb266290ce42188193da43e65c5c329e1e278e2e4d23505b34c70c413537815197afd871d004f3e7ded87d4a6e3662bc123fc09d5559f4d548e6104c92103839e3560556eef57443c120d06b6a16b0463bbe50ad288d0aee1f17c62337500ddf12d3dd4fda101daac2ecd557cd1bbb7cb9a8d6d8e46e930839bb03362bc4c53f769cd4ac181b970b14f9ba7ec3212236fa1641ad8229e29dcabd1ea26883354bad26778aeb8f39c9727abb512f5d3d6ca75ccce2413644c231bcb984da224b8a9719ad2feecd2ca7b414123179f7afd797d0f22c5ee3bbbee08e89fd4667e6c6763e1418b9472b0d2d1b8c8d1034ae4ad2e8e20ae127f977ca6241700d5885de4cc5fb2bb6193be0a950625b5c3ce872f6ab6d101d3a3d7ecab8a24ccc3e5122c600addac5d8170f36130c4fad873d07b5e6f5315cc02c0e4e9e8f0137391025d23095e3dc19d79b458777b60ae8b6bfb7135049f6f308ad9462a7adefc0fbaaca6d20a17eb1966cb5c26a53a0945960b9120b117eea5d3e5ab304ca0df38cc5b0760a0aad2d4b3899eee4eb041993eace3cb18cd44397d4e51ca4beb6013fe202a7ef55a0b479687a995e3aacf409a0409cf878307f4273d94dd5d18b48ed3f49f3fb0ec5b4f03fec7e7af5736f3c6eb54dd7466378c135e117bb607e8a5efac49e13f4501f3b9a3a7304a5d517bfeb91f87c57c8498fd859d11b6be16dd712d856fdec47ce15a7128606a3d69743d78dff20cb5288d152e52da59b1720052d0c624b4192be2d79a2c5b40e6399c39bb6cdc603e2e94b83e59282aa8836b0747effaccdf3fd8e881a73d0c9680ac15e2abca9ca0a907aca58b615efcf2a98311defd9d668e5684c9feda83f8dd60dd5ac4988264a5b50f6cf2a2679695c3f74d10e293da0aac6ce1edaf159e921f07dac79af6ce666fcfd89206d933513ed298cfe50509a0d2e271aab014d2fe64f49bd1c5e1e1ad6848fe58115ece497f5ac95709d8f2a51cccd88a69d77ae8e7fa4eef5b01958710bdcb96ad902ac392d14e898a868fe1a3185d521da47c3e8dd01ec6aa39fac8422cb3d2c01884b4d2d7f4d770dc6833e40bbedb67b44016dc33061210beadbe5ef64feb56ba7604aa7f0a73997e422af16832c82ff2ffd5cca382ac135815c1ad0065d28ad56dad5f64069deb6383ebeb9f79e48b1025c4c9a1f10ebc1c4cc07a761bfbb32095a8ce8f61a7b904962becfcbecb2033502713fb9818068c96da44f42416878e10fff6fc3a58a4c90d5b5846e60560c80938ebab41f5ad4cf63d87f1c88806bf89bb0c56b133e3b9919fcc0fe131376a018b79c8d6fabe18fe5195c714c694768a32f59b272b60bed51101523411d5249972dfde3fdff536faaee9f240a5fcec9a94b93b611c98a71915a84339655b76909a08152224157aa7a13d85f017f0ebf748f3e9beff25c94afeed4e8dbc5a0f90face6671d3b43f806309b65d1941e444c71f02b582a1882ffa658f1cb81a4cbec5e310c9735ea9f955a02791fe2827ac08fea5323a5ff569d823a90b673c1cd8964ba65e7bc2b435e65d2a06a01eafd96e7235236c763e854253cc59626c041e118f895f66e562b35921ea50b0af5d10bff2ac2acb46d17e8ae7f64a3da61c83df529cac5c9c33f8dc7b5354921a650a68d9f181fab0fd90bfcc0d32f211ce17d487c52df58e24c52b7d94b0971a20fc5f030d69b59708d3d457b755fdf5624d68941194dcd22982b79af62228053e7b49af858957e5f85659fd1e1438ca2c9df9904753ae996aaeb4ebea56cf2289862f621588ea09fdc5dd937a7ad7fd67d358f604188cfc817832fcf2f602c5fbe6c2b302844f84ed72750b55589876113096f613004c53275e8b80a90c6adcafac41e61b69e2a551d944196b41dc299736da5aa507862732af53bfcdd6f2d4e0733fe519357515cb9a4dc4bad6546155fb16a228c3bb65054577b3ed81cf45b1965e680a7631b6a7165406b0590d19dd706578e8bbce2dcd0307a92919011c70d5938077541bea03572ef9fc0bb3290e789108b036cd608b604145ff63c5146a54c8501d83a318ed929bed4e0c15e5292a91770948663d8c90c861fc44c9078f1cb7e5b20c13e1e571455c5d3c8252a936080b122989e6474d6835c45b8a5f02921397916ad18ee7be758ce315e5a4fe494209cf8e20e776ba1db6acc57d10d8599e10b78ea3ae45629cfd2bab9560c80f4f14024454ee1d49eeb5cbae9becc95ecf5b0794aa8360015c4243f013771c1014c5a3a697b00b10be7c913628501854ad22ea508d8130d905e82da8c3826b18a044d0e2bf3d58e0024c5b341133d7e3adfa1f56438177de79c90a6005b344b0fe9bd0f2b1b162d3fc91669de55ab397d7d6f197e3ec8c4cf0014e01ef963ea2a81aa19100e790811b7fe88edbf69d998eb6b2c97cb6ba3b1b255d3334a4670dd122dcf535614c848fa96d9057a0684a087e8566260b9a4246f36c0b0291eb1d5d5ac8ccd22330805fc24ff5e59beb4306b71738f4509f09eda94b8d89b8bfea4456ce6860b9c388efd957cc0612efc216c6a613a47987bc3f478d9b25be7fb04f8eba69f5a33ecff106c2bd9ef59644bc61e7e5da84e7869d461db7c9ad2335859d6cf382e99a4459e020b226de73322118ee1bef0a13841efed2dc41ed66d41a2e97fd59b3082c35d1120b2224f0e1603340414d09be342ff93836f1c153961ed56be8b3480b21da5aa339eb4ff5327a69a493a88aa5c1d394d0b46cf1f956dcb736fed056ecd1dc28de416226c8b2de043764f153b9c80c6b526f0c9ec920288eaa85a61966cfb1317925c68dbc89a0e0f7f861ff8abe2a81f2e1afbe3eafbf5a4736f314e0c2e7ffd0f72c960205e43eda94e4fa092dd2f7ecd982236ae508b2862e27197cb5e9c36fe445bec525fe76300858c1cc1bb5ed52beff23c56c6385ec227c67d6575ac56c9d07d1ff5520ce37b749bfb405b8ae728b87bdb78e84a8933996734195b0f871caa475e352f7e3a00342d75857e6081a201df7282cd59144c11976787697b20ccc07ac5c57543f1589db2fa5dccbf806f5867a21b484e2d1376bec97d828fc17a152c8675706aeee8930922d7fb15a77d412a8d74b41c6376a6a1009785c5545e4fabdfc6a5ad2b2db52ffb50e85a7b942dfde911401f2eb4b21cb83f7c1fb977b1e3f78850829321ea44a20c99834a3b415c05230655b48f3224ac3ab650a777cadd7656915abf4c8f931d41de96a975f4efd8aad3e2f3a9826fb7714219d7145bffeb7213387e9169f8d28d58d4903366a5ae6887c079e66292a816d76e578803454c6a51e05e59cd166743222bf3a7fd3de9f7b61914c6c20404de8c0910310bdb19dc9c785ff0f96b9310e74770a6bd6e5910921ad8c77448fb8c77c6eb8489ecabe4673adaec86899d679fcdb1c814579b1eecb26d3dcf65acace133008aea730579caf94ef1c7689021642b1db8cd571b48ea91122c348568341c4c925489d60ce595b424738c5e9ed3484d3acc3c5ff5561ea172859664d3548bf165b085c3189564c9f84d1e2d23ad03bd2176a975dc5200cc71ac579963d32ecfeccca89d0312a86dbf5a15e3249223eb53bfca5c1fe7fb1ff6e926bc252dcfa14e3314719b9a3a301b4ef3fd8f021b060b6cdad68231e37d82383161dab2925642aeab1050aae7aa7388b92361bbfe1038653dbcbe7ab2b96ccec45210427b2c9177b3bf0ed117bf887d14c8d41dae04f723938a2e31b4fa9224218043be2e5a870abb513a9b6af03a1b57b050ee5f7960c1a84870060f173154475bbee7f9c5e9270b6109bfd63c2a9f4d3b04dd9be752f54976066326a32c90d5ee85bf26452f99f94ec8a9f164776db8e38317f4ff7df569d490a658fd7a17f3cc2d37212f0f40cc4209c33408aa08c7b978f3bd8e3d93c1c3b90b23c22099e5b9c72324d2b0cf582e4cc51a21a9ea630d8c253b8ce1cdc67b81767b34eff50e49aa70cf09ffaa277865299d180512a78ca9bea5d38533366558b17109f74a81afebee4eedbee731f2b693a3ef18ca87c5f9a56bfd29c79d0e650f3414b9248ef029f5d17f27ad279625fce751810de2069b9016eb3981f84d1d5396aeae4c6f754d11bd6bc4aa0405459839391b6beb70012f2b3edee02981f6f37ff28ab2e9be893bd9fba541b9dbb3fb3d60399640e97c0d704ae14b468ba10c53805f05ca28c876655d63a03becf4efc8373f09d44ef0ea15fa6093d7a083cc29a423a958b8b4c867c96a631158f9fe040a85fdc3bddf72f3e3301e5c3c3c1030bcdbe41d14413a29120058d4d9ac176ab1794c41e611a41c0ac61b29487423ee7507899dffb95b486784c07e5bc0f407ca54a09f79c64b6d0576b84ae6ac849433fc5aaad1253528ff0f2365d434216740fd3ddba875c0a2d13de63a669e3dc6dcddfd3a02a489d89f8e262809c6ddc7cb19641a678d00b22201bb411b377acc39721dce6b567e7697ce7793a78e6a02a5e8f246c2f544af32757a7412bc43a4e38b376c6b8c1f3e9f3020064ca10849ccf5e4fbbc553bba65e72fb8bc5a3a8f570319d2574be406b4de6ab20f3aff42a96c8e9455d5163bf3ed9c4c1fd121e066a82eca723640d39206259c74c9949569e1075d8350406906402ff7a62ebecaf6e0cfac0e5cd6aa90f720bae00a383fe6f8f79144443e350102b8a7a4cd7f4af4ca0ed6f376cc14901d42db1c3a93f64b4ea1d93c54b65ca071a99299ce3007d0237f1a72b1d9b8a286e5905f34f10bc7b9c59b60b917c611bbf7ce3d35ab545944166080a1f906547b3b92e37e37a06ad41a94152d5e6cc0b12f960962c11cb91b043b1e017044d7eb2f77798018d244b717202ba951bdab234c9525f879fa45b2a278a8a139254a269c3fec3f6c79ceafc7998be13e123cfdc30fd804745bbd6e74745c2d51547da139357cdce4cef8ebfdba0aca604a6647125ed98964f2a4473d6ec5215a67529dda9fa87b2926ef1667bb6abac161cf89c1339b4f803630f4efed067043380a95cccc523e9466dd0e9d7b4511d83d4fdac7e6cf1e8b5a2b7934ec6f09552c04e7a16bc94d2c8fb16caf2da8e22598c55b1dc74d8f4cfe8fa8b1298310bfa894ffb1e49f8d820b9cf53d0d6e779cb0d8cca44f1075edb868530e7589cbe63c7af3e2679a2e21dc97ea7b88ebe534d21fc7c28be2a76060c23cfb9f47320ab13fe5b758a22c3e989c7520b2270541c46b6d90043c47b7ea7daca31bc22f0aec43f8e0be31958d64b5495dc8f4ff5f4bc97b0eb36ac2c6f8e06b5432435db5b699911fcb3e5ab92f4d2c9a1fe6ea0054fac9b2001c5b2635df5f20dc9b52522a4a7c83a22a32b6ae502f36001b7192c5d2327c66f443021ff8a6fa4300613f5c7149d586ba53c19aa754bf1d4b75f5bd27f6a02b5c5075016e5fefecac74329c78b860b01d6b2d829a94dd435f9901c8e54e9631c3eace87b6b3b92a7c2935a607dc3ac410453a08f6f26bd734358245ae670f6ee739203951a208c5d2a91376ddd2429482508850ff72b1d8d56967fb9fb76428de704cf5d54ec60f87b6348672b2a050fa3cb2ccd33dd7874abd076ff75fcb849df0661b6345a407cc94229778576657c0623418a289bacd14c0987bbc024b68b6a1142e00df9f05acb3b529f1bdd52a8c1fd2668020049f1ca0840b7fd19361ded63991d6de12bb5842caf538a2c4054052ef462ebf5acbba8ffccc4bca17a2775569577514cd3f16187faa723db2e5c8b4ef5accd4729060e49143be07c520c28f252f3660be815d0cae308088476625bb70f14cb964a7d4bff026587fbc8926299138a87b22afbdec539a339a738260bd62c25079a17ac8642602f673d7552d49ece889de6830eb7fa77f7af9f7e084a9aa5feee74cbee655aaaf3b164745512889e8ea52db04d869080170d820ebea416e564bf5af550004406e2fb4bc757923b483b0090e488a8d964b8a0c6b6a883021044837253747814b6a570c075eb812bfbd6758ce4d91efd00ea3e84883cb0eb616bdfb36d1f7bf0f4e30c9d3f6da5c595a0bb18f553d1dd3eee57b794ec49793439af4612618366c6d57841495eb4d13e8bbe85e2bb9190e48b0dac34bd01aa5899ca6684148419c66870ae6181f7b9a67c85e4dcfb787d8673a9e859f46d0ec31ecac4ab160814e78487f91abeffe2d1669c72b3a6fd8abce84bd168668365685897627fffd4639811d8ac4b695dd1fb10c6b2f8a1594ee88d066da58cd4bc0f3fa04a9a549eecf50b7169320eb870962b2c062eb6c19ec9317674a81d07423115dd0bcab8577ce3721bf90d4fab2f87379b12bff2ed6e1e220cf36b4ffa451fbf6330d6eede7475fd5f62cdc3ce788da429756a09c397371b0b0c4fe3c3348c052b7dfbcde07bfef264f9004b5b8fa81bfac535592e0f0107b2c108e0767ad12a81ac1e28563d40e86cca3198c90e67e4e6a632b48181cc39c4efd82b30d25df5f295d3d75c07116db5e279bcb1939a497bf7d0ac05e528c7f934239443cc8e5e0cdbdce20ed7196a3450e127a02b735abd9551a8dab61ce9d382e08c1760368a305a70dafc31c745c5dc7f9f9fbe346db0e31e18335161697734f178e6f50e1287e7ac7f61b5372972bdaa8b12856dd5ea3a0c3802e1a481d79a9382d630e652e1b955baecfdcf6071a6a18e294aef5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
