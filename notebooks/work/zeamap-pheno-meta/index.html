<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e89516b5e7685962df9af7aaff9213abb3ea88909ae663e6c46bf501512ec9747c59ef23df0e96437e4adf3b1833a90de714263f9d34fc08d6fffee10da917336f609da41f7e69b720b12fab9a5a5a12a13c9b61c147993aac43fad6deefba43755af0319be6fe57c45fed3adf9309044a38db5e2b71af421c4cc02af03aba6ee44c84c80e97f7b473266825c15f751baee91111a39905e3df34e160a2faa1f0a0b4211f938e8db250b494f39bb09606e58893d69c829d20f4ebac6b20d3e6833db100aa74aae44efbb23a40ab33b5d558819b877b662066b01fe4fc5afd1368cd21fc59debfc9eb2681d46b9ea8c2f1a61483cf511cc9ebf58ec5fb909e9e67e121f747332fb9fbe29e617254ea8e0c8c25b7490ab8751f6a111bae635b409969af8c020cab31edc4864044d9b353ba3d3d5be11cb8e9ddd5284530f22ea64f0a86354bc26d038c01f75fd1439cd6d67e94448c854e06d6e1a74c7c4ddb16067d952cf6eaf7eb5d3db6c626373506770a37c400adb1076a222abff6fc6d5d2b77fe64a66b65d7583fb29cf869beeab7423e1a439287adbffab922901d08f83393a73284f194b044ba54af0004557eeb01bbbc342a1e32eee24673b23f1aa5a99458f4f62aa8c72b02b1063055743a2c30ecd698a1d2cff684a9c0abb3b3b1a312696e81ea810a5388ea1818be47a1dd1d1e47d1e691d51466563ba44eb96eaec0954859d07dea62e424021c143d823147bab81b35a6a53cd0b1747fa9cc8a9705e98c5f47e29791f39e6b47e7f10f73e613885f43b600e2f68dc600c2b21d349c265821522bb7bfd2269aa4f937d3d9f117fa6fdf0d44e474ad21820cd0192a8d46deb044cab603b3145ea08e806a62f02f20eae1dc2a254849702ce8f3714541870882286584ccb94ad46fd443d821e2ed8038259549a7f717151aaab2a5bd29e76f1426ebdc665e1459cccc4b08e6cd34717bc6d19554178545c00995ad5c00797c845370cc080cbb92722d9e751e9a00361771a451b777183b6de30213ec4bc957b8adca55d5d26e8eb70e258bd010415d2d276d3a4624799f0fded190dc45467a704a85364e19bad96a7f3a4c1a2354833c10dba54d97387b0e570f80864225806e5d18e1b96e3405f8b541a2a21950dc58bd48769d0cd17f9d82164a8bc97899392175ee873dbcd3e8cf59b3ab9bee71446e7c51b8c9decb8f3e65f9d308ba953b6b6b5d28babec45a08676f57475b45f284200220e15904919bfbf832ecacb5674c4f448970602b81d316e3dc45d8457e1141093dc036a526a3c404a35629d004c01f30c6d75a26f8fcabd43af6ea7b212eabc8001f04a3e5adf42bef1592ea5331bbbbc5cd79cae89cf5224fb08f670018c49acba757d82c6583be40c47e5f734ab839f22064a8cab6150cd4903107e4a81de3962c3afed98151f86db3b448e06a46ce31c5d30b373c16c23a0b0e53c0b95bd3645a4591a6230d7f3c730fe252703ad23c541ed0a71cfb168912181c7cab76c5bccea80f946a2406cffa00c9f6176abbafac29ec6006f5633b21a4539205bae5a9ba277fc24d6582b2d16aa2e76497796afa98a501d44bca4984199ada9281dfb6583b4302df9481798d0dc784740654bfa80f0fdd09da0d99868f854fa1ece57145f164ddf2e289db0720a621a160266936b9222432c7910efc6540b80db19eec919ac5d5e1ab12144df9f0e4800757d9a318250df8ca146fd481afc3593dcd4233590afe30b40014f22556f106115890e8b80742ffe304c4074379fe811c03f8813a70f75ed2eba5eab93a0557ab58b50261ca3818c0848822eafca09d91afde881daf38f0915e897fcbb8f2018491aefb933dfa5fc815d8a09e5d04de59fff0ae919a8431b6b56cb7d906ba09d9b0c4871a8e718b6e1123720db855d5a29c71609e6130f61f6009b2991774ff228943a59870f0ac0a32b4b42aa77a2e7e14f0e5bc8ec31238af8d3441c26fa80783d65fc17cfec899680a6149fa596055aa529bcd3f29f0e959df16f8c7999758dcdb977fb6cb7db6ac9980d611f13528d0b58ba9ed5b5311f8cdf8396a91c769dc7060f1e8cc013de75203a7368c8003c38464b92ba04281c06498430d5ac01a282efc841b75b9fa096c46a17714e70c8a5701e06f0836fcc408b344cab294eeb5097ac02a8c015d7cc775623fb358074ef738a1485bcf9aa02ee28432a2c60563c47246e2a34b3a706b6eb67e3024150ddb2f6c895e925d54a5acb9491a30de41189f6185f249b5d75db1c18233f3ec255703bd9b340a15b86eb6a43b7fc04cead383ae662849693fe9c56424ba3d98c5945bad1642e6fb3009d94e647f0ad9e691492ac1989d09715ba72fdb2c3855823fd3f6f7a3cd14b42ab7b57096930177cdfb3a429acbaab8fdf2182b2dd2c4b44a3f24e469d0d38d980fb265bf9d7a61fc9ea46681b48459907c7eac6edfde30f77a40e266ff9f23319f034ae0abcc42211bfc76f74d28e86d8241a25ac780e2e5b8f38b75e7fabc0a401e92a68b24449d993d80c1da27d02baee106b911e146cbbef2f98ed4fecf7872bf75bae12b91ebe16f2a61bdadc73622ff06f669d7b647d6217a2adb55033af4a145da7e498d5ed89bb1a13c78f21b3fe292b5d65ea8ebe024e1a0421b46904653a39c10c4369244c6982581c1704784024088cc4a018533a8a1ee78d833533dd6a13211babeeb9d9ac16f4468cab3237f54b4bff1caa65a49c0f19a8bd6e2cce74a5c21dd66bc91324a0c84d878a70ad265eb6c5daa3a445ea6cde264f77a64c299995b2a716e012bfe69ae1b21e3ee267e7377813d79cb48db611962aaa64ca747d07ed75cfd50bc14e2041a683eb104cdf550b8057cd4b2ffba40b8ba0a91534c9e87dafeaaf49eacbdd96194b1b862518e66790ce227270640f326c5f11f7964cb758f395992ad754c981d3c96b4b525f88040e6018c8f284cdbb4b2b48ab780e3077dade11f8a6225bbcf13c406b287eaa47401d7d2784c9535a604067733997206118455ce398a1309b7a5616368c2ea518cf7b3bf812c4aa9b773c001045112225cd48750087b734d4055bcd582741632659367a03e655f62934fb36a3442aec6a4d338cde4eb859c226397f7003045cac0713b4b066b0ad99ab5556668fcef349d7a2f406f6ee6e12206a9c38959effa1cd446fbb5b3a421b21251e0f91d6b546cf34b9af14d607e1ef3bf65e456856960923da80adba4ae7407c820dd654c9787913c2b1b744f65e8fe7c31f599f127b3ad731e494387a1a686683e60692e6fc0809a6257cc79964b854844e92ca991418f494d7b671ac389eaded0203c6ffbbd7e7b79c160ca4a9ed2589ef4797c153e228f2629f05c4b1aebf432cda646a9cb64a8be5823410881d4a84938cbda6b1908bc367b8c6d86cd0cc448d9085be97a5d2a9a21aa5a1bdf3985c1b4f7590c2187f3569ebee5e8b6642471d9ba666784a3033ccc4351953b591e17b80ef5ce92161909e4f081a93108b774b646740c23a05470dba5a8a43f523d7a2e6182dee844c63265fd30d347c7a5b2f242bd882d38d03479cd794062f8c7446faa8490de2d1cbb8c61bdccfa28f1c26d6f6aa8d4bd1387c2de178e0c88937909d309111f8d6596fd368627948deaed5614e3059ec17d774d173cb191ef4ec73b807337d569291b197dbb46dda975b493f60719126d2f5215e44c0645369a91090c5d7522ac266176c423a110b755b10be162b9f50b76bede16d4cfe11d6d7e37f695a9ca6748298e55a00487905c09969c87fe3005c79da30dc7270b0773b095887addd76d106b6cad575eb07f9a12c5c6dd5948642c659b94beb0a74abbe7e30ce8fc01857bb9e46b931d6767724f82e0f35f4d4e583a8e89f982f9f62ce8f5d6b405d8b87e5f91919893b2c0d76148c83b2861ac24e4646ae049f400408cdd0966509f1a2d32630096d254e4c8f75bf7135194263a042cc29d1908b832c5160a85712a4f88f77f2abced8e49f71d265b48952661c7a0c4cf9aea2136a0ff74943ac3d0b937f6f0bac69a2c75df1fa81a135c27db93e835573223f930e05e227f413ee417f565adfe274870189cc7654f65ccb008cd254306591534e7301d702dd99982f16524ac4aa3d8b67de6bc62b6e8db388314ade17f621ab2a19c6d35476aeb56b7d026b963b2cf8b71106c4a7a0fc17bb22180173a26479ccd8236090a0b2c2268757dbb251127045a52369eb173178928d4717df5e7d6d400df61e01c4d358a696e09f1c6f58e543409e7a98400d5d4a8d035ae9bee2d928798c4b4cead89fbdcf728958abcf9d0ae2381b5a7db9c50100124ec2ac204ff5ba1c245d0a78bf3e7a8dcc16a4323a8d054bd704d55b65b3577f30180adcae76fbbe68bf439fd8b5a8e7be1ef3f17de28868ae594c317f4d1528907a614c8db6021dea812f052d6b1a1879990a7c079383fd149eb4dc507f52ee677faece084747ff20de598e882610a8a802bec70ed4b759c4de3351454f9cf12fb3f488a826a0af737cc934bd07f8ace1624b04920c5be6e48927ce5df641226fe07a5905b1f982f826e57a1fb5b624583253cc37fcbe0972ceeb4a10f3414df5b2406600b5ba33f5196da1042b0e28a63d3b89394415e73a86999b8bb1024db619489232d8f67e586ff82d946f5dc686d2b3f2678a1dc1f71e11cdd90db636c2f2030862d7ba5f484f271f881da3e02581bdcab238d56466cc3db02d4d3aa3f2f773a676e40e322b3e8971db33cda6cef92ccabf9e3f1db7193f33ef3e73865db06d9c530ee4ff1af06aa3c0f32128f916571dbae4230c63222907dc6330b302a53e2d0d3fb42ef9fbbd4d74f4702de823cf72cd06ec0b84c976daeabe1306576f9adced3cffd65c32d588ac35b09bc158ac96a3b1758aae60dd47a3f20072e9e1724bea4e16d17860a0d3c166f8a4b85ad0ce49eea0555b137ecf4994012fbb5577738e294825f9a61aa064fcffb74369ed54dc89563014a3b1d9668cc854f134fc5e214c0583b52b1d8b5e1c09b4fb75e93a8a6078bb59746ed19b2f2c00132e487530a86966888f364fd79fd44178f85975e3f2cce0f1e1eac8e27de7ac950959e4b75bd3b97a12e7c601253b36c984435d2e78d8c08eaae7f6af6f7a1493e4a3f97237b07a465b970df4e934d3be5338aee6d02dc149588d56eb01135379c9a3e55823189aac3a0f6463514980cc91fd247b14757b9afcc11a441eeac1c73ab923e48a03b7bf0957e2ee7704575290dcb2ee129c3cc3b4252e5af35b4b55c9e83330f77f7c06df290468d57a607919e22a59a7e7a3152160e5d4f9f005df232558b27114864ac2ab34bdbdce95bd18a94011ba2fbd462120497bc24fbebb55c6f42cf4b7f79b51122f7d364d21c2b562d945bb52bd5446f12f8f68ca4e7af099ab99f957ce28dd7fa635f3b047df7c872714affe79036b22de8248d47242e638d9c9a326bc824b80d6ae851df4b873c0b97f53c28c0e3935a3ada7cf2a49be96cb67627ffbf0e9bbaa7b230f2ff5bb5b0596c88563cfafe1aff5b7514b240683b77695d417987d831d241cb2ac8c0649326a630e050275520ecb0e049c96e8ef0d74461ff0182814a802dbd6f4614317e58c369dd08d2cd3b99ec02f275d2d75ffe3da02469b4727faf9d963cbb831682d9331f6d8d1921f9abcb082bdf80a83dca23e775f1b57db8403cb24e80400b5b868958d338e0f634f8b4c7c8744b17802683cc6c3418f9e7192b696e4558fb5d44a6189352d2656f3f6e23d87885231ae66a51da54b24e0fab09659672398319b49ec784f204a1cde182e133bc1cd9e2093eae6bcb710721d8ba8dd8c55b1397c11ec995798abf004fd43f8b8b66d5e3da5567bd0e8dde685bb8d5ac7bf8922a21727fc18c2ef49c91174bd3b594f1ae554e7619182579546ed51e7e435a54bed13ca84e2f4f36224acf11f7b313a2d4d3e70cf8f16772e7d29e6467bc46faabe742a16cab26f8a5a28021ecbddea566c0050ddbaec7f25922b0b1f92fc4fd45f20c7c1c4b22f04a2b41f8dd1245a19c804ee1d4b33344e9172ff83a09c4e66b80561512db85c44c98bb488be2582a3fc05ea5c6f0f2106917a311d954f2f699c9cd6afd5b689072a8ec4c354912f6c2d646f68dd41fac6e38386d98496b65c991b8c70e5e9ef9cd80a46691795c26bda4eb6fd16813ac3decd5b4a26b85da526318f8fac08bdd9168b116887b68a23d4f13de31a49ac2a486160cb33e2c46beb6da8d0ca566e0743ff1444b8033f8008e2f2cf8647a01802bf04dbb71b07398c3a2b833307402d516c50d34cfe59206af229f8b9173dcc0a6f7b65d65dac323003973359a180d855305464c4af339e03fe45e10c326d37ab96e0df5b0d4d32a136b4b5785ffce04272dc452bc427a432507b47b9a545ff33eebd5086140d8890520ba5c21dd2ffadc62dd45e36cb48a3e0ddf0cb9834b715df0b87741b75856abe09399da01d3aa30ab0138dc6eb75710cb13c448d0edf83defff4022fbfbd6bc0e65fd01556c2b1e71c84b012d6240ab80e19b3185e050a67faa0923928f6a85c889fcdbcbd4644e015af40c71442b3412829d189b002e6d22ee276c1484154e46c3f00bfc1a8ba3eb94868543b8fc6986d6a529c1c26ca1425b46c1f102e1472abfb98c90527cf265ccdb1f2d2a3cd3cdd6765d39dff28cec659a08fed0d1092be1d9abd45c621397e1175eeef3aac0da2369e983d6424a84eddc89ff11df22ff465f713483bf1d1ba276e4f5d4c9acf33c89d05a3564cc4c4518ab93b7a8a3b540c64bda72340fa78054f317b26bfe2b10892c750b8a0ffb46908fe06ae1cf241241125a91ff97949537c30ed8d5bf9142036e22b964436ffc580da9cd44534d5e71899f9fd7f31ca7ad50f2bb44009a73f07d2d80630cbd72f4328c7a39640889c94940b31a26f26a461379870aa868d7d0bb8b86cbc510cca0ac41920bb98172a2e27c6c9b795c3a9e42a875e1aed37b4ebe7a99823f74de36b303c385c45284008a3a62e841e7c7572e699ddfe139b293ed0757ba438baf35504a60fb23b69227cdde1b32e1cd969c51732c3a505b0c614e27962fec76a5477110ddb32fbb53ffa8ce7160b7fc1fea4e8a461c42a5dfa466c637100f237939aeedb054eea7fccbedf893507bd4b1f8db23197a080299279948c3c0dbe0b79f0c9c89db48ded8851c5ee1102ea15a5342a644dcdf637245436ea8346816a2fe66651d2019aeb68a408519219bb7af8029641787442dd25466a99c35d268340463fb47d7e43850c8c5fd2e8682164e346348eeda3d6e26df53859b105351cc1bcaac5dca2f7a16cd54c71e8dba9cc1a86a4266afc63d21a4b029911926b80152dcd1b5a5f0e12166bdcedb547d7669e9a3c26b745d4b691092715c3746e7482cfa8ef9d30f0e3ff0d391bc210cb6f2af08042ad375850a6b40eeb1978df5d21ae59e1a22fcebc1c775946f9f4dcbddf9a10d768db8bbbb0be4704fd581c0f79daf3ef700e4882d78fd8b77ec2464b93c9b0f6eab2077b54aa501903b144cf87070f993f85bb9ccfc07b003c7a3eba9a4308a2f69d41e5e2a4748f3ee9d7ce367797999fc509e228c312bc942c7a87d24cb0fde897d3c6871bb7e76523ee0fd3ef53ca9b34dd6865164185364a8785e673442d04335f3d1e90ed53da651607044e32923fcd0ffda2d1af05155f7ce45bfcacd6b54637802af636a309ed450d76ce7c437f6ff529cfdc897971694e80015987e1d26b2ca5382badaa2a7a21b16f5367faaa1646ddb4fc5f212b59883743c4335e962396d8cab5e887a1fb93319aaec236437497188353a5d94ebd68fde778c8453488f4df2970d1dbbeb1f8fb1f169db1edf346898cd579cbc34adbc6e6ff6937415cc52e3c9034096f7a740b1f0464f5f5956ef04723a6bc4db4dc1db6c8f87f34b1490f0ef6cedcb19db2cf58ee6b2ff83c1ba37faa040bd6ef78849d1d8daa86329358871ab2efac037dbe40e4c39a81318b32b04dc10b7361532af8f45629eaf8d0f4de321f8d1be0a5d3227745061e5867cc10f878ea8d22e08e3c3d82e6669d3f09bf106b6cb99894f9ef1a0685be8a20be99d7f063ad9c0aab40bc170b88a74ac3e1943eaafe02b13e5cc141b640f145deeaff69847c6f0a53f659b13f09c6fc6bc40417d94db92f50b8eedf982ad8ed8c656798c3e88789a7a4c835fda9f82feb3566bf9ed21cb6945c6722e742aade424a83d0202d796c665726fd331c0e3482bebadcab1f8b29cb85ec5d02478b696d5be4ca334d194b059f868b51f8c032621755c78591955cceac0536287bc4aa71ac3365fdcfb127f4e1d0a2ed051921c7638f98bc4854bd7237f5196189392b3d875b2b6bb9b24f7dedc5057fd6861c5aa7696385919a4ce8c867375b448d29b2f70b3ff2672751c9329241b7564041ae8b215d75154a5431e227ffe2efdef149b7a29370bf71df2bafff16c64055b6d9a6775acc301ba1eba3f25e5f56a9358a93be14d069aa51689b07e32d9bb882f59cc6be5ca3605050e295c50c13dad5b1ba9d7f2a9241a8ad5022f6aefef1bc213b1a37ac244b9d09dd1639dbd4c2e6866a6adf768335d9ca164090a965f2fa93290136c21349ff10f13e4f0e314acbde6847efa21f06f19a2fc1a88bcc472ea93a15b4398c70d772c9aefd4915598e3f88c56083a027b3caaec92773b88f47888deeabafda68b0fb8fa0dc16e4b850a8c69d3fd61b0e21b266a012dbd8e95143d8403e0ee8589e296f773182fa4e10f379b2964eb69654e9588e51d639705b5128aae0faeda6ac565932a55198d993deb47113e2f6060bf47abbc342809389263ff4dea72511ff3923a8480b6e3e239ba09476df3694a70d198e683ff41443bd3cac5cad5cee0654bcfa29f2b68975c47299d04685202e2486018568313d2a4859bf6138d808fc19103a11317a4b7c8afab34c1695673e1a76d80e87b46a16ae983f27d8d8beb433a5eca450a38af56f8eb7579402c62c625b96a553cd11ae7766004234aa80e137bd5d5885169764a92a45946cbbf458d6149b8a36d364bb6cb894c5ec64bbce7a1f0c06f515565f776ad3f5bad4990a89216eae676fffa26410ec4ad8ecf0fb3c0d81fd50e8e16c5ac3aec4f1d83f95309af8292fb36f0ebd566dacfbd1838879a1ae8df917655872a270ed86719a61c8452c0b2be61ee34ebfc27306cb7cf4f847a198f72ee5455739d11642dd0fa8225c4ebe1c22ab98049d63f03f65bff5bb8849ec0128a536b48029f1021cace55a6ad31c604eb97c9735074f9786c226c8cba30aade5091fbce35a5a83009ffcddc7012d22244cea7011a5787c056574d53a9c5a824d87134c5d3749100546ef51b861eb5f3c14b34d8f938dc48ad3cbcc4f9bb30c208c56fbc2e2731d488371783db27d0fcccaa6c71a8e5c81a2fdab0733e7e0ee829d9861533f1f02007b61cb3f55279bb57f494be0b9a96bfedeec13d9418bae10f67315144539c9b28a272c05a808e02ec49c3ff95538fe655a77d01d9499ceddc5ad2a664cef324bf364c0bb85926887ffef65bfdd406c6379778d134728558850a25c7d9839c48ad89a5e524782c8d59b5a82c0dbe8036607cc8002782a67ce04675a96103de5daa86313409048159da79cf0519eabb3cc3af84e8233fc028e6d480a604e999bcb1ef4aa309a0e12a2f895cb6b10877c34f330ed6d099ad96576cf474eb12478a7598a99a1e3b444fd34341cfacb0c253e9da6f5411ab353d5bf1ad58cdbe9cd368e7f092bbfdd0b207e5347d53df7e506bf1dc7ea5d7ea1829282ce544551018ab7b558e34ad12e11e84ccfd9c9dc8d69fc300b8805efc15fab032b4d9aa3b62cd7ed5648d1009868f7203c0c785d73e3ab76f59ec4f2ac1408a615eae0af49e468e2bd80debc6f47208f9c77ce0402775b810bdc6505f763505ad70bd9f18f2366b73dbcb3dbd3302c4f451aceb561d51066ee314642e3241a7442bd4be97416bdece21afc44dd71df1be38d1be0ef35cebe10638c1f3006e9d73c204c9416c6a448166a748e3622a29a17b064355bebde751a59503e10c06e6599d0de717aba86dd2d7d30a4eb44ca4609b8ec9606cb52965d0380bbe43bf984e263df1b2c3ad810c3923f7d610a07b5ee81d69c798f2fe8b02a04e1e5b8eddc28024599a8fe071e983002b8251deaeac2a2bea03ff71d0a91fc19c29021541fb56d8dc37b7524c25d3398867ff1a58b03d66a03fbbf90ef619360d06a380536a696d9cd4e1672dd2040dab2b22a7ea5cb553ffb724046eadee465133369f34a98d8d7901d412db3393b4d763ab5b64e70df493b75a5ea84da5f62e872d731774510ae68bbf2cf30b9b05c8583e52fc505355840fdd3151dcffbfe785c7f9f3e3c64a9c1573f0df309feaa7c7ccd0e073398d4d395c03d9415e8c5b908cef019858bc434704249c87567761d1c4a8e4edcb5d95cafb7689165ca6afbf0bcee5b8b766c7c7a298d7bf26cdbd9ed846b97580b945ea826579b3f2854c0cabb188974221c4610795bc41fc9c64bc05c3e0d1f478c754434ec7f987e5765e058e7737f27c76ed3326b1d709b41540d37ecd65c4d2a91215a1637aab530c0f83af05173a4a3d9a3ca48867c0708f38efd834fd16480b00079415c3838c6b5b23b09fe964da715eef6145920da7e4abf37e913e373c901b46961d996a26156f83b5c3d8189c7f3a912b4ef91fb61d29ee449851372f84999513d8ecd1048a17e6fdd6cd1e994bb906bb5feeae4e177c419da827a736b3db25e1ce5b60be79ab46d6de3521bc3e3e9f7d859a1fac076f8792c886b882ac7fce1b963d677f5c7b9ba39ba40065b5a8057124bdf7ab154c1de0ae553bd8fb9d92c487600914003f41ca8002750aefbe272fa906af3c00a60fa0c2703638d9cf23a99973f641e9da6fc14b70e39dba4f349644ec7f13f8d5e3709acdd675f5c5f581cf1b718a7c79b8f96780aa8a452252e172ad3d27ae5e659fe2ae6695a4224d7b7dc6d1c4b8932ea4698b44923ca216c5088187fdc8053a5dcc34732fd364c00e603437c16670b0cdb4d3aaa83cd827047f62be3743a239a6f67c3c74d1c9ae4913544710c7e76dddfd0e1dfac6e66b153abe54eca80af2b210d0075d682113a4ba1b2ec8bf7e2f005c2e9d3531888c942cb59b966e454624fec71403053465580ffaf81633a128d6fb4c0ed9b2251b029d22e7a7acaa754706e6eb73ff5c5e955bfdc06a2fdfff7823b48c0a890e378ee45462b64247bfd28e2957bfb236fc138a219c20f84eb170d689826de5f3ebfe7bcab8195fda713dd0ff23e3b3d22192c151c168c3e69d9facf8f9c5c53716672ceee4665068627558996d42a456c12674a21140965bd53f25ab7822c902dc3ff3429c01667c9c531d12b36cd545d97caf12c71959724816cea94ac2e6ab8a7624da2cf05b6e567f81da4a4adf4ba4c522dac077933e3c92b932b1d35b20f7592feef878aa9ed1a009bc7a25f3a2236068cc36543b1410bba4d4f558f8ac5583127f983e43d05741c29dc679fd046c17e84a5b3941a643130388f9cef5825be21b6873de2e42781cfa821a69a586404db9915349738f4bf3a6d7cc0e8169bd9182739ee2567b4393f22935ff26fc55c90488d24c1ffc9e71c45e0f127e4c3f1da98e06013c2073549ce5fac9c199092e1a7566af29c586019ffde31dde5c6cab7bb2d794e098b7979a10eed4512394ecee406d8e4973af855fca0c019aa698aaee9cbf63591b55d2691d224dd21236a63505c1a55d9248e70e25d46e90827af94a87472bc635fa635832fbe167cbe16e48b52393a7f38193f935d98457fd4425c91dddaee3de1af402895c543e14a77d0b6a3210bbe9dafa8b4e95f14c3358ef1ecb4a82f082faf6d4c2d0a3146e72b97c0dd5e21d57dbf9acd98f6c219880096bd3ce1c8ad6f82a8c50d4442ce3e261cb5d6feddfb5092bb0a57960af248f46bdaf6ff36215c9b2e49c26c436ae399ebba51a7aa892372121574d10bfa387df42ed143ee172cb975c265227aef6de15b121716400a84882d0f7f064f7e8afb622e8e1a8e3e91a206493e42b85f6ed4a10e281d947790ef69c8424ac33d906162ef17c5090c433e75275c48c1963b57ee9e5769ca60ed734259595dc30f26f3c057f0bafc7d069238073d0231f18330a5d84b591f1b97256280a4d60d689280156ca583d0fca4fe0a47d57a67503a5f2476412cb46d3889e22cf2627b028d0a634a9876fb4eecb7d1dcb322015ccc569ea9dd079be68ef6f0ba561aa6c6b1ed9f4d161e3de76d07c9d42d6c772b9216b55b6fc0e17652b9a987c139362a90fdc978921008f03ce6b8c65c21f1f81b0211d5f6e2ecc72251924a5603fe1962decc0a96de6c6c3b74619128408a4ad094fe2e3ab8a8c9ab65562324c38bf09216fffa3fc36829222acfedc85fef317402673e3f72344871e340dde9ebb37ed52bdc6c594311030ce4b5a181895ce5b2096cd49c0e0fe5f8b5523ba7b86b5b7dd461db355d6f0b6270f20db19d689ed85f80443f57c7e0d132b185f6d807ef568d418313e28c9a1773b7524ddd2914c4bca673db8e5d7e40c38079f56e5aa4090992865efe2419e314c10b815fdde05e11fd8780b371985e6dee3b4b8769c67095d5bfe1d5ebbcb5f5fc8a3b1edf83380a258355032e9aa77705dbb9d37a6a9b16d2ff00e8e31828e84605f3df7a0aae67d1e0dff773859649ed61620bdbc69f499652cd2a955ce7a6f02b0b21bff661bb52043efae12828a0af312b0b28aef0bf9eab53c42428acf0a5cdcd66d95b2d60ec3dfac2d31257591c0c9c6a162294aba6f8539a069e2f5e55df2642ce45fe8fccceee5f876211bb2ab5585d5bd7e296877554640dfcc94be1ad911a1f20a9582c20b905141f365ca15d120239b49c2aabc30ac1fed4d3018f9d05ee99b1694d2a404e58b4847efe9c28aba5c0fc5dc751ebdd54c9b0bb24e3c7789c590891b96336b75d433966dc84df22c6284a5f3fdcfde5737120b462ae1cbec359ab196611ccfbd74b9a34fa021529e6395f652860eb65a03306978d3c1a758c5c4b55a1f421cb52ce32145a66f831a1fab16652cd05d71d1b60cc48fc56ca352d7be13413aa5d66572da78de879576b792552c2870e781638163e94bd7ef2d29bd5be99627ccaa901a5c73da2df38939f9d060881e291f51715a397a6adf7f11b7056cc6e97790c5c81996521cc7828e0e328494139364c908ce2a1de21c600bc787f0135031d7cf578269aa06ff71965cedb5ce72f13e646db9bbd31d9eba104eaf6da2c4122015fce57a3bf275e1bbc07d65baf01341015a10961ce022d141226091d9541c46f344828387ca91a10fd62a1a631a5c6c16d2e1cf9498a9ab784c2b2a00ba65988c9ec70090974f61289ec4f3ccb1c1ce3ce4794a885916ec40ecc26f7620dd2da2f94bfe14b0efdba3d9afd7a4be9ea30c8e81889cf0c6efff7b2135790fe2d1517a18c77fe69c106104b346db70978fd93dc3723ae817a809b9bd6b0f9f9accfead43d9e7d8869224cba6902702a6839c45ed4b0c033e956061bc74546580dc30dd0d43cf750056d4a36a59392390087e5ae356a4c56e6d2ee593ef84ca9205139f9dcb9dd558f2bb22124c2225b51af1219f0e31372dbdcadf154e57601cb53b3412253548b9978bb04df37b733337d5f3ecd9b121054d93a1d2cc11555df983d3050db51abd376a5a267a4987ed2a1fdd63698ece07ff0dd4622db2b417f812be6c16692842781dd48f8b3faf0e18ede230503e46e8feedd34e560212a859f463a254475c4b36f5e27785fcb6f77bd01c4869b340faf7f1eb78998b27f92ed24287bfa074755a4c663766d5d5e48eba3b7186916abe1a87058a98af1c64432399f1921c5f705d1f9f89e862c4ca9fb719f7fe05f4f567523089d34e6f7bf8a2ab3b9c659ea70fa5d970bc846a20e07c1df5eb52ed29aef0ba1e8d17eb680e7fffefc77d276827617867df546aa8f81fd772f3b19d4b96c100780af6e274cc830dbc5927e567a06a93cfb632355f78fd9def1f87138da218aeac2a30f7508a762f287917313035c2366e39667dc7488e6e2e8dd7ce8bf77a7ae4d2377e525767ccc9c7894b7ebe1e4328a7427350c7640a19bc878ea209dc931458fb8ba1cdf0c5a68c2e079468629e65723bf459eb9905f7beef75a0d39c46f20b39de6bdd9ef230f943578f5b44ab31a929423f4ed207773f0ba0dcb8b83c0b83ebf70dc568d614aef958c4abc44482035e290b443a762c538f7e088e842bfd90f474b7dd25fc3dc69bb02f7ffea7736059de5442f78857155100784c5c23ce47d8fa8edd55f676b7bad7c12fb593db252b808004a97193df8664043333e6c0f9b43d2a38fd2641b20c6d0db59b6b81ae82f01a953eb8311a0bf12e6bfcb150d86b5be7aaedb5f9f74912a27f1962da2dc9a078031be9875d8cc806bf8221bcad869e9a0a290f8006d7bc241c547da0285211fe1dbd2d420f694ef2684c15b7c0ae98ba643b0d11b30f71a90341e0ad6b2a2466870976f33b6bacbc06842e6b0d44053c55dcc5cc042fdd16dfcd3640ea2cc12bfec1e9febb39a66d3bdd7cba015036b47d2a4da8f8d2126229a3b3624245656e78334ba852ad78a22ad15eac95e903a5028d7d7f6c9c5fe5ab12747d0d44fc9ca695464ec28b8107e51d0fb28d83deda2723933666266b6f93e27de136425d7daaee237c7de2ffedb479439c3274d7f4e960b01f531151b3ae45c2f95cc0923f884cb52ddcab625059d894ddbb5d8053f0f43f0837b858a6711fe5eccc86916a6cbff717ef1c66c99df3add4c3a6ee681878667ae3d6341cf5cfc10778687d3123e982bce590cb6b87ce40019de038d89107b796860a78698e57b3e5c472838b5b88add55da0ae2162a1956c84da5d51351924c8c2403dd4fe6a3d7e1db61026610d2f06770e507570cf2728b91b9b400f4b2713d3202cdd860287e1b83207ca09ab9f633a2fe89db95411b7019e22f1d546cf50d18e694c5b982bfb67d9528734538435deac1c24d35d32ad60ef897aee1bb14dbbf2fa1e3192c24bdd84a2a7b746aa8447f85d488ccf2a718952c66e0b6b334facdf1114cf20308e48b1dae7530f57d0a0a4f862a08aa23f52cd733389d6df4f961f521150ddb7c794e2e1b0231f7ca2d954b82d4c5b8f67fcb5efb5bfa3172d2275c973e638bdd4f6a7f56469205bfa0051a25cbce245e7873aead41aec9eee9a4d791175de0204cccf2473c02ff599e54294863bca6928c9b9bf74ab69f87b835e606ae5f1a62f6494dfa1686a5307ef3e91af7d5c4332677ff92f4b4d38923c7406f25c8a6a9b65246566043ae625e21d21dfacd63784db6afa0afa81e5ba1e3ac2fdbddfe3ee3b60c459749327dc861888a4b30c6af34c9706464c0ba9309b725217b3d44e108cedb41ded389f86c4707fa78e55a1a9a66bbb971456c66e020c22f0a6f16d3cb5659e0c6504a62420cf177d4de7db640adda0e3deeccc0a905062bd6fc82a4b7d8d3685817cabfdd46fe3b5fac35b91701fdf0eabd38de93023851d2750c8bae9f5fd9bbfe29127a62fbee32d984104a8c6ebd8ee1c3d9d7244d0ca8020b883cfb574a14e8321c19eaa8be6ad880d21c5dce8a09af866234851adad04c8cd62b6d7088dbd7f620d9108940c8fce06940fcf7b95cf60455701c46f8671d7749ccc50d6fdefafa902cc5ab66779720e47a34124bf5f122a7c0335ef6b15f451f7f96dfd58dcd9a483f514579bd642adf09a47ae048271217e34468ad866b07199c9677b0b0ef2d402078f7c6e440feec40137c684c0d015f93e51d77af5d3f1e63d67ba09c5359a49aa84bf5bb482a7bbe8a1e146a3b689eaea61da6368b9f786e676ac35bebb65ce259152fb348aaef63d24641000714464a741767211ce77ee5781b0b5466189557964e2d06d9e84fea178581a2aba00605545ffbb8e25164fdfb520b88f798677998c1170c965688322b7ce94383f714c53491bf12d846f5dc96b7e3e17a97fa9d009f39dfcf8ef91d19aa5e1d63fd9458a0eeb4a653c41a530080585e6db9231658b4ace0b9c89a81abf076dd9c55e744fad3a58d41a0655da41eaae01e9b266fd3943000899b4ee04b68df3b696f542293fe794ca1ba59614f68a9c413d05d24aa1892a39a873c9d637ee3bac922c25f9aa58a8d88d88b75b882c790006320d2bd734f00f301301a92e766d45c9961de422ea3a721c1d6b32dc2cbc2b76f35d97eb9f56995b1cc2e6c3d797b2230dcadea288417ab7bba1d52548bc2c84ec1a98ce13cb8769d31d2d258a565f9bdefbe385a2b69d36ecc3cb5458cb208ae3d00c28f1209b5eb9f5733ecfb6808b5c48d3f982fd171716d589bc30d182c270927e94ba7403b884b25a7c303c852cdc3e859a24f1b9a0091d2aa9be3d06d21e85a87ff2ad3f6de3186936b7c54f3a408a393135e9a5e4ef5d8905a9a780d62e83d95ee3578ddf6511cf57b164767475dad68f9506f92fd72edb06f921ff109d69d4d9d74032c138520ff3f988d48fd0435b6532d26428d0df0c24ee3b1f29432b3703ec9f3e56931e0ea19b9680615cf1700dbd747175a4c3e4ff67eeb6ab0c4877743b33f2d2ccb847bb029bf4289a8ad589345d0bbc955e12f6c1aab60c8b9d2607783660c5ef3dccfbd4a7d3dcb0c54c0104e66ffbcbad269088e989f878d371a966bb4650275bada32fb18ca7cc19ab12b97556864302ad3812d86593a8e1ca443ff899a0ed9a4f7dbac9187ba3fffa433d72df358b9db47915f2d76daecb53073a0b1c4762412b154c6b2f32489038a0837ab09c827ffb4983da34dad30d5bbaf3c4cd4855b0d267a669587a8e316a16de5f90a737aaf7f5fdd51aaa11d671fb68f80399f037c5839f30fdf085816a199ed8f7ddb1d3bc11848e18ccb2d68e5f9130bac26248c12b3774f39ffea3538f61937a89f6dcfde8c6004d9c09eae79ffbac606058da1bac5a885337d9a224e14ec8bd98ceae27dd767e5a4699c19e739fc5703e922a4188b154e5499641a9494bbf1fcf1d9592dc2379b240a3274db317de085bd73b03d6529e5cacb72523b5c711f5bee2b6f6a24f3553fe983561c7cab139bf1498dfdcf93a665c8811a8b25924b00f2eb56bf1c51ede363bcee0dc4cc4510cced9e2894b158b9750b17783527077722ca1f0904b92388db4eb8cdc72b5adca33f85077fc82fe96b09465392e14f8ecccbabbe95170ec0dbeb516552191b4be286d2a72955a79ecdaff97e7997837b7f1b48bc0a3e50bf9c31bafc5b3d3f114cfb58682f83ba6f5f58b2f68a8bad0b1eca578944f5b83614f1d1cbbd596b596f382771019cd0a7b192e66f3718a110664754ff1713c2ed9ec09e88e32b31dc05cb9e777bb20c36d633c4b25be31805e887ff884747f6ca73f00d47600128c34ab7a947f7be5d866f374f85322372d7edf8464e5fe6ec608cdba5c14c3825de58a1d951d4b57e651ffd9d43cd097c0091fc62ae5c3717cf7492c19d5a9f3813c089c5f6b4ed270b8e0f644b2c533fa863b385b7bdd091b20b456c035a39660b99bc5c752db9899b4db9bd67ba73555c28723d35ae7a2872454cfaa168d6ea4a13410f655c955d772bbb111988c0378def2fd35824be7d707f9d2cabb778b005ef966e3b614dcb59840a6d174344fa8eb9ebfe31428ffc3f42ae01f7e4c7829091e0b1f2674a89e662a2aa102ad4f6a0f88b9d82c8ae7b6c853d52d74138aca469b4d260ba6178b8de7bacdb549ca6be965b0c67e9d63ac274834c11574ce68b19fd59c02cc6f219d00cc20a994349530a837d93832f8b063340325da481e4d5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
