<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77fe435acb8afa1eb000440471a4ea923fc787ebd1454884a3806db69699f7394d8b0bbf4db0f476be608a228d51c34a28e52922615c07ae848d6fb943c79de7ef8277a91fa9fe6c3c7da3b9d993d1a055fb2d9a164b6568e706f3b0359ef7220415f325053d47be5978666edace738b0f1b8d7c414ca284f4e1567215c029caf4dce6e5067223455479d297c42e46c50d3ccc9bcd1bb4e596eef2ca04192665d103bec677e181ba6344b559622a13d6afe4db2ee4e8ed3d8e93590b61bba90feb5e9d08de620ed84c6ebc83ddfeaa8919e1dc7ee3e7ad69c571eee0c7225c9ba7184255539d6d19217d3e1a9d2dbddf07ee4df6439e25bb37034bd5224dbade7c1c0a626315c5857a75b2424699ee922b5134d6a196492d5f5928aab9c75875010383a55c1eeca0684a127888bd1723aa2b19bab87e16f2dcfe315cc98981f5dd214b75726831cf2096102c3a97223cd7299b5062bbf965e9a9fcda0a7c0ef55f93fba9faa6e040d1e0d80113516081ae3d00701503c84f780d89c01d1ce32f917c684f1901c142d97f64465cfb625b609f80ab55c3481c85e5f92da807e38661db09cc65965c4263c11be7a1d77c32954a73f3d6669a6bd8401d575d029ee0e758cc9fee69e2c49e08d7e536b923c7f27c114adf38b451ac722b3352ca4e3cef79871110127b511e94aad643845d181a05d85c65667ce49cae4ae2ecb6adfa3097094bd2c8de2450f8fc333950245ca287dd9e34eabb604162ee7146fe78b89b186e6c7ed73dc4ad4cdb625f28838725a5d986a1f90e089f513d7e810fcbe9b6f95912b2339359207cd135b4f16896fe997cafc3572643e49418f740ff5d61195fc3a72c9838e3f463829f767ab5f3da1b534b7342610ab14b1824182fc8569b8e670bc021ca4d88ac5a1dd4319fd312d3389d1d315ace52c1dd66ab99c3ff87a8c5fb289c9241128472f0e4b0b9c947c89a296bf236deafccec94b105d709228482820162928fea3926df00ddf7d852c61685b57498e39001d3e52863a5698ae7bd04b5e46a0f7b8538c6f759634ca4ddef564248bf45e44281c58a5b6024493ca6a1efeb241097541151baf971802ae3a1e8aa9069bd895071bcfc5b7582e1c94a8eec35241cc2ba828f3a52a9c9d9f5813a563014da0382f8b32679a75534c7636e033eb829dc35ce7169a09ab9fc88fa36448e37ba11898af0d577b89fef4f1e3f6996eb82e8736f2a74708df74dc181febf8718aeddb668482c92330a319b7161811d3c4c94ca562be609af298e1fde3faec762be717c2e588f4f7581e791a846317b33883ee9593eb7de96f1c7fd6b7cbace75aaf26a89228a8a555f314190a79dab3b2b14752d81a4f508b9251407a4b343c3918230697a753655bcbec14230436dedfadd3ad6fc4f3aa67036d4049ba7377b9f0bdbd0244c3d6ca35292f088a350be9b2ded0f7ac33d97fdf89c7e683a8434e869b6aa50a3a6a0a29f9843953421e108bc87b56004ec5a86ea5b1e82ad6b7b96e957be9357b5f1adff229f3f5b17fb4102cd0ddc5e8587deb415f4f179208be47a189b87c499a4435c7bcd446f532819c5970a0757a1e3e58ea0e3f8d90f8c78940f017a9e15821ed6266d4b27fd8177d8d185b0b219c9bd754deac2651a9b79d7516e812caf2cf70757a9a35351c4feb890a5b4653c53e857e36ac4de106c5392ed607bfdf6a05638953ab000630b6133af95d5746cbaf41dec1eeaacc1d3bbaf6516e864092148a5c093732125ef569b3415ecb6919defc078208ba3e27abb4f36851fea34716232e4031cac42a7a7c95af6e0ef39fbeacd072f23ee8e8eccf4843d30a80d8fa18df23f39c9f38867436d1c2d6a342df292a8b1d796fb374164d89ce4486b2892722fa5a07446c15a6765a2f6877ef328c8daec8a30d1a693fc44bef773a3a2bfa72cacd2fc7172016119d3fe5a49c7eea6460fba379ba9ef961fe04d6ba048ebae4a66f45b76338443898e818aa12832b674801d59878eddb43b7b1b701fd451bd3ca5ac4d0e06302458e9c734112b5db8f5fbe2d1b00ea369b624ff0666e0579fdf889d4ce8b86ad5da26de74fb7709f52d3ef22468257db1b010aadea29a2d31736c06d5ce71dca5c3ccb1bb3074c99e974c9adc58545aa6347f8bfbfb72dcfe45afcd1c724fb35f3c6037fa1d25f40c0f37083d0031de814e4c1a38f8a7140b10bc145c19385075dbc9859a2ca77424cb5287e79166b32c23a015210e3ee8f969e888280ac90dc9f8214866a02cfee9f2a5958d89323639bcc9e55b0068c6780d30522f0b414abb675562d76a63e9d9eb896c26d3dd8dcb015d578218e99eb692ac547074a4ce11515bb3eb885b18e7420dce931f5a7c7e5457e9856a763bd08990ab756f1dc62160ed4584e359711f8eb1e7109509500648657bac3e50d6856610ef3d96ce48db5721ae9e92041fed8a76ea7bf3464d1a5fa729635955846bb77f1aec3ab94e5da00a3f610fd0e6db26e3e09ea94c25e3f12039043bb904e6cd81aa36c5238dc0b5574c2fecd0913edca559948ceaeac942371639f6b262c15a754ce91caa0910d6be05d105ffa7110a877b44ff615e8615d4fa9045ea2493250812c9893caa099530c90a3d7e926b5f60979d79bebdb91d56e9fd26f4eebf64d2d414bdc4cb78af8fcc9688a035a5e4eab3a0d9ff9f67fd908225712e21d8d7caddd93a41c2cd5fe0df85e889b48a74307fc1bbcbdafd220d25ce937cab2935c7ed984bebda8f546fec56950c2d80339f70a07964504d0f4bfccafd2e2939b7b9a306984df58abc79f2089fbb94e4aabb0bccdd8b9426b8a8451808856e434bc891699ddfdf02b067231c2f875a70fa6543c3b4f3d0142e894413bd2a1ccc4b86da275f20e9b9ecabd7bf4b9e4cff57f5fb1144174ba30cb49ab66a170ded29342224035f2dd152f3cc34f2e2de7f0830ce679179d94913d25b3563b98fabf439a6d4149b35ca056b175bd752aa154025a7f1805d46c3588bf512adf66776245a0b8e6fefd8c7332e457a1de8b0c9634d6aa2c328c4e5682dea791ed7a6d64b07d319b9bb6f0a6909cac976e399d31a4f43002d2667cf0badb5d7eebf2450ec2a718a686f90d708739b75c84f565e0c3891d68d570d8a5192d921538402f5d9a28e64e244407328bfce0cdd2941ecaca4982a7721b43dbb1616190c89140024b5eccc31af8c809551493ad2454527d17ab568510ea3b4818ba0bdfb0d234277dd22900378dd25658127626d60c9946681a39f3263deccad60f3d303bb29da3fd054d35d19d24e9616f19c27ee19b1d32db15bccbf54a61d850dab03697bada597932b2d003ae7bffcb1501627f229fa905bafee2b5562850641180e1b9250cde33bd8d2ba20a08e711e44210941dece5758d86b30f12aa79d01f952e79ff3c3b77a0714a8ccf2f35445197c070b4893ae04b4b1eb6622288640a868bbd410c9f0fb3e068af2fc6f9d93bd97d9c00777139b9cdf0eb02359417e1cecc58162bb7214635a18e91633f7255e6506ac3a51bb6d840169603ffb6c1e00f308ea984729eca0910badc9c3698c5ee9abccf05ac272cf6f33752ab6e169bed0c07ce625478beb2ff683e2d29889b21f719439bd236a5ff7f5ccd71a091ef9011470b105246074c80d22a54cf05061055fe82b4f1118caf832c43a803b662ae0d18ee9f274b301f7c4e8439317b4596e1d45b61514a231b013755bdd3afdce71134241796189838c59650cce18fbea0a549bb33dd98d80cdee60ba221807c40a1bcb7e9cfb047327866fa48be317b99822c9d1357069353ea019ab4cf60cef55b0f3c9307b4ffddb44025190f0507f7306f17862d33fe5f6fb4df7a150a00173a1215fdd7bd0279cd00221f4d55dae0e73d58b66d40e8fc5f838bb028ce00d50af58e7ce4a293a89db9fef1e9964187217dafeae8a2a49e055a301249a25a620d70a143a59b332f17648e48b6da383cbbca993f307dd9d9a9c7d91a5934cc3b9811740dfb9dd7b6c342dc66d8ce9aaece8d387c39a0ca0e052115569623bb5989c95b1e91414b4174716a84a37120d847e4dfc1920452a884546919f1f9950e3b3b0ecbe9b717f0b9e533bbcb9fdb13b1ab2f277a9372e129d14dfdca2630471b4abfe295e09701520ba883609c618472f17705e3d9ea60a24cfd495f8f3bc8b1aea7d630b67554822359d2787d379156227a787617b60870ce193d1463cc07f19e7772c0d113d9835203c9ee1f337f98c936d76047f33cd9e0bb6e58bdf614c6862b1a66d1c3f32c43c316772201014adf39570ed3783ec9c4443e07d779146ad9a406ed0711261f024abfe2effdd6523914fd5bb5033d0fa3566591c2f2f4a246f9eecf485a71a42566759e732f8dab483ffdbc34816f2073ec3a82d35d538eb788ee9e09bea27ddbd6c107f66ad1a538fbfefc29cebe6688cc99ade2301b54bd324990ae65c7ddfddaad244cb9f6ec7631f4cc49f35142553619f089a0524cb226ea562f7ed9a9587764122763d69cc83291b3407628a83c95b45984d8abb28b5462dca2c1eb7b2d7ceef83ba8fafd4ea7dee152f2eee626ed407410a923ca09ea6c8628a5f84cf9e5fa0965f0b7465f0350f2a2cea316baa779a4d4ff37cb1c92568b7e8074951321100485cb2576128b569afbae3127c3faa2697578691fb443c29ef82698fb94f10426d1d63c626d12a8a27984396bb561d4208330f992e46f39132c2638203b0eb1ef41508d63a2ea87073b34dd1a0ed6f5777c509d19df6857e4acc1445b070285dc29073ad1281962b0ea652d8cd0e6dd5db11c929bf53f1a799b6a1629061ba467734e2922096038837a509afafb3b3b475c8e50c0873ca35e0d998aca8fb8453ebacafde6298eebe27c8a2dbc892373e84a4a61c3a2a4800e258421a8713dbb5e2161ab685c615d168fd5cc6c793374115813920ad285df033fa396affc65722b89fb1b4253de7007ca4e2c0a93fc88a1414f9eb9155381e7af5eb0b6dbe45882494b6b85af624cd38f53f738eb35530e43b1fb7510aca6e98fe3fecc0fc1f3e05b75e862ce66868cf9b35d458255388d40525fce17d31a20ec08800e39084eb063a4bd4850b98b29937f56cebe8e8ffb7901b9498a80ee549416a6e1b5fc64d5e5fd763c7a92aac072ddc5bd777e7ad153751989285ccdb7a428b9e4204c6dae22ddd2161a16eef85ad3c5a4a4b1e05b818c56daae77fd6cde639dc2333fc403909eda6a8a7b3ce67a55c559c1531f4e71a336cd21ded3826f0df09c58c44f7848535bc22eca1f0ce581e0ba484338df4ab01119937107a1a7c98e6fcd09f92020399692178cf7aab6cf40b4c9504a72179b06aab39a6180737824ef3ca3ffb36b84a76a4e3f959f97870a402aac5ca5774d25da8cca709327c7821cab91bf35345d3c50242aa4e5768d5c63fda1719afddeef9a70b06240df0e46eb290df52308cd42e5104596ed34d8a9ed6c50b756a93f12a5135ab5bb6dfefe41dad3ff87aaebffffd2761782e5dd9a43bb2fd4d056ffc454cfc253f9f924032ea4a0c233f9aab07472ee5e5178718bd35d1593ec53c97df5afdf868402ccf71855fa1fbd12a90125cc34de6aa6e05c6554b362ff19bd6bc521ce5fd72fd6539540c4110bdd9679070f0a47d44d665711c63acc4dd0a33fb8a8e952e4b86ada30d75b8ff4511952a3db7041743f89b67176a266b07f9e3f7321bfb08908e94b9ef16ad71c3e6e7daeffc2c794f3b9ee51894b8282dd7f35d7bddce147b4996dfa45b9a5a793ed0829a1e6e6f61b89c4f1e1417a561aa7b3dc083b44a6bfa32000cfead0b61b48e1f0021f992adb49df9b9a82b8bae7ee28ca15f9e26b2b85d92b88b9407c371a2cf6e11fef371be905a1a214099b78e70043fa2d7a734479f1109dcb10c50f46aac7619e941d6001e504ca23ea065b34b830200ec4cf3cfcfee8ce0d2f7c44c8843f565d72d74cd39c49d5817cc905b8888aba14af75126cadc12c95ac653cc50ace2ea4e18ed3675d5cc1d8611471aa9f97d433a96fa000c19a8d12bc615e803cf0fc6dd1fae81290d420d58d943ac997c89b52f77ce3321978a2cfda7fc4c72cac5098578f723a8c414239734569feae35e6a8358374c34455e45e9a3c8984de460b6b2d0dcd22eac4c9dbf047a5a5075c2901bb88536317ba01252852e10cbf62027ad58c92bdbc3ea9e3a812d9e19d0372b110af953432976a08ff27a5d2b4951e2c525a5cf852d75541f2f9f82a964589f4f2d6007b21103fb7c1d25d1a7844796e792865bbb16fcf99267c70dc6cc59e837796ec1e5afe5e3438f3e3674548bc880ce180535ee03ab94c0e356fcfcf11c93a91a8346a4e85b0a349768c754d6757938fdc16414e187a498923ca1ce03fc730042168a2510c6332aa9d5d8e643ee5085b400d0f0a2880a7433af96cf1ece5bfffa90cf72b1a762ba14d91514edfe56a708b670c5e772b6dd92afb715e0fa55fdee3201e28369d6c2c0442a3c8e4d820e66ead5e601fdb85e27372584f3aa051834e9735c88ef1d7e69842d01a75183722d30d184f8e717b8661b8299c6095869acafbdd7b2d446202f2c3f4fd7249f27c9449070a45b80772f1b14b5a739a839ecb52f4db7e7d51f0a1cd08ef04c795a1dfc778c5fdccb54d8d95ae9a40232c2bcc271655efe69a44f8d7ef4601ee8aae06c4bbe74de2835d1334c82cab325469a919428eefc2da772d41092ecea7d0661dfbd77fd57c89cc3d620ef00eddbeddeefa3987398e3be9177a9d8002e854abc998ca21d71e04ab8586178796cabc27a47b26597a7cee2cb14328d1316dc8977eaeb944eb24be4cc42498faba2293d1ed09bb6cd9b63c1bc595f24c110bfb06e077c410afb7b3170708b7468ca0ad548e929616b7c68f83c26bf856ff87b7facdc839e041f4a802c7b21225c3fb7b66fcc01323f47de9771378cd2a7745601e1301248dfac15c87c264d7700a7905702a916fe6a77d1e1284f2959f46e861af70e03d1cbf8ff8668ce3fbcf633d1e82c113da24dcea96564dc73fe46098c321743eb64e74d135ba4cbba3042c2b19963f2718e4fa9a6a10ec1e8012a4067e49907be820111a91e7bd606127d1fe43bb314e3ecc46d1dafdf3750389134cdc5a2a9e59e5eab1c22b3b7eaafceee6c1fb08f218019b04f3e564092dfc8f0a29c17fda2963985b2eb55cdb8f92de33c833b3e8b8f24dd25c01ffeae4a97f4df02a22515331b77ee0e9857140075be256704ea87675b3f3de6a3a0c9dd481ba51c33920b68857ad87187f9c695bc764148c331d39d2a1f39702e4fb79cb2d102794436ae561e9206a7bf8947a17c39508a43b64e18221fbaade8c05da0b0b519d6106e7858b3396be3fea8070c119bacfc6650fca846b0299c48863b07658189c573e934d6307d1f0fb6944f78cdf282d104f4649c8ab22163fb1c55ecad2a6eb9047d538fbf660af4805a343719b23e206a40d4139ee214363eb57cab1e1d3e1dea7a5e4639db8988d6b24ff924bf0895c6c93fe6dc9972821d810599db3b811a1384e7a02b28fc91a44d49357d34eb8478a89ea68299019632b342cabceaa950eacc7fa526949485a7aa2101214483d17e5d00f8dbd8282df5e0adf1c9e4d247c12176cf9ae1f5128352937b97dab937a89520f9b3dd59de2e68075215c5a440ff5904596f5f77d968f2b590c0db8f0619a5051fddb8ebb0cd45491d1a157c2c3376177d7840e96ec872b5cc7beac45465cb86574b2aabbdedc1ac1a02f8ea951cc266d2fa8d69219b16d129ca28908bf2b7eabc34c508dda3576dd56a14abfad3e6d80decdd08dea059eb08efd71176d0694d37ececd84cddcb1278c49a7f0ce4bf634e9684c0972aacac2b0679cb5931591846bce8e7fc7152d8db81a8fa516a668c7d1d042b1ea5ac919ee6b01a10f1a0d13daab3784fe0e40436a587cf45b5f15003a3c764840d887f6063615c4baa4be368b0f66c9082d536defec2a81e9cc64bc89abe2652b5e3cd8b87092412f00dc954073b2d3eef91a4bd0050374ed665688c27f5b87101357a476f6d04ea2dd62bbdb7e58673fcec7f898bdbc6bd0823fc1fb8f0af85c9543cf644f3ac05f5c0cd6ee01c6f04db058c47a9c5474ef2f4227d4a2e41454d6dd81d923531f69b7af192cf538b7fc3dc05748044d82234ce1db9c027ed3fe6a15823809e4b6b6a6df19b4752d4bce2e6bdcee2fc26e7f6e1dd6d7985f926d43b6fed25391e44b2fbddb299cae3fcd72312492c779a3ce9e52ec42a3b6fe06743cf332aaf1ed2917ffe63c63963435721e1062548f1e9878d11721704d1468ba9ab86d1f9ab069719c5104d8a44cf5c29c39d97d3009017187f9168c7562feabbdcb980ceaa51fa7cea9a8543729c80be9d0e5c2cf3468dde70709da2c6119aabf7e36699f723b50e9d2f723a43185c417e5c7149ce77271f833195a82f4749e2fdcaeff2c357add304163b4508970e1db82de7505bd46b2131425a7ed51ffa25edc6063c2e1160b3fef2535ac7ac6d97a2231596ba4a25c7400bb848471016e37c938aa5d9410fd2024cd80a723e2520befa9d9bdd90f47294f84736dc9f2dea0aa7edf2ef757a9533e144dc805c1fef9dcc871730756940914d9b65358a869e404f71e2a044edab4565b284fbdcc2bc12612c34851b8cc96f8961e1d229864f42446d7a2a27a8b761bf39ab0d40fef4e2371f4f7ac4fdc3b79cf644cfc945560541641be4a47300e1d0edb6bcc71a1099e7f4a8a37f9c2350ec6ca2773c9ca30d90019efd7e9a6202ec24758caf8f6b0f36ce37a3746214d5058f513c677ce80702f85157e99444165c2286058a09f891344200c4c5fc1bab0e0f39e7cad617f5c7b0318fe2d627ff62e6e5b717f1fcf27875d6974a0ccb2a6868584998c6eeea94b2d34a148ae45620af78c3eae5d96fb70e8f91f68fb176f02daa4016e67ffa72eab9d4cef2e9396e87c858debd17f274a90224bcb51274d1c27b596cd88bd79d9476426cca3936fbbb049e676538ef52b436a923c00cea71a43b18e886f29f51bd86244c8faa5490f76b73790d45265730654dc2cde83a6abac4983f67cfaae471012803e18bf03a069c6e04def020cb4b86ab1e38a341da9a2aa9fcd34c107bcf21b4c43464e0fa4714be131183318783f1ab8cf59b14a5b449f2953d80fcf1b52e74dfedaedf5a331bead7dfce9017f42d6bb954ec01ce80da1faa3a682f8686219610d750a1e12b2e9a65da7b9df89b5ae487758390b419013b2746c42abce7276951b23b638b975533be0da1a62c105ddeaecdff8775ca1594d08ed18469969774b5c7f8ff5ba5a2486bc6a3825041efda622b81642d67a77c65f57162e9f213db4c3ab1372bbd4dcd94680c5e297643426ada1ae1a42526bdef16f99dc7a785ece0ccc0f6f573db0dde37a47d8eb77aae8b17605cb0dbb3d6572dc0650485e424a266882ac51360897568e7cb352bdd95f10371428c6c8587ce480ca0ebbf850936e30d29a5ae64c85d092c36c0c4812b533918bc8b87065a2854892f7367a6f1cd5af6e369d8dcce66c9c5cf6827b3afae9d4fb04b734f0c35527110f310fcf122747c71c4784421e2604ad3d79a51de9a188927341f43ee4871cf31f5982c87b50bad0f320e9085dc4edf40f48ce1521ec550ca790b89351ba0483dbe0480dd5ff546e238798a8bc2f901bd0c790fd8061511220b498d84bc7c9b236bbbec3e1bf6431de8c28c939e5b59b0cc771b0801fbac39fe8961189952b4c29b9f4e88080adb098f4601c940890bd9687688014c8a17ad5e725e721fc72537b191ef3df72bbbd6abd8df6eb8273f19698a428bba12ff3010538212b810d239e7bc273832c17b20091bdbc60caff162997b00ca5e0486dee889273014f8af4cfe68b387a4843ea40dc04b29c90e1dce767c400be5f27159f5da3fb863a01e2ec9f14ba33d5b432591fb8eaa2cd515c4fdad54c0c4574d17d54f2ad7e4c4a3c59bcbcd4897c992fb8a80225c85bcde10b2d470d734575a42d05f9961c6b2e491ef0ef4019a9a3613798bbca8da050d38aa0948159a4cec54b1f72a07b80c18cbfc18b843ff115d967902fc8aa3cc9f15e3f5767fadb7ecb504c6fd18cf3f630530c72065b5bfd8c8ae091bc7ed4e86fd9a81df27602731cc848226e60f8b8ecd9eac653b789e7d2b2a86a61531cb4949cbc5ad3da71cf03841835fa515dced118219b20691cc5838a1b82e32af1328520ad9b476cd41051f121900c9e64707c309066d35933843f5e10f501a1459893edbcd762614e1b1c2375872795e298a0c3f99dc039b5fc68900b68d89e62baa3a4d8af7e09eedd8220c8197dfdc234f1e16b8abddf0e2f57d1728151760e07a240887c3711ca714002441cd396a94797054bb0f69dbd815a3528f7a2863f89e127525b4bb7f96ef23a475b9f56890a5579e5bd72acf163ce48194a4da7c37922acc589e9eef973cc2cdf4f7d450ab2e5190ae3738e64e0de660d1dfd5d29af018121753dc36afa483024f5b822cbdfe6a170b9c716d59ca04ca86bd48b1f2eb60935a24824ed7c4b180ff03a643a5e5f92cc5cd9df1294107a5468c9edef63c274e33845704ae7fd1a3059344b89679bd6edd3cd77e635fedf172687bc35d8eb91068cd6152cb0b23ac7b3928924610f9165040ad429ce0b009c2348744b9bcbc03e9e01eac03fd3cfc1c06c7b3d19d03ed409daea9c40d3023a260fe60bbf5d61c0f2f10d005caf35253f554b23d66d63010a98bfb9b8ec967679fa0bb78d8347703bfd1a7739b141f1c9f7b484770f5f09b7dbb51f32435caf0934bd0834df7d9064fde03c3cb0c45fb395a4e8193660bfbcb8a8f4cd680a0a8f5dcbbf4c2a5440a2b071c0db65c2db5058642ccf82ef066d6bcf31cddc4c29f2a2c69f1cc5ee52e71bad4d65247b5d84a9f6e89bde525dba70689e528d05b0f75f3d54524ff2d87a1bf0dc7e43212ea8e359b0e2b3ef9a31e072147ba965bba18a0169e24d0067a5734be1c7c277606e293f954bdbf67ea8740d857e903bf01c1002a91df27a136102d58a9523ee2d81f1553000ea697231ee33e01981022a8cbc5c6a8770811403cf7ed7be35ec9987bcc39c6d28d36157fe24bef619b32ae9cdb9401904606e26d6d6d65c164044ae6935fa96286c942ab96afdb1933506e6f3e92143e6d8af1c2b3c443200ab5f77fbb90130e07831bbb46e1f44aeb70ff0ec45528156a861b905984650fd3264176886c40f5ba397fa357112699d272968f82e12235db6a750fb66fa742db3aff8cfde16d6f54a5f5d547042ec2814410d0aed8ac8669259429bf65c7e361c6c9d852403965824833208d8d9dbf51974c97db15f9129ecd413bc9a4ffd0e7ea1f68973e63bd47d5615e7133619bf6bb3229367e80fd119d607c620cdbc3741f1a616f272840e0e5de8cb1f3f4f22a5c503c768799a7f136e04560aab051ea91ed335e40f31097c6150f64d436fb2b1e4e5712e060ba78a763f0054da5636535f0d9f86749c2a4df57a5817fe2a588c6bfb926caab4dfb8fee88c6ddbe7ca04ee4f0a4e1907fe03bb3c23ec9fc624701048a1182495bcf1ec6716776a428a9105c9b4454c3699172d7080dfd5507923b1f3d3d4cba6804750289030e837d7000f080e592a89625b5e409ca86032d728927a4ccfb0a9d5c811b78763824dba98d7c73d1444a09cd09e374747fac24bab20873e419a076e99685117e16d5eb47a54f6370831f17418b6f0eba4434bc075529517f19c9301119ee78053ffa4ca0a1931173147aec6d319a493ad6f4f933c20eda11b2a0dcdb97e4dc574947e28ad64ed3ff535765a3e97805abd36c2e0a9a93d286c298b1fa30b836ca68c4cc1953b96a77a08bcc5f44e245c41477e73640fee461d988fab9dcf32911d0162872937d02648211086af47493db1ae19a14b5f1bf82a80ae089b720141f9a6e490cf302d2a4fea7b7c48a51eefcc5484379066b126c755346f234d009e4d88eac9e4e91ac51c4c2c4e07c7535420de0ea4ae1cf7d0b659fea0318fd4a481e78e817d400eb61227667570952162eafbd4279989ea3f2d3fe5e42de1df575b2c1cfb091e218a7212739b094edd3cbc0d8252849b5f8f329ecd24c283a4dc51a16d19d03020e65f6f6277b211e57d5d67a90c12fbfb760e12342d71cf54fcac1444de97c1ce37b536a0075b08e411dd3040bce8df41beaf0bb6efd60d668e2cba64c8163c10e68becaa62453563bf29330be4c336d607d6ad0a848f473d65898acd38c3bfc6f009ca3b257516677502a2a39a066576a70d2095a5f3896e97ab16538dcfbe26932c4ca4a975771c6bf50c92fdb510285cd6eb9328e240e08526c86fd77225cd51a9e7ef52fc928224a9e3a1a6b22ea0dba8d360f2e3484f02c59cdaecd126f4f43fa0e7432da21e1ddd58445386bf6f539b31ea1219dd9dcba5122bc67c0c6b97ecbad174fa958500ab4e761093ce223d3a383f384f052ba8254a280ad335f30b045e4fe700f437ac40dd7aff2fac4f3bb8b6a08db5828ba9ec730ab1876e0eddb2ae97e174f2c2ab2049235547ecefff2ad8983a7102edd015445a43ab6659a83113dedeb298d5a33b35ad0048e0a58ee41a66b90ebef5274f6a635c8dcd538b068ac0d75fd3b913a28b51135a67bd179056cb9864db2865bf8a354bfb458583ce035f613be8e9d985b5a3d62bfa56e2c35f787e573e516e129cd70c1b652ea5f8d3bf75f7e4f70154482e5552741207b49a5a4b3e003ac83953110ebb9c43d47fd5c047db8bf8491fbee71845511f0f99ff777c81f9d1bdc8fc981526a2f21e8bd1a0e61316e75e00397f526c1573630d155a4c8752382e3f51ba9d8713992356c800e72dd33180af5ff13c168cf13773db730b3d37956bb77a0fe24d63820db7a662a9a8371497bf258fba43858000840c25e53a02d34ca647b27ba5ea401b6b9bba0fc758359778bfb0a39fa5159901dae057eb093d065fa679ae8520f0ddb0925a0b1a681f65522943083f1f04e503ed937aa0990d853864b2ad4219699999f72463083707e9a34e988f5065659b1f581782d3550d254249e0e43c284e66ee79ce04b8bf8905bcd3c478de8ae479af64ace68e1237097ea4a037d815d7ff198eb83526393a4fbee9d08d5a9db7ed59a09927a410e12f66ed48b620081ef94749cd72e37ef32b6debdc99a0c3bfc33ea9e385edeaf049a934dffb8f47cd5c3a08c227cf6ff2dd371f858a28ab293dbef2e4d08d8d817766b6bfb0f530d7198a48d06e0c181f2ebbb62169852e0e1ae66f9f139b0e40fd87dff260de3ba36fc5ee9e0ba442b32e34df1eafa7a4a9381e784ebb9ed21162b95a239f502e1c4a2c95210de492f99656f98f9fcdf158b0cfe74d786ac09b90347adb5e2171ed7188e6615939f71809a70a9e0afeb72fdecd6d44650d2a7fe5d1accfb58afbb0ec9d277a1e31f45f05c0a61e600085edfbc10c29a5c56ecbdefdf022bea62cd32fde4cafc748cde0b379df69bea599d94358cfe2a2624854880fd3115481e59f031ab729032734afb96d7788a405595b05977411a4fcb84e1e28670f917a654c793009a7773ad5ee62e708e23190fb8699a945e81891467e7c2fa48025582bef89cbc75f680f850c49b9cc4bc970fc039918abd79a8c3589a8286e488c67e2ba2a8375b1478ed7f5dfa75bd04f8ac0918fe3c3d51e10f935ab37b53ed07cb8f9c3eea25827ba8b15247ba91173b82828046f7cb53abf17374ff3061977e3a5a0527c3d4fc48e04fa5071b015b02877372f7d9b2313516ea21be04d46c7a1eac90d5927f27a14421626231d5148388519b2c4dac9711c2cda9ae0587e3643cebda8606f0cef24616bde731ad1d07f680e46ef1681fc1e2d8eb0268a26c139d9e1551f58971b75888d9ecf60f6c31b1a258efbdee85f5e9431630a92a82bfef3cc3553c1cc0b5cdcf27df85de0daa6bd1affda1ddba581c1d2c7834943a84c923beacd2c6965d96f62ffab5ee04406f5b2597016ce4b6fb76cb511a8dacd91dbfbd6caf583499032d83e5be89445b7f74b413d57364a5e6ea685ca1a82bc9213de1052a18fd06be39ab27394e97ce03cf172ee350772365c08d830087ed04436f5f7b9dee39d2562632e76156e5a2ac4f8c50468299f09aa2333c8352c0476857d7268d0ddae5c17f3ed8827dec80b6ad637fbfa05bf529e08b963dcdf1f26966f1152e58fd68176d29511267a6bcc85b6ae87c18ae2f8dbb8398bccf788c9036378777c978329583af09708a585fac177d8d96d851643a527c8ee61ab2f5b4344edd70a45439f2d49205cf318f17af0798a55569548debd1fc2a43a5ab9aa9fe8d564639484f43c7ee15e5f67a9bdd361b2370a3a275b1a1efad81d8d7a74eb5c99d8d02884738547390ce81b18393aa41848fabc9845c993efc62cc171f22cdba58a9c0d2a7382e81756e796b50d71c31b8e37dc14758f7afb55f8f3f434367ea2a188960028a912d5a5b2ce7b4300a35b25da3f5766fcfa927a02da75a1ff8e3ce85b9b540f24edcc882c0cb2a61ebbaf47f20da5efb566acdb6c02f336ab2841c77623032094e76d8daec1b419401ba0561ba396a1a5462fe0137146030a924bf1632584bb7e4e203e70d2451eeefee7db5a0fe83ddcb15866095d193796253a7d9284ba79343cea846a1ae87b36ad8465bddc12bdac824dc4beab81b1eb465303797a440e99a335f96461aa893dc336a4bc1411fdb496e3ebd4a42641a30c2369355395eeba79a3ea30056de9518c7060eb771b1ab8e13e7471722f6dff158dfb5e3227ec45a49714d204f0035f241ae4ce7d65a13448bf9d3b651d0b2172c14cf697f017335c99976527af6f660a7a399d9d1a787142e3d528d42cd1ee45035fbe8685f2b7c19e1085a8587c093c54bf7d4738d62fae9dcfe772315522ba13d2020234cc265f78ae412a44c6cba3d22100e4d0af955668a8b984b5df529e876cc29ea142293e8f67da6d94f9afd47528b274c9d3cb77915d9014cb8b399522d1fc20b16aaf2764b0e761d42053a42011d89a561afd5144ee4bcc4d5ae55c596c86c82a6c196f4296c0566de06d38cac93bf2d0bf2b75e1354151a5ac57c740239aa49f061e729bbb91aadf0803bf128d7bb242dcd451f8cf76e20a2213e1e4c673072c0ed73000cc7d7e5f07a74af4dacff25805d18b1dc55f89080fe008ef7f5aa4774a20de81049e57c7a0e383ed99875ecad20460447923a686bc77be68a4441b65e9b3a4dade23a6dcb20b85cf7790f75d07b10440a74ea87116b3ce29a249ae7d062e05e8c49f1571340ca8e88c6282d5243221871072cabd44afe979d6b188f49dd5b8966d256212f87ca4d41628ee544a20631c42dab20020d0c4c9725a0aeb0c34ad3d47f3bf3bc55c488cbbcf0b9e44198e1a64e483123a8c511c3ea33d50379b61e7735688f30e220f2a07c216a7f95ba80791a53c6e5dde3e712a77cdbcdfdeaf8e27c8447696af093f812bb8b56f8ebc368c86252047a390af8920340a331e7cf31a5cfc51012910bad95bc7972d3c4c5dd4c9cd51ef9b1db871a819beca2b51cd6138439f989ccabcf660e67e561853505729d0946080b848557e046bacefa2dadffa013adf6901ca349e7b39bf9d8a26cc66120d4185338e5bc640d226471256c9d13825961c6d933c3e53c86989924042fae309776a5ecd4423910d313741732438dd2bf1e2055d72d4e3c857d26f01766bd5b254750e401f49049dfc201a5ef3d259b058356a7aec0e8cfd0524a71783c757288b777f100f751daa020954de2aab3f5b408fdaf368001843b655e030bfb46ae5da8cd3588ebe61b957596c628aefda85fa681088843a8274ba1e7c6dff51b1e43016b59f82d262cbde7559b19722f9e34daf68999ae63246cee18fe9707069e7cc865b698c59d7428e476d1bc3af3fefe1529b3c4ef05e2a2c1795377e144b71a4e75eabe45a27d2d46bd860a17b8e2852a407fba9b2c1cbbbb22526b9d615984ab44d2315647fbde6f8f90ba048f6bbb959cbb2d0f1ea00f5c942c2f5ad854d5210ab7fa1217c85eef012865bf43f5eec240aeeff4dfa727846173d4e610ef6e39b353cef0edc47d61d6e40245d406c48a7cb2c98e0edb272e77c64a14b808af0a3a5b04e3a3fee4193575d62f1e80e40c91b43060e72c807127f374b75aeb2821d4d30ff1142f916f8baf6e80a26af76543dd2980933906bea0ead353537abceffc9bd13d16abc2eb5469db014c180fee9531bdc7cd045e25318315db0e8a442b70da3c481a139fd6021f177ed5c0eec3ab5577ee882bf9e3fae7970576754ad8109a8d847f3a9a05ada4f1b3d6c6e5e69d0528ab86aaea76d0a6ad1786b7413b58fabb323e98257c318f06f1c5a8711fd478bcb21e9e699daa3961469f661717febe78d018a79dffb575148643e1f4263cadd63478f18804753242c819f1fd07427a4a0f2717349a73440bc4ca1d35ff6b732fd359e444b4aa044ab581a2dac436286b752b7898379063aab924ea1913eab2ca10b4ceaacbc63e73a22520c9444c60f2d521f752eabdb39bd443c383f5647341d60e08eff7c4c4ddf0473eccc7c16521ebc3f9d23a28c5653f2976fdce31be7b486880c84ec471e8a23f9fe7250f51ac5594de15411a1ccd4266323262f8a6f114fc7e2a05c84b40ec9919f1ffef35a65b0a1320b07e96557fb8df8dd7764423d7d8509a524adce47feba6f7d5de70eb81e9963d4a6a62c1c75d9061e12443b4768059e193fb233f489b76eec7af55684ff3fe7b2a1982a4639537f5b1eb8a556e73467d26430340f37cbed5a837d80e49db0110b902e20d7245f845cf85f39ded7a20f40bfe849665b430835624f5170f1c764332af0ef91fccd305037054aae3a3d8faabf1b42cd098cdadadf7d74b7134a5489faf6be0375efff8ad6ef3d315f057a8b8e513796b6ea51534344b145e8167564779664244e1f6f4e1be4a4ec802c596e189be8b9070bfb67dae13d011f26359dc321083a3523d75f3c00f990d2f392e20565a79270cd48b1e284fca5c7836bcf1f453495568a6036a5e336085ae3263cbfb5f4c2f54d290f564b40a8267a5a6cdb926c461141d7d12e74865889523d630eafb61efc524ce817ac2a8eaf75e6c3f61e721c77b481222bfb7503f0cc02602d1b9c5d7f9dcaf61dc3a076ed92e0018770aab57ca840eefd617362e51803117d2a733b6b8251272cd5ec176757758145d93df48ca1f51c24b4022fcd23f015bd2e51e07acd467e68608c946c5c747ccab781be07f86878921a329a0ceedd82f19d0b72f90a8a79d5a1017dce9aaaa175c523b2fc94432b2bd889ef4041551c8fad162fb94c65a74592c4a092d77ace5a8277aa0c97c91ea7e12520e71dddcda4b2a3324b9d1802f569db135ced18a6ec95f08d394b066eab6479acc156fae63d8a2dddd2c87732cd930ee24c3a98533e3f806ab3a60a58f43e8b258441751e62c487d3c96565fa2705e9a36b6c2a3786b64eaec9dea1f25be0851cdfd5ddc3362778f0c894e91f5f56bd4582c12faabfb64ac1ce3fe3242c9c4665377ee4553071c836601087c78fcf2a1fe1c511054a882672ea993b644895b4e080d6a55d8c0cb0e969fd5c2974071cbb15f6974f0af5dbd3b419a8ca16a1acd9f1326781bd245f4a059a94e536aec10c77ec2cf0f4910945f9528cf2790275e807a3ec6c016e42c6a3ca5fe529aa0c4f8cfd0a2e8894d8604a43d51fc35a6891332b753819ea946766b7a4b9c54f79048b95b575105c34ef5e8bb206919809513d4c649353462cabb37f572adbdc80547740f867ac2ee550db12877e80779e464d2e87222b2c56963394aff9f55ee210eb470ed4a502b5ca3880fa2f70d2abdd9959f57692ac2db2fc3948a0d11f1019f77fc71b910904f15461308f4fa65824ccdb762d464f74641c387eff85d38f338b13a49c740058803eb6e1ad7eda81eb75953497004bb262d62c34ae0f85386d01834fa0c95fc8689adc5e393ae5ace36cead45277937b8258d5e58a2cd633c2db83dd3d46118c03e06c192b37699b46cba4314b5ff9d248345171ffbac91e592d787deeb34d433c1c75488004508a647fbda4da49d9f1744a43ce7d81a3d173f07c477559b1d69fb381bebd752471ad97dcc0c8ba4619a2dc576020dd505b4a3330eecbf398b439031b261ca77d385f36c3a8624f00f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
