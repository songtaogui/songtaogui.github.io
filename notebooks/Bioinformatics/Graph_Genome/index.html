<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28b89058bb9779fd4cdc168a5582f2dcf1a73ffa4371ba72a6a836fb9ce9e778fc36a6d82e3a5a27b91b6f9ebc5693bc49c8dc2c4482915917f56833d8bf280d60b5c7dada64d04de20022b5e3a19623485dd75a5c59dc2ef788219f2da7fdc95da7e9f8fa22cdc0c6c16ac6443bbbac66f76044379befd7416839a56307ba21d400d905a3104df128b9973bc2c945fd738b6ba54be64c1db16a81fe08d0ca30e31e41bb4f207b8fed0df657a7672041b03e77bc7012bdb0a6fce6d60e8183c2b00a3e064b2af6b7df0382db1bd889c0065497a3229e21e5e4d6ad23e340b8272fefb65981812f9c4788197f06de3242035857ced6f6319d333f6b2cb028ae46b7579f015f3c14979eddfece17ee0c6384e57f4b9d58a923ab3bffbbea61f44e4063014f1c8dc0e52087adf0cc7f5b7611410f6d6a7a542a5b825993e103c99336094c6d5c48a56dc806c2a15b2a35cc3020e9d16ade9452928c4f2d0f8d3bce480eee630405e0c89c362c86d8ad96e1dab9be2308557d8a8d63e32b19980e24bfab4d3019d9c7f90ff7a5dc2e5029bdb2a5175e91a1d5d793955ac1a9b3fe63a11ce006a0de33c66d8a95fbb77c2142ebd91db6026c8a257a5a460fff6758ec13d18df9266b134511f6813f5d7d61b13ba4ac773a8c597bcf0393f5acdd6fb9cb3f05ed2a4454f9d854498fcfe329a7191de8bf7886f6c96632d49bd57d4997e660bf69f4d7297a4aa7f08f62de46f40ae4af2ac0c7691e997046a1c3120c15496298860c1849d8827bb91e3882a25c018bbdb6e7c3b92eae512a94316f1aeca2b5ad0a3e8917a03b23f1bd567baff58a0ca31c33f3883f84f5ff4e72f7063beaa0771554901b711e64cf0ec18e96352e45f4ecb7a3bd300fb8c20b174261ab41307db76a4025b01ef64c5578a7a5f28525f89ec85a26263109ee63f101f27ed18df8c4a4e2dc0f4bd7b90cba2a398aa7d081ec46d9e14d2f90d378e5ffcdc49e82e2270892b29f0be19ca1397fa0a2295c202ad5ca2f9a2b96c45d621e3964c91116f09700915d5da8bfaf50f3f2c7c94241327a49eabb028e86bfb6fd322afadf6ace9161f94acfd0dd895757c2ddc1a4d1ba61b94af66676117e45ca51404755cdbbf4f0326bd65e7ca11e93f55ac6f7665b76f25dfd23d87b8c2eb2c0dd57398874df17f56f877b0a8dcd9784a9a6bca2f5efc289987356b53d22e39d8966fa8b3f16f81c3baca2c316f6a624abede83d82d7565a73154b61e5b6ea98d5565d772a5b4ca852562deddfdbb046d1010b033cd88da6b9edf40461ca0e21dccc1f6a090193a8f08b8e28cdaedbd379b4a9e38576ca4fe9b6b46307f656698e7bfa137a45a998bafd45aa3c76ceb8e92f63a45673ac61ee896d11099999d47afc73503f530657f701fc5c7e2712a27db546ccfe66c3acbb56c8138d6a302b9bd87f71aedc44d984ed4f44ad55b7d4d785f16a6f3f08a5ddfb7c872c8cd5236f3d344ca13e527bbd9c52810b3bf29cf3b8601af7cfab147bab6fa207b9f30291466ffa6c5b436ec4309554709b0bc0dc04938569c3b142a41aadafc214ba7c55ad176366bcf55a8b6af993035b274d169a7c694a6d0bbbac35a3b62c7c43d79bba4fc9f373ccf6d5f1e504d354909c19a0ab2968548e5b77ec959021a57d192d9d606608b139c8c1bece185d260c81cb66ec72c98e785a61c3dc14161d8e42b75dca33b0ccd82eb9f64a2b7f4d10ce83bd591a169a3ed1f471933286e417abe041d57cc80bb9d274c4366c70d38fcc3406417bfd4c81a0a870763ec42a5fb6ab87823ef23979c890560a876fab71952f1017b5bfb0d0621af2b0119cb4053286ff1124dd8a52334ea69c4a1d7c2ee88bf9fabbcbdd51dfcb0fae408c891080294599b2db458f8bf65f1adae48e4512382be664fbe031dbc9e9f2fbdb7bd8b66fdce0e28407b9bf991e3c348eeaf390e463f47fb59412e1daf41b8bbb0994d97e37af9a0ac77fb2ed1a8d9c909c0ce4f40f96fa507153a71cdbfe190e20227ab95101897122885f628bb631b4623723a69e72772bbbeb8d3cc1abe587a2def602d4437f4f030869122aaab45f27f52d8683f25767965175c41162fed97fdc6189e799cbf1f14f45ac8972ca1a8b13f068f407864a032afd1b525a0f86ed09a18248b76415a3b53c1fe6fa8b2ad70e57ac0c695d454ca65318a7a3d1e7521cad490e3ead7d98d4eca037b87f7421868e8b9830a98c7f7cad9b3bd9f1c01eb023e5d61d7cf1a92e23526681601f3e062931beaec42e546ca2319d9b55ba0d45f4c2aa745fbcdf9e246feb8994141d813a6afdedd84ff50f33334e085ad16c94e0c47f940633fb401dc6b06a616e232f2087c42fbffc90b9055391fc253a7bce789b4ea14a14dabd266dc37f84154906af1d4787000f3e86e52a8e647e89c0f670544d8aac1e4f1e3e3e1fbe2085b353702194a9ebfebdf8f53fcf1a4a9ec964a1dfc8ec43dc0579f2589dac76a386ea3c3ea06646fc340ce60b550f7ec7ba744fa9f9ce526c531934b20275d540e23032cb2130d9eb1866dc48b238ddea4a334f84f62c64f5d4f8b5030ac98b78680694a19824a09dffee63ba236c41672971b0b0de57f2791cb8df275fd34502835976dac7c01cef083cf85e061c69ed30c291d12b6b34e846aa6692bb20a9e9e2cd7c06928067149d24aa9cfdca483bdfd548dd68b18d1eeef50f0264786257733adcea2b95c1c064f88e56d5be871e982d7e5d23eb4456876bac8cfbe039a2aa512f87542b95240cada8dd06ddeb1c1200e6573e81034e83ba64260b0088ea2738797434a46e811ba2151521ccb8164d6e02ae7ac02eac47d158d76c81623e0392c5dd326eca4f0aa4ffe54be9d82c5100053f1624e3d201ca251cc7e8e5e34f5e1a7ec28c99dd20a5de6bb7f4744d5673f44398ce8ded80408540e2f9c0eb771f0885802ec02b78626552fd5117ebdb5eb48d7abecdbdc533d73504596f0ceb5110774c7feaafa747a2eb7a371c3a40711287f758fccfc6b3451085d5ce73b1762a7b7e8ef5c0928d3d8ef3ddababf5fe146c80f14b49a2d78486c45e0730af86000b616ad56cf8a9d4933271eef2b79b395f915d793c062e5dcde217e8edbc6f839bb4ae37194b036b183daf0bf1770875d67733be7fec9c7eee53b543ab69fb7f7e94483b77f901bcea3a1114722c883bc3b984b80ef446a031733fbf6ca4d6f617702a50485d87434ead39d42a986f420d9a8e7e90dcf689ec1a4d56d10283cd29f4bbec47e52a9d6f03a850cd61d8439a2d15a767d21be7d31d7d288a627eeedc1f2c0256dbbed9b665b85bf9875ffe3c4448e8c6514ce69c241aa728c3a8bb74e999e438b7f28c1f2ecd25d7d5c980361f5492b9eaa1c5fad4d4e8a83a0928526a37dacf1cd69218694e3329fe712d09499ed1693b134ff5af5758c1f2e627145c4eeee39207e81af44553063fdb329ee047b48ef09b7aba511b8447b6d1d437eedbea001c0aec4c748b68493e7f313a279652f43bdca623ab9679b3a5a2751c91a5778d49bc97fd30035b2fbb5da492e8dca04a640a4c40a528c1119279c11d62651581d2740ab0c49898e941c9046a31ab9b5c9c4c93cd9886673f2a85372fb63d13c3d7efd57d8aeb7d9edf2999d0475c5486a2bd06a3ff1220d6c56bfd52237baaa565a8113d6e2ebc8aba24ae80f9fb7b51ff17adca03746a154d9b5cb4bc4bbdd875820ff8c8d3a7a09cce5e7beb9f0bb08bb7aaf4b658f5eeba773ab4910676e24009ca777a8abe11dab126f8793128ae7c2083d6a94fbc55fb32eb322bab1ffa2735ca50bf53251bb20f05ea748b24d59d458ab0fe0eb48086eda928c24e5235cfbc5538f0128e70c77348bb0cd045c61a38ea0accef8fc5491b924f40fa2a86b9ede986268f1eba924c2d7d1106f9d4499563e01d82548e6af73d731219ed942446244f588411c7e010ee6035411effebd19d2cc04744ccb1a17f085912aeeed841e365407067ee668ead52dccc7a704d6232da2a8f141a6990e3f1cd9d141810f89b582ca78c786a2fab02c429560fe4d5a320da63855dd1d343c2f76ce939eedf2c5cd7630ad24d67ba8114e05f4cdca4607006831e6a2b44ce6e918c8893475d023e614491e312f9bbec49630b06e5af5bef38937ce3d4c7573658fd5a9b410b7b00fc311e3e1bb8d636a9c3233a13f20facf2d5f74f522a15fa1ba9bf2314ba048d37a7d38287f7493adae274900b0beab8df5232f5a86e2c8b39e00ea78c8d69a74c32e8a0a30427d318f3526031e56c340108d7edd18a6204d853168eab98fa219ada536d7be94211da253927227a888c2d4d9cd42579b28f41b963a494c8568b06dcfdae5dea7ca9599d4469d3a5b97ec9798c944445f5a82d501d2c001fa0cc08940e2f1036e2a3a5d1268e8254e02039747b3a9f0ce2bfe43a7b24f437166bef0bd640e5968420764a6c3e2224e98fdd7d94b1cac0fd1d9bf1e16b2015a31e5a6c1ebd38b5d2d4df735f271166fc45700005d3c2860cb2b616c66620ac97c6e74ac770eb1de1c998eeb622c5d2eae91c6bdfda2e2eafcabbf5b4a602befb58d3b0ec9e7e4e271a170f7b02843a5e6b85904d6b1698a56dd7528bb5d879431a75152dfc3786c3672b112ecfafb2203ff0e8ace1f85678376f844f506332f646d6d93d22527d960f093bac146d4b7f3a60e5076a450780f5a8d98554a995603d2401a6a5f4e53a8eb2df2568b4845c8246322d6671bbd145f74671d09983cfb8e11e365b067c0075dabbaa333a3a308120e23abffa10833c059131a8086f9fe8db98237ad90bb40d1ee96fb5857fa255f389d5991080b0a2a423a76b706062bbc1097730f21d3a1f65c4216e744e97c9926cc90bba97e0347a335a5d97b1e5b0c728e59fe48fe3ae910411ecc034054631ca87afd285eed1ed2e6fdcb87ee2cc56d68af85c14e2626fa2269468dd24d5fb332040ce949381999dde4f3817c43a610b7a4bd1e67f44ec571bf6be1dcabc0daf2a189342df49b66e15082112fc9537baa0ef1f3fc8f3d6cbdbe1d2b11202860222b2c9f3223a78ac9b998530540b27704e0d90d95e1cda8ea582228c72fa1e636889e16d2b62ce6da6ebcfa8895fce93ec6c99da52a0e56d71450cd5ca890d67670ada584aa54a49f37a70276e2d789365173f06e90357932f9782725ca0be68eff75f58d86eb114e0fc6068c810772bb04ce439ab10a0203ce1d05ba6d75ebb659c2cc01b8751fe0f4adcca5d4fd4565521336db759cfe21c46e4a4941d8017e2b2caea04fceae654553173b2e1ca16b65efd26f4acb19c9f5e18d33a3c03ff892360179e69d9703bcf6846498c1a06c1d304536a6ea95c44ac9cf635b532f1a907596b1055359ff0d17dbf467cd8fa9fb6adde666c23d44aade8c6332876ab2559a771c57eb7c60cb66e6c65731b3a468d1042745477898a0b35e76b623eaf9d6feda4c225f0318fa3ca44e38ed3b38952d15e1d90aa8aac93c7fac76b41b68e11d1a7cc0f7e5d0b64d189779d17bd8d17afcb9ba5656a97a956b0e0f336170b7b582428e5cbe0c22815012d215f891787323dd09592d7d05e5f18da6edfceb6a80704523448e8dcb726bcb5b7eb868d5a9c72899a907c248931bc3cba6b01eceb94d04507aeb2edc1ce73c8fd666a9221896d842c0b884e0b0e0659e341ac9cb14c508a8c22d9be8eec0bf27d9438f2405b801ca9e6992af2257beb839a3d63fc077b2f28d3d64595b6efaeff3d8ad7f2feb951d7552741353bf1e735a4cbbe83396870f260835b80d653a22f3cfa9ade0dae40baa215e03860dcefcd997c9c14519c589e2e455f2a932b577a827b2f67a0488d7e537738a3346cce868960fb52ec3b073917d7605be059a7c97dfbc7ffdb17c58114cc646116c3fc083fe10cb8930f962815c69540db88486492b01097fc76eef942aa2472944f305525c2175e98984025d483fefb4fd25e854de66cab8e1d4dc1d263ea5f6cb6a6b738402c11521fc36eb96f7eae6a681b007394524ab55601e29323309fe92107f0c7c3017eaf9a03389fb7b6952f324aec57f829fd210390b09a6dd7893bddb491052280aea50b0cd52da19f707f0b357ad42dd9e63ce0c23e91d91ba75118d7cda3d9f9cfcc5983bd11bd6078f104213e18d67158e8ced53df0317ed507b8ed10e6cbbb7fbc6aaaebb45f36928cc069fd6becb8f480a59e18bac3463b3d7b25bc913d5b6837ac03d367f135b163a291640856e9e19251f9e57d996e3e843aca7ee4ea229fa85c06da9a62bd8c0975afd2b58f9e6ab389a9406d7984a9e69aaacc7442ac4ec9e72661a72526777f6f4ead373dfb157a21006709aebe21a5b6b399bf732729b36f74d6d8da7f6bcd91d03895a3344859f7cf0ad954bf24d1810e1f0c7f56fafc9c00be577eeff8a5457e7e763a94f2ad463d5d161b2cf8a71b4913ee9bc211444c4cac7feea80fe407305debf713afafb7c5809f9ba68668de6446fd9cad65d561f21718b05f039b766804d19af9226bc2999df7b22e56a3b202c9843cc41fccef384eea9b6116d400b30ea0abdcd12a7cc27492ee706d5b55dc0a6c4f9e480d6218aa1c287114157ac82b35a1d3a34f8c1597ca29dddcf07ae571652fce40e97c316913171590f3441759663bf3c7e7ce62ddae4f0400ccccd6b299366a6847b12f2f06a2446c45ab5b53c50fbf65df2dc74409dda27c01dc21529282ca2db2fad58777402cb4c44c60fb64474bb6063a2a4dcdaef9e42c811dd838e5e0400355ef8d98bcc4c0b7e142fae3a5c191f0c48e5c177bc545e3d2d34a0fc648b49c2fa23837a70de29a2d0a1331ad47ca468942fa2a70a0825d3adf856b3f234b3ca93fba972f66303bcfa6a7be333e442368fdee26cd12af027b41ddc45aed0432e780eeaa788810ee0a7220755bb387d5029e2faa1555b89531fa651abd3502e046fb525a20fe95cb5601d04601cc35374f2097da03a67ece94fb5cb6ce5ffc90463e75d38bd83d747e681bf881cb826bad42153e3934a717f6f955b805968aff64501ba4f2bf211ae6ed5057ec72a9c8aeef91824b0dd4ece0240e619814971d3a707ca800cf54ca2c9f6af3db2fa72125ad438419ee813c8ddd82e51c2b29923699ed5ce8e95395baeaafd02156d8fe72cebf2c684512c687013cb1be52862b490324fdbefa05d5480f68a32d7f079cd2dbeca8c5aa04d8c8aa83302fcd51657e8f30117fdfdffde632a132253b72acf5e01f081a06b9e49aa2031f0fc391e15663ba6b158ff218cb24e9d20d6d2f886c19582993eba10e657bba497f8d04710621cf6f45b4c1e7894805b7dc137b4d3d5e364425d10ee626c43d600595e911d46e5b965513bb4b6514a56a75598993d1f1bada2dd4dab1d3a9976d86b8c9ad13c5ea752a114e2a35aa41972c7a851dca5970b2b1413cd63aaa28d08840f217ae144b7f1514698beafff095ee19dc62154f519345c1de9aa606e7ae3558c45be8076ad5173911b3c0bdbad6fb759b771c212fe58c24465488f769c3667fe1e714db31faca3b72b6b698e840f1fb0a3b5975e7bf085400ba6fc1af4cf9c218761d1178038eb81eef01ebae38e7433bf206ed330987bb8a002f4ca6b11869bb2c374a445f0a7d5b6178c8e0f27095561fc224f51c266011a30c052f43d57db124bee0b2703002052fa9e82e325be462dacc01c345379ba92d4ed0968ec9dabd9a62eaa064d35255c8e2728220458deff88ea48000f2403c8fe5bf2402eb7754a7f88da766f2774d65d3667edef2bcd42d8e609a23ed21109e791c16033f27d77d117fac6e48cc02e431579580485b115053bd376461b6df2f3c7e6f9c424ef97c5c35f5312cc7ab3a12192569449794f71af79954218fecab0e9167bb0dbece3eaa1b69a40a37d37a6aa88de8d305174a15fd64caffc8312238f565a9b1d5a65807ac7eefd4e0dda73533fdb639821a9a4769fe54042d0ec1d16dfa3714ba8257aff1cb73a0ac92f692b8b521a311a78ba9ded611c61ec613ef13aa1a209a7636fccd09ff8da01f240a68321423f2ad6eb11fd7a53ce7da499f479a1a81a7e551dd1e7971e639259d964b1bd6a3dafcea97c0893087bf5bbce3aecf955dce50c42182bb6214410f9eb919fb6d47db9708ae7b5dac7679c46536b21a1564f66f73ca282ca7c5506d7fc97a4fce2890146f2cc8074ad546638b111093752f5d4cbe75c9e4ed6efcf348716d3ffe9be6040aab116aee0d0205f758426b6b99206ecae0772b990f73b82a3ff81e089c9735aea5c27e2846bc6a0e1134d76f4e1b15f0649ba20a0224d723f2deeee80a81c565f350bfe5587ad35379c7ee300a0f796678ade100ace3384a713be45f52025dbef1dd00321a13a487f79fc01d47d85bb2e353a90a3bf916dc2630dd23cf5ebb37047921d68af8ec58a6da7c3fb9625e9b2f53ba46f4897d2adc6e85ebf6bd83a42d2c21c204f0a0a70b8c72f7fcbebb382f613cb3e175f210e325de6120d8b260456ee501f717a2357d3ad4cb24a3ebee8e525ea258cda0417600afd69a52396f0e71227520e578c9768a95e5303609e8265d9f686e415054b89fa0d076f300bdcfdbfdecea2ceaab520712ae44679978393effd607a0db6e515b76c1d1f98dc99da36c2ea203bbf124058538c63c404e7c4d68348ed455ac36029def643c452738f6340979ced9b3e09f2ab6a96a6ba01b452b7f745866512dc53f08da406721c727964e9d39a881ae36fb5ef4b8d478cc9eb7a906a024eef0d1b2a6bd8a207454d452596f9c326278113a8a01886f4be7cd856ac7fcca559a50d4a2d1aa8698e807dba42787241724ac0013e1275fe55cb8e4100c638fd73f20fa583e0ca79dbc802d31c1bc8bf3b3404a3f50547058ba5d48d26438ebc14f97831e082b183e3f37ba8316379890cadac5a57edbec743ded962a1e8042867520d89a6f94d5093910917a00010ec23c8bdc848e36832f5db04ba18579ef62e6ca01028e5bdb01b9b1b1bce902a6f8fcdf493d0fa3a9aa4148c60a547ef642dfb59ce7fa7d15a28d5e381d7f888439dfd807418ec70afb495983181e84bf1abc64edf1f79c741f0b18b6069d4093033b26a26552c26f3a3ceca4d6f768299e28934cb906b48bd39faff43b4cbf1a5aa7aff43d26aeb79391f29118b8ea71e55e45c630a3dc13f9b70b228c7f330b2d22378acee5920fc75ac31c920cc37cb711d3f3c91982d26f3f09f157a750f8ad901e7b6a73dbd393e5e9b514ed869c9b7ef621c7201f000f3b42136d3e0f58bf672206556d92b3eaad86c8793a8e9eb0a955ded3c9496ceb11d087b66d558b0abece8b6e60f350fcba403e58373a09b043b6d46bd7fb84b232593b1a11dabc485259e8571d0b8dbf46c5545b0b006d6d2d1e957ed597393a57ee067f03a0081de2365e7ecfe6077ff69ef9b56c42bc348cbc4198ecde80e20792e21b8ad716f5be5a0adebcdbcf16d4fcedfab8a3615220ca36bada49f07bd10cbbf191643043320c9a10a57fc92634af889600e8684a7f9e46c134241d8450f87cb416570ac059b3f2b1e655eac501c476cf466ce3fbf0c17f60648620666893da340e892abd7e3227258f392b45c763ccefe9cb89445b7e95358471a0c889fa155c8db3acbe994d9058471ec6d0be149d639c1df34466b65a64ec156c60a50de036e79695d517b7f8c1b7eed72688f38d3c232d3e717e8956a9cbd90fd64b97c8a26d85218a8cf7f394147c87d979b7d8fc0963a72302a6209ee2d8153c737ae3026a5d52ae1af57f1527473c538ac8ce831b0d80680cf82407ad1372764741690e4cc616e5c77f0e63bfc22beee9b7051e59fece6fa8fd52ff298871db8c0a9a6be4b92304b8075229e7d4ce018164d8049f62fa148dfebf2b71672014052a95a125f25716499da9eaa643e622f9837b89f932573523fc76302d60b35284a421dbb3d12209a54e885b3a816f377169eb1b3a8ee7b921347cd5fc0f11e36787684106a5bb6377f968064b0d805d4585ec78e19a2a7437407b8290e489f780a6a1174c777ffaf11d830bb651172584392781b5da3399721f58c0f41e2b721a0cc4147f2e48c2580a2ddb10f776df5da1c2409a0dd7571749047d07475133ce2aa10ad3ae94c8f37a3793db5b6461b64d5445e11a0973e33d2add1e9fb051c8793521dfa5bc8e211042e67b813ec202374608222cf7d422473f4cfe4336763eb63b4891efaaee0c2947ed5772bb5986e120033f59d9ed0be196e3b903e09972eec0ad94755ddc900805682407ac6c2cda44ca862d1ecefd1450701251d0a63a8a4fe6a46ca3a27b57489053f446bbbbed9c0aa747ab16edd380d55e64e14b071aa89836120f0cc6408dda3822346ff5358ace3e608746769b30fff843ff1e30c24a9e0fc84e94fdaa282baa1950b62d3f99d589e3ed7f47d8d61233242e1ffdcc5bddf19b442d8d7bb76064646971f34c7fccfc185f4aea3f1dfd8bb875967b44afcf4eeb071efaf743b863adf0f27711f01e1f8e77806a2af352151f17f0b475f463757ca75f82b60c2035e78bf7a36a7dd8e882e218d8c6021cf681e2241eb6bc6eddb6b0be4a2d098b700371f754259b161ec738f55407289cf14e9f218f60ec9d9f13c967b5051783dd63b45cb6a816d660024f81eb6ada1a4e48943e9ccc7317abe719f7515acfe9c3e749b7c6a2007c3eb98c58609a226285f3ecb0f4246aeb76bbee4246aa097cb36598d5c000c25748ce59d796b21b107493a1b6c7ae0fd25a95cd34ec2b428b0eae4cb07fa7986c10f8a09f20c3c9a2ce0ed30f2065a07eeaac1fbc0bf7453580eee042dec5fb8e9eab4313fc65b6c7c645fa5b4dfb2d22968241abc6360f4b515c8f8632bf4382931d498f7abef295e7f20cc302636b40ff832a3313f4545d3e4582d654cc598e3678df02f06c43fbeca2d80350fcd494f6e7e0e11ffc2c4d0eb45e78f8a466521bb527b9561a7b4bb92bc65b3523500b1d6fd0a65d1ef631cb43326ddd0dc1b5580d40c8992d261f46b5c0f640221a1e096c847788a7e85613f01201c009c6127c2660c8afc6a5027a972784fc7c06137ff3bd73801c443f62167ba15c896e169cfb672c9d19eed0eff4ecebe9ddaeab3c75fd52dd9e3bb760f66b901f2f9e8355f2f9008537cb70a58d2e0dc7695a9461d9f20b502b4bec6edff6cb93e52f5eccb496639057133083e6af42b015a548c3f6f0372b2303177d926f36dc1e80d3c86198879e070872f841e898f291a4a3475f3560a68b5595c84c8a2ef76451a11b16078dc1afbc3a0adaa58ebe791598bcf1291f121be9d12081b20b3659d0afdb8bbbd5246baa8043c01b5f89a393692e5912171d39fee76539d63e4eaf0aca2266338453ea8b0df37843f7068687efac463b286727b0ac16ca90ed6aeb1d9d48d2859aa18ea1180e4ee9c68b6a63a8c43cdd70d2e3872badb8d8efbeef0cd2641d9e606fa3ef1043c7fa57aec9e0cbf917b8f7fdd7f874ac0088c24d2ef7f836d63d0d3d5486e2260fb1803552d4d45f02d0671d5a60bb0c3653617e5e550cc6649d6f3de91d9c654f4442461f5e156575a54f41fc05a3873c26c3686a1a839497f98d303613c7766625e6e0992c80b2d74b2bed5545c841d652454a9e8b06c8dd626cac81932a8dc96e1fa018eaca5d87b2e4dec70485f001088946757de5c758f179789975edb4c0cb1bc13668973dfa965bb968877aaf6e03c79fb2a20eb138cd069ec8f203ff11d7ad17a91a2c53aa4a91530dccb89a6024bc4f67011aaa6d5a8f2de7f484e64f419eb2ff6a179e2296d050077a2367a7c25b3ab930c89894f4c5889ef3c7eed968db8318a9bcbfba51603dd7b64ae259ffe96e02dbd5f53ac6eee39551416a545e525142b32194df1db5ff8e3689bdad14732a89dea1b8ce9edc5cad49f791a6035554d46290df15c91e81c064d9276ef28fd4eff3896a5e32a16da75c97736d162c1fb877303785f83c6cd623944dcc8461de3a39535e3132d56f0e7f859b6d2054c3291cfa60d909beba389a21185e9f458f1c29114eb836ae28e712db84ef9633c331354ce182148bd4478700c7d1b334dc68eba400759c8d6a4e116fe2c5970e704154ba0014a7f052a98593e2758777151ff10c51e02d5bf3087dbb0eb877c28d7a7790ca07c062b26cd63dad9d8f92dbf2aee015a3726f206dcb505ca211484dacebd23e5dcc559cac64b08f756157c44868296536576a91b1232c4e2e7a74eef7206d7efdb83de8be6f0d6b7639918d8e05d5ce703ed7439b1da8112923dfdc1ec525728ccd1cef229687a1122d07fd48c58977fea9719c8089ca55858beb37ec38c1837618e6d73ed96d4b3c62ef872592954ae27fc120478f11f6f518bbecc36bb426a1ee59f9e8b1fcd853748e2c082bab8610c2cb1e3bbb26bfa7ac85f4d64476092fc37e488a1ca46dbf3fcac8575dd24774e6edd8151fce9da8198f19e90cad03fe8c147cc1ef1a3a90e6d25b2fdd76b5b1760ec32c0ab007374064756fb99574fa415a3e90e79b929e613d90226d0c3afa2044b10d03f7320ab003e59a9b9e2f2319daac5ef6eced3f31b59caed88ce12fe6315e2008ad5f7393009275e4ef479b7f559d6954a2a681b6b57614a8c9412a1203b73bd850528769925c661878b076dce4c10429d8510ceb513461f2a147ac2f38d74c232ea27503a9924b8b735a21bdd9e1d3c574ead9d0a473a9fc981abf4a47da039ef72fea8334844f8ea2f65171151dbf5b70ad74634b6f1e5a155aed08bce453d981871bba4fb8a80aef0eac2f70382961c1027388259c330ce1ed7a5cd1c547019ee6f43901a8adf2d20f850ae61aee9d9f9b1a3745639d92261565c53cfbd0ae9c932477ab36da908d277ac0e25bff0c74ca58139661defb20d1102f88bc3fa428f57cf62137f96a1d285cc8a3090b41e21f9ac94bf370c5318bbd59da84cc84f6f743c872b00d59e72a7e6600d37c5dec0ab82be9adca76d689b8066a4eb2293f42898237969ee3176c40925aa9b7c7e06248021d78e4a4d32ccf1babbd80250ff950ca9711d12dc4998e33cdabd3b1347ca8f082c8e1397024402301b953aa8d9cd88c428550e731a7a846d95110a8fe4b446a405dee2cabf411a3a0cd28ba34f12b3076a38ccc6015f7f2f1e9a90f05576b7adeb3834ae0e511ced2510d76329194424dcbb9c822f767ff064bedf76fea8f453928797ab1c0c5e555b3decd0ecfd433584a1ccb047f7a6eef0ad96c2f017c6a636dc2512e110d7d4dc930ab3244814f111cdedf38438479381ec1b58fda977935c1d617953ade69c59e4b2663d2b006330d85bc9290cb506e38d34612771a002ca842c8fe613678a6de71c350115689c6417be7e5c8a229c1dcc380f7781618543ae71ffc096e46dd2ea28711b6788bbf23b0dbfe5dbeccf851f05ec4d3196fbd7fc5eabdbb4935dc93a799b6e8cf758b9f08a93681f81bbdf61ab9717b0e442e14336552b3b781fc273214a3c81699d3f8da883f18bb82a2d4b1c833dc9c30cd90dfa1985fbf3c4feed05841d91392622d3ef19b47cd0c837011ef11e0384f0390c3828923864bc2ff68d615b13bb528fb8664dc43fc8fa9be7804db97970751cae429922d1f882dfb6c6c8edb1e04efa39e1f56fc2a6d8bcb393785b01eecefa11d7f47fcc6629163f1ed17ee23d2d57a37a5e69a5c4b291561b30657464e13f20f8d3615b47eb1b231565eb41874131ba92affb4f239d51bd301c605cf5f62c3726bf8592e04959fafefbe5077c716a091dea52384abbbcabe0d1bd45df2a596eca01a73e3972e4cf8310fb7978c2824740135e0dfaabfef95d6004ec2214b189f58acf22f70c4cfb7dfaa99777913559dbdf143d19087a7edebaa60e0a1df351b0eb88d03e0de76272c339cde5ce8fa1f67c4a7e49aaf8bce8716e590e47ec65b3cc4fe507fd888aca99d1de7490ce203517a8b78b48f80991757ba129b028a9794aa4833fa68959035fa771099f38f550a906cec892fa072330e05089641f44adcc29730094e4d2cfb2b80db308385ea7bbadebb4adfc2574d6d3a3d527b115fbb5f1db874189b1179867e0e58c3df7963cb4c1cb59bd81a500faf72cea862cf06188493e10c32d23f49a9c41929f4afcc55d3d02ca627fe2040c72082420570fdcd50ba5b8afec63563848ce467b7882746fd30ab033c2f82b68f7ce6d946396cbec3e1b18297f69c7acb8b674c224eb44ba9f27796d8d73d28624026e43dc8326b220d2c214260f111b7b3d2b83e205aab5e1dbbe950d9436ecb1efb488262656fb436d4bcd1df944e848cf69850ab81f8fd172896e006dcd2817c55a1cc876166a8a4abc62763e37e4fe266d6f9fddab58e7b9822d6e9faed6700dcdc536bf2d106e430cf341a335d6bae32b43160f9c1eaa1c8c17a969d2182e2d0e523e2a686ab6260ab454aa8c9e743d8c5b22464e9924cd11729cf72b154c896659fbd2beb1e8eb9aaa2b540d1ec1dc6451adb9c44cf25ce17275a998197e53aafcbc35e30802da5e16b318b5b5348d46ac4cda48a270ca3c02c26c80f31d991e7dd0bbbd4919e2375229b707fde3df3b91db1e415bd2019b8417fe4ab1a2b8ca366ea53943c789ece3a3a39b3da5e941575523a401d5a7460237030068cd44456b05303603abd383bc22bf9e30ead599c00861714390331d17c95c9089ea3d59869b6c92d128c591c239f02d24865ad8fb5f0f0ee34eda079f2b97b75ef98efcfe0cdfc8ce2620059a9f9acfd46ef01f707ddc05a1b651b198f029e7dd3e419808cf32cade67c0384c2b8d820db57abcb6fdd2b7bdda4f2745c0f5a297fc1b2ca47ea5a7f79c87c98286bf61ec76783d051997e2b9fd2e289cab75fb50c59fae8d0ca7e0b1408ec03ae86fbd83ca1e13f6f8487884557f87d13634c0493cf8b0fa3b303c29c3903468675cbc7c1fc7192a0692358485ecbe41169e0175590a407097131c942dbaa9e805304edd1967990898703b627ce96ebdadf0755860ba579f40793b3cc34ae030053f72ba310f556c9af191f505d51ed739f50b5d485b180898696615aa77015126a942cd74dd42e6512a137614efc6f5a8d01e13a151f20514023b948818a54472f531a6c0be4baa78ebf55911773573c1bf9b164c2c81578f6d81d6594f7653d20557fc406400fd987ebd95458a1b732c0b063fff99b465ce930bed132de970cdb07ed45d08b96a5b441263a252732eb01567c39b5f7551325c536a010fab029a53f57b1e23cb83d1a87e781b92c448b00187d7c0435253b924c5d3d994fdccb694b1d74405e4ea8d430d75ff2a1e5dbfee8003da0a3d3b665888689a2c82feebef1f2e7a55ea6a855360ef77968971501115008f287482a144c8cc0ca9eb64c39d91fd20c481356ff20e33aebb5385aa139b20fa7b5ccfab26eab4e45f38fabf8890d68ff35c1308d0f5741e03cdd5ecf2b016cc8247587425b2dc4a0e3e4d46cf1519618b028b695dba8c8b84ea9f9758e602585afbc3c5b9d418afd6382e0ee92783fda38a7fd236b6fce6d3e7bd37e4449434147b5e788ae3198c4a8d6ed50d9d61476b02460cb3a66728498606b2466f2ae1e5b283f29e37eca6aee98a4234d3f1321eeecf542d754bad5fc2c944347f02b9d40dd1114182b3f8a6584ddd2e022c052a3f162d2e202bd36b1d7d0d28ed872ee89a3b353f084c1b4dd13bbdd04a84ab98eeb5830d1aa1e571e9333801c85cdd28dbcf3faf9007291dadee87d1b2f4bb1bcfd3cc087512b411739d76ad2f68fbcc0286397f2c6f61a499e5189f0002a33490b27c28784829382a89e1369ae27f4ac007d9ec728cca25ac6caf1c83735aff42c2f2ed3be39c0a713ec19b9d9e625ee7c2b6e59d7aff45f2b11b9cc40364b9b9c755075210b60bd85a412a2c8b2eaaa5ba5878e871dcfa3596643f4b47e4cd02379979042fe9e7862e485aeb528c4e89713700c5bb4922a76d917eed14210bbb4d51eb3eb0b9e60b4e639cdfdced7ea35a241df6df4ec1e18da9f0df46956edab216d0201eb0c789d193ac1414d4024bde00a67054b9474e1068aaa023a09cd0afab937fba5f98d181d1878c487447891a1c8a743b0b035c8f9a0eec29ce283b81ab11df22279c613c5a0267427851ad053f292bfc778b60e6a41d95ca5c8be3291f2e75fbd84effa07dbd9c8d1527656a2f8ae8c2dab6995700dcb6b71f1bc48779e184027b078a55cf81e1e418590872bdd9e9a14e2fe7e96ad351063cc109f45a83ded8ebcc94b1706196f1c6151a6f3a1d1caff677a3b55a7c5cde49119b79b876b08f66a1fa419d28419c018bda8fb7e74414a0ae344425d51deb54a18a3eff3fc276ade8d3e4551ed91bab577042113245400b6823d49e5303ed377d6ee62cd18946bce6d109c0bf5816f4975b0cb9145cba7e1cc58b9398a1b3fad479808826273fd41ca5d3e9ad86c6e1bcbd78fd0ffea3573e4f0ba58406ddb8adba6cb62899b16bd687a250c959b261186a937ed3dc99c29472530419d82a82fc6f44456d61d33920f0c6fc349b0711e80b1d893d14d12eb6e61b42f75bc5d4e0768bccb52a07c164d5ab0e474dc2538450d26a5880dee7ada63de3cb4ec5feb7d75693097185d5a49a7ddb5488ba09025c7f229bcf93890943024d2bcf083ebe4be2420f8db0c1bb4c2c47af56e3553c8694a089de328d0d756cc14956902d2a2b9f63cdf7dcecf6837f92b3a3e303409be1cbed22970da85f2c1a5dc21efc6d891612152c50fae888e2d19ea32c411cfd50d604823445c860f881e88893e6c548405a6189fb88bf2806119bd7b4e3a5cdd85036a72393a75a7a270fbe0a14681241fbcafde547e0c09a43e6094cfbd7944bf2c62f83cf62bd127f62dd8818225f8a300fe41bf4bc5602581b95a04beb454f8dcf7e269029a0653f3bd67f8c9e011e61ee32761e52b055472ea20d5b656558d11557eccd10773978d70fa02a4f61e850fd110cc76323fe0afc4d4b8f04ae75113e0c0cd3190c00067449729a42fdf168766f45ad31559ff1b92904d5022e589a08e2df02544d8abefd06899a3ee4a6c213e1d510a7a004bf3a50c8c0c8a1878fc60a5e90dd26a0f57f3dd299aafdbbf078259e33f50ce37b13ebc42d7e9ec9901eba0ad0589dce8122ad90d15c2c02ca2f637bbbea58619c3cbe43fac564c8b8c2f49945cb28994ec4c9d0aa00b9d416a818514d3443b8e1e1704e34d58c04110c6b2f14c2b5b4190fb72985a917c9b137cd439eea8acaedaccaf5050ed0c99ea3145834642ad73811800866062a4a31ba078e7bc6b532bf379bd3bc441c8264f683bee1a3e1a6fde10512fc77bce13593f53aa39c57ad1385e95cbb1743b431de1196e9addea9f014b5392523660ced34f30b22145fa4ede97dddd8aade4f55f0bd8b33eccdecea030dbe2bb971cd1b57f08c6042b6dee31681e3c8bb407928bff51aa9c0cea9cf98abdf2630d2d018cd5c37b52136854c6afa5b349a9fa1b7513fac02a05d8374a8bdc1446552b15ce624b6332629b1e97f903bd81bdde8aec0acdf94f7dcc0330ea254de7f2720466a576b27459c9fed6977e6d955e27f07a74e0304692a3884b67fbc2796ca466fb6d13fb475496de037940b4230b1020866d7d8e8e584e88b5f2a58efe3a799247870a6a91f4a839a49b46468401317b82297ce3d1225b1e137d2ba2a1ae1551a8617b86a832c342c6a2f121d5fecc6d3af5047e917078d1ef49a771c648edea2960f9a6c5efd89e0ba57a7cb7ab1aa2dd6ecd2f8c76767186582dae26d4138bab3e3cb504bc986876cab545ecf14e987ab6f2adc8af2d4bad0697bbab304c5c1d93f50c1d2c1d4402d46af0a714b41d48ea04b2b05fefae42c3f6ffd3ba57f5e475cf3229240b8d5b1bc72ada62367d9ac0e7cd6e74438f2b2e52c322605c57189fef915fa2994416d1d62cd522ba04b7a84ab1895c28182c0747d4252da287c8f13b9d7e7652be64259c949858167a9e152a4d57fae10682e64946a9bf635974cd2d8328ddc431c6b342a623711ee80c906ffeb98f1119b0e008729927d2199354e1311647779fca419b9f8414fb813521e2a12b8944141c07c8159072574b8d6ff9720b0267bea5b6eb740ef1995def9a869fb30783b1d520b22ceb52ab9c50c472d3fef154c9e65e6cc3cbf2379957b1597ff1aea83efc1d247d6db9c2f1ba089dcf318069877a895fc7757dc2567d96d53afd242d0d301b29e2ab3235c4da55648688c57208e88b05f78cebcf8b84a3fa980d2ec7af9edc01bd214aea006f9ed7e10ab6806b7b69c2aa24cb5df3c3db95dc56fe9f340ac94cbe52446dafcf71b7b038bd75fe50fbab6c5032384eeaf6e2d89add5d53cf4a18e28e8587fa8bead4b2ee61ebeb8a26d55d088a6e9101c0d657852a360e70a2c011c8a7de767134180033839cb989d9870e6cbca7a33aaa7c93b611be90cab33cf2099a1bff9bce40d25c0a59458e6591eaebe23cd178d69c70a6b35606b9ab49e7a15970ffabdd5e65f7f2768d79974a3627946576c631","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
