<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72fef217350f12da28231a27ac4e1a89bb02c8351aa6ace0efa04075e0d6657e8b21dcf29ce63041d0baaaea402d85394aca076c3eaf4fe37d41c98e891907ce4c5ed87ded46fead9aeb5813ddbc61b67bc801061fa02c99cb85fd5d9ec32428652280e55a97676d2ac30b50a31d7a46eea56e9ca0a92b0dd434918944137c7741f8bf51ace8688a28d36e899414c9c40782132a0037b8466c4855d0f9b10d7571126e048d739cf410d84027e72ecef5bf6d027d5ba008233c844be71f9d29b6bd812872d72abe024f7c08f8cf498c712a9535edda23f4e73aadf25a9b7fae1f7d72a5a24610a45d3c734d886dcdeba1c993d26b8082914f9dbea656ff64a91c499c2686c0b15b12ab55ee4a5a5c67f0c9d2f20417ef60eff6fcf7f59d3c4d9cf416c5472aecc79c95cceaad1e07443e80fbcfb58395061bbdc0110ac73c21338f38877b2d07b81008321f6f819f0bc46864608e1f6b953253b7e23f2b05f7dcae0de615b59d3daaf31efa81659c2956d3836770d1b8b5d44bf7c154370bd125ee9a793caa1e3e9685434df2c3c517cf1c9ccef39d5d4b8e3446e2cf691bf26efc8e2ebe5ce028e62dee9b5335d82755b25846b18282eca88e492be39eba2dc778f0fb51ea254ffe6af804a3b49248b11d06c1586de3c1f72f8e486d0df0dcdcbbcdb1ae95c8333cebb6013d7bfe97ce1dccc2bd6805c85033b844a93c741cc7b7edeebe3cc1661be90039b1e09feadca9d7b25525379f25b14123167b73e46810269c5623d07bf83d8b85497bc542674dda9140eac28291855df0d4d54311547f633d858297f1810a2d03572bb8734226efa1048ade45cf1c3782f26d05cf759ee5a93aa664c5c3a29ae82f20b4a832b36b99e0d8333d5a665654863c226c920740017334b80c31180ba27c64f51ad733dd6797b971193f421f7c861964c24734dd32a6f1e09c21788d8afc0dd19b2fdee626464fddcff5d0f7e6927cfbef466c8f2ff489cbfe9cc931de0dbb6eb843dd2983e0b0d2797bdee45a07366d52ce08ff225290a3b0dd9c285a4645960d6e4ba53d02e75314261b37a11c26c996ae3fc6da9be4102c79e89d8f7c494a62e6cad76c02afa5165771a64736a5cb3afe47dcb3dad18df18e168519a38a25a56a4902a38547ace3192faa07c97a27b293cc65dcec8bef88fb49b35a7905f41f12059e3520f753183ae55717f2e321225203f04ae60d467523f1bc0862bde5e91e6452d7eb1a3a22715b2b6c81aee9aa5c08a1e30c0e7c2b552924ad0bd74984d4752439270f6d9201991ac9f2fb50f71ca19bbbcaffb22c93d7c004d1588243d483e41aa3fe5d76df88f0544b766aafb82cf2253b5b00cbb965e45f5f9c2d6eadfa1c500f1a5f1c31f3cc40b115421c8eba9b4eea41a341507613d8d7300404f9d70f3c46897c1bc16fd9e433fdb48eab2d232395c839e951c76a6c1f452553809348139534e307cdea9c2cd3d95ddbfcd78982d0356cc28c66f1f3f00ba18e6247035ba3a2739f062b4a013a8394edcedad7faa8ee9818457a636ae5dcae8d09a5ca4396c35994a7ed206cfade29777c698d908b2b44d354f8564e28da9309b271400389fa18440b7177f730869e679e715d6c75e71141e4725ab896899bcbab5bed31eab6427f57f4622c0e569a86f6247d6312bb4240e8c4b380b170ff4860a905262c40cc7c1f0362812e47d93124342db2d3305ca7a0914db2a82774fc8c56986d76edb08e37782eaff1097cce82a9cac5f4b43c26ba8a642cc66066ca8a1579716b0e3269dcff22a9194355da32d54684af2b553fda0cbd150f9065801fc5f1d22966fe4807f87f94ac8630a54b7a902f32445ff28dd8eff52de7076c1fd6f40cf039c2fd8b4e98447556c3f811e66c7495a28caa76992377a5cdb8cc284fc227821c9c2dbb56e5dc215d0e61bef75475122b3fc95e9e7269fab887f476c1ff09df58ad09bd36058f4aedaa0ccb44b4ac2f6b43c49b5cc4ff209f9eba0edeb538240e21f99130dd9422920494d267f5f7104070f3b38f263ddc251d7c163242ecd98f5fa9297337fa1a4f9650152714f08eb072437ff9797046822fa043221341d1b506da61974f7c507b56270216206bacf1d863f0c3907dcefb1d9b491b9c433c9fcfa42945b9cb48a4432f65fe8c8f09440675310417c4cf8d2a56ec248d71388eac14989595ca0dfebf1ae683727dd93473293cab677b4e018042b8356f1476ab0ef6cb9b20b37b56ca9fa9ad7f3d38249cf1de997925f7acdef46c6aa3cb6075970a58cab6510021dbe0c5a4bb29f136f955fa84398ef7dba31c8772ea7a8f86f1649b997b8b7993e58fe2eba4f1bfad02eabc2e1c4a42643ea4e360af1b2e4f3b5a5f70898024cc5adbb734b0b879ebc13f8497f54b317533d9520276b8f87b52ab72928d323727ef7f1c3386ea2811c35964613587589807b6c70844ae48834ab29862363775d8fea802ac4dcf9549e36a708a2585ffaa79c9419b41ba37471a6af3288f9e6eb5fb8f5b826bbfe995b534c9479af6f7715490bc2c85929590c3e046cf48c7f73f76dfaef80b248a752caf9b697f4bc7dc0c069fbe28f5987e15d72b6e917620a787341f9a1782ef9029db47e267a6f50f40a0e0457508d78c976c6262789af703800aa9653af5e337f7602bf97e913e05610d25bb9c4245102d0ed1fac5a80c3a94b2cff47f8d65f1f8537bf4678be1cc13e157f58388fe6e0f086467cfc7a5eac3794317203025e0b97afebf11849575f5b1a2b4d970e93ced86c2550f420d8780574ed8dd683f10a039d0b0baf3f108204f96635b101ee9485177f94835474e82195eab4d5864f93b66cadaad56b8b84c8aaefe2c10686f886f5623dc4ba48e93d79dc62888c7135e1c8eff724c1a5222a6588b0d477faf12ec919b0406adda51bc04041bb55030afd6592adfab51565493def009ab45db352dec5b9608f562cb703e5a1c4e11cd664662628a91344b67a2b1ef5040907cb80db8c04321d557e42c6ca69d7eb7855b1bd222d387cccaa70f7c913094556d463bf1a623175a702e9e6463936b305daabb6ffd256dae6998df2f17eb3df20f1c0f61210b962f0196113178167a6a6cdd564ca17d70b9def5f1c3abbe1752247723a574256d309ec823e559da1571906dd995796ad8e74aa8ec341ddf2e896d048a2618d4069ae6872ecb5f978f68aa7260b4d97fa8bae4d1bab8cea133ba4d6c308ebe44011ca361d8e4b8cc4b5e20480dd0269565fcb3f34dea0711418184e75a04d756e1906fd796d11825ab7ca9fe000373d50e59fbb197cd3cf890956afe530e09d83138d27e1beab5b8dcbb4a5f81e9dda4092ed26b0f8e7770d85ed8040129e6b83039e737debe6191e9e442eb7d9bf8474726db17fcc663bff933b02f902e1b95630eff8a96ae9f44cb3929037bff7a4fbb93f9739a9d1551074987510d783f718acf20ab649b74f0d60cbe3ebd719f25b774a4cb877ead4c9bc027e1e18cf91a4cca8223c0ef4c6853c5925f746cd5c46e3e2f46248c6a5c25bb76c54402fc060f4b7db2c4a873e2a9e588ac059e47cf2c79096b8ce8706d2fae1a0661dc01cfeae13911e9c87cd2c46fa11132eb2c01322113c02a1f7438130586f6a1230e83b992c3b102ca9e2a1d71ccedab4d22516ff5a65bb5ec0d39c426f3922ec0ddc7d03439db9220f14157bfce9d9ea52e15be5b646e4223cf85882982ff48f35159c69e97b6c7fdebbcd3913a7e4d2e63bc26ab87adadb690f5554be6c9fb20b3838cf8ce9ace4adcd568558f3277cfb2e3c0826803f0e69ad5e265c4f3fc588dd4c1eb08befbca336b7d1845bdb934672c63471ded85f1cd1a8b96e6ece36a36aebd0671a1dfa39d320db9d06007825a80181fa1670970cc08af5916f578b690f1ea9fcfb21d2c1e88a7c7826243c1df67c92cc3b26c4908b09a351ff31ca14a1f8fe6d04a4252660b63b5ed383a5f0da68d3e1fbb812362b94c36265143e124d05d33c72ec8a9eb40f6735cfec0bb64075fbc62bfcca55cc3bb0fed8ec9483190715d7b63b27f6a13e493e108576152b3f91177c74b825a20721dd39f1e62174bf736b60792efcaa5fd8903fd4fab4011a605da79ac30cbde50aa906afc93a881f8790386b6f91c746f020af8ec6c8f14227c8697e7cfcede8e5a3eadf9470c802df29195bc97c12d427492a4e48be31affabd52cecfb5794999d4563888891ddcf42c253d63d099b3d977c583417481787d0ac18cea5d1561dffbaa21e96937933036ca568c3f611824910cf0cff16c2e9ff177058ad5f3318571d85adb9901761784a07cf1af4c3662b7d6060e93782105caff316456c02726f06c3c62b0c5dbcd0ba6b07a5898a148673215f4e08b223aa8f7eca832a5af257c685772214ede7d9b23ad23ab0924b13254ce790a61d5df6d8e38e4c1857abc11350fb43683dd3e03eba55cb7a8dbfccdc5ea40f70d3a23bef4cdd65adf8848d6132778ba9f909f8c4686219d8d784a2e802a1aaa9ab4fee9a2a2a2d7b3cc20f6dccb9bf1d9fea1878b4b51d9ab61646f8224927df28b5eae47568435ddac28e2d30b5e9f2ffb89b67411023a67be1139d6e0d7c8fc3a2828a8e39ff48a6706b9039f2ee75a59e1ff4a2f34c1e35f70dd692aadcda14de2b97a1e7b68c492b215bfb93dd6da2500e1dcd8210fbd5055243e274088e90af759642db1082eb69a50de9bb1c6f0c455d6b0417542c0dca675005ce2903d38fb7e9b75f7f23e61cf618ab92ca8fe9d19d07c52d9a1cf0a54b41e575ce884825d940da5ac9bbbab03a1d6029db821a973b08e85cc7c31c127f0cc73e0b0fc482885f2e3a7035226202b5cbd7094431f8413ccb3f602a10340f417cb6df2c674ac6f56d68fed50683b817025a02f80063f1211116188d523f5372fc2f8ac35dc02439606d4b051b375f4767f14312fc7437bca58812dcd37d9267eb6fdc576076b4de54613ad4acac742fbd40875f828071c409178f44945afe047438a9e5bb4acb54e6fa02f63ffd7feeadc1ee20826076a1147db5840120d48e0a7b030b838e36eb85f59147e60b2246d4e4826e4b54983c37b9e702fad6e4b4180788d07ba6749d03daf685315ea4b1f981cd2320c8e35270e2899e909fcaeb45a2db9a44aee285fe788a6d53d48e17d222b09eda09cf7eecddc75d6452cac5cf2b9dd8b832e61c1a5f423dec39847e947c5327b9e0cea91a274774b6343dbf5c1fa01897f56f3d7da159d393a9dbcbb4da20556c792cc93a98695cca0161fc838c463d9a57f998d96add72e7449bd877dd8a2e3634a13cb471a943dba52e162e27dd68ad5a99af4e7f4799f232e34c41a2a944c337a93a427b209ab0d5a9a134ddd60a6be8688346e56927aa9e7820abbb4c261cd540ddf78f542fd9ff838c0b1b7b2a77e2c549b338c5e9edce2e547a5cd058c5a1fd5840a12d0ac85218e1ac312805790bb01c16656674c94e5a59ee7fc618e380489c66132e98d2ec8919b5be5aedab852abb75a388cd5ba4466762af338064eed34fe973c5f83f136308355b3b9e65d2ce99a58125d361ea9ad122bebacb81e2175d777a2855c2f077a5a5b0f61036ecb91d0cc8d425285b5f74d3855d02eb2fa52cec1a39aabd388f29cbf3d953257754060e50d8e546bba47cd8a9505f75f4c7be91372c302e97e714d97d40409ce6688b61d87ddea069823229530696b8f161085046641947ae7db8724e3e8b217a87f4cb73aace8b5ecf90c1b29d1b35a61ace7194cd3001092273782ea9d6e6df71601e02d80320dc08d8e6968ca974a8e56462eda746e4478a469072291a4e2f8d3802acb0e9df60577bc5cb677bdc4a9fd15097fd160b456a184183dab2b4537861ed964eb4653a73f22d36f2161682dbafa4058b0e4e1989396902b3708b7a21bbbb8bf8e3db93ee7ab5f37edfc00830a8ddb653c7addcee55170156e3f326fa0c7d1bfb1c3eab71557d4904679d2a93fc92d1222ba289dc8adbf510ed0c641f7499e2f9e7e17a91cf50eaafa9f0dbabd27504de2ce5911155fff39426131c7606328843635ba93ec541848acb77cd868fb097dec61550f7ce5507071d25243c11dca2f0ae2980f50a692640e28f65d2bf4650963c26f64e2bf4de0213ea235a50c4e822cbb27a286c46b885c717ca0376cff669c23f354e9acf52e0b2e4bb4e382d2192b337ee31c8c39ab0e0b757e82e3a80073166b4136fdc50dcfc51a3330b3c56526091521dca9c9e0f8f93d362c231227176817e6738057645f4d3a180c0e6d981493adbebfc87f921de72e10a5e802d115f97d00b85d822f87ed9363e7add401b5b43487c79cee72488e7eab9c5a1111d28e798988803eb64898d9d990a556cd976fc7ff64ad4920e72824f0e6f059318c07a529bf3d7866a2d00977de00aaf2eba9bb68f47efd6e01f95aa965cccb876b497f316c7e07e6c3485458d504e8502a2d9f4b82016a0070803fc1bb8de59c8ec4ec2508b72ba0df48a3695c426a844b79d9b4cf28541d01664ab457d95ffd3eb29358a0f6192509717f3203699f1a5618edb36ce9aeb6e3594dc94f112a7856e81ac1bf2dd0aea330ecf3f8156bf7cb2da899d2283c249fb33ae74b3790b8f25861787c117030f1817cf60e725329fd5161c6270c9ff21c34bfc8cb697fdd48a626d49a2e71d8bf93b7c3688ecbee2dbe3c80c4ad8022b5c9594893b777738b7f93cf23eb48e5adee50461cc062377bdcc568330b7661ce0e1172bf2a5ad703197decbd0bfa116c13fabebc4d1b6cf0bef5bc2610a1b5a71b662481f9afcb938b9385135188044d4495841ec95953f2fbcfcf6e37b972a93710a364ac887ed446e2b7d0c1b1b8f2a6a256863c9a569012ecbe20820ba480a583bd7bda75937b9071eaffc6edf4fa68ef504b8d9d1209197e37d821039ca2cab208d7eddff2c3d2dc7d01eee2061d0aa6992c7f06f6ce14685a0eccf511ba557180c699c4c822406a90d8977b8412f125e5142d243eddc9621eafada6a446a20ff0bfe41a1faa06b4140f8f892d20c636b3c70b4ffee6e94c575bf3ee92d7552238545220582ea99b92ff9251e667c1cc4ad61a9c0b7be1a90f4282ec3d9806cba8f7e17dca76f9b34688eef0a62375c9567e0fb362ddc3a24606d7e06e70193690bb9e1e2b46b000058189a450a17e2c613397672d292f15f046c29d93661d9ec32157c1218f561e63409d697f450e9a0f17be95017c2e572ebbc13ab12dc0382c1c37447002c6d8c7bcd399cb0a85c289f6e9929954e73f77b9902eec1644f965fd8dc619af8692e0e7cb9f04c4a2b9dbe760c02fa1127f7e4f10239b5e5810163ea95b0363d86ca31353171ac135b219c8397edff121bedecdd0632f5d3ab96c8e942de26b6f4c0df638520f99a1a4da589e67b86dc945a4f8e09031259b9dc9b68d691194d07f1f951c19d4712cb09fbf67f3ffa4cc898c46411cdf0d9106093ff4b9bbd707209b9ce9f46b90af991f8da8bd8abe25f77cc7b2c2f2aedc41fe6c573d67eb1119df3717b561305d72376a37b63b22c91dc9813402e005cccb32dad51cf66d1c40c4773ee62f3ce1edeb48695f7eda90ba61d7ab11cb571ce7bc70b995aa3185160ea1a8911cf20ccde380738dd47bd4921b33513ad6180519cbefe24cf4dd59fdb065db0818d957b7a16efc008878765ea14baf3bf8a3cb136b15beec5a59de4fb79c6380b1558167d808bf12d8d4b44f2e11aa3df3836fa82bec4782717ac713c52fb83caca6f14c2787ae8e79d5c464dc643f7a201406bcae4ffb9ecfc36e3a6ecaf02adceb1d6baf09c1d3c5d8f7d4b26f37d55c3bb7783c938d161799785138187849fffac59dbfcb53383cc541fc1b8eae744bd08152c0dddbd06e9623ffe3e852fb927a2e5199443e86bd7a146834ed3e0287443e732a62fb69af689801f82214471814277a5e3c500ab0f329cde9c0032bf879e1c9afeedfbc6edd2671457e8a58e91dad20703672753484fb42924b839c103b1aa7e6d500de519a1a6ef43bfc28ec91aefde3f91389a2d8469ca7a7500481509a7a9da13837be32ec9ff222aa2298ac347b913f213746819eb91ed34fa2244004817982de6e6a1de34c1d588ec3ee4aaa8fef33eed6d906519a9cd98e81911ab605ce1a4554ddd78a971afbeaef3d7d5caa1ce73c7d0c790ad07d9114a2c1450ec06a2446dfd7d90d80061f7541c9ae1da86c9beefec7b610399ec0cbd855b5eceae00d763b12715037687d8c3534d813fca3c8bfd473115f0d466ee4ac99e7f14f1b8eb8d274dd5746b009a34673437c9409d1ef61040d7a89212f862bd0d60dd55e995280929e86e237b49351b910de9480e4dc84402d7647ca34a5cb5e3d764d518546f712e348cf5fa2321c24eafc3e206f9e4e0c65b7a0e9d25ebad45fd9fb83ee336efe72159f5f1c1b15604ee8c27bba34b9ccc81b34ead8c7f6d685776117d6b78cbb6f643c6704a28b85dd0e662ad11c32ed01e8e4e2b029906f29069f53d1bc2f32209f2eb98dc95ceec6db04a35f5fa6066700d10f2486c22a3c1076fb8dde14c8cc5f2e2155dedba15d9492493fe96287ed71a3b1310b6899e3482a798b9322c159cbe81d0311604930769121b36dd4042950805bceab25c8311010f53b78870712618e948f7f21f5e160fb0fdaec8aabab5a8417e93f4f431a1396d5ae66d7047b2caea72fe80f09c28b2faea2e999da3eb010de241b49be90c0c849c06e9f241073760a900cc1fe3eb91bf29fff5fd7d543032445658748bfcffa7f0f08164c9cd484ffcd3508c2c6dd3407245554f54a218fb3f8eaab82113a7ff663cc5e12d9dfbef967763dc34e29ff0a11f19a784b53c094b5999be4c8bc2d9cd99cea3e628126219674b7ec73eed6fa3085322a7c536e9a468d911e173c39b7534b01bff215844b2f332969219600ede79c354c2b518f395a6e0bc12865b7dcd854446ea19760cc195c977c800e61fd8ade2f4e3b21d4a981bff9870db11dc4d8b789ad455f46f3e72d538f4d3ddd0c0fd0c1802ad382faacb50ddc425b948936770c99aec294a4aef8e5ea38e981979a9e4cc1d349981aa42c73f8f9d28b0ca590afdf588cbdbcc65f2de50c9d5693d1acb0b36116182b1d14305a74f1f812f74e18625d4295324612888c60d52b1733be61fc02fe60365c9ccc0c833d36771e540719e7ff18ff35fd73d414f1e89d838f12bde49fc64908dcdc6e2d9e06c70ff223f7c6185ff940553269178e4e964d797bda76a008134bfe01d2983f043a9e2dcb2930673d45d809d04c901b69c26c146d42bde2f7c5fa2d85d4187103c75d21876a77bf22302380924bcee22cb3925bcf166c3df966118650dac1ab506ed3d5e9bcfd542873e6fbe3c9da78f9cbe95301b457df7e72cfe2ac20492b1af27a0e7ea33c1c4402f987b3df70bacb7b446a8391784ea20b990408bad0261f0b5d504a759eefdbc65488ec22a03a7ea309af8f91d9abd36b138ed60f7d0abadb89d7258a236bffab43b76fdf33acb3f65f534c39fc0962461ae1d494f2a0c85543c6a83b1353d49d87ae3a5094ac3579e79855b51b8e5ce1e26d643247f08615e12a289ea965a6798146fff80cfdc2cb03a3dc1c264bd0f1a12ea0ce7b2523b4a0d614ec6d9e5349eabcc04f90b98772f057d516ac740635e0f32fa71d83c6ecd6d5aa4c39b40c76a020cacf9dc6bcd111d0f64f2ef315c83c40d5ed0ac195e964ca92bc107ef8c438318c34ffca349ee1e848f06559951fa34851f1f27be740cd79dbd4ff2803f8ef7fa91dddd4d482584b5e34b54e16eb4fecfa489be5855af04eaf69cdb048d08a4fef3739b90e1aa57951f034fbf1a9dafdc4ccb2529d37b5927f8c037af59da38b72820e6df70d3100314393ea634b3936997577672e92a8f86d9362f45f0a84f193435d4ece882cda4d876a14b871903976975fdc08ca5fcbcaa77173243840cc6d119a253d94b9238ae5ad65091557a06b80447d290ab7314a92e6ba7392cc9decb2cc8474ebf1aa367628891774f9770e7b7d0ea37a979e2fd2ee4fb4b6e94ba3c446223c4a953bd2d86d29ae91e1755ae9ec3bff757d17a5322999be2183890f3ca48fcd11528600c6a2559ce673d65596b44252fd4193803a7f18a6f6e4f1bc4c43b26e288940fe50036f15875fe21e6aeacf312bc493e90267b401fab440a30357e0e3e05ba4bb080a8ff48ee99a5d498a4e0be17231f87c397b027ee6a1219576c31b683e4cd64edb797bae14b592ddee853d3ff30caab9c0ee200b3dea37a9b47bd08c06a32a48a4f412ad89275c8427b1c9085f5ec0585a678fcbbd4d1166f1420cb1ed5d2cc408635e355ebda4649457a33857f615dca9a65b1c6747bde3f63ab16f55ae008704533757b31262b5aec88f4a0dc38352b767639b4b35b1ca2c9fb9d70b0c327a840a6a186d381560de31955ab5516966a983b712a0cfdf52ef57c410b7f4a02c8b69927565e5ce712b94712f0654a2aa98400f31fbd6263aaa5886de99d450dd42adf4006d4ca39a8d01719831835f1d52338865c1313e0952f3ad9ce1c59adb81167cf5238a37daf1ff5722879cbc502683dacb519ef5b953248aa43300168421d872af54d1604a6dc7093d972e4bb4a6bd469e0a544e8f4aa21861378b9d00fbc64450428402714bc079c18a4590686a68fe2928db94ade473747dfcc393cef8039afc600dd4189b15e3262f7c5a6f0ffc88e622c4985aee825f71794e8bec48b027f29b2dfad35b90f75eeecdaaf3921190da91e284696cbd56c99d23fa01ba0d2114467d1e81fc1f9bcae0484494b2b2c7d85745740ac14a5346a0fee405e2b58e6c27f5d6a1c7c007e859134f2fbb9a26def1163ad01962a00c8fbd3455f22e10c362649d5adb4f56bea8c2208b0bd16c8da073ea6d0d7d3a02cbe54cf6ace6049e2e6e5e50a003c77faee4d7482dfad31bf7d75f736e4075d6bfacc9657cc7a38adc38799b0cb3e6e620815e056aa3ccf57e4f20dd0bd78b5c81c3aedaf000594bda51caf0ed7644f843f9dc4b5abff2ec2107714b921a3bddfda56b71f059a18234aaebb8436a5a91612c9151a6ecba9281f64c5a06a6cb67f3ac4d1721c981ef2e752c3ff874bb6e963ff6ede646e0146a01d89c8e9bafa36c9dc38dc95251a590bbf7aa07ff79d99325ea8d386630b8b1bb8e3d4ea2e579d0042a61d30552f907eb5c42f54864761ef39fd59c6835e9120f1f42054c840cde6930ec90e352cf9ba518a76c19225dd131c822de09b7df3d3ac8a3e63bc3b0d3c62ba5d682197c28abe015e8b1de9d43028249d911628e94583e82951c15b83f72782b10b6242102d7884d1b0d826dca602bb6a0eaeed06fb8b5978d312f214f796fa1285368cdd3558fe3153d250b39c967a88524b8a2653cbd162da8a35dd905b9c9407a74cc8613eab869fc4cda03fdf034dd6e3afeecdcd0f890e8329d7153319e098da7308fafb4948eda8646a2b965ee2c9a54d22fbbc7254c0be7217fb5637969ca3a871268d812d0006bfb6293a644008205801f78b8e08a64cbd37618e3a6a62fc5e92323e07df1ab85b301ddaf92211cd9a80574c9e9828154c35bd2c05043f258da6d0163b1bfdaab811f2eebae4a7020bc2d7d40149ab71da24e6db0310aa7c9f0860f63afe5650a9ebe7961b40dc39e797e39589f2a259deb8db045848245a5063c53e22c20e09c4ebacd5e281e0c75d79551dd0f7344fa897d6c641a3aa58368c92da2a6efcb810ceb887215ef402d97ae04a9762d4e414914f0754d97924d97dea8369a389537af8674321eb4173cd1cbad3e1eb5a7b2310a9289ff4ed9dd964050c067629e49bff04f810f9cd1a80804954c9d8bc76d8b86071a13c941bbbe46507c7a23c9a6d5f5d6910316a5a2356b06543aab01440d540112eb36e464392c8acc636256562c5669d052244a1ae7556a14495c6de7845a469d5019a83e5986de8b12ba0b4470027ac3306ba090971b357fe28696abf69fac1deb1695d4898738379413e13de1998d415a62212309e758f42919a974703a52ff7261bf4e7443cb0ba351fbd00e5ea054ab1f9f14d5ff9b2ef5a36502ea5626c6c0d9887b6cbe2c09c49aadcd836761d9b1fc8569215a9f716f5171b58778fe3a04d09f5248fe1e0b7f62e2d42a40ce4d62a5801e6de1f86f53ffb29f3b8e7cde55dd6a27f1269c94fbdee0391a384eb8ed8fb97ac0b34a031051914cec664b67a848232e42113c66dab4979ef2dbddcc5c0b547dcf804049e3c592b1de9d5a2b2479d1ecda4d836958672ee5a818016a04269833b78e7634d3861ca609270fefdfc9cdec6ceeddb578701bb3a79979822694674d777c971f234e526f4634adc46c337b7d26d69370d83a0e17b7d27d82d8b2cb55688b8e586002308ad707f965cc307dcad9f00592805179827f6ca04b30eb343b2f39503690e129adf82609181356acb2bf1a9fce55d342cc90ed75da9d635a895f242eaa7625be7bfbf198289bf2ae3b8e30600f0270704a9d121dab483750849d1cb3e9e47beff6c58ddefcf7c812c3a0eb1db11ec543f3250c978973661e5ad218c769a05c743d582091dbcec39be37f76aa60613fd2e958c2783fca09009b082a2ba3f945e248452f0ded806451a2f4376b0f4a2f2116884460939bd1d82f3381648d16410535ea0850afaabdf5e3e837e008b7fa0fbd7a93d2cfa1b954cfd5189317165805c6436f506facda0a885e27a6c2914e222f0bce27bcc3e4eba44ca9b940be0a1b6bd14b44394602609746caf6a4cc045219019a5bcb788b67e4062ab74e07ba48db865a2b3e48e04662c6b39bc5dec9e808163f06b089efe0f950cbe7a0c7eeef0a6a41ed8a23e16cc736dd1583ce119b6b52a6335f172a71cc6c7c1db0112ecf95445ab417934313eef188ece97c7122f213257bec5e25e5e83cf00b45b394b145fe48351e198fb8487756aeffeb01c778412c229fbf1df7e3f07f263a94c304d861c5df7907cbabf9b6fbead4ed24910c078a67f00c1dcedfafbd29b702bc6ea9f0f5eb0d72b6f4d1bc7cbd8dc6ce8c9c2f17aacabe59aa94e6c7e41d8dc24c578ff3d9aecfd90b8ddc2ae23d28ae46e09328c43970c4ed688054b4481a34fc3043e7e2804571c9155590e248c449c76c729e0e0a04078538ccff6443d27ad13440650a6a1f41d531adaa20a87b678482acb059de66f0f587e7508ff9c2935033a35441353ca2ed819f1cdd63e4bbd1011ff6c0957f13a102f5dd5d771f289d617d99a0736022e773f8fd6d8c752751c5fcdaf2c696704a0645b0301e203fa1d6183ba9084228087487cb619b01ab7fe220d0c90c8b4bcdce5eaebb69eefd7570c3eb6538b175e2079ecba623e478d06464226a1779aebcfa8d41f59c7a2d168677449f8400fb443213d265249e7c9f9abed81b34b686ebb4ed80411175188fac0e8ce7d4689f2c84a38dcffcea9f9d7d61e660ae3da9f7199b4c2a2e680b7f41aebbc07ba56b2818b30204daf3847ef15acafb869a6ca656a37406326351eec962550d4813d20cd6a862b6a2732af38219e37e9763c227ed0eeda2bcc4ab110c1fbe1105c33a9c65535f79836af5b6da840a758756a042dd4e73a4df9f0bbdf00bafb1c319a46a501d39f80582496dbdd53d031ab5c3a9e1f78b9f5c9dd8059a9b416a0b239fad30fef0d3476ec0acfaac907539a57d903045e4b0894f51e57597395edaaee196b016a4fa909f66534ce46994565bc8d22dd82e851e0a9a62afcddd61190cff97ca3b874c1abe19f13c8e03a0d562975cc215a953cb75d502b3c517ecd7e489a5098ba1ea7066b1bdc15ed8f44986fabd9d3dbde2dcb5e89a73606d7c33daeaf0515e8fb0159fadafc1d4548fbc10dd037e5758d48e8062fcfb03a019ec57995c3533b8c5802336e6f5e5dd92bec9ad9a82171313825b400c923cf901474098083bf8c6e6d10e348deb20783e06af4762008554c9b6a1f14e824939b8659bb02e3e5d9e6430c8bbb110598f68d6b673857c6cea31e2225e79da7e9392d59b246c17a9469ddc5ad919e88c467ffdab2cb9b4f9ceac8018c23ade0158d56ca945abf721d447ca0ae96d7b8c664f25fe822bbba08dba59c304454e76420917d06bb936e994e1491e04cbc60f0418dfe93512d1e244ccedf837895fe4fdd2540034f25af213545ae7754721d5b4795ecc256b984edf4e409f3f0f02cf15ce4df5104cdfa4f0c2714eee4120b2592e1ab41a9b7b94d807df86b21d2e36d5d20e38f137ba28007ac8fe118062fe8f2be6a879dbf80aabb5d8a9846c7852b384f0254a8ea83fe10e57577b70dd3dfaf32230788d2833587e625792291d021df263978e47364527d6fa85e7ca5f3c63a63eef6a41875ac50e02cdc8d0ba25f938dc0bfe3bedb4a0625cfb026754321b47dc1bd086c6b9eacfc04a5c6446e89f1fc1ac896586ac488bbddd23ac87b96386d4593b1e6bac3ed3b851d39d9fc5d623d5dbdbaa23e157c6b23c8781e941cd3562d3f90c33dfa7f85f8e0787e5c81e939b0c53623fda4e0b35e2b967f2a8edb7f5976548f49eef16701d9d1a2d050a2e2a96a07970ff3b6f440b7faf38c76c99cf32070c7dd4ad6325b68ff065612de883259347cd1fa688919f43e3af098caf039f6b46846b6dcb6853c96aa8837d87b2985798482a4ac25d223e18ed9ef7fbaa75ca896e41edf529cae8091b6091ae7b00e1b72b0cf37123cf100bcb8883bbd4a3ace1032352b7cdfb6129e41bb4fa92812a53f0517573540de434a65958d36831a69bfec5779c2947f8b5f1f6d64d0300b45fd3a4d92911001a545348a6448e2245f65be79ec9717d1fde8a751cdbe8426c7ecde90a2dea1d6f6d4c6c88b988587f8684a2b581a5be5dd9a77fea1deb884cc1b75dbfe166394c519096002f5cab7095d46173ff5fe9b09089327ae991a99a1987f601ce28d3df7bca05e083ad22204b8e0bffd8695549c91fd9d93af5669e287e1c94c129ef954ba5ee83a89faaa1a718f80ef031f58c0eb66139e21082f5c08154ce8debd42cfb5fa42417862cf844875026edd7aba8165f4e7ce4bc80f31716da9e9695884ee575ef092162bbfecaca816b3bf3c4ed802926f86cd5ebdd01328c684ba4e10fdd67653e67c7f50c28242071b399400f0da703286ca45bb62091e9ee0445bbcf8866603d32d0110af55f674b301b3dd48929f3661efad25d850cc9ac7ceef5456d0f1be0c23e22bc53d38b793910110482eef839cb0773fdf02c2ac4c063d42f2d7b50f3894074dfaf7a9da800b11a22de3d595a62c0ffc95eed8344275f84708ced5c2f69d93384ac6ab8cdbded372d5bb675a140d17caab2a6e2416be65c9e147cf79b1969b239b8d0143ae24755fb7475c9ba9dde5fd95b189179813906e0d88547081bf614f2e96598ba43e682453755d13a0ee31884a01e8ce15fabcc5b439fe72687d9a15f2fac50d8565f367223ecac5f3e06b0a55620ce5d654cd0cca17b2793d6c115064a00530de180838dbd199c16c31bdb0ba05b19e5b8764682739bc253267ad8db32b544e9a503ec2e64f376fa67b9f717f4cee4d907f26f6a83d6fdfe2fc373992eaa2382486da2d3fa7dae3afa59a6b2d1e975fb67cdc76a70884906ed79992b728fb34e2c0f19d598ab6b25e44e629a42a87da53504bf448515a5720607cc1866609dd910a594c62022e4872ff88a399e4fd3a8e9aab3f0209f7741d6aa77b2ba5103c7fa6139b1b9cb8426f3aa0fba27eef737ed9dcd4311bdd3ff20db970551e6eb1cae0831b3ec574349344bb7664e08aaa2d58d8eaf33d0bf0ed406b827a9f3db4f863d3f2d2ca1ddab69f10295c63bd4c39c7ea10d52eb218180caff5db3bbac81ae83e21d862a4f984a155658656c779682ff5bf81fb40f72fc54ea5a63ea514eb96cc70d6988dc6bd576ddeaee80d44d15e7bf9259b5dbf9755da938daec270d4db3b0c4ad5ced57813b125ab457db2e4c8ed85f32473c0954ff56b75160538a666cdb1fb7152775726f21143d5c34a980ca2e6410b19f7891c948c3a496cc23ca2df1c49c1e96837438edd7e237e72a77fad9b11dd4dc4199b8779454797f3fda53a504b7bc24e6a93373063f76edf215b42e4f0dbb67aaa0b571120838a3b325e506d2a3121967c1a24b52bde2b8ba436c57fc82dde46418addb94e2bc18c8536430f44b859f6850a936c0e74ea592ea8394d164db65f163c1ae467933c427df92a4c31abbdfe2e4b8962cb149e0c5fbf0b828e815f85270ebc14d4ef44235bbf6fa6ae497e239bdad89dc38eb7d56c163fa95e820061ae836c1a8073556516d04e9268274548e834b5bac71a8e00561c92b9c3a7f16f9866fbed0af47492ebc241490e9173a60dc59e971c6acd128db7f9158d39dd7ed267a0a90669f02de7e0ec7fb361ea5c2bbf650eeaeb5e94239a11a0e3035ecc8ffd3f092010c841ed031f296be5820aae07172fc13546f283222b0ec759af2ef34cd0ade305c91950d5b9c8df995f4763466f9f5a97532641953048e171c68f95f26e2c7004fca6deae0068cbd5b2c379d09d12ef2399585712b0a7c9c2a17de3f4ab1e6e81ed6b74ca2393c2eda21e4c52bc9f02859337d86758337cd7d0c0cd8cb73531c77bcfb53efb9d67552d9cf6ce7e85f508de1d2f249f25def525c8fe8ea71733b58addf9846b5cb0c7f427a610fd09bf18a31ae5585b004e5947aecbe1e51f0c866dd9fa6c980cc8acc999c51f035ba068a3916f199428a82b5dad2b12a619a82719920833ae113a420f0c6c1164b2c427307112b8bab331a3368acbc8b6dedcd66287879fa9025427a90e931b7fd9c87145715ef41cf43bb4d791fa1191d02856dbbbd91bf67960033200ef30e57c12e0740170a39c0491e33052a6bb45f9d25ad208848c52ecd7d7ed2b0b48afd6a2d095001733b01bec54b7a8c4125ef8d4e07cd6b4dd74b2e5bd5fe1ffcfd140535a824dba0532c8c6032bbebbc9848e1de43d4d6eaae1cc494c7f61b19b0515380e5e944ed9cd0d5a137dd5752f168feb391328386c9c1a999bf779620b53b7d15bc4353bfbea9174bd1131c87fee46df22750888b17d1a3156a01d7091b23f31f2ab48644b04ef7614c785cb13b498018b96052a3d1ff0a98ed039ae2bbe6fc37d5b44ad1bd202dffc0164fc6d501061d66752314be11f1522dae54bc749b2f17acaeef1a0d2d532ffe380432802de9def40d3ab097f42c202bc8aea0707e86e1edcffd0bc8fdf0494550c778d604c7dccd5cb3cc9cf88a578aae60bbcf668c2e1d009170b8e89e31bbd9089a67d39590430596d37cbf1480f15b61f9f4abe9daa0f7c2f4e80f5854e1281af7b05315de2882bac1ca2b38aa351f0c56afe98e34b1a4e1694a012d75f2493e889a20cc9dfc08143cd1f81a8ea795b0f478066f9d6fe1d01b3a81db74f7ee047111c240a9475ea3543b19ddf0232a506792d076b35e1fe2d3c79f485541a262a3e968cb391526581ec4decd8c1e1b8a4b6ba4de32e08e297ca9ea6e4438abbb9c6e446ee9a5eea75008dd5dad5ef642dc3ea052f1e39ad0d7cdf67673892062a8607ad908a01416df315457cbb2a1bc62cf71ba78f2897c82d821eea6672ba02e329f0d4c5c7840e33de1a08236258fdb5137971b9ab0c2ca570dc455cd0e7cebe09cadfababb83ddc4e5ecf17f5e59fde34b7a863140d475465d0b0af68617337c9082457be4659577c1942415d830f1e58321164c7a395e1bffc7353c514e67a8e2e254e5b3722a52e235f4c7d9b2367a99fe73b88a0cdd73cffb769b70e6c16d385aefc6a9b73644f4596375754e3561e6e780f7168cc9f2c54180d84505c8e068ed3283f135dc0e16a51d6f9b0fa50d6d5da8b212ea1f4b935f6cb27ca04e2ee64da882157bca2ce39b2143d33e23b267e236aaff472290e5a7a29da103cc24227a0ce2a2f96a48a9feb183f848f2191fda77b0687ba7a890f6b520d7cd9b94868da93940344ee05879c4f670351fbd5a6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
