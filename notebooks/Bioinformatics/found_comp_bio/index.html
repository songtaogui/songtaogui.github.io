<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e3bdb35e9d98c87c6699c2f6084ef2bdbca1a591593a9afd70d5e9d7263d2ca68fe8279ff70a807ff3222e413868d88a11ae35f1ec21f7aebbfbc8a39aa1ae96115885779dcc7723c43fa57da98c00cc83909b13406f2a161089270e2bfd1fe05ab0484e93d164caafc11fee2a5b598fa7e4e29e4c532de6e82bbbe83e2a1ff3577eaa91d4ea18caa6bb02d2c46edd1b6a606a48f213dc613b6fb20af304e5b94250ec62f1432b7802f19c80bab3591c0fff4a38a53d4424d1cdc4627057e8255cef9bbc59ac8f4183ef19f336ef581fdd9d03d89a55510b33931fbb92ac4b02e1d4167d677a076f34c6f646dbe4f14d65291413a121b23beaf073d36703fb8a724f80c5e828bea52889301c99c2d38ea5c960f364603a8b36b67ee7433cf40179dc80b5731f866984d6238fdd97344bc9c4133c15adca39c68d580ec28bf4fe8c5df71d72f2f7df853d3ffdcbc33a49112968b77d39d445130c7b460d5111e7a8c48a760c48366c4c7fe12279409b18a60aef2cbcbfb09dd82cd56a16ad939e061272cf10d9c8970790a64a8942100ca6298f93ce4354e1b7dc520d1120b2ca267c189d72af2f22cec36062775b08cca0b64db83a97efe3f54c93d8156ca18763e5e8acc50794a8858398ce27031f72a9ad3b56cd71cbc4aa036c2e8e27912fff895fd0c08c714b21a0b78af3e82249f413c7a7e524385647234f1e479e1f41e5bfa6d502bccc12f90ff861df2226a6e82861b58fcb63149f404405b881dbdd8fe7d1a687b2c8692c6dd92c7b9d76a5a0a9c09f8028582df4a7eb51bc9d7aa03bab5bdbb4c0d66e668e172d9c49853d764e73e260170b42848a84f484e63912d9a0f6afabbc701211bc7050dd44f93ba6f8cd9715b5cd213f3306c7d0fb1e668640c3df40a61d589b9018ca95fec3279cd73903a14f14ee467c4e6f8f6d0cc6279e8c80960c0c681fdcba87a06a6e7746fb019c747478e4f37e37ee48d69205e8ae5a16cf9d37c017678ffda96f5613ea42ad6f0657b284be161fff40780fc2a9e04158accb59aa11e60ad8676c7dc1612aa2bdc65dea9110e696a20ecd76d73e54afb4b72fcd6f6713c536f960e168a8bcc077d1aa17cb7d65670007188336348090ccc09aaa68138709c1e1a91e34fbc36b45961a5ccd75f63ccf3e7bc9e5cba5f509edab6561c375132eb247dd55e3c209e79cefc5c5c9ee02edb18c5e5bd9f1b827aeb0cb25d03b2232141d830bf7c6f46f153b26c57b2cc0d09bd770bd6ed69176c8e34ed6949c1413b4b07392be203e0de87af60a7ef47c4296a911532dd49610603ece7867ceb36c17c3eaf15bd099d5172802ea52761c7cc86010cba78f367f601571db7e7195e41eca70b337b9d2bc95dbf777064db121781f90024c74f3e3b2de188b30851d104e8ff42655fa00c791e36fe257be6075d8ce2e027cd8d92d674ba2100a5b752b67ffafc963d5b5baa724c1c4bb90e18a539298f87bcb9ee991623fd1c2f580a3271bcd9679f37e2ea710e6f088bb9bbb84f6782e5afeed9044a894f65d2a097eca42f3ff8c978f806afe5b93bd63b0ad4f15de402402475286b02d57e41ea6efa290ddc7bbe3f9fe4d8ef22b6fb21f387445c7783d9caa0a2141ffc369f44bfc50ab9208f215703b0eeecdcf9f0656648c7598c23112f9c9938f9936dd2adff8f89100c361ba92f653442696c26ae98144ad2618692dd615d86e44131cc17d604894efb10f8d78f2b1680dd7a975039ae85ab6c6eb5c0bc695215e95ec6a6ae7be29072b74667608c32edafc4228778f67b4753e61e1d568b69602e5cd47e1aa867734d3b0be972a780f60fbb3b14fa245fdd556f179a1881e2112a977cfbc5e5cdd4486dde0277bdf7171c0a099d17fe8d9a14ded1a0872ba9b28a66fe7261bcf6ba541641dacbf8a867daffc5eb472116cf36fb967320f7dd46bc6b0baa7b668b9ea20fb46ae023deca53348656f38fedee9253891ed8bc81ba7e6d68421fb5699dc03d187d5cd5186775a203e9750424ff273afb3adfd801541f17353b9cbbfce993cbe9f86a8360b62c6f3c736c7c89c6bbcc01fcfeb7f24e34931942fa0793461f7af451b076500f5924fac38c89a22753f39120511a2accf51a167d48a94fe5955fafb93abf96d2c0b5d186c130c4fc02a2c8f8a9dca5ff9473f6fee069733d392932228fc8b9581061f562eb83e6dcf57684cb1c0738ddae40087ba6d597846b55d93796592370bb672a06000d5493ce4a2ac2337b79b2a0b65d812e778e1915cf622919010f7e8e10d743b07f4817c5a77c0dbfa225fe2a90cea07278e0d81558504b9bdbdcae702a74f71fbeb9233f51546cc66a81aba2392b378e719ff993bdaa8564d38e37b453e15d63c0749dda165acb793575b83551afc7bed93bb7ae366970dfd4d28bc75cd30e27895c0eab5bec6120fd96d131d60cca396128a91f34715c70de21bf9abff42c8dac3efda56de236d722c03d9f3b47e1e30185aa0da63f54f61c0c3afe9a082df32de080215cd78eb3c9aef728a85f0d2e24cbf74758470488f29ad5fcd547c509ba0f786fd01972525b86a98ed2ca3ef4a853691e18c7fff5c3fa6185e7080e76e99c6a33537aa2680a2dd1bccf7d43a8f0d6468d9121d3dad266a1d4b8076607cdf9b84148da517c6049948b75b1da28b5797006a207613b1321f3e0c9332785741f1c2c53a965aa8b751af724c257b9a1e76f8645e480477a48a34daeccd9a7b2a126e06efb3c42d6347fde85c04a92ae759068784b4172ab8ed9eb4d1eabc4a19943c14cc64513a7531e30f39a643c9aaf1f4339d3cd8e52586ec79a223f79aa6bd00c23733d73de93df5468b432b0c72f062f3eb94a315de590dd009ee6cbb7d731ffe7a19afc26b435a36b0b225ddea7642346ef544c496b36ed555f3e2e3399f1c62cdceda4e6ae0ef1bf1ec322255638491968f5479ccad4bfeaa947c744f9ba143237ba316b55184db2c17503173b3d0c5f6bde7812665a122c84ec2733230af3062583196e92232ebbe1c3bdfb277c18cf2d5fc291baa592ea22a76f0e2720f5d080e638d852d2b7b3def73865ef397da755f131014ca60e40d8076c76419f712bde9b736725ddcd1c564191c2641ca6e3277c88649fe39b170b5cfb85f66eb7695b78e931312214639bf8976545d8241182fb8aa447fbb8a43650c8481c5eb877912b83883e6ca3448a0e1898754d4bc30d635f49c28f5c31c77087fd3738528c480813d3bd27dbaccaffc926df6d3abc94fc745683a33ef1b35db82c160080bdf0f289397177f7c5de3decc2e6d942d04b11ca92cf38a1c9b075445176e08a605f44c92fd888b4310dcace5c5ac3a1b533762b9be2d7a8751b130b629e216be633c46a85e5db774914596bbf6d706552224074b1c80ce89d1dcb5bf7327e1473211eedd4b07ae84e8d9e1727b2a3a19c1a7ff31c84cafc7663cc4bc841d347f9c7a6d87435be7c9ffa13795e8818a7d6030bb3de39536654d11a6a2708fee3fc256234626f6c1adc3677fa3434a05b51d249fc56448002759607173045138c3db5102748d82708bc51450d5243b09c7bf870372f98a386426b8daf4e2cdc50ce3b65ae9070eff3641f111324dc28d6f814a837c34c4ffd95eda7964c6340e74528f5cf9c06d937eb63eacdea864756d4893adcb75031c5642333f45d6510d4b3cdeb325ab795add1b7420f9b5167119f10d2d842042f4fcaa95ad73b0d38b6b5a7a200d5475ecb89b80ff5e28db83e72a72fa33318d9654a735dac22ffed1d4286322430ebd9002f7405a3ce50c9521b488b71ecabe44e7bfba02be953efaf7d7736dc6466fdd7998dfb94c27ac421c2b5b01e973ba75a6ce3b79af0ac021737be77033ed7a60f26ecde4a3e5ddba482d4c927035e63d0046ec141a5c8ed24ce4d6eb09759c8248cd761697b3c28cf620257446e8c5a5ebbe84797ab1bf6105ea9fb9ad5460e3ddcd861cc5ae84136e221342c50aedcd95de9844df23cfdccc75a4990bef2189a10d9279767701fcd304d4aacce776ba4a8ccc5fb2ef0b5f06a5534bb7a219a9f82dfbcf1e5680e6d1c2813d913246466cae59155ebd5d027faba7e0e8b28531d3325ea0181ee194efd7fedaa1126103dcfcd1567d349dbb30d8ff4497f60beab449627e271752db837fe0939f5de43fa0789d259202fabfc432cb1573e3198877f52621a44ed5e735232d73ed5af6a8b6fa09ffeda815317057268bbd3e0e82252f9fd0868f3de09b1ef9ae7260bd4d605313df040d724ce069fbf26a2743b67a162afca30e07bc05af26a1b1fc99e5eb8e11932e666d0dc7f5ff96d32c1d78db76004066fdac2c37807e7a27b06a50140216e14ee9115dea75e55b5cfbc444e2d397904e2a0d7ca331c4380930bc06ee1af3e3fda5b3232517c930286b6305c9013aad3d4a6cc0b9f0b891275e0119836d49f2f59bb00a8b0a2325861420b51258bfbae4b7914f2e18aedc64d88424f0dbed3c03b8c4dad75c26b9ade231cbe67899b251444bacdaa5bc5c4661c7df559184ff4ecbf869748636f46a7c09d0617ff4fadef21cdd604fb12ebf51d046441e86b13f5fa503611ea58fbb30dfe020da61334bfd66615171c01533bc4e6ffb598d812b12f18fcd18f460cf5cbce2be4d964472bfa51056480588465719ab19c3b644b483e817d9b2d5a2bb8478f9d97779926389c6d35018dbfbab38415c6c1c6b0c0234d5e9ffa255fb4fedfb0fa5eaaf9f8748d31916da128fe85323d0ff40f88a94511c43d83b3e5eedf240c3d9a49f5122850af59257b71e198b0b0ffe00b406e86d790a20558c21181e3a5fe21816352a4d8d9bb0845caa263c4c5723ab77a7934ca2daf19e847d71577bdbdc8ed0927cd8303687073ee01a76b0cd2dd48a6c7076e0e1fa4cfb5eb15c066491906ab10bed7bf8e77d246ba34649ef77e30579ad5f7e4c52f0de69dbef30d401d6e2283fb2cc4f522702102aeae1f25faa8dc4191a3f97620ebc7c2e8efa09691f2ae93db95005ec5f6d5dc432da10084c9993a71aca1815a0e163260feef9136db617bbfb9f82d84f4112a5a7fa76914bfbbc3ebeb8d80dd787a27be514d683435d701d81c550890b79435c991ffa23fc67b7a18e2458dd067a6ecbb963b78085c7139007d3d731d02de32a9d4a33494d37205cd4c974e7971589dd242db777e5e777fabeb16d2bd68c62ca1adba42777ece061ab7ed7095e297b970867be53b562ef2c6f1bfdac946e38330706a5b407311e5bcd8ab377cbdad9e9f258ce939533571f1543859bec706188ef41eaa45051974a10dfc400e0b5ff51c6470ec63d11148cf17deb077bc4cbf0332c81ae34b26ff54913ea991993b79e73046af715634b430298ac917a145a4a80bf5d4ea5f7306ad8c3ef8299714719640b6f8e18bd93e4ee4adb3885d15157249b939b46086252059ed19592b3dea72bf193ba57eee0fd112e012ac1401f7d530e6b7eedea50788a5c1b30992c7778f3d41f1f8ff85868563ea80577917e22edc3f33543c157c997ee6e374b24419d90f7ed8c5f2a90cd4de020cbefaa2f67ce839c9be27cc3578878ec56b337c3630e9a561c9c588f9d783b3984e0f75fa8027475b2336811f0ac44c2760e58cb5d8cf7d50287823c6f5cad284405d061d1092e8394658f9c29b09cb1f0b914ffbc3c69bbcfc5592192cf83e5ba45f2945c32b0f219e7f190c8800cccc0e62b83ac93f4d718035c18526e85ec5ed8fd78875345eed16ee36c7990a4bddb70db44e730d623208d37f4d5ed160855a2d98fcb25c8aafb192863dd0e544e7eda07169d8649a97be31755956b6e233d0f23868f0aa1e7935f6c730fb2f15ec392ac715753c5263e9d2a9d293632b675e8e808be32a1fc0bfe661fd5fcb6dea33b2c8bddb3bc48a5d2844ef378ec82be6ccf594df38f3e935ec457174fc288a1187db9f92c357dbfb4307c02fddfef06acd0c6550ec04fafbcd4f4b991d9fc47172f18a9bdb7d5086138dee2815109dbd853b286c7332010cd4ee7de84a1454cc61161e3a9861c53f1909d97bc7bfeb4b4d206f0b5f1518f5d3c0ffe3cf72a78a6cb8fab78d91de5fc096b322d919d2cddc8ac4296512b3a8dfdbaa8b82e85cdda089e5bbf1758bdbbf96b8c13150ed6c86e2f365e1197222cada7e1fd6a2177db21c2514d5c7d188deeddebd118c842de625fae748a08db533aa2bb9ce69a1410684bd62e8e1b5742a18feac1edc6811381bec34f9265faf4af039e1c8c991866ef870cf0ea11c79a4a1d2b2f55b854f4df7effff43cf98b96ac64ae50b7ea4ef4d0a18021cb7001cc30226a7047231fcb47548bc21954d8b8c499bd73f34a8b5a2f627cd40eecba6964348509a4932b44d99551929b40235f602fad5d9d9e6349a669be6984d8dc7547441375a8057c31cd452d20a9a1593d72218a29c74f1d8d469d311ec9f61499e7bd6c44db3330d755c39c7832d495e8f048199e0bb90337ca5d3e5985ea2423549fef2e555dc7e5a8f4b82c91a47820055177215f5210308f7bbc6d4cf8a07549d78e48a422430581a9d29ef7646941afcd1950e8d808f01429db821d649eaa413ef1bd79c5c373b6c967f82b5abb37178f35c799e34734222ab7cd2b9d4efaf6e4b1f6292644694db22a4aa2e6d6022a0dd93930af04d1b2f0522ac610973f4314c8f66f0d92e340dd36a8cb4099338ce05a2b2ae438fa16290592b19137de37af993488783fcdea61b287d676ae47aa4892eaf5df9e7082e54536ecd72fbdb64a275677171d18923f403eca4d94324da74e0c1264e0476a3c7e968469c72f9a83eafee9dc4aacda4c0e85cda46577944769401a574bb0c2c8e913c32eb446abd1698f1c8bc10b18135ae0de1a393ae179f7a1e4956d5abaa18e9cd679c27f7a558a9be38cc2eb7e1e7b9ba09b12ca393433740cefda4c23d8fcb38a648ab9f8fe1f239ed246ac82e8da219c8e8b204b3e87fe649db461e2a5f81b9eb197cb918f6ca58e0be0f6490c3646c89f420ab6edeb5def0993de80c57da5af998ad21268732b3c40d89da0f9ff56aa6f6d992cde22a61a806861f8471878e6c52e5e0489d96834a4a8dbb3a412a363928d0c0c4ad9b654f8636e1778c950741845882ab078ade84cddc688245f636f61ea133cd84dbb9132fad18fa645732f703e7e9fec1514e5c784d73d3c0e8a36544d62f34db90aa165705f3d6a3163ce4a9f16a1d025d455d6800591321d5afefefab35da5ad31b3ba737ec1de3c2bdd7e0ba8f4d173e54ca80be0cf1e7c5d2495c664e9da6e16202a438de21cb13e43bc173566982077f9d3b9a5902bf5badc34231efd8a9ef1de37bd429ee9c476448475f8a010888badd5c9bb5574ec83ccc569eb102f16fa9756549fa17f73299fdd4633c489aea590784504f3a1947428612049c4379a4646ee96157c4974d15e39f84e9f1eb509a840086c5f57888a7b2d79e7ae7b47c66f3418511ff152917d4f742ed061515c377552d2d0d712eed7bf6b24ecbc7241c989ae4dcef63bbf8ae944be0337a2d5fc387547e9c999585d5d72cf4a6191e9a9b136748f6bc383143e9c09c89ab6779360ceaf33679d71023466d3e9342c30ac94863564215d9d132b67cc97062cdc0b6823551ce35d5826a5d7207a15106958f2243eb51c03d35de05d4b77f036ba7008633f81162290a7e1f5d6a62682800c4319f8ff372d6a305d19363502cbd527042ad749faeca8b0e97dbe3e72eb73de8705019e2280f5a1ff1fd378a17a4100ea9c3b77d20c45313aded1123ae1f644e641d93a3124b8a01949a6cab6023ee08baa75331c6bd73511414165acfe9d8fa02f287cc73e52a98d9677da51e777e372934f4ef634a58eef05460e0f8cf26621448b82c942a48beb04b8299ed0f3804dd04d31e8579c6fb190a0de3b52f210d61994b53bee95d7078ab9701f758eec4ad9af898664f7bbae22c3a284859089eec9073d401a674e0e7d2e2213d40b3b3719c1402472cc6e2e2ea27833e886a3ec5b8628bfc68d7ad09649ca104d9477e32d1b0ebfa74e95021e1ac7cd738b7ee2b5da21670a74a1eb08be04813c2effa9cdd38e4b190ac44bee86ac7afdb6c3a3e84afe3fa2a7e238a2287fbbf59039fc99f9b9dd57035dd50acd056f17f968fdd59775bba3718fc1bcdbb1b239025e3d649b905a82ece18c5134c0e5843fab80c8e6ab768389d44566dc4d2fd50cedc1ff3adcdba1b1afa12cc4f6e924210f39cded66c534e2fb9f9eb497d03cf26ab5569595d702f7c6ad4c434420bbdbb163599e9bb571caf172cbd263d18e01b5222cdaa29faed3dd7ff26516cdd853c9912b84832296642a126904eb59826d6fbc35732a0563062d31608ee32200e9eb0ad523a342a5e5d5b561921a8662c13fff5fb0181470d4cfe40bb184aa8b1471ece3436d0d2d11eab917b3bd9017eb6fbe596dbd2d1b112b2a6e81e26fc1a1200a6adc66167b6924b4945e19f4ff219706372c7545a412575470954e6999eec8f03588fd66bbf72cbd5885a9c323ac754bfb9632dbded28bdbbb67c880f5ac17de2421d9abf8136b4f1e2b1a76ac4b8a8e878d3762115c5b622b8fd5d0f25081a522b5355259ebf3ad464553c9eb5c3321b2f23911009cfaf418030f719191017c9eb1c1a454f636ac6c29baf814d55b05e0dc653430b9fe7c1169ca592260acbc34c21f908a39f1f5003fd1b4cb32d18a82368ddc3e5672fbf2ad21347510d99f2b3feffa3700d592fdc5b07ff12f7e4a2acaab04540ed74aeac5b0a248330db1d801aa0057fe78293a830f60771a52adca708f3d39b713352b8046c26acd5c28f97f40ddecd838f39822984416675fb0e6ce03b948978ad8f57505502346d7ef641ac5ca7109e98f07bf747750e7fc6e2325c057b35544299ea7684ab962561fbc42f847d1da5ecc28fe8d38a522a1165d43ccce5613f53a455d379c0e92fe883d34c9cd678314210617d481d0a386265133dabe72101b015efefcd213855df285595a39a05428849929ea132816b4953f8dedbcdfcc40d93eb60932793b6d2f744d783ef0f59db11734e3cdd8632bc8756d31691cceec0f71e6f98767a8fdbbc908aec3bfe46429d27199bcbd633612f76a7f82defffe44dbcd62ded838e279b257498fc309d517423a7fdeefb60bd7397667c20ff1c06e6bfdf02b373be6d6160fd42d1408898607348167d6770da64e1bd7eb2629ef94bb6072a62ee7965082d9b302ae2b16da2f7245090cfb5fa2912d8506944c4c2a449004255540bc48ee0f6b7b139a60d109a3a867dc688bd2aaedc6b0b20e543b4a441fe4156c5f98ae839b741115765dff1d5fa663538f11f48b793775483fde056473fa93419684ffc1f46bbd813a894081ee6a0c495004c7b3dc529fe1483f2a4f85e12249004324521ccef3b7a18da923be3ffd2497a5363205a4fabc2466a733f37190a55f157323fb47953a41ed648d321d7e440c143a76eee2966bdbd1b4621c46d806dfea4680d75a7301df03e51e058d81b3513146ce6b8890996244bbcaab7c0b1cb765fff5c1d9598a6dc6aef4d2bd8497b2d1b31aeb74432afd004838e559aa5c5783166db62d5b958669fee52a09c2c270f02062d33053472f5583b434dcd4f20a43f9c993c859ee59442f01e969b2561eb9cde3f7016423612653a2d873b28000c87ae1e9fa75018d716a24709d8b7c234fdd0e6f36901e3e8a99d693d41460cc9433a25ccc1a9eec79ccf489c312c573ebe9b16a7e5c1e0193ae86a1ebd47c38273fbbb16028f8434bc57d7c20c8e1e02ed8243cd5ebfb7af5be4a7856e0d9fad37008e9742426eee3a9c69dc0b9de892368e77a6a466dfb142337b450deac92e98804ab754d02062dff6df07e4aac2d344c9dd0f4b5e6303088f8bc17c8086a336e81b655706d22ae259370c8c0969620f705feced7c8fa5375e843d087ab2b3c41845e2468625c5f819665f9d00279a5c22411c8e4d5d9d57c0d54b2895b78f9fab2ecf38604f8bb52bd6665159026127db2ad53aba785bd923e77071f8ec7f1802039908ef174917b60c12ffe9dd3ec2dda9e45c02534f4a582df0c2e5b2d468f50169356a9fefe2fcba9e88e437a078ab21aeba65b12378d4c9b8b39e9b432d0ef490ab1c2f3ef2f0eb3ad45af48cac1b9733fb7ff4fbe937ca6a7ee54ae55fe9d54a6534928607875d6de7eea9d1dddd3105f935b058fbd142e2c1a913d606c52d02adef82c3623632351cd97d5190aae916e9ddd4afa3291cfdce898bc4716564bef6b9a6e36d013eaec947b70717f2bd7a8f786aa4415abc43d9f21ff5244e08ba9821979f57d557df0a7d94ac3caa3e594e6dbe41d05296da496a75e4695339b8f4e2101536e96c2dd797fe0ce52324ee27a622fd991c135671116304121dfc8b729376cf679f6774e893e7caf4d3ab08229525dbdd2e5fa4aeb0f1affab8fdb226219f47a4b8607c3e40da7adfc78c2603cf8293ea96d8dc015e80e3c88b9acde58ac62479b38a1a5d58ab2a3d394398cc95742b7b20118ab0bdd062cd9a436d058b8c2f1b139ae075a26180bb8644e485db314a1846b4e55c4e7d6d468d3313305bb371955a502e0288a09f89bfb2d95a869f57bfcc757418fa79743ccd4e3eb1740594d67af27362bde1949525c29b4fe6eee087b9eb3872a8a5046840797d4faa37e4d93b0c9c3333d516317201b64852aaeb4136b95b9ac3932e02a1bd303d63327db1eb48a3205a2c9df70f06519b5bfd782f4c82c1d34d1dd7a93e34600223838139bb4ca1370a538f4f2d96a11d62f88113081c088a2162fa579cf6299c2053968e296e030ba3dc2a12e18494813819c8fc762e58887e82b32c0595b4d9be31636681d6f4082114de2a1b5fb2a1706926ea48d5b1dd30827b23f2697cbce3147ee0049b938b5f5afed7132a025f01b3dc3214c28850967f83b3c8f13907dd2bc538e3abe833dc1d96de2e4466ba13c356f6b8cab28ae5b9810a4825ae53bdd8d6fc3044a02c8db3548d13a699a15ff4028d533d94463cb45e3823de113fa00def100c08727046d7a900d6f242c2715f3379a2a9e8b9bf944c648bfa55187f67c9767179c8a910bed1fe670cda98f1c0515992858c77926d45f8a9d50d2fb128e25ad9f35cd8a522c815a223ddd3efe9de62ff4731ee975ab7c2ac9bfe0650477d61a5ecc90467eb2b087d1e6ee6afb1617a865c147091061d495359c008dc991f273da3419eae71e3625e6df23ed19b16192d35660d22c10c9d23f5c4442ad487bb86a0a51d7b4953789ef5a73068ec023714e25cdf44c67f177981703d72a42a912fd0da0ca95a5a27cf5eaaca480cdc246212a763d8353474ba6837e52f00d2f0f2641df1193c617503b460da1209f110ae6cd6f217cc9b2542e6e3315f12b4f06961f86a0766fcb5ec33d9b4dd440f4e045ad0fca32065283943dc66dd39b29f4c13e0d7f2c35c0985e4413f7cefea345bee3ff47a72aaf16bd93b4c9c0ac3b6bfe08db93026751a468bacbcd86228b1c1b15b1731b6f2223be30295bc8ecbdff1986edc4a16c583a6a1c87f52053d5e80c52a96bc5b0f825eb2834e4aef7f20404710111f97be693dcb8750cee2d77dcf7d496d3fe30b209c85ede51a0bb2e9fa3171cc7e6c74d2b502b6d392ace0227ac2abd23bd2858b4ac2ba9221b830e3748349597f8577bc280366fb11e0ac1dbb675eadbe78c7613d97a00b47090c8d576558c04e3c615cde070cf482084953c868cd9a81e6a0b077cdf17561c2ebc266ba5f6a941d085f7062a7a695d3ed38c54fab9c9ed50d07157854e66ecd03f405855beeda57df27734831844fe9687db85ec4ff21f03e3da8758a92648f37765b7c34cf56a5f78866d66c6dffb01e8a7f6cfd18501232e1316a65526612a2964a35d0f33f3082a42da2d5c5d2f3a09e873885d64b3c6bba2dcca83dd29290d948393a0ee0005c96e6d0cbfb702b0b0b0d43ba043515ee0acc823387b468efa16f19cc9c252e337a19b9afe6cf42a0dbcb8ea1fc84a75b197d29b4925500b553724a3f7f053f454aa29825d77ba51be6ed37c64cd6b5f5bb2bab527f1d78571891831f011d70b3e6f417542d088aa56626ef76903641fe9b1a7d6a6b955f2c419aee4563d8cbcb99af1028b352afe47cd7006b38dd6f751cb111b7cb69686e07ce26548b42f62d48f3aca68942e7f6d46c7ccba52ddb10263cebb71dcaff1226a507a851dbb1fff5e208733e7ccfe8839c8c9a7d0c9382230e27fb1f110e0c84841bc7604eb96512d8b8dd264ad90e7a54f704b61cb4805ef2a35066e2985e70ab0f82113ccb715165cacb5bdc097a7dce89ac1ddd4efad3087af79ce1c8fb250fb322aee565be865b867e97cae06f29b09fc6d72e19cb34ad2efc3794c757832c92803a0aea4a114137ae77fad7dcd69475098b25d08288cf36c75cc74387f078340eb5084c80bf456ed7e5c8e7f42cff08a07811ebb0e192c144e7321276276cd65b799eb1a0ac69c74646c25a9c19675445d0b30b97c11b1416333c5b5ad0cda4530759f485e313d54b62d7bcc5c9bda4e4a7411d7dab2480dcef117098ba3aedc4ff5035b4b7c1b081bfab4ec0454af2263a5fb31797f92c854a43953ae7979e4ed7e61e422725cfef4614394eb761da2c88cc4b73b394b392d7cef103bb86d6cf9e83733f618104882032b8739100966c0a1dbe76f70072b5dd3ef0beabb5e782529b3290f68db2a81d464d73afc8873cf489da828bdcd963e4ae83ace270b4e1ef8b922eb2b91129b9683d0b5dda6825674a900ea97f1922a676c8ac5156585e661adf6367fc4021e791afcb0062568289cfe14a75e512bda2c87fd601a651166afe851495f065c15c7a1e6e6866220fc7412a1f5702f60b795791f81c75dd72e1d2c02e7d043a33412ccd591fb8094b4cd12e653c494f6d4fc09215ef16bf09ec7e492278e06ec97becb508004f02c58f823c2a7cfa6b79b9aa0386c4dc5052ef312b790034bfea9dd66abd5d43ce9242c9b4c3195e2f4cba6c953fce9f124e1c62fb60561aa7c6e97eb533f14677fc72ba872db1f1227f5869eac15eacd833a98f5d623367783a398fd0e3975a4b3a761f8be35dec18a2814ebfa2882b800e169765f96115d9e21f062d1f5b28e62f8881047255492830b589ab936bd0c041c4fcb41d97a88abde2645154742654ad0b75c376c80e960086669f2e7ad53e53689447b0a4342f98685f4b461576028264163661bb80d18da76b3e9d5a14927d77bf238c9e283ee73fa7dba04f34a1798b833ce8cf23661e3de2373c06b7a511341f2ab993ccd9dbce9d9f28a8cbbf80c442a352f8eb68e7a859446a1546e9c0893523b37391be9315beae992e1cccd8cdfa78de4ffa6e8d2e6d8865f797996258332a9e93fc29ce696df1026bf9cb2e9ef0195206f20d195626f493c2a09db56d2d6092106eca1dc9014563be2cec7dee1ada50f4b4687183305d90a55c89251ec1b0e90e8a74ab31ee33338860076da934f0801e8dac9021c7fa73f247bc8be27a62cf962818855a5107f8fc466a29b290c0ff34ae35714b0def010deb022fba2ac60fc6cf5d3aa9bc912dce5f248ee1a665f9479adbe2ae35ed215299c680ada4a5f974a80d9cf6e682202fa430ae05798d5302c5812504a81ff796c7f1a6fce5c192bf9f1ad7fe5431730615d783d49720265a29ae6303256680a072378dcc05695e1196088a3015d2cbe74e4e78fe21cacee3253b73bfacaedec1649048575bbf614f400ac9ec20c37f477fdf7b4d7b36182907d4082a54bda173bd4b4a0b3f0629fb9e3d4629e65025dbb7b0dd7ffb2d715d619de09ab4d7c383bdfba6e8b5f78a76b378164fcae766711af8e4e9aacc20d7c098e4a19f1cde84a6b3e338e02905afc018869916adc669c9828b96ceada1a3be616f54a172adfe7debc72a486c596c444801bfc35d56c8dd776a90ad5aa025f909f925fd1503eba72f398f930cce5fcbaf397a674897293fe69ea2e6ea9c069452edc3b19835fd472a5063c17f8cc7039c705a7a354f6c0e7dfb2a53cee5072a3cbfae8469b3a893a84377601e687ca572ce58e8a2e5fde63d2e09954b6f9b3b01423bd3e67cc681d2ba2e0997410c684f0c4b2f25c39380e37cfdc3bd62575ba73aaf9524070b37cae1d7ad412f2a34509c0582e6e2c92ebe7409fd3927cb82e0d81535102ffaf5fef88ba86a62ee7526bdedad647621b1d5d4d646310c1014b75bd93654e233311ab3d91729154f4e8e7da36389fb863b59d4bbbcdad00a9cf0e82ee6641f00c8cb9a98912725dcfffd6f58b51b053e792d0a7340ab3d31c532ddf8b59f398bc50bec8f116bcd379bd5395e74dbc02fe3b84cbf85fd0e6e0a363b246b0f49d03914b9f8c647d1fa5d9db72a90d563b3a12a4586ddc7bcf595366a249013b1dde7d46d29aad9225f2cd7a09711b37cb5a4de6675cb1567e78ff2260919d8c5904e2b0063f5eec909ad0ab9bd2e64f08fd3a248c8df1ced0094b7e3dad16dde90e3cf0911c224f44ffd9da7f2d402204bb6fa059ae139aa5ea12f83e5ef2772c60dbfd21507e7f8cc352165f9225b9f875b516287ad31296adec79e31a110043f39b779223fd4aed9aa2f37ab91cc4e2355c033a88e67c95661c35b567978e0b25ffce3aafb42a6ab08df03e44aec11a6640368ee9c217c0867aebb9b57beffc342bef029d9b05b171ef20ba30e87687e2bc71d7fb9250031d33f00b4a25fe55c96e7328a307b5221f259f633068faf0c70167e86bb4e01dacb1d47944699108c87fc73ee73ee4282d8114e66e49acf12c27d9f7ec59a6564edcbd5de3f161cce8567dcf0e6e7823c7c17a8cf27fe643bc7e2b0c227ada607a4e98c9d1f45cf3f352bd007c44a2e9598bba56806e29527fb31c6faf6fb4fd9712d39551d86b4c5262b065825ca0121f5cfc6df45f145bf3116e01e2976f3b532e934b684d3d86910867b0edf0d7260f2c49cbea3d87903057a743112f16c4ed22b1cf11bd4c88d2fca621492dd9d902775725bf915b0d4842748aefd064ac6fe82bc700a24d1bb48614518730a2c53f5ef90ef2611f9fb4d0beea3660c3a40b690965b9c648b0ae5d8582907bbdb28df4dd4f2a5d3eda0cd700319649dc1528a761ccc0db8e8f20870dc4017a308f29ddbfc9c959d68dcd64c18639429120300478aa5a9a3dd6385ea992cd54f7ae43ec4dee506dd26d59a476ae6fc5c84c8610c3e2c7a228174a91adaecf27fdb99df10fff0f3f443336b84da912cfcc2edaf8187b787fd0b75bf0b29288a25ea146e6f712ff3734703b63363022f32462bb193ae1359e42e9807a82fc6b20cb2c73f09fce8feb96d4ef5982f24fd91ad378c6b5ee88d7d9e44d0cff1d37dfe55dadc1beca0f74919f68a7b6bf2f7949b1f3cf8e13c3ac4508e4d0d63fe9705a70bdfc839f4ddf38f64841b5790c3d990fe2581e9677ca9f5bd614714e26348748079678b7f0aba34f8695a49c1fc62beb6dff0cecffd5ce7bb3fc83788bdebcb4d8ecb2cb92c26d7a69b8f737d3900760f8361fb0af781c5c7d57199850bf6b3219653ed6b20a9f4ae2a71ade9313d38bb3b9e2ace4a9c51425537bb6c153e28d2787fb59428f9eb69a174c23d37218e5ce000f4942ff609b4189f7a8635294812ca075cf43fa95e49191d8f1d45c6371fc9f1a55206ae7c23f9657e58543e366c48b787b6f3c66ae9f62622d7aa2005db23e4649c57432a6a1c0a9c398831a99d0445ad60a878e3ede49cb9450012f83ab9fb94eccc2c76da403ca3d0429a026b5754c4e1ede1920dc7e774b7c6703aa9e8c733636315c19d9bd89c5f663b1c6a75421fd89231a876d1d42535eaac61a4a78ab50bc207e235c2eee69e5729d835029fcd3c284c42082a60b0470b9b3a8829704e6c770d6148398db84b61cd285de87d8e6201c347986486da09b4207857c3911e4d61a1558179aec682da6be122415e38d111fb59c46caf419280623e9c6bf1d0edcb6fc7cd837969de1c30a990032243e1c6140808fef5bf38126e0cb596fa2942f31d726a1a4a6aab692c2b9741f027dc3ce3b71b2d733f0ec5a8ba9ecfd5af2a6de9b89416e875fd00fc9e0d0bf0986119fcf9dcacfa8be3a3bbe9bad20416ad4b3f14e6b0d4bac85518738d2340058f2474666920fa8b6bfb454c5ff9c4e3911784e3c2b51cfd0c7f909e27d07dd233d0c4f67c32e7c3e0d591134d06b12aa0186fee3db68511c4e5f520e50aa9114604e77deff3063c6c7436f2b22b919e13e874a0d30f7fc933a1e25b3164c42e386f619d829fb9744f670cd34eab6ccdd38efbf0f3a48bfc69cd16464e31b120de1c203adc4b78a277029b4923ac00a518217758472deea5cd2ffd8c11cd6a92a5c6f74561a5a450c76969d10cd2e09d7dda7aac3f0eb41cab8713860ed745c5bd070694e7421a01386ae9610e3d58ac40dafea20122498cf884d4b7248a9de997328d7eefbb4fdc94f0a72d5c6fbfa985be8f4e15b1dadd8b04b66cbbc74d86cd95eeb08c379953afea1bacbf01660c0baeaff775a6243d5d2fc4c3b4ad4ee87725edcb00528d8517b4db73e41fc0c727dd4e760ab915c84fdbd5e3ec6103cbcb57ac4c61f6f70d28f8d593e254a23336b6db2a4b798484d5417352bf09465f3c5f1ca99fbd3051b2a483c12659f3cca1595b97624b10aff09fa14d68f1c8b13a4e0113261d5d46b641b1b05c0553210ea8873ae319f238a1263b6af140ae4a2d4b9e879bb9233df4b78bba0a578b830f92892e4fd21fce4ad787015f6fe47faf1b7b54469f83c816bcb5ca5b8d8c56cd2bca857d0c35ede4c1bb263c6357630c58f00b5fe66c26379dede4c1294413d6cadd0aea9f9bc9956e7ace46db2ddce93f73275e8c78011c32ca2619d37c6200e8b1798b85ec3d1b310d0d75b5d1ff7bda287cb56320c54ab424757908c2c82ffc593b2d2ce0aeb71c3828f705c651f6d273d21ab69ab7d511b5ac67df5f78b9b940b62a2f44788220962d94849a17ae822c28fcbbae0df7ec0c016fac2b98266ced3a4e192ff8136449642cfe10d9f660373f6a1fb9106b2d0d1fd2425a850ec46ee7cf4809fa5d2fa101cdec0936dd138bba938ef8609e99d285359cc26126d71a95037f0de9aa92bdfb7f071266aaa1242562e3601c322e903a6810412f07bca4d5144d5a31d14275bfe38857db38fbdeb52704616fd0a04d12708194eaa3bc534bdc5bece3623c20b252bc161b600edc44fa9d425d681762a32319a135c12da9bbc8545b1d9dd4108873ff1271a211307fac4132ac75c2dfd2f32019deec335b4f157ba3722da672b6454db4f7e560983cbae143ccc53f858a5a9919184a94b6ad24d7e09a43941d7d07388f8e6d8b2f56264cd5c0f13201f4bd6467b8d26a8adddcbac587ed5c2a5357286d1fc9fd9890d76b99127e9d97f0e9c0f6431cb1f82a9f54dccac7f71ba93ea6d666cd05e09866bdb9a865df5a0ccdac26bee95bf3638b55d34c5f402f553f74b070b61f4b94095945fe2d28e77f918424684c535e31fce5c853985786d7d826bbbe4f5f6ce2e0787650b5027a9bdf5ba91e3af5ca579342e47aee0ac9e033774d17088c70c2ede15251889a0daf5a8184f34b72b3faf80e874ef7325b1ac25a9b8badb518916e9d1a04f1c2700dcbc35868c05f6d6703d1d63d9605941783b345c69eca6bd6819e5d611990078f5de3ce868088a0ee4880ace0430059d231aff27975f46359af22ffc0be6215b5b8d98390bd15c63869d976a58a796ac0b9d032fb134d6b84982750368d0ca9ea2a4660c96712b0981e4a575776173e3f7c9515a8402da03812b6ce55b448383c3127fb1bf6b8085c53017e034a5de76cf52ac0c73634674fe2e02ae1e54cab0707bf0e7128c657daaa24396918bd9780a18420acff41043b162e90a750214300ef08ab351668e6a662d46e46c1534dce87a45b1c2f1d2aca99ac0b9c4dffa4764caa5a18898a665d9390e7e08a0a984bc","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
