<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"32b7b37cde42d71125cf9c140267db8e371b5049006f0beb6a3b9985997e8c1f24416c6d46abd539d03e211e2b20e349793d69b47b52cd3a92594fd54132c199a4251c029688e8c3aca82c798a977fed04a7b0878668b7a8ba7c14c13ef09e2ba224bf2ff9030a60077af5b9859ab71b3936c147ecc4ba22a7233f7d683a550ee183d2200b13c7811694251e13975c4366bee074d84236440b613ec47b50871b648c5cf6f22d61a0f105d28d0b5faa970c0975466f9a7c2712e79f40cab82128e1404631905aa043dd5735b14fbc39891d073ebba570c6baf284cc644b0d5b2ec9a97d16ac82ebb8fa3d3ec0c6e7db08a497954e5977ad3cbac2daa9b688da269247c751f12c4b5ce473a655ee0ec5983db69a1bc8604072d58623a3714d6ec10a3ff58d88e2226ad8560ecc1938f39a9a9555cbf4129e75c0e096d4dc408df3c87229a0e5d084f40e29f86dcce09981730c56ff30cc60e33c7d3a6466aa1458b1b962c84baff25d474366952dd8ba7b2e2af3bd466fbbc2d4e316a631c0541ae30b144c6866863b34d5222df617cbe833889faa5612f2c505bf738ee3aeecc1df4d498f1d668ff41e8ccbc11364c008a5212fe8b5e1e3e0432c3233501b158e9a9b53a25fde23b7174f11b64faab375db44d62ecf36f07a77065cc8f5d9dc43b1d677f7ab302100c2b11ac9984204376f642fa5ff47288c4ddedffdb114d2e360c19904e182a5635e54bd0d03a071bce420dfb0c237416e7859b83279913ef9c34538cbfb1c21672d46749b71147831a53b64c8eb8678b207a1f63838fd464c3ab3469a328f4a77c3c5d4c35f04b3f98f91944a843fa24dd2ab93e2aec0a47b847c3642372842dab803e7f8c696b7c455a1f68684cf5ca5b3ddb4a615f3b30e2807763e53eb7143c7211bcc4f9026192011e43478661693619599c52ee9c20683fbba83a797de475305010de30d31f14d6686aa2f2b68114448abc298f48c91fb26a527e66d7cd46f42f05fe44f58fd90d4d93c349017aaf6d1e631c3ebe62418e62b21f273acf382d946e54b354858d3e3bec8fa1ab4926a86435100525d2641c4361e61b1b7908abad5614c695f35c6b02be82b8c03a8c8b59197eaecd048b3bdb34afcb4c5e4b6e1c7db615838a764a091c7fe00a80f07e5ab19eff56b446a3b3b97d7271a0d78252cc148ddaa069ed54ad28dbda56b50207c779ef885938d821b687d32dfbcbd05c0453c411f4b21f1c9191a9f458894de09526bbc2aa065972a930d78f6395a6419a3f7494bfca983fad3f8e88c05c67400ca689e6b01415b875e36bfc69fb6f399b1d51a6ce813dcd85190fbb8badea72752826b3805cda889c30644aca84ac2b43c6cf404d59360ed6ddeb49dc861a492a14183ab87fc3f24407fbf15b0a39570d8c6c35ec8551fe6b2d3e3afc34863fbe9ed2f6ada6300636e9819a899ac7d61315de45fbab822d211e0d79b032084ca803f95a4ae5af0e3d940c15824cde7900e6fe11f2c1606843c6356b6c00bd10d05a5aa04a94db07c9d789e513276c16eb168c398d1218860e7f7694898e22e9293f7aad4172037318a7e0e8cdfdeda39028cc42adaa9e629730eea2c9ae05ee6e6ec46e0c23c48290721a194532eea28b15d06a8023d06dd6d742cd3528adc37979c9f840628ebd7858fe3f80eb28807b00f6bd2dc769032a51f7a63f9fd9a143bcdb2f9c0a3d1e3254e98ff0e401686706a5a383b256d5d9412f2a4b3892dc66e5ceb02a6edd974cda8b6f3ae6a2050906663725d43412055be2d8bb897f78febde641012a20240af6bdcef221eeff4daf4935785afac1e4b593a824983dc12717fe46cd16a48da5c09c697d117e23fe7916b48ff9d094485a977ac512e9d2557ef4839343fe3447f220bb8628129b7706304c7e13271ecaa4210b4dd93fa6d2f0863409cfdd850868931c91802841a3f52fdb0279d190c1cbbd70de4ec8955de84f1e9cd573bc0513e0c047ca344c4c6e5a587b3413cb64d3f9bab53c7b9e89d3de24bd545ec6b0589faf1f3a12ee6e768bbf18a02522415b063b0c17fa58104c51b896cef1300ef399d047df6905e4dffa83fe7678434b6b32ff3fffecfd9fbe7ced3ef8a384ae9848122da29452a6ced1bd672bdaabe6cbb6088bec0d5dd4abf42315951dd49a88da239c6cec847f0f46278ff35f05b1c3f012aa808787cb3baa4632c9612d497f983998ed4c39b1b16cddca8445f9fa6f4fb950aa6bb36abedcc68e68b92617c4c717c83f311b407670faac6a6efe235208471359bae9ae2b1a0ced591f88fa5ef09c3a67e6bbccb6e4ff4ffa8b0c1e011ccf563faab278a28aa7a89cc334103ad81d04b4ceb323f73278e7c996c99ac30515630be7bf6d12569dcb697f327afea8f0bab01bc80d6c9264391b8236ecebfa72230941928b4b321025074501d35eb2e0e081f855250e8373a4a5e339991858964dc343fdc564673ea3cd5a255ad940c5c611fbe187e245e0a78d7ef13209562792ef41c9df587e74debf9c17b9c5daf3b388c8439c07cc93e38bc4e6988cdccfeb0e791179b972e3ed611a404e9ba3274bd3a012b165a2542027e59fae750607c4811c6119862b5af66f995564fc09800dc3d220871ff9a0c90d2f1ee77123e5553cacacff328f09e78a971cb3dc5d8b47ff90800542fcc60842b2811425ee078202df891f4eeb1dca68a875a09076a56d5641eba3e07b6239eda14cc0000bf23411cd2af4d01c62a27432b57c2f738ae094eb9bd48b8ab80c35be20367e313268b9f1303dcd8bdfcb152802a5c4c0d2ebca4ac53a0ad8d260067f5d33c94476505c8d76b68d8d4618805fd7fcebdcf61339c2da7cb42b6f64e510f697bc89fe250ef2d164a5549b9cc23a25ec783497aa8cc79c541f86365394bc85737379ed0403200c59a60a5357b80e3684dd36c7e4aff19ae693b4d50ef90f42d41b6e4e7fdd941350623b3eccca765afd4be1ed6dc8db36705b7d3aae563c6c887e593b8009f2ff1dda497eb0526a5ac46a71220a3d22e184cc54d3d57e1b1d4fbb96ad8b4efff54ffbbc7a2d2076d57d25d05a28f579718f4a023ca2f1dc30ecd30da447724c8c0d1aeb9fdf8e1f5c9e12f5eeae33b3cbaeced3dbef0fa75b36aa688aecc2155d2c7a8661614e12bf09b96bd5ead3e8e428546ca0bba935583bc7a35e4884d1aa414b59dd34de6e26e2ad59456207b8de5d56305efece522c2c8118a3170b20aadfb80e24b5e8a25d20c0c56d4fa6770a91bc71032bc40dfb9ec68142ad2c70078544d9df7dea7ba7edb1e29d0c9191bdbcb8ae0a2ff328be428be0585e51cb2e7783a2d932870bbed790f148c9fb71cf9819758181e111910bcadec359947da818b2e12140c91241914bf7f7cfc379032fdb8c0d8b7e8feb8f9ea41ec72d8c858d0e00bdf316510d3c6a0a2c1353a002c9927913e2ecc24181bb935518eda2745e2179c634e06d43dea7f371dddfd31e2c4b8fa3cf9c6240610916efe070db147c2c2225ff185e01e8c6f441a4ba2bcaff187306b65628b7bda7fc406318485fa68746152a3084356f0bd01ea1f4590611500653d7a9afb6d2ddbde72a86c1609b5e1d67c60f06ee67d7aa7b573323c45c5a80ba3d1effcd53be6ee87cbcb56b825adf499719a38f2f6a16576e36406c3e5983b773ea05f6446ff86487e53ccb02ecf95d85b27d1c7e7152074b1cc2d1b003bc91041a2485f04e0958da9c5c6a2ccc75f88a035b21e32349a0c958e7c4446251ec03b2d8cab3c23e35292cefac601adf9ce1630cb14dcb4dcb5190414b5deed8b3381a2bdcbff72ed697588f0829596b6f2f77ccca8255d91c2a7402c5079999478cd7a0c24a4c67914d064a91f0b530144a819924a15e22174e8fb56134f71a32ad2f39d4d4534fd1ac72e9e8e731748088faafa5ab2297ab9e1bca9e17611ebfd20e34068fbd2548c37613451b2ba1fd67830cf5a3e6dcb9c3e548dbf2f10425acd6810115dfee1e5286c77215f0a4f1085de118183c6a339b6eea255b44713060ecfb29edbb8f3ef923d0ff2e6e7e7bc92c074251ad92468a57b0f3ce34cb1b8600c5c5c7a69b0a219a1e6c0f707d933275645eb9063eedfaa8a27d983e4ce2bd43fe5f1344ee3e614dc599ad27d2c03f709d7d32b85ae2443e5f28a05c602983518edd511110026bd67a4a8556a4accbca31d58acbc6125ae026f23f4725ce55668f912b1f31d94ab099b17ac664b13157fb53e7d43cf8e464180313a4cd20d6b2fa770c4c62fbac48c47bb38c92e90c79f4154704abd024af77ec298c090eb1c0efe153e27b04ea5a9c1fc995b33b0ad38dc7f30133c1cc5b9b62a63c847c431a1c53c5d1405310884de7447e6305085b972a371e10d071dbb1501149d02739f4925172f023483045c7652dbd27151f56df10df57d00cc48772456bf93c8f0f837ed0a57e0e977e6171848443396c8efa2b49e4e8e16dc79ae7a62625dfd8881e2e09d2d008dbc57b2588c016a3316e19486b1a0183cc1161671df37ed89c0912dce91c4d2b3695bc78286f2a256eacf64c7978935df6558873e436e6ab50353f0afa278c0faba384c6a3b5e1b35b5fdacd2e5e7c8442c72680c30a6fe5030947d54c360b0bcd4deec2032fdf87f4ba73b89f25e937cbcde62c5463990bc28dfc074da7fa97cc3697b251df22c89c87f168eed0b162864ba97dc5c8f5419994923cd33471bfbeda5188a08eba6eaef0df8e1a617a4ba24a6eef3afc3989b0d6033660ac5ada3fd10034b1a5109ed8e03077e63a998004ed74615fb6207ef9dce1a3b91b1515cdfdec9c9f86ddbbf16623013e2e37e2059c929a15de9129ad05a67e38886fe34a24203d29e62d31400ce957a5cac5bb9609b8c863f58b58ff55d7068c54fc42e83bb91adf399417e8eff5d740473e0daa818308ec01428eb478831db8481dec687990507d20e8a71410ab5c180eb1e1aa092364d4880a8c535ad6af9132a54626457f6bab508543e44730e4970e2eb4cee7c6b8302bd0ddead249fade6fd747059e7961684a164e4350e2759d3b7c0c18747362d60846d5865bbeabc47950cb6379c25522928a3be0504ec6ebf7707a279e1614ae7f92589db0b4e480bccd3a536d8886b8e4f74171501bf06cb9d50989b2d0557674f42fd24b59272e3ef915bc0e5d60ce00b7ca6165303a5c68e34ca45bced34fb81708adb2954d1b91e34d1aa0082a2a13e5bc41fc1b5eac84bb554cfee885e74e8199dfa217cf7f170346303ac4f0d6416fefb2ea19c8b4247ebed323d7c4a5a06520482ebb462b5864c85c8dc7df72218c7e35c25e8896e70dfc4a9c8aa7c4d9e63107b4f6175d09eef7478477569fc98665624a30f1db940f8b15148dccf65ba2ae3f6a46c7878c5644c11f6b774aab8744fbcd38521230ef3acacc3de9a59b9949c140bf3ae6966beef01b606d11582f76ee5647de298ec51f0cdcd0a403f2e130f5ded440828a3ddddf753a4b5d7f7df74ea915fa7761034a29f43a5170157f863fbc6d407bb7a73825884397f0e3605106c4c1e9c0d7b21cb9ef0c703c425f64146dddb2e91cfb748c0a12d2710104439627974ee3388b4b066048397051a8f253d8fcf0840adaf11cb7027cc64baa6a6835470dac9da198c501c142f3bb114bb6d0ad6b353400d71dcf3bf4a7ea9d4699038fb6b4275de354754eb74870f472e1f7a01d8042db395bdda309887aa981ba666651b9c9d8cd621348de92ab47280176bff4273be00a23f21f6dd2e152966b8237b21d03dd636a4ffbc9ebcfc77b47c93e84dc7ac50eef7ebcbed46e459d50ff12f2af35398775bd53ac9f9271345b0badecb4372a29a86503504843b1f20a2e1b4a9cc1f73a925b304de9293aad072b648d85bff02da3600ea02e275d652675ccc58d44d3a9d28842a48112e17b970d28f9815363a2a03aef6b2aaa4ff4b4e546ffb3333757644027c65a033f42a9c6698c7a0b2bf7cd162da275e5deeb76a44a243bd11252904a2904eb26d87f5c55fb3c43a83c5170d4d4e9044e87c326478eca805166c9e2d7e5b2c286db74e79f74135ae2a9e41825962c4e86116aca9dd6fe2368a7e3cbe3f226f887c07077119a3aa58a04227e2cbf6eb124a6f7b2cf1cd5c14327c416be115ca087a31574749069d5ede611287968c13667d12c53c92efe3616c3bf3290021d9d997da510fb207be7b12337e729a628268407ab0a2837f9cfcaa1bc8f02ae8724828dd65ea42c73e38e330eb006094efd03f8b454e91b7cbdd901a55ae01e31409419acf30a3831ee16b101894fd80a304fd8097718eada6a75abc08ce55a3d197155256d009eff55b736ee2e9f3858da1b56b4ef7c835909954fdecd2d5d1dbf629a4fe0972c0384a08f4f0baa3f1560ee578f437dd96d8b020792c8ac67a572274801169124ee47375523be29b571e2b67376d45fe2d8fdd37a88cfaeb98cf9e2dfc4c63d77d65dad608611aba431aa254a74370eac1a98f41e3ef3cb9e26b042d96366fa56c4e892746a7331fb438558698da3d9bd26766a0dd0f85cb613a393f6f4137d6927a478402e2c37462fff39279ee999c592600e11c8be9ed6390a8e482b87980392ffb5c8e07bc2c52cc432433db897ad57d0e5d31bd457c869b300eda9fda9cbf0dd01e039bb4f1eed0344fb1cbaec71a8a99fe49c26c09df99b524cda082f41002af887f09102c193a3ab5e239bede3196b7bc444ac24b48b18c6f22185e4a022473a9657e1a90db258fbefbc18ed1ce2e5733938ba06e711c9b6bb3c56f369eb8ea05b18dd41f2cd2619804cae45c3808fefe4e34574d2e04a8d8afe94aea56549bc13af212df814819716c901b71c489f70cd3c8ecffb518ce2571f661d083cc59d659797da9e747478351ea252b5b14dca60fdf44b4217016cad1b8ee3d838450ae10edc19c8cbaa1ab79cd2e44ff5335983ab3ed579681cc75583b43ea404b1ed15b24f1bf3ce7b1212d0963f296cc7beeb773ed582e03c55f1a0c9189319e87798482a68db973157258ca0e8e09420838db238eb6817d2944fe847bdfcf4361794df461365ebcd74364fb1163d7039f87244cd7b6b50ed6596c705076db39a66960c59f8a955447497a1142ea61c7eb5e698051b054c1ad0d9020cd1b53d3c0fb72dfb5852feea56bd13b32cad4485a581907a5d8cc14c33b85dc57971c81259da1dd50aca2d1d74108a30077ed65cb5a0da3e7b486ad75d47a4c4f932b1f2f4724030da29b817d457de10b253e12d1288670745dae76c3f9686e433de1631e3ea7d6636895434b7d766031196f8ab8e6f00e6278fcff9cbd7a516f484c2fb7e4eef9d2885c24e1afc25aaf7115d0f3dda3e60ce8aea9a068b76603f5e8f1e270a14d733abda2ac9351ca06e9ef35deb2ca0c6a50a4a73108d0a04f86bbb9551fad87331f8e2bcfff2bda51448b354c491a026a731a3a53834ecdc1a563810bff117de029a115c94e3546ae22f58e0a49b8b3594dadfe124318cdc0598782565c2b31dfe4d8f2804a97c7b52d1dc679de7a0359454cdecf792b8b006151fc12df0394d47a1f8f4f0aca86e5e1ec0bdc74e9b27942c52518bee52a3f9e0708f64c18f52c55d20da8123a87e02033ca46f6c4e04c0f812e9b9e2d9598709adad862ac0b6ee0f2f3a4a94d55101224a75c9b9c70b584d764fe892a634166587c162bba040ad1ccdd2bbc60e2d9775f0635d794451f4cb8d813a3669a9b3c8c5f2bc01c48b191b0ddeb44359f2df5e68b8407fef4bfde9ab37a00e9ce801669c22b26a5770f218d358b9303216c526dee6f454e3378536a32846e4c0475ae57f72d513f53b9d60864350835ddea8c1f83ef95bcefe0255d692623c63b06fc74fb2a907d38d244c766cd07fd8b65af75ac1b48fe3ef394f77ddee59d3340753ab806c101f67fea1d0d91fccdb61d143f42e59417676f4f2f302ebfcaf1f30621f995a6a7e4af9a7bddbe75e3173f0a9f22c36e58e8cf27cee594485dfa1cfd67966733e6380b1fc4aa2b7eafd78c9e4cf765bcc558fb29970f654fafdf183c55af731219a9b22edf87cd8bacd35d75c4a02a95afd7d14ce50bc4b2f7ab1e5a425e0fda0af3aaf67ed88c9819a7b608f856eacdfa6d21e96b1c267764e852c26e767ce4f46f66231701250f35dc48e8f0c3ffb91259c9775de8b121fc179ae8ee2d06e304c75cfdc7910d4f9b938ccf8efdfbc1ccc923358c962bb584eedde2a4012f26c7c92fce1a9b8287f7dbc6aff6dd284c255b29cdbff288aad8d8c0eee5f13983cbf80c69d174b26e62357d2ab5bbdc8f32e9020ecc862e8b9dedb362e8dd385fa71d0cd5b7b9196a954dbd37c6d2c2a8ca82eed61e8bb73a6c65d139f7b07ba3e4b2df7848e02f8be2802856abd1dceb6f1c5739a99121d44fdd0a8324e50be4796298923380bebc49f414581cbb601de171265519f60dc2848bcaba4bb7ae585a376e78bfe98c7a00074ede7b3a613fc4541948e636176d2a1d61cae915fa324d13947b90b7f61ce824813814f3db5ff5f4821a4ed1953ff674e213cadb42d1f9bf0269de1fb03a9dc9b1d14e79ecf08e0470a6fab6a9c34393c50f90c51d9c52840640edba50f4fbd4c33e05317b3593382ca0d50145045e3233367fa59ed7848c659f40bd175b1a75202a238d799d932be59164deff6303cd35595d54b5b75831873f7cca0559486cff618a748d2006f0d39e24cb01279ba5d3bea3b4f1047ae4dec58ac11ee895ad4a0a2e6ac367019ed7584ef8a12b3e465526c38522c04c5ae60694d1d4bc9650a5e52c64ebfe642c2382ecbd3054574e998646f878faef93f1f2cabc2dfdb8931d0cd3296a5f7accd0ec99eeb05cbee7709662127223217ae52efbf3874b847f6fae4a00b92f9cb6c9ecc5d3abdd8aaec6fd0b48d918e29630e81f986b4595ebfe1094020373960222a92cfccb38bfbfc0ae1c8de883183416326c46ac97da4a00c4d4eeecc627c968b775eed2ba2a4f698cd4287af0570db3efe8085fd5e532ee6b62e112e3b6969eaccdf65828a7e0b60ccfae0aa524f94948a44a3a3f58613222c7858cb8b8a8d7e6860d3727d8f22069c0e7746ee98dc03d435ba47f510563b54eb7715c11eb75a953fa4e71f408f7f9b1f7d5d0c1197ef4a347b10dfc12537886a14d2cbfe01818c822ec87184e8de9ea71c15a06215cc0a789ae8129017b9900d2984c7fdd38a69b062e6f1dedcf2935aae114f046029748173736355a192de9d243b45469188925a94b95ea2e4179cc6fd8d20c53666deef1bc3f480a7a9d0e52275cc57a69760a5747fd135bfd9ceb842ee0566dbb055607f65cc7db3c1e37b6e86e1dbfa5a670e1e7f9d2cdca49e1bf4286754969595a004acdfaa8a6b51251eceb28e1963f26a3b3bfe28c8b1d3d1e062a2cd63bbd9c5c5d2b0b6ae928e2076df26cfd663774ee8683fcf28a6929ec5c143cbf65fd77ddeb1cbdd0072046e00d1e9e360bf6c44c66d2c845b5f2eff052e1de2659ff51e2de5d7072fdd12fb4e66dd9413649ef22c113669bcf3aff3322c9d43a99087000443ba3a6a3bfcf3602b6e903b031d79622936f07eefd97e35c82e0c0514bdd1ebfecb6f706b556cbaf41b19b74f526cb11451928a9c8b4cba49120d49a7756a9706866d673c6ef8c75248f4bf4e408b6a5e949c90bc1faae8b62243be74161170b915973089cd0dbe7636bab1ca678e85b2c09491f7b109ffc0fc6a604b268763f54117c883ab49f25745cb8c6c2d81dbfb2e2fa398fff79afd72fed3e7045ef5b80f6dedc204185f903384d090d6775cd2e89e59eaada8fbcf15cb34f7588c33e2d096e7787c86e0262098b530e016cf2c6c996f97e1a4b1b415567989bbc7c16a87d3a92dfb3f3fb9fec26b2a462436e7f08aef2508357cf29c5abe041b0a43984ca6531d1289e2d84c45068a9649643facedd144c43279aba410043f71c8991a042ed761238f9e88e391ec5a3d02d91f9769d8824c65efe84125f25fe6db65b7f79654cff9a99e490fb44f56c1fa675045daadec0edf18b27f8d7674047b8333350de138a545320672036f6f9d11b52ab53f7da457a8bb16ec5dff8cd826fcd26580331800f46df4ed0a9c5e02a207fcfc7b71b81d921b4c9741615f253b3e45b30de6b6275dfb1fd1f2b2ca5c9389e22f6a704c3c9c0b12b9134fe3d82c635634cfc19d3b275df471e2eb0e37004f8ef8ac8e383540b0f92b3da8b6f234dcb45c87399a325cbc8f3acfa0ece7183c6368b7eef152263abe30c8e7014af5c4f9a622431d2fa881a221d429a4fddad45bae02dd424506184c4015f29105ad4ba55103216351e70a38605d7cdf11756c5371d5f05d10cf3bce9f6610fdf75bde88d6240f27d8abb5a20e1428da3b0f55d3b952358b3daf484b98403c4e5c03d844f4655488331b9bf3a0e3a57f0d2ec2e14a306b73fb75b12506eb2b1247c4328057e225fbd0d4f5aaf2197f59885f9652f9dcfd5a815d8b067a73b604d1b923ff007322b1c141fd96a9de962fba0e655e8e800805f623600c10b58d09240114796214a2839484c9d7edaf579e2cf3347fc64d5570550f0cd635220abaff32437ba90f7cd58306c9825a862953f5a36cc501e3ced7d1f4a432ace78588f72abdcf65616335b1ce0824f48727cc79530a8624bd86e4a50385c0d132e12f86f0cf77d80842cf6d5301465af37c42e5c3f841a7dfc55751a682dde7f497434a834c58b51efcb95ebd2d7facd64889bed49748c6cae90f5db9b87d4a168ce9910d19b7a39ae8e0d0c8e90b122c40d3801499204cc081cfb0d23917e45233a17461b0385929f8c03f1d2422722e4cdd227df4532bd1ea84d523e7691208a992c079d1de81c79d2883e7ae503966ac23f551a031d99d3a045a12a97e31982f16ce2b6c74ccbc77293e8197196e21fdfd51368e460cea6ad2a2a3e57f1a97f5fd321438f457360860370887578693391b2415d8acf205833f4e83615ae8c0dba9663fc2c8c0932486ad215f91fadd96ffab6f9892b964d948976d33280588b3b1044c4117e3c1d4fdc65227f3dcdd35e1b517842d92c710f6716fbbc7508fc4ae99b6d8af8363ac140c1707a77c82320db54c7fed55770355116b9978a8f0d11575b5fbd4ad55fe53b9c1d3002cb72576dc7856f8457858014178ce623e08866a9f604518ea55e283ce8f6a37a2cfb792908dacf0264c20521f40a4072b685aaf7fde90cad81b1b9455f3eaa562a9c071b9842fbd2001cef47d4ba5341189137fff2471849f3eeae0da4df94577fd227c25dcec72eeaf2d8701a9d078f4cbd3c480f4a994d03ace86903292f859733afb124d1c80dd6dd056bab8dd183ea81a57ee5e48c9dd4e1edebd1dbda4bd6f0e1db6b93af43c41254c1e9da9e9a55f2bbb224ef287e6b67b342000e56458dd212b10ebd649a323e78bcf0419cbdd0b9f25f9536fcbf00fb2b4d58e71d1563501ab08939c7800bef0fff7938d184c94d2ebc4f73cc657c78a2d804b8a39337793e4bbe46afbf42d8e76d0a8105852d1b4c476070bac8c858fb4f53e6f7df4237da04d6bbca0da450fa4943570f3a0a9c7246e94a0e16bfd0eb99eaa3e5e8f18f275c8895f103aa1b1e3916500ce692a07f24222f53820f7c5ab0ab6002a7619515e785578e1784488f8b2cc5550478da8e3a90c646d5854de916abac3809b6b46fc2a4e6cad44df7ec3dc176439c91a6686fbe3642e2623d32099f394f411d3640ce845ba9e38ffb347cd6ad35978a3cbcc11e51414c9da1de1c0b7aa9d88825c99175dc66672b88ba0c5eb203fb7e732897c3a042f63dad7b337ef86d4e08b598b5950bf8b97637de4e2bc5b4a9752cc5f227c77abce59f6edf6459ecb5e36f65c877364582c61148d378afd0210bd8a76ac8a5f09593841ab2896266a66b55310de8e83f526628f320e597988c46bba564115c212ab5996a4a375261e4fc4dc192393dcc1af993883d6f44fc4b08b77aee9179babab01e2cad6dbf9d306bedc62fb432cacda154f2e0488e63a9d9e4222e1143e117f4b5d4cf965c560da19c7597efe1da75c505afc37d2358bd95d67790f9047dcb230fc34d48556ed42532e85892a1dda5c0225c2a4b2ef195db5b740219ae1de12d4228f38556e5b68eccf8aeb20c04efa7fb9388f4ee75d0c6f8e2b43cebda6acb18ef247530ed68165f1cf6161a05f4f39e09dfbdfbc53573d069f28cf02c3fb1ca62c9522d4016cab257e8a2f6d438efe512e780b233c610c3871bd1e637d327a118410068808c5ed18a04e14009d9c255ac12d91f32ce86d92b622ddd7c5b15f74f85924bdd09979a2b943b08deedbed6240bc121cf2e46050d856367e26868e58cc3fed3c891dcd7dd05b98177bf118ccbcc4ffba47801dd46cd95661b58ac34d63b902fa24f57f4d150d1eb93758a2c26784c24663e6c4e32adf8fed53ad2770b8e9fe0334431fa3503b3244d28f807ea0a222088fa7e455ec66de37ec454e809000fbdedb2c7cda9a30e462b58302385f108017656c92bbc0a2691e51ed0ce6e936fa6feed6838e8ff04dc4a73b8a9e5c5a4e3a700fc591a43b77a3ab11828e24372e677910f3b5892e44a3d8f634b2164f251079fe1a95761e8c8a2aaa8c0c0aa9662a5ac692886abaf75b47bcce76402bcf32c52768becf8ba5bde58a66289f88ce997fa9abebbfdfa20948d1d9544e5295d2450d6b9368ae18fc309d1d537b2360e4afbd6eac1e07f254db8efd629cd398d712621b3bee3ee2c79bc978708181136d32f52124f11f25413de046ef7b864a7f9605ce98e1a2f189f7a76af4bda4cb11dd8d1c86defff160f45a28341bdc483a402f123c4fde2e882c99abd15debbbf64eca3090be54bad3318e2a1fb474f0e15d51767473e37aa1789214c75e4e53e3783cc045ae6095f7941309b9b3afa1e763719fdc7ecfcaeb69271a68fd6943a110482b114ee2001cc6ab937a14235bb343fd1c8a32d657e3b22e5c3587bb33c809d793a013547c2cb7c638a7539e3b2ac133a39071a37cb278289b5a612f7087091820cab98cc0dd41b08a16d8903488a3624a21af384cb8713baafe1b0f9c138c363163b71648cf3e993221368d51c357d60da52779caad4b7e7c136881c5eba83b97a9437b1ed7ed0cb0bb1773fb60d0607a82e060474059d1b45fa3ac22d4e8ba2230ba4a8ef60a9d87b5e47089925ec307be18f41cfd2dc24819f4f2a832b2c41e5c4681b0eacbb57700dbe07291f08b5fbabe2abf409c71a51cd8a0123abea7158f615975e9017bfe8073df808dc0d96dc0405d1812bdbea13c8502f6adeab9dede254f5e8762ee9d7529b771346247a33f29984694ba38bf7b5e24763afb3c76d4991550e1a93dfa30ef3ed897548076f82abcc0beb94a7be9745211f21e0df71762fe6e7d274d92ad85ff793bc00abc23000fdd93e8a4febbacacc86de97365f92b73161108c8ffdbd5ad95fa3d5d9caaddfab0330cf903df339375f4a139bdd3f8faa1e91c415535647c9c6d8fa21f7c2dffc40e2d6b38e88ca2b2ca17f276d016307d30a678f4dd5fd99e20a15e586510225946c0f938fa73cb44dcb9f80586c71495116e33290ee11fb4af06e007a72df83dfd6a1502cd5290cbc4c2ac72d61d29a0066d3363a45e3d4b26597b7f938217e116bc6be7f5c8d091911c9634585ea2d9f06566ca36345d72cf401b6c9ca7367c42780182580bddea176a782756d4b2e4694c27a89a0d5bd9e4cc970112890d256da2cb8338aa1b7b754635220383dc844a148a0c6b3991a6a24ce15fb706e0f1bca5e3f617bc094837b686822f2c645601cbbd5e5761349ba2bb9ff0c739713d0e21c3085873d7371e2f9430dba0d8d48e5e77e0b942ef64d0394ece3bfb68da7648249c82dc2abe1d2e6e20b68104103a3ef287675c081556fc72940aab87138c2d7653efb8955807853751b037fb0ac6930806618e03b94d02106d8db03b7eab4a19dfe2a62b9b7409063835398a99e42717a81d48606dae3b1e63014b41aea7e4e552424b3db94ac9c199b35df358fc8999b45a993353c2079c5ed7ddb153cb4dc1445ec8d93de5a981c8f04797c54641448f670d276ac4909c81911a1de43bc73b18b55840594c8ab22f5e46f6efbe3172ba9e6808f2b2c0e69c027650d18806becf1ecfe634eafe92625d5db0bd2b032f1ee6e84b3c989c8ced6285564b89e159960b8c1747d599ab2f149dfd0e52d8b71320ab016c980cb1d3b2c8cd4b8f8fbd919c6b573ee3515ed32fa9d0789005970888cbf21bae706e9c8d0b3c6549e4f008875810f24d2f8de2329859c782ef4bb87645312a67077f9cdaacefbc1380c96b473bb75630322c65cc9e1b79ed47218f252e37cd197bfd66a776dce6d71a29d206787a59d5ebc24215c02d97329a77b4d2db92fd8062548ecb2b0efe7c85ca502653fd5861c579b6a7e4f3511eae0cd6018a3bb6d6e57044b26a6e2856e37ad740386d6b3aa5ee0f8bc1a244a883078ceca8132604df6480aeeb6dd7e5e909c2b0f33884c3b1ecdb204056e3092b88444926bbfe20598d89641f817b316988d287c8f19063173adae7d1019799098500662938c9f25ce83c3cc1cbe7b4f0f49cbde6254a1ce3a94cd52259c144c968d760a91bc6a69da8ae897d4bb80b6e8911b49c14a0d4465447b6d9740979fa41e7e981369de69eae7bc13608776e28f66e0ce2d185a6419e2a7fe5f9c4f8a171f569b8d118de2cbb9de4740a0971301fa54821217b710aaa17e4f3b5b18ab9bd5b49b0af4c4f8760f7bbcaec996493e6563f9dc0504dc7fe8911bf998351729fd0fb875a1b15637eb6e57f2cc5fee4fa31dc2fe59dd3a4cfa2774c6c77825636695ebff70741d2f4e3ccad14cc57c065e28402192a43631352d071258e67c7e5155e742576885afa10dd701f4198762710281a23ae4f1e01a109285467c6fbdac47955d1fa6cdcc862a28b278d0e20114562710e25e5ca42c2dc7149a026b3b783a2fe08fd9bd4f936ab0914312f75f5d047733d7c6b5b39d25665c5059bdf3cb54491146ed7560c2d2cb65c31ef2c136d238d1d82e3636a673b5c74c3ac33afd2bf45143c1ee61c00aeb03d3b4ac20a104e27a0c3897288abbe3cc77599dfb136a577f3d7bd2312b6a461e4ee4ff3d4214f5fec05d06a25523b096b2a7f04b3f717518407f66fa340a216615b057cca481f829a2d6898f7d13f37130c1c1827746e83e5d96ac23dda8f5fb94ca9825c2ace314bd501a0fb2e65907f00593d95d66503e2d55ab8cac7cdc013b2374e64d30f9f1c23d3ba49d768b282b5e70abaf85d56f14e2ef23fb0cd0149edec864f8ab620356b3a74f0b34fe71f037eb5c1c411ea32a5b82f377d83f223992d79c1f5785d36613f1dea2102b3d06ffd5179f0142ccbd4a73691dbcbef28b2a965df75f0aa21d9f3ed785b11fb9a0ce712f567ab4c40068f7592fe0ce94ea38167a531a4126bf0ca0ecc4091f73933ca02796d487a66be12a30aaae08ae6ff7b540e6bb81746d35751db810737ae20f0948c384e53ec934f6f99c4f7bbdec8c61f65da8fd536cef367be650e4b2ed1a50987e8b59230e1016210c36d7bbf0b8f49b067ce564e06e89c5b1b6f297c07b770cc82edd24bafddafef86371365ec9647095449cd4c54512f7343b5ddaf62fcba9f296bf0c3f538b1e1f879a8021e6cb9d2283067eaad9c81ba0c372fa4870e5bcda441c83038cf6e74bc98b40a751e050959ee5bff8793e98da70f58f7921bd27c1e38bc27e47d4a8145565601a8bfa9412d977c3f82be2b731cd24cca6f20370522e3c06a611732788998a0304d7c637f80fed361abfcfa5074ea848ba38863c5bf66fcbc8bbb9ebc5918f0071cb3a05db5a09db7b22364f656305ee76a76c65f694b527204f1cdb3ce5974c6e6bb75c3c95c3816049b189df9e2874bec173edf2930eef8a226a19fd9ed22af9b31db037efeb640e6a17f02df3ce662be11b745763ef4bb7c06144d52ac311f89100284a5e5ebb6512bb9f9154f068f911bbcf7ae10d5ae175e1a8c127dde757f296d2fd8eb77fc98026343e72b376dbc0df5a824f060de9ae1686a3d37eb12fae9b6bae388bcdbd7125b10fb1d1d1b6024ad313ec528c257b28b32b05c4d0a915dd4ddbb29462b1f0eb8dd313bfa25cb9552d80c9ca47ee4867795eb9c5a8a8ef06076c5a92ecb5957dfbdf9c41a95e61688efc5ae9d44d51f07c037f83657e783d458a23b55f77d8ba936421d24710a99c03b3ff04c060a4f3f3f669eb3eb51674d42c3620d1953c94a4d5a9aa00a4b1a1ceb24f22bdd054558fabe8097a05034ac9bb6edd6642765f6992c77b2b5fbce044e500faaebebd6fbc3be6d861410674a3a113b5c5173c99941febe70a215542e69ba57da3342667173a3b9d19614e1bac99a8ed30caf00d2fe33f6a5311db5c1d106b98ee5555b0caedd023aabf05960e02c0ad87ef50ce38bf0bed6a90a64600630c176f63624c47cd48b5bc89a17aa1b5ae876ecfb07c1f5689091619e6d6b053c9c5769704633824657e75ca07bb81c997d8fa1121ed591bfbb73b96ac7a3c06bba27cab5649aed1efffd6a3fcec3748965a378b5420359068d3eb34f8966246afcc129be3310edc0a8d15aba29c4f1d9f3ab97044dbf1184bea9a077171ba6834cf0290f260b50c28b6fcb2609c78064f0d7f619088f4d8cc482d91c9b6b937717d02aa594d7c6a3c19c0bf114d6dab6dc44498dcaa626ef3354e6f97d33a91e308f99466bac88dc6561839c978828baffe69277444570b32b1d93a944652ccd334c1b115198dabdf887ec3fd28d1dc7799139831583f74f1eb4ded0f2f1792f5b6c870c2f8e109621187850a27d16bc8a83ec8b7bcd172d72dd18f23a036c141ef27e6719fc8990df2386883bd361642f3b6c2128e6f075a23edc5651bbc0ffbfd0f2ca18f75301d8cf6beebe3e329b1489a2d242af6bc48d0e0ec6f8b2f953c93b870a2878ab2f91f24c8dc7babe36d91b7dd79e3fd4c58de9a002cd0b9f3ff59b9c77510c0f94520c89f94282a3c3096f2317182454a354e1551e95a94458c6b5f7e7accae79f5a6127c64ba7b2d4fda1fcaa8540faf1bdffec1cb62486028045f4b4704821237e7d54850bf24efdb0497c1846637ec31c9cc9aa3878051152a84398345c7d37f969a1c03c5a2786272b8b1430a83701b77ff32ad2c6bfa343e3f05bd7f4328b6efb6a3c377258788e8a60401ad0e7d906cc26a9e20f71031c3305714781687c8d408609ca456574ce6ced8c264b089aca3c0d50ae3a0302d40554ebba7703f1cf30a481cf68719c164f38d07eb9406806e343c6a7a64b60c89529063367a1cf5e124e197fdb4416f19f6eb3f9aef4af5333889df4759d3dc84fe960b17dababe69a80f49d7e2ab51143fd56a9b12118d0595d06cc055f0ac5946c74c536f498583ba634c8e5076850f4fb52307570b2ce6cb122b54b68f2a6334d4cb501c20407dd6148e9b5dbc7020606f828ce989e5e3d8203825112a4051c5c48ed6e9ad26ba23e6d663ad349a400bdeb85356acbcf3bdfa3223e38449954e5db6a2a8d397fd396c5b7287b494cdb09bf55373b40b381f78a053a2c6382eb56300e618415622ef375394eca43d7d467004044bdc92d456a1a34a1cf8723525165be080c1336aed6900555eeb15fb35b6bae5dc252158f0920bf1c6843b1aa4b29443fd8ad49db5c4db3550047d8730a199f3a6e0eff245a5bbe29bc313d98da260826c98f1707290319ccad81a6d7b1e15e1e11d79dc80a3913d7b383dedb9b4e617cc0e2035a3a4fcac457533fcb1e81332476a412edac0efa95e85cc37ff10bdb4fe497d875346a330cf8b63c9131c809677c04543830ce5d96dc9f555a2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
