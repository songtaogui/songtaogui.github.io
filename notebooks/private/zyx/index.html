<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b348e5f61c7a17d795009c4660eda2249cc03391663c3894aa48103ed09551935707f7919459a267a0383ba8a9570b44371ad35eda4890ad2bee3ad04156545c7ca023c021908a53f79a5253062e789969b6a8a65e2255963353fd5e067d7ff421394c53f94c469585ceb33f4bdb6a3e1885fd16c9b5322e3547bf2ed37079f8ba70eb691061d65e67793ea0c4cfc3f8d638ae8f921f5d920165ab039396d16dd845344f3d6ec89bf8af90df8a90fe3cd86553c884299f423cbe0d04c0e5171e665777fb84ecdb02f5a97f3468a7122aef42e53a5d552f27c55675c50f65b087ab3d897bbbb911d65ca8dd8456da33ec90bf0221c187ffe88d9d90ed220e8b545db19f469cb7b76eb7e4cfa0586c9f367d97c13f7153d898e1b1db3c5131b5c0151245be89b604100cf27430d500d7125025b4dc148bf7c6e46901b10f5eb26adbb4fbcf27accff2c062aca7d86b0c9e109537948837c4edaf9f1cc8b99d9df778d24a57fcd3f678c649ab992488fe52db82d5b60d38d6d146e9100195302d975ee15a123f29a6e9cbec4c8ece9b427141669a60e5ced41ad24e3c175dfcd329a1ca8304141fc38e0eb09cca6b4b8b8cd1dfdb4c4ff596bb3b35e9581e341d4508d0834e892fd6d988bc3de1be0ebe9464cf1a8916d21369a4f6aec9609534bf210051e674912c0d1a3ea56630190b3a70140a4eb6c82805d7559678f604a6cf5093e91c2641ea7beaba5cbcc5f8bd6ebc8532bccf1525026bb952c295b22d79019ca59b35800a26eaef366e1e0abe28c0fd6fd6dd90933eca152b534f18d92830a914061db10caba9f872d1087f60acaf4332c6703bd7535e0e886c8cd664b3627925722afcdb051344464673c965413b4dca50b6f05cb4d904156ad041c5f47348ca154832918eafbc0c74db83e9d15c1d9ff9377b6f179c2810e8a0f7ae0267c0ab45357b8291bc4b840ebab957fc2665416b7e9929c887f5a2a21e86d8eced0b6e26a43960010528db2d5746661f8d62258e2e890916c4c7556ba60326d9fc7047b1398726948cd1cf60b2c188b0a7cc71dd80edf152ffd5e8cb8465c6c708bb55ccbd3d355a8d7a9952adf68f68d726f5eb1c551d261ab6a6f05d0b9b2cea3dc20d8c50738cef1a36b6266ac7bc75610af6e569bff86484dbe767a2b6440e165f5cd6de9fcb49818e91f19e1cde91716122399f1ce2589f88aa814cd397c7a25a19cdb77c11b5abe76fd9da276ac0627ddd0f7c9c4b7d125f40003d1bdf70ec575896f43b218b99e1f5514bcfcd0525b33e84a97b798d3675dd4b107ea907ff12ac52336f224291b297762f6c920bf04eae244f443e530e39811707a979301616616a3db6110c0b799cc68f78db1458dee48b55ca24c9d3ce9f6af03060d2e44ff81a3f43baf4c4e779a78bdcf00af074b29ee079a9c5c64b20a5a4226a6b541fb0b14b2aabd252082c158fe35ba7026239c1fb750055aad19580ce538bfe73e79132d363e9dc4c51db6e077b927775ff21db530aa1e6d28f07be1e3bcf1e5f6af0b6e5507d8c155c4a107f9a4ddd9328414e3841c2045d9787bfed99a306b4ee466ab57b982ed243de681420f862a8a32a08b99dbb29fae5a964a3d957b71e2ac7b491eafe70fe9bfb610f290dc85b4c0e09170712d3c126412642ef46b4686d5a8a73292c25993dd4a768eb36fc1899a9670b672b3ced7a293c35a5394404619e44ee8f7edd93ed752d213358511ec7c242cbc4d6d635b67d3cfbdf1e62950d923f9f08671150cfe45cabcd7d4afc6fe0543041272a1bb8073329a0fa0ffe0d8ce5dae30bda8ee10533f3b1fbc8e0eadf50b0c9f630c13a4c907b9e46aa4f2f2fc31655f4e8867b2de79daf307b330ccbdc5eddff3bbaa3652dfe1adf7dcbc42f584f9af4d59f12845c0f570f9768720e79278d1ceeeffff141a91be1eb5f5dc57ba18e2deb4fd9168f610f545578a4beebd7739cc070a683d004968435b3334c939a8690f898b374bfbdf3fe1237d41763085fc4cc04b2efb866aabb3e1d3f96192d1f477d3fde4a77edf077854abd8d5a53a8b25de9fb421921a3dcac5d69308cff7c51fe600c3bf5d00c998d2f5087415129262eff243b134d15a9b45dd166b03dc6b9e42142e4af1efb0fa2ad477693647381bed3f8b84c4144906be392e93c34b186ec52aa5258a7ee78cc586c37f0270b16599b10ea5519d47c613fba9f6ded989625a634ba88e56da00981e654f002c59f1757e68c3ce9960e5dddf48a21995ce474ae065552b926e05496e766d581b5e5dd0e53694bc35553f732c8a769988697af54a1da4a9e56d9c04d3b4bd37d66e1ad605146ef672eee34b3b1dba6127420dfe1ea3b29eb5f369827424c496155925f2697080f3778c56502669dff486b218641e124aebea45a7aa8be3fdf115e3fc451d90832d2f208b6ce00654b6c9a43d1b596ad50b4762ebafa014b06caf06288ba1abd70045e63eb8e1873b92bb52b00345c89d6afc8f6bdba524a38c0ea54e2adf173367805d6d5ff9e89960d8d12486eaa93f662b51ed01e41a9118f523edc8349e8e20cd6bf6f5874568c3ba0851c7243a71a1bbe5d68568d9b5461d0587b5dda0fef5ecbe8bdc5e0f68ef308dfc3db8317eb11b807cdf154080fb24299e1fb5627d86768e2ab4c92f0adfa77c4e34713a4155cd2b45b51dd7df34a8b08b1d8d1047fcfbcd2e0c860ed03ba1049e1cf30bda5c5076535cbef43dbdc6f6422b5d50d518ce848d90d556887608c1992a8bc7c6bf5fe24a70a7365b9903bfbbf317b8dfcf168f9783f661378b944213303507160af8455d8918a907933825e410a68e89ae1805b987e903710b2135682fbe72c216a12267be03315cf9f43436baf73a167830bfe63bdd1562980a7017891144b5590498b1287d770764fd17a347087f48ee38468af0414bca8a16946200ad9d51b711401c7f211f902246bcd93eefa82367e7e5f6a380df4bf29713ebb64eb20926ecd4489c6e9843f3a45070de1a8ab2e8e4b23b6deb3f48588fbdbfafb1e0f61a2270d36352cf4d54c9587e8b760bf2a4a6c1be8bc6603dcaf3137d311779cb8e7c437ee0de59b7095c8e90ce497a0a7334b22030816cb7213ed8d7e4e68d264c533ade963c9d6d63bdece9bbaaf3d3b3893007898e68f9f8c059baa77b14a49f54c6a55929f2143bb3149ea48eb66251a8efc25ff92c7c7e037099997941bfcbb0f9fb13f9ece5b0ac4d60ceff920ac56ed8cafcc702e8cf784bad627a4102a339209d904b701c45b11bc22011752e7d2e5fbeb0c79cab791cfb5c32e78fe92c5f16b1c31a3795398c3240de68d155042f3b9ebe4c65d00fe8df84a4999c8a9f93b8c53bf5e57e38490882c6039584fa72c4c01f856e4a61d8073af7c16ffca6affbbd26465b54e3c46443d5d567e639963d83b0929b77e5a993cfe44016b5d0f999e785eab2b846ec7fa4dae11b3bbac1adfa548733662eb063ba48b594c2e8749b1abe68e18666c885a6c830fae2f572c66ae777d8f54a64eecd9b3592bd9519e5b8a4e47ae2d057adf5f2e7da5454e40774dd6c48161eec366efc4ca00be19ae5f9d123bd2ba75b7a90b4e9eb12f7f5d521744750d2e8f0bb2ebc95e23fadd60e49ae5081f4395768cc61acfefbb877a1e421a463975f210cc747a68491b41e673180e0a0efc76851c68ed1ba78630777bee3d810b5f15cfb13730f90d0f02934849f471ee8ec551371affc63bd376b744456deea09dc9db4dc0a988931a9f7a6a105b2e786335f84e46d2c735f882791df3360b137b9c886f195f46cb96dd124e0089ac78d9692b644425229ef599fb3e80ac8681b94b79b0c95a60162a016d54522453808165e22ce79c6aa38d3c199178a330a34ebd7bc5760c4804ebb63bc7853bf1d8406f4eb977940566e83f7b649eb60f764cfe87e420698657250336aeddd12b3271866f5e25e10a749ecf111019efbe48845fadf92fb8614792f99a5295e65e71f16031a5979f46dcc3828b686932d685456b7526791741052a483d55923ac779b77c50bb97b2eca7b7026633e914c9cedb3114ba993fbe7e9da9cbd1faf5620b44e5c98365e82a276ac84bc7d89886e36e847fb6a6c711f7c625c02140b24e89e8ce005284fa8229e5293ace7074ee2dad4edd3f2dc261cb0a74692a676acdbc60430b1ffe1e0bfd184053b4e6fda0afd00a7a0dc0b9efaa8000bd6a984d4d701110e84fd9e13e0094b12fc555f2aeff90f42cc8369192c224d043b3d5d6132bf211de430ce2eba496e0dbc6382894fe597a1c533897dc59fd9dab348051d0967958f8e56d871e63059455e7575644353ce2b93056ceabf828eeebc7e2e0c0d6574bc49d656be8bc8c0c8912e7865b54590dde72226a45eabfb55806798d2b5ee81c1dda9f65b8724fa95e78c51b635e1e32c2292afba89f83496e093d3ee685debcd18bab8309d7ce1cdcffea16bd565d87c71db6da24b619dcf4b997980cc9a2aaf69e51e89ce5a320a1fcf5675bf319b264e43c9c15b603adf1861312199eb03c19853adf2b1e29dbbb553d23eeb637e8e8791a7e576c1effd9031bf3b3fc94f8d503884c2565edf57b6c85e1bcb7880087695cf0e9af03e8aa6376e1a0190ccbb06cf3dba99c2590a2bb4d61f5644daff95aeb0229c70914cd2615a066fc4c854afc79ecdaa3e6089d756e0f181b91e86d65541750dd0919ed0f375e6352adf2d80965dbdf0a7de517f0922677dae1f43ecf2aa448d7a2405271741ca61daaee087bfc1021d1135ac0577df1998daa3707884c91ed36d19bd111e034ba5d92a050610e1cbafbec6168cb6547828678ab969bfbdaedc43d88af4fb4125a5a3d410b8091fc31546779285e1e48181adbd0122b2fd833eacc15f155e70dd95484308a86c92b4f1ad95521a54160b8056899d5487186ade720bd1b1450bb9b094d09d173fa8fcc477fd4f53fae60d775cbc8eb0c1d2c4ef394a42c92cec0cd824bf643e7ef8a41937383724f3bd0c5e119f33512723c8cd6e93362a7095ff71916bf0e2aa5669bb1911167ba0f6086c076efa87683c4ae449f90c1d6cc3e8fd191dc680ffde5ffb5a559b0197a0d8e2d59169f2ddee00ba1e461a45526451d4e6434104e0c58c86f82abc59c2e04030aa51e22f4db4b6ca27b71bc79fb85d19529899a3c556f1541d847f934a87940b79ce0574c827df64d771959234fa664440d4cc7d3240e19dbd0290629b0eb5ffa893d17937e5c1637c27412b9bdda2246d0c35c062e295affe7bf1e307f614e936b3284dc6e370aad81783685d2a4f719f0e9d8fb9a9e5b961544fb84ec6e25984c59bf033bb1169728134c920cd4fa91e1bf9f9f44ede5b01f165a870cc9613e744b02b11aa07e1141235b73d910b1c278056a5c08ce5ee5a560fe8d008d41fb2b2b5fd2e72cb94d47d50c9b81f35c2f5c727e16759edc00409eff77bebe21d5446217ed59ee52c0db553825af1ebb0feda27370b5d3c0340419dbddf1203762794866a3538861bce2411a44c2833f5105ba6977bb2b42be98d8a1db0dd0d352a2929720b8fe27b771efe33330ca67d4a0c7ed6f597695057beb777dbc7c913446d4e73ab77de333be1c813a94233ce48487ce6178c2fd7b72f0f225f5b71944f8b2921d3c47c13a76903e89bcd8819ead5a597ac6c8271113e2366099c4a10bcc438a2da27add6a87f8535c67f749c8e04778b4fad9f3ae6cdf3a153e317eee0825469035beb9ffb9054bb610aa066e7b89b6694c4492e073fadc727f5162f37f281410c67b3c4c0e405abee38f6fd2310eea6eab80087cd7615ac45823e27d5b919ed6a57f511f0e1c2d73bdd7f95ce55334aed6b99cc9257e846900d389f91862b3241ddaa8a579403599a2ac55667c9bd1b8754da7178fae497e273a7653d086a4153c7cc70f1cd602de92f5a4c2b6e11223d5e51265dcaca2bd1c0954d4e7deb081a494563ed971da99903a877d4e45785552af75ff590945ca7dc1f56c27f779de27e27a951f471cfcdda8d4bdc89307b548274df5b361b57772c6172077c76c46c1669144335561c2ce5ce5cb4deee78fadca85b75344854d5dff6dfef47885a52bacc29f0f067db59df6155fe2650bc988235316967fdb97627c64579324fccd5dfbeff23e0e92112082e36e98bb997a5230c50a1a17da66ffc0c71f2105ec574412de51834808535797cfd7dbb7a05f09ab371e649083d75116ca4843e940f8d2628c77477b7fafffdd441262c743c5cf29e67ec32dad6e609d80cc2cc6d72e654b9d59bff34801eeacd68ccf906f3efdba6f8de3192e28878a245920067201359e42dbca0b6135e67a9902bfbb89912f3e955f577b717dc5ea5c7b01a4b6c03709e98c4010f12036506fe650e614dc15f83599d498451632c8cc243483b0390fcffaf4b690c7a03513a4549e8d41aed24d8eb45ac11d264b93a019798c679366d73be2129bd45ed34f48a8a1267d0ecbe076aaae46a9b540f58169b77c25d360167bc8b97a9d9f1dcd940e2de79edded811a39d52578321c9df43eced2a3205e9f2bbe4cdfc8e106d27ec1cb2bd037dab144fd332543a80d781bd62cacb19ba8e5da44b9f1c1d8274d093502990b123a8822824d3c86a1e9c15fa559bb8c95612efa565052438a667628e6a1066d2fdcfd13c9ed65b14a83b9dead87d1214a08de801529333b163b0b57703248da54ac5227e2585e84c516d109850884dddae65b34b1831e268a3c8065735421277528d98589ad40d4cddce970a0153aa52c639d67171fe3af548552578f2afd466c10c25caad9d1426a90378882e9aa819486df9d91076fb750b4dabbd0c9eccb4a1256dbe946f4bc8fffec96956285d8f220f637d8caa030366f36637dca12ad2c82dcd7469ef197e594546b398d7468baf49bbcaad8bbcb9b37f1dfb78706819de593efb539bc822b0fade62661853e45aaade59803c87fb0a250db64d65bc3f16a024b9629215b8d20839bb285f0a6e38ae8bda2e1b005ef1b799dce0616d2362e3f8705a6fc9e499027efa185b2ff046044335c2f26866bb743e7f8b9e2c110381029e3844be29dec8f78377b6d6e7550a315cd32410b382ef13b3d5011a304e09a776387338d783b78476a06df0aedd9b3b61296c9e2566220a6edde65f304a8576a5d8e400448fca8db240b59e136d67046650516299fd9d26f46ffda726329da9e6d0f8095157b9c70235c315faefbaadd13de3421f6779d463489f0b32fe019e7289d2819d3638d232650666b01b9c83b2a8d8c75da659c0f9ad7704ccf14b0b1eafeee6db3c58ab25bdcb848f721b46f5a41986f590b87d6587b18593b327da404f6fe32aac3a842450ae4995e859704a468ebfcfef829ff1c471f699243d6e03d7795788a09c754ae179e2b201c51668a8394fd1f37756054f123bbd30762c17d70559bd5a377f33eb9b4afdabfceb1c68f041bd701f871880ff2b1f72546026748b686cfeb1372617b4a3dabf272b4e2f621e76b89ecb898ffa07f06604897403581c7bdc4e208cab621250df99fbea80b6001c4b2af83d72f3af70cce425bb28f3eeda38608fd9d8f4c5e6818d3adc7916cb924118e327b273301b19d30f08288772dd58f996b95a8a12083b66fa67efa306b768659e6d756764463ab7e7c6c4ea4fec83d13b3054b0c6572b2e3c4c51d33253e589e076851a55588c37f8ba33a7dd63630d505ae51933f96c282e6bc7b5c6d7af4fe8d918f02a21258edd86989ba0e2dc04e6f2237c83bc3d95bcf4e9d03a6643d3f0ba7776a88874af80e4c1714ade8cb6e261b0d2101fab79672e054f5b45473145c83ab7ed0d57d6d104eb4275ce7b8732f2853cfd7d26587e7eabb8ac995f7d84c94a8b8b368fe199413e1965d50d1b517c6f9bddc01352758c5e359f8a6cb4433161bae7fe97a50243c28fe34a03e3317ced7ddffb9423f4129331d014f80e13e04ecf0e23ce3ee3655156321936e291fdb4669e014bdb361f1507e076f9ba81e0a6833a6550df0afde58256c7a196896225f51ae8d15f01afec8d758e49904dbcf593d81d66a325410825668c7dc9c8deb89b44e8f6098900f4b412b1debe884110f9e29f37f1dd710ead103646cc1bcccfc85dea06eaccde6ff82db834d93615e04c840f304a36780dc67f67e458a53e2ce99ca0e8b2e009df2473d267925e2d0a9aea16dc9d9bdd7d8ffba46e7e1baa6bf58f8ec40be3b2f1fa3f6138053973657f3866b337e2f2fa11f873f88fcd058633f99356254c92f8cf15752e6ca576f797e1e14c3ed340783837c46ba6e7d8223547d38571e4b0a49bb002d91a89f1966aaf7bcaacb76214e7fe4d6568e87234be44ec8f54fe79134902958c3006e91ce40783194c2a3252d09edda672f6aa317758d72a58e5039ef8a94d6552af49abd69b1f6e571738fd0ce0933dd41ddf3ae03c52725be94fdace542e5d3044000c38d062b1aadad70f26fd9cf34b496f771daf55c4a28cb2cd813ccec9e0aa16136a157ace40aa71b457ca597e2f946f02333d984cda4f262fc50af97230d30d52398460df530d3bc4c8ec20efcfb7b4493aeca16db4de01df2c5e6103eb6c4298fb29218072f20220cbfdba8ab683df738da1ee0e30a2cc85ba16ae65659029ec96074cf0e1d4d9d123fa0aab48db943e8abda4958aa56803c15afc37bf7807de1887bc2c8302051c0ac714aebd6f5e702aef9476b46115009f63284b3dc2ff2b63b93fd38ef83db7d9deae1ab84f6ce9d9d22436a7bff55320051c00abcc67f92493a8f0d8863f2813a202edb632edbe5cc2c8be8d6e385f7eb498257c39b897b6139ee95bf97cbc252954177343822c078fa6bb7af9e9bd96bd2ad387e32b3d954776edb00ab941bff72aa11ce1f49051421145d51137c8f8af819f262046bec6f89520d67effd1abbb55379592454850c8cf1c339c176d0c0ec83b5f63d146f1767fba95c4f964ab6910eaa7e0903a6c7f39c88bfef864a9826ebe1d9727ba98cd51e3f008335929e929a06cac70f6002be2dfa23e65ecd23f6cdc6b3439a028bbc19037f86852f3fe8709a705ec97232f9b4ca2b7e4e0ad425361c41a0ab4fc87df7fecf287985c991d996db5770df255d43d15b2e1528a39499fc05ce7584b62cb9dbafd672b9ce05f0eaf56e321783ebbbfbb90ff089b7118196f31087e5eadf015bc012e9ffa762e3c1f8587ff62d9724cc3cd815b90ac51fea0fc19ec82a11b1519d790f4f0177853c28837b3038f9aa750462abe7e33ea9328db322b3880d97ae7acd5b7f5c3fb06323b681c7a9c03458c5af8eeb8d2e65b2039c85a3c3f1fc7096e54587bc950af1fd97a5b573fbb18a4481184874bf0624cef63bb43e3e848b5c0b4ad446fd2567c9a102a0b68773c06b2d81f1466624d2de0ca7632a047515034870adfaaf15e172ff390ba9918050544b9e33ab2c734815b5a1705753ef52240d0e50971b3d13f0b1a95825d499b7b3353b24ea7b0f206504a827c4f5c7609114e9ae7b749ab1029ac449fdd071b4937e9c4891dae55c39802e8ab1703a0130c4088608f28086694054ce1b957dc1f852aef892bd88f1ba38870777d00dcbbf67eb3bab3ab7d440070dbc9bb65f5ac339ba83ffca856f88736856d40025fcf411c9baa29e649dc61f15e119f7d14ee2822cc47703258432dad8e855921e679a9d329294c511e77a22916cba16321fb1291a0be09842c8e49f5fbe384ad23bedbb425071937561e55096c4a4a5d66069af33c1189312eeade7d9ac5d0d032280894facf0ec894635bce9985e3e4c0f4b9e5836d5d80eeaae4a8fd00c80113c3e4824d39931eb75d02f4549928b71fef0dd8c8bac4dcde6f69af70ed000c5b4edd861cb67fe119ae306150a076b53b8b7e4ba353a0ad274501e447ec16f8674f4b014336e29b29151eaaf431dc5fa312ac92668fc77542ff26833f69dda23581d09fc4b60d79d818f5aef65a6bb5f5b33ac974ecf25a441b56e64ce006ebaf0b9773cb0b87a1b9717f6638ab3bd7c0d87f10a084ed8c7654935c891dc4be7dab4acf1f245bed7f31949b5a9f0fedf66965dbb4fab040ba5d8a6f93bf6f6e440f274967ca563df8ff1c8a6bbfeeeaf9f8c46d58f274b2f677406290a493ece9d2164badf01e572656e0abc26a5854e4ef98fec228fa6019392dfca4bfa42bf167981e3881837fa832b6b74f48af4850da0cb1ad5062c56f3b41ba451f11c101c88cee3360b71031b478f603ab073c515993a2d3f0c88b6145aa72d10d04594fc9ab280a22d61562548990ea909576f8f82cfe7b011a40cf25c1ac5338351b78f2917b03d68fa5f72f4647f049b17821548d1d5b6fbbf766d0d6461b0b2a36f7b204021d0ebec91a5af90d6b3d1de6028d39099ac19c77cdbe3ad3c6fe3b248c8729c727c528e203ef3feff557fb8505a79b35376ee697133f4dd9a467f6181c7669d2abd7369d2edbc450787e3a8bee4f03cfcdc94929e4ef487f65c3eda5cb6186ed8c381b5621f4a6f423df11b134923974d5fc6f0946cc153d46e532c49c2b4a441865673bd960dc7c905bb07ffae715b852e666ace814fa7836c2707b1a3462af494ff2f0bb962b080aecaede0a407c9affda7f3b24871b1ff4342af387233b44ce3acac097bde0224d864c40ce48a6b07dbe14fe672fcbddcf70b6043a65dc252a2928babddb453b747cce0856344fd55ce2aa7a263340bee91868e86557b22c97245f7a1819def18565c85c629c9b7d870904bd93f15b01ce6d7daf6f69b34363cb633e3279bb29fc5b88ec8dbd34eb1e9ad0dc3b1f8edb3b4ba90f31d6c9467da03a46dd9f1b8e3ada72c4d5c5e0460add32db127edf09fa2360f40b4754fb81327c5c2c0e84cbb498576063a3f2da49e79dfb0a5f7dee6b62d2bb5be74d85ea5bc9cd170d1ee72375f62398eba76616174cf7eb8f020dada2b446e31fe15fe837ea581e416c6639303c497ee8d6c0a1650b2949f32f0a3845bfca2887b2ce7ce9fe6d102c46e887c44a734502e0110251c3967b84905b9cb35b70326d05f260672c1155ac763f2931de653974a680c4ffcccf28a884147801bb0615bd1efae9df40062fd6f59c3aaf9e23d821879b21eccdf8b97e740fc4567444a0128c85dba44037e4cb528624b8cbe6f118132142414d6e384b1cb64909e89db1e6ffe96f19eb74e2cc2d8e4e89904299996d59163daf434d439a4b5d19800743115de8f61028697e03fb6b7bd872e19eb9c55ed7c902582a265e7cb7bce965928c5d17956463e16ac5f3e03bba0bf78550b1b9a7ab9e37f85b66697afa5eaacbeb9214a10d396fbbae2660389c5ef92fa7290286bed97377636fa717532ae22b7df9315d4e7709886c768b372e75d1af7db4dce47c67fbd2440a41ce45f47ea38f28d80b49b6cbce6e1c1bc05c168bd43511106daac7211d000759b6bc6a706f0deb5999055645583da2f182b5096545f657f4a1810286d527418597ee1aa0d769e2e1ba3225582e9e4a32acd756be24effb5fea130319795633fa264bc40c788a8cf1707cb7b08aaad232d73457bc8ad9deff146a651250a76dcaf6cf25002856d33e0a28b0573aab5a4333f5f40db0a013b6b304d726ba9be2276905b617dcadb2b523dfd804dee87a595ad39ecbdd635a88f13ed99c5f23e6a3bf7b3b28c22ec80d1b1d49de532bc4c957e26381c2b34b446e9de490c5c24ac6a051243295a832abedabc098f55991f39e97933c0ff822a4c8b80e901a6b11a74bfc5a458ab5c7504c4c76e64215b4c694f9605747a25a216f23c865e68275834f3493ac35f4047276aa03a98123f6b4b2d7ed9ea00e532da9e9a6372105d83b0b349a89213145142b893f4010f137d552f358ee8d25655e7ecf000f77a19532899444daa68850e97292be4209d534ae8bfe108d5ebe838f32d88ad64d3ae9ac14503a983fd6910ea8cf3008545f260b90ed98299ea2e9cbae944ce2e8ffffd4646acb49a5302000c9195848c112b796eda468717aac22a320fc8d105e4a06f617ca6235485b9f4dcb179ba9a77acbe3a69d6c7d4bf91f1ff225fb6b9e34909c450de5e1475c0774a2f13b9c6c004620112b00e422f16a6a69ae07c7f5f145b4d1918642e4853f7b5963619a184da7bd509ba8dc8bc1099bc965a6e62ba666bb2857e8b97690394b147782ec3dddba7aaf981e3011a9ad62d9e134407b69b1afd7bbd4fa6eabf903a8b44a2fc87fe0c5acec08f9fa83327f69e4b92ad014f120900cd2e97933e1c477f3a0b47bb7648cdd530b70df15bb734305086580c4b85effee0f187e065c180f01ffc4cff82da90a48491de550ed0e0743abbaf50010877f607e4627a70b8a990a5c569c38b5b2d151a5ec29863581a19dfd8b50e955cfb8c6cc9dcfb9b35dc00a869782adc2b574e2b456c5bc99d5a33d02d62b9a00181de4b4558f41cf1039b7d7abe78942e6bdaac866344a3bcf004ae82cfcda6979259364be49fc0fb3c8a3f6a0419b9fc1c72acbdf2348f7551c91de6dd184570080c8a01370913ebf4c070f5a3d360b43afcb25b06fae9c391ca827cf0ce53352145fecc289e492a9f746c9ee84d123e37f3e071670454752087570f6c78488965e4bf5693ff2080544e43b37a664d320f9b87775cbaeca36a8327b80d1f85981c7e1b4470317c58c22f9f5019b5089273ef75a0194e840173d747401dceacc87bf404910a3da492ce751e3e464e32743c030ddb7b65712a72e5cd1941f0344ab4761848317d5a14e564a7861b30d3bbcfee53a7256d4026c48eedb096b9a33aba6134923231525b6410a82131375808ea17265774e9d32aa9554969dbce1d6576b5403367575e6869a1c495565aeb3f1ac6e19b9d84fc5f6b4d3ee6c17bfdb09e6c5b2de27d3691fd0fcd94e6807acd7a7bd243618c9a97a39644a7c6dd597012c79dedc73414c170332335cbbaec4f0f4da1f35ade17fc6aefa87f1cf0a20730c61c0c275b439506603c5efd341cc98075d734967ed9929701b48c669756df3df2e812b7e0bd94f1a74ff1ab16984e3e08ffa739abfb8b374cc875ae95fa8490d934a1cd19c7d9efa5c8c94566fbc231777d5e0f5d081591f14c8165465d230459f54c228599865b9a7a6dbfd08e0f688ccdaa87773e31e52795dbe0f63465c67e80d64ed4559a46025e328185dba57dc33ffea8632d129800093d07405a5763f08179aac2e34bed4413f973d5b2238580c77276f695d14aac55f6ee0e976d473960530d4dfeda1843fdfb757c6550ba0df3a6cc8093ce24c3195121b308e311acb21027620daadbabda9acd4b4b769259e83190fa48de6ca31d8084c9bbcc0d4767b0c30f1c154c07f28301883f2534b60318e5aa63722029d9672a0dd93c5a18831cea023cf86014957bf3565b42498efc7a7bbc2fa8e10b1b0728b63aabad8772a6f56e8044773b6a6ad677c5a506cd86682a664ef7bc9169edf95bb4bc188d5c0dc83532dea73deaf16adbf909b3a6e25b8dea5af09e69cf13203b761688b6b6c4a6d13167168b0c296c8d0752ec35b35cd9faffb79cd12553a03e4fea8c57c79002c868256906c239d1cec3193103fa103de095bd7e7c0f75a65fec5565065170bdcfbbb071e95190beacc7c6815afa1bc75365a84ecb7a8e730c9b2e68c8aa505df647d5ccb9bdcd9fbb1e0baaa383a02f6f1b7682f9586bd3e1cb31eb981adbe33ab20f65ccda97a5a19bfa5170a1ef7281363a472f954eca1f0ed9a3f2e9af0237de0f7fa8b59da6fa8ad8d71c557776861da0dcf11e46c1a5dad1293bbb61739f5f6602c30a80f98ae37205a62e95a8f08eb2e29f0fce91b8618f7e51c5c0059d465a9967e5e4d2454d304c30a563f8e911a9d770990348121290342d307d003fd6d670b2bb1e0b89fc7f84774bd0f8462463b5b667eed2832733fd2df27de7bac633d6740e9672217df6a82fc6f99729b4f222fbf6d78fb51a8500253f7059ccae3679cd172dfed5555eb20bd81058ed5b98753d38e9a42b4672103eaa3e5e5707996c24b4434e378dec8a3bbe4385bd873d8ce09ecec5b24d2aad5b7179f6c5cb168e03360276379d3075c2ad283674b984b3409424a09ad80573d3f109673b3516ef8dd001c4851268a85c99ef645bc6165442bb383ba1a17a516350d596b9f2a38c5836c4c87311437df9b3d7e52ddf443b22a20ae8baae45e8cedf361535d5ac1e35fa84c009298ae92d9792f255e4e8828adf06949e602f99fdab98e6f6e53eacbe3694fb53b7f74635663ef06acb5ca79f2cb8147d48166219135837fcade16a9d68e7e190127e5858d4e5bb64f41b13e6c3720d662ea5bef016d33d9b97f3e20ba754fd66db04b98c48666009b1bfde9f427ba1dd705f656b27909c5a061d2a175461cd08a905d3a545671c0f1de95749c0acf2a62746c3d6537ded0cfe2009d61d5ae60b465724d42013b3edd9a261d07d25244ab6e60ea0b93fa443c62ef3a3cb846dce791a6cb3273b14620effb925b4711ca3b6e4cc8ffdb917b31d3ddeba85acdab26421108c2cd175e4f806f3c529e7b48cc7e92ecb6c69621ba40e88c0c175a478eea0fa6f58a253a49930593433e7a41693459142897750b48831e983ebdff9ebdbecc370885e58ff28391bedb1c0307add8d79da6f8897d62ec86602ef16909222c5b220cca49d43ef9983b5cb8f5b4f29412d6806e17ae634c43d96449a8a041fe13e6e0b3698986102a7169f1c0f3488bb541c97e9766a349bdcca15b9f83c650c1c345bcf699b6a9557593cc99a68844fddd53d5f2610bc9dc2134f69e2d196147fa9ef0126d93b82b3fdbf5e8f9ad9687b626ef050aa175b9ac87bd7456a8f5f92098f275f9194ef5e516e0ab42c2309f43c7a1d92340f10f754f1b69e8fe646474e1d272fe942578eec5dda43b627bbe23d441e7ec434fe477c8c23292a5581c403bfd1b470606051849de950d0e0ef32c5f0abe59babceeec462cf579edd4e6304a460ca99dca3fdd39be82cfe3536852dab879d861761fe5f0c0e86d84f79a986aad44404ee61a2807e00f8cf79873470ced086971a64f75f056010512273eff115e8320a805db112d5d40427eda8e9a401d613dee980e8dcaf64be5ffbff34ab06c3631a4dff83175aa621fd194238b6f926d539e5601a546988718a52fe833d6ed6bc93839d0bfa07d0a4ba7a9e29ade809cbce5b879248f0cd61178aa10975a927626f108d3938b98ab4258530d191aa7af3eeeccb91024eab06105d8e636954a3937d28127b1bde2ab6d8eca1376c11726e4e0409d4fbc7a934ae0bf91d51650c1519378d9fc0841bd9107e449d40cc90270b9903abd95be4a6a0d9ccac13a21b61fcc578f353b1451a1132d8eb2716ae9603304676bfe68bce2e76d215f3e1bf78a2fc3b866a25381d99f56022af2756b5e113f718bb8a5505a19eb6cf0200a2e1553f5b4345d04251a60dafdf92244ef1c20782ebf366279821d58b235346d198c46da1694b8c8b57af5d4b48dd3d79944df7dd3fd173b97005707484c5dd8af5209c7d12631453b40cd22a212e8152d8e4b6070e75f9877c57d23c69d74be299e9d942c33db8db9d34b5dd1468acc4063d2827fceb9c1a02dceb8cebeb72b7b60a230e78e96ba4b12515ad1aaa3c8963bb1f339fd5377fc66156e7ef93c11fabf1133a57550fb62c9c50da3a6f11f4fda4af3f3cbb1f6ad7e017fc038fc8d1847712382c1165b434c095c4319f512a2bc69915ac4ac854c545fdfad4e51c2580fe873b43463c2091145398e40a08cba1514ee299cd9fa3ab5d69ab71cc5bdee9215edd1671b6790c2c823725a6d67cf1ca3390c9a0464f18e0087e087aa5327249433ed45f2d63d84987a1ea71aae7a3642a82b87aee337efe1749f6bca19427d57c302f9951ad49e500f5b78a5f6a273691ab9bc346ca1827a4fe2344d1683026daab8bd2149747380df8b5bf7032e0a9280c77f846dfc00165c79a9d5ab7a47b86f66b6e97dc4b478ea5ce4943147fbca7ad506407ee973838fa6b4a6a4e6642f417af72032417fd56d2bb74fcbe1f3a401caba57452ef2fd8f33a7ea52d291a39f11d78759c17e9d3cf7332e1c5b65af5d2dde75154b7248fed70883e8bf1fce46926b335b9417495942d78ae4dd15c51cb4be26eb408473e6e28d8987fef75e7b0a6f2bb484fc99db90063c1f1822041cf0e7a43601ea0c6704d25a061a89d0a0f3264a2d2426beae3af1d2a3b458856793a5e73035ea427b5d835644f547cb8083c9bdac7dd58b2614ded3a58701bc381b42846fa7cf280dccb8fff834f31d391b678e68407849879df29357e5a020f0999929284e3c1ec4153f3572b37af10cc26c812041cba120f790824cb726a3ba38b263eccd2f3ffe830830cb03aabb4b9a5bcf55cad6dcb92075f02baa110a9720db051667fb58dbdb8cb8b48b95d79f985de7ef66f4dbc412424f5fe2be9abaf688faff3efda82fbc7c484247af9ffe1d74b010a23e2d72bba8556b4ff3d046ef0ebf462e540055ef35a47237dee97120becf8e8af7eb7d5a8f7488eae5ddbdf1e1e4624faf2edab2b443eccffff79a59ab6f1ec759b30e26df664e56293ca568b38245db4858632982e157788c241a33439d20ae4e39b1e5715d77a1dde5c0f37bb4adaaa4334e2f1809a4592806f9cc6f8682b54ae455faabc842305cf2c80fa72a6b1d27c2543820662960e1cda9626040c8646fcb179ecb75173ac93a855a6b4dfd2f6266d3cfd123a257b05a397a5c8e389878b36f0fadcde39151d270c840087e467a87cfdd5c6e36874f2eb6eb3e18a278e9056c51e6879299066685358029a47e72e25421fa657e6a4e48084c5e38fce7dea6b42afb62fad8ea2bc64c8d7b5d6db2406824b529b7a2afad3dcb3a9877751abb5b02f5fa912e10c7e50491757afdf4f856933f775470f74019d428bc8a81e439326fbd13c9d79ca42395a285fd6e7634372fbe507681272e6583662dd17aa11a1e59bd8ea77aea6e81a01fdde9d4e1ad5cbe92bbce2931465b6523bceae1dee29667e400e07ad91256cddf59e1d61fc391a0e7e0608070bc7d767c2addc6890ee38ccdbeb2132f7fa323743336e5abd92650e35e44ad6f051dbd50d58322ecc28a3f493292feec5909a3aef31d1aca2f5a7a2913f830ae75cf9273fe9c6651a633a9f95e72faf7f7bce7ef8aef290ba03273186b10c2bcd113be0a5a349df0a047ee4fb728faef751dde5db8178cd798e2d51c752060fdb7256dbdef7d423cdf0df044e82206e4115524c023e608b7f273471caee4106161328a99fe5dd06e391308d1fe2c8c70abb34ce02d13153545170378a0b695f9606d17355a8b827e718da763f7ee7f91ebbab4a4a22c634f25a9e857d2d6f73c07203713140852173a36f0ddb6d1cf1c1a908e9d01d8ee489bc4a437f43a97aa82377fa88c7d79c65724b37f7d83ac9ee6c7cb99f2b1f9b162acc24789bd65560747c3083b3b5970c88f65f1924804b450f8a8030db2d4382ec80ad58ddc6d8d0e831f91726d790a13974ae32113348978dd0e75977d1bf9e612f52e3a87eb6307c278e8faaf1dab89cbfd7d96b8b551defb436cfcbb89038b0fbc6d01d654cf7144a5d3e4ae4ea2905ee14a6b7a18f13a4ff601ab51cad6f03cd5158e6b29122593a7a479d722bff395ffe887891d3d193975e19a5e3d80db3a0e6c775943f3ed2602f3768e8b5673801ace0b7e3e987967718022eb36b491fec9c30853351282f768f2fb5a7350f5d2a5075b770cc062ca291934aa7a0646c00a8510f3f8faf3e05c54563efbb8ce1f102da6aa0c1d565b2a09026a08b784f37fd763a6cce0f4cfec16491d090c2957767e1b90f028d0ca605d9180ac7ca192a627b86a1c3f961046432947df689bfc000bef8c81ed77add27b1c185a6cb20a0e25f94c9e2106127aac2e17789ea000c7ea1315c084e643eab45c8b9daf4cb78ce54b6bea708df89c2e9167fab54f4840fbaf25ea2a2e432d99654cb78ee36c3ac3771687792b224be31339b63f86fe45919ff63f931eb248e3f544ae8739b18a3c9eac83eb1f21ca04504a67082fc84af119555806eec4684710cd8ee499b7a45acf3ae72b981ffcac09a928e1f8689ccf0b3e1568c589a0534c9fe3ba15ade61cd9a1fc5313e11aad147e312cec1f42aad0a8f9a1f65f9473539013d3d77330e7c0f840aa48a2af5706f60f4f81e4349a08505737785c4e75d4c65f10fceeba11e2b8305be0d7f8b0d4711d004536020c05f036fbf4eaf1c5845853cd47676f6f9bc67c02d056425727db73825bd2528c2669a5226488e5a022a4f806822e8b691144d9a0497245ef418b330254da66516822ddac3f6dfa41831c9e938a7ab93bb76d6fbad7ad13e080b914c48d8624c5ee479c9bc206caaa1c138792c606f329fb7fd727a2ce55f015bd47c3b52a097316ab44ba377fa5cad5de491667ae24d043ab8b298d985d96541e9617fa6c05e358f8d68a93eceab336fb2b9a61d399b9863b0104fa82f984f86d12d2cf22ce257609bd78227c99760ef2955cbe4ff6c508e9f3aab7a9599ce4c4f235074b6725f13806bef6eedab1574c90a3f4626cc9e0a82257c5cd535b8c9d6ab0af47e4c59bacb2786dca57d8c637e03c3d63205539cd7aa6cfb0adbe62a90761768029f4811940ed881ddf8995c5fa56bd39ac090914da5f83b9e394771d2ac4b10bf32fd7b62bdd948266e8a3cf4df3c7f0894f9b1381db8bde1a8504df72ee83c0014a4e6c4005db22e31851c10ba3614db576c0f3993d21de19515df7a0b1f1ab05c739b116317cbd525f9ae9c3ab245ab0e94ccd0b86e4fd1b122e3831262b1186b071395cd5f19b21680e990645cf4d3bef9a8a386015d561c50a5e448ee7c57626e99ec5fb9f65731c46f6e179dbe3b5ef37ac6be8cb94f7983fecdeb9224d731c8a4ddc6d5dab5db9f6c454d742b02984417144b0391d58d0daf38889b58ccb5f5699f08c04ff64e9a2d8104411bd1fc91b82c1bdb4fe9bec33250ce38ab2e929f3028f229dfebc4a0e77dfda868def8a81126c5301a9cbe513c5d85e34566e4b2af63663deb2affe762649c6080e356a89f5874e263fee24e491a2996ba641535b6520a5887df1a4ae68a5fd58f726515ef17bc6fa0e1c70871a33df075302511cd605b0d80901866923b8007d1f6cd3b41e19123efa2324241b5e87ff39f92a1f5bf5c1bc2b7bf96d075c93d12542618b47928afad6722af9c5d6bf0e87bf42a62c7189f240eeabaa99563afa8f5ff5af418333e1eeafc472bdbc7ba409f63a793e9c0abf84594168fbd3c94e7e11e4c744355b5ead7911156d7ef07b5fdd6134f2201652c54e021ffef7d048245a21566b2fef7ad156b90c1a7e2ca8e7e821a94425634052b83f706a045867f0f948952cec2a13870344ba6edacada461a71610b618236f7bc461d2998354664dbe267c3d5922de7375d4f8ac6f6bf9c0157ae61746a030ff2484a1019b88e5e724c9b65bb899c2c83e66b82cab91ec2e7eb010f8a63eb2ce2eecff7622459274a15ba63615a5403318a9345f055d142b1981798f010307479a0aa5ead1ca91261c43fb4adcd6507f55365787814299d15b1ccd8cb70d7cf75699ffa07fe74494ba759b432b28c27f6c2f0169cbb526f26d564aea410b863e6ee71fa73e45fde55d20b116dc30375889af092261b615e5055083cf4f1ee0c67580d901387eaeb57989e008630a7c93a2bd56128bbf227569d940b429f342642e75635491bc4ca3e1f9cc8f64f11be650db92f44f3f857df75ed8b88e820eb4ce230ad5b7e4acc54ed3a7437dab4b43e492e2924f2ae62d82daaa172c2055d0350bedad939ba489a922e0ce98b6aee2987430e7c1f2d65cb08c932ff8b00d847e9bdf557c0f9342407bb737023733b3af154159178622dad39b021082e866f48abc5dc16a405cba407a6097bc42e881b174fda307335c10a90a86a92b353722080c9d2a85242cf8a8a10155f5e28d659e4fd9625392bbb8fa40d7fa110056d01d26a0beb7e59076777e899519ef61d44d86256be5de47689637872b1ac84cba4f8be92f1d5023a74c9dab782538c5a8d1b0c0997d9924757afd0014277d2167fe5d4d6fd22b1ef2401e9a7545eb448cc1caab5052c9e590f85a541a0ab207be8f30dff6c3d7e92bb5786c1e2e82ef21ddff70fca24487fbd2f018abaec8c328f513173814d81a56ef6143bd7d79737f8679f5249d94973613bb51c5fc315fee89164cb134649ead5727f9f301ff256eb58eda653ffebdf09a0db9689a42ad834fcd294ebe3c231bd2f077a80a6c1c24f579d8b4a1b47557f7befffbc2c4694e00b997f4cb957b494ed727423493f86ee63ce6581db4ec1ece1263371ae5f342e29fd8ada1d8f44db11f024018da03fd4297acd1aaba33a0023e741ec1bc5bb3865a4ae54db7ad23469defb62492a74d2a3271d2865f227b763c70f703c4c66f1cebabac7918f189f1fea71db450c9e5cb5f87abb133f9dc994b0e132dfbdd6079db7033e28fc51816f839e0cb4d365fae902546a10d9ffc98fd76604505816c8e0a8880545576298c3067b5a50f644b34c8a6d78b3ed5c0373c533568dd3a6cdab615fda031057348506c6deb5e4cb613d0ccb4b13bb85eb20343a056db5d9e72aad88b4171a3a632a239398e45edcb340edb223cb1faf943f26a67d98e507141a89cbdf1dab3fcdf008534de7063613a39840410ce679a16f79324ea3f6697b96bf5d06643e0ed4847090a9d95dcba5ac4c778340e447372acbc531cf19483bc2d77f404d16d0d19648118523a7e17ea256e0e87c323d8b5c2e003ac444a2ce954c89ffdcfa4ebd1949bad5065f20a603f33e5892701b6c74e8d35943ca1debe68d1fbe01da8b5d7409b97aa15f556da5232b993c3647c975fa0567f402a51d43026d5ce6e09c9ce2277ef22db919a88ed468450822b5b0db49316426930dcb5e224ff21f95df63604dc90a9f2be00f66164db20dd49a62225eb193fa48312240572ec1d5143770312f64dc842deb71286e5575d91efd80372567772b96c84795adc46a5b4bd04af753834f307dbb0b0175ba9ccabbddf4d2b7f48f8308bed4b3cf4e8df7d1f71dcc1bfe1daa09694cb584f8976ef426d6d5230df317cf1fd42c6d32ae10301030e550bb66959f74c3bb12455eca0e70fda6163ce47e3666496c4cb9fae018edac93d314b394943be4d67f924318eb2302a9c0b8d4800aff3d02e83795a0d368824d7c757eb31a35bd6716a21b85d6e89209cd42ce8ce27434c0b67d8f6bcb73dc28696ca9e2e77c2979c750c8ea1991e571d4d1a9409ca366c9ae6d1d9d5ecab4f733988a6996a84fa3994de07cabba4d82b4eddeee191dc3674e6395b9076efd7959a930e9890cf0f145b911ed44e02c73266c4aea596d6c33a6a17604f96fbac6980846c7f7907e0cc44f710dc3f6b5e8e1928c3cdbc555c78e06c6ca2f76e5feb06dd6461dc11cda95f0097b380dfbc693a9cc03a710b03abe53c5744360337db4d7be323a33c914d9b7abce22bd24a8e08a6fa845694858abd6066120f3987f647098e86b9326706fc1dc709353cfdceb8f7f76274e286842dc9fb350ae27bfa599df54476431c71e2a0058fe2e8133ef606171b88f1e4516efe96c8e726753f4ed69ec5efb2c096a9cc0ce9c84f803f5427ba7c7b02a65b797c97583033913f66f088f14bd91be7ea4d3ec752c4aaff5ff647cfde731982c1f035f5689bc55c33faa00f20958b6cd68eed6ae059e4807fe04cf630e1c7991e759deb7628e78bf9c87f1b0a6980d471268f7a76820b0b26360e86ee137417aab87b6199c72d98c89b7d35d055980bfd4e2d313b1d83d6d40cb162306460f2d9058200759a68bd98b4ea44d8a9f27f2688824ac314e8041c3b33ed3a982b8bce725d7dbc30db168414935dc38ad3cf3cee5661429137a75a44a00e1749ae6ba27181b70854497d8c8b7c19d706174df485e387ea1e020207aab994e1447fed2f3b4cc764014f0c8ed6ecb4abc04ecfe0eca1dea3716844ade3d1a8cc2b4b0bdf04bf51056c1ad11398b85927b1fbd1d02982af68b7688bcef5632b2e95f0c0449ba9dc934f32cf41377d88f03268a4fb80904d211f3df0d90cd8ff5395b0d83558b88f73438411967420cad2bfa8db0c91dbc5e27469fa5f85187d76d30b0f56af44c7c30b2c40d039c40c766ecbb976136ed4c85a16ad5f254136d65cb0f2773454e51de9ef0f852bb3625c3c6f331799efcd17acfd4c46d6a294f35f10b1a6d6f4f238c5b58333b45d2be4dd39c6292baf74dd0bf07b529d8470bcc05676ff153d6bc349b4f2a1dda0f13f25df36eeb06280ff1a335a282e9f0f4f66b24108ce1ffdfd120b1c30d0f1ff8bec53faab2c377554c8e50f6936304e6bb5a5533fb781ce29ed2d13c517e0615d17425c9e7994f75e0ac84f8d2b0cc0763836bb818aadfdbf4db05606e07dbbc9be9ec2d3b746c3e6b907972dca2276c034952eb63e94efca702e5afcc83f441f1e0a0b664b75468865545545f840b57d9f8bcdaeee6fe2d594e4e65e5f8bb9f9271aadb16f7ec1c333fd8d7476a6f631a043d4cdb7f0fff3f5d0cd4397037a75242a68e8efe3db5a4d638921ac596089a06f79a0a25f1a820f0a9a0d9e7ed4e8730d081141e5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
