<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06011852616df3f95c42fa3498ab5bbac7a87e1f1bd9d55fc3d68230a15a36babaaec8143946fac129cdff381f2194a29e68dacccaef15958ee52b5d8b01c3a403b4ddff25043375571a0f07c5fb0e3f14f1cd1d5ea3cd2d261b64991d8e06e38f36cadd4fb45fe0c1061855006998b243c045bc86d4eee4bbda0f1560e6b73c6c9d6bfbed26210b61d64ae14c661be2938e27578d97b75a81dcda718da8cf53134e59cb95945b09ec3c3261a5531eb2d289529237e866dba9d541a9a32472b0d1684a9eed86e59b06fd7e72166d3b593fe17dac0d59a353e509654e70501e55c96d7d5b54f5989faec8b88a7a9bfba805f73154aba702bb011467b2b5605a43300ab9f03ea16ad420d23ecfc92f042109e97408f710db71a0c5f2d760e41a1e692a702f74e6509e99d0efac4892c0936ad7aa133509a5c6b74c750c1fa7ae774cc828718f240eff5a8497f616b10788846f2d8031d34c47d593866d762b6bb7df220df6fa963eef53e8374aa8e3c721b1a5a437f096d6176050cf80b4aa61effcf8a72f0543b3567c2abd93c2fddd23ca02cbaf0fc90b4c0ed224e5476fa01f9881a71d10af36e363a1ec1d7b603faae1311eb4207090bfb980beddbccc1fbb206f20093bc6f74ced22c3b96568a8655c02fefd77bdbc5e442b60e68ae3b1c2ed14176e13de370c592eede71c8d3e7eda541ce3aba97be7da8094b3fa15dc4103f13c1e031d8b0099c9fe1b0cfcc9eafca0fd0dc692cc3ee405584685a93a1f5255645fb6c783d56b4440cd82c87a1fb818ebacd1dbea93a0fd003651d74f0b722878ae2b81ab6a9cf4217ec5b7341ae30faa4cdd55442f9d39e88f6e4ac3857a4836cffce1a91befa61163dfe6e5fd2d497bbd3db8945e602a4fe16f71b301bae72844c63dedb127d622a61d5358415795de97c4a0791ae641f6f3782d3d93bef0b22d9d4928a9c6a457cd37060138029aecc5571cedd7286ae83f66f0ae871eb828be5b64ee768dbf37f7224f45a8d5c431d053aba60b17381abf941455e89640f333af451cbe9d4df0c849b1e5eca7db844eec1fffe11efe9c9011ec1edeff44ca688c2ab133d965c444e590ca08d078a3d124e0cd80fcdd45155c01b73177a65e7465692d0b5a27a02c4ba970078485abad1317a8458081eaba8586b0c41540341f739b5ff995a5039635b52ac35495e10da6cc999641ab4777c44042874c7dcd4160603119a7b01cf6178c11a9e5a348d467bc9bd8b7fc656891c1c8d0f1edd4c11f491a20a4d03b45ff213d05d1963a080c51366e599cb0d4d68c1bbfdcd4bf0c6ae1cd146f84fc92c85930098197b309f526827444d213832a032fc8af1a8d3c7e622ac56fb01cd53a7d7748c86282a1f5576548a51df99a18feede4bcd57d5871517e22706d5d1b79edcb0e6a49fdb9271ab859407768af48e9784f7c2b1b0448ff63b539b09487e58beee0c4d3267f9ed37bad61998a2c1fdfdd4fbd2b523e787ec4e2f8eb74dcace8048677eafb4bb00f60a9eeb7caa73e5fd219013d2ba7bf222216d8b6c8b63e4c2eecc339a9d597397b7970e701e22493d6949b45ad761ab0dc6257d9fafb76a4795ca00279e4aecc5a4a5c09fa885c39d37672cbc8e306696dabe498f4f4edeea0cd7908c96144bc439e9de4906f1bed9af81b80d3dd450681e22d66eb4a807477a88eee51fb0f45dc3dc0dc26f33be4018e11cf97b34459517ff3979d2a477a0e48e9a8be2bb3096971c112e724bf5cdb9431786c534ab6274b29cb01d412aaf33aa21e6575f6295cb14dc2977768f15c70459126bf460dfdaa1d058a3af30f0ce562579e1fb2440026aedd2ce2ec5770a973337e869c2376c7e771f849619f6b5865a3b85e4808070fef55cc6d6800c659baf37fd79abac2cb6787cbbde1cf82eeb6d31d146170c2996077a4c0958e89f1091f9b6310051dac9dba00064682867d3923d88f0762bf154daec9c641961420d1280bba8b37e425bbcc6a96e1e7e02cced7512edc7edcf1d7856748d0bb1c4eb3ddc1da2fad72a411fc46fdcb28019d5e2978caeec578c68eaa5d3e49c76f2613f5d3bd4da5f982e4bf66d1e6323d2b0d9e75e7a1cde9f69b6ef310d5c794d38b73adb1ec7ec743b998dc405ccdde1e300f52eafe0217ab95aad1d3a44f86d199f614d87b4b40ce86c0b1afe82e644c772289e80974721e147be249a2a48154ae45beef96dc9f44e5fa8f555b8a625900b7a76f7986e2ee468e75bf0e846a9b08b71ccdc3d6c394a61b6821e9e99c3933b1b2ac3e6e8852260253acf8c2ed67300d0fd86d6f06a47988f2cbe95311d795a96fe8d3f092f6f5e18bdd19ec98610882d9c01774fc0979a966b5ca4eaa7f8418b56446d9943f0980fb6f51746766c0895f529bb1721f340e69c7e1094286d4864121d75c4bfc0c1e478c90ab950c969d16092ac1bec474fc76fbd1b2a0d6a3e1f4723d8d9ff6d86c932f6a37c89f4497e4984f2dff35d132e951470b6ab1f68adbb126d1c9c769c954c6af41c7ed1d65c920bbbc81549299158446887c43d4ae3aef68fad0ddd40ce811a50fde3e56dbc1970b9ac96b94554ecd79fa43c22ca1d66e193268ec7af5a34acc92b81bd376c14d3674bc8b8a4ae327063b57029d1ad289c79bf0544fe84093ecded4f12aeed5589686acefa4d32008ced76599fc30398ac286b621229c2b9a6759d88479b9e70fb3396850d6ddbcb4388300e5570ebdea4f3f626c20a4fdab81d42a40b1ae5ac4838afbf362b49d2c636c328d98774fef3cfd4e92762c12728ebbc798999c253cea0890d51147bb2462e085612e4c10fa7195670e32f2fa479aa70701d8cdcb171bd8c007cdb032f870198abc69af8ad6532c0d25c89c920363bcb06621a8d55e73ecd7aee88a861495be27e20b2061473710f20fa9f6afb4e89b8872bb2590d24c1db2da503127bc6189936847b335d66a71e7beb4aa3a79762ed5671d2c985c2249c80106f50e2f5ef029d0e4c35d767fb363ddf808665255b4acb52c7a404b399cecc6bbbc7e80377a518a32825ee04bce33b976e64a071b4cfe614999181d5f8330acfe785f6c91fd30ffad45b33e5bac53b82f42514355dd469468f95eca9ee2c3461044edc211ea7d4853d3b26acbb6264cf5dffe91c598f2f8efdf974d50a87f00c150f567f537e02429b12b1b625d8f7c334075c9dbd0ce93046eec0bc20f7bf9827076ef0d64cc9bbd207ade9a8ddef393492fc098621b6c81b3c4c5e493c1bdc2bcbbcf8771e5379ad1b92e3a11b119e95eff08b7ca2c51a93e1c91454eecb678f385623e85c0feb61394398dcae893d7391f0f06cb218b3c9cc3e7961d1bc84d72e59c88c3af307cda001d30b7ccd31115fb132290418c088e4454ef3e9ef3c2212c1826905fc3ccc3282dd3866eaa54f162662e5dd82cc848c09d96b5ef3999bd490e24837c6197f03402d04c594396ccbeff32c9971365a2a1a1441bea893c2b4e4b4595a0629a1b735e4c8d0d325aa6c384aa40a69bce2298df7fe04c5dd0564d370ff1c70c3d03b0b16848a7dc645863a6a3c54d947172f150e4d39d6781fce9d44ff81228689b763819ee2352455e066452c56d448690258b44a24487e42cba987e63f8e477cc5ac1f7c95b12e37f62ccf41ea8d16f6eb3ff44543278b812503ec0eeec73e68c9e4d74614e58bc9e92a3b3f6b199d137e9c62167e12e7e68c8c59a0a38a570cfd9306c2f7f1cfdd126c2066de49f7a9b7e6e665a24b2a78e529ab7b19b4ca1d1981a42a4b0aeaf185dbeaa82f0b3d55c61790b85257e645b2248348aafb295cce2726bbd4171e911152f975e0440e0e9a52d0ea4b6d9b88a65625a945f22a1093ea964b43532e0e34697943290df6693ff626364e98f85f4d19c09d62e7556b7e9f714704008485bac5794244cccde6b106639e5ec7b09e54aeb2c757a78b8a747a2f1585fcbb384511a6fc3269f1864c70afb7965e86b6958270ff8fedfa33120956ec8ca62a029ca02415aa3c75f59799c6a6b8d3a67cd059b433fb506a1e38b13d4a4ea19a37e6f574b0f5e58341676a8e1d2097722f44274e80d243bc6f90dd8f22d1bf23037d583a7197af74bf1d0ded6b3b618a760cd819417fec90f7a4cbe9d2b8548910d8b01c8a54184efa99c7dd46b801cf2345a64abbd4d11f71611e2f822d5a9c4ddb050bc8f8dce3cae4f3070ae0b39b92900a8304512b1a93830d69f1420ad1bc3079d7771acd32f9675220fd27e6ba7effd46b429e294b2ca9cb948cb4871d143507bf5ba0379554ac431c4380ce42c8b145ba304be3b2b45fd4e8a66a24b4c316d5594ff8cf0db0e6506ac1ff9ebb320af3bf8df3bf46731c596358c9b3342ecd6b40fd5e71d5d3603a06043acc7cca8ff8b41a961b59cbfe41f319ca9c473f1f5c7516022a15e8e5adb3753b0f021da4e687d6058ad2633f8b6d7cb3c9dac3bdd2cb96a2f084d846546b5160d3886d347448f32a50fbfebe4b7bdfbecfde28530e568ac76220034dad0b85a294714522c1260651bcb23f24bef5434046113753345c2cc981d17fed0bf8ab6650432ef76bcde9d12d3366074f64f8a483d9697dce54b249a3cd11ee020108a5fa7b509d4bbeeb9ce930ada36005967296993d2dc7e582f7da00fe5eb8230e32b36f8d947c103026c624179386928474f5ec0566b9408b0a572256f688fb35442a233ee3b5f96135b704a939dbc0aaa33b8f7c26e7b39b9fd4d857ae635e2845fe8e283bd5dbdb7d3fce6fd67372a5de372f1d5937a9ae0705da72748d95fc5fdee9589a02bf227ff810e3a7d2c8674d2a3e8c46fc593a2b6343bbea39da778fc83ce1e4da1309545923a7f35eb7b3cb422fbacee897e7625905c0f5a21cd63046d2877257ed683b19bb3ab1d752d579e4280ccee282b3db58b58f81356a858e841587c42bc193ed638bcba472d62a4c38005954e3b1befd440d79b495811a0b83ebaec93d76f813239c428c1b2bf4ef0837ea5c67c92c0264707caa5653bdac26158c54cb42ec7672be15437d5c3b28174476487efc3ab8c5fdda67fb68ef42f83464600359b58490984ab19b998ff14608b76749e6bca05fc7f5a1072c9fc2bf13b9345723597291f671a5ddc5373d56f2f2803df77c673ab53eaec9e726cdb2682b99647fcf58ed2ff6a16b2ee6a156bd73620797849cc2c55fe40a75124de9b1c01e7799759748517b8921b006103603647bc5e1ab050409390ea1573e38adb00321948975ce0f1c0f7696b5bc016a832c1e9ff136b3014db5240980fa6169a6349b683d07812f17d1c19df4f40a5abf1b258ed75fe8c9ec602f9d9557021212c41c99fecf68df89300154a1759153dcf1795f862269ea568a2f43535659b00b8298f08c7aeb0bdc0f9ee8c06bc62fb0ce622c5061a59a98f01d07accac3d0e3a253ff0a684e72655543b6fb4afb010b693dffe9caeed36fb6721facb5a44804400c337399a650950af9a1455fe4f8d8a3949b2f76d5bfdb143a1a6af6b4d0fcdb6c71fd9e150aee91c6ba449af5b4cbaa0476641caab2caa6c6a7d2250e42e07e6757f6d7843ba2e32bb9eef2bb13c60ee4ab02c6a8a03b59e120d5627b6dbdeb7c084d9b70967c411a0b40d321781bb7a5866cde74e5809a4d2ab18b57bc58b0acd78d42f60a4c6b86ae2635ae40ada84cb2226818d3ad4eb5d2e2b1edf571b820189d8317c65b546ea7f55abbb1960e65d7c338e1ba5afe1c3a86edc3148bf90e96fce0d56fd6e67a31870b316a6e6989fa111fab5b08fba22816119a02812c35dded4170c59b6cf0dd7187e57411e0bfdf68912d7578a5968f770960a36795a428afdae68f8ce7cb78804313874ca6258b351bcfa1d03d04ebb6a96002f7a95098b027221d40847251ccfc357009da4ed6df881c3f71888fb9c9fac16916c84a33f9ab9283ab895dbabfd0893ee97e22838dab80859c2a167af449949d91dd471b3387f74a491de8db82d7c0f78afec5a881e7798ef30d8914f2c02a450c63a3bfecd1cca7ef6f06c45468583282f565a6080271256b6eab9ba1d67ee9962d7b701cb655537da7639f89dee185e272d421aefc67323f4a9b7e8aad83e463a10b0d5a6424c902bb2424497d5faa7a51437250c7dacbdae507c2a4fa0d89b5cae3a19acaec574d88d9996baff9cea07ee288a37622e160438a0c82a5362f1711bd7649cb1408c439da7107885d6dc9fda507a9652ca675375dc7aa2208e95ac585e7417ac826edc997fc1973f17086f33bfb8810e7b06e3b14f407a7fce918b12858419d9c27a6f4d22e6fddd5364aa3d88f1c5fb564ee8e85266dcf906477d3f24b04279b36a40e4970dc57d15f601cbca7e88e0f59912ffdc6d278177c9ac98c4b741e2e34e0ba61ea62283e46ff6f5461e56242f4ae43fcddd642a566918aa768f81e95c41fd95dff02d10ec35d8e4da024db613ba8d0ade6540ea0e73144037ecfd347adc9a83cd401390033d3bce2dd5bfb7b708a590ebfec3dad00d8ae053109038d60f1d3de0a18935c95acf433674076822f64e68028d24355ff5d7729f26337e163b4c7dc9c36eb3cf944271483430ae28f4143cd1a0a7018efbb865c8fcdcf9d52b5ecfcc19aa19933821e89c32d423e77ee671c05dea841504557e547dae8330e401766e123280815316f3d6a1087aba5dba20e2f7019f84546b3cd025eda842fbd6aa1e28c816fc4662dc3810e1a07271da2f16985b3e05d4c907ef290fbe44e4808ed0720c508ee23f0cb73bd5235b57ac06834e929355061eb1f8a03ff41b91975e3422a4097d03dadab93a636aadf2d38175b846a3739857d2c7397ecf4d48cbb4e8905048da7af984868b3820867574d3e583b6539092373f5c4c93d5b52d795c374f223063aab6d7d219e141ad7e4f9ff90fee6c9e4ecadd76e6d01e71e7f09f5694bc2d73d0f7706b43ffddf9b116e53a551f4ccc52b23c2425917c326b74462d4e29eb971b7cb2ce4cb60bcde771637d0b8e961102d0ed2d8b87b126bd107447427b1f045bae5de21f14c4b55b5c96ef5b2c8feb3b88eeeb429e76b3d7d9383ffa4feb102ee702cc39286bb94c78940c253c20bb4486d95306da5de73f60c4b193efa6b6fd0966411a0122d7307bd56d9c7356a75d4b35e3ea02b1939c054b8ad0e7dab32c669ac412d0cea15f21dac4b2d1dc9fd53485b1a5ddd4e0d8e437ed750af1dd90a1ddc72cf4f7500a80084dd31591514ca1d3fa7a7da72cde32842a14856525bb6f2dbd1784278675cc319e679269fa0485dca1bb5e2fda59579b9d565cd7c0e450157f6d74cd6d32d8aaab66be8b556553da544bf781ed5fa1f077aa677a087aed8723598d03085d2be7d8256d29cdc07584f11cb894d771fcd9d73b57cb820ecd88abf8b837ac5c9ea1ac9ce36f2c0b593ddb1fa9c5b57ab256f234f64054ad2fd2bf2c8b2a394816a7ac900631e9d87251c3216347a859b34fa061e5f1dc815677c1313aa6739102c651a13a0021a3c3865d4ac7a3e46ec934d1d5021031c86bf0e493db18250d02205b293612c7642d3ba033ec4279bee6c32bb7c875235c1e2853579fd1cccf001e513afcca8d7c05398c1f04e8f3e1374c8581e382c097549da2db8573e566ea01f171c3adf69ad8bf7c2c5d85207cba6cb513a5cd80aa6a4eb6f969c24eb5fe992ad1c7bfb4c341458844890cede391cdd1f628fdfd5ad5e9a1c476dded544c1b60db685ff364504fca275481708837d77ceebcc9ff41219ad0e077f36a4b05e950697ea6ac39125eb262c54452d603434507d8d0b59480fbf76ba06a56d5502e409ecabf9785663c0dfc88d68b94c948595cbb0224b281dfbab8ee101558a5f460109c6984b2e5e107631776a7ef7add83a67197cb29c0ff5a82a1fd7bb3e52a6778567f7f05555d814bdbc3d8c8819e6885903c6f0dd3bfffd3541e4d8a8639cdf509cc51f43c7c2882587a981641a3dda4068bb7efc3f2cec2caf53726dd59f649facd64f0f88ae0b6288f391d9bb4388ea108b3b71ed7697a6d0fe215f469723f7682cf76df2ee6fb92337be1baa6c29fa72cf7b1e6ace4fa7f37fa71d14833313650ad0dcdd61a0f9c9f0171f687bb20a949c79110000ceac2a22afee4518a03f4dcab7201feb56077bd147b48de3a0417c538360b72698111b63d03db55249453f60bca16eb56ed5c1014aa7666ead0f645dd012fedcf7f0b7f8f9e05e42ab73d46e28d83ebaaca0f75a2cdb32556c070b2f0cc187ff3477330dd20edb230a230124ddf389355899ad5c03f5b0ef59b43907b1687b560fd5aafc1d425363c181ac2c365ca445c17e8f536867fee1989394ff84bd00919f9b8ed6cb4be76a171c16476cb9df1f378deff5e3f150035444c18638f690d9463628bec558c4fad9f553aa2b7e195b1b4a54a4588c287c2c77c9f8b8b08c199718e5ada6f62fa96fec882d3d77ca3d7a55ef9b6766834441ef20b659984d9f956dd75e50e154a7a13690fcb4cb43e7e995bbcb97345534af92ae055bdd69608cb7ac62b07cbf67a289bee03cad921e8be2f2fe28f6a09c4767ac6640ff236ddb1af158be7e8f6c379142268c8be34b2fd9dc63064ab65409e2561384f0faf6750479745164302b73c689b1d106498dd11342dc0af97ca0de4c93270a8121d6ad62fc61a765e4a7bef4749f39636a51d5de979b7434eb949b117bf40e156330ece0af9f17cdc5f2e5af909f4946f06b9f52e832f2c4169aa8c99a5eb653abc029218a8fc99981c3ec02484127bc87e1c28cc815f5000639049fb6064fabab11efd6194e737f376e663c47e0b8df72733976a5a5f6999459bba4c2cdf6fdd87d2237ef2eed73982908b6d3296ff2b9a713ba69d61d2a05150a7e6cc2438ece836f6b92568475ef8cbcecea833990675bbccca6bbbdd5698d3ff4d39233798bd2bd039b6b51b1ce36110e523f393517f4366358b89b2cf2e93a2780e02c2111a3f23fb5906fe7ab8fd917168859c8edf0743a3e9709aeee620a4014c61b4e5932dc4eea94c3aa9bafe25555618d1e0b277fe618b3624f3f3bdfc2f1af1514aa0f99f71cdf9aac61d7c0a0eb96bec9d75b77ba27eaffa74fefa3ffe3802a51605ef4114fd4d8c9b570a51cffc48690f5efec0487fa44c18028eee0a98a902e6a7f957c22b81cfb53dc444d1b2d118aefc83adf43f69f26fedbfcf1ce9c36e1335b1cc899015c52afd4c0c6aa5c887a5546f1e0f55a9e6cd5b8dafb80136e6d874db3b6bd99e08339ca372d902db73e9ee0b938c5e80c0bb607e1b6196f225206f71a1631940fc5d654386f9f267ed65193e3c1feda92e7d13eb46e202d7729b61c71901a8ac8f479719508be1d9016e83601c23fa7603fe6b5b4305d57c7c55d6540721afc3466bc20f9bc93c576ba3a969dbbf015a0a9fa48fc90dea7b0f3610d6601e77c08709b64b946a2e48d58be0388a16837f79539f07883de64b84b8a72273170bb0fde0c7a12022ece793b45a15e00814182a75fc3dc55642ecc4bbba2098f9296945826d408639c2a22396be92fcba9334ba864e9e32c258921437e3d9d88e74a83cf7bc0ab4359b492ef84062b0c1759a9e4fe2ee9234d53adc1434161e35619b8230cd161a68689060670016e3bec22fc02cc048b0b24a79c1e99a62e5538b2615399f792bd6acd2976fee8e51ae90cd6ff4c5a22bcd1092404b33c598481986a5c81388f3c5ff0235b26c033dc6a0c6b415d121949acbb408cea5385506115c24aa91d68009888973a08e0ac39bbda955e42ce3a8c593fd7f21aa8624d99ebeb775988cbccc3010a500052530aab5ad332f6d206e12db9e065968b3b366ce68dad55a0b280420b9a46410d3fae67df465826cf80399561370eda73b35c702550df885ff82024dde4446f0601b0da5da5df259c685a650596c4b07b84736d89a69a00c09896ff4a1757760c7c310a168520ca06e86912c4ee691512b9b80fba988bed21a194ffc64f0bb4fd0717f29110d988de9308de622869caa30f06802b5040cf5f8f584f22dcb8da2211a2c9252505d5f72875abb150ed1c23c1851a3edaaa832fe78fe38ceb72e316df2c311a6dab63e44cfe360daf1a139d9b88977acb0e5d14ea979fcb6736c18551b16244d6145c55b82f9ee15d58aca4154c51682836abe122f98879b42fc0f71921d4e60c8bddb217ee52634edd9459464b13f80a301583d897b64a67c7816083a2fbb76eea7880c8a5ae872555491065d0e95bc62fd43e6e16d3da0bbcbd0ee6ca3771be3c40155d5cab79e76d72f4ca3980bcde0decdc00c57cf804ba30ebbeac9222bbf257378cd3a35d11ca4c6bf0ed12370c8b63236059c35effff8791f2d25b4c745b6871b5c58aad59120fa0cc4af47dde1f741ebcf7b8ba278334b474a7a82eea4d1a9bb431fa0c7cc8539a345b7d33713dde92943cb3f904e3df29419353e243c99e24d4bbc25d8c9fe4146f02be7f8119deca0c6b78251c90f028f31774c998deb73978f6cc67f064ce6e2c26b71652bfa555ed821668a9e1cdf5ac96ae9171c93d862ed047a8310fd3c77e3809288d85d2c7342112ce641786aa7501e47a235c273ec2c902f2da896140dcacbbcd355d02c23ba65c9dbb88ea12b3d2b65876faf93ce2b76ff24621a1c9f851242abb30eadcae52e37cc5a937d29481d9379f371ccd43305291a79cad7ca06b6b22f426b6755e2c6e8b65a841e71d8f8e3710f58345e450b0b136d7396e94ed051298f0e45491d316389be37dcdd09a36336c9ca550c3249fbadf98953b8b7fe72873f9d3a4f33d0997c5b1de81d6ec15b0f75b313ce727ac7378b7b717855f13a8b77fcfaa6ce0c6d0f0f6869ab169623fb2f21d965eaed7ce365f8e65a2e9ed4c98d7366054363d39986210e896928d29f1ab1170463c7fdcd6767a0d3081d44566ef6ef47d66ec90e4fc246be0d0e973c79b4869d6ba71ce213586108ffc65818eb3b0d32b9c529cbf4ac1e45b6e3c7ccab0bd0ad16422c0d785cb45508d85862a0e93496e95d2bc12574efdfab39c6c115c588938c1c4d50054a6c37ed5475eb71f5264f737cbca0ef37aeb53fc3575e75c0b163e2eaee1751ad27baa5f594eba14a6ab6bd3acf062c9f8feac27169c9f8a3d07ea0b4a3752bba8252a1fe6afcee53d2311b523a5f4bc87f7c0b38814b9e32a3aeac3f47f023c268dccaa6c994621f615925bb9f356c1c53d3adc491d54494c8a043a9b27cbaea5819d1e2a4e76f1eef0e52b8ac9443eda4114d20dfda1488b871108de4e018db35caeb9c01fe507c20e65847f6ca13457173bae3a53bb83e1645216a955812531914cc39a096c9a882e4d715de5e173fadc17ef3e9173a721d6e00a2f9a2feb9a404b3f6c779e672874204673e8571bbafd494853f6468b5eaf46b3abdad84133cd4695bf96e1ef31f726c930df3bd2a8c05a0125f9fee3c8cfd32f460267c3680f1ad7d3aad0268b245d629845d9d0fc3d3a1f3e782add618c43dfaf2d08a91327d90ad9bc44506c69387557ec012abe55c3a4bc7531a3e3167c15f572816b5c9102e284c1c95001f5817bb57481bb4f9c6b58096d472f2b4478689933ba8457088f85dab088b17650e930fbbce3ccbec6b9a9608f2328db8af705cf3ce968eaa1131555e7c29f5aa3f29c18a3867122da8708e7923ca8a0185c6070c877bde64199b18bc2270536b0bf99e3332e7fc813623621341d8190ff7a5c090ec0799b9dcf053610bc8eaf66d9b3d3cb7422fa26801670a98e6d3939984b506f661477bcc5ca579bfbbeb34c207ce54aa683968b93eceb3836c1dfbe09a84796ba5286a4ae11fc4ff1d8733089efa84a0693849af2ad8ae306d1766d7010e9f925e701becaa29508fea56c706c67e3c29faea10c9a2fdd0398f8dbc01219907493c48bc12afeb7bdfd28660fadca72302e091ab46c1ab86a32e8bd1cfe825673e235f779aeffec2a4fa3cccbbd3a20d413670676a93acfe98f9197e63e43e7a2475b12f5aeaaad39769dcf9b7e16b04b811cb62a136cbcb48cee46326f7d900c44ea687ae73178047d3fe66e5133415e43f04545fea0aa32d945be2c6d1abd165d3f82082aba4f893f111e35e4f10319bbcf820e11306644e09c65a232cce11ced5e6a2a305d8572b0fada35e542b57afced3b9bd941e527a1f80679b6af6a8416edd2ccd17fb7137fbb181087fecf6d612bea39e7a67f9aa25d2372eddcb06214b6edc79518b9f7233cdf1d58a5dc27a7fd3cbda6314f70c8adab41ba1be8820dedbc4686cdb6e491d2847f857c88ef717bc820f25e21a61cf6ca3869100375abdfbcd2469b17ef5d517ddd6ec3e3c2a988a905749d9dacf4999640213b91c5c53bbc80cdb91dcc45114145707b47b342954eaa12a6cf2f2dfa39289369302fe1c13f3d40f613fb87151bd9e340c269aba4aa320a79bdda8788ebdf255af362adb8fbb9b255e6aeaaa14d7e1cd6f1212b606bec06a65474b55403ae5d76ed22c18ceedd6f3093a6bd1c4107ef8327c32960ec81f1293216c11541d54751c88dc90754bfa92407bf591ccbd3b108438599289206b3d1e7be54a021432cf3e1b47b2410f827ea5bd4008e8997a4ef70a61243b45f8de268c27ed7a89cfa3e652256062496d6965c5dda46cce7d1c1f7a3344c815d127454a856bf6b542529b72ac18a32b6dd78749af4270cd38ff08cf1e61f592c92dd5211195bd3a585db5fd55803624134ea40a3128627972a6bf2b9458d8979dd5af42de63153a767f8bb17f587af79edd6ff3dede69d16a6865ec141b479835b78d4afeb416fb14996164f7565ad4d8e8be353e78e88c918d4aeb177f63670ef97e14451aa6ff109d6d730dafd767e8880416b23c091d34099d53d620720326fefca2aff6fe3b32fe0721820ab4892b4004110b39567e644fae776dde0bf93f40e9bea398e33774bbe08028f13d14184d902ad4bdc4ff1bfb3e9269628ef77e4a402c8da01ee0b83b02312d5a7b2f4a007e140746adfa452d5bc2434ab64d54508fbc58854c88925afb7f150d76c4c2de8f27d19a8fcc207006d7aa50ac431de0cd5e3b9b03fcf2d65abc4fb9d7bd59bca83acf52f9991a1f67867c3ddb907b00cdf858cadf8f89d585a4e19ab7e5301b0359f3b40627e9417254f1419aa614198cd2e53dff6a79202d715ca6254b7b51c406a78be788f71fb43e6f53af71195f8007295f47ee159a81d0a5d748fd7a9eeb5e0c26610d51c3321b63d122c233da3bd08dfb8e8277a1937515bfb30e9c48679e2239b99f51eaf281b407e5c4769cef835ada5d4ce4c4917ca706f05d42c254b849cf84c9c7c0398c12cce3833ee0f6b3fe38041be2c12270e76897afec39863f08c515e6f49cfe5aab7d4cc2d4f1dd8ab0ca68a40324e7ccacad96e2208e1e5a1e6a105d060b0e0b6da13eb084c9c3070c74129d69585e26a1679cfec3d34c488e9c3f24e5fb481f679a52e111e3f14d79747bdc49fdf27cd50bb8df15255448dea680f2c87337661a984e4052c99a0f90f6e945f1541c1cc3e906ce3c3bab209b6b431185a21c7e9507265482a94fa9ff8f54261fe89aa4b3ef70e887947cd887ba218d9b838a4f071ddf00763a305523904ac3132576ece56be38c46b99365caa43b667c66a7a960aa33f340f1ebb19c4e1ed9f1917c4ae58891a1ed8915d138a90a337188cc0ade89053066984557f0703675ebe5b07b79f53a6d038010a2b6b8a91b7243f62a92b43a31e6d46e57dffe6561309333154b8b20214916a24da0a112b5169bb5876124fd9555cbb838775647115a6677b95957d7e0ebb176d15c5cb418af931973e5733ec42c7b8c2eafcd4a260fe5aa0db57c62cea128e5c6b928bc75b8b1d93952ad4efeb234d21edc68a639250d54cc40cae89b7b9b16203545b241eb4471899f14c9c116ed0e10552f9c5bf04386c28336506270f14a2a9ed9e3833c2cd3becc83ba22ea30a5cccc911e3f426582afaa26f6ad817dd37d84a1a36682d4a3304b49183df19cab3667b285786509541719e23b5ee566266e323db1e8987293f03ae8d9b1e6b40baaa84dd690c3aae434a483adacb47d7c65fbed32893bebaa38992192c2f4b5f5886f316fd96dd71a0c1997b8c65bc9f94eb50fbd4b6c1633dd767549534b041157a74fb44a98c4a141c98d49019ba549f6c5f5add86a9772084203e9b929b6ddd8e3bd16056b74eb2c4d391bfb99cb8d3536b973ebd74d58f28adcd953726446ad26b06b1beaa1eca511887d29960b108eb3928b886f84237ff84f24043b5f97ae2edd4373d25c2c045153f1112253f6160d3a8074a61fc7f9f52129716b96d1b982c620f4083ba8642cd59c50a2f558113684bacce66e8729f4194667e9bfff8e8eda03b41e03d90516cc1199b9de9ff7a0f79b716201bb42a92814d34fa52efb7828fb25d067d982fc18ec010b8bfa45af2e34a1fbf5a384b0c71ee541d6fec6bef7661c267953a072b126a7165b351e58ff0c2cfd78a07ab104e42115ab79278bd35ebb486a00ced4ea6863fa05f88a59d04040f85dc3418162938ca6438170dfb241001e874f8df97e6d0a69627a8115c5e014d40cd043e6b881e059f4a7236669c5e1b5d02669db776365b4b7205ce79b3927d89da920b2a5349bbababbe2d27a5eb78a21628f87e1b526adc3d813b0c352639621231bf8bf1082501ad7e726f4e09f4086f02b14af1f298655edf8ccaba699be362f35b18d2dc9024a72d066161753443538329321e5073f5f8d177541889b71c7a59c05a2169d486ec5b86a981fe0993167957c613788d2ef82db41e3ed14b4b81231b6e7bbfad6af5a357c3b2db396431893d725b4a96a3086d5bcbd9176d0bb69d91c2bd71c1ecb4e14bcfc4ce8830f6a5f8a41c7302c456dd2efcdc5ef7283403e07316d8669263e15f7e8e98845c3f769bd85855f60fdceb3e0abe80be624f13284ab0b284e5b8df661b43fb6e61aedb61fe50f2b5023c5ef8293265904ae044a11f3bceaed44fa9514fb6c0c998f995bc1bfec5284c0f51d0a12ed14eefb0c7d11760c165a8a70b33a87403df05388a3b1809c5b224cc9542e21e5c9843d43118a77d1f938403f6ab696f93fc11678a254ed61947077aa165d8099d0fbc8e8603283a35d2c187363b8d7490a9d01ade960b2d8e087754d02312b42c3c45f6226afcc5a58a1c86fbd3f8429a48303f009cce33071a1cfba7baf7ff5aebd527f3a315cd975a8f232b37198eca437b682d63b4caa931e424bc12793be2a846285b71551fa9db05a406a52b579c77ad49da699b8a837c7ac66cc1df6f3c41cb96a1e1dda31e62ce943ed285efbde5c0ee6c8cd384cf282ad4355f6d29e780982484c7e27617af79a9fe782d8b2d63241b16c01b3647f6c61adaa49e3d346619506bfeee79bb957108521851baecb154b24a8154760838323408de7436594ea0207e6a83b9e771fa30faff99b430666571937f8af5668a41c0f6a11116e821cfd4be8fffb7742c7b7b0abf46b466253598e15e01541eb0ea9df707b857b8e6870babd56fa7f1403b95722ef5fd57600db3b70789707281e61b1920ce8a699abc2afaac4f21dedef601f996e9bab927717f8ac8d7c41ed4c2cefaaf3dbc6c578791c9fac17988f944fce5fcd8ad8655587e61b02048509de42730ebe8ab83f28b42ecaa6c136cfb0f4530ec4119faa6a1b6884e1cf22e64430ddd6cad5a987391ca9b3ecac51f7f0b4978ea1ee67490eea3edfc3808392c55c26d8609423d5507905df99f9e417ea385a7810df38be0de92a571c9f58099bcb65d104db0cf06eaf5015ffa65ef693e205bc025a119b861025dce74ef790e0561ef0d92a213e3d455b72f84c067dee42687a7433f731a9523d5379b65d8de0b6342d81ccb679237206664bbb81597429b8c94c40b38a3579858e8d318f7f9dc6d13dc830be7d0ad44f9466fea1fd35af1b5d8239c24b1f106928d209c9bce0d036a0bd155bf2192a1bf96ac0ca9912ed73bac32d79a7a9370d4d1db023ee1874c18fffcdf8073aacfff7cfab73d0b7e8c5a76983fcbf8a5782bda0ed706002c52deabf56e88a63f45bb76fe3f2a4539596a9e5040228128b9acf5028ef60fb3e98791d5e76a6105aec983f1a66105c77a7ecd4f477e2a7323b53c9ddd6f98ea8c09e167892e0d41ea49967ef62b4e3d963cf19fb1cf77e5ec1cda0fd92090c37e9fac607e0d6536550df44bd0160e63f3535bcccb331a4ad84f5e14093f47c86b352e8a66f38eff0eb722472dec6fef6f2e5cfec1294655b7d693b76f4714ef1f57e6f70ee3673b280d7cf9c26f6796d102c8224fbdfc66ca4a6d2e4b4c2f81c3f7cca32152cdb2d300c1e6f3ad44954f80ab21e494a774c994c667c39ed47abf8f0aea83e966cfca714adf8e4eb84aac3a15b56b2893c98b62c34454ccee5ff747b0396610bdab25bc1a6df563cf4957cc199a140ae00e90d4aeb468886152346a031960323cf1bec13734cee39613ba28c6ba46b54d8b442e33ed436d89a269cec61e43f75884deb0ed13b540210b139630982bfacb5276825f2fb808f3099fb51bfe215b70c0169b4dda0ea9ba378de8141fd6a2bf8bca1781e5bd1861f82cce82ec4be49a269e274055a73ae753a3aaf8bdba117989989274a28483a95df0464c1f452295f820fa07c25019e1df19b58cece1ec274a976fc4e0f6d975ae31e94391de3df4a6be78f1073e3e91443789020d1a1de14ef117ab113fbed56275ac6e611f2433b4b912804d9e16e4004215fbf156f2fec733af686c6578375de6f15d001ee6fc28857a67cf69887c680a9db9f4376dfba635eb7e0f8da025f696d6064049430afe9c2b2929264cc4caa03285a7ba51137965747a3f07acd417d2e7b1c71369d67b24bb61b6edfd7175e816c503d2d5b7b8df91826cc98a7709bdd6a451bfbc1ec8fc48cba28130a1203e528a4e4d8445d0ffb42bfea5efd96e9be06d00c233cf6eb542b307b6bd2d896ce16c4e3550ba58a5dee0500ccd32a1307b873b9e93b6ba400562595aeb627db02f3f000c77cb8810fe4ad4ff98dbfcd905eef664f505e050163b723b3a5722c7d6dc4978e277d11fe2af39d0f5337738e2c5198eec265f125ccce299f382a688186b5303a974c9de45eec4f1745d4af16a513125d376cb7e1368095162b7e1715029698c1473ee9d879926d9951b82dfd1bcf104f39e07f3902ea811919f836afce1818d0e60b5416a5a8a870f10702c30155602b79218ef4d6e692bfaae4c8006217f7268cb4d17717884ec2c1b583cbfc98d2fd34979c3710c08d7f94660c2b66a5ac87bfebed6455f2295d89dfdf6a96fcfcbbde137fbfc162cc429026d7500778e1c4c909d30586f61a6978f8e1c85d3d232438c9001c8c3adc7d03f19cd220b5e340b43bd347bb6c695739e833f313f9c7335c68423dd4594e143db7d306726280b9cf719d01c182c55dc1f3da2a76ecdb6f575b637598db6041a57b74e0c472d6755b5fbc6b292a3196935559503b3eafcc169df7cd3ad2451c9a912b048dbeaa79ba595e1b7c7e84ffc7d26bb9b1bd7d70512f08e2b88ad0fa4ea418543768ae03a72caf30bee453707a787992463012ebd22dec2366966d46824d256f51a44b62ad794fcce2862e37800653562dd539f69406504fd4309fd6f1e36a55294bca4709ea988e5e3d25fed7e2eea10cc67752c826b641f9ef86787048bef843defb3a6d9be53ee35761e65a4a3b6a27b7aa9ceef5bd1b8acfe4495777a894045e8b5ec31dd7698af325651b156d4d03d26730c0d8fc51d6424142801887dc2a89dac032bd01d9b1a216d65e90e8a8ab13cb22736c229dd7e425f169e10fe000eeed57ede053628b9edf96eec2f78dc29e39e71720ca06143d223bb3e6cad3117f892e02c374acf263b3b4950cfa7bffd614116502548e1ce4b8471e7903966cf2c83efa400e5875a5bf2ea716bbd1c0d809ee2ed928eecfa8da6e896b835d95af6864ee0a2bf3e7b080842f85d76bf1b18d8999582f223a2c017be33850943f5abc8771e7fcfc184841cf30d48f858570b91c2d3bc9e882d7840ad697db564f5b5e27a14efa5e699338f338cadc5ccf907964ecfa43f6699f450296d42ed254cc483f7a70cccca5dcf8a1327269e768bfc4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
