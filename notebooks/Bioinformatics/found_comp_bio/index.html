<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50326942b1655ce630dfab4995ddfa1b4f8e3c7a05ec2f56e1cfcf65906858d5d513bab9f0908880f943fd0007316b10d2290d09c0b13e38d3a7ae8e9dd27ed507f803f739512aa4c4c50122a19c613052af5110bf25c16f64f6f1bc34d47ce8ae2084686afc7b091f2f81d517383af25a50054e8dc4a6cbb882bc9ab4ba970cbe89630fa634588a896fc207c25be6e5c1aa9dc1965ec0a7b1b90d917bfe3e00d00e86f35a20d772024d7e09717973a8863fd047bdf22e5af9167da3357d62a4975f9291f2399dbefae78312694e0902e313ca8719126795fcd3059f539a7ae160321ec359e084e5e8fe919974e7ff75241dd0c5ca38d7b06c6ac2007ae36d47d5ab519b3b70a951c695ed4c41427b7ba12ccfea4dd2a0eeadf50428d34ef306f73160845a0bff103fdd491de4da5045dd2b62940365243f0120bf72210da7b8b1314c0ad03cf06d34c11b04aaa1eb7c435216a2a535bb25fe49091eed8d18d293edba537453e10160ceaf8e819e4284977c1d21ebc80c2cb10dc39b11eb8091f6cd0fbbb5fb5722576a6fc301e92c525739185ac0a6d9a8843dd807bd812801950228a350f9252a124b49f964552e5f35c1d39a1a96fe5d02875ca755524f0e330f5b44adf3589b538e0080208518a61a7de79d9e5fa235527943247887f91c8823d233538f6ff6c4b6d298651ef1d5763954080921ce4068a49b6fedf0c80bc7ee481f1498c1b0b4de6e7b2d3ce39ecb2b7ccf4b907fe730032469f57088e2c9a990754dda5bbf629f34c175212b16ee18422054eaab80cc03f9d2bae0bb105396647989e42bb3fb73ef727e7b9e58aad57c1d3b8454c929137d2896606abd4f00e32bc7c7f761df6a4e8d9424b0c28f073ee4dec92e40b052e5022d914b731a5a32c8777505cf14e8bba19a185b0651c4217a17cc16ca23a7dc2ec9f1eae6d075afaa1aa9da56393bdf22254de7e786156d99b5988674fc71589e5c7fa6832071a668cefccc3053728a15b8767de66b0369e50d61ad51e7a5c68d1c0b46e7d4a3351fd5036395322c0d2f5f6599dc8c1eef23c4cb726fff53f3fc08ba6b1683628ad278d1d628bd4efb84d6cb363b62e80cf310c401dd598a7a41dc9f6035bf9441515bb0113e941ebc707751c8c3fd757a3f8c48764146081d75e1c8a6b68f401833afe1ea65abc4461b4dadcf71de09299b431a09755e176a5d94a1e1ab2dccbd8a9c0af8d6b0a3aded990de82eb4f629e6f2539faefab08c206aadc4126f45d8f3d4cdc775f029a66920bda5f36dcc62b67a0d269b562133cad5680b6ab5a1b5bbf76f6669f46a70d517e4ef7eb609269b1e2e4e3c9223833247279bcabfa79fc5b1a5e480070f3b5f9116c10a9fe6abce7405190e88ae7e156d8bc65a28aeea41495b880285cdb5fb88d2efc65ac150964a478d00011ee349e8cd027c4f8b3aa53118558fdd8f7286a73e4cdcc8b55423aafe6d796e6eea1188c33de6dedbd146368c6b2f4535869f1edfa4fe2ca8fb574e369bfeadf82088fee19b35cbf45625b306ba197ea9c5d7dd48500019125da01f997dcfcfe9b1b4f98f711710a0359ce14e198652237876b045879d2e23cfa9888e67d8e0a18906d2bc7a5595182ea18eca20bf0792ad98b0f726859aaa53bc1c44063b5af8d7465ab0bf8bd76d6a860415e05dc455da8fde60614e68e8ed496e99779c523c5f83545908405d8e15a5dc5b9896c325e810c1d22db3dfbba3751d50abc9e4b241f466ccc4084cb6a22dabefe358e7da9e06983d68ff38e0d69421748149b853a98a30026bf5c62b5f9a5531eec9c01deecb2d74191684236dd0677a9b2ed354f8206c5bef8ab8464d738a60e0856aa4af252bd888ae71bc742bf2373e9497694f057656601409bea7ff18a4a4aefde8f9ace204c46a8a64bea86e64213c2dcf6f89ed91b49df45583a3adc0e5123bc5a84b408f531b6c856e22dc5d35de72b9440d2f11b7130782c90ba144fb71c703a6ba175db174f503b66683c4aa01f2b2f5e48de2f9dbef14cff444c14f96631fc10c8b8336c500982389c92980d3ad89836ddf2adf60286594fc83014c4a42b755ff776f12dd1a59d87ee8c492a7ad71747cc00ab71d3ca9a4d34e692d37bcf6e11d322aa9254dbf1dc43940b84addd84b51b3667b8c1c3d8727b5743fe96b7dd9eb07e9bef45b52b943e7b4244b6365e1ad8eac433218e7b5ab6c95f68b28f0ec7dd4f1cc57cff65b04a53f148e73cd62a854fdf8970f9d05373d3c67dfbd50d33f0f04e2ccbe248c63c46cdb244e402e91baf346671be9bc66a75e3bdf42f88e5d155c49d6653e06f08aaecfaa6ee61783ea5826fefacd87819848622359477e51e28d8163212f6de5932be9e1815bd63853de91e386293835c00963ea93c523b4c9de0aaf5639b6904e0859b9819e390bbd53a459d67642d8bae281c73db737636dd8c5ba57039701b726e832ec941a2b59e44026fcf92a2727ab5da1c6ba0e16e475575802f77256f9372589a8bfdcfd5076c5948cbbc7f9bbe0d0f1d73d9d0f5b37c2950287b59c8ab91842de79ed80502a3ff59e4ef1325ecda0e98703cd80aec2c120e925fd3a2b537bf9dccc630a8d760474acb777e86d07c1971f171d0c79d93728c9654673e6dcd44edb78352e53c23336ad974e3175679ffb05ba4944a00e4b37410a3b08847f468ce3098ddcc7d96d3840a0a1795baf0ad410a5bbb6caf74104b0053645486f8a743bf7dc3c0189f8b88458b6c90504df0ddad0ed62b9d6152ad51b1938bc4c93cfe23c2c818140d2980e0a672aa0d33e982b8b04c3f2e444f37c07c0445d89883610635e4375c3fbe835345789fc9303744b875b9fbc2b79299cbcf55ed6f173f1d41673c185b7a35a838f7d783ae815fb24cd193840681e7ab74d8192b2be62c3fee695951318ee966e22586ebe7c6f3ecfec51e485a1492acf3e8095e56294174450512a9ea8f72603a87dd20b29185ea1fbec044d1889c62b20415adb5aab194e89f92d646d65318241ddab1af85bb7cd4320b99875de6a34195c904e5ca7edad2174624fb97bfc034e7db63d7bc6b10ddc52fffd0378334b0ac73b863ff0f4a75072dfbdaece7cc61e1554eab9a2deac9f9cdfa98e41f88faedebaf74504a48000e4a667c279414da37d09cb277f3ac7919c79cc4c49258dbf631be2a1839651ad5e2d3ff8e5dba0863cc8966862a38ad9a6620c73815b8e1946267f0fbf3efa58a6acbf96b80f4c624b822522673368fc20c94ef7957998021eac4bac73924aeb9e44e4b395e1c27b048a2c0de69e3db7cd7d96384cb8d632a963448925251aa3ff3ce80a2e3f0f136464be6ca39e5252de0b0a74bdb1832b53bd91e175d0e3df171c355fa18513f67cacd6d070629549de4c4a662ade14326f65982fcb35571f1bcb3e60013a862121258c095fe945286531d5e26dd933a176d423f2cc12351a43d33140318d40ba8e6339cbb393b6c39ad48646a3d07ad7be19b7d966f3cb0fccd5183ba55b2ef5c8890e33e86a07ca79c2bfae3e202a620ed9f8512866f99d62d35f815d9b05603743e80b219b0e59ea0116eaf8bcc4fe1df1c0480dfde9a40e0d146fa09ea249f18a37a87cb363850990926b60cc14623561a90e4592a82c78b1c31508b79cf41680191ed6de5d12834d5ad1d5697c165c43e61ae0b274b7396ad2f6a9d3c205fbfe33337e125470ba00819f78fdb80a53becdad53554e13548773c5d543db57bd6253df3eb0c5d0fcd3bbecec5921eb77e43c0c44b4ff5a832aecfe967df425d7942d832554606cd69e81d27942727e64ca3b11078dd9a4b9af0a9f1f762151c5fcbb22f4f88a2c9896206584c2856ad5462345ccb5ae28787de101546116fab2f5a187863e3cf163ddc2be13243bfebdfaff4f296a90208cd6d05722137c6695b54037df184a9cd07769b19bb4fd913662aade99228a33c82c215c9c860fb021d4efca60f091447e2c0b412c27cf1b3466691bef6de7f4b83cddbd6a6e2010892fad27cbdf114eef4f72e6c422bb46de0ead1c345ec082acb1ede9f8328cd60f9f8e1bb7d3ef900dc6ab1631ca67f4f01aa3889e0fbda345c161899e4a9f57d97af49e9f12fa09f047a487b66934e40f8790ebe1c30048352537b6a62576427861918c344d847e945fecfb101e9857b13a89090e3d467827c406f5fc752b9efe3d89d449c0d41753df9c34826157f0e7a2273084364bd240ca401f7dcf745e2a85143ee26ceb5ddd52b39eeb2ca5742a28cd5315188cc441b2aba32f30a2d9f0217d3f0f7abfa70f538ac32fa909d40e0f9fdf1b90a9531bcd266891c0bf99e68e1e6a91edbc23fe62c8f0f57ca17535ee956645b04ae7d28e177e1765cee3fef2b424d804a081ca7ffcf00eafd7f62f210936aeeff40edc8a0b7cf812cabdf2b681c8b1cec19f0039510775641f6a0b927016f2f9ea6de9ab5da0d390ded3bc1c1645372d553935a7019c20e5cc00fc88096db9dd4cf4874de932dc2b3065f049ae9c58131bbfcac56285362255a469f09bc987b985d4be466f34164e94cdccf4287f5cb7eea50f451618894109241a9aa69feac2f08b1c8e8466acc702727c3b0335530483885c928a3665a1a24320cd94633bc3d8d0eec5182e2da84dd4a56faaca2ded994c429e6145fbb8ca9e9619c39432c6edf57e5d564d56a14169c19376127b152237807b54025c98515458f7e584eb1f64aff5ef3a04462495eec500b0afc4b5033a33c25ab04e5c4ed0d16d8d7710ba0c4445bfbbd3500080bb019bf3536984a82571ebce05dc4c2be2db843db196ef78cd1d44bcae595a0a10dec85d0675da07c596c976c1128cba93191e4818eae51cc8df51c47efbc078fab7c0e1446df082429e01e7d1a6c2a2fecb1e9123261a37e0fa2c32fb4e7e9fbe8918c1fc24a1ac1ab1b7551772a2e17b6e02507328c21855b8505459f0846f9af70e58e405a73655a0ae8a600804768a8730f0364249865711e5f6889beafd2aa6fddd6570b1319ebc60f47815218c12dbb467337c1a19f49bd4ea3fef040674e21140011106769894ad0ab5fc1e4c9bad78ed64fc791e94caf6d04541cd99ea8940949c41b256e9b7db048dbf2287dbc79cce66ba57fc3d312bd405c75084a773abf6077bfd3c201b795dfe987b7d186af177087ecea048637582b8d2e3deb97d93739bae05b88868000b6fb1046e5a5ae3029d146dc35dc5542263b33cdced09af6eb87c5f6ecf706da02f75ef343a305da9d9b27028eb90215a7aa77363e6b314e3eb431011f767578d2a672aeff3706cc4a3f589d161bef88a3a882439afa3ee884439c3837f18f23013c44076915dc6bdc8497b530d968f36892496986724d7effe66f7513b502173e62767b0231e2f9842ddb9a44e285ed83a9d4f524fd4bca9104f66d239682c03fb31c165661dda5bd1c0c669c89153509270b3c764117febbea12f013587712a5171c4705c8e4e739333ee741bf4ef5f1ab3fde18e7185e93bb4f7aba98da639aa07870f52026cf9cc626031b29b02990a9ddcba0ee1e16d6d3971e1b77662560990c591c13ae4a2632bc24eacc253185cbfe8d1122800cfcce9ba8462765c529547117ac4c5b04bb4c7f4a402997c803e2230fa31404dfa460c0f24561fbdbdce9e6b002db3fcd6ad707202e46b5a84e0f215f915d470a2fae9a460460a1f9e40f082378e424c617d5ad4e8e0fe66f29f3aabe2f58441343edc351fce9ae45fccc402dcf49058b67adb1b59d00163ee5758c5d2aacfe58c31ae8a06a98e3de936b698573adcfe0cb7b87a7c781f6ca95846553161bdecf6e91b60986886e53619e0e9df0182593a5efc339f2da573f373bb576e5291cc7638b7bc5eeb30e07a565030c82a74847563d701bdc726c02b9a761119bb681cdb74ac4c7ebbdfb8ef6ece03eff6f33785e8573acf4a9a12aaf99853e4d011d45bcf5b16cb32ad72195e16136dcb10b50c32d711abb9301585b05c18a59fd04d5132c34e03a49dfb964737fda2dc365e813a7b99e88d1b17572c59006dfb62722d529a823dd9509c70ee8048042b5b3b354994b1d09d3937f5e54eefb1fe14763f6c9e857ba627073e69238bc49768c7659cae30080cbb6e749824ae44ce3af94aa4c0b6280f9ac8ee9c8a7a7669c905e635fa8be2e249de8a254db96cf8add8a41bd701a7de7e0b81973613e2abf83ecdaf1d3e31d593ddd15b9a745049cf24f0cbb6ade388613f9006e958c55f62c2522a9890f201a9b23afe18de530bbc601ab7b7f8f39dc9d2c0244d1ac5520ba5a44b633987f56c50e2ad683637a2f4d0e8685e99cb95f019e465c5a2957ecfe87f68b2047b6af190448504bd46e89ee97dea7f87aa3e7861602b37259ed1b0779950f9ce4c3a56bb6c0e8ddf43e3471f78da559414c962b2fa5dbb96b6f2632202894e28159de261ce7d6c18eb7bb085cd9eddaad1c8138a9ab0c2bc9a1a6b0633f313665cd82377df0d60f9ddfebcc21df5b689fc18f82e264c9ce1a8be3831faba2c1305eefc6829a104d397f2c5531bad7718ddcc76f8253826ced4115fa36888e91ee6d6656d1892ad2a2a8bd937fd62530f35a5eaf6fa0a84f8e7c4e3d94db63698def6bd41cb07fe26020348b2dfe75589eb1095953c838fea125278d94ddd6d98e32c3efff4c5e2b2853cea57921f21f631dc208c632a433256f2e45ab618036810dfb127bce81dd32abb68c80110b5a366d7cc5b0145b0fc5dea142c4839476a82d004d99517d7aaf83c67cd333d4f5ac693e0e56d5a75423efac3d32860471871cd84d0ec5d628744cdc953fc7ae0eb97d2fbe2bff8b1f7aa02aa15cd6f2febd6f1416bd2759e5bc469177e85bca166f2753ec5a7e8126ab66758b07c29675214a27d2eb1f01df027798374f376860ee5490c2a5376fdc81d86dde63a5cce834b7f5ddaa98f434ef851df2d725b3e844bc21fe02d55aa1237073e4d8c77ff93b7d945c7fcf47b4fa8ffaa428e959991fc3837ed34e04b4ed7c986bebfa9398ea5d6ddeaa313a6db57548798f74e32349c625c5fca434800e9227d877307ca765e60aae76efc029dcd91210bfa5deb19958c7480359452c0f5c0046623c752bb8edc41c87039930293582100a1d501ee10ca95230543c9324240f51f3ef48d295f0a56d9dc4d91130cae8db4bd2d636256f27ed2cfa5bb24a6e4f7560607759ea0e5241768be647689a39db4088d49057f2bbfcdc53b0fef975e0e7bf95024a821b26af6745e17c3692af5a8076bdfca9695b7ddeec9cfbd6b21027c553423a2cfbdfc0bbf66af811162f19f17100e67bd9b38836dd0bd9e1c3d4b7e933366fb41bec8e5832f437a09394616e3e009102db1d6e28b122a8d691a078fd4ac863898ae4b148f23868ab219379be5609ff85da340964a0e9b22f72f35c0505c35f63c13c3fe689823958d0aead6babce385c22f86ff74bd15ee332bdd48b5591a4c4f0a271c8c62621d571563d26bc1ad818726cc5310eb7a85ebb6379839fdde151b90878027b79d3ac0231260e304ac1944a603be7f1eb2a2cf3d373ae8ace1476573ac5dd682654b031735c950f0ebb7021c4bb1fbe36146c6ef3da7238cb1886030344ed11f318e0c20b1d92fa8c65501509e2891e65b732716021a824bd2d71d14a128fb5bd4c22b16eeb59e56c46e6a58107c22f5a27edbe74a557e2baa076764134cfb4a01322fe5aa11b296859d071e0d85acad9df2f2c12e08fdf207f4576cc2d78aa905116b0326b0dcda36fd1b38ae01b57c65992798361a6479e4a904a8e783f919f2bfd9ace12b2525fd6e991f3f77b442eebd5faf8a7deb10a920b3f165f1ae3881ecb2a82a79c0ccc9f7940c86f621c7218fe72dabb7c917d03285a47216746457416338770348292ddb9219c99d3f5578cd747597f84a43411b3db265560c1de50a8bf9b79304c8de62532fe72e75685e8b68736a809d2e1414fbd079fdffeb92a262eb42230a39c911ea9fedb0217e0305d18505d4deb16476810dc228eab8373c4ecfabc7e944b846e0b08408d66c92680428308383e9b854e3b8152055afe47fb115bc527cc3e2103257be393ed4eafd9c43dcf93ed1e1380cf60ec8ba00ff51a94544e9c102f524f4d886f49fd87c2307cea90465ae7bd7a6b65fcad1532681a6930458c2aef423545c3f9f02badf573dc3ce6a05a308ab3042f5eb845da2f4396edda1e585692100c6213a9222f5190cae285f6bb7349e2dfee57f5ae720c1087bf0ce826d9e25bcbf96a477c2c933ba378a5242745dd1369ee27d3289f6de126e7c6e15b7006df6f03c3dec84340a6b0c1bf167d881a2d847af94c45f56e79ee4f1d7b8883ed7a134a9dc6244562603203b1bd4f7a285c9aab7d1c40daf81fef3a428fc245fb2abc8542f609cc33bb2a4397c3ad878fb8496ce44472ca47cf37a379e49c0e41286d8d695ff6b155b4eac92568090b22baee249e5cf81fabb903d9fc51196ec22ce48b5a039d5a1a2f7b4465b64953f99ab47ecbf157bb6845b3242e50e26374dd0e770abd3a6a045c38fa8a9c5185db9bc02e749ee42d3c7da230b241f40f216f84c05613b44ba0c93c6f3cf8103c79994ff5d1c8e66eb6733fbd3c3cfb1df65b8e2c5c260116a86f4f41b969b263a6af166ea5de2623d27f8eb38bb46cffa0e555331d6a11d548348f7582826ce1736ce8f44c891b011ef7c2c6b0c736e1a1ad8c45aeaa3f5a98e2a10c97ca8850b917d6216f0a64c147e541d09e06b7466fbb0a2c2cc3332be5c3d12d12374724b1fa95790aec42cfff7581878642dab864f1aba4331706c2bd9c330f503e0b760a996b5d529276f4ae97a8756917cf94ffb8ee3c5c21c1e4044f34f66bcea28e078467e165f2928e5065c4d10719eefb629598818fb515ce5cf4b64a017fc6a952983f43e09017d7fc398fed959584e449dd544e09458954250acb341f24fe71c558e45ac8185f07ca6f99ab82b01918fa211c5dab2ee786a94c4dc0703a4b4a477ce0c3320af82a11350312737b5fd36de75de0ec6fb8d48b18b5d5dd7866a4964a19462c0f981737b7aa65277e640321bc57bd7cfbd9f35ee98b69a0f3725df06fd054e7805a9b8e2e08831dbc2d77cc40b11f16b358ee992a2b4b1e1bc5de488ee93e0602e0178e318f4bb78066a5517b552001a36e69214ac18670e24bff18a2c9f7ae44296b382a7fd3092f675b244070f950ddf7de039b143d22abd5d1d44092195ed7baf6c90396777cbf68859a7e370d0f5f432f6852ddae525ffd41a5409eaedf8a5384666d6521ce7ffc1a03ba23b99d4c078e44e0cc704db4c94390011309dec2f87f3e9c53357cc631c5b173b7a804bb9e24a341ca250a754a041db2a232233842182c1f416a6f379e2d3f706c64a7f7266df46fcf528a7fb1dd039ee8b3e560a7c600304a3089296f7383327276744032b1b02f8e9a4232a0b43b03a631c6aacaa7197cfe97e4703ff626482677b20c7d03e7dbdd705ff4715abef7da85b9b243140b5f2224d1e19034ff8c3527e7a040c41e7701436651ff1e736d7ebff3d8d4d7b0077fb3a24cf98a8da7bdfece2c937b5d2b922b05c086a10966dd50efe84974434779d13a557164b7a488197ababcaa503e7fd2ed16b7c19a17b64086e5fc5c1afdbdc62855c651a57621883a164eb056299e93e1d73aec531147a527ee53e84e07d7231bf758e50212a76168a310164f675c611b2b73560bcabc242efb1e2d0acc1fa265c8d0270913c22114be7b607145d36e0d0f908b3038aa6c4289ad99b59734d3dfa5103500de06429fac8bcc47e35b86a0c609e2773906c394d69df7e8463b22e4bcbf0c32017c8aa85b8a87fc5fb01a7ec375ae27d03facdafd9229ec7cac5141eb043e79f58c4915add0f21452765173ac5e5e1a39950a7451b7ad5928b4910c81380910fc6f2e0cbc689e4fdb296ff9cb255fb956063d0ad9eca0294b9a8a7fe76107415c9029fa6fdcff9ffbcb261e87eb8cb10e40d87af2ac9639c3586ff0563f4463937695ae81f73eccbef3ea269132972c9037717d3f3aaf54e410f86194c3cba7200b1ab087f23f0058dba0a978c67ced842cbc67b35f93dd1d787b3508a40ca414894db869c9b915aa84d4a50a9d4ea6c9f7d605fb3322d3bb5070d05170325eadb49d083a34e07a967626b37e5b857ae6384a0b667692d25309fca46d7222e8570b139a7f873c087bc429cc21b3bb238ee2e3ff30367547b6e45d68f2fde4b4be5e07f7ee209739f9b6a910959cef4185ab366b6c4048ac68f8dcfdc3f7738122fdf45c40aa6e773457fdb348c5b30ea9cfd592d7cfc421c1fdef8e4040edb129ae71bf442b7ce135f783d7d7e0eef91eec3ac62742b5c1b7c0e78c4e3a4a00a0d0b887004f8c34cd1c4b2ba72ecfff2d6fc90c39c2a408c74d20676dbd3ccf1455a08e9d0a3735916de470ea78aab4a5da52558a83043f62ea6ebad244f9b8edf412a15de7ace5b64586d680cc7ee4454f3410785080571be72fb06d44d9171cfbfc5622e56758734fb903f459d97cb5ff5a6229135bd387f2b0cdb004833c68f4c605a83ccb1c77ebda0c6117b9d7c4c2bb8871482d03931ba1cf7470b21f74028dca941aa1fedba1871041f9bdf9d8e6c21eada1c9e83dac135b8d1f5f86e64d37bef7a1ea7f106d805fbb57623b529b6951f194988c60e8a8fea7eb16ec3176c4cdec4e4571cf27a289f0bcfe3254717aea105f3a3e3e4e5ec04e47f7e58f4ffefd59c118c5cdf7c87b6c0cc659a6ed076609d3c1ccd3a1a311109c7c76e36ad6e254126d8bd952f10ac2eab3f1c1b3a5c317edb41c079e738c434fd80367fd8730e52abc880ca20edb3e348aa276381fbf59ce583c82c4391c6ade143968a1664438fbd81ef4e990f37721b056b836d04f828ce9a1452624d2c62eb3751d40cb3cfc272b9b19a9b1d578db33fe81a8825b529fc9b1672fdd0f90402386e1191bfbbe811e2ed02c7ab5b7fcf101368dd7bd758cb2b3a167d762cf440b64705e5748579304add21b273068788abad177231587247afaa68a4440e9ed23f809944b14ed255074398809aada5f318a9c1a263348112fd844a437464982a91915fff68315df837817dd3d86273e24c6c58ebd5207d521b56d799a2051a12dd9185ece2513090f638d6bd765ff68522d4764005a42eecc3e3f8e54292911a41b012693890d7a0edb1b6ef21a730dc3acca5057f9a4eabec7f9d80e61da2082c833de6dedd4a659839fcff364b43fc9f1de73d86a9b0e7c2c00113e65c467205fbd712868f44bb0308d98449efacdb25dd05c20dfc652dca09960ce74a2ac50056fa3db7ec2ac0112aeb1bd476818bdefaa4f29fadec3b8efbfbab0b5096c05f5db6352151abc3cbe4d9a586969370a0bd1c57ed96cf7b935eb1c32c01a605f13e0ecb19d546fdfa7e83ef4979e43ba5d1ec2a25038e5a592328878c1988295f8c0978f7b7ad740a7b319f7a20bfd7e21d7c4926ce45edf1a284c86567003a042bc31d82a48d88d3b909f0c9695f94b6efb0fbea4e578754224336bcc67019f742d7082798a49afd0f02a3f3268233f1f6660daf7e2912efe7e37bbe8ed1a7354ac7762cb2e86ba09e9a29d2e5aff0dd0012b11dd2e75481f3ae3c88cdb71e7ae4235d23fb45d3bf997ce66eed2ff5654015c3327ef70ac53aefe92d63492476c80ac8c2bcd04c397bc62188de4b40bfac676686332ac36839c441e7f4434efeeb03471912538bb869bb22c4561aba696c7844debbfc4c43d261d606b41565022a2f0a7d4c9bbbad6f6a40a82136e0348857ccdbe82a252f9e39507036b14bdb72e16ebf57fda3c787c67cc0bf679e9ac47ef17832ae7485527d728e80db6a2c5221214e3517658b5a6f1f5160954da697e2fa78cc0e4df21f8be9d3c3a1d742b95ca096b8bfe13c280c6d85cd731f130909c5527529a97477a2a0147d1d60ebbdc495f7f0b7d2eeeee113b73626044aa9651ab01af9dce86e5ead91f0baf2b1d6fd21d2d3810ede9eddb35a7100a46f272103e5768f0724aff6a9e8606687b04469cf0e1061a343874eb75e1e80edc07822abc8c8e21620c3281d867566884d44cf2cb23e4ee4adb0d2a6b8945dab8a101e93ee095b200a91546207158d3d82b9672b2160f3c9075e1a384eac5b2069b45b77ce900d2e5c29bdd66e5ff1c278a558b8cde9de481094cc3ab5b9e3ec2e3e1193dd0aa20794eb19a7415c0ad9473509378a72f958f547379c2b0e205f60dd66ec513ae247807516a78d9def8f9996268f0ccbdef3ac69a83b07cee8102712a73d47c3c9c1687f8473643c5969af33a129d96af731e2dbaccd471aeba84b048dd0b8929d9bccaa85d1d8deb666ca4a5b27cc9ad45bf8a32ebd345757013ff728c568a2949cdf2c00b49f5fd77816015d8ddc5f0b2f59e10949f74a23a49d6ec04af12337a5b6484a8978d630f8694b85a383eec0a02a7c6572b44536a70b99f2fa7c224195782522c2da6674182c9c24cbb9181b2f8ee84ec3a8819061c6a884b38fb44e72d704d1d6a497d771e45fdccee95c84c21ae61727f84689d1064f2acca48899d4045d68af74ea8b08081f1862d042deb049daf5e10533c6ebede7dde9fa1a5567039135a9ba533ebd656117f53af1a50b124fc41956274ac89e083aaf8e364fa0b109e260567c7198cf38edb4766a94436c0b4dfd246f8253408876115173d5388198a02065beaea7dc7944ac54ae2009317f5e686f08a738664c22d7210c6951f9942a8d9c242bdd561d5cd39e304a98d30cbd04fc00a0eba4edf445a7ca5a820161e2ecefdc6cd12c4b67ab961cdadf47d3b1df249564dee29316b935c4ce2e43557ec182647f0c0673125b56db13e4286088d588afa9a6c863bc8799afa58d8d1c848d872363dc6c1cc219ae2091f8bcf863e82a9b2ff9f3aef14ae77801ed93b8ae83dd2a9b64dc5160aae8b9f17ca1a0980018ef95b8aaeeca1908572204c083a7e2c9b64f13dc01aa03c240949d7bf30c7e12efe9643ca3fcd57f186b0ab542e34cfad37d59e22ba8418db97083448d4174533513f823c0f513408d8d9a01b84135146944fa0cfa1464ddc268262c86e578f88494a3ee80d7635e5b53de6f505be4c4bdbf2cb57c5a7cd613692b7ff3aad49dd8830ff754bf13cc1708e214a5e59cbdab6e7187aa8457c5d3d780d43b1e862876e4b895f90fc3b0803f01fb6d9e082f42fb516a808aad5df4654e4586bf5d3255821befad41382b5c1eb54755a224950825dd55c8dd2adee486a70b139a4e778c865e5b8010ef3d12b1c3be1b92b6e7bd4c5d163601fdc12767db6ef9bcd4d93135db66b42610defb603f25b9c40d168b6b1b84ecd2ef47fbaa03c3e06139d8266636439ec6f6ba4ec7339727ea8a910236924b2dff443c606e304132196e8e192282149c0870a79ba4f568c1456274dd9163861249a8133addd563eedb37ff9710d16f4ace5fcf6521fbb9386e9e3f8cc0ff67329b0cbbbdfdb0da8dee1206c2ab63147168b4a8339e70b6c00acf7489f063421929a53e9dca11ac308154db3c24f141a7c0b882ef8152bc559cd0994d7bfda90d55c6359520c694c6f644a41f5d503ff38e2595d6f61f2733367d33b9b9fcfbc19054f184a8da517a33c996cca77951781454d87802dc71139884add1b1a5dd7988a712c45588d5bed43d54a77cbb497a2836f4883e94841e6332f61159d9f3dae89975c79279048139d1847b899c9e1603169b1848ae5b4b9b93b1c3d000b7152160cb1289511df8c81c91731ec18db414fd94aee2c015ad3ee15915c8649ded8a6a822636ee18a62f8e3f98e4dc5997d8b18356140a8986929079631a7fd873765b8dabe1e3a38e08009693a40724f7a4d32695a08c15518a8a49fff035fd6bca42d1e8146725270800fd50cfe9aae3a32a6ab366a02f26d3c8f97cc0901a9a12167f002daf1ec1d1b0d8beccb565ccc60f87e5414e65fffb6285ad4a0aaf6505ec562b48a53ec1721c4eddee2486a32b0465e525c21c34ba9591348fa463b5fa16bcd6ce416e8ad65b55e11d6297380b11ef08cff2dfbf8d6477e37620b73c883b6cb59dc97f3b9110afe3d65298cebda544f0bde3dc615b0b6c51564b8a02b14825cdf8b8049da28b4d6e4f21085e4d15363b56eb583df9a7422a6bda13738ca4bed2ad2328fb69ddf4406106cffce88f3d9d8c4f79ac4cf56fd45c8fcbfccbfe97272b6b3f0da794129b3dbbf2a6b581ec7c5aebb6a4a7f1415babc9f2ce30896ae706ccd1a7fc426361467647bc48ff7c8a1ee06e583d717043cec2b8bea37b869e78fa690ea11ab2b1520fad6e090774db60d346dd2744cc2bc4c86a64a8d2749c94d47798d4f6b4c9406bd343a7785014b317e03c0ea30704f5a66e87d6a90de9bb7c2bec55d2e15b827824b69fc3c815b9dbf927ef6b56f72e7fda4dd94603561f73f61f4069e7b3886dc9f50711190c1710f25ec377d814a537016250f1a6caaec33bc579e268a63f405abebf79fcb96564edc398acd9618db5da699d93075341b265edb934ea38242ae2d32823a7f15e2196679c64a2aead6b897384ef80dd4f46d883aaccc79f7638beaf1ca39a3113bf6d6d0553a7fedf4b464feb8b59a6edfa85b20a057e0ea965c49c1081b5ae4db9851374d405c42a4e749df44e30352d304b862add91411a1b8c2aa6ef99d89ed878565be5ab68f08b24c896cb167110afe72cee923eecf79806e83aa51517fbfed640c1eaca80200fa4fc7c70b010febde7349c2cc910b2e915b951836a35cee458a786cd61947ecc5a6129f3c1f79f7c523b6ae1906edcff1378d7c2816a9b0eba846e221284b299109332c086733fe47fda279ad68e0179868e4f6676f4880390a545023c6804fdd3574c49f0d24b320b4c772d4667c6d645afa531dac55126f141d718c175f6355db24238bd08d33a051fd7f8d5ae0a780812c21300bd62e1d3fc337200426f0c017013d7b9f59c2792de39ec87cd4f6dfa3d83cd2eb4603d502acbb76511d94706201d3da39c4f90242b6b10bac4a4ab3fb214d400e48857f4263c7e38a233aef71dd4d926b14e2e1f7541f1e5d2f03546e7d10a1b0f28b27e6982ed0d4fc968c06954526a631fb3d31b9ff70fc2db7d86606bb16e4df38a600b5d907cc050c26cad2ea888afd9c1f0dc166191af64987310807c57e2a3fe39125286f3b8225b4ce9c491878dc411b015c282926a45eb2ae327c24320f3577addc1ae95b0f5614abdb3f977288a3a68a38b0f6a89583b716897207d2a9b5664551ff1fbeac8209aa4c1a79723ab2d063405ae9e43894bb62b739289d144753f28e748fc7edc107647299ac3aaf23836970c8bd9f8d36bce4d85235bae7c69504e71e7702bc8933faf9e3c65a7defd450d0bb09123cba1b16c651ce4a0c389fe2ffc31356d098c860f35495a279ac6f7e678e856a08a0dce2f9dc42a76228b532e91b81fe6c15653342de7e98e1eea45ef2cf17f1cc048aebf322924bae0c819c967b1ea768e67ab8e9ae758492cac9914ac35578e7c58c1d9790db75ca4af2c6fc090f4171e139bbeb8ab8806db7ec4a756ac31c5eb83a7dc8843606c393702df2e32f2fc1eedaae493e759a1acd0ac3b1e5d38a2c9b38bff4259038013d1e0ac8c1b6fa06f20b28328567e76532b618ea15fae184c27554df1c45e920a5871286a7190641cc2854ae9a6794a7db7f4dd1d17106a043b8240be3f4be0131f8564d4099b64341c1c743c498f6c42bf22323f4909ae104f2c6dc3f7080881dce10ff8f96917ae8b9e79183f8733f5fd9abf0f1da79789aa069a548bb11148c442974623b6b93cb6f4af610ae40d7a4f4565987599e2c7148281db3e1479c02b1a63088946204fc81343c83919cc53248b0761aaecdc774d8a4dd8abc7408e0524f4c4e767d749159fdd330fdf8ee2a7b172a729da0b34a8e6c38fd859ef10d94f4233ebba94477eb97f4484af3dd78345cb1cece3caa9c4453b843277658a612b2fa32f90e5f00412a2591701bf507c67dd5b47549a07423f8e5b5451bc44944fd3fc2c9f7c067e003d1adf09a06e1dc70cd8b94e33636b35908dda3c74d506481b195958abba960cba9c3720d9646c21b93e6b1d7bd3f18b12de30f181292f900618cf74de75f134d04cef4addbd07f7e29e56f8d46d55584da6cd01736d989dd3917676e26c1a17e60c2df746ac28ac4b57a0febd533bb71d7a95849c6225f5a0c763aa099b326ec3560a398b317296f973d1149bbfa4494e9d23e6a9d791a347482886d48b3b687aec8d4dedeed3c63c04851d1b7cc6a88914a69e69a62a235815fd036cace1a8c599c9bb74a9ffb230fb700d4b50cd1a357ba060f92cf9a006616578a830d8b1763723d29705e39d7e1b8b7af132da70f48143e8d4891690e3c7e422e847d8e55bc29a6efa02c8d0065950c38ae3fdada1e1a462086a51ca6c032681af5e13eee1126c5cbe6ce4e1e1d8aeec97966c43876f1e3c124867e1fa7000539d65fecd84065a1b1e341d5932628bee586254ad7ca1d34f1b98a8a0024535cf00502425686685de74f0348ea539e642f38e4e48e4a7f3582b0d4742c433bb6852b6469277d53d443292dd69061d3b4fa16c780bbd01e195c7ad5e14fbb268cc956e1fc6c726784a849480b328288f417fd7e0389b3e53e1494672827d1328129ee4ea1ee736397b28e49d5d89a0c1a99a2e3d8f6fbc462ed01f3b885999c3675c11f9531d2353e5f5f2206cefa9bba18661b1bb908a18fe65b227e70ec15691e1ec815ffd1101f1dd1c462b1db4fc1a087c374321d68b3a403b1e21ca2dc4bda37116177de52100ee0b14f9fec44573f36498239820588bece6f5278c427d5b0f0ba6d468d52503782466f257181df5a92ec81964a1774621c680ca0d07a962fc7c0ca180e7c4af6b9939271152954f52280f0af97745020f176d07fd71860a801b4f2a02c22ec4e02d4e7e3b1331d505a532854ec6fb7bb09a5b06ff16746c446baa188b2e3b6030729b406129c703b87ebd81705b21a8ae483f20c0c0ba9dcfffd5fa11d46a117a5b5d540a6375ba97a6b08f6291de2df5a7f439e51beaaba0c624ce1adc9ded87a5110eb6b2d4f92db3ffb3337d050b06c9996b3d84120851f20da5afb15f86572643bb1ce213cfb80508c94df5639717ac9ac134b41df5cc11a663e42a8ee9ea4b30d43b8cf2aa3e07d2e7a8fa7971e387fc2ad42218c898a38c01517b9c6c7caea29d004d6a1ef4298bd9543101a178caa9ae6029f86b9e2f0243a1735cfe1b833a8b3ded7bf36fdb00d4f4ed953bbda6b84f3bca35032deed293b90eeba36f91eeac91bd9fd1f7a0dbabb08afc2cec10f3fdbdfde5a4bf3461c785a50f32763aefecd35f76c97392011043b806044acf3173c6b6aa8c93041c3ad54881c1a193645870750057621df068113b4be5ebf0850c7ee0474c186b9968d02034079baa927e5104ac3d3cf706fdf6150881f07adb029406b20dac136b4d95dfe25a29c0b2b751a27c206391ff1cd48aa54b9b3604c851b12c24ca0d0dccf6b6accbc1f202ead37e52c4a1d2bca048a4ea1a6a818ca4a0ba141571d8e150210e29eda569fe97bf79c6eac3f26c051777ca6d8cdbd66a7125e30236363ca0ded6cfa9fbca065d3f1aa0b78a409f3104340dc0726c5c761ae2d69055bafd777e14d31f00240b602dafe5a2d5cb18acfd5bfa02893fe46605cbe0e10496e7a3355a005604399a80331f420a19c8a1b7dbdcedc1d23f86de25d3d216e6fe927c300bff98f952a328701a6a263b32098d46b269ba93b5cc442ed6cb66f0bfa9d8f69b9718b15bffc5ca83ca8694d8c334e264e348136b4b61c1ccf59167d0f47a37e73eb40b8d9969883794637951de0952af8a49819dd4f4938b3e51320457f4918c82a15444d440ded79e5e06a72836d70c84f7d3dbf37dbcbaa3735e9e02fe9adabb1d92a50c0c504d6030aade3869e6873dfd7d41fc0411829bc8742e770d434c01efea29da6f40","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
