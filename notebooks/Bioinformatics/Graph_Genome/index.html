<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0455e1532b039f46cf37b65718fe19a6a7542970c66ce4f3415018ba1cb8b416a9b7bcfd969b535d600fa76f139db5e0d9e5770d052a55af4227c30f5de086d31dc4c191bc00e3567ea95867c25463b37c4784155362a4cfd51f875cde5ba7eb2da1a659c0517aa8ea586a2176e212d2f5e66e1525632bc29ceaf9ffb0ef94f815646758c09618130a24c5443c4fbd6a79ad19aac21725228e9a6500a1487debf414a1c6d5dd3aa627886d0fdb12bdf5a42a1bf8987c92a4e1a71b42bd7b4b823c38f862cb24190c5e3bcf8655d7359b7a758ff36841ef93771d84de5f1d8a29c010ec8551207115861e156c8d120933ed9f4fee0e4def9eed49b2afec853f9169ddd5cb0205770af969799e503242c2d58a5b674e0825673f04c89a85d5d0686d91329913c8d9e0478e1004acc17618c40e9c9fd086bf0a91d2fb7ef25771ca06498f995e9a4e1ec31cd064edcb88137d45a3a4c9f8b1f574fcfc23f3dd2f33271eb3f51e2e6b02d5386960538b23e0a7ec998148e928cb76031480126cf10c8b5bcd549bf22da783f54394e98e4ec611df3dbd85af5a04deca9d762cc47be2983ab256cc0af7245c7f3e23bacd28f1368b3d7aad18ca36405cfe553fdbfc01be9727493712ee890efe91f2b8bc5f90edce8d1d285817098b15eb32d235fa3890561af8481427e193f191a737461d5a7df24c18166c2568a04c003c553acc15a18866a417da2f9ca59ba789b739d632780d17d83435fa6ef9fff8695ced61df86c5d1dab03cedf756e35a5f94ec1810683316531df1cf798cba7b2c0b34d3e3aa8fbb46a8ad299b06031a15ff84d5a9d631ba1357eebd2f5331bc15ba7bf9a4b3e2b97137afd9be2cd970540ead4df51b6c18aa04b655d61d1fa8941c85df4f1aa494b39089c5f794da07f4f93f5a3087d9cb3973fb9b1a13b76b6d2b3e7ce772bda8581d53e5323fe302f5f87488287f6511923adcbc6eabd457dbabbe282b8dfb30135988b9b7cdec8463e994aecf6e799f7480df6f7559aaf36682f642ffda0b7151376ce389d331cc28c773908a7185b99c46bd23db90e834cbdb6bbf982161a7f781561569f22feb20b227ac99ae19b86967a5d1dfc1ab7454a553e90aeccff548f8f682879e43fdd3112961f800163d29339505fe1b51e57ab8f07ab1cc1d6f5ac5ebc3e4b84855368fb5074ebd6c567ed447b6917be90b0f2a94d88b3c58a769daf7b031aa28ce4f66023ee11a6b91dc0cdee37d5e5ed6708076a643969de8fa47931c553d0bcb0d572e91d51f145b0d750d6c817fd8f09430d295089fed673faa3e10d4c3e11cf5d4d9aab28ee38b2cdd7ab6e096b63480f9e5f77624a5422ade4faeb0da6d0b7154ba6785ad44da2e63047cade5072ac727e1f1e790401e19f77fb3d6c30103b54c5794872ced6a2bf58c30cc4860d6e4950dee99805db6d87db18903d1d87af2ccd8a3294c1702954f21cfc2f22a4ebdda5e052345a6dd9a2cc244aea86ea010d2c47815527ad71c0cc05b015d9b129393b21b4469bae34ae510dffc2d964770feb5f00297a6b708621de271e037d4f5ac8b05f52b53c4d240b2853684e9cff27c7565c508a3f38f3c05d87cc9f48ab26f5305a3d453ad0698be196d0f71631af462f07e88b9fec802b79f48b3b1dd28bfd999d13c24c236fbb82e05b9c337ddc00b0377686d40e9354d14109746e92b77f914b33ff91c3846f3b0f35f88067031ec82a8b039d40642aa8bedfb3e92258b55be95ed1db1ef40d8fe0c0ee43a0ce6683eca252c882f46091dfc1bb02f76607efc82cb455bf61d849f6fb7869fa151737c78fcd1138f8bcddb286c165099429a8ddb28d2188e43c5c9ade1ae90294d3c0ea449d9de22189a9ae080174c0317a6f9cfd6e53d92047d7632290aabd3d09e29792f75309b582f24e9c1aeb6c9d38616aa5e20c2673cd8dbf8c475ccec93b4aa40b2e801395d447d2e6e4782ef03cadb9c145dbb2b67e26633c8a93caf2ededaea04e99efc49dfbca51976df7579c472002ae2fb523271d75bcd8290adefa65b98dfb7c9b08a8a514b05698861f7a6d962d29a469d8d1a599d1979f6e1dd5b10e510fb70111d3c5a70e0779483531f520e937796ffbff1f752af342ea7e277babddaefbaf4fb06ba34d8e27c047596af64ea5a4afa26f26feb1e8ceafe3cbf6f2051484be4d18f7182e712fe1aa6a09867fa9583c8c414a6499abee04a9f154a70ff96c1bf2ac2318a760f0630c366ea1822a245dee4b35db55b8834289862c420d4d81ab44ca7fc89d821a059e0755bef42c900f3ed60e6be59ac0fc969b1b6cc341b72c84fe8528e51c1a8ff4a539de18d40529de7ef04b94e94301a2d3f802ccf6e03de62ff97e02e89e22174570cdb585333794e3a10750a9d40735ab3670ca8c21e30aa251f9ad0bf96392ee4e6cabb37f9feb095f903d71ef0cfd92ae27dc78042e1e94767ba0fbd4ef9c926cb4c487dd9500bf3664f460d3f1c05553d1466c8a6c5ce46ef09001ceaaf0add7f5627b6147b50b19a21f440860899c905dc4a6bf3383913bab477383b71c1b09ceb9462bc9adfb88447d813e02eaaafea03deaac8db011013d0c5374ab7d01cbe8d20d027faca1ed4579b02f09029f50e554c64b080220a8ee3d5843c2dfb945200a2d0b02171b460804d6350c233c658c45b1582bd75f6903c2d2b6b720ebee9a38aeb1a5f485dc3cbb68a23f86efb3b923bd74b794738c5e58e418f48d967b392d1e3793813810185bb5802e5737727657ff4e8fecdc3b9bfe0c0941aa54eea4d5f52e220847b77bb32ab947cc31fe7cbe801b63c6e6e2538da0df046ebf072f13faacd1e2399237f89fd73e1cba89e3f74e88bdbc2ca4d71fa9e01d37bf6f39055e289041275cc2b59235759846a86997ba17f21e87e2a0b04ce4a3ecf0fb9d4e0f04e97bcefd0a722ee59fe6c2a475d08a231e6b533b8d49f0cf46b98f9a6a42eeb92f967566ca12fefab2426bc24933e86c4b15a6d702958a303361e1d12ef7e5d68127e2e689e58dc3208bf5f943c4ed98854b50f75abf304dc59e683e7e1ad9412015db6f2f84adafcd091371854b8534a58d3246f084bf8501038527d1ad06b11b8bfefb9c733bb112beee77dd853f4fa2783c2317e90c49fd053ba5a64c1f2062f83288438b22e73106d274792ceb5ee0dc07cd7f551f59a1097ae9130a7084aae9feace5c702e4db5c5fc2da8b7d936d0a8921bcd415277376ea8068c22c90b636ed9cd3881053f22d93ca9799c8f92f236fa7ea01037bc05595f2e51c845c614b3783e94a72c04e1e857e2e2050d87e0d48f8d9779879bda5d2ff94f083877a5a43333fb3ebd3f8aa86921dcc81ecb64d23d27bda3ed1920f594fead751ccd5c5127c916f738fe673eb3d5a1a66a3ee86a8ad7ff390471e69917c727f45ce9e20ecc82f2bb0632013e641437727dbf28cb02f57a941cb64359b49147d55e856d78291a5c47b0ed8f11fbd42b1e7eccb78a04b215946f4a0e6f492ebe4e8e790a8c79543cc7088253c2183a4bbd8832a5c746f5468a8bfc89a26876cb399e2a08c94805724399e46d4f69f407dd657b10811831b0121504c66a092089166b1a594fefdcd7d4cf015568e55a9c40d30a38adf3858b839c04daa2abfd6f91d59a702a1b7a5c139b5ae11d6ae8db23a2994de3b0a394c63f56cedd4e4e556508603db5df1b0b97e4de5024a71d16940e832df4090d6c7b1199afa805cdd97baa88ebc34568b7b9e71d5bdacd7c0185e5a6e882b9cde6d02f52d9dfd871e3a1656fc1ec8d388deb4dee80b0ba047a740b8ccd4c4427f5c906205d30b387d2d7f579abf383335094bebb0a68cced6b4c8cb1c515c194fddc019c810392c78068d5b615047994f457b53470556eccbdfe7fe5cefa8522c3d5a75e32569a0b19988ed6bdf396272492d68e8ba648edd3ab5d0dac98afa15c7edc50893eefb91a96d6af02c34ef441a8f3f1ef4a89a7365bd1c4ca424243811f58cc802daca721c3788964fce917f448b46b005f14be0c0fbc0232619af4868083425e5d39dd076d128d79ce997ead08cf0e56cef76085435c215552837673bbbad51626489b9d90731eb6950fbfe5a59def15d0b2a3851dcaecb728013b3744fcd45c482db4612ee27af382949c8ee5b5cc8b9ecb10b173c1ffce29a5a39c08e6bdd5ef55d95ecc5dc47d58ea016d55aed20a7ac74c8297843a443946e7c84b230f213e92b9d745801810894b6ca3dce0bed8e6c47c925cedab942a63d80e0a077a4bc6c3bd280c475358df1436815f5e418087e371c3f45f5cdf5d3eb7743d7dd75cd97782d5c3144df07bb24affd98240cfb32ee585d459f5072f5a57dc06cbe116ebe879169c81863caddf34bdf14fe0080db5557f861e747522bdc2d5288daeff6644cd87f5c44716a0bf3e0f10fbe5d083cd8587b576135e3c56cab03a1f73b363319cee099c62e3278a6f3f88797fab659bfef803e2c3f725fcc458936dd0728ebc930327548b9646c1584f8c562aad55b6ee75a12fdfa7403f4312a1d89394682be5388a74e21ad9e4dede609cdb7da1bbbce10213135a32361633d7d25405172bed30732c10bdb06bba130442914767132da3b2623cb02b2547173469aba285e2be0f8c75bdf3c768f61dea6167a26d4ad433cc2f24e8ee0332710c2e9605100e52ea62d0dd6da988480edadb7e273a350ad9d0687df37a956c5a929e07767e94007ea35c19827ba813a19a08dd5ac1416dc4edc9e0a24c28f3296156d5c3044a15b181b6721be84bf62152f2902ce0e54d60b72669c885285f8742fa07a688dbe6ca8c3592ea1cd33c8fa6522be407e068447b803d3910f130024c4e13d322f5f56158cc979ef204defa95b7aaf6c4a9deb23041acecdb34487c0098ef1aeda598fc72228ec15f36eacca69a622320a6583fdf3cff6437de7049f128f862656e224ca9faaf6ca1b18df0c438f174b91b8fae771b6a3571e4440bd8315b1c87b94bc2c107f55b30216cdb500aa5359d13eac8163c7c75194fab5fd104ae3e2a1e3586cda5de1061b15c66048f79a0de6e1a67428d252609374c6558cfe5863990b288203a3127363e45e9d0a5829a582c755457cf897b49f24603ef623399b80eee3a3a5f725c6743a32126c4406fe2facac97f056ad468629b16262e66e658695c90fc7da74e128962cd33218fdb5826c71947c42aaead9260c358c545dc5d00dc74ab01ab0988073ea35f1a6e44cfbd5adba1ac82e85e5370c33836f2cb8047a43839bd759b02b4c7c60d235f9e61f9d9b51de8afe13d4e2e96cd25b93392b107696ad6e88ef166512d95498c0c50bc0cd192c39f47a9a18af0cbed95fe9d24614ba1faea41c1949be8af4a959ed9543c324a43cad7fdabb1bbe718ee478704c3eee71f2af8007f51750037e40de8404dee5f959380d207b6d2453752949bd4f217995c1eb39b288010e99d4ebbb7e312ecebb3a5e4a89b3ab676f8d04cc7e3955f79ca284456adeb6d68f771deaa7b78ca5005c353fa1b847ea87069d555bf37f18823acea254d71ba7fc86bae422f47eadd9daace4097509c645f1250a6483f77b210cefbd4482b5f394281d7c5619e03d7b5140fda2c0c51587469c1453f6a78eb91c10c4f8f1fdbf167ffba002148d82509b66bd5d4648563ea8f98baaa15f3b3426f3c5730580b875928715d3f8839214a2993aff6ac5d38cd90ecb71e2e4a841bc25626716e2b919b751dc752fc894c7d717813316081891beb686554a1f2f974c04a5861bb024fdf7ef478d25ee670eb914e01b6ef574c954c97e19ba59980657333f3ef2afb8b5530adc459ce618fba60616c57d38408c05f91d39883deb81ad519aab71b2160504f2523e9a91330a5a1bfcca2aa69473e71ff90f093c585ea2a0203e757dd3a8bf4fa22bc70c70d4861230e7a496a5c857ebe34a8726b2ff6f3abd1928a95719639e15c5ceb63d30a4a11d24b0c3e7997b385f16e857dbbebbedfa9644b98d92e6136c2bda1e036a09bcd4fb2d9ea1671d973e21a89d8eb01c192c24d2dc5373df5f2bb691bc119112c7cf305d46d8c35d869e591446926840bd16396d7d5d086b77fb8dc19bc5fe8e2e965be4be15fa1a36743107113068499447a2918bdf6a9dac37f77b8f351f775fa77bf8ac7cfb37b29738c38ff37b1a23986845b06ca6c615a7fbbb5d6860a99ab832bb263439a9ec5b6af8e8f85ebfa3f46f49d5bae8e99c5526511d0febca0d4331acdf2cb4803fd38aee680027d14272c7a6d3c72eae284eb5edb5f3326d7652d3404a33cd918a53d429c140e05f8264246f01ace19ee2a1dfebc9a303aface7afd9d85ee1bbab0c26edc0c0889d0af70184edcecfaebe1e6d4c9b238bbbba5c0af81f4490fe967e45021c2242306c7750414c86f12b2e694c656e8fbd81cc193dc78cdf8c79116a57873e79dce70eb26934e9ba9e0fecc3fc7d65158cee5f426e3c1af49d77a6eeb6c69f7e5dca321dbd6061f91e2b11f2055b44f1cf1cf94c0bb5831cba7c54a4e6ac08bd7c1906b041e6404f4be6b5109bcd0924f252b8a4228340c673c172f7c4d121e7cea9355f48ec958fb53f10b5386f270efa5ffa030e6188865a68dc5079fc5db7781dd390d9918f5198aeb10b91d026fcccc241ce1eb7a353dd3dfec28b04296e860883aacbb043066bac57ff38a985cec250d5d288b7a3d53c943e84e7ae46d600b5f1c3d61a8dfa90ca8f8810aeca384cd82dce08fc0bfd64426f166ae47c7ee5b200f0555b40fee37376a22e8218019842445d0d76615d8266b42441f656991dc9a8a409cb75867572f70c2ed53cae3132a12d682869e5496d8344d1a22e2b8f9c33d6cacd825c2b057b8d65755d52cc799ad692bcf4379d44bd3aa1f1afa847d70d3f854c0162fdfe065ec19a7cf45a99445bbd244f295b663ddad9f78b9cb9174c0c1a6ff57256042c6ae2860f72363b7c40fa113bc5df663a6fa21e1a80128ca8703927e3fff8635133f41659bd96424258c7454c15fb13a74026e9074231b460916e04368c3923eff2448a7f0b9b63eaf7f8e4271f463090308218418748ebb54b972d2e1bd038ce0a4ccca6ec376b6c7c7fff67bb15da47f6041db90b7279f07c0c1a26924da93adfbd4e2f06848c4105e43dcf88964c66a36ff008a65d7f5186b9fc57df8f4e4617181cc0ff7b27be5cbdc9e286b20f3cdc46dd72f0f728d19cb53dc3845b0a5750437263fc8aee3cf117eee3c787e96248fbf2aee53edcf6c86c3ed5a554f67517929b1bea1d4383beedabeb93bb2296c76c5716b71d783fc29fa22b1f2183028af37840cd7493e867b58d9e45dc2598f85608a676e2efc4f6ad4afa507119b2e28fee044f5be8a6c7c99bd6a766d1c9bb66148d3f33c695b863d3daee0893e58bf25061b840d8804ea3d451b9a218ecad52b0646a288af387f9e634046dfe01a48eb2fa66117dc19ae4242755ee425391c5d07d658f961e79febef8c61de3679019a72c8390c58971600b549a5cfd0dd0b6ec0edf7b471a38278876d01048a2947019eb7d5a862c6266744c3e4726924ada9380ca3d16444d3a7b28e215131e741891a10549a15fa5ddbe63c659256b12b808befe4be842941cc7f29d5ee5883e57d939ecd51fae7d44932b137f8bb7556c5925734f1e6497e8e6d0550a4fefc7ce7d7deb0b1b93e2c99e56f823eb15275eaa0670cb85d5430454ec38e57fd8d3f63251087d77189d97693e4faa5b25a5d2d98a714d0ebee5651bd818608b0e0316a65128dc86c0196be15d3d7d6cf054ee069d5ae25969a83e67e5079967c4fd2234e37036c9a8b01c24783c5dbd7ed513ea373feea9924135a3b783ec1f797078a9b1e4329c5a18f5c1105307b9387a49dd1c10f2f21c76c61a88f79e38bff480032c4182a410f999f31b84b7f4f7c92a9837ca0682c453e83bc55d5c7a3b179be8194f6c9e5b461212d6138ac05e5228bb59461593743df443280ae70a764b4b00799a406ab68a21ed63ec02889e42d60828e45dd53a4a4430a3ce44d9893e750b5fa539c600ddb7b0ca66638338b383611518e1f0950963c8cf231e5c35b0437b517c85fe99c657617d4b15c1025fcceac79cd05c9311d3b16ee769ebc8d0c211c916d6d44fa5bf0da7cbd74c96949fe30a2294251e32fdaf99fbad9dd1b6bbc5d6aa0b4e06f539cf121cbe48c6d454c61ba35034facaa59227db5e4060c104894a89306a1b425056afde2e5d7517903b88875ba49369c6c119bad4b01d3826bd1b1b392f9beedb9708e95012bb9cc4cbfde364b6fefeb038522e929624e0d5b69b6ae0ebb46914c0f010b585ec61fe30035636774c8f1a259692920f1ee4a1021fb66fb58a82943a5aed1036351798cf95741b97c23ddcb16226ca4858201d5d6d1df27cd17148aeb1413b0cfce3bc3a3b742193420c61fe123102b1520c79b9691bee20fe1ae88675e6a0dcddde4d19f0807577f1ebe97b3b8d0a9d59ad41afc49675cc21a8e1c0f1da16f5c5d3b835402a5e8e5eb1be23dd0387fcbc483db4d512237769970f8fcf63058d463a4491ec77e7a2fb68092aae211567064214a38837e0ed0137aa622827c2686501c4887d342f37599c31413cc64ae12408f1248faf5bbc98338e5aaf342dc88f90f40b0d2a25bcd5f058798e4757cff8a5272b3395c2df622e67fe8c4d2731cc2b39574e6098027127771822be33ad01601a05800807a64d1c7f3cd7ee3922151a2bc6258b56b35b3de861ee7070cd5c5295b7ce727b9acdcef116f70e9c044386a5c0f746b9d7db3922c4ea1061ca0c3f8d5c222c8c0d322d9956255013acc74f42950f9109a3361b548796404e3aee3db6574bc17d91448b085e2cfaf331dc6c07a18bc34ccf8486c05e83660b03a055f0e26f5f95d2d5f5cd2698721a01d21886993090f09fbb5630293d562815d7f2972d70283faf582742a41c2f236f229187fa780f8994f15f36f440371e7481d69463f40af8f5fe1c73cc682bd988e3422d444e17a777957fa4dafddbb0fb18b253d7cb9bccfb3eaf7524fcd9eecbccff35718f827bfa040a6e605a56cb1e9bec36566d409ff423e85a768237a257db95e62c1401d000b8f642051462f6d66a606d3eaf718e9e86132fc7c06bb3e2373996e6fa96b4cefcb7630b3d43ac7458296c3ff629bcb776d8f31874d6ad2a12d70befe68e5dc8fa65fda1334dd1a1dbe45cbc8c975987eb0a2872fd1a6af5ea59b1cc756cbb8f52be8e39bd7725a1ac12a73a167463e70832e1e13fddaa0235a603eb9ffc1b466645992fd0744e66647fc9c17c73f86c26bc6e0cc419c96c54bf86593af7e15ee48f9261ab61aabe2a5ffd6df963a5938eb9e932eeacd529fb601c7ab176bbcc35647644ae966e5157b24a808c160985952d98bac65b21e1d238bc7d44d04e5bec0b0de1106c5733bfd531b14528512670a9d30e6815d5e2530f9e8df434f6e8dcbeaafc8c39596f38530e76d56e9a61ce5d07149a5fd512bb6350831b6698ad03bf6b9c1258a69fa318f7c00e02f8e4cff3d68eee553af817a03606308c389f06cf6884c0bc2009e3c00d80c2cdab3ef1817d027ee8ba215abf14c7a8df14ed494045d7f7db02ba12ffe0947d8d81d863c62eaaffe1859d2ef266c2baaa77194a292723e20b7ff7823ca3c92d4225ad85b7a205ac214a87e29aba4424749fda5d4d5edb33ce9bfcb17de2a8fb1af1a640f4056e4b7dd7b859568ee243b783f2de13de321572178eefb73f39e4ab84671880aebea263abea92bc9353975a7dc56c9ba81d239351ca341e1fac05d7bd36cffa0f9e0a3094a23b44a28ae14c4367ae372f3eaea3188cc29a50f7d73d35e8ad470679874cd025ae977d4a32d5126aedfcbedf8b0f7e517a5ea6905e40c718a9be46de12a1742302243d9cf7b697b6d908045b0eb45257c3e222ef26e7336530e767cfc44d58aa2835ac71030841b6ee08ece42385a3265b8e0cd62a5858dfbde44eddb4ab42f37eb82245832f12ad88330808951973ff37c490a58796038239b835f1ecf275873c69982b9c7d4e6329abf45de5ce5dd300d036cd9b106de730bab32bc758e789c4fdd37ed48f09840414f311e067f38005b8e19f5abdcbf5eb134c380948d4fddd21713d5226074c76f28643bea6f9030151ebc6b0a3d0fbda089f3fe48bc725ef95f3c39b71ffc520a0d9ac56fbb3b95e274aca80ad0ae1feb6adb18e5d6801ac3eb065e954eac48f3d76e6787d704be5a7e2313cad3e4f8dcf1ac949fac81efa3789266856c086f7701bc774656dc49d4c5fa9d2b0ef7dd110f91db2c77c8c5014d1d232e9ebe3b9bf5a045b4798d3e2841471f8427a4341ef5f7616dfe6b9b1b2b9b97db66ccc0c06ea2c9b7853c21f1b489de021f0d9877118af21896235488f11d87dc6114f7b7c84d85cf6baffeee53de45d55d46aaf53baef3d66371e1a390d74c487bc5e8f4703e3d04b191a2e757587de6c87df990afd65b3a50314f97f4b11abede642fab5145dc593de5fc25afd75f326efc923920647339e9ac89094775d19b53f02ffcad91316389d906f20e7c19cd089456f428e6e563f94098f53c2785ddbe090afe24fcc68a62193431149331c2f8e48f1127a4b4dd5972fd4e743092a420726a22b259fd499ac597fd251476a83ded2bba5cff1120601c05cbcd2bdb81db9b5bab04c32af3ba1bab6d40e712ebac0dd3601a9bfc2a6fb0741e2e09925422901d4c8f6fd3830a485aaaf88ba251cb15f70a316e1eb9f06c3dc9787cf27a0168ac0f5885581ec40e51642440b81e26a578a0572048fb03ed6fbd46ab1d901b1abe378f4e05e2ba00daa2c357e50246b08cc11364dfb9fcf838de61c8cfa4184086194429c01cf9d7b8839182ce696a52725e14261f55263b14adc27bd771be773e69d75bcf2669a43b50bc062cf4a55d88cf8fdeb3d402fae2ed572014224abe4eb98bd2acc70ea82a8bf2369918838cb57c9fec83381c6c67020f5e9d0fe53f1ee0ae73383f16b7b08c38dd3fa30d453505c64b8951491f739737d75a25b2a6084f26022fff8fa8a6e146f245c2b6bb76f24251dfc9540f8c21844be994d7a7e782dd91b4517ec74a6d89f7e904dd6415747a406dbd0a0e05e2fc2167e46d988159d2a018c54d12d522203989a01456f5ffce8fc251e835de7b9da42e2eceb025963a05918fa7424bf0eea11756fd5fd44ca80930af90209c8d8a1ca4937f6a6c6459df2a41145047118433170bab85aae8983fa98bf1cd411bf7cab10c84680108eed6513ef1fec778b5653709d6713d17863506e565940daaf3eeaa841d5af440a2368628606b8d14a315375ee1a174c352594fadbc25c901b714786a7de9b554c687866f8560081250e24e81ee023cedf72b2a00685475d814be490402cd888b28b4b187d56b4577d9d50882b1ddb7461b53bb6172ffcad4f9337e94b13ed4c4919694d7627920fbf7ef9cb324d82244f6dff9389a2d3ad7f10641f5a81eeaaea8abccb2773b96bf9390e2e2333ead8009bd0b62f0a162f79642dfac374ebd5fa88b9d211f201eccd59fedbe58ffe6efb9ee59d8b30f396451152895da4df7481e923035a57b2334a905c8d4fc949bd9c880feb29a319645d4300b51763500c716cf166fb0ba0cc1790612ef0e26561c815377154148f9362e87a5f829894cc3ea9246e409345e808a739c4cd9853db1dd54ac703894723a929948da0b8d374fe4af27b7237e63e29bf544ffb70938269a2836fe86f2f1032132677405c820715abc4b85743854f50b3d072af1eb2df466c886b3dba6d289db0f8b7b5c4864319a6e76753f8f068a32fcb33c15e48d1e3edf79d4496a16bb0bbcc6d90fa7de3b7bc0e29c23fbe3ab0aceb5a06b9527a6ab3c9386686b6993a5bcdd1dafafcda7bcfd77b9a39bf86e47601e4701c7a1ba40df115b76e69981396e26f3da73079fdd26846a66b78ca53c7bf14b0648d9d1fa9f77cc915717dfa278e0440d492c43067f29488ab642c702e1d1d9521cb86bb23483922ee7b61b315b3bac6811c1e019fa8f9e61dfc90a7deb8a30dda090faa74102e7e9aa0f7cf94d04579a660f8a1b6f5dbb1c88a1b10b7974c0cdc4412582e30f3f70e685cc48f901c49e3561871dc7f9e505ca225e8b55ad42f04a67a34be12b6cb623d8d719d7fb0861e009f8657da4b9744b34f409c0ccbbd2f179df40efde21c092de7f578d289f020f23fcf0c0ca2f88d2b76cd73b545f0dd95fe1aa1c813ee5860e07531d402139a43e3796eca70b1e2e26190e86de024c81f6ac9dd59f933e4801b3cffddfc13717b5245c3a0b667b67e6b33650b19eda13bb27591204f9d077e6876bdf3655036969a01975a0b6a90fc5004a02be7bf854bc7028315a7f2faa80d26942dec5588423b588270fb8bf1ab6365b84dbb72869eb7d8e4e928ea7682894f379f21cec365230c15cc0711b7a507aaa148660055f7d582748c55a2423b375fd032e9d9eebca8217615c6212af94c6e9f7f66da1afb3a819b805b870c33944ae798f5e15a71c5b888829af0126639fce33e7c320af959eb0861e8a302b0614ceba183e2fd94f0ddcc3d7b05fdef35937e84889e368256cab3fddf5df3685c62fa03dba7e600546ad0041174acdb3344f82013f51143b65d0d2fc51a7e4423479d5ebb86dd3d94b2301386e0e308b3007f1774e188a4614d7e5fe2983fc7b56cbcbed508eb73e7fd5dee0879bb9186ab9b82e7ac7fc903725444dc3777e026c738d8eea13e6f679daa258129037090653bd5df833140fcff46b308e258c5cc66d8a57993c86cbfc47254698dc9c60e970b3ff7e7c1c9e79c6b37533a3dc8ebaa5986237f2721b5ae6299224ac84311064b1dca23f0ac34ff479f89d4274d3813f940f86270e88393e78a19926fe806ea305fe1c9f0e497b350fcdf6ce8e93a62f1e421e564c690a925ce7b7aca3d4e4ecc5417b88f806129e0d724e27865c51203a0a5916a96f06622edb1fd2707df3b24184033fc7eec979c830b98e15652d3337f55446112c2c2cb729b723a28b03f8d4ef1ab348ffe38cc81a031e7705edd874d55e8a138f3e6ab7f6905173b3cf915d800af1512c2c80a8c5d9b8f0cc9b9e95dc311d98b687789e0d9e3fce1607921520854ca79dce9144cb623143ecd031363f14e7150be9609c23d0c7d1d2fdefe5ce8c247191e14ed9ad357b9c04cc259d8486ce5a8f2b1731722cb12e8964f502a5c43be3515da7f80de3faef8cdfe3b6889500dbc0fe0a41427afd53414131314458796c848eadffbbfa1726682fe0bc8e4c966dd9c2f9e0ee7a8dd0bbe3f9187f80721858036c7f4b1b382ceab90c270d4082be68c063b7c513662e0cf3c617fe0b55b224d8a4bbbb8ad3a811adeb6e4b4b6ab09ba8f48e944b168ec807f9174a247ad5f05ad2e9143456300e2662a26f3c806364c36abfd397661fba9e2f88f36a269637001958f947892e277f46db288ba2b041c3e301b34775c848eddf26c2d2d86c290ffd85f79ed7b69302553a4f76df48670d1647de44ff98a60ede890807cb21023edce4c02f7e7360c6f33439696f0e07c6af9e2a1fdf6f183e00c4ad75727e71c170f1d16e577714baa88247988bfec26e48ae8a0cfff2677e2c0876e099a26524f8892f12b5df325df6a83f25d18becdadd7669416830bd84950126c19e1273f7b08dc3d0aa64dee19c70c22f597299d2581d10415e2f6f9962d1c65711fff3e0f609c8c8eb78ac7845d7ed336e8677b1819dcea48f474ed56e2d4614ba6f899633b71ae79feaa4c8be60db6f35bd8bb2e0789f83affc44c8819945bec7525f264e16b779db0d588365e51459b6451f90050aaf02de8764ea5eca44facfa87e21fd9d2ee17a1a51093d808829e2caf3dca64ec70873558f9ea3e6f61096cd77a378803673f837483c0d4654e5710cbc34c1b545b07b5c7b5bf7f1982b863d608086ab3ae7f7c06f8e034796387b6a9f4848bd17f5755ae622bff5b2340396701a589ce268b3be7da40bf55091817d8bde20537e9fb98eaad59a600ec9ba7099d27e33e9104e992bcbdf6f5686729c51c9e08b6e58aae927fc33ef4a758f177dc01a6071cee62c74b4eaed3927a6ffb617ef8dcd0172dca789d6a0d86d0f87e982a0e79f4aed6f580a9f3c7e615b28a589c4fb5e08523cea98ce03cf378cdaa0c20c1b7c959ec3c945a37f3edd0071c988ce98ba5f8e15edb64eddb111eaa0e1b819d57d4f9c7f8f6a2f010a7ecb8d4b1ba81173b16df456c1eca90bb72b30610d4df47e283dc9012e856fb92cc87b6789a2966595232b522830056a80d3fc0728837b8e87d95f9fedf8add3110202fcf195795f1eb9228b2be03d00bcf0921dceff8031126f35471cfa28fe754db0b6f1e8fe178f94ae7bfbed34db9ecd8b8c93fe433d298db152c087890eea14a101e738ef372cf5a142448de806512f8b9449c938d1652aff4e1028fe47596dd9b44020d77fd15455ebbe94f26b477c14c802e35526ed8ea4235a3da5bd7cafeffe307bc90c94a33dc6f376888e53f545c3436471b398bd5424c93893095ec9a50efb83d330a309ca2d105681769282548e60ff8606647f5877b59d2ff1b2594912ea4c1dd3ea53f5cf8c5d146b0187abb91735c353f0c620de4f0b08ee4a0a903e6aff2d9a11bb06fad933dec1ec120d24ae1db8f586e414b5448bc43edb8eb9cfbb32bdf259c03c301cf596c9d5bcea15b44ef9cab74ba22eeaf8bb60d9282c31317a43ded5223567ae0f1788783fbc7a58ffbd333d029d33af2b57fe10735995f3927ca7bce221fa14658390d8fdd5b07b37ebc63370e059c8bdeea7fc7ea76e89316935344c07af347aa0a25295b667be7a639ebf9afdf02a8dd90444135f03e269555f0062cbe0034445197629fcef0bfd61b3934755acd8fc0079958a3a1aeb2f379727ea1a86933774ceac6705305e25ab3e53db35cb3e98ab7581cddbee9d20c5929cd5b1f31d6a9c844ffb6eb194596dd1e345fb0e39c766b4924512e30db5a7f1afe017c7a289b5141dd6a62447394b5973522a80fc551418969887a44d5f39bc9354f801ca9a01e58d520889c80e4277074acde3a570ad70e36ea12a37d083fc20ba56b8948907b3f65ff6f2376ddc90466475cdcfcf88084c8fd6de971e91917f9fde7e04599e6f3728a8330fddb582a221a1abb0d0f02acdfa04b7b780d4088f522530db6a5d97afd9552bf12cec00980e3362f4193300492a4d9f860ee2dd6c7f79ffa12426a108a739ef5df792780cc76d2779128bd7558d40f8dd8f0323802e35457ea967efc59c9fb5a0bc8aa08caed9206855bc921e89ce53bb5d6141980125fabfa22e850cb74da0f1f1b5b47cea8b1986a93752a35501d513d25bb3d95627e563d7a54312fa8f7a85687f4a1710499e15d8a8c39b57216dc76b9632534def42cf7047d852fcd9f77a21313fa70cf8017d3b1d751fae4ff7bfd5dbfcc38e6f6ae0ef3a7a62b749646246bd368477471196247846ff72cefe6b87e41a33a27dee58c0eba310c04ae0777159cc065087f98afdb2c4f41e6fa4b026e91fd5a56f619112c382680e0a9b0f90c9788da0118e23896271eea1fc4566df4b6382a958d31009a9f6177abf0bb44e9e34e0396a0cc44b9edb14568c77cd1935026c1df45da579979fc8ccdbeae22d4154ec1379fd59b332771bb1bbbf0c511ec4e66d51455badea56b9d126021920b749ff18e73537cee912b3980db51596079fbd0f80d3469118e4901337b0ac7f925d2d960f42b254660f5ffeba2d0ce77a4ef9e3bece95c2d825bbdc63d9527209f19d450479e43a15436c7ac5f0a3e7afe7877ce91fa65d1fc22a1eeb72a559a10605b043cac1cfb8d242b6f65d4098308c930ae997081f5d88a8e2e5219616368aef69914e6c89a9c12bee89226babe2160c24f53aa10789302786bf299d5d783e7645341aa5944767274dea8019d88a8cf0ca254304b01c6712311b4797e5e9af31d1632f3fba7d7dba10b6ef4450ccdfa0ac143152e5701afcde6a906a755c6219ef02628629f07f3b20435d601022d79c396c71403dc7c9f5dd489dffa8a8a24a90458ef0161bdcc08604aa35f85fb09f2975eccfeb2cad4ec33bd4fa83a6662aea7944a23ec750a6ad28cc227832fc97fe5712a646053c1ad432f3a9fae85e0333f2b9ffab2a7e7ba43794f43a66fd88c07267b64beb268cf02631483e6e17de485f14a9c6d4b2df35b67e229c2359a6933bacbfd0b2e8eaa9a974b16897201081f29cc723f614b08fc5ad90bef4e5ec3c2f1b517e6ad1bab0790b9e1c47f39e7ae5456b0ee0110fa61fff1b4c8fb12d33f1b168d9d4a6ff5265b1da6156f1f9c79ba747db7f6f0eefaabe0a593e9242d84b41b136aaa7891ba167da9f97bbd2dc219bd6c015c947c0eaceef972cbf71811c85e797d264c24122b4e1498c1784d74732b1e42d0cd2f9356fc544b61477d4aa1189c4ffaf65dce182bdfb397ff6ab902e39b1fcf476dc6c1dc13256b225cf3d3d00b09e2331a6240763f3489fd39b474ad268b7f6bcf50db33053e44b92af3d1801a1367377f2f7970806f45219536bccafe7292c3943c688ddaeb65a81cfeadcf4b4e48167712a42b36e39361109e02665dcb16702ff5b31d9b7ec9383eb3d75b85644fb718219bb3c449a1c43049a4ed2d015877282b0aa07758c7ffb03750d684f518a0f177b5be63e058b152bcc0591a503a5ddc33f4cec13825eccacf06fb5cb8e8920ba6595c980a4863091c305558a38adb54ab6f6371320e234d29b202d8dfd4bb392fd180284a7396628c4224100ecf24d0a219dcff59dcaea8e2b3a6be528915422877a8f849e877dd084bb78c57b91db5aae976bdd8d748e1d7a05a0ef890b07efeb31affb8e6ae2cfe32ac737ccc0f7fd5ce6e89b7b1ee86c6e47b20a88a10f6166bb9861066b7fac4d83f22fca996066af4290fe7774590ca440317aadf752f64ba19e0fb5ae3848edd30799635b721bdb9ada007a334430b042a145341488b9c785215ccd4017e59f98be1cbb73308e7ada0308079d1e30f8802e480225072446f515aae9db02af6ed3f9495a81be0da255070b7873707b0f6013697675df4cd3a689d250142f49f13f8c3cbc131cfeb056804a5d10d22277b38ceceee81df32cb0770fc1842ba33bd2a2fa154d4d52b5c10d4d58b941e6e3ac67b4d9b293226c2cc1e63e78be81c5e6aa23e1511e39e4cfa0bff768eabcacc9a95998de464c0166e431fbece9b41aa42038a33a0b4cc10c0151a84592834a4a4589ea51ac7b950b9d091fb4bb48d79ee1c27e831104e5fb696511d51c45f55337e5936485a84a5ee4ca3e72a44ec3fa50fa5c7632bde59dc38b30b32c5960d930bd2cd77ca27bd3f3d3cd1e1329872042bb86c90dbed952f6c72f6472d9d20503d9fd4a1d86a38791fd628e5d3931f7322dc2f92f974755ac19ee3495ddbffa8fae10cf4adab8329ab8b5e2c38120e6b286f1e2ecefbd75ea52abcc2ed43034d1f2ec7430dc9c89f0f9cb89c7d3153c97752344ecc75a30cba34b221c22d03c630b63b7e82bda761b8f6bd07fd5ba45776177fea6a93256556bb79d1cd5058158c8314a40f85efc07df0e5c3a502e1e5713b7b91ba5627c590113a64c3bd01939f168ee18dfed219065a236fb9fef332dfe7a2994c65346e39a76067f8b0e3ab0d1217e46849aa4c353d172c19c211a3d46faf4a82c031dd0a86b515505c70935a4461f844fcea6048b41fce452f70ff7442987fa282700ff53b64c0e5cb4856c34a883eb2086068cc572938f7cf82ca70e68d2018c31f72a34faf2117676f48ba3edc5c5e6241f5ae7782eee57e9fbf91df5f241567248d245937192c2270646856a61fc10e9e7136c7fdf1c7e1143e803368af390a6bfc0f72b00a0146a84c12ca5239ebdc8a07f5e32837b77b8a636f370fdefa5f8a80a187be0566c9aebcb43da7fe8d8207cca477788f4932359e0765ec1b494e0d64250b27b6f81c86eb8b9569da6cf2ccbbf83eb8d05a27b3b16d1392f8f4de0fe1ff5d5d487e27cb5faed5ca69d0a43e627593799c0ccfeec40f48e1364ba5505ae51e5b3c54a6485d01c7fd37eb624b84d7f923f55d3866448bd58419fd19d82f32457c660f0b996210208e271bdafb2e7c3fc24ecc486813657cd11c87392d498d12fca31938d6ef39974322a0ab8fc0f0b5d433a2984992cd016e20a03b4a1f642b5e19e900ae2b73d81ae5072be8299582f51f44ba37ebfde8a97bdf4c81a2b403e4a12a6b545a6b056345cd7e40117363f93e178687ede0358a2fc1c6ea66b4469adaef5d41cfcf5b5c388284f626aa2dce508d9f5bb9e2439c1958ce87321add7ada41f03f31d6dfc4c1f459ad88335e0104c859393c2608617dea0ec418224a315e3d4a20f14cc222948237a4abf4b3c206f3dcd2664a1483e3d0877cb864fdd7a3a47e534ec77ae20d15ff87aeba8471f2c8bb45bd79d3e228a8cbd44eb0648504409d80250b1e9ce206148d85f0643cac1633590eb22b8b63236c14ad10121082a5763bc94b88521ad","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
