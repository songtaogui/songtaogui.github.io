<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"53e4b02dd96e24c0e6a1089918f8297177120e3e084e25b828d2245b7957fed05bd52bd2f950b7c98e6758e668c970de3335d58f939d1378995639baa4823cfe2efdf6a00849180a2660517d0131e815821e8323910b3167b57208abd2b61215a24ef6f003d63358a8e6a986cc6a2371c9e131bf14d2b88b3b94aebc44a9a67051ff912cc3dd666bd73b8dc86276644193c815c54deaabaa2f82aac543a77426dd64b20dcee3e671a1e555bd8367b85ff7c11a7640c13f814ad833c1e2f981b213b3a028d3c2469ad2fb2eaa8b946d61d7c8788d984e9fe0c35c288b694f4d08c3b3296c229d0380582ba7d0f67411b65fe4e138d8a3d41fe4240dcb2fc5723af7748851e1ef4358cff161449d3c68d5fff9a4d959dc77c2bbd5b0ba6bc1f1effcee821df74363f4965df1ec38fc6f0b041ec074fb5ac8b72382ff8d18c257a2c07a4154bb6c9fe7fe685787bea48488b16439548df835553c01e00dcb69a84faf3bb066f0232b076cb46748d3fbf2487731fcc961a84817b8b8f41bbadb40ab75517da326fafc51d8d61d12ea359b88d25923fea903bb058f1d72a6cfd396469ac9c4c7cfee4497323dbb9847b13e544c520b98a4d240b699d2dad433eb9f7bc37e564852a8717ac2fb63526345e7a4ad6f4ca352459c71b01545f8d89eb0ed0afa3dafd67b70ad72e991d155269fc7f35366d5273c5ec096f1e3bf8d5abe0af2925fa8e1b9d3bd2cf501159810e21b82ca344cfb08451a02a4143707bd78435f59ade5afa91adfd41a6aa8a6be783a258e9dbe282cbd9108524c79b5a5ac51b7c7615aaf1c80a607d1034e5b4f887b0533e9e23337b8d2443aea5803cba6f46b3ab8f938b144abb3846c91cb3dd9788aea86889fedc2e22ad664b8f933c74be53788d8f4cb99ff2b1bca8309027f5916d21971c034b0b08cb4cc51291d585eb75991801ff60e2c29ce940bdde0ee618bade674e2e377390612f68628cec19832abd87f0e62ec757f63ed3bf35116f881eea8939da8ac3e527d5db4d6ecbc77f98460d44144ed4fa5fbae504a979e4490ffe889b3ff466756cd9c9025680c89b9d90cfaa48902a38f5e765e83d5c76e6d78048e982ec57c9e95821cbfc73bbf169de43009471c1d87fd69b0a383597b1040ff8cf07176f0ec014874993be5cc3a52dbd12850a2135742976f6404481c11611fab57221e20abbeb26a1c77037a5bc7d11afb483301deea956936f38a3677096d25acaf8fefeaf90c80b12d32cf68fefd624cd415b723ac0828e7ce216cfabb82cfa2872fe45e7bd8982070094e720443534d4d78237380130053b334617ce3819b7eeb78b4bc8983ad773f924ddafce9427bcbbf09acdf98d595af86f4124168c7d4c3aacadc89b41e9ac3fcdcd154115e2aff70cf475ead7818c7ec3564bc323d5eadff45fbcf134aad92c038fbc84c325348643d0128b275dab604cbe2793e65069502f0ee63e0a045cdec868c4c53159b72f254a56efd83501a006209d1df540b07874448e61cdff341498f2426ca00e852faa51033f9525b864536cd33e1e1803511cd59c76ec69921337437c60949101c2535a32ab0e122f8730c55edf2888044a0a70b4d5bf82d7e687dddff18ff406b0a34029cae79813bec419704aa07c3eb8ab193c3a5dceecb3c8f359918be62442bdceb7dc753e4819f451efe7f5c69b8cdfe70ed790b00b3b66d2a3e0ac4f0d1b852ba26f5b9cc89cb77d88b07b0f7d129fa0fd6a8b97961f0e8caf4d925309946a1f7fb2e7d372f5c03fafc16f2bb7af4e5bf78c94af19edbd544853d7075c61cf11fbeadb3f29dd66b6af0d31c638a4b03dae3f6e79a3c40ffeb68c4cdda239f468b93a27591434675c6913f894c7dea85d7e39d8c7bfe46c3b0750084e4f4f5b1a54426ebdbc803b5d65c288f671c0b083181d50fcf89bd0ef22d328244fef05ae4b80b3009ad634f3b776be9ea9086b67e4a738958b01856010d5e43fb38ad5341028a37b225d3debe908764ce9ee1fd0d2e811d4e60a91ea046c7aadea7b2a2b0a1a5aa9954f79a7f13517c4607c74c9dae21da8e46a43fdb1fa5ee37d571d2cf11b553872cfd5962f534259c6517e433b87fad0a4c56e89e8611d5003a5e2305466dfb05c9c885101cd579f7c7dcf45348ebba25ac78d8773c6c81560577929de213792d48295437f29d6e03fb5de59dc8135dc941ffc09b3a65acbbfaa54984869dd4a908057a28c210a7399fd8aec53c47494c4a5250c7cb55d27c81a67cdcb07846b29bcb090f6523ef51a07160506e02e9fd0f35545cfcf2d165b3feda4d342e0926aefab2eb5af97b8ef50b14b9c74a061ca08008482eee54ee28fd7c33db2b8680da25cfd8a3903f1a15a36258ed45e38d0c8668a096ec7f89a7fcfb7b1e6dc043eb6fae11ee0eaadf2940c2c362999aea0ae29e4c07938b134b7da5a6adfb75f572c9b6b25642fe9db1a541524e99b6f01e076998633457aa87b7a9f5865b72291495abd64008b5bd0ce2e53a9a8d646d96239f3e2cd10bce8a8abb6af80ab091a7688247e2789529c427e78ddacf3504cbe874512827c6c47122ab0b51a69d234c211f410ce7f2a586269fcd28ed9d561972b08fcb7be6b4505fc8b4fdb0a10cd0f22fe24ae08d41516772096846677bd8eed372255afdf50efb5d27c5e602ed8f14780326f2328122f22d4360a302b6d122cd033ca509de3e0b812dc870ec465d6826f4b4db10948af30a16d7a7d2fe9671e4c7130601ed9f13ebd60a56dee7f4af51e236e3b44df6424149e81a228b8dbdc03c9b5698eb0d5459ea0a731774a7481dcb205400d10a5ce6238b722be38591b88f4aab78f3ce5510cda05499498cab574ab3eaaa1578a89f7af45cc4940dea278db0487d0b671fb004d36efdf7f9dd8b70c2d902e6856df96bbd48b50b80d7b0128746e522649b679f0d9720911e4ad94d272dcf734cdb35dd2187819a1bc2f692ced3357048aa2f21bf94b4207e360efd13071e8a0ac2a496cb2470e0f8431e45d3e18b3ce18b5773da9147fd74fa8b4f7d2672c21b25c4524e1ff1929bdc68c22a0684500353308044c143366486314577248f5b863e335fd9cb276d704d4d849011f5011f3b85ee991e64653243c6eff37c79f7a1e4cb4a9fd62d3a6803452700a5d4fcc1eef21f650d4aaf90888286e25662b742908ab7a42a84ac35fb1114a096114df00e2490312492aa7badc4c1a17fcc7776cd9aedad018415914ba887f8c117a3613dafb9c414ce8e57a6116d9d6a5c9a07c854ba2ef1f5e379503c9a760c6d88c25cdaf2a8b247616fc42f269ed9c1456b0f090c5a0eb7e5b1940ae396fc4c088f4cbaabc632d00a86e8f6e9a81c89145fe130b87709befdf5c359e0830431803598b68e45eb9b2c5d7d9350f5acd9b92d297c7545fbe44402acaa9eccfdf1e6c61720d3763513bb5094fa01a74a44792875f4fb2a4a0a78d612b0e255c81037c86c33ceb0362d9805aabd02c4f80ace764b63591f29b8e0df0e91dc10d440a357e52c5794476021dc8f4b1d83fd70ff6c5e056ad5e86a7e37d12ae9eaaf573191ed780380a7888d25c728847c7fa6a245c749504137660db4bfb635d6c20af90392e5aacb01ce55bee103a088104e28008df039451c12d577497bca5c5cb81ed43c2e4377bd0d7e6399c26b10812295c40ab4f38758fd323897d08148d6d9f141114f9a7faaa4536f0601c71d868f591239105d052feb804add2076c7a67034086a5b55fbe1f4f874428142a38ea9a52ad0de366430be52ce661b4b870f71469b331ab47ec1975508be341b2e52133fd9a5d064a3e0dcc40cebe468be68da9d7029836c24ed8c379bfdd92e58bcf49ff7ec6ec6e8568140b637da519ed4cbebabde86a5350515942c2f1b32c85c17546c2ee9234eaec2488dcad32e483d9105c10f6347fdd74d8b3d79cdf9c59e2df8f25d5a99e70fa0d744899125ce0283fa10a39e17f5694904bd65c7f7a385789309ae866401cd2ad6022c63dfc0deade6b56797abee8307135d84c564a9cf0eb0b02de25b7b1ee9b7cdb6681698d6461d07091488b46d8fa7015f29544dca2f63ca3e4a237a408c93cc12063f864ed08e4ec265f08e999842744839e4dca0537b669fb8b5c81723af7074a72a3a09cff8cafe057d850258b2210413bcb3f539c801cda4c3aa197d47c62fd64dbbacf4356b9bb6af5ca3419701b4d09f2cef7d71e21f7ac4a3919e49fa02c7068e9fa9d2df6c391e334c5b38e9b98381e8c57b2f8d0febad0c90712d9991eef517a7afb97e87726329b0b6dd273819f01444c1aaba2783c149ff5c125cea38a44987bbd8d513646caf3f775e481a6c92b59fbecbb6800cec20d8ee6d43a982c768665523354ecb459abf4c7a7b0db1f1c82e6d802ba9250a06fd0fcc80a4cc08fcf922047e7204c1a3ceca04e0c131321ef67b54fe86d8de3adacdf3f30eb7a0dc1c9fec1450758045d256bda7e9525339ab9cc703902e2bb78b42578ed3ef1fc6328c6faf5093e4b92482804206cad1d5408bba4e48f60cee768df2bddc0bc88954970ce11f9d48be2e2612ab887a9f0fd43f7275515e3d9d3c4e2af30608e767d68faa4ac2eed68760d8743103f972203645632980946494cfda14727eef013cc1c4ce29515891e16632132d667672ba838bf35cd574640cf9d66533902e1f37f92ba0801ee36d70be75fabe4f4f38a00fcb17064da440794d3a5996f38e3274b19df8b622e0d9ca6fd5b2ab7263c38c56ae75896d9ef1fc70cd08fdaf5671c063a3fcb77d283de24fd0ac39011c202a48ebf039a8e9a9fa40ccba56e8dd5668d93f2d2002e804f1bedab7046830b356f03ebace763643418b97f0c6f4b2e518ad55ff5ecae315a9eaf450ca5bc5216b745b542a07a4e7cd2b7f73ad9696553cae60ae7c45268b253a0b65e334cfa91def65ddb6ff71e1435503a843068bfff4a88e107101a5c474d624d1e88ed517472a072152f3a8a5577f8886253c615d0fa9c21fcebf4d85e6bf9c83ac34434bad04d26c3782b8c32731a175ae042a04cd4685afda35b3e7cf5ac07fb9dbe8f0e32acf6185fbe2f63ce7000dc2067a466a47061baf159aeb128549ab00af3b3f9ff9e294e28a861fa493d08f7ceaba08b2bc202849a0bf517c70d53c57ce1cdc779ec51ad29396a1e682155142570ddad1a3fb4aca13c4e78536f474aeedc394b51f190c81f543f886d067308cc4fe884e298d467569c9a3f356f73c77ac25a18f809d383d958582f792001868eeb44c1bf680972d15d363fe0bc4654e13806bcf4f09ac1e14ff450dff85afa91e156c107eedf88bade0ca9ab6cbfbd8b0a4018673cd9dcc7ebaa036c842b7172cd88572a0aad8e8a36567d927c9e6651e93b7c168f63e977f8b62bf6932e08e215503211514437609da2a1ad11caf7d712c39658eac72870a9ba4661b7b8eafa98da61ff4253d0f0f0926099aa16df125c97683863d3f3b543f2d38f4ce5b7dfa5ef1298fdca120fc3a8d0eed1c0997cc95fd7eee0b0bdd5c4c19a1de423921e32fe24a0752099a793d465b16da1a232a0b4038666d5ed7b0047b4ceec7ce6dc7d85c4eb5e6a111ed053f7217e4d59292622b76d178a7a0e6131ccbc9b881ae9f4771b534507821cce1b904f0e9814df640646451aa7a392e52a9d926c52456dcd189705349e0e68e5517e48bb91a409a583c1b5d5854e40f8f82b3d94382292108f2e8a35bc8d207d38fe6c5e941ffd4d27da02b0fa2a47a682d9162f02b3adf659b50e50253471055f74217a717063a5ab77daa2a70113d0cab4ea9d0ffaee7009ebe4606595f03de8ece27de29f584234b10ad63a7dfcf281925936a4df4afbab4fe8f741dbf86209cc0185d426e1d2f59f5ad2f53c9c021d2a7dba1e412a8597494caac4e6830aa6b58db400da08fa180e362682f015b720bab9c2ea801a4d9d2c7a57f0f02715af120fd912c6073d3ea1939ec5a48a9b836681551d012ed437ad64c0931aebb5ef5ce050bd928a1bc7b697fb9b8a001ded662c2bbc47279d6ac253880a37a25c06bb213205831fe6aadecba3e87acc05c2ff8038ae2801a1118839d1c50ba3d2124f91c8a12549115dc91f5836663b85930a1c141205bcf0f1a6c7d2f61c50789a72197ca83d455bd10165f86a2553e44529b0dd4b260a3a8903066dbaca48372906328b55e981d6e91b8213a214282254f8f592abc77dc24f155b8dc5b0b86089278f4e07f649dbe90b02c5793c98d30b9ee1a63b5aebcd97959a8289ebff9d02a64754edda1250bb3cbaf3b1912d28ba637bf39631801611a096f699a5ea49955ece26d92f592de3c5e17bf10e8d19cb0e77a3ae7c7c45645244a6421c38e47643d9383b4e555af35edc36696ea8516f57273fdc4d21dabb3a28e8829060211a61e4e391f088b230954e4fc453c29a887df095381404a17c46e519806c0ec16548f0d3b6b029123183e09f63b70f6c529d7624d492f108d231c2cd9f495bd8bef0c0354aa3ec9a180d17977997622faab49683507771fc4a505455f7b0c8b1b272d088ec8d7f0db72938250c36c417bdf64c5da538c4ece031a8c4a07edd18b3fb90b4d93de4d3256cfec2645f380af709fe07d6bdd876172bea7b0e50ffeba69f8ce8671672bed7d4445d686999b92c7145a80f6a46d8236cd710dd2692e84d95bcdd4071d41a0265b7f908813d29a0ab34c77e85e0f4218c9cf7dfa66b913dc10d9936a7db21d0a96e0b42616a44f3588ef3fde6589f3772e61d7d4476def79ae3040f9a6f8f22fff9b1c36711bfd58b4a4263222f2ba7100c0b338502329022a6e7c4e4d53912f34b0ed0bae399cb9f93539d363971ff7b4cecf3a03b9024e79b1183db8aad1bfae5ab96d64beb89a978f265683f1155961baa6eab29126939bc8b0ac8e3f2d6b8700de21940ea8d74fe7508ad474ea061f3e730105f4c5b570ea0c36247484cb5147f917fc0c535d5b07bd2b7d6ff30f621f501fc09432130af9fa0c5226cf60ec0dd752637c9c03e233ed73deaa454271a1f844c53e234dae8e28448e23da60879b6365a2046e9defc36ccf02665b2c0b40d1bec99c208ad42ea97ab15bb21a7535874c5d184c2e2496b977f9eee63225ca03936ac16a7d01a314978777d9c9aedf183e307308b9d9e4861a7babeeca618a26edb66898fa8a61f7c16d10636cecd2dd5a97455c9548d3a1b15240c723d7a767060145aedd847739dbeaab3133d8d196479bff6c70e44392171d06b65644cd4e7872c7832980ba507aec5221fa9e4eb132e7d59e5fbd16b5cecb17e125e1fa35568ba13062efdfc68e2a3623445f23cfd3f3702c40176ab2b1eca7f6131aee3ec9588fbf20595be1ee6d8dced350e912b4adcfe987555bea48813c1ef344cde337440b930b0001e506d20895f405fb70bba48f30b832cc0c36aa9275b089d7f8b3ae33d299db81311e794a26858b402d2e786d848f51fa8492531d191fb00d82b78909a4c31566887d2c24a79a01670b2b49a60185f7755d7a6b341ff36ec7c090540bcc2a772234f401eb07ecd82be051e95e9c1010424798119d4e4512340e60c696d8d2f401238f0ec57b77f59f4f5b14d2d5dcb34abb81c6a86ea6120424789f216a76325eb567c4aaf9cad121338e17e72d76346c2b92325736324228414b5862975c0a662415129fe537afd2d7bf88b1c1641843c39dd1dd87c164a63abdf3c011bddde76307d61f0bf2dffa9006c43e77ca36973d481286b00a660f275d5c986d3f388ca90a155284b24a870d19acc638511de3a0025a0c6e082ebaf190296c3915b27c66eb122b13ba73e85dbc5e27a08d553c51e45823fcb840bf5729ac2de351bb98898ae066f6b362f4f16fc45b56c29ce820b57e059d82a650f99f13c320d09d33bc63c513f98adcee99a5ff1332f7791afeb0dcbce8ab763628f5e58ee2ed1f4a12c2b3474f8ea525e746567dea461adde3aa9a60bc91e6927d29caeec6b5ccb26c708052adebedf7d56b021e08ccfa01fcf9b8c2816848011b51b0ceac05ff88aa7dc8377147c8f445a647602f9c84808728152c1cd36c29232713283775052ea6b054284fec9d15bf747bd79544bcaffb36622be5760c9a82026100fc3dee0f42d9d4492479f22896ac1dd3bed998919d4bd70f98d1eaa0451978616a9cd0b1aa736179fa9f257749597b8bb4da4f35efb8f5763b0b30db85c21f7db4a78e8bc94723999e190ef50030ecf83d994b9dc3b0ef6c25a395348ead9aa2678f199b172e08f04033a9248727762483849f5e0acac44312ec7c8dc020ca8483a578d14fee79a960d1cdd44a8af8fbb97102edfda256a58c8d6cffca0ecaac0153df4aadc2fb047aa03e9eabdf8f22992bc5a2a639253031771f777bb90f3292c700201dfaa1d627e1a2d55330472769dd96bd34832d4d0dddcf89accccbf46b39cdff53294f7b7b5064cd2b1aa2069d505c44e6f7c2dc07b4d88d82e703782c979ca376d6aa62398797cc35b6ed257d034ee79bba0ba98568dc88c21547861da2015605b623ecca0f85ca6ac5212c485c12c6108e52e6340f8c6c08cf9522f037d1e5b9328cbc364b3f27b4aecc18a5d155a6c04949bd42d2d7ed2b04d01f355159302ebcbff2e78bf3889145fca3a492f9c0ed8027064d33a8ee4dda966dc5a1681622fef009858ae065a619b6a5219523a4687f56837d7fba64b248c445af1431ab31a3cdeb7db32c5d4ddd3f9057b735975f0b9ffdfc1dfb9434ac0afd824b1edb542cdaad4ea18b2482810c571ecb9e45fb0f03051a8c9cd0a0cc7a2df2183f2e3616ad1c638748520a93bc92e369cf967bdf292d7db401edc8349d46f599b21b58ce16831a79d903477d76c7ca000f71214f013bca67b07519cbeeabbf49d746b545ac0045f748744d7a88b84d4dfd32417f215c10b4fc9918b027dbc82472d242e091fdf2482d413842348497fbbb3f392d33501c8740c32fb5e4fe60f27283be58ab852dfe28541eae07851f2d374645ccf22963763e8163799b228b224b515762beeacd3ea5991d3202775a08254af8f1aa8d71f39727f662440e68418592a6ce290f4b8d610ec96f092b2c49869545856d9914ef2b48e9dae5c3c285a417f8240e74c1ffff40da5d0678107a1effc195d513ca813b25dafc14af587f172d068f2f102f01e12bb4ba4ad523ec296cab476ba47e241ae5f8d584c1e32d65abf7e8aa333b7c0f8739958510a25145bc7feb4f50e5410b3a2dd7f9bf7b6edc73cc47a21b016279a453c5a1ec0b69c42ec4695a72e826e3b884cc1f72a17dd407db3d9e881bbfd0f9bd7c8b5d18c47bbb0fc7e724b290367d701a69e27b413adbe10ddb83f64cef4f6c8bd70796f91d307fe833f2771055fee00ff6256982b4c03b65a1abde801fd90d55ec775d48bce76252cc86632ab3ea5acf131b7cf82f3b476fd697cdb8da0ccccce75a0462d8329e6c9b740b08d099f5af7fca0f055cdb9590065764dcc19340a2a78d9120f2b222ec83472419b71a0c85a79759ef8118d9c75986044a194b24d22e9e34c4713e3e1d91ca9e62c332ade83630bdf709b2aff034ea73968166ede392071c86981ef62aa75d3ef0798853e9d9cdf92f6753e1fe93f01f82204d9025b34a2a3e33ec5ada3d802260fb70cff46c8f11fa7bcfbbda1d543498946ca0fa129ce89f3adea0bd74517a3d13d68a2e89ef88a7125b3b0a1c6e169f85851af65b853676b3abd32e92602e6979d9a91afd62ac690f95e976350c66b5758670ddc574d287faeaf04700bba371e55cc97b7819a8a2d825501d0dd18e388fab1c493a76aaf95fd00c00d617b4136b7cb9b3d10e5353006605b9f938e3773209cccfabd429e5da68f70b108a0105a19aac230c296c4c606ef10f1c68333492a0ea86ca5ea7a05399edd38c89461108dde8d44473d165d4fff9c4493b6e1f99888d5208fdce483c2aaeec9d0c50a8ce60faf9095f02ae7a6274e0087a385ef61b9cf92cc38cbe18080a89fa3039d6797005487c06ead076a948aa703cc5b1e9e48a093242fbce9505e204f242dcc2508feb22c6f1c8c7a75bcb04c3895ad32bbe11908f4355a8ec44841d0674da420368ab52df2419ef81db561706cd7e0945917d6a28bafdf5426621f3374ad8ff2b279c7a78585e2013dbb2fbfd6d5c1841aa9f3294568facf291a64bc0c051a81c124901afed0dfdd4af475eb5161e0a7b56a7f3685375d1dda3d88de6d08fcdd4d79033c438ed8f57ee36d50b2df5e249d19c8fea4ae3da30bc1eb429b00f1d8eda8bc6224616b5c4898b3c19f7c3795622c651cc79a3333aa289ca22459f33d4d7761e8b046c5af8577e82dbeeab6a0b5acfb662d4abbabf9dfbe78907b5604c1fbbccc3a4927920a89728b4fc73fe4c47b54f3f2b59f78b4bbe305c35ad01b8c2792308bed654f744f343ea5fb1177e0993f518a2debe4ba629130d5a21d22b97057e5218e12081b256c856637df7f3b525aa6ce4fd78718d592909be26983003869323d8993b98398cd0411a27a3f5da19400ab4870452e115a81ae93775e50e5b3a8bdd179291cb3052fa91a4b088fab7298760e747a53a6bbc1cdc3b7c2679f48ecef4c27ad0e8d9a88337fb94cfdcc3328e8367f6b118429f10423dc3716f8a55dc846cb93236d184410b26b1def8f41f86dc6a580319005f96e916f39b682a46c2e1faba0f4db1996679ed5ba485f6675c25860afa7ae9799d6bfb2d0be29b0f8e5937ea404c3d62586d6511f60c4fe4095163c4983cdfcdc91e6fa230dc4030fcab2e04a61d6ad0660111f097ad8d9bcb769a44d1a503d8642b8a1d9d63cd2e02ea9a11db182bbb12b2ff8bc8c81c4dc34462f921bd3c919923918505c3245941733eb64bb7aefde908fea04dca5272980282bab47607324e4509f390366561197378f3c7364a9e879d6a9afbec366644c29ee43901251f4a2d94b10df84297aa5fbb25c4faa96bfdb8550ec9df79cc61e44331b46002d1c5434d8d40fabf5e55ea8b94340a96c315648948f46a56b61321518dca1fb92b29d40d9e30b94bc6f74da64fbc2c7e594ceee13ff86370c306db2c5cccd420cd671eb2dd9670f33c5983477dd160554378e9d3c99d4ed17801e5cf52aa8a88e71b8188f150b2c2d1d74b09b08fcf5dc0b75f4007742fd9bf5133897f0fba962a6bb194fb17c9f25bd082f229e77db29e222d520d0b32244dcce1cc8fc8311203f4e7a3452130dfe67631d2384214842d24b738da3025ef537d974131b5334c49531525d36f9eb6735b46c3ea592333bcfe1ac9102e0eb6c9e69b4abb75c353df165115eae2cc72cb248f3780fb8ea9cb90b46cc17d2543add5e70b91b2de4ef8a761b8a89daf5db78677b641ad6a085b83cf5fbff990286f8b94a6d5ff01af733b4d44217a18e8621eeafd9d5db68785f15e3d8eb47ced8b89287f5e55967973d2efc228dd4cd835b1723519670b1f235c72052e03b7bd53b5722e8de07b6a2460065e2125f43966226bc609686b0ce6486c59bcc58a66c0276bc7813f4981040822576275182523192cb322dfdee4b80125a70143fd35c146ad5cd8f10e550a5718e538d58d9e26f9c0e4bf8f61634d360df71e69b13f5ecfbe414bee57c24dc3d158fedd20cd62f81084369e7513906b3b7fa88edd5ac5e6e9f2102a7abb0850b131c9a1b60920b76a9a086d226d40badde0e0ae9a9a96643e9eebfcf20f46146abd12c6aee87a120d21bedb6549d84c31a2de7617145d7074db7a29ce24c21bc541984f25857d9c60e2d60004832a356ca16a6c6bd2446531cb3374aa4e896fe190e2856b2ae21343a52b69b1630ebedfb87e2a244b53e133d84b0931218b6fe85338bb5de84c08fcab4a468a39870f2a10118b6fa814779402e3413bfb57c45b645b97b7ac533d9027aa41d4f68bae24d0d63deab99180469f3a78c681a315075256fae7bea56bcde9b41d41ca5902073637f4f171c3427526baf212ace4805ad8a47c6cb5c2510fb884c820101f282bc1332bf66dc5843ab385d62b21466776ea21be642f042f26d52d3e34e39662a54b42e6f24809047d268d523a8ef58b8390475d12112743c411f21a64a1d07038e4e0a51c0a5f412c4661705c6dba8e30c3271011d533af790725745788ee14025987c43e609fc3aecb46248de48f6413d5fd6eea93034fb1babfa70e845f54a46ee8e0d849f237042a4e30b9fd77f6015f570d51e69a90d529ebfe510f162665006da8e3ca0c27115d37fa7a8d90d6ceaf537b852cc346dcae9507076fef9137df09035725bb196569da15beb1fdae8e0d8e6fde2abdaa0f43c5b9f779f1e350f68442f899fdd0da1450a7974e73f24320ce323ccdf589146d133055e77f085d4497c420518d7a719332d34339604ff9508edce7197b6ec8fcad4a1b600ce9f642ffd21554d7d290c299ae3cbdbb65b7b66085684a8bb4ab9630e1bdfa8ccb6e7649045b76e27f55d447fe2b4e76e7baf1b7f6fee4b8c32e170dbc692a6e4d5d2580f05980eab27573222f443aa5499a25594b02346825ac57982f97ed1a2295075482d31b3160b0e82cfd249931dc14c163f01766c77a6aabba2bc6cd6a7ffea0a0e08d4bf265507ac5713382dfae35849effeaa25ba885e8ed34bc0f25923ef67e43f68464a59d37993fea450f707cd589f6f4222cc6ddf97b74fac93e0ab5a31aa3a477faad7f094972b46cd8c4bdb8e26d9153ac1b665451dfcf6ba2f222b08e0f24b0f9f398820dd783a6462f7626116cdd09a91004607fcd388dcd8d5753258dbc0424361c79820bb8c2489a91a36fda33dc267bc8130114d4f1c054b511b5f76ae7251dae2ec78f00e1880ee31c9d9091250f8fb588e25606b865ec8fcd25f79b8245e4d907a3f7cf07e77b6f19088b387855f77c48b555c86e9b6e5569a5eb292da1a0514a6f0fddd550f59391c726752e0be97420d865927b561268a91c0704498958e1abd01b508e6eeeab46998ead02f9392984e0ed581183131ec71614852472aa954d00385eb0d2f8d6e0131fc0b35acc6f588aaa97782435f4978764ad792cf18416ab55acabb60cb91b9608e1256d38325f77934004ed8bab20f532a8a74678c236ab6fed9326b56c2a5c808d41fa631d47b681116d176a7014f1cd92d29c096d6b046b5033b4de3dccf3332821c78d80f15ca929950a40e51a3bf5186fa11a7bd69566b7b973fbfe7b93894140d74addae9134cb211aeda2e1f99acbfc7ed35222abc149e0f72dc42c5780ebe1ba169e34ac5b59b712bcbb983da6c86feb92a7613969880046b4a31c21f425e78c8bc40e79e4add006b89769b2ba6b33182690da12ddeb177132e9a142bcdd9dd40a1eae91edc3aaa41661ab0ceec6bb921f171871b36f9a17875b6da0cbabe92f028279dd9844304cd7eabc0a280bfdfd6ab5091430857e255c6d5804a810cd7e05ff30cc88b2cbe999286f8199bab611b6c0624bf999a4a49da52a61462d4e3de363950322043f01dfa8c34122a9e5d7b8f6be011d63d843eff22754882fa34aa36a17519d8a62251faa360d593929de386b8193c9790aa032971132f6ccd4e71c5aafe82c0224f0f794f19534e2187b64b1975efbe84ff4e504098febca56f3e34cfde5fd437b16ff6fa0bfe0484f96d1f1e71e202a57e8cdeb396f5e9f07a50e0190a4f65c922bf471e1de9146fe8e688cb4bd40ea8062e1a19c50769aa6ef7130aae9d44b71938cf982f5e3599d77109e2ca36da13026d3e031cfa6a95338bd907ffc79ecceea91695b393bc7fb8e0b4388fcc9bd113a5c31c0ba3453176d6152eb82dd49f76d03969a7ff3b7868dfc33af06b7be2fcfc9f0f69a671378994de17355205d168014c6de8300e8cb288c22c662e075fa498415b4461a2b6caeaaa7eaec89530fdd97c1ed7e0bc8676ddc906ebd27790f70a3c6204b7e483548f51153abc7b67dcfde8f035f2457dbe3cf4b6219b5d2c4ddc3930229877a814f898a60aee909d8ba2104c80ec701f78d97ebb92fe33d06f10ab65e479a7e7cc8b7856a44e4ad37a00a889b5a03c652ae54db4590b6d9d30a34e29d5609c46f112a1777a04a511011335fe0f441618d3852e9e1990a8a425fb835a755f950109f204cfc2031d26c544743ac04c306ef4e335e60dec4e723249af8d299d23b65a61cbf883dec77356fd32e4b633aa81549795eb2d9cecd975add34058bbb8f58a0b46046e6896c34d8e7bfb433c2ba6229144b823e85aad8e2a7693df8863384f0ce5d58aa8e961e7f60b51ac742bf5c96cdef219f8b04bfbe33e02621fac374ffd4f30ab221af6cf392399916ffda087379c52f3dbb62f4d4a02d59385283e12031e756c541ce40b68063c9781d97518d2612eaf7013e106d2b41edef23aca8c24218247e6acee8696d5eb3b560c94521501d5e3826875a4ab33e51527a8d984e1af55e790392efc1300dfb9f7da44ce20e2bfeb97cf67c107871dbecc11018706752254d63ec9604f5487031f02a32cb98f0cde499a6d559387adb3e1842b7fefad7e0978de115f57f4fc040be1f905b09cc9859bfaf6c8502b79d9a382d6c69650c116d5f5336921211d9266deedf4af6bcc7fad706a2715a8ce529da3fab52216431b6ff20ee1a7e8feb5de8386bde07ad3d1988958a8cae4e254a62a582e9528a09f62d622553ecf7c464203462dfeb6d82c121fbeed06b95c005e3010316dd0bf357709802617d7d01351c0b2edaa20cc7919c1bfde5550ee17fb83253cd63326c1faec5a61986647d90e81c941f7e8cbe019d5b00fcdb61843fb01c09cb45c454c5ae5d2257647f3157a905dde1b76a4379bbecd2ed21784129edb9055461d58b0e2eb380943af33b9dfd8a3a82c3a5e2619e9e3cfe477d49102fd5c364f2b1598abfc0ec02c9b861a41572618f2a5acd3f49ac24eeb82d37cd95bb3f801796210b5983d672c7e21c79b302d59cbd8896531313357f33f7c19323434a9dfca92481067da52b1d7920f9ed9052f0c1f7e17a84e762ef6183fb1c9f0480181987764f8f2ce9ae47d7866f66d35f4abeebc1f349f20b408d1baa1a7694b36484447020b8215bf32d7e40f8fd833613de060ca4f4d36f49fe2be638ae66bbcf09cfd563e1459d16f3008ce3f47e6cdd60dc8d8b074e8a37169f9ee46b462a5f23aefd0f6f68c29917531fe4c2ffd1851903f7a825718584df40869cc8ded046a4ebf2ced2927d2458b50af69cb247c14323bff9dae2ca6fd7536cd917e0d2bcde32aa1fc09b3cf18659b040f8df5031b0ba9d4a65545a09c4e35355b016256c848f691c17ab9dadc45671dc1ca4551a5cbbf5fa38b73ee27313cb9e9bd67c8751c341d20f46d5841858d2310d70b7ac0ebe5f44f1f20109bac885eb95d284af451805159d97ca22486e8de5358f809d6dc73d08d316f893c5f6a4984f863fe8c93158baa6f9c599ef2ba55988425b8bf258e3f6cb310427ae8f2bb3f86756d95fed183cec2950efe47556152bf5a7bf56783d4b4100570dd3778ab39f000cfe88849938e235571d169cd7ca7ae59db5bc71aecab37ee4fc032b175e3b7012df8b7849c1d6c1f28d45c61a6b2f0ad59915cdf4e88880041b46e09011a041060185e1c4c93ee4e8f9a35c2c6c6110c383261fd40f64ad8ef078364564a7ea6061bd6b804b47b438f16fb658e2a141e342c178088c2b118676ef8559559ea1e1c3d9632bc99c77f4d733eb8d8ea7f536bc86d37705742ecca18cdd7c14dcde27919646f48c0d147d0ce84a099da7250e8e33b0559f2d412c62cd0eb00bbb5899fb608dacb7cbf6626929b06fa7b2798b96f629aeac2c86eaa7d208c924306ef9bed33d8c5740f6e4ec403e51ee31dc6e60408b77a70d1e5bdb507150bce9a9501e8aa9522585a5638f12167f04cc6adeb6a0dbd6ea15fcbcaaf5e73199cc86d041ab157e4954e9928cad1ae4651afd46a607888670e4e4f1f0c90e2edc59c37c1a4e6b4381812e8e6124820e759a0d8619a45564342b4460ae688631bf45512a5fb188fa5940f84507abefae5f012e6d1cfbdc9be4144bf733bb5b20de7daba3def1169087325207c8dba9c55dba5c73b342300943d622f2e56f3b541fef076d2adefc2c9d5bc8a67209882b03ff1db8b058299e062847ddb999b0e0f9198e46179030968b3e3b8e6485fda28f1961a484e7e8fc550d6825956145184db0ac3ef76089b6009eb2db60973a14caf4e3f8412b6dd2c69927ad984411260a45ddb42c049cd438788c29807fb1fad4cee0a1b6cc9691665993d92456d5bcedfadce4955b0e317a5c968652c01c9f86bc358f09619213230405c55ded0fabb635696169aca6fe39fc0ccd0923f218fd9a5319dce875c346d27cdc0a26de36e967257fc6f3cc7660ed56e319acf8ee56dc6ea58e0451c765d0cc055109912ecc89d22bcae3fe052bb36e8e6a22538bfdf6023bf62d19c457db8496386625da2ea12aeef1d22628dde5a25fcedd287fc5e6038a7b032b4b93e7b3bc6404d9a8bad5bfa11c01a1aaa9b2a33b6ec408bd35c5be428f0a3d399dd55af89233d35709e44e0d15e312b8f8a616d5bf0425fa4d9ed3d00e0759ae06c278dd45ef65ec2c3a7d24effb4b16ba5fae7ab8ca019a5610f9477c50382bdd7fbf35b83ebfdef635565b2231de7088331c1fa3a7eb0c1fec0481f46bf1654eacaf2f7b6df17620858ea7e64b20fe18fd6e07551d0b218a29a947894c92e1f7c88d13707d917f544b29027d93096af87c0db17a7dd1e8ba1930d28a538792a5c4a37a4347e7f2c008e63c98c87af4b0b458e241ef3ddccb9f533cfde9ce54df50eee63cb25736918316c4289cb04ddc6d85e9e4dfd491c82de9351d41088542680f65874692c6a47fcbac39eeb593a3ec1c36a8702c632494c5b14d3477deb5fd937bfc6ba673ade5e6085a62cad4cda3da7f1405fe1221bead50abb83bbebf4382385b42e4c435eb20d0aca1358a8e5bc529e6456351bac97ddf21c851a76ecd949c62d1ac02b8e484c7e9fa3a750b0a0e206a36f1b2fdd89f3bf5af3cc0dd9a0e1d4527135abe461a99d2789604b6487e3b29dc629a88a5d901da580a3f7545503a3701392cfcdfad5f122cbe86ec0417f6126feb6995acc524207a90dd5863855ce05be1b5b97e48a6b78134cdee0d8609d0a9b11b2afba49f73b5857e425ffd13164ecc04109a88c9cc7cbabdd095161fdd6cfbf8b3950419cb807a3b462ebad11dcde2388e2357c0b58b873a4d02cd3e60d773a2c08ed344468eca5ec7803c6959f936e08e61667535ae96dbddc944ba2fbeee261e4278219df8bf77d13145c5151874b0c706143d60e2a45d68234f849bdf99528abc15e7b7847563660f8277cc90d9408433b3331f611b0c1569536879d6eb0bf5c2c62ea74d6d07839e66316697e23d38bc49764cd7b3194fd9cef8c281ff29b3ee84aaaac9d9742fbb6d4afc949f6ce455a60c209822a6e12c7325a03db5026f1d7365921bff1c6c69cb45ab6d739c3f2b02bf744f190dccbff3713bb2fb259a6e349eb761e905330162d9fbc909f2138368a56f8d4485c024c19f85092c95ebef679e546a6e24d88328538c346fa4adc2d7657b5f46049a23643c2f1424c03b53b75dfb421ae0d1141cb68a24e62f881696b496aad7428e446944049581fa4c70e0098eb14e3520083c725bda62ab5fbf549db900bf2ff0f453c4bc41077a9ceffe7b227c73669bd098501a6cf25616ab2dfcac575fa22bca9aafca5e4705839ab9d7e4e75e2b9d4f53bdfcf079f0195c627d7e2ceddca3c2cbc4f98f72b01626c834446a57be38cd4e8afe9ad63d3d9ec8766a7aa8b49999ed40983cf88d6ca75092e8fa71c9baec5283fe4e59a234db0a3637e7a49cc23b11e714fb13aa","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
