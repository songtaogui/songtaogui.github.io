<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d2237ef6eba28916d6a3fbf4be3ab2a789c9945c7fd6b1b67ad2529977551b8b1ca24c8001e2c0ac5c4fae4d59d3d36fdc6704e90c9c2516a023fdade38249f8932a0f58f4b7e02903e5d4d1ca990ac7321f4c73b3a9d5aa9b979ce243fb41d9868657f79ba3d4e5cadb6db09d7af1ac78c7196c1626a624d9fd43dcd5035529f4f36678ef678b6573786a797857303c44c34b0aed643937b92e4f710ea56686c53afc0646b0f6c84eb66b631b34ab0ba77db0984e72adeb8c058949c646b66ce5cf7d100b78c8df2677ba3a966bfd3ab9be5d6a6dc50394dd91d6adf4a2327b3a0608adbca15ac84022bd32fd7ae47f767a3d92067dbdc6b866554f8cd7ce1e57c9620d48645ffaf21ce3d9a75838bd362a375fc347aae0d714a56b3ec5c0f650ea786591eeb739a275c6b55bbc6dff1d8c41b1c10018495e23a558e45102759e1feca41d670b61d43fc7763d9cdc7b6c7e747575184bb30a15cb12e21ea37f126623ef236d6a41a7ca920af208bc240c9ec1314a909d9b970ceb03b166b2583a9942cbfcfe282ceb2b467f984cc17bd0e5b96d26ec29d50b18965334db6775abde0ee82f35737d2f63a2889ed6247f1eb5fcd3bc56af14405f9bab2a967085df96e5afdafac3a50b316f52e21abfe562e4836f3dda5a14d3758f16545f1289390d06b408b4d8339bcf947a2b805c354772b2f18c839cebbeff25aff7a3582d2754c21aad5243a5a25613c7b3c8977aba52ba20fdb41816e29ed858d20d3a9d5fc59bdb843b1238804a8ad0f8f174718a85c521632edc88277a99f2471d1bbb2b945df18e8f41cb10977c9609d25b082b0d66efb80dbf51bdceea2bcd6a83dd741b7632ec3b47343ae8fbd3dc7ab5b9ec72e8877ce9566412e77de7b7973c61ee906176e2b3dfe38b4a90741ee26506db530d8736e8462b566a5ab8a3036391a5aedc1be7ce2e4fd697777de34b7cdd77a13aa566150e63216f240ac51c574bbc3c62a50c36f66cd38f9157a10119abc9901cf18a512491eef7272e0254a75efff6e54836027aec45516ee20d9642824144153329651b417712093a10a5f5c677bf2d4dd17d022fb168bb23607577016573e26fafeb032805eeb4edb3a1ec6cdaa5e91af062692c21ab10bacc360da508fce1128f8f0880c5b429afdf3e015be3e6aa9cc14860b14ba10242a799677d73535884533785e45c0621f83884f68c58ea88cff0725ae3d5df72a59c39a3e79ee69a5ee0455e537903c7d6aad5fe7efb3fee442620f6d93a2b5aa23b867e45e5444a4de7a5351b689c0f942ca4862ed39a84ce265910de0932c8d2411e5475782fe4a5fc940293e39a41f19b48adcae6fdd942b69a74be6d7173ea8e1f13dcea5dac657393534272b4a330afa215e2893f03bf0264807db25823dc7fd686c330874f96f4fa31c50a990ebce55265d04edee3dddcb68f4b5fe5445bbf068a684a6183b1da5c63520319547474f3943f71639af39d74fffff2d9ef21ed25816cc886364f5ce00b33adb6dc1f3a9e4e3ff5bcd5ac2dc011f2467ab41fa0ba253a8914accd090ab932c251ef68fa576a7ac8340a145b2449e1b71cae46d7e9cc1667d2685c8ae5a0eeb0a5c0c0184cbb2212dae87483ebcf35282824f739f5448fb34a850eb6430de72f1f7a8783c649f4c4fef45e684f26a36c2b9009ef04363af568a6b7aeecec05bdc10fae7602403c65cb48fab4d297e199ffdb3d4e4e130ed6361c047c4e5ac87f40882233c5d38ad11b42a0514ce30441cee0abe198566f45b29cba9b43bb21a5791d0b0c25aaf72758089ebe778a100d20f6db9320770d1f87be452c3fba822bd1081ccd565abb1385bdff8a25a26287c892d97b125c4b40b587ccbaffcf6cfc78f9a78d357e078a2f8d51eb9bceb6320fa17083e686ec93a657243e2ffeb8526cfab39bdbcb8c8d86fc7ea0779d2d49d8c4998c3d4b517c02ee6bca82d936157aca521aa2e030f32a0a5cea0cf0525918081f9633f47e106e3befe484e83ea726523558497756e802fcc4103302c46d634406a621c9b6a31e6d86ad079f0b9fe80b806a4fcb9e5259337e30109add7df11edceeddc1ebd97b7fb38763cfb5a0894b79d2097a90f24d59b1af1bfa57580fc408725c2a986e941e251fe41e7a456b3efcaeada9acdadcc45335c66f5997e15a8bc90b083262fa3230f467bf676a42af3651589b317faa44710c6488d00022a701964a9d615b5e69260a15ddc03329338cf19693300aed104158069500777686d1af74a9afc48c7abd663d573e288e57ea87ac1cb9c29f372a9033813aa1d7be4cd4466576c9b70587962de2c41570a147abc8c27c4913f60cb4df7acb3ac00b7f76aba5c0be1fac99de9a6a0ceaf37c2e1dd1241a82da6244ac189a7158657c04689350d5a078e397eaf7a6826a77ed706dbcb726408653c13ff106a39ad31d3ff5ebcf0c280b22052fb7fe5cdc044550a9cfa88acfab2ba05b5095cf11def9f0bef4da1eacd44eb8299e93554466c076846db5515753641d343a4e498073480e4e6e3e3aa64e8551cd180cc6b20a78e4596b25cc5992ebfee1ed765e97de48b3080f40fc98c833a20068d2e3c966325789fc67bde869ae6dccb1b11abda390913466e42bbfa1b777ed819e2c1da8e84ea227a2441923af4767c53f307c5e2f5f449d7f56ad17b373fe7d9659b39c7218fb7d94ce6f0bd12ace74273f2d79a351b7b30030548d658c6a57d89f496976be65f09c870a4e69471adb5fa80516782b2f6ae78455210bfda74e1fa26ce861698850cfe011060493f942518fdf46c7d6315d298f6081d1193b16141f81c1092f9ab89a7c646583326a422586ebe7303c956ace0790ce63bd5b1ba62f45f800b3346bf0a610e9bc1279840c2f5c1beabd4c22cb13066a7b76cf4c71f3af9b3ea5ba4da7b07461bd03c72735aa94e3ebef006902297c3084cc36bfa4fb10236168337502b2cc060501da88237162ddbace8678d44476199362883ca4a55927945fd6c2f9446ee6577d7207e3d98a291391c595200f51f968feeee491802bb4b5d25083f0b71960cdadfcd24dfbef0c754a9d157efe3ab86542821de7b3fd697a0348d166e47bcdec6cffbe17ec2cb35daeb06390273b70d09dbe399d431278fb77952334f3de0d9d4a4e2b8b5987f4076aea7e2c6c2aad188f722b988f7c50ff41a6b8ffe6e283e5e772fec7bd753b70aa99efdd4da002fc7dee6f10f84612675ef9d553a689975dedce65b20d84ebbdae87881e8e3f52f2b2fc277e6e799c090a7ecf0ab731470cec2ad90f5e443ac035d5de70d6a058abc6a13da8e5b46235aefc465c7abe588fe564253e0496c41d98c4a7ae252b31325bc5d0a65c635f3455d73bff1a32129bcb33a57239aeffe43cd141d76cb9968e68738687a1d9ef503fdb573aec8a6958f83ebf2708ad6f839f89a71ae2ea0d24cf39476ab11038422a1d3999d74b0c265bd575dcdfb49bbdd7ec0c89fdd725e9012ba191e7914a32ec43797d9e0ee617eed0055b4e12028bef5ec1b3bcbc536bd6d81d3d4911b82a74bfddcbda38365cf8d0845315275e7db06e76e762141be112cd9e2ad21656b108b4c77bb7b0d5f15818e9b4837f8aac3ebf85a674f05d81d94a5804e4fc9c43343b4b6401f91f64c8af85c96725908f2c669d9315aa096d0735bf6b31d3d1045899c1f530df0eccbd6980da8482f0c3c5daaa292ec27268950254a3491c3f7ca50dd8596836259eb4c61d74fa1a29d65c8223dede660829b0e5cbce57af6e5f2350484f60b6ce14adee776937edfa7c42a8a907bbb33734da934d22238c7601a1cc3c2f140768661bab6c70faf05c62ef893ee919a30055e26a3fbcd9a9646f81073c20537b2b63abe7763a08a6eac9a007a5e9cc9f39acb3c26b60602e115c9f37903bd64852e2024e37543fd2598a12619b48161c14729493a3087b60b9b215408c969a6f6c4ab18f6f2f411ccb1d1158ab1d92b7b2f41595c60e148a1dc9a631d918e6a10cce6dccebfc68fe14524f0ee9a8d1627aa74a293d7d4995cbc92dbf88b84c70c17218ed4be0ff398dd7322c11f069da60f97ddb9fc50bf3cf5b85134d7b1fc63353100a49dbe172c3b4e2ec000fd66c73a27e13c51a4dcabdb552d29ddc3f1773f91827a07cc4344e5ec11a57a69075b6432793238ceed3e9e65c937d4f0d81dc91063397a309fc0233ed7777d690ddac4b42e50ff2094125a665919279e0232996a1b46a096c84bc010747261e167649a3b73921920a224859dcfd3ebdc54ac346a6237d470fe62d5e349e1b72ca812bb5b3d3ce52f09f8f1e11bd6be6dd91062925413016ddce2b8f8c5b0ac9929ccd68f81b53b8c7c868054645bd8c29befc033ed0e85696a177f864944faedce7eb88b3bd1fa11665b1e49a50e3e9ec98037dd3f13aa50218341a4e5f12d99903375b1b966439bd13759619d9c4a848dd8aaa97ae49772f6e6941f987a2dd2500066559565696e43dd8a7da9611372e917c6441ed5ac0e548802547cdf715aa11ef7a55e3429f68185d32101c660318a42b658bbf457b9eea7f4028e87dfeca210a41b3d3bd23a719761fb435d2b039ad1cc0c18e09ac8b3c978df0e0a9f0aac19cb48a597d7535bc32f63dc742124020b4b173bc473d1d29aba49a86d4fded2f49e77930c66b8697c1715259f5798a62a3018bffc35e085053f49e46ffb04993c85a0a44dbfd80127256c39902bb38f3c342881cd372d6e41caf2917d0806cf128431afbeb4c6982e5756d4db9cd912b28b47a86de3c7bfa4138afe06fa94767be0e55e6b324250b4f2a6dc7f7f08ebc9cdd1506b2974f29dee26dca95cd8b3cf99580756265ead5fcb30778ead85805337a53d2fda5c9a138b342a563e2bc2268cb30444773499f507b83e2b3f86f3fc9f8b4e5e488f6be361708f6cfcf3db6bba2604a5b8a2e02d6c3fa8d3d97abfadfd93e3eb43e00417ebf83fb4d0b9cb414fd5eacebf45f1b6e069eeae5d69b29b7bf25c5cf5f91d70b468b1045d990c11909a11978d42999440427771b9dca6199c87da0c71d213b8dcdd857464505521663ccc048784db47cda82e5dbabfffc3224ce914edeb1501117c938d3dfef4023c27e059561508e3f5f7b08293edc9a6018c578cbddd784ac6943755e9cabb7614e4289d0d670056f858f69aebb2ab95128e3ed0b36e83238f54305774e1d274ab319de779bfe3a4f18918289f1c649b28ef7b05d5b337a64a4df58b49d9e56c9b3bae182deb21a4d1717682c2a118174db8dc09f745d7aa9059107b9a5c127e06c4262b04482ce31a461ee202b791b19ff3b7e7d1481ad65ccf67afcb2f40b34870995fb9d78b70ab934d18c50a4d2ee255df644fa895a6bafaf2f02155288e3e320bc94d4e9635268296572be372bf1b08a750a4e1cb0eea529a5b9b7bffeabb21370dd211f9d54e2c4ce3f950e6f8a753cb15ff86f7eb7aae2c33b86978de18d86402e15b094d2692646b5c8a0b555080c9bf7249210063b9d910e8d0c70a29358793db062b21e8ab4f49ec887f5e38b0caf215ef1cd6092c4397c57d644070be8e64eef81a76f60b1c132d540974ba0cfedf0be8fc75b70b21e51b8f90d9886f2af243e3c64fa956a2889e35f44de1a92ddc8bf3a5c3ee714c6fae9d1754636bdd0b350769ac455d4865f3f5826e492f359f3505c3b31cd509306299555bae144d6b1bffbfcdd02a3f6488523b5db09c3fe6eb9bd5a64d4f745c1f7fca4a469f4e8f976b82fbd9dd174981290d30735b1afb7375880b702970952353b1aaec1a5dd3c7a947b829a83823dc1c37bda010e3705ef5e39cc4ef3996bb4b2d885a243f5fe239c10addfb880750d82a4b5a856175e4d66cc62980581dd5430f54beb55d6bee50ffe27f7f5a8b202ab2a3ea960727cc264f356e7f21e76e5177c6ead77ce47dc22567a534b90546f0fc5c2059e10e46d8fa0a77def812c9c7b36cd9badad76304fe3d84b9e682860db1d0339dc5207be414306dfaa86cebe9c2e21ced7e9bfc06db78d8e39da168a55b6965066e66ee5247369927112e0c64e2191939aab959778ad4325e01da3783268b0a024988bcb5a7d2dd08b773c3e5d6ea9c50325b6ae965dd3de5f70b77889b2bbbe3b55a2b512ead3f037f674d98fca357ef6c4e0f9f43be1852c45e9845fc4f56c7951708b8e9fefaf18285f7d525679cb77892e087f74c0e47c7b559bc804ac83c7cd76abe1c994b6358ac64c82842214b141809b709154f71d06e3312a9a7eb8cbfba67f9825047e250cbefacedf2d9b54f632014fb2ac22e55596bee5ea43e68d48292d67a83c00a63df080455da59d223077dc5c4369bd3072ce825b92b2b41e8a302224c37f58a59bdfc0a54b9c992a85747267249ea0afc81f1019047c298ff2c8333f9e911983b919ee067d5515a2c39c4ea495102b98617db335a20153d525a19b43b172203a09bf3f149f28cb2414d2db504fa6f92b671fbb7472426c7c45442063908f1718737512f8c03ca6d2ed1e720ca406d47daec1e5319efb933fbad599f26364343d4028e9e11c905149f6996a77ca278f748fb406c969a83dcab937a33a962d4331b97a2e16a339808697d4242f406f72e7045bbe37f24cafa781d3571705d2928bcafce9d1ed32b991f66410c9a47854cf24ed730e2675629757d7973b3e60cbb74f6277266d82c92ef28bb3d75c65674da7ac686cd28906ed74dd2667e96d7891c286a6a09096d671c49d78b1b7f5a05f45b20c01c54fcedbc9a2593796c749477423348f1b3dca758862c6b99a48d30d2f178f0f3fa20debe30a24bdb68213830fc8aa88ac978ace1310f94dea0bc586d276a23e04651fe22ca6354407498cd867aa49e6c7b0d0e9b48260b9e4641d32641348014f61dae41618d83b3303506b4a6f01593d4797db2b6a0ca4903a1265b5b8901a133f9875ce91d04329143640a4ae947a97b2966fc3026e0ae70e438a6581f782701fb57ed8e03e602c2acd6d021b85cf5207c920e5395f74afb2f02ae2bdfc7707bb0704b4afb940f75d81245335ffad3f20a2a5b5755b92584c2b0719c072407b574087ab52a5bb14f79697c0ceeac3c8fe0eda179f281beb54f0c479c041087194eeec543d5d41e58c9d45b1351eb8f43b6fe7649c425efb2405c0fc342fabeff2ea169c180d4b49620a986845c4b3d5f604303ccd33339c4d103000d04bdb99f80e856175ea4f886690615cb97af4c465bf11be272803721cc5b487b145bda4b3e46f996e231b13024595be9dc19538cb63a905288478a6103c4719ec1e3e1d34fb868acb91de8665ca8f3b5f5197142d726c32a4eefc7c07410d2e87b6e19009b45551178e9618602b5349ba987742b8704a0851e00f9478e684e7eccdfa0daba0ade72cb06d6c12b0d32db156d160e990605c43bf856c44dd119c849bf1c7ecde4294845043ef278dd3979003e081314433e8869ffcdcb1972a800a73d1dce941ca2309a4b9757f8e17e15e3ba844c84962c7c85822698954bda8a975fd5ecef9351658f03ee98dd693f77208e102aae5dfe815d1d33ab1f256c78ca5e54563a298d89c62e1defcce655e454023936c8f423e3a23993723501f481f2a60e98ef2577338f552f96a51fd53cceff64cfc9727404460d1da53a2688c62f7e3e13e381b5a9aa15c43f9ef0187ada3d4bb987262ae12693c4e17d3a1b9e443eda64a16879fef48507d3d3204938531a1a1f38be164b441fe0048befe525e299c19cbbc992027177fa8d39c9d077afa63ad03fdbcaffcfd6a240ad82c86cf7f6c84c7113a6e4047e129a657f9818bc4d1ae3c3a1ae5c3987cae82bb50700684c37266ae7529a03dd74acdb096372e85e7f158908a847c580fb4b98afd42f83afa3bd74f7993d93d7f481efbb43e5cb4ec89f5e6b3ecd46784b76132388710cf668f9b9ffffdccaef3c22ff7c0fc8f74865e610444b8799691b4d48caa9258c12654a54624eef09b05075a8ad293089425621a81a2bd2cbe1b318ab19fa6f761ef776c06aa9f5ab95c11527aeb09a0f7455042923c6308d6554e5172ff88f694b5247479205bad29c53ddab8a8b758699647e5fff4b294cf7066273cf729fdcbe220f354eb17934a9940bfe783c062bf8c47da9c1fc7595e67578adec2170dacc772e7dbbd9f6d4347a4fca500207939b0f9337a65f2a97c5c905981ebcd5e4ae6ba35b59c590009e8f1f668d5becf21b1767f712ba7b95a1d682cf348a2051054d1859778bee4cba980fb932b1a3f98bc983c17258d1eda3d62b7c673159e5af8a575291bd4d4fde6be53ec4b9ebd22c13caa9556b1ffd1ac1cf1ac49c2c018cdb26e00a8936b7efd2d13708839350fbb3af9d324181e785f3f877a1c12eb72dbe17c9f4a23c27607a6b541deb04c1836520326fa2d90335f9cea6e6a57a8ea35d726f99267f66a861a1e07b9d86e9522db32018e684736cd3230db6d736060b4dbd4239d3a8f578aee19d470a122ce0e2d554073e6fb387149d739c1e067007e638f020934257a670b8f2a731c3990122f05700bd8d3820a284cdf87683283f7ad8c6874aa891d3f56ff846d7d7b6c29a7020bc6100c7ea665ce4cf9d74cb23bc1ded188f698522f231f78c36c7667c52e46a568a19f07e3de69fcae083b3d0eb9b26e7d41e9538a40d4ec798a92ee60006b2d0148aa025658dc170526e9d07a18af2dfcbd4a9df611e3124945a341846deefde4a3203e16c5de8da846e9d064327dd95cf1e571a5891474e7da9c3aee0d1bc9a74c53ef10d780af85444f2bef70708e461cf4697dbeb5c6a6a43b11c8ac0bd9d0eea2d388a718ce04d440404a74ac735e9caeaa29dfcb25aa6131b7637b8abab4b0de00f778bdcf146cef35d21a004baa4518db00a0f46a08e849dc2496b29bc20b31c6b9aafaf8f3b50f9a9deabd34cc458045462da063168aef8b8659473f62b91be8ef4ee312216c6d7cf1c2e0cb1e25f68341c93942549ee0a9978b1119d23f868e183f60b8df7256cc5378233508d231bc0ff9bf58eb2cf61aa2352671c087c884d9a796dd3383666f50ab94da59bd9a99d2c94acd6f560662663e6099146330abf5cbae09ced37284a6280cf7b2b1d7572b34340d24f90e252412efb42ab17b71bc0c5e45e5180698a33193aff5d82bb2e9957d887904999bb0922a645ece1daa8d94735fa700da247f0fae79bd4a568e33a110533562c446fdfff2516e30595bb914c66fd534c6482b10fda8f7dfd6c3e32afc42df73ad5cd947ea3dcb63698f3c6400fc8a864981c28e58027a1d427eae44e1e3ecb448ff212d570f6095283d79c60536b933d28fab40e159a5a884b0c2450f66cd6b8b8691901d085db227d3a02c06acc684a0b57ea662eabd7d58dfc0a5205b0ffc9e8f2be1bdaaa395b1710ecfbc76d5ae4c62a57a9980c211a943b97c36a8acb2ade23ce37dfa6019ee6edf76b5081b8e9173c4c54d5f99eaf57f3e5739d1aa928897bd5ed367eeb711d532feca5ea339ede142c71c790fcea4d13d0df40ec7099de677f24c855d6172b67e83c3096614d2a65196931c6313eb6939dcc6b630e386c6594eff756d261052c710ec54bd28751ea22e68e924643417c5b9e4ba01ff1efeaa234907d4aa4b6c94aab17108316532fb9272fceedeb6ebaa8176ca3beb67b8927f242bb8defb4fe02cff7c987a8e51f0bc51fc193903e974f04fcfa458f27967f29d77da3509cfd9edd5ccb2de9100d4cc8056d8bbe412126b70294349bca351bfbfd5a3c27600f2213e417a73b9e866c615f9dd9db9604b90e3f190478aece5c8d44a56099bff88018a9b6a2bf18458e102fadd45a41971e847a38b8c0edfb014a07295b566acd620bab167deff4d18391d64b472b7d6fdff35de25d5ff480616ac70ffd53feef19e9ad90e5ba5c2660d6d9c74fceaa7490659064f19603b1866dee731042d40eb508d28b701d9e6fbf25f266335e5afebf80d3565fb935b2d40f5c056c9c11839807c518fd1b4c8434a76fcfc9f3c8b26c88d926e10be4f5caaf90d0692874b401a4ed445de6ea81b8a1f1acd5b51b1468b61cf16dffac331d2d15696dd0e67d01febd0ff108f2e541688d3aa52baa05ae95a1e15d2ac03ab4593dbc827dbb0d00cb6d78c3a3b5505a6f469f444004f0ba7388172ee6712c048819b0f7e3bdc98a0c6ac5c3bb330aed09240624695fb15ba4953974f6bb537fe2dcd72f097c033439503c4aac5f6a8a5f965ed7e79c4db6d6bfa1cccca24705cd112d30ca299f927d5c5c88eac58cbbf6618f24e4fc5323b46cbfee05a7d21a12f5dba4f87a62020cf984d4651300687400efc7310274e20d4e3828e3d17d08e296a07c51847b3f94869cc17c54e94e111cf9fcf847c8baef66225b51ec96474cd3caab641c646a0ea56cd5360fef6f32067c800614bfdbff6b2f8ca638a057c80fbb6856e43bf44e2db946ab557842aefe58ed5ea9029c558340627f7db3e5742d1751f144b0f29bb9b0108b4488e02059088f200362bb415c17b02b4f59e58787906789b1c021406bcaea480b36530150ed99a7d8f83527125719cae948d0b310aee71ce3c878557b6f7ba141914d86d344cb5ceb72d375891251d8d11b8859ce6fba8294d4844652a9cb2dc3c6ba2bc8d95134381cd9eb75e0e1ad829258887752c1712908d1b1c68c56606ca640a7b23496b14f4ed2c83a78d0e4cc1f85b377071d3906b668817e18f733a1e052c98531c9cb442c152eddb273410336e5dcde5e927653051b7ff4ffa72e9926ae03aa114fb51c7d3cdb14b1708f889a7f6f3f526a21345a2ca41912106afdaf84ffe6602102ca65190a0500b384d288e3d162d94ecdb0fba23fa153b49fac81139b79a075fe711d8e02c4051e7c7ce0a1d0e78f1e05acbb77f2353de7c64ec0f65494bd1d1b7308e046328b6bd3793ffebaca001998acf2145e7f72ecdc70bac5b27842b000b3dc133a4114aca4edcfe1571664a921120dfe77d8a7e75bb3655c2cdba61254a17e89ab75b77dfb83c2344f29e01a3a65932cea7f184961c468d472ec7924a57dddc13924c2b68ea2f24e20710779f54e37d91ec1920bfe2b12d06ef939c10550513306e47a932e1503dd59e8c54ea1d2fe4998687d53b3c5a48ffe7c70434737205628be7f1943334a38a3706cf5e122085a04b88855c0740f7462db5bf2e7e41f84b0acc18ff3c4482022968212223aabb344f9d200cfe1362b565a55c257e5ad231dae47273de1ec16ec6ce90df7a2bf199dac3b91e16cae184d68a7cbd37f64e6da55306680b57e9c21e988fbe5dcd843376e163dc57d86501d49726cefdd23a76e83682b26eb0c6e414f8c52fda3d7aef8bb705980d55fd772de30e9dcd1dd3e572c5b9ddc8b4dfbe06d1f3b3ba916404ee396f1201bd90658e0356f7be6ea31a143e6aab698cfc4a6cd0296eeceb1577b6c389917deb5cecd9c5298b9116e7d45b324a8899b405ec700a277d156359afaeee605dec207af783fa6ea20caeb7f372e7a332cc9369dd1fb3092d425b5e089b6da3eb2e3a83f4d3bd6e1c22208b87bfed485bd3a61387fca077e5c8b141f5836dbc65d44d01ad4b7d2141943d63aca48340b9df77734e0cafc690b8204b6bdd6611dab31dc84bd52ec83bd7bc132279c7de2c65c453dd5c766030130166cd5d1224a34017023752a9475388292c34cebbec3a3d64d91d225e290f4d422e5d2a053ade3c4abcde5285e5ea24d52b76d3da9220b74887ffb0b85069e5a6eac2c9474ab7ae354a3918007170eead4ea9cf28d89615242db1dd59d0dbc652af3cfea908e10c1fcb1458b4cc7a1aae92539c30059721c5ab28c8cd64c4aeabba66ec533910b47bbf7cfcd0e275c351f5666bbf7a2c8267226861c74ebdc05d39840757b97a8fc674ff7e386f10bf9a5aa3bff6a0f8edb50a0b54e8a520596dfeb69c1195fe45803a0b1484b3d31d85f06934817b5644d8de582593107fcc60ef28b36e3c83e38f39ef123410cd8c7ba6c396c5ae4e40274bcee99b0e6d9e7d3d4f2aa4259a3bcc00b5e45af34c379dbea479c778b00a066e87fadd4b2a2a89e69b74c394894d0419d3bd2f94b41e7b4b9cdddd8f7e7dab697fb0dd14634e818c8c668dab6a7c90c7432a00c1ed63f43fc2d001ae47f4555c0f4178164b8df62855f3e3cfd8c8271cad2e8837c0f22f9fab8d31848508e655c77fd14b46fd878e4e3a469615cb73e205ede75b71e4eea36f3420d7e98642ea2fb8d3235002d6628efef32f56422375791defb4b2e92462c14c25124a363c6154a8bcbe5e75f5a3a7ea32bdde73fecd34711817eb5dad3ef7389967034fbe0c7e83a9341a3ae4fb304ece3b4ecce0e47896c02734e53d2c54d5e167be7d9678214216be04130cd6587bde7ee843605a713cc2a67bc0cfabd4fa525c189dd042e9e3356e35006a5eb05edf6181e2b473bc93ea16853fb10468e69ef0622d8b46ef3214c73fae6447fc4bd22affddd99d8162149f638b430888189acb074eddcfd78304239dbc1401aee801ddd94c6dd23373055094e26f7c944e5a6631f5df43d35ca34ab5bc4f19d56969bdaa131f1337e4dedbae90d93c774d9fc607d66d3077be41bc5a04f1e5d9c5317c807e628f297b6a4a7a1431e7d746febdb6603ec7a5fcfd18f74c98958fe1fc8d0d082b97952885910f6b9a24b84aa50c3a5940f872a3c71efabf428160f1f6ac873ff63aa9d8289015756f71d4ba50e80f94a6efa913914d5c679225c182bbe3ef79cea05da64670997611f5099447c3f2c080a86a5f570adb6b8ab5d6f884233c70b67c1b1674c1382a8a105614c82ceb765bb29b4114a50621aad70b3cb18c1be55c0ec2a1ee1fe11606ead0798e46e0b43ddfa162bcdcd00f8021fe91a17250d4ff2cb15489c8c754b5e0073efb0709fc392c251633429ae1a879c31339cd8485b7eb8ddf829eb504e334559ac84d9a4dcedaa11bc99b6aa61063194ba4fdb5a4973c20f9ceb7b8beeb7d12dbea3c56f1ceb96c1a56ab10c24a382a799573e429977a0a52d9efb3e9f9a036bbbf0584a9aab0274bf83686b8e4e44ac7e8cbc8a796209684b78cc322189d90864e2e551fe1744df7ed86654d8418fe9b628649fb4b7f46cb619634633fcda2e9810fde232f2c400b8d3edd0c36850ad1b10eba4c7a5b6cad8509be89a47fbb884df9dfeab84119cc3c2c9bc34bf23d6f399cb9df1d2e6dbe3c7457c99e2c1d1bbd8f480ad3a3fc6217a089efe012023dc8fa3226f7387e3689d964042784fdfd0785bd2102ea4dba5096758f9f7d8ffb8bd906c89b101031ca27329ac6f825e6d995d526fac314b1f3b038566c13257a30a6bebbb623e22cac9ea34f2245181bdca82d832aac2853dee755bcf57d27cdcd12649fb91e8c43c27227ae36326f4fe806002dbfbe735f63e6f6084bc992a0c9ec515ad8043b732ae940f09e424824c445df354740699b9bf2c707c76e43b1d5d493a795ff0ebbc9a57bd33474206997c2c992447b0a2d2bbc66ca960abb1cd9f5a2c99fef48d627d6351b09fb5a27f41104abeaebb6c8ed43e76716a75a81238cf2a3267a40ce07385c3fbf617d79e593a78ba5504312b3e5d15482b366614ee09c42765d0ab825229e8fb2f4a216d72e2e43910fcb734f7f3196ebf58f853c951dc9a08880c6af22e34a76f37b9e16ebeec12647633934e8c2b4b3cad7a5f77deeda4fb2397b71c22e1690410f01e99401fed17ff941ef2af849d47ab79ef9f62f309601775d14e745f8c8ae5059487856c5e41e41b459e53e5a9f25cad3ef06ba1693432085713b4a14fca7d0bdcce379d949208c93c3760685a747df5c280534017b11b52b7a59e9afe4020d7e61985daf819f70aabffc620118150ac1a3456a62ca387052bc8dd2a38153d9007008642a8161303a72e0378f9311798745d71da5201e8985244edfd0f38e3ab3e9a9b7dda6bd5539238449bca59a3f2337b39349da293fc057f94968ce19fe204c52faa934091385e630e21447b222754a8990c9221883342c49431ee805bf541f92dea329504129cac13e56c9acc9b096947c9d27dec515dae8e18ae2a7cf6b1ffec367433b1a144788b39f3ef4d124ff19805eba16f7ca69a3202e485235f3d54cf317bad81282c83649a8ab100721af7ccdf84158307ce1cfd2d68a38314f3df33faa964f90891202b269e3a1fa09f28b3268484b6b160f5691a4cd74e12bc0f07cce62adc0397e77a191266465e37a9dbbaeb90a38e1d7d0b2eae1613dd98f4ac05f0abdf479c64b46c1e610dbe907789551d0d5ade97da73f5fa10ff87b5f1d259aa358de1272215dc3ddfadccab3ebcf9843fc1b4de294f0571f3e9adeb3c366edb09aba76e0f5ee2af6984aa67cfd6368f79b773c1dc83c753ad129706245913e12c4256cbe51f367ddc7760217c829dc3ea28583d2f35141356576077987aeffcb8dc8e9bd0d5c289512d925e09de834f174bbf1f81add71566df8b87c3b32822ca5bc412ed3fd29bf6cfdd2df9802fc18bd38f1381e4e16d6c537e3d9e72403908a51dfe9d6c835f3e1b2540a4834553c6e2428683c0414d2e0ecf1cf81792c210485822b4e085e50b2a603b2228efeb396b31d7f868d799b38ff0a49cf31db7255f0c7b3761727cf11b357e56b5034f83465589dad9ba9fe4d33e1bd2b0923692a0a3ca04c132edc86213c383c417d92964aa34c57ca918ad12c46d8c33cd9311af0e15de7965ee0a1a987eaae5827bf432c9f39cbc52fcb192a953e8cd04a0b984ecfc05f8dd889ecbbbbd6d805d81e7e04bdf91f0f7cc64a99be927fb4a91a514e99de24ff64171eb2c7674dd01a0ce39a86c8653106483ce665c57e995a44742c4511fbacc86805aadb1214c29fc3726b97d11acab3f0c4a77df9a0dffb72886c06e9a0049f73d9963d84b9ad3b92b3b4c56b626863469b48b98840b294f587475a627de397f2f1ceef83ba3f0d33e19dfcecefcfd8d9a048160ef203d298bff9b2bd5d782cf3c5797b5b0164794ad5703b4172577f617e42686a7d3cf3013fc7857ccd15d8c6d3bb60d06ef8fba117bf8cba04fad01e16472a4c27f42028e770ab53edc11b6774b36f75d92de1dfa66dbcc6896b2f4831f8397d54a5da7e8e0a21c5b9f3b7cbaab9e41a2b7cb4fc2c7ef5a050825fff14aeaf62fd1019ef3c7a68c8d4d14990f00fe44eaae9e9c8ee726e38abbd06f954ce90c22b4aea64228e243fd4e68fd68580d3fb9acfed7162d1ed5a587592b557c17e96014afcc7ff193ca13e4c6cb410eaa6555d3d8a0303c642afe26d5629e2325a80707caad9754144aca4c9fc6570ba48787e48383ec86ae5c43f8ab693682965e108fd564c76f104ef925f8ef0159a7f8520a94f4f41e4d4045dbed4575c9339d344ef77b9d6f18c4d50a6a6765757c68660e3f03f99ecae913de0e5df3c28f40150889bdb9cdbae805a3e58bf7437be98fbe0cdceac49561f5c23d3ebc1ad97fd0b52c593d12a6a4e059fb9fe64894e1efab78e5ce96f7ab616cbf0009876c9075c3da973c87a30f0a2bde422fb484ff8f5825ab8f3359cbbd28e536556a5436fb07698459b90626f4c7e5fe2acc5d1a88bd04fadbda50fc066e92ab09550024a5ad1f0fe4acb5c11e5fd7da4f8b5e7b790f6cfa483f4340f00295d96f4b6c261bdb6be474c8f7a8a24bf4434887e65d12876733bd85f920e0caf5b0225becab41122e85e4693a1f3eb3344496776e7fa2390eb8586d70c18f6aabaf2f871acc8668dda283021a06139eb80e91b9cd35ab29406a28d8ef12c0e5407f7ee0b8057ca38f21a84d8b8be6311c39f5b0d2037d01c9a404ffc5ac5a86dca448e39e8b95a6ae764b991d16af80f0e287ba64d5361747e0c547f87dc34924ea81e82734b5339686a97894a3ffb7c5c4c98bc184340b67fd642b770cf2681c68df3dd2bdc6334285c22be05c8be4cbb7b768d40b7d7f222bbbc32e93476720694c47f88bcbb54413b86fde1bcaf634d9698907b395f832f17910fa1915f18a8bb4346c760aa42bb31b9a53297b873b9a04b1701b51c4c3b7943303f02b62f5683566bcbd15c893ca3fdb0c2df78b0e207d8d89aa0adedd276939d99154b43304e99371bf190b3b6d93749f06d7207f03de349d88893649e98dedcb477bcc948c62efda371dca46ce9ab0c56b26a8c7124327c3e390b2649efa36bc92f98ff535cd51d7b9e1b31768a5e7e3eeb94235d1dcd197bcbc748f8f4ed7face9cca47752768b7b2b4bfebb3e60959d6957a61c9ca8e03f6ed56ee99a6f8198c4381eee8db61664dfbb2fa9bb612e70f00189e98a38427225b1b5ea60aacecb9ffb3f226d47959bdc86d6f2e20fbe60b6f2baceb675985e6f4d4c6b52086c4d661308af1c727130567f9b689a9cc229d3c44d23a85c9a63aa889578401fe821e1ae32f43327ca80293b82a28405fe13e6792501acc7961e68670384f79e3381a0fdf41604ce64f723bbf0340f8224c78189e535aa798bd0891fe3a03350e573d49a4209e39ce18051923440b336c99316c917425c9824b92584775e7864e46e60771a9432901ad95554773bc830a70b48bf56f8f292797760b2a4d8d434046bc45f0df5cbf926abc8e0fc105f22723bdaf5a7ebf85203251f0101c47da1a8b90778722f9ab100cf720698c1c7b05e59c4032296ac979be5aac67b213bf77d43a6e36a07ef4f7f90386a71a2b051484d81b0cde0e2989b136a71362d6c27bb8a237a7f10750e8c367241f6421a15e72820bdd1652ad3c47337f635549d2203b7a01b42a2c1419cc548192ec0f2ce6baa8a6c21b64853c08df6638adb8b510a873b1c483709cb96a466bee2c47bbe2d44bc5f2423e7eaa4dfe44254f3f806f8f10afe1d928fa2e545aa1453b68452bba80983ee5618e24d3da602c028aaf851970d97d571b7aec39526411182997126aa7abe96ec4a59823588913e7944ff1dce0f2035f59352929c5b9e4d7dd90cf08d46e2d9d41686031a5665c4d9b029c4e2019c09004e5ea94952233be0efb7c020e75adbc1874f2eb5a5bc5d6e27fe5f0748b5bfcb50a7397d9311f7ce3b2c104ed61f82f23ce323169d0dc467d752744be38aff84114d13e4ec180f877c9df634adbd0021595c743f42e91ac7ba18de989488b2232caf0029304584493e90b2dc8e6540c568eab2c6272931c096f13a4a513ce98a436846892bae77feeee2d13a080cc5058efeb7435bce8f00e95b5dd9858b0863a229bc283d145c44bb78f310e4249e855901b248fd23c9e3fdb63f905781e2cac5316f97cbdc4be239943e7ae09a7f23f8c1168194705878de91319a69349a0a6bb6567c7257019938a13adb4fac1ba895fddce79ec09061fa0789cb3521b98bc14eed2bd38d04609da68a026ecdc568f222661611b18c05b67af5c257cb4cf32ff831b19f8767e2a5e6adb6c26a0e062cc641b6deeaa332c73e3d7e19c429e3b025a728b8893683c72b702655f3e031597f69907e96afa600cd8b2e24da180c710a5ced8354689bc13156e5a81efb53c17d9fdbd5dccb06b980c7b7d74c3ef94e03aee1ae0b187edd078128ec75891214d1fc670898be177ea885a57bc63bd9fa491206eef30e6393277a3acfb4c0038892f2b0cef4daf1afab1286f69ce21220f5a0bd0d06de1c484047ef1707c75b72594f5975895647c3db630eb77aef0341978732be01c59924ef99c9d2635458dbd09a0e6baf7152da8c82f0a47b893dd353fa9553d381a8e2d396fd465be931cb798b7ffd5660376304b63f676d5f80b811bcadcd3f742b2a6ccbeab834399e090fd4c3b6470723bccbf7f6ea2eb02e1577ad6250e99cc4c5b651ca1e3d1298f44cd325ac1829d5434135ffa763528fefb83afb977d5ec4b2e40d42e8b9e28cd78fe959593082ea57917d46cd55bc8f30e92bfe1c93a3cda621c7f45b303883a0f84dc5f66957f7e6a8d2ef14595d442f5b3386a950b4d546330b95d2e133778c59d63f6b5a141e21eaf9bfa6addf34b5acc0b5068b4ac031b3593ce108eaf0bb18df2171439fe341b5db891c0a86bb0477b1f805b984cc948dd2aa15be9e46b41efce2bcfc40c68f009ee564bc7f9b99f913b6b08dd2048caf2efea7451253a0b190d436fd9220cf1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
