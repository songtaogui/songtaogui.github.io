<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fd29817957730e31a2c9259622dd589a8a4ff07d72d87c3ae28da196e9fb1197b4a9a96e3a16f0d2f3e10bf917db9ccd878985d7940d6781e41152569c9f95829e46af23a5f75b00286dd84e64035c7d80ac03463871f8e866f450e9f32943494116a43a6e580446a4771ed5cb26cce989742009c62118faae22f859de0754d8640d92ab6cc5ec108715a8c2c91790e42482bf01e970794a38a4dc3439b41c97f5b2fabf20754dac1e16a924b1ea00cde90a86c8d1a35e8de46db9e95fee94752755692f4b482310340a733770a4b47e2db8064724a550364e3c65b415c1b485a0d2c794e2a0d3d40b371346495c77f6e50cbf74f9b1d3317ca417cc4753314308af336159360d1f766f4c6c7f126c839a0c9d564b8b9f154b97c8bf5e843b63f276b9d3f31fcc343f1c6fe312093d93e9c88744a84554d0703064d6ce6598061f3588538c7b2c5dcdfbfd8aed7b029ad4ae7b2e15030f00653359fa8590d14233aaea3a0e466fd603f14058a5d6dd95178f5f76eaed29713136a43d28bb3904ab0b61df52bc01b3be5779c6c0a280ed1dfda688f4827f3eed3c98ca3e28355a44929017761e8422dd41e9b69cad74ca31ab01e6194612811d4622255f11934a79f0b73c27464c52b5a7239987fccd382ae5c07bc4901f6bae4b7a44693535526f022d590d635db5027133fb3042fc7cc5313a0da5621ae4c306f98903f202b4392af01aaad98e6fdb14e31801f045533cde860eb7ff9ac1dbc8f1786bd903754b5d66b014213d2fc1bbbb9dc7b9fdc318fa007e62fa1ea1a0993ca9ce2f4031ef8ff6fafc721a8d0baca9680ac974a6bb1cd2b03613973c2cd2f367e45cb3f8815fe70b47d742c8f04c39d1b5760b48bf191832b93220a88888a94daa8800242aa1b5910171d8e439b23580423fdc1561c92748c33afa94d37b35760fb19f45af354063970dc9d80614eb4204c4d84c31a4a711c23c1baf99277a2701f463c1fe6b6cf0ba99e322a0a3ef420175aa31500775d2eb1bc3aa927f952647927b1d94fd0a3d5dcff0188e5b11b8418b623bca7b2318cfd5fbac3be60fde38f8f9b5b6cbf11876bd5400f490f502ff497728efee0c51d8a655cdd59215d0385bc01ead1474fb0093c641032fc96dfe5db35f559444dcdbacda3b51a78ac6e28dad89b1cb2bc32243944d52301180df848972879c18d71066ea94fd25f1d79adc10dd4efd458058a19bb0e6a78a9c7d24fa1eb7c3cd213fd1cb3ddac673f3e38ff730cb6d49ebf85f80437966b1c3eaf8b4775be1fe7b03d1c2b1f3fbbe4fcbd5f485a6114215a20a09f6015c4644dc5f48ef5d782de6bde05bf8c296aa279bd666a02dbe338697cbef953244713ae3c5be53d631182a055165e7f8c259cd7732cac91b0282cad62e9eb81bbba809723d546f598950dd9fa30e3d4e81b6d216d1c061959aa7eb40ee24dc371b4484e112bc1c42a043379aff6d55a14a6174f460dd705b0ab8512732e64e41aebf25efb393ddbf7f6cef2b97c1b7024f103060f3476106e5b44702969644ce68166e53250eb32ba209000f9df5c5ae0c36c1924c5fe35f4c271c52a2ec70a0fa2abad505d879c0a4da835c081b9efbd291108aeb49f2d9da673cceff344c1f6d7736ad1607729002da0ff34bbbb37db48a09873ffd611bb35f34c9fa414f53522ff37734348bac4cbbf0a2a0bdbcf9bb3d45f5e6ad7181ea4ea66c30e45715035a0524e23b47b9c4d0540ffbe57bb87720411248b21589fbb30ff81eb088dfe7f8f5c80af1a5bbeee20c2a6490f832d80d999d81428447f7eeaef19876992c77407764cd22f968dc7083b3b04dd006f087627b442df4dda0d1e1cd19f8fbe7f803bf6b8f1742b3f4b6ebfeb0fe48fe08805be07b1b343cfc3ab76dce21e3c6a785b0dac36962dc6e9549644fe47f5e8abe722039a301ce0bec5cf281b33f85114b58b2a7f411aa796747dd5a0381aeaf750c12d1e2ad183e175bda7f59610fe2da7777fa290e9743dfd25d09087baf3e95993bf3fed9074cc2b0da3420ce6182da4f51477419abe868a6337bd67547b01bee3c7603d14e8338dcb45240978b20faacf5b068b3fa7769490be8dadafaeaefb1e330d4674b9f58cb2bee0e0a6d723b26d3eeb7d316e515afd0c54a1c5905b2d8b26b12af02216d1769a4506ea30e508e86ddd3940dca265a95933570b59709c2c6aa584da44619831863b53c2636ba218caecce22d0e85d02b42bcb2d1567a911038f464de89c3da5bc74afa3de790127351724ef995a598a98d2d4d6bc2abfbda08c10cb21d66f5821d0a68362abd3d20a3b9250af0ef6203b0e385497a9b76bc69bfed5ef2e9ed9eeb6a19049131f0d596997d4aef86990fdddf75376fd493cae9ea24ae3752a3e908371343758d1f82a1e2239c16ab8c10485486a66748b9367b084038aec411ecbbddc8a9973b1e61b5813fbb184d0dc07510e56591000995445086b7090db36fe02fccf14639e5132f19a3f609424c6fc660b222142ed7ad16a21a4b5eac8b280e4c4fa5a07176c09e2a2eae7af9c853b5c9aaa56dcd82bc9337e3fa24de7edd0baf0fddda58535cc917abdabf574963d674045a218494717a844aec3279079eb5816b6433c1b17e4a9d975168d9fde2f8b9b7db5ea359c66872a978c0fc52d8c72e4a22cda380e282ed265df103bd8876e12dcd042f66ffedbd5b0da8e08bb0af4edd6eb4a47b3eb5b5ae806b9d4f84a7a8b19d3ec1315346ebfaf5e7ee7e94045c48cf5b8d36ec5685bf278b0f3de82ce8e8065aeaa546ba324105c3c8cd3a78a023631d4c81a501af93ca859a429af73d269a2d5db051130830a0ff2c46854dd13281110292904679c400180aa886f8397628dd2a00d030479eb611732514462d4283b6ab52c17f52cb57b62977c30446a800f7088bf27aab856d5fe7ff1d6da7d9763935390621a02393b8c1eef55174e4a3411c1a95fe40a98940dddcc01661d049e73f52ee319b47e08f65ea286b1aabb7dccbdc58518bf1f19cc2099d7a084ca5de130a275398bca895336a209223a8e30084c779e2217bbdb11608616e441f272326c3a6b6b0e894dafd880824e2124c87d45bfae44ac215caebcd878d021c89450b5d8c7d1551c831229da0820204a5adf840a325a8eafba1d5e4919a823ccbdc4492262446f4434f8ed78c15560f3839e0d4f9513d0af0707735f0c5b13e1d1f73751916f87c3b74cc22bbab50899322517396c2a3770554da9837026b60e304ddd89c5790e13051152d0a2ae6bc77340f451e4b5b338a392fb3dbe98c7cd9d7fadcf2d0837cf1b4a2d6eb8edc3cae497795289887419754462c05de2c74ee5f9c3fba2b966a7678745dbf88f158b7c2d55a06d7b8067a95a5dd97b5009693ada4d66fdf732ce8993b0cae3a6f8a4659ac2e8253515c240f44126d066bb0ae94818b16388b1c55374d6fcd2488ffeea6c020651811d4c8c1e68235f3d6bf17c43ac92aba508eb4ce21001e90978c6bb32ed083ff3fbf2568afa01a8dc6a17502c54a88d7ea71e53ddb1ff57377a5c9a6c899f32c12a872a18be3e94d2f84aa2afbc36e31cda7eaa608edbee22765765293c1a30e429ac8f9b96c15096ee9f389cfc7f90249477c8dc154c5adca6b3bc236b5b1876227ad740f32515d330f0168ef8d48323bdc5c43847ea12e5c557fdc415ab11d499113b89437c9d6c6d211bda76f2350c085dadb08ee84709eaa5fe88ec09d3e750cafee646c55f2f3c3abbf5ae9aea96d83f18b4ebbe4564d646018ef8a758fcaa7b1ba31d88638685afdcd5a649e4b0a1210318a7c13745081ddcb13a3deff225c6f4fd3c9d559e2edccbdd64a2cafb5a8840449d4e2b353c4fa808ae6e1ea76aa45ee6f98ed4d5fbd6e7d41792b32702502a6b343b0cc382d8b3a50bde478a86b0d3a1fac0073268cb924e5a32b0d53bafcfed0fd79278754495cf63701bda1ad1dda81fc2e82ed05c65ca082731c3318209771423869f292dc5544674835962b8f2bcbb2264ff56f9d8a4d4bad0f3d1af092fd9136242964311ec05e087818428595fdbac971e6906a1d164d5bda11da81c4d1b843d8290dc79bd03adf75136b8dda192729b3574b941f9a94d163f234164f506b98d679b0f9283347e56b67ae1271acd40f4176c5c1b93b2b67555f9846a7ed13fe010a2ea31b58b8b407505b3d60f0a7323f7c659e9a5451c44eed5dcd955092e084d5d5cd7d3f8248f536d24e4392279f7eed3eedf0d3d672c73957fe1b723a255acc00d4825e47d99469b68d587025a74e5cfa10709bf09fa279915befae67f1b14610804d575aca316a5684effcfd5e9cb29c23690e1b6aaf098b5af4d5d6792c59643a2f48849fec85c6687bfea44d623c4f0a3d9ddbbb218520c35ebe57096bbdf478f9a95cc37f6a8ffe010824ba2b11033345d9966067601e68cabd5f4bc3998bcb8983d661e315806afec4bdeb88d1fd1ebf613bdc72549ff64b7236d9a361b871bd39e0602ee9530e08c1866b6d57d3eb08a83d44757a0466d8a74b4dc572adb1a8534fa0d1c03b02cf2e3616f6933f5886033834f54e998942fa94c25989718c0dbb3723e6b33730e05d076c29971f5aee621fff4b78282fc2d251ec944260fdf839861ddeead132f8bd9a6ca49777432d113186869bfda3cbc6b834cff844ada5a0c1e9834fa3bb7db53b7130eecf288774419b806ba6834b17af7e5b611e2b48f6d106e1bb42c55b7fd2f38d942d851ec0935a610dc83c57b4c22279a6fc1a8b3150cd4c3fee82d2c00d0d74246ebb485b0cde20910cba6de0be08c5761db1c96df8e23b23287cde37ddcfcb9ea23c212ece607ece63d8ccff386c51f7300f62562dda00d56f883fe26bf65f3ddcd86474a5936d727704d3a315abb21191bd174f15cbb1754c01dd911d94427d006c6ace4967852b9ae8429c26c9028a202b320888bc45c41583a902d739fb8e18d300ec9fec1b8fafe14d73a4207bfbb205545cefbebde7ec9b1e8a899ae34031140d3e9c0bdbefd8b2dd22687f016b4e5faa2ff810158d4d025614355b9a7f197babb57417626343929728f3523ac3bfd8101e4cea162b01024c641d1a9cc9c9c7c9b92beb913e0140e9045493d281b9f8da03f7a955dd7219404536b849e24c4bbedf666011a855e0e82be954ba5301b598672fe37f37b606a9e645eeae53de2ac4f617ddf979f7099e8c02709d4294d183b13237feeea3ab4d7afba3342b41c2ec052628b946136e8098d2ac96b1a5823964e081f6202f9be25edcd48dc867ccbdbafefe2923d67bd57708bd1a55dfe0f927917fc85fc4659bf38a4d0e7bed8bdf44c844f354f0f27fb39ee1a5edbe75866ad92b46781bbfee32cd38f7c71683348955a1ebc714cf5101b4b67394453f0cb39f4c8e27868004b16cbee99add07e4dc3dff5eb218d65081b61cf2099044218982c726029e02801b4377227c2cd38ac57ffd2d6fecd2eff7c4381b76592f2ed422aaa9f24664e9fbfa7f2f3e92753ba503e72961f0bf58cfe2733da2059bb2cb0e95ca6962a0ed473dfaca92bf03bedf08f919fefecc60a45869f1b8c1f33f9edf7e155cc83946641ffb9739881dc436526f7ec36d9fd8883d6e2c819cd9e0aed331486b90f2ec6163d7af550f62fff0b98d6da0fb3ed5046a8c3778589392db2e73114717a0e6ff6b1ecaa2eac510b98c5e13c42ac2df72983a75439538bef2f3712d8fe87df07e8fb9f3eec165327fdb01546a9736f3f0a96f7183e7b58077bbc35c65b8ad714e5eaf467510073d29250d81a127e252c7cd36b110027b386eb6eac76a44801213ca6b072e34cccf487310a9b48b18b517d5d84e23342b9622b9d69335e9fb2914457158bc3eb238f014b3971de53d65e191e3852b62f7bd987123f08312433890108fd875de630535bd531f8d77e34d03bf5436e1861afaeb78a26660036a20f606375e5c3bc77d46a7f349d24cc44a76b2cd811f6a51f82baaca571687582502fc93da8fedd6d3fd2b04a1124f06af89928ef7e4f8cb249451fe45adb7ce0da17a755dc4f28020efa2fc5e29db1c90276b77c9a629da3f2fa088b7927c104d57d81ff2409c631e36902b9aa21c32a09a2cf0c53a320998fc480987e109ae9533cd9951b81761029c55ebc3040f4818ccab0ab758e6bbbbe04083235cb1258170e6a2600ab0df06e51646d320bea58f5c173d0b54e115a5f28fe470619ef6279725eede7f19c294efbb913c58be7bce2f07baf04dff0b100890fcf61234a7153d0576d7bfa916edc36200d3843e60fcde7f4cc906e8839b9ec8138498762a76a1f6cb4e801cceb21a1dc7e3a6f3e794bc049ef22ca62ea3cfe62c1dd680412225b6b2f4dbaa47344fd6769688c0d527b752188cfaca5f2e403d0197bd83acafd262ac122b663005445dfa2d5bc39a8d76e7990da5df04187dcd6efbd3cd9b3c17e825c6bf1e43d426ebb9594b9b8b3d0493363fc4e071660367205992a6c901034ee5986972d4b71f6a45466a5a787fd956e39356c5653927aa199849335702bdfd57f5b6309a1ea8eef43d76894d882e37a8e144357861494849c07482fd4730456da4bc96152dd70e5a7311a6cc2ba79fc6cd5906e763aec6aaab1fa3eda2bbe48669d51c70447a2d44df3e1961ea6dbef859f267c68550288a4baaaa11af9e6983d1528ffb5027bc4da390ac2c315122673a0ddaa9c669f765f9791bcd276579a325163e576d44a7838d931db5625788164e7f8e6e290c4a0f585a62166ef8d8cdab47da9bd5c91df7af07ba53e6cbdf956f7f4bd2588eddb56b25d1ec000697d2ce04dd58704e05fc738d54ecda388e7a252333b1d7293c40f84de561f7c4200ce503d25782a4480c1c0f6fb1b6743dee6fbc5bddaa5dcf6d7b99f413dc5e09c8d17bed28f7c72e01236b2176e9a0a6af5b182ec81fc7db0f9acfbfb331bc9c8d424d3214ec72d5bf3d0f12bdc5642037ba001d216dc3fba35849a277b2dd4255a718de9d32816112b3bd4001053efa298d6e3bc12d7f65c52c59e23c4deeee34fe5cd6170698bac9fe299e75791f5c0593c71bbbada432935ec78339937dafcfae6f33b929c51e5e5808fbda6af73cadf0d9ef21bee802d328f64385e6f5759bd1aa0f23838839783570efa92f1bc3098d1dcbd91ad29737fdc238f0732b309cac8b0c1946102e9417fe3219efb2ad3e6a4b6cb6c606290127aabadf0df60b13f551bf8c7e446148c8aab95aeb0c8234e19c2fe92e6f80df8d2706dc759562abb8a4f7a935e67cf5fa62ac278e2eb0dc28215082c0dc625a08d57d556f80941eea1d43946861ee7d2503740d80726a8d46e2a73ef3acde7fc2eaf040f0c8e859ae6931fb48ab689032b3a2df192dd7cca5743bb68d8a4cd57ec327fff96da7ccd5792f5b0ad05dcb34eb76583401c4c499060a68073000585bb9699bc123f7d10fe8e346406f53136f9614ce612a1c9c871912da3a64aee31a82c57c264213aadc66e637118b26e02c977a35cead7bf5c0c0925b267d83c8435835d0f38e8fc8411adc4b6de1e40300f8061924e2cf3eb354ca89bd1c872a7d54c5ddd9555cd2e6c9e545ddb4435c1d72adbb8a24d65c9db4290a2846380d39a96f5570ad337ac22b8c03b8bd972ab68856e7ec12cb0b9b76118d5a506ad939e43c8b8c6c74ec1d5afc812686d52f6c506c874171fcd41ca31a509f25b2bb1610a2205a9b5664e86235dea2eebd0e236a586048314d4a62ce9a69d4227327fb4d7b7aa99f037c62a42e37accf3ab0f410aa70023710bbf16a1e28f6312257cc6925fa649936239e3c7ead208b8abe1085635701559af60d151a585fc379b26f873a123f6e7faeb402339155cf7158171af6db2dddbafddf9f603aa0d9afa9e9fe894c6c26ad6be18b3054db22334392e1617e254127864b39f571480ca7dff066daabee447e189c01a426a51477970aeeb681458c8b4fc3c3e46254bfe77f76698a4682d1d0c83ec905f6fc9e2917a61a3424e55437da39f090d5db25a4d231ff5af0cc1e38119e3ece932aae15e229b3d4405e246e02ff704c658eb45959779a11587f4f18c849f47003c7609d4a226271e0a4104beee4e2437c715f2588c8b28eaeb4ed147ef8de1f2c24e319e1ea75432f5f72e926c4a8790ba0000cc853ffdcf9892e4ab7b3a5f91e031ecfd34d5df9b0b7ca106d6221c9f78b8ce5261df8d5efc6289a177a0612425d2bb3c1e716d75a9bf8121d845682728b2d6c7597698665c76cbc96dc52c7e499a09ad8cadef8735b557e3f42622e776bd383d8f25c7a8d421c30861fe30f84cc1293a05a3e72beedf55d8cbef447bf6c167c6f5ff4b782f4ed43153f31789a24ac7958db3b2bbdb441f691763951b26c0d192810114560ef4d3b787f16c988480fb087009e14643571d218bc57f8e8af4d43c58194efc4af3756dc721422a9ca7d76d8d82fa55cce1dcdd0ffdd83ba48b73f18b97aa40659054e25837a24d03b4f8eaf3d63d2d297a249fc665d33e0b56a73dec4daa9ecee632d4d6a56c6d9b31be0aafcc3433449e4e299f10baaa5b64be613026dc5f7a20e72f9f69e176e1ead596b2ba19dc13b6390320a049ca15f7fe3f27078ab91cb99c58c1c487fdadbc86171359162b47cf33ba1246bc3729126e00509ee84448bd718021299e2741b4fe0748716ec40becda8b49fb3e8d0764a70bfc6d86b8377a49cf2228781bb2a3d5386ddc7d40ae5dc40db603bc393b76deea66ea76a2a24f730839c8a82a4416ccdc6c4f5037e38dbfa36f903d57549444f8555ddb9d549280835c74ca707dd09dc06c44f92a14dd0fc44afa1dfb08ca1b6bc1aea0e0dffd0e3d1ed787a47dde736360713480bef601b45db0b6737e726d44cc4321f1e9ee4eb28a51d57257452ba3f79873c49efc440e4c3dfef23f2e081c67ad13159b3f1e9556159380c8480b13ac2624b60089fc8911ce3d480179f4146d622821387279247d32d44692a0345ffd6bce8d4a485a2ff75ba5012ae1d24373e065c256e1144a0ae67aef1a3f4adbb8dc6efe1d288e1a8f520364f0b42d9a3c927b8235df64916c9b4a85223aefaa89b56c943d05879d28fa4b72d0677eea9e62b2093c62f39ecace684febc9204bc22a055910a8850a820dd6e45fae78634f29ea3c75f7e0c5db510045f46b4adda26022c894a534c6e19a45cbc5d56106f6a13b7b34924410a47f242575c1bc6923c9bfb4ceb73e9fb049c4dd9137dd4d08713c087ee101b830a2c1e09cce3cbf3b466b2859cc7d4e5b6063cb149eef549c4b0e13692e76f29a0ddbaa9bf83b79be5de3f36baba45d89b88099941d1fa50d561d830721816b6f86bfdbe1a769c14dfd794dc71f1d1a5ab59e83b871ed89afebef6ee5d1caa8b0e1fccf963a8b3e8744460e5807bdb378757ca71f7060bce2fa71cb7acb98d405172e327f171cfff9fc55a784282797807ee27918a1b724bdf3cfbcdd50c861c2e5c8c6a2ba4c270e4c01597911d7baaedb2d3a3ff7679ed57f3267cdab0d231884e7887e6215e1f389cd8d408059f8d1422ec86395c57b52fd12287f2a462d84f0b3b085c8a4ca93d11b6c9ce545860215236517e33cf40d6cae4b2cbe2b0277edaa66aa6cef2f9b4eebfeb2fcf93d736c64c4e611900798ec128d5b9f08ba01266c84814dd7b0a7bdef1539c69dddb882ac9874f6dd624f4e050918bfcf2850ffdf8c4dd80f8cf07fb0da959d119b1e15c28911bf8ef1ea12df77dc29dcabfc7431dc5d5d6fd26a3eab00e1becc98d6187d7cad60a61b96a67bf0fe06fa00c7bcf684f2d890da30b2f3799a86f27f35d7e57b886fdcab72c093cf7325846886cb4b2a78cb457cbcf731e47a23191fb417f81e3a8ff0d7d68f4d097b0278c54d927d53dc356256d942c3a6612b5d00cf120868031a756fb2a249620a03641e2aa0e96fcd2a7cbe154f184d99fff54b57ad08337f009ee5d5a5611efbda32ddbebe37f0cb17696355b66c0e0cb79feff5728a36df748dede074ddb137e346fbadb879253f25017699d2c927b5c9317adecba4fcbebc752442bcf38661d1651ee8d58dfa54089e95b4b90de6bcbef2f5ac221f8aff526a3e412517e08a46af3d921031e2859b098bde3b0aa13540ce6bd1831885e8f8c93b82881b134a64358c513c0c66c9625324ee11578ecdbd4ded6f2f324a6c5ecb6e184e5fc8f144dd34904b62fff6b7897b6a1daddb28d0e1376014e5325b350b8e204d6b370c43ffc1f5a630cf6dac1db5b0d5a765e61754880a87b0747469fd1f5fe8886d3c3e0afc2793c347d2f33a9439fdc169e78f6322e9a40bba072d0dc6ef4e71b7775528a949b2b2632dbd8e66250b50dc5edc9fd16be82d73b5a55a0619714164338cc7e0d60926c22b229ad942b3217ebf10306d952a9545d2286c127319aec164661c028b309912a533ac7310bbd7920c84818b52cae77c79d60174d808a136a081555f5fbb9cdb4605e3779dc768b6c31d91020830020db54bfaac400ce2b2ab7113c5456ca35dc53b69e2dcc94a80222beb46bab9373b19bc9da6f906facc8fd59796bbc21ce57a1a97b06e40264682ffd4576153685842d23cb0e357ac6d02c6c4a3386e8a6cd1feb575e3242a8f2435b8f184ecde290398eaf7f83fcbd64f7ad359557cc0180b10b99050f792a4ad208452697a05f85ef8c7d796c2ba4b1442b39b1274611e371a6684dc2d833e0b03c1ca70c9f914b96a86ec7a81d4404f93d48093525f94b197d726f70e069399b03e2b619ce4415f6355480ea48f5aaa4710b17b9c123b9b2217f8d1c8f9b1811c5127abe766ffa0948fd9cb6f0a0977a16fc49b321a8b9605f8235c032499af19c770ed393620a87330e4758e6be9c39fc57259b1183f2b07cf1ffe0351baa01f394542fab6fe7259dff6674e18c4f60e6126785b9a6a9ab201bd4de2339b674d5dd5bd9e837d73a6dafb3f6d1b18ac801381b531728349163dc1d397807443b5de1b4c57b676ce95917f2d99b6a7368c1d52983eeef08c87072fa73be5700a69ba0d0cc0c0bcaafbd0c2cec4fc5f814b72586bd70d49113d40768274bfb40162e1de518fae235758804ee09201bae3769b1a828c9ea0c49723f97f593ac5f749fd4197784af1efe5932c2ebc1abb9064017cb3cbaf0dfbc04147f9881754be35066457d593c2a42ed2f445077279211bc3a1827551935fc8d3ff4e10b14c06a57bb45a9e888a4d950740d80a8026c92b7a6a1a279b007a556077dcd8706c5d1bf0404904f27450ce7733c705994c8280b4efb43e1c3e515418d82e10ac25b0f9406faa3290652751729b9da018f55642602bb5baf0a685af538467aecb9017b1323acb175bf17f90d99d874d55a84b1a1ebdc590316480c29211df61fc0f0442d20882475f820f0d159038776b4d0bc807487e057c79dfec34e9e23fd0b3fa949bf09fd615322d9826e211ad2d35cb372328744a00167b0e579e670f10be9783ee2c3ee619722b289f257db01d346886a41e7d0033ddabae411ff3cafea29204e4c3d130efba9a3ae918d4c8afed41a13d2fd01a04aa21983400b1f4f232aa2a7b5cf5bca6f49a49897a1f9362c777b217d6d220c5b8be7957d304e49cd88d1557c8f373afd3bc7ab9750e3a72146e3905510b222b8735e02ae6406640ccff4831bf1f2c7edd927e5515eaf1be1686dad9a8733c4222fa2883626149665675601e213b9e65de9917750c910c006e49d006a4d07d8002dfadc6fe951e41a02ea789b47c197e5ff3f8e0729c98a525d119721804b73409f2e4b8050499adfd25d98d9b6e54ed3faf811d892040006602050a06bfcd9e7dfa52829dd1bebeabe5d10736e49a601a2e3537831f3df25ead446928edbdd5d43fe83cfedc178254ec3369daa526d6540dd51f16c87575ff2bb78ba19c7415750af27d1b520551e43ee604e84156ff1fb092d729621c14956bfa9e0cd2cea12c7fc97a6d5d447d90d23c1376f9692fd2085e1d3fa490c72ba747b89627e3d62eea8f71f31a362b8a2d0fe655d5600bf5332fe121d5b7d92c4fdda73fd7e0d029b1feaf95df25e25fd8b25379e089aa61cf01feab7cea2abbb8fbe15631f592b3fd646f06385e143ae411c324d7f976289b764150ed2fffd400a3703ca0120d5742942e358c26bfd01e9a104d905febf2eb840031f6ff43eebce704fca0283ea8b68ed852df26c97f992a8ddd573850ade58df37beea51b1ba685648311871588d41c5cc2a27df4325e534b9635e295f203120509dd4595e3cbc42cc63ab74e6d82d5132f01fb5e0d1666febb2532732a67cc3c586a43414419530483ec4a875b249298346f4b0a04acd3e8314de3ec53451af5fe18f8fc94cdf60fd37ba93f81e6dac05c31ad43068a6dfadf9c90d9421b41f8d5d579dea585216c600c2a75211ab91eb5b75299398958368d885bf453ce2b7907a9d46f82e56b47274a20d8e0946acd4bc38ad9f943abcd70fe819cb72de7f68337977572caa74798511ec6c5afab7c888e6bf78709befd1a0629262e3faf18ca8a9c267ac529ca33ef5670389fe3d5da1b0edde42e7b13f36e6c91c25270a8f950eb0663a0b6fd54adda4d8be2eb33a4033ddbb011716840fd0d22088d93c5a92be4fcb7ca5dae3714b9af80e826f32f165b83a4e644b9887dda343955df3035142cb700f4254939cf2effbf46a78c7984dc741a8f8b894d01d8df5d268aaa2c5f49efea457d6316510a40b0dc51af97219e6e02fad174c9ff4c6ad6549bf19cd13ba1acfc83a5c683f53b160e4dc03c8d9552ec5c09878d29a1e2ba9e2b6ec70d8b84e79d2c61232adb6618ebe044103737217603a281eaf59126a5cfccf0a8f815bda2357d42819f785633872b517328400e32e1dab7eedf15943cec488956ae43e8b715268a160db59183fee5a597a8fe621faaae525a38f434fda4d1c186b2577c0cd95cecf2d23557d2c5539ec6cc1d192fd0ffd4e3cab4249d0e211e4c2b568d97810e2a8b1002a4ab75d6c4dcd3f2038d659240a45faf21073beea14657dd6eb24d5ce3074fe5399e27074c9f4b8020c8dbdac9f2f5fda42191e35c42db7204e36adfc00c379cf81c9d7fe76b332f5f163169a4a77faa5d437230f7e3b77a693e26f3e6740d32cdf78a985f47d7f50f289b9d6810f070d140f09b702289aa688931c393480ab8bbc6cb20e4a2c1dd4b8bf82350b8f094bf1e8a1a94c7434da2c854bf885a5836c270700300fb2cd811c4c78276a3d9c53cd1bb57f147adb3064ffcc7da138bfcde3f8f69a9a6dcdbbdccf45c3f3f58b83210a1fde38dbeef370ded7fab71a4e531a622b781f79032a415b40d753b02af71fbe4aaa94429d65a79f1d2399c3cac60c4669319a7fddbdb0bbc4ef1f50faf1ad14e6f2762ae15f8fc213ef191d52480028f3e365f91c3aef352c49a344b41241cfdbe72cbb0b9dcb4bd9f7be4adf60f12eb87f84d4fb2f622c1cecf3ca803e6d180c777007d47b30c1c1a265833ac5e8542ef7f73cc687e8f9e57a3a317fe8b1368d4c0374a3e59476c3281f444cd044ba3e98125de347966f04126b18e13b8461dbc1c03c109390a121ed0b113695e791b3a450ee1e68f687f60bd5113b026ab49be08a9f6c24bc3197910d1d067ae9c1eb21a1984869560edda42f8c97ea80fbe1cd05ad68ba3b778957c449cf911ec58b038d391c635966a69d4aabc3dd4474089b239978c267c473c421423759ef46f035ab4225a716b67a969609cfc0194f8a1f2c57c80e4082108107c12328da4afa8a8a02c7aa0235751414b349579ddca65e3bdf1cf9110f37cb1edd5f8b050b3174f6cd279b216c769d402fdc4967c458580179d1b82e964b28a12204149cf08cbdf2b53f5cbdc26d5f0a4c2351013c3ebcdd0c1c7d0d09ae6beac224e20401b9caea08fdf5be56328690db1a6b86f635c2138510b00a70ed2769b5bb83c68594b384a3281a69d41b575ea7ee927125743b7977afac7cc19790c9c65d5321a5bef356d5d74b4063185fff0a91be1897c582475888ec0b168a32e05b0aa6519e4105b61f49ca6dd52c5a5fa8a941c093549c09ba0dccf5b26dbfc9ab6fa32eec070a02c5bca25139fe389ca3da54be49b6610276a3e45d4f43c5703192fe18c67b8231322e078c40d70ba90399c7c75f3d837418318c04243dc68e6af17f9805546529323aefc6e73f09e50bda9acce175fc2f23fa2a2b08aeb43eecbfdc98249aa539eb25e7efcaa3c10b227a9de63b749dc46736464f9ccd9a97675b12116fd97a24505c303de10c8ebaf825890687f1105411b2f0407e641aeb44292059217afb313ee67ccc1be0e8a46e2eb7b329808ecffeb44218ea05fc1c096343d4a3c95b03b05d65a3b363150359928c9b4d801cc1241bde393501cc75045b25cbf5909fc2a197f3e2969758a893c225507c03d488530bb4cfe83a6b7ea8c5350841a0438bc51bae70733e413e2eefc43a0668e20ce6e7969f9564a277926f81148997c0884d7117710db85a6918c9af209ef8593d36a7a9ee239b8f775daff0b0930e97108f10c5228aeb389b4b30937daa340f6fb175a823b9517bb363faeeddb685303eed6808d3ce5951263ce125d3536f0665456e8fa6348e3dad9c78ec218d3e723e83ae91acb62e5f2ba324c36c66a616b3bc5b66a3e007316ef69c5cfd8bb0085daca70a71b3dd60361d8956c1ff2a50ce25ebe84f9c0225a3502907e1a9529f457dfa38c6c4ef8efb3e9eaa239d9dbfe82ae084416f12a365dddb4d9824aa257c097c264eb1ea959ce3ef2808169cdcab673fbfc16d1b2a58e7b9cebcdcda12268cbf4cf3e364c92dd29dd0aff930fffae9579a8a881450b0e7d634c24cc9448d4fdacf8236547afd83d2b42b5e2d9b874ac8ce14518714822172d9020a7a9102b7376887bdbdb89632f56160db49e4fa1b7b10c9bbf4f07748ff096a1e537c10c20cc43d5c696ba6811d49b9fc6e89009ccc7dc163aea7df00e1769ab9dcd83b8af301a96d823f8a3eedfb78f9ad9a98a02f2af6adf9112d419af197c2614dbab75ac610881f9fb7c37bec0579c427ca86d7eae562213c7a07fb07208f0538eecc63b97e68b24ac1111755d8efc45b53d61accec6fa60781361f7be0ae4b7ede1dec93ffe306f1c96e0918550212c5d2d6f9e3d50c8497072074c5a7fc77d37e467bb6f33da7437a6bf240270a44e5cce2069a8e6f1bee06bac934457dc39a8c21b897ec17758952c214e471c6c9f22034ec63806c33a1255cd88d95420d17a270a95aa13e711e793123952698ef282b454932e99b53b5f8ba9dfa221b067ae049db2bb3f12c6261cd5375e6a3c8a6fcb4d0b0ba074966650e5d4bf43a8899726906c4ce6ea96cb8c4330a4e2a21348306ef90842e4d8be26f303a177fdedf454342c90c8aef6e66ecb01c118afcf858cb09abea7ce80cddfdacf8af3c4833c73c597d5b44ac79af1a7853c6236b6c623075af41d5bfd5956af292337daa2dba1bb524bd959fbed89ee40c74ba48658cd366f50b739a7f734a03f081c073605a1496c8a6eb5c80a4ebe465801616ad48912a319a9f769b8b6711bdb6fb3a563979ba2920da1e69ed1b6433dd74b6a03e60737a3e1b76d6a3cc4c9e5742277442c28386dd4026b756e8dcd8d41d5cabc939b016de58a93edacb6dc6f67457fdfb8db37560235d4ecc9fe21f981d68bb85bd77bb4df48a52bb2519f3fd7282e8273e19571206868e6258e03ae425dea51a9a1ee61cfbfd384f454f9a3b8f371e6908f9903f7290388a03475caadf4f0ab4633bcc4082ac42166051b6fc8f5b09a699fe7b6cf2fd39b828b5cc06d4c0ed46213f300c638cf52023b98892eafc6c1f184a05bc4b273a9c3145e896bc1fc50d49cc4a8836fe6884877b7d5569472ac52f026ceac1eff6f9a2ffa894ca10d8adc383636f39e5092f2d81b9d4a8c614e6b869089406089e92ab989b063a1a659cda91987e6244ca335a8ae84e004e46e3c56a659fa9e01bdd1bed32afcd8123a205d0b179e400b72a8cb018f48876e6dd686b33b0c858dc16d405e2f259085faadd1689c87e27ab5ed9b7efcfff9024dcb6381d371e8561ddc402aeff089cedc76f7cb7f8b53a318c2c911242422fdb84339acb505e58b9720fb1c1bdc162f88f25a1a56b4a773a6f92f888d05e7ebce11b44ac2415b4e20b60d0ddb1537d31491e8df4efc073ada3f94a65cbd71ec1b6703db04e6187af708c511d97b257e4bde59bbbb28598d8dbbb3b50b50562f7e00ec97bafaa57b5ae5c5de37822b1c642820717425d94a6a38a758a81cf18fbb0c7d105f33e0f334c12557a686e4ff7814b956d3e4a730f67ebc8f03bd36493ed2cc2146c4ce76522e7019bdab0383a2ef0600e6e4c9483991ec221fe8a46e3401d988351ebd439a6431d8fcd74aaf35f59476140b0816cac6e3ee4d1f7d1f90e83662f68ec72f01b36fe30297af591a9b9930e5ad2b165a99069ef272f81bd4bcd335b520a98cf3512e0d77cde84ec3dc0bc3f381b514f02e4b89b2c3bac886457841ce521ecfee024daf091c8d29da615a48e634a2c9bbaa4f5657e1fde719248baafc08f63a0cd969e1e52c9566ab415f8a1f5a7bf3232318afcfd4169d31c0725d3a84aae29e3d633f8225ae5f9d3aa80b5902e21cd3e042dbaecb81eaea97f8efd7a173a62fb5510414bdd921f157157eef41dae414d792b4d4ffbc0089be5173eaa1b313f328e412c8f3034da64f84a464b6974fa20dfb8c09a76aa7944180f4a6cd5188c086379436986f699b239f56d4d0c32ebfdf4a24cccfc0479a9fbadf7f6b82017469c743e75d31a10e3f18ad71a679ded3b30009f9943f2f122233097244f1de122c580d2afae5f4bf0d95244895f8de5de78b9775fcdb8762158ec523e7b2f8d7052e30b7e50ce12651cb4da7f7ad16f5467b93da33e415d4b5c082e4c73989def579c175ddf2f46bc7746559a3263e96cbede4f8330b2024ea47af74fe23cb5da36aa5ea8a0e3fe6c7c4975a25d0b4f3b3bc1bb634a2d517edd69d6653ee9a90b950c5bd2f77474651938502fb6e644c6e7b9d67baf1756b5fb50f9a52cd325a48454784ff5d1d08c7a332360229768ea407957b89075f5a6430bf6fc409f18987a11be839facb6321cf07523864cc689c562b949ad61999f2f73acb1e122cadc40d47a792e5a9cf4e83440f6eaac028a938781e3fb38e935d083767b1c8e604bc8b6f658dc187f9d03f2a779580925ede3e013029e5dff0821703b77bdf89e7c3765ea744ff2a237b9d8c8a72af15c205653553e91e65a9fd7088124a02138a9915d5653f5c78cd23bf9177b498baa1106dc6fd9669ebc66bcd4d039f11fab0b11577b558cfe041f68adfc9259bba468c2d69f81805c2eef7f6a95d30a566181c75c75cba93977e7a9733cc45e674db22eb6e3af23e647d1b2851f706ada7bf29294b63ca9b1dce530900549cfe462b77ff672baf217eecc4764adfdc3f9bf869b2eefeb16d0fbce8e5f3b90a71a286eb1e05f8c0398a0157e8144c5de1a2f8a6f998c75828e7075c629cb69460940b6dba5c709e9b87174012521acd8a070d9b7f394a8a50cbd1d9dce105db43a01b423de543e1f4cfcbf317c7e7e1261894670bbb2e63e87db45298fca6f65d54e3fda3ead4278b75feb4955768f8b19f18d70bb1d77514998ebc9272fb9a11a8afe4acd165b41da158e9cb3e9b9fffe38768eb8b6491007469f365cb39fc1e9e3d1e70c7b38e2f1c040cc352b9006536ae069f978acdeb1f81d644b5bf533207165e18cf90cb60530a802172bad63185565fc6bca9ad9ec29166b0954dd4a76744a013071e6c74b41ea1b9fbf0e2c36301b0072f3cc6b1b240ae097e6fc6a130c552bfdfd23f28506dbd6b36d200d712186c7acaf9e6e7957cd1b277dcd89dfd9335c0e842e027a8e34f0f3fd47dc9c2442e0ecd903c4c46056178a822edaceb0d635087d348d9b07d755f434532cbb8026c3957f8a6b6715291803f6bc50a9c1ffcee8b2bc8bfedaa1ee1fbec951927204c6d6b144884c0fdab1e828774c73343b44ca6f3653e189c772a71c32d243faad0f2c265a6df4c636b80d707a16b1dd7580fef85a3639840d11241200bcec7e1f71bf190809d6251f324e497150364b658c9baae7318ada16b4de4789859eda44606718d84f66469654825329e4dcf734ced2410b94f76bd0b6a96b691dbe8cb9084ebcc88469d3c4760ff16ce35b85b7cbf3eded309714a807f85a6441bb5fcccaf2a463cd237572d88f099a87c15e0a185e41d832986b52fd9c6ce3972da7668b52cecf53373cf0c3c9d850c515503840b862feeb1d3206c3fe37293497965cbc51b64d3623d9a76298c127d2098081958ed27c61e76431dfed3ad942a9a4703d54838ad84ee0c8e018d4d921893843f2fb6bd1b8bf8c369a845029d53684998ca99db6306ec530fe9058f5099d85fe94940381ea191eec52399c01ac77623ba64032e6a648854b0dff9a52cfee8ec1ffb58b50885573ca7565e03b05fae602cf20f02eeb65fd9e655cb597094986d1efdb19493aff8f8decc4474","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
