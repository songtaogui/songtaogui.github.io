<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd858be94ac574e27730fa2ce2364e9da2f0357e5ea2b760ebbb3843608da26e846ea82c2951387af44c688725d4a7ae649c91448fc3c594665bbe615bd7af8863dfebeec29646a3f5a382d3f765b9a49de2a931b20ba2686181e5261c4613c1de319955b819d472bb46780be8286e7c99f3d29cfe79237787e9627712ffc94011d256789e25c7e74fdae541b6107d9665f39a981d1396dba5eb35fca7fcd8fb30db39e24772af56d47c50662295d8370c32c7d781684a4ca6a86123abea9b304abd61c64fea2c9ec3faf9211b6ce214f10f87f96cc1371231276a6f60c02c5d877c925d1508415af90f2ed48b12d789c772ac9883326fc77fb6331ec91febe56e5ead86b45acf9693bc8a9a8da32592f69695363f8d104326a5ea6bb28d05c23e9d547daa3209bf6be9adc4f92bd2ea6c3ad959e5114066aec6c14b1fecebe1e947e3238559fa65bb50e785991f1cb2a6f097b7891a6beeb7209ca32da83ac696e7569a8f38809a0faade3c6e8334209f99c494b30eb4609b0f7c01c4fa80354fb599b980359008f0f6a238ceb88c05400c4a9bd78152a64c6b567ea7093cc327b28a212567ad0ffdb8aa3c36c85bd340631719b8f4d36c4b1965222e78d5d6751f8553967336d63ed33a19e35d84704770eaa769eb7608164389fb91001288017b5ebaafc1a046632e0d4d15938d68fd0610a0d45b1c0a469c94a4fcad43cfd4ac0a9033fa46c1be6f60b27616a4dd12a8c82e09d17a58e2b021270dda74523c786c9e107d775c10a2b4c2895fd781d22afe862b3fa598e4a843dbdb86a19e180229d4cc5ff4490705ec3f048ef7c8d4377f4521b3fe3e0804e044f1887e0b90010e30c822901160bb3fdd2279fbf43fe4c8488170d32183b585dbb21c1cf5d85c9d8f45f35be693eb2635528660990e9e74559933ed137de3813687ed1a61238eac255927c559b2601ac9634d7c1d53179e23476b06175e901674e5269cefccc2a53a8d37c875aa9bc7735406088a7f955d5d9da49679992fede540e8951d38ddce09ff28712a1ae83c1f3a8bd62d1567329d13976ff8944a0a69376efcb4ea57fcb535cc01514b80d61f8e18489b962e0b6ba8107562ba8511b41c3226ffddb5a7d9cf347906c06365bba13ced21ab0b4c624a917a4f45371c9fe9a10c974f290fb11ed558f636b290e31712f4d3962940094100d37f692449606a30c316f1e468dac6785d7cf80f77b9762a2dec1d2a37fe935490a91f98cbe5f230ae4946f680eff86ef1455567ff4ffc2442eb597e37a103018ddbf79f9e0bab10365f9d0c479e6f190b970dc3de1526d0930218d2f389bb8a6c40d38096142069420ef8cb3be4b4cbd65652c52a2f1ab0c252fd862d974604141cc6ba73f146d407ecfa64ad897dc48d1705e91268f385894a571402e158e3e35e26fad9c98759d6173dfe771575e32f26b306870f91db4c964e3d5561b0a7884ae2af5f43653bcf446d4b1a12013104bc9f75ba3ebacd607c6c77cbd25dac0ed16c9870fa68408c25f7d334b5f2febab8ac9381aed5ec0ba5e58dedd5af6e6633fc4cb5d6dd7763c919a04a0d68850fe9b32743242a46e13c972e7f79ff0a64cfdc403ac177d3bda888515718e01671de6d8c48d06762502e757d954c19f9d6e7c7dbdebad2b7c384112d9374c17a52ff137b23c2fbd74e34fd6ab92771007f354950a7b1305ebd53ee86bdf5437a519570189dfad4915a2028ea993f914a63353353c38bcdde9dbfd6ba2309efdfb2bbdce1893329dca6d4068aafd0a333dff0a3b082da487439b7e21333fbae9c71df4fbb212998922443dac3d06fa8b54db49cd3d9ba38b326a77511a343f455292a0df23ee948523eebe8266b2aa0f5849b02df9a1ead2c7656ac5a83bdc6d82c67dacbe5ffe333a35f324e5aa8754eb17f23915b704971311daeae92ec29a174244483166469ecf700de17bcacff2368ef44fce09799a44d1b018937cffabfba3ca2a4b5abb6775f603d42b8216da3287535dc24d59fc69fd966308c3eadfe7a5a358938bdb843ec9f71c22c5d7c0e6c89933de6a981fd3350d0dc51107cead2639684011cc7f8c87f556202d886ba68c981bb271af6aa079d2a50e06aef577291449ae4f494dfb6edfcf744a588cbcd2d8f7c029635d9e1c2653f984394997bbbf7028f74f3c1cef197e0e2c33c0fda880c6a7ee2be1c54e1ac2a5f3141fa0b72ca1d688e8765cf2357a83c829eaf2cec68e00567127c51bd0c0cda5bd4e8781628abc1e2e1b8d5d08625ae44029815bdadf38d8a82aa1979a34d9587f3810ced1518da2a3725f8bad02711330b3f74523eb79232c8162767a82a4277ae67e087464a4ecf8c5cccc01d1f51ddec6172c66154252c88375a2322217bff4665f06c4e588cbd28d69722506eea3af62a4e8632f89a8d74a86d3b56c3d30513c55bca86ae4165d8b2e960d25055300f9363390f2d32468503d2d6b51bae1051ef346da29ba17b8af5c7b8d7eb6374a6f3932cc8539d18ef3b3abf8cd3fd0fecc83f7acc014126d1ca6d0c5fe75a2ad7a597aba6830d0f9c54d3d7d455b4fb485ef5c541d54321f7b1b44bf614ed76a6c8e31ce03f8633224723d327f8bd5535a591a7c8bbbfe5eda7ecd34b1e70368e3e0ad61ac855c07d28e255a368bc44c6f34c6b720ff471c47cbd4741e80333cf7f8fbe23da9df45a66e165dcabba65446473b65da34d1e1c3b24aed80ffb849798f6302f873f659bf6795655d835df6c093018353fcab46efc4a50ee430922affc0d6e43aba13fea0b11be1dbdb8c8c72b65639597a9c225b579124d2ccf64cce6510c7368627969cc5b0c37fa074166ccc177a5634dd1f8ad80c089a6ca305b65b53caca9aebc87973b6b7a9be189ee05cd5dad78ce278bb1954c0f491820b2b441b375c92f6b1ddc080e297c0e26b00e1a3c689694a2279fa309f7ccc40f9c5ce6564875be85debbbc6feff3271bddb237e5aebd7367534bdc2c2ea32f424b016321bae2b3c4fe9048a391dcab87416e56773db8bd85ab96af8dad7faa42fe3409d7dbe096118d8d14e8f9e0be3a2d40ada8e14f042b19305ef67a0d59187057546007f447e36f59bdb9bb62dca94f258f035dfd275026850b238d3975842f60bbd9efeb725c7296ec4ad986a4c716b66c53e093ab45a474d1feaf0aaabe853b985514795e6cc88f0f09fd9d6160a31597ffa35512c0904a2265856d4de0eaa1d5f6cff945863c0fdbd4401274a3f81778912bbf7b0894a91ec7059ed580ab2393fc6cee9a8e6ac52392342a7976c57f3ad5078ba197d575f47b99877d2ddb6606faa1a0d2a710575b94db3fad08eea28a017da986face5c21ed05ed76df52a14c21cd8ccc913a05ec2c31719fb653ba9095a7bf25e26e10316f7bc97ce789e1408b802beffd8f9ded0133db6940284b1bb8ed88c7ba9fca39c26b77ea8ef846586c033ab26235f61bc7a46298e85a4be70953c88d7361a0334da30ba1d48db60a7c125e6dbd78eeb336dca7791a34ca0593dee394f5909f164b1b3467a5e7e7008198cdb974d716ef7d7015f0f0d8d9ad8534f7110864e366c43c2afbaaabe36416977f3f4d1d7bdb08f3fbdd399746bfd0bbc5d87f582a79331bfc2a14aa4c2b1ed41d1ea571449f07b48351f028c21759cb532eb96e6f9e2c38abdc7329be8bd38787efa3b057d2f45d8899add46e4e52abe31d35b15d9d0651eb12541c99f3224b5bc540b0d6526a160ebf7725987c2f091edcaaf7fe2c0695bcd8fbcf8b9dc9fbd4b202d7750a901e0efd4325a9157f275d1c93e2bba2aafb00058275f240930933354979c1aa64e221f567fcc6e772cc46dea6d8bbdc892c42f4d154003a06e53ee224e1e6775973ffa86634975617c076f79a73160422551fb96a2e2fe2fce29c71fcc34734c9b8370e9249dc2e546f56ea45a5830f7139bc4ab9268d633ada114facce5a212213b018e197b8be295e3638e4ad552310008857b7778a7e767592de39fd4ff8e41b751abb63bb479da100cbe4e094d2ac0499d2a3bf4a09ffe55216709654715cf564041d04953a24f3395ddca938adab237f4a71e8d077400f3422c1adace8a2c90e14809ea8d77cc59131e7751fa8386f70f19732fe3275cfa3b78907ee129fcc48f097867e3415cf0bf0f4081c4b9651e23f3761781db3711662dba26709ff73a271513ade40e3850e8553fe88625586269b98ff1f37e7f99c99f4406ca8bc168f4f66e12ccd9f3354e6b8b341d858d44a0d5db3c70cb4508775e99db7755d8b7a4ba8b4f4c5a0d7f385e48d6a425c513d7c1ca886a29a38980dac41de51219caac039b0c5cfd2e97a277f6c5b1f2bc9880b6c2bc4137a0f3850c382bbc6699bff28aef065f35ea853ea1ed6604dc40ace4094f2c722ff8250d51f2818b54e1cc1990c5c12ef723041dd2013cd0f4e16e6070d2590c3b08bddd3ad409e723aa560de23bf994a256230d46fc418e348815c51069cc7356d2b86edd1101d840399e8ca2b8a24afcd8f6bc4a33f3c7133d5ab81379a3eacde26a953524f906b81ed666a760b0e2bb0abf32ab26f5cf2f0897542f487802b5e05f4ac23fd990d93366644a0b42c4a82221d4bd8e5356dcb242122b8ebaeb79b3bd733efaf40b76d139cefa4e06e7744db0b982e6cabfcad11d8d897cd6d7001f797105b921fa406dae02ffd59543042dedb159493d79a72e0c4601193fe93042fc68899f8e7fd203fef14ebbe8c0b9228e5bb0d93b672ba6939501be7814033fd5b6b4c4f394c88ec852b515ffd12c2d042df2568fd35ed704b76c45c48b7a277280210da6e32b5d1b464f22cb9235deff31aac5ea6ad91e67b24c4b8e2259d4a7aa77a763936f4e2b22821fd8edde4e6d80f49b00b5ab640092655578f98abead4caff09c52c0e53dd7c7c199cb03fd4a955b96a1fee7e0daf57667948859e93dc1b54028aeb1886b73fe412f6403710c7f51b3605f9c46490bce685bbf9e0cbfb9749a05b4f61292fae566d4a95737a4148e87184e176664ca2b17b49b5c241c82eecb09599094e002684bbde3f04b5f6b7e741197753559977af20d67ded9ad6c6c777319697472de7167277f1ef8b7b115efd12957e383490863052f24bc7890de74245127d03ae3815cbf16511fe2bb70486808d646019e220fa3a4090feabeb14e31c707cdfe2f3f0f1c0bc9aa1a50980f8c716e89ad0078d768f50586e45bd7487dfc662119721cbd500c2cd3326a4537db10a1d59e00673bcf7cb8424bcdbad8c82858851b2279ad30ee72bb8b43786eb834c7fa3eeae281f13527727d5542541cc5de02a12537ed0812264bc900d7f257486f45a89af3b88e7e4dd6ac54ed0dff95e76c9193b343b17a827cc04b160352dfa9fbc0ab85bbf74b52c551c335c0dd28166464ebc295ae62ce963afd88fa88a5d45e28ed28468fbe0aa105c8720da5677b53cc6b34cd233e90539ebc87994286753c28d9c9d8b3766983ad2c37579266e356aa6b4bfe5c4a8bcadbf210df4def6921bcafa7cf44d52d6ecdd25e6b159cd2fe84f3e943ff8ac2ba1c56501687db53d5f7316f8cdd0834d44fc537f6143c1098ac72e0a8ce5224b6d1544874aea820ea1f06a2b32739da3fa00892c6cabd9f94fd8ff77553dd98f1553dbc0612558491a1d40f359a72821e479c354fc10644e4f1eac0083dec2bea407fe517f9c609d7cf80dd70054cef847147f4882ad8368daa89e917b052cd4e815b3ae3636a70744ba1e5a9acb3ee00e229e79f0a5cc842e75c02510bafae8623f77956aa6aef37b3d03df8767850f4067a754a884169d2db15cd74fd81a6f32df1f9f6db6dd917df3f3f6a2775f94901d866300b54e11892c8f7288fbf5eec0f43d4549b301d0ba2c819047cca2d76e1b346db0eb98d1e46678adb47a7a0338dfd505364a3aa976867efa31f2e370a72e1dac976234e656b5a13128819ebf796309212b915417921ab4339520ed87e8af102e646b9425ddae391c9415132cfd31aaf3bda8531c43f8392d3b96ddb931910f605725a7938957b4bcb6b97aa4e8d8fb6397fa16f47549ea93b48f2c7ef96d14b190132d6b3a36dabab7120e25c748983bb4704be7ec4a7acb1a26df3cef6909ecd769740aa2772a9f05d24530d2d39d3dd4e3fca90eaccacfe19385bbe4b4b410e0cbcd139b2c9b763e25d1413f591cf4b5d4e91e78430c6cd796d369a0c439cc1a2af14f5d53a2a6e6ca1e8a576cf566b76be49793feea31a7af94dd20581efc7055701fdf4655418b9c8db1e44b34b5764c0c3c900acb1c6d8b4cd0fb3fdb81df36d0d1d7516ee327c92f555cb3c108bf71c7fdc695ed108b678ef3b88c1f6116d6eada88282ae2e8beae4e8462487235f8e5b1f5c284fefb3ab8d576980a9f13afe1ceeff06c07bbf38b1fcfd8030daf6a9598dd2e301b9dbbdfd47887359461b6afc4c7f7c325e5929382d3c7149cf994e0939818b42e493fb54cb1760bea3a9a3ece8b98c375396736b80d0469b739d8e2d05fda8c41a5fbbadd1ff7af6672206368beb587cfb9c07bea1956333d25074edce4d456b8c8c6e2fdd9f75959f95145a11396940d175bcfd84861b1228e4b77f76e3f31d571f241da2d37d863b92803f65eeadf557765818e5196eba6b2883b709adb7cbb48746052112f3fd2430e1c6c04c9a7c30a0da43a1c0101db54a8cb2a4a6e1bc736b4c5487b0ae99846105ca1d7dccd75597ad58e0132c1997d6e09f93195d9f0d8d0352276a03613dec6c614279af7f88030dcc0186ebddfffb4cbdb9e9f82fc33d438d4d4fb1c3c2bb3a059bb65bd52396b016b1d4abcdc0593baf7fd6505a63e44a41774381279660e798ddcfd58c4f65b990f49cb108ab5c54870cdd3be3373d1960e70642ea6c8523fac9b66c53b36d03cb9c6b8d114110b629a84c5d4d87860b6cad717e0dbad8237a256690f106e699adbc21e1c5ebe21d989fd6393071e3f5e949a578a6b2e1535a7b239648c1a35e9827119e45628e5d9362308da9c3cbf18d40b1792807038ce9096d77709733b54e71b2463060b5262d3409ab40680d720368dd75196a25b2d999878b6a031355a2344b3788fe253c63a39d46afe03f0f5b225bf3da511239524ade5d4381adf96a380a733eb28309141e67319d706c1a73858281f178e37751f13554f5c3ed6f0fe5cbc1f59b8e40b8e669cab52c00232d579b9f9a22a343edc9173b1308666829604d3be4f53169ac7ffc7cc74c273afa1e7bf4862c5856c785f0dcea29b7a76dc15a57035c22357591219e63cb51f17e48dc9e65df97ca3e99b0d2aa437eb079a475364135e44e9dbed1f9132e5c42035fc73950ccc13d69f3584ef4f09cf7dfef53d66c05606e5c176907a5590c349f4353e5b10543e86cf24de78bf46c5ab21c95bf3c0984acacb7d59918205d118e213a69a15d3723108e770ae8de57a89814c222c2c46595f8c66883bc3ad2ec25bda1bf77c5a6c319103ca71e59073372ee836fd9ac072ce3273fbed2990bc86d8aef93c198d361fb74bc8b4152f3b0361cb60515b682ab50249744a7baee61551be0e3751c63c563e2c472b98118d3100af5459f5b71969879d4651cbf9f5772700ad96caa37c3366eb7d9e9e70f980154c85621a0a0b5b24151073b81e048d82f77dc0839a2cf67d2fadf96a5b55de6430f8a078aaacfa612ad683121f4351c1d7462694c493debb2a6e72862d9b14176d6ab794b391f240bb8ff6a32003ffd938a24568d5fb2bfcccd4269da62e2b03c4de1b75f50b7e29b9a36cf7b2a2bc9ba623eee31bd4ea1f177c5b95e7128067dfda441317f1a4c56ce040a4559520e7a5eb20cef9334dc28dff483fd1256174390dd19195e0a8a8bfb743411770e281f6690b62230ce31c252f47eee26dc6f4b786b26fca4bb9e1bd3718d6efc479b6ce3b16de20c0ee9f14bac1cea23e7d14e5934cab2c8f59d2e252ba621fcadb22f763fd42f13b1dcf74790325c5ae649a46224dee6dea12e0e41bc2c06600b0de31d5aa9581773dbf76a6c428de70368be78d728d5837be05a3860bd656f708a10f86a290b5929ffa24c1ca024be5f2a37a90154e6db5d9eccb436ba4783b031fdbc7cd6306c30d263c86e668aa6311474c0804d6d788cfd0f0960edcec8c1a9576d770043adae5cbf470e18c03ad9fe9797f564bf6c7cf22a9ffb761d31b820f97ace7364781c038cfeab922b156be0037c6965388afc50777cb0e249936cd762b0a25dff8f84d6f0d5061653225e70f2b9ed8d3898583e2da6ea418c732150a2e0166a2338d840d034e38b395c9193edbf864c2185ebb4b910f5d72a5aa2517ff1e68aebe15d1767b4033aa10f04c68aecdb1ab7befd07c771a279fff94fd762fa8929c4078afbcea6c64d13604fdfc6e17de695f4dda6b199918ad5f88f65ebc75ce31591f27a383a63452e741c6f8f58615c783b2409d22cdda638f4d1a72a59a644c3d4b7f2d4b10ffec42747c93476e93db0a59deeb68670702a7bd03809f7e93d171f5e3145cf0a2145478deb28836a62117877b544f9da4e69736e353ad4f09d017d9922a0edfcd619665c940ea3cdd9c45e2ad393fed27732b0001029954d34883692d502614c3bfd66ed30eb8e7293c9f5404e3f926cf2f9b565a1fc8364acb5789c3c2d6968237dce4001075018f04601284393454b581575e6388b7a86614684cbe61ae69c3c44f27b8fbd1a5bc9031a39838a7d075f540dadbede9bd42bf7db8e15e2134425f965c82d6d99f392ab570c79ee2465f88a4de076017e2cce52ddd52be35714bcca2ca264c7f9143854a4c21a6cd1ab52bd9a78990e152b5d558b2ff219a9ee9abad28a9198612de5e4b5db846b087e7a8bda2d615eafd047424ceeae177ab7ceee5b70199582a9d65ad4a380b27bb9e17aa8cac88eaa654e447547fae2a9b91ceedeb6e60e2d1acef53959516250d1d1745d85a42b23ab7447a0559c12b8917c09975775ea3240c8b70f89d1a811644873018bf11b050ce425f381bf4ab2337a4b6a81bc12d0a00f8241e68348d51347df99966de6bf9f53146b9695bf28d93531c1992363e58bb4c7c967aa6b90d9b7f649028549e7b3b20cfe93952e951b9a09e1d068bfb20aaff985b5697346e41682b6500470ae4a767a4ec253a1c1c33df2cae43a47219e51631b42aef263f0923f35833f1a1d4c95f5e88765bff0c546e6649acf80e508955e595eb83931cbce4149960e94d2daf3630cb67691d21f60be163134d5df3f3ec6622b518f24c22875e508c1568ac4d6b42ce07fe0fcdde69be6ebe601a319ad05d3d4dc3f9d67ba87360865d3e330534ab5a8a06f30043983e539facce4afe180a645ca6f9486cea9a3f70f6c7287ff88aa12118712c280048ebf254c5242b908a39cefdcba59cc27564e5ebca2a214a3375cb4c7c14d5e4cb9ce48c8b335faff2f6655562ad10b506f1c9b16a2e09db8ac0384a15cc14d7968c6a66078dc3bbfc0f8e8260d23e94782d982390ef5f540ed54113027bb52dc4c10e2345af33742c03d819f8eada3461922e09c2933e81d969ee1902b60df864bfba04d71b9e652c96dd1a0d6cdbb7ab93077139b60a3eaedf12941959a625d4daeda163fc2c5fa2b84a4946cb1b6f297a3ed6fdde64ab3e7e0449073ea22c75b17ddf30557991c17424bc5a405d13019fc28f7bcd587e360a62698871aa6df5dfb9180c68f03edea792e32513345d2bf147ba6fd3021ef879fa22a3608a876e1f6a1b91701370dfb0e2e88f9cafd632af4fa1f52d7223c07e61fa8bdb9e1ed476cefc94b04c5da1cc0c790289c4216e4fd11674e98bc390e01ff1a872bd124bc1091e3eb609a4f0bc95f538c3e550105f7531a52855bcaa727ac49498b8c2ce0bc354560a3fb4915664f7116b62de1caacee42277f070994d8a74e1354174dbf828675adc372d4fb42c2a1c081c5de50766ab86b3a79a5b5fa74fb8186fea89729e305c568ed811168259c6dd8dc0be6844292ba2594d902af72d29c9ccba1fa98bd08cac830cdf5d8ae10cfdf9eaeef5cac1eeb7449d424ec5b3e970ad119db8be7767608d68c7369c195e24e3c5cf42b27653cf61c38c064986a7e3ca0c856dd67744f0622e62c327abebf8af30464f6b1deb34d9fae4d28454c86d44357890bcf34eef93d7a03199a411606bddbebc0042b77ab2e9bed15e300ad4b88057dcf2360a764370c68676f2cccae6a01335a3be8896b6eb0272f3ef79a1af1ba7a3322c2d81a30bf6628da8117ef5d4b0f443b9e5a8e1b99c9fb65e34117de2c777dd21efb08b75dbb117225e12ac69f937ebb37d506a1545f82f520eda8f80266fde67fd8c4238beba50653b882d216c1b4ed70dba3d73a21609f15da5f1de82f515336343bb615d53bc10f4c19a23cd8e0899da3c6157f9e57d3d042543d46c56bd72fcf630ceac6c58111f674ee65ff745bd50c0fa17a1387a8b12daedd4f6a893fa30a80ea4f66e1fb22ed41647afcbebdc2fc32fa60b3c65bc888306c19df2dbd6bb6360c4cd2d75ce543c2703aa45a6bf2e623b6060a1444e65b0304a9aa6159e0be138804d590ce00b519ee712adf251de30e59e79b14b8668984e128d0bcf832b464dea5ed553a8c719fb04b921b300d41c4bbe978b19ebb657af2ab20b75e1e36bee452a7d163148fce0f4d4fd7ca1980c24e49273f080af877ffac7b1f4ebea3ffbceea77cbf4ac6f98a02a21a50def8c596a16b0b230f62cf12678c09179397587b3686144922a802438ef4eee539608eaa55f29f7a204b2d58afa82722351504ab00e333b70c9989935f064062993f3a7c08b40384a380f58192206308b3020f8fd2a172b232b408e063c7ad87141b094bf1b66a29eeb522afee82a5eac26b3cd0fc66bcac755d7647c95d55d9cdac60d57f84f16f0742854ac1b2afa794a2ac79783efff8f4f0ebb20717b7051197cb66a1ff3506a082141dc0647a74045866d73fbe13f56842fa32deaf4c7cea679ae708e3bd5498e922a83dafc99b48f55abcf848d75dd89e1737ac3ee471a1fc7263d670826554f7a0d774e03ce6fa64c2c7a5aed7d9cf2ec634d5b22d0aa8586dabbc7586e3bbdda0380a27623ed7c73ece600f45220142892f46968bca547f4fa2d89713be62bd6d7dd8f14193523f5533fcb9aa42c94c40bcc0d45ec9c1e9033551972e2161e0778d3b103da1be256707ff35ace52636c17d522276c3d02c9ff52c74a78cc3c6c1dfda10a2f5d2a33798bda731bafb8dedc9eb50d0ff050dbb51d363d4de190b73fa5c4ef55239f88f3fa450cfa163c1a928e231cf5a7b4a08c5ce04dae6f46079403c57a5f3eb8fb703cae373570d281c3a50133976a24862f67e5cae0ad8bb849226936d762a8a2d2fcf99217c339e769ad367bef9e0e3bf37eac63a335fd47c008cee1466c45d5fa08824cba43b8f6db626973367ae619eebc94ea186b4a893c77d4865eaf67f7951ff886e57bb8ccdbe7f9e3a7b3357f93ed8d5daff10f9c76e1106ceab3a4636a7c8ecb5f3ccd93c18c45d0d969208406db414a2144526a8e604c8ddfd38866d3a592147090d5d138f2c1c070d757d744fd010f990d52d071e052e0ba90d24d23c5d4d333127f5242f5ee5a71f89d44f7258475376a8dd62385156ea46d8ab2181f9c36b54697efea20ede734b180f43545f01dad12b427c0aa5137cef4da11e3bca7168cbf4d61fc91faa9a396fcd6471e59fed1f2841991467cf96063b8884d19eec0f7b29468e4b971292d62cd7dea24412a76d1551ef886f85ee7ec7555b44ded88b171cffc0cd528b055b1c42eb8ef26bdced661f5df9905ac2fe3bced20155ebf8a7209944b339d19c2330a00b4b48a4c0993f0f9dd2465c145a59bc7721d6e38ee4227fc99edd5e5b17b57357b50ea8a776c7abba308895d5c2e30033a183bcd599778161319f4f0017b9b41e18c330bce5d511b8ccf109dae2bc55b0bcb5eedf133e0fa729a360e597c8bca2abe863b3f6f9f2da0c40ad4fc3fd5cc5946fd75460863ea2f82c405d00215acf6afdab25f60faaa73c0d4eff4ffa35708aaef41302324ba5875480049f9d46c47e4dea176da06ce0d26a41941d9040ea6ed162b19a40ea98b4b8d8457936768eb7f8ddb4fcb69b4d2eba8be5a56a655378604c5544a7de1372cd4237b3005c5a41bc1ab9b93ecef5c476497ae294d5fbe3ec8d1e50b60ca6ca6a23c0d7d50001707526f6b6d5a9dcb61024c4c6740090b6095968bc4ee6d28974c5e58c74a5be36f6d6d96d17c9b6dd2b3c4d0e9fca2f8fe1490f834d869f6f1811de44906ce1ab48c2e61c1ea0224705eca12d1a4980e8942f23b3196396127d6ac73269d2c8dda2b8072b3ebb5a8460da4816b96892671b2eb4599ab4d13f8d72cbc7fd54405d714e177b1a3a0a5aee15389ad5bce074ffb7e347135e7e3d021e9b143c08f01342a6ff7b6b35ce455987eb1be3fdf000ffd130e8e9f91e2adfd3f32f6d606b7be6f805dd69699581354dfde9b467b0704084f865a52cd80c46de411b720defdf2bfc3b5052af2055520f1400dfa2f98d83e2f9a4c3829fad432d26348bb167a9ba2f659ffb006ed3034068bb3cd22a5fd3536b8017367a8aac9dd3b5878e005d91912ee8843c63cbc2c165c4d37e76b81ca203476b6c53975eb11766b05900131850f48c15013e451dfa4366d5403ab3e044fc0a9555b2dfc3344b7af0a79be4bb5b083e2ed2f015eb43c8eeea887ea89537580e45c01a2f6090f1cb05dd1a66fede6e48360620c8952c32acc76e9be35e23d2206b11fb89cd3450040a34c7e93b72e66793773e50c1bf395656a288b6c407c8d01f93b2cb320dfece4ad624ebf99ddeb764ddd7abb2f0b9395070d474881e444bed8570e040cb10efe234c5f3489752805eb825a42ac0c5547a2a741eee7db60453772cfaa06b7134fa2b45c0c8dd702ca045b1cd64a3d7527c9c825055c7371b48d53fe4bb0391a8888c72c34545b4ad105da832b2b7cb02024dd8960b397cb8999046398e7e4fa20eb9c2b470faa3396a676b0cb902e568aa94e60cb7a227210a502b3c0e69686a0e103e32b38dba994871033ff091522ee3a8f86126ec20fc65c65cb8023d0ca920ccfb45fa3b2cbd5549ade23deb15e4b6accb89702bac9ce0637cdcaf32f4540bc722d6b3fc18f800ec01296f3a3e55fac12b89fa7f81c7ddf35d18b1d4b9385574da2a1c5822d287f1da8dc6e8fc2a3aaf40e139ce2aaa63f5e84ec81b7f553f067133da74d7fb784559ab8a04e821f2aca3caf72dcb5de2f13ca3b0278de75a52c9ba7d5b7656624cbd729043e60fa89264cc9f98a66abef6947281ab2f82bfa62455130e106686cb8670ce2351f44f4aa190b1e98e1e98d06f154f89feae695315ba6fa74681262000ec5116fc1e2bc4c6aeeda309a37d5c79b1a3c4b6e6509976daaf003ef40f0c59eb6a1c39018ef6bcba57429accd6cf1de379bc335c58539640f45223d7f0682a9e79c717da5ca9809ec0683a077338965c32e2991d6f0e746a2c4d3fb57c096e60c651f8c2a6792cb13abbb8c0ffac6dae6524bce32bdde8a6342984289244369b0c7fe92e9ad27737dd08814709c72ce1d390b5057b8a63767107d91ab446045be49b21f30b7fc5b081f2990ce332947c6e9e41b2068adb948c6fd3d9d20bdcbbd9189117d67093e16ea985ad70ee874ed5fbe9a1f55079831c5baaddbf8dddaa5eeeed645e91b90cacd80502b37189c7d9d4b18588a1591b363020571bbfc121b9c508716c8cd7c22ed1f5dca31ca5d36617e3531b5e15f945fce64fac7dc79552502b6faa1e9cbc858366743e20778fc1829609db418a36ebeb8b54474658e61873187eca9ef7c52efb452f91d79ab495d2d7c297f5e3165454c9348d70da7d5041eb1385b9f6387aa8138cad83ed5a22c024eba96029f86d8e2b4bc38c63534e2f511908b9987ca78f67ef4ac993e30852d4c7300ee4a053220ede6f2f7218a5e8672b665a569e122ac98bf1c432e221c7a694288d5e98b87792203661bcf10af59aed05b381c1b47a623fa9bfa67de947e3db1c046e6e0eecd2ee5b23381a4d16eea20ea6ace450e8df5c15b3983583efada2635142a616c7ea78bc37d04c68d2264e660d4a02af7e3ba6bfadb197a559322cdf7f605c702a20d5897550ebf8a9b1181771887451813e80c1305a82924dcb8f95c246b1ddb092e6d8f39ec51d96f5096c6dee9306d8f3f8aa485aadd4334f65b38b0482e4f83471dc7275f7c400d93bd18699c2ce756cfe06fa6553bffaee5bf290e7d74a2089e08b123b7005a966b2d1ed8bd6a3f81e74e3e24561976149f68319ec94d01ecb706969edf89c3c973edfae2ce111c562a74603a8346bb91393784f0146958742a340a03906f76d924223b5b26e41efb5efdc21f80bdb7a8dab6470ff11d59e4712e063733f5107bb7b862129a65ecd1f7d29fb992da081dd16d5d4e39d40cac0ed98f8cf0695c88701ae088f7af2bc3ccfc01fb0e48f0111b764e74f22666f09c27a30362aafcb311108be159c8b89560114e3d765bf01e9ce8ee93a04e91667c5b6c03faa8d536b62cd3d51e17e3c74a6f4991a1732a592bd0600c409934c978cfb1629ac1a2167ae26c1d139763ea0e831978523b81478cafeb2f86a60b2d9b4875c4e764fdbf69727b1c744e08a668e184250e17fc783df2c1e1d8be5c018033e6395723d1a3461038f4d17ee866e22bbc27c0712efd4e544f40a6b82fc6c96d4772415828077d132b3e560548a8e863ebe1375f791ddc99e5d66230189613b4f7b76ab80d8437116b68f6a02b8246f987be0f67203fc2334588c5bd257a93fe1b8ce4e77eb0520dabacf7321fde088df0c526ba0611eb5bf97b80e5a4eafe782f51a194ece9c1b20e20f57479331b8beccc29f70c222fcfc876d9d37454675802f5c66bc98877588fc62303da90e20b2c1ef4cb46dc34df2da46f9e72fb2130fac69fb22d9109920fbf22162af17fbdb2f48007fcb134b3c5301f18f11b8346e718282ae13b9a58aa5dc526572e54cec3b88b85d0f1d79c08bcb9f0d7eb51f93790e0385d748490cc1e28a0d96db579fd388cd8656438e46f1a5d1315318190e97720f47acb77daae30749abb9d65c249b953ab1ebdea3bd2f120cdb5559f373a27153f3a33514fd1d68170ee2e40588599d3c5e1293a92c5c3bb44bd25ff64860b6dbe049668bbd082511b58153c77f77dc36110973857da4c38b438a163b1c0a56cf7b5650ab04f147641a03d76fb86e028518d9562dadeb45e8f84672088a69015b79444932adce55709b464d5a44420863abb42137f6f91c4489067421b078535fc14cc0774099777f18ab053bab7536db860a7e2eef1fc4303d1a6084db4ea2ee9fbe83af7842b8ecdd0e251d734f7b1bdaf848c42aec9ba6774e426ef2bb2ca2345c7f8aeef2c415d8cf84fb575eebcec088cf87dadc2c3007f2a8d1f55c9c1a3d9f3ab49482599775cd0bd749ffb5a5516c64eda17ea733bd6ed8c1d7419fe656c50a7d59571a1cba94dc7d5c02b275b2e17a44a6192a6a9f19e5b7013ecbf26ea1256173af2038dee451c4cf53747fc53d352a4a2ec65549bb69468df6577dd3693fbd04729e27dbdba5d6aad65207ef157314cef6ea91dcd99d9361152c170123ebd3dafa1ddb08c06c8ca2382c4c05543a31e8a003372739dd42fcb6b86e51d7186bc373b2b0b6ecceac4a9359a6b20fb3604894581e10866789b50c7f501dd8cdde148fc933b557d6f765e9560f6ba9df9225cd8fa1f4df40b380b4ed8a489d35c1582664244a15239ce90ada047d0503c7afd7d81afc55df115a8e06a26f59eea443db737a4961cc0aa0cb6c17e77c2d3de2cdc6726d4e1c88c20f3a7c85daebdf8eb56572efb01af8f36b8f1206923a3adf6375c42450c2f355c0baecc196593e24a556f3bcdbb68481c21e2d8969b4ab65e409c6bb1a7a96eb8929a5396c37382c88db322d8ac54e2edcadf7ef135ad3ebc1db3c1f240c9379c6efe178d1680d820989f32cbacc4a10fce195cd22b3a9e743fd0b5829d7d4b9b8eb400a2e3e4db3a50a0b7ae86dec13b298158c2dd4e7b58145c973e4fb6b65dd6d4b4220eb4a5a9bd8f78e9a0bf98cc6b0ddb8d6146cfb0bb8752c40bbf6a6c4a369e9d67916a6307c029e93bd7ce15ec07ce57fe221297b7f0db8270eabe4858c8b64a4a7b8a315f95545f4b4cd3beca217a7cf1a2aabc191c373e42a12e6beb8f3232943d9dcd7394c57740f29e439a2ca0bf6651b09fe07566712c5b1a187b9d6d91dd9ff6c5fd38bace226db84262e4e29359d62dadd3e80dbc737aca0f805d0c95c9855561a8f6212698ebcc3a9a05719a363f27557c93200ad612fac9d5e040b423a6789e02dc0744258aa171a82531847ab950578d349349161f612b5094caa45325e01a6034c99d7fe98aa134983d5090fba8ff71bab89597887a36965c3904d5c1a01ac364029180f20f06d951f7f2fb5591b376d33d042ea78f6299ec17f5ff7e16d28b65f9f398c4278a6ac8e8d668c878ae54cc9012629f1150fca84f0f0fb659acce363447aacd5d7b0c80259c96bbdc2ca258fb03000743c9c52f07ee0b923d7347523d49b6c36c48d524ec81a6df45889a9c67bb38d1d378a7125a8d17a3a06678a46b561a42436481b7ab5ce1d788b9bf7d097d0d80d52485f85494b7548466ec837b7811e1922d7fe55fcd7c0e2b36800a494db5aafc66d3949ccbfe3955b3ec0f6778cf68f5968f90b2518fda504c49908001bf552e5a40fd6a799af8cbc55cb98a168956743c7a24c0c97cc034710aa8520cbae158ffa314bf3f0aa67ab7b44404f79e41b91eb0d4b37d264085f8f6dc938f2433493c76b912623ede29236ebe3672d9abd014434bc84b7bf44d09c6be7ea9697d855db44e2d5ebe61f456bd6c7471f384ce4a7421e99ce0dfa1fb1c64764d14080a87f5f81d16e337301ef2536fa5af49d6691117a2ce1f5c8951b109e77973efa6443ae124df089914408c2f2dd060024fe58ccb4d50c87322162947853696b13fc29c1c8c37d33774de5d5bebdb5a5b6a5a9f7e46e4cde208c6059d84a2f1ad53478f57860788c710c2a2307cb028dfea84d00e137d59ef59ae03fe4fa38ba12dcf542c3ae83f1f5c0a69fa9278e623eb39238ed79130ea9c50404d3e8aab027eb4d8a1f817b26f91f1df2346ddc4d09e7e2917df3af5e38544b6e9e725f28214ce0271ad4739d2337b56e11482cd6952cb426d51e687f5482524fb2a7908896f88fc8e3dd3aebbe566fa53f5e2ea598c07dd883e9887ff7002c40cc89576b971c128deed21ddb08cd85831cae0a0e1e434a2daed5a8a74a979f705b5eb3281300aedf64429d7643db398d2d4d27c310851f91a94e2d4db1f486ea6a6e56704fea52a636181812543336e47e382cb1528441b71ccbd69d3d8cc64a070523aa37d4e393c396cb0d3bf58d3c03c8da694fbedfdb850a25c3fbb4623bfba297a77cbaff9893e5419823cd427dc1552b1ca531e0fbe057ee6be1670e1c84a69b03ef4c71e9ca78c81880b258de34b767f6b355600c685fe0140a7c4dc6379d1de52d8a7382c5b76617b283a5f72fa1b7908acf86828e0da94b56fc9aad328ccc5f55aaea5b127ce4d7472cd46df16daa1857d03bccaaa608462d51a44e112014f8670a135f1c9bd170451d11f6927f5b3efa3326c5a4ca998b013eee284442c16784a7e5526400c7ce3834eeeefa8c3cf47bfc8e95399676713501992dddb4b8334d4178d9eb49f71518ec08bca61eaedd21b391a41c28b3e2874b4ed4b08333d15f3b12f93a2de101b6714184022d1402a1c8f7bf15fa535e82f5b1bb181b6a8696b92b32e003422314df4c7e343ad37e951d3b57940b9d8bcf09dc19eaae379eec36a320f046a32974add492d42dc701c6aeab79704a3b00a7235218f7232e175c975d05197c883d59ac0d49c441fdecd7017ea2d0429116fe8ac0c02f7984a8a74265335d7c6c7d242ba7bb69feeed09d42f8f40b38a707db7e9cb057f7d784b99c5648121ea79860fcee7264e460ede190cace5ee3ab34eee72a18140e808a26598f336fc6da38b4bd34d2082de3041897cf091ad20b31f19b5b8d4e78612cb80a15a18683de92d20d871e4390390c8335efb32f878ed00ce0e6f8c502c78506146a30aee629214f820bbbae8da90b2b1f20e6eda8413150f848a1bbf430da0aec4bc83ee2dfdf9caaa11b9062a5949520d983477c1ae3bade16fcc2cd5b94007b5807a86ef9b850279c81836f718f931cd7b8f195e7dca254536447aacd8814249bd7a0b2174a779beeaac5aa2a75ff1e043ccce9d1a8154004c9b7dd3fd4e96e951d587b8ea0fd4d0b97da09d75356f8f4b071834584fdedfca46abe114fb1cd90d01ac050af3345502547abd0b27359c89d4a18544fe4bdd619ad84c8e8c6d72b56169610749fd446120460f76b9eaee05ac4b16711cef941541bac074b4b970e9e11be58e1ea794f56ba32e8b68589cac5ec96d1737bee22d346fccdf2d7c6cb30d0c4422030e9566f240e82beb2b0ae73cd9004ca1260990401c9ef1910fa433c8c618dab860cc45bfe80634fe71ca7c8d76c4d0074d5df92539364db8f6ca61e38208d52fcc32edb8400ff7baf5a1b6139261b20e2ed41f0b146e9461a3d3fc9ca4d68c59366ec93dfc6755d96d9c4b74e9cf6f1ab9a1e8e1ad9797717ef6bd979e60758ab66f84235a3ddff0a0af2cefb481c560a2360f89d1cf8d0a659544407cf0089f098b7343defde4fdb881a81b985da8b94ef771e22cab773eb38dabd6e09f6cff0c8573cd1627d7057d835171ddf93d2c7749450ec156e827ea11039bef96b4913d3ea7f97ed7ac13bc2dd900b607088e0d4e68d193809e1361da2cefd7f66f2fb114f2f245e955febae0d003bacfa9f0e515290d4b653440da18735ed59cf435a369a39ca108a64b11c3e9cf0656a0f18ab772e0212572cdaa1c23e2d3d825670bd0bf9ee35d3fbda90a8f34eba5cad9e72d44d714d3252f124f02db908bd9823ed0db14683a254468c60fbba5c72d3a25aa44a361532af66610b4bd4faa544d7310026fde4d81d27a1fdd928b1908761ef6a138e2aa753e08ed6b030fe852e36adde6952856a7a16ad6c68a3c7a8f570b896b837189522d7bcecaf5d1dcec2dcf6e98b7126a86d53d5a7c881d8ba473ca5eef74cc3046c621f29b1bdcc43351b2f94dbfefc663d412d7bd2b1cdd8a2d547eaccacd20911a1abc56f689d3fdaa1efee95a4f4214a7a0ac49234cbd7c4cd219bb50ffd5da959df52e39b761b3347904d6cc5203a71b65c6c3b9a64be86ad7c14f28a4d225fedeaea92bb8990247856314cf0749369eb4ea55bcf9e7c2be7417838adfd9ffb1c06144ba9f2ab83c2b0f24cda212186863feadda205c6dc9e62032f0856140d0322749b09d959f9ae770f39ecdf689710b60b9f6b5414c7df7f3c2be00a2c37d9a6f1fea7b5a75d9820bd772a835a5f812596d84852ed2e2688127642bb8571c229931381971fcf7a4ac7d02d0969979ce002f649c0b3ab9b448c74fa1669b812d90c724f458536830f9b1681441f092b8a6d71a7163017b6fe2d528d9e4d7614df9530a7baf25e31b5890ab25a61d0a807951d0d844493be73e4a50d22fcdac4e59e74d52abb7633347c2e93038bf5beba2935b9f2fdbd9498a92fb9567843836250c4e828f7a956a0836b6e0ecd5aa8349cf7cefb9d7b12fd14ca61423255bb09586752a1976c56e8860b1183c0a9c3365dd280cff68bc635f4c0536d13c04a75f6ff797b62fddd34824b8380222045c5f507753a57b9cc11c11ecbae45654d2c620ba3115af0730da1337b04567bf7b45a85cee0afd7b121abaa1b87d9a64141170aee5a7f5d0b97b83199667861d0c5999518d257aef324586e970de99e77281d2a5bb46c6d869daaf01edae5261a8c833604a9d7f38c68729774a5941da08bb86e39348f3af700e61441a3737235662f09bef0490e638c872eea4920800e1610932cd983faf12b01b6e783a1b390f5f329594cdf4875a5040417444a83c6ad93c1323bbb7b1eb5fd24e0f0bd850ac2926b6e17a348bcc699169141ae1c3023fd65317e23ff939c5a2fa471d672e2580127df609feea6cb57c7cf2d80226c0c24eaf474262fb5cd955f3b5817999b6c39a43ca534278fa28a849d51e575932d1808ca44528f53140350738b0ba1430d105e206ab1c46ba8a683743ed3b9ac0e91e0bd56a17c502f000acac0fb8b2b61180c78e0d017bea7245e259276573299a8e902a3077e4a7c348e51077dc8bb129b2e88ecc1f3ce4604ba977c1f1dcac03f65f03e806bd32b0e2a07c98598d18a10fb4bea4716956449b89547f890ddaa04db8d548e556f489372b44c59bcb1642407dd8310dfb2b4ef6371e12c3400d9f1b4df49318fcdbcf0b4d601182cde7010ac133665fa2bd592fc3532974cb15c65eef3fefe3a82f2604de96a9accb5449da0d062ba07ee350d25dc7a91851c456d78f78f14d2946d17e35e06e1a4c49c89e369ad8b183a710225e5f9cd343f4b74ffa9b7edbaa479c297d237246bbd4f662cfdd04b8edde595596f63c2a115f28068fc3d774c9200367493bb89ea292c56b7c778fd08b3080f3eb8450ddb5893ea83356987fa4f5c9d69eda5273050e8f9ca9f419a06d10d13b58d9c1cb52728e1a7e8b0a4bec51a3205415d4a1723b73468f48001c62a1521c4aa025d4ba350aa08fdedaab26ccfb2244ea370baa6d4df7ff798f989eaf2e6b6d6b1352d3c726a6fd803f4f594494ceca154815d512bb3a94e6810a5222cc8ec71e80003d746fb13bb43f1f6f89af89147fad538e44a06b63a0dc125268bfcb74472fcf2b11eb8c7353a1f0ba6a035f28c1b5a9d33427a44f95103138aba367426dca96ea03af7653a8a46fac49d5b34b195bf6ffdb44a0f4019a727c7e2031c8ee77297e19040534c81ee462998b64023e01df4ff24b9f83cdd25a8acc7451116803ca3649cab1cf051b8e45e076f23feaea3ecb6bc3fa14719e071b21f6f00e543dfbaa18b8ec74dcdc761e75a63bcdee56d73fc6a0b1e5d6560c0b9285325efc91ec26db1add10962ac1ed59ea1f0adde918ad70ead6d423639419dd777993c46fc85c28d5004677fd5aebc0eea5705514191c721a1a93f4eeaaf47db106b09ab254c5879728a4464163252f6eaaa77229204a9d2638ccba5adb4f94340dc52324ba0b1623fe633766c0be802786a5c52654f2ecba0cac8ff3a4e635da55c0d0560378f1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
