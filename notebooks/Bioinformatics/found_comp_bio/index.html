<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2131a15791bf448d7d7b88701c9292ecfe8f319977875b0d0ff5af7ebf644972ee7ae3cc9d87df76920e722dd30cf0f6a5c04180dce1e9872e4d6caf86c9382cf6900d7a5cf339f00aa95094a5b5298c2c69cb1aa555dbe0fd6bf7383472431a0a042dd7398a37c98c7e59bce2530c96ec30628d3ffa423b4663afd63d4696bb8d96fc2657aa81e0b00a3092f833bd1cb239b99552d8b35e807322e70f7ce0a26111e0b6f5ba3c43bfbf10deef856440ab2efff8f8f5f681af156581a5156fd0fee49431049ae5da864e8014142db939b518636ecf1b05eb85fa23e1c23a54404d34034b19f572bacfbd078a218c640c318b2178610ab156b057d5edb5a208e568287cb09880da8365fc7e16df6043f947195236e65516cf51bbaa87fbd5a278bff65833481258abb83a8d039036210ffdc631059c966bcc795d7546a0fb47c0ab47ec18fbc5e4a37d474ba40d4e131035384b67050703bed09df5c2a7dbaf82b0f8ad981392eab442da04ef65acd063a2b98451771c0a2ba3821c065345f7a961e18b1be1b057e1468263e87e45e84bac69ede9692f24742a569f0d3046c22a2d7ece74d07effb99acf41697d2d974788ba8faab07d413a70465ac5dad55ac2b4c2deb71ccf84b778e0434161d9ba1fdac882076e18456477a1f718cf1b86378648df565243cab651001bed9d3bc65e10d2d15b6957034410a5be187237184e0afab8bca075f3134eb6d2b2d7141f8dea1a9966a0c642d45ed50d7da35f32193d1180ac82e62621582977d5f35c328d785c42555dae50cb5fc9b061a3da9136a2815334d4f718f03c98135e5ee5ae58c990a61c01456108b746bd2af91f36f088e6d4a6bbe54f03e1147a896c8637d969a1a86ad4a12f542804e1d4fb87f2028306bc66be69b5fb5d253c00cf1401eada48a24df1fc8b5c6809595fffd3094b2708888d36c0c12c0cf5b6c5e255118b96686ed27f2e0a6102187edae80dc41db5ed1f53fefce7e2ab4d4cd70e7ffead8afef9d69e8df823488d690ff171ff2de4bcfac1e1eb9b987680064834749d5bd0edc68685ff3742d535edce901ae6779d39c1699485857767a0fb3e20d8fa414d4eff4198c580d7c52ac01b5fe9e400c32147453de84a250fb16fc470722a966861f42af41a5389524349ab4e47d79484d2733e896d19abbf11780f6207c70652bba095219e21f4b1bcf1b1d06616abfbaab666e94c66bbb68e0316308234c38cef17c0034516f0ef143ba4fb4835f80778aea7ede3743a4a6ddb255c99b5e80336f6b0c5f80f82d8f6838a9732faf43168cdc8103623bce0545af9021d1abd41895d517905c5abf68dfd080d3fddbe411f8e7d223e9e45cbbc3e2b59b9dda55992e476d19b2760c241843f6f7844308efc4625c47db0de98f4a075999ac04e9abf44e00eb155377817c9d1a8928d63f75c70a91d97ec024b80384e94e4ddcf6e1f24320043c9135aa56b00e9f35454172273f7edce49eb3fd78acce99a6def9e73718497181352697bdf54728696f3084758aa472c3bc23d74d29864c09d270089c3812a82a8b3417f381d3397b5d636d776023c6090c11dd8019fed4296e759325b15ec11c75b809bd4076ddf67f2c5253edfcf16896c8f0d97e1106ebad2061a5982b55ca278b0a07e4d8bfebd582ddd81f8ece818382a971edeafffe2c97dd65453afe25c56e850ea310189742b2dc2e5ab80312d2dc82e7c1e2ad212040e0693de125132c6dd2b344cc857fb590086cf8567a3609fb417a5600332aebd80218299cc0f8a6bf0244148bad3e0223627e159a891f04d82c0a572decfd0e54f3ad4f8d06827286c9478803f2ba3cd9c2cab9275e33ad0be1b4e973d37ed8bd39686f0e3abf316e6565f09c0f84e0e547b2c5463c3f3cdefd9f09547b017fa66cfa65e65216fba914719a874e17e03371713c49942ea9b3723dd8c34b55f2ed47872062bb6f0a1a1c30812ac1b34f55dd352aed93be04931e8522f130127934c35f5861e41eb13239c7155fa7433af2b1ad4da3f450172d13fe3261db020a7d37d1e119606e06c4c115ce600e06778ec743fc472cd499ee3e763c51fb5dee21f06c486fdbfbc1dae2fa38c22833e07b3f04906aa53bdd6482067f9a79ef40edcbe3a956aa7bfe804392751f19680e88814dd2d7d0213d7fcaeec2fdb9ba37eb194e7d4cd65af696aa88d13f07ab7bfa9a84c95f4258ac35ab07992674b4b33ef8a881185c8e443dacc89ad57f9c3fdbc6e2b8ff54d3b50bce0f81f6b39bb4442a800f38d43912104157199eb065bc46c98acfe6c8a237c343acf19d09cdc6e9ee5755d717ba922459c89ad2d65ded673f83be529682d244362ccdf6ad22fc1c90a4e942d623ca74fd395364d94c748d0f20d1bf35f2c1572a20449ba900e469e234e3a337978296dd67ec4ec1316a720804d6eb9d1bc724772a4199a96761c85eda7caa2a8eff11d0376713657db80e9ccdf99d2d216e47937a8ec53655fa8b1db1ab0c7ee6d5ccabd830b9696ed01c4230068300591de67a96c4f5b41880ecd7dfd208f9607287b451ddb53e5331c16a47b0c4f0acd3b587dc494e2d023f28a458ee6328f47ceab4c085dfb81d5fad3bd348b9361cce95e3c46bdcea1161a140b0d5d39434b684382f99c8932df78c7af91fd6cc0e0b2a31b4a28e60d94797a8e37907de47c2bd571cb1e20cd88c13cde2ec347112fc726b5863ada213eb6a0da088b6971dd4dc38142b9fb5498e247507a632f1110fd4343b9fa9b09d77fd93e7c738aa8e15f52b1a7401b738146b74f154a303aae4c4c373514aaeb62889f736a471e4c97a05acb21d8b93a31a91b77b1ae40f46837122e1973b281470aa5b52063017cab2429932b9f071c4954cd4edd18ebef5bd5345ecd94011dc5015e120f10e9eb3e7a07e0752bbcc2bdfd22ea29cfa002a8c8418c1727c29cde0b64726b61e4f1ae35f83c3b1ed87fd02c01e1dcaf5ad37c87ded5b1f6ec50339f685d87d45d49ae0f0189b0eb89a4b4fbe0e09a180b22c757037dfc4f0caec811bf79b25f6092ea805e184406499d75cb50bb6086b5b80dfce3d5c16751d27cc375328cc279b62c28fc31799d862a789279ba12eaf6d5a5276613cccec4bb418fb1eb0ad52a74822959b9b361b8df957a9ff835db3a503207b29265a49790e2bca0ddaa0babbff9dabbad7f97ad8078bcaf7c8c61a91017690866130b97e94f25952c9aa6ed0c7fbd787b215d3495358443316c9c484d449f4134aade2de7cfef2bc07afd9c3a45920ca6ee9dd9950bfec5280ba625fdd568f7f4ccaa962f83effac631996a96e064a51c71ced654f2f82eb057cd21cbeac6cd793a9a9466e64878944f45b0da68ed14a54025b28e8951a21cbbfeea2a2f1146c98414529b3a3781ad0493c2808ce2e6d87b2dc949b7f7daa2d550facbc7bdc4830eb9b529934b0ead9a02dadf724656c9c47175e7473164f5f99308d26309ffb4eba1c5c70bd2fdb363c8e7b9bdac70304f0dc8d4d56250b72dd5d7044588ed27772aa5dd09d27b98b54bdfbb36893066286de13254b95b708407afe2f45b333599ff18568e6a1c10fb4742c6d7d673e79e9ec74977ab8ebedda463969f7b3195ec673d7a0f56e125180faaa08297de727c9f67d79109cb16c757d751c56a9339c7e017990956a5c5f085c3d642ac2d9a72f573a2f55809304633a72b0e2adddc9c5c00ea4abd4227f0e6bd99231841c9a30d4bfb35c8b1f0f135ede1c0ea6eee9c2cfec929d58c9ed826185f520d841456f32a848cddecd545b489545a4a6edc8adc68aab5607f1b73fbc4436feb3e4022e01c6b834c6313ec9a3471616f7380ca9f122011b2851d102aee0f6c59358d4846601edcc2bee25a28bafd087febe83b10a27039a993e706de94700c16b87d499942f52bb44a6325e3644247b54282a7ff6c8d3db3f59d3bf339869425f838061d29f4d100872da1fd333482ed1f0e2369eb4ae81e5d651824a43c84c18b77fca1e441d7f36ec86d0d906cef0df6e0c8b2e479cdc2e380f95f2aca1381a75867214840e4d1f175f95a9fc550eba4097d81a3e21b47dfc285b14ab95b26f1943144d964bd2e0cc2ed1a0d4d5e2fcbf7f028dd59eafe1662a19367c3c95df4c603b745bd94df47234dd2e8184de9b7a816ae3f791ea3c84b04a0ea1eae3d1eed4a26a21dabb478271ee0d9c3f992fbc637723ada4aa37c5ed3b671896a97fdd8f6e3be5e8d6360e2ade73e7b63aeea0ae285c02e111df180bab668fd9f448eba2064846638c923aeebb7d0fdab31ab47082ef5c53358b01c7a0b5ca4cc623c750981ccef4a22a0e7e6a4d308ca6a511b60afebfeb94c8b3625b7f03c039ccd10a0bed3a13068b097eafd9071c1779ab90af5fdbd6f2ddfca5f5ba4378b1f57d797c2d55c303c7c37764e7b8cc2fd9047a6f7d14a1c4cf0528636170d5d58ec19231adf55c914e26d79b2aef55d7fa28c53703a41d168cabd3f77180178fa87c5b034b34c797960c295ec7caddb5cdd50524657f708e7a33c9afdad199470c479629307ae4e2cf833fc2a7dfbd910c5355b3c7f0ab3477f32a21faf9e72ac115daf9931e2b8d4ac0bf49648e3a685bfacf90383613071fb645aa7d26ddcc908e3ba853e817abc09194e48794012e6ffbfc083d28f661774301bdd88fe51e699766a80553693bc434df53fa5be8ea0bd0ea0c7aca82f249053128378c37bbb64edd6e2ce855729da25ffd2cbba186b0293ed669ede7f99fdafa7c5cc624942f383db2df6d6bf25fb80d6b39835705241b965af8a87265f5aeb2949f513b09f74e2fe28d211f1526535337d306bf37ceb6b81b235d40b6cc271049c0c153f36a092722562120bb22981b06f7692c5c7906071ede3217cb375bdf2f57a761642a07c74d04e9d80eb7bc665b9f474f84a38a6dd5b0228ea1f926cadf4f9701d7b48a69deaf760757d72a1e74a3c39eeb3a859e833d4e62228f5952ee10221075f2739ba8118cdd879e791d83d2f9d91d6a43aeda44ca3c0978eaab9561d0700994bad054364c564194e30542d5083ddcfb40f0730588475ce990460b61fb4bace7d3407f634473b8518c0480bf439b0ad2da0255aa08fea9f1a59ce468021b9b29b3cf6e0c271fc866bd6cf0b415f2bcd8462bb72af92da549d04cc0e5fcdb8a4ab6471c0d33c7263e08caeed95f78ac111c08c99edcc795fbcebd66242136af7da73c59a1597ab22a347cf26aea1f0d222af580ae725da72a2ffed503f6fd5dcee9b30562bdb329490b3aa903c39fa655d6efa4b0c3cf7e24bef814fae4ca2ca1b8aa60fe0347f0aff74e38f7ab85a50be120dfeedb44ff6304545600266cb0225c013ee156d4f1dad69a1a610ba8966dd3b912bddec23a36d5af086a78b85cb14a351c4eb3ebddc2db9a773ff0b7ec650c30dbfcf88dccfb61237cb52e74a4d594dd1b97fa286cf524f90f7d793c8894e46de04891ebc3c7ef0970d175fc67d041abb9ca3352807579223fc1bec844887e2007a011a36802ec64b07ce147db8e78c53fb8e10950ec55d5d9a1cfde8c64d0973cc555110c65f5652c8c46b7187fb7463cf3cb6664eeb6028bfe32b2eb1e35dfa5bc65e02cc4179be85476bb888824d3d8bf37e7b80ef94ae1d29947959107d71c3523b0ba2c67f68c94d4f07b0237294159274ec6745f1f897928d591a73dbadedf2012abb6900251d270876c949917a072691da730c255507069f5c0e23262bd259f75b3ada5aebf527bc29313857279ff48982f012c87c1a37c8048806bda2f699f3159f5a7630cdcb1ad695462db6b842e943de79da8cbb92b504c77962e3d55786b7ceaf9c4f86594bf3dd8602761a21600f7c35c056461f8f21f05057e56fc4d2350bf7b9602a0eb45a14da8a31de86e98e8aaf3bffbf9e2c9cd6665e67eaae9fe7dc2c448fe6ef48b06fc91a66435b4025f4528c0e058b9047e9357bb4a4df8979132b9477729ff144ea2926bb71ab71cb43630274e4c48933a11c89b290eed683b1a048c44e39cc578fa2194c46e119c0bed10cabb6b87c266a71a2b6c837299d8073a7013f08b1d1d2c64b67081d013f994d8d32221366a5f27f67c98ef2b80c7e74ff05042569246b6a52e27a2846bc0fb521e0a8bfb8fac6925bceb942843b22a673e6eff8086e816de3921d34c15e5a5fab1aaaee070b7e82fd3d650e7be289b5d722c6b9a547aca292c98ffe2ed347ffc7d1c7a5c7fda24d3fe2deb1fc03ae9de260ecf6e83eaca4e69958f0f7f12ccbd856cdcb067b98af8a54f476c1bf4474cc129e828adb1dd3e6870792954578a2fae80f333f4e1ba5a57d1eb81e57882d0c4619acdc4ef8efb993a3cf06e6bfafd3e1330b32d271382a3625c3d06660ddcd24775418d4149e403627008757df4068dd2197c6017a98bbea82cc702f42ebc7caa0c89fe326a407030c5b4f70b1e4226185b2a1fd9313e05a77eb747f741f36b1f889576bdc4127d74930ca6bbe77cc0cc10b0124836794caf15e5b2ea028001ebdeee1121751c064b840e7304b0e47be4609606e0c2a640be57679207291100fb3550c5183f59682b7ba449eb91f4b31dcb01e6f51c12e8a632513240c0f5a3cfefc38545aaef018f37b7da5e45792526cdd4c9d68af75cbefbf133bab4645a8bdd10c80cb26724a31d855f4ca375c7949c0f61c44a26da73a7832e9129e5ea57a6690ad4d57f3e8d0180413b229a1f5fe2c79794d48f1008584ccbab9deb59cd5a34968c6e64326832d8af399119f5c9d8d1605e5bc2242430c67e539c80cfd0c65d99afb026cf2e2b92ce52857e258d55aeba4bc581a071b1a7fc691fb7a65a74ad4e6c94aceed3b369da8d1ab34cff6b8e50b2d43a25a0679d95f3be0f7bca6068a4536099d1a5293c0a293b31f6d905a97cdb56dd6c147f3f3e97bd590a3f0e0a14ca92e5fcf868d238fe963923a160c23e95d7c7d4a36d31fd314e6c503d5e4b5455703a42f748379641858b5ee2e1794af5865f21683b7a9d335ef80207aa8f28067fec969f437cf187626f11b2bbf247713977b4cfbc09dcf94d6b46d1aad2e2a3ac20e1e1795e6f00eded62ff24e80de1568436c1f7a2edca4d887c87b2c6a55ef4f9c3de231a1cde50350ae7a08b41b7f2ba3edb09b297390bb859f9039e9a8c72986b81726b41cb31d54b7cbaf6b1760f250ba62d7e26605cf4802b4c8555643cf91fa9345d5833a73004cfedf129d797938b73e4a05e0f2c02ee43f0bdd02241d873b6ecbd4eb9a6cb82e92b4c2b8f90251768cfb71cf478e180068d2f5fac058236e758a3cc8920d67c0709626236af16c618cc4c788e635cfd967321474d27f5b7ae6c2a674b559a84c2cdb70e9df3ddd4f5b6d865a51b28ecbe33774accd18f04197da01db03e20213dac6289f395715381c2c072f36bef1f069e1c24fedf1480f751ce88bdd1af0a320a6bec8c90c97fde9d9c0dda3afd80b5518b2dd8d1183e7838e14808193aca48f7615b51b15c4772b2b0119608522be58e90ac0783ad3b678a10c3df32d69d03d41a5d73ce61e060d5b65eabb0b6a93cc016cb8c0b9eaff0ff8b9bd1191da101532173a7fb02af1f2ee90663ff334124287cd89ad752feebea5934eaad24b440bd300c60d73a36f6335bbf4a1eef9acf7a206dcf8c7295e13c9404df2385e8196b4136f2bd328d02f1d31c3027d1989c9a784e799f9f44910c521dc251336a458cec76c852bb316fff128d45fa51dec1eb1a38b9c25a55217f22eea6c7189a67db4b29decd9622535ac1792406b77d7c9a49f430777baa92e04eeb76843506635afdee9757504993779636a6ea03cfa2fae19556dce8e1bfda0c15864fa11f0d757531e888e6ef54204828295ec4f7251548bf08361ec1e368399bbc50344945d4d8c5c3adfa01094c83fe287f9875580ffae8da4f4b90f285cb3b7966d9cd3488679bc1da73f6f4be61e4d63b91cd22f90141852ee36ca6402b2feb9c3903a307410477a9d5208f7b2a26dd81850f20a48159fc54c90f449d843cca3654cddaff740869c29d175fc535a60580d689111bea0f4b9e0c20c8e228156d77d241b12c20ea16a7a2bc7ac9ca62dd2890b21301516182e13b32265b68a20a4f8083657ae80310ef8b9ae829b396bc7b626d16a7708d02994fcca4f0a60f831540537afe63f2833c464ff9d30f7ed08b1e6ea0915a0624674bfd3316fef74fb989ad0343deeb39df39b3a36b359baf62d1c090d3825c5187fdea9c0f02fa4795f5b9e3b12565c9ed82c869ac38725757ae69da42ba11c804b86d0e83cc316125129201a489436609c163ebdf3265342a541217eb88a69f81a6c71eb9e89b53dd606ff1379d764a41d6e62c95a32889630ef9ad88a41cc55d36a0ec40cc0dc45287236ef0be1fd3c7ff05231eb1dbc84de0ef988c298b928e149b8db1b94e10902beabf360613d8161014a005d4dbd9dcff48d2c459cc9e64446354bde9fb9754e2fe8bd1d5e6fddcee01f7cfca340d6e1d48cf7007423822b8f45b244c68fa9c5c6329a59de00415da60a7610ec8b6dd81e90e1aa787679579c3a58c98f23dbf5ad5d63345a990c5284b769e2a9763f15244c64c2d54a9d7a0cb9bcb45ba339dc40555f4dc917e3cb3ac7e082e36c80e4c6a91d1924b904fe94749123ab98bec291f9368f4ceadb694fbd21be5c78d5ab51f23a91428906cc0e46732ff2aa62ea929c9a0c661b74b00cbf121ae9a8ccf9e29eaa9d8604645b13e82e50e9587f495388efc6f92fb0d730e151c9f47977d364122eaf5fe11c4a092f9df4eca10c6aaaa30daeb3730047fb146c2c1ec36c90c923a23ac1bebb8bcf19245dc39a6c7312be5eddee47e98f7bfac93a4ae3237c49cc91cb6cd53a92a0e916a02baf929c2c0a05fc494d59d8080c14108e002dac6ad58216150daa3b1443dba54b17439a585a425e64b9570d7e9c60dab9a755f53e7182e721245374c260ad0a69feb7f85fd509256594565994dcb2c0097a0ec0e7c5e7bc576ffa06aa925138344357da8eb66887c7647871efbabfa4499116e2593788b3adfdf110e1706eb48caec09d9c115fe0499460610d689562421a4dc073205937a9397d6084e0d27ba650535965b5dfd9f70ea614375de83894e24dd35c63c645cd016606571fd1a826d61dba3d89670276530a8e5c6cba933a47b1368d7b8dbe522280ce1b08fa3ffe386068df32182cacb1ef2fb7916ac54d8e55464fc63f7c907b0464db5f10751c6121abfd108f40fac21f605e70965981f99ee6679db21b05a822253e243f60e5de0d34137776b9c573d0e4bad69b158897c503d56804eca2d7ed0591e05198d57620f663b87276163862a17b79a84460f6e92d3e7bd617288789da9d0d13ac940d4cac8972609c19edf68de4f0209a48bec47bb59c5a9088872470defede6dd2a821d01ce7e2444a421e8236788d4187270433c52ec7ef28483ee8f22e018943a8fabcfeea7576bd9a9e407770e4f0ba66147010ec7b773567328d87f1692f85817f2e01c8d0798606d8fd9265b6e17441ae56c077c7366f61df8201cc1334880a57e3ec0fb379e0d0e20f57dd80a933e92d1704c4ff516407c0e8e28caee0318614d9aa6837d2d2f97e4b24a026266bb4af0f475eb076336bcfc3eba142641ebf7622f58b942b6ef097d2d3c7e228c9512bd97da5b486af20a9f45aa480039a44b361087f966a7599875d515307894d57c422f7486ca98b73e5c034cc043c5bff8c6ee5f802c4ad31b85f2e62af85d2c6ba9a8a042f4752d47044d8344f1d991b8300171b59d9498593fdd6a232957accfd76b14fab7d26bcde674854f7986cda961e7de542b1d914c13af2908caa75927a45a68209ebc4f387b09e9f1a233ac866757cf5cf1a8abf144cb79450849066be803d084af21d19b1740fb2b53a9f6db7be5fd25607a08c2b096e15770fb186dc298c48d47a2c9b96ac381d65dade8a7dbed468621e077faee8ea8ce055a1e59c33f6fddcb5326b16af0bcaf0cbb43e16448fc97884f79e85b4afdff7c430bea827d0590ab51838dd006ab0b843d4362b48413a30f7d7d3cec44117f8de460ea4c9f7111ab60eb3af6e75a7debac2b3ff1473ab10062ab9ecced6cdee148a9fb297b7e47ee5a5b1a8b88bf5ec7a41509e2acf536ac68fa9b4092f0c8c6cfe1d893454f2f94d26c5e93f7d9311c00ad9e6940ab6505d7aa3d189e7bf25a2852e82c8352c3cd0cf62babb6f8e80262c38ef96d5c25eb7f6e3d146fdb377e5c3bf4dc1d18f6e2011c3d652beb2d5c03e42c48edaadfce8443fb1358171b1819fe34b7d21834f8dc75ea98da299bac743f69526913678c594ccc64d2e5613a4389a78fd1b5f0004373876ab89e0518003d4c9b808bc514a251fb58e5dba11d39bca9dda8e469ca885706115e8c2f20842f869c6541e77354555f15b4314c4ce10cb19614039d8664a3497ae372717c8c2f4422d50cc279ec80a56040525e98c4c411c97c0797c07952773d4c6a72ccb274e92ecaf6427a5d463b8b0b2e1ab534d448e1beac31037792ed46a8fa25f82bbc08bf91feb8151464fa65b5929ad283848bd6dc708b98cb7422738d512b783ddf6122a68ba242f4b5f3b9a80e6cfbc342a8eae5adafa3feaf5851e894a97354d886fcfd279646199ea4b363b21561e37945246d8f33605f7ab31ddc8dbdced33d18ea469bac8caff976e43062073d28b6138d093547ed2da375c418f10a21c7ff5024c6cf4484c840d913172b649e3b33299bae8efdf2aba09ad39d0aa00823a4d9bd66b7d471924d395a92c71fac84d56aa8a78d7cdc577275b9de037c632b1bed633dd08591cbc179cbb9ae7f55b23e98b6caaa3ce6919faa460b7b90b88a2dfe97d2cfbd7cfffee17b81fb1dd28034aa1e0b11974b31ba0d89da62644ccc4641cc54a86fee0185edede7ae0374d234f9151d10cc5ee0bb430ff448a3bc35a7186e5abd565fbc78c9b6836b7cc8573ab843cfcfb555329f9c3a53b59478f4c49b4c71469ec834e8c2363bf36491f591475819a1a55f4cbd4acb6040831b5fe0728af443f10b8d2f7b52bdf9242d80f7752bd3121eafc5dccf90ca569e472681ccdd8ee7a2376417060a655704dd6852b65f9ebb5ed0be528cb48527c3eb8432100e2ee05ba0dcbe818819884bc4bf2451ed3e72c55f2dc6ede158c379a3fd57991132eea0b4b54533af912bb99fe116bc41bd7fc54bc52c503fb740159904f33dc821373188b7852d394b9fb2088e16e06b94a11565617f15b33ad4f82bb13fa9b76dedf10523fa6f2b3b50a43f83032f15e9212ebf72d4669c52eb50b79a50e357190da4b66c0456a9fd7c4d37b7c47f82b070bceb7b8c21d4e5f642108325be9f36346ff5480964eacdc086786221f2b26e54bf091aca82ebf5e885e4df3cc59019f719a22b4b227d10e7d6144c517c4a9290b79345eda563abaed6e98f84eac0f16487c4155081ec2fe48d973a543029dacb9f072d9289b2a4f23864e995df7108d966ebbc0094a2f02f8ad0db7988a00d3e84d4217b037ff3b951c5e93b7e598663caa1e92cfa55a4b313c3ee2dde007d21558962c32db32af27cb6279cebcbe06d663c31d47bfcaabde9e943954639d44868a48dba37a3833b433bb14ea86b2953bf1c39cbc6d87a827153c97e9ef78e9c3cac7850783504e61e68c9224f7215b1aaf45a12e9fc09e4eb00722a64c91e6120023f550e8f9728ea21c7e9ae03b732bb851d0f4f88517b8b2fbbd9993df1dc3ec32a1b450dac1100186cf0b569c3943e0abb9bdf6e47ca4d4b6ea5391e11f64ae875c22059b803a59b87c135ee00f412108d7e1b8727cb877eac2a63278eb33ef66af656b43157e6aac3811a367e1c81089cb7c7d59654440d45796a52516f05ec0f0d6040c1f0d142c006c84d22aac8776e5d3abac49227fc98f6201e9d950b107c2eb8ce268e4a28c81da9298a6322515ee5ec66ff718c2b8fc434ffd3ef2295d2ab96156b87319a9d461dc8b7d82f6785d58ff70b1d8c92af9ba9c7e181242547bd39b12d3061664dd07af5d10dd7dec3e712251e9eff2b5caf64a2f53240d1de16bddefb1cd333a851797f9c0075a3d594a0f5f53f1b85106ed1b8006516ee115d28bbf009e302699c1c28288ca860605500036ed9c9417a03b7000af1c73e39d48436c7c5fde513e7acd47512423476b4e075990ac01c438e7a5700ba9ad42f1cff623a9205af545c8cca19ee5a207285253e10d981cb8cf247e26c21f4f73a1de2f6890ab23d360a25fc19964fecb6315403872ccdfd743cd433afbbd4afd246d5003b7ac02ac7af0f1267580ca0176deaf711f2eabe3b35def67e77d1e36fa4c652a768f126eea6654039c6d45e0632b71e4574896346480549bb1977e3457f44c3fad4f80df404e24c4499b71c1a3922219d4cf938bce80d120caa20f8dbacdd0406348e3db428d7fa7cb3ae68ac1ea4b177186c367d92e7ba6ba37fd1b388f59f9004d5cc4c5e7e562ed92a1aeac67c572870e06747fae49710201e0ab12aa0f78fd9b34a2deb6afd117d00cb827909e0ef5dfb8fb866897dbee80aa92e7cb585d451c7dd0f136734f44f2271e1121e9cd3b2386575cf43ce2a5e5a8edf7b05b5273623f9d68512bf264d829c719af9f871210a4bce9b9323d4f07d9ecdb79a32f63918999a3bb4ff0f23910646ba9ddc069a1ebe339f07e4c1eeb4777f8e24f3407ca0a0a68375767d595ce96e25cc844412cb42895a98e8e06f39f41408c00391d6de8661fd0fe9b73b71014f9a47afa9e84efe2e6799ef397749b3b6520efb72e5c803bd89bd1c3702bdc0adf652f87eb1cd492a129e8236d03dc647cbfd03cf7a47b9b9c95d003fb1f605a5d9367090fb9deae7ad3d128c71a4de916c8c4426b367a64804b56ced677b9b11f894c38c4e484721fa3341b312025020c9b460d522dfb96c44c3f709a1f17c1f7dead8a82339ac918f886dc1b3eeda1074d0c4d26cf5107deb26c72cd5af31d9b75ca93f9c72b88d92e5d12bd704e98758569c2eb71bd3e365b93963ed99237a0aacda9bc6658cb364b7ced900e2462b4d301a7b82e66573adcd572a6b05e3dc8a3c24653f07c5c2c2a377d8ed14665b98d8fb4c2af747cb3775a5bb82f6726d7cac75ab53f118366c15caf3c28d327c9a2b211c03ac5a4f5055bccb42a849aab5e7dc4d6608de11ef9a19098b600f4acb7d038c24c7e071403be4c8f5b8dd21d890236147420fc5560feea3c15fe8de7fdc8ba5677753a25413e7eba81dbcb23167833684446ed60b7e498f8ed481788d64917e4ca9051b47adcc55f829865a84814ad30125d85e70ab25c2b5503935ad887df5db6a7c4b776e668de941a1ca87e8091da3acdc16e37e263368f98225fa31f633c159d1c35f48c96ef921ee5e8e6bbada3a5e384616c7d35f62b5ec677296bc8d0421db9b4bff433a77482039e41ce2e983e6a0daf5fc73058fc441de7b0037462a131fcaebbd46533ad2f452ba61049130f18c7fefcf019004901dde74b067d793a86b6bc884822d9fe1ce42099bee9f27c721969365160febde7e27254dca534823946b2d31f323b0f75b5d776b87a6d97c0506d67f3b9bbbcce7ce158662ce5e3d46ce5b211dec94980e2006d2e10fbef670e7ff51d8aa209e780b9dbf667843e938706cd16f94cc7ec4770ce7a4e4f76464855968f79336348cba13896254d22887e0b345a4b421002d5bc9d20aee9b0e15e91783162cdaa3925bc16532f5e2cfcb9bd23a8fa4930c83cd80105b1af84f2fe55d1b6b88cf1adffaf719873f53290158f3619f550bc5ad535c09f79f8788f65bd25245eccf36ae815129b948721c2b79a17fcda33ca9324bcba387cfbc0e7ae9d106c81063d70de5f3cb56bc684f04f1440ea4946ec9caeb7923f0ea246130935b1b74e51839c739259592b00347746a121b17f7bc7f7a573e6aa985e5f3ed4efb80ce56bc5f1a5efdfbc3f328c5f74ca82f00e0bdd84d052ebd73cb197d39b1b898a581f7645bc706c95984908f5a8a7dc2c194b44fa83e473b672108dd82397f68a38c439c002084a9862f75821655d154157f3a3c54f2128f792dce5bfeceeb77f90b14812ba023c2e217bfcacec1f9b5f0bb6ead5df3e1e0d53e20a604c3491560aa981bdfed0290271ac0cbc65bb31a264f5b901ff3bf4fcd0607adb36d35fce0e0450359f70a36e975f7b509d52907aacf7b03c43ba37de0da8c9361af1c9250a9145f0be3cf0402839a1e20c51132bd390d87dd8511824654e4b4d4d8349a35aca8d8362407b216a75a4079dc95bd4b1b78f6d2f94a86137349db742af1d59dee9a6ba63f1034aee1c0734bca702756249c85bf71746a77e0577da74f2aa76fa11d2bb7723ebf8cb61e6d0bbeb88699279d3cff1c769aa33c2929bf809a13ed7c5606542eedaddc985b30cb221d3b6a13583a34c365a5de1533b77d814d211c4d41e6040fc30813414e76417d2cf535194ed4aa8171360d5b8f3d684921dc738388525060bba1c27a55ccac5c1da6ef1d410c45bc9f7065f5d7333a6aeb6cb009b5828205ab4b686181bb6ae5d37dfc1e2bff04268685c5ac3318aa52696629dcf0bbe5d4bf963325e775868ed5f9bc0271541f97f431610ccccf3731c6486420d6a4ee60104417c603a519fbf94cd5ca74789f152346159745a75bc1b2c421d9b29179339832ee7375379662e97cb3635e813ec01a0c72fe11a9d03ea5f69220ac941d35794a35cbcd904417aac7d3f708e76aa249b0d11fd437929df05282236df11f2a6d2fc935cea6e88227b7655068e77a3a975da7ce21eeb69afddc27941e1bfa4c5a1a211d2a2b6ad16a79631e86d35a752a2dda24df261441aa7689a33f2a6a69f92671c468ff191d3c624add598e5914db87de7e994b130fcf8d73568f56cadd36202b8577f2c972a54fe7a375a8ac109f4cb76b3da4332054ee8c4235d550d954aac21b27c0e41356eed98ea789188a54963a2da32563ccf631d9fa8ab1065673ccc63ca04c2d08e66f0ca7e3262dc1ce9f116ddea6149be99967abb483e8560e3afa6397c172fbb866441f6ff08f440a3085b7221f1cdf5201293fe7eb325f02f7c848c9d54d4e8b7b9a94a46c48454060e27be72b0390d70254680ecb5c1afd74ebc94606edb2e014522cb1fb1a6974202d874e1e497e22f854f7b51940b65c06c5299c58acf4b20f769a8e66188d72454e0ffa5ac0118e518944091778145f79895d56b728b7915680a34a9e842d8e00c47403b529ea6ff0168689306935b6aafcdf1ba85d762df6fe60d59d93c540620851f4992b08f8ac24cbc0400257d4c32631f88a7e2c62c7c0f2c2518a8cc1001034b1592a84485a6a3f7c9d40c42d845b97bdd0190d5903db656803c6fca6a1bf2f46679ef4e2ac0553b032696b8d520d884eb9a309bcf39e4aa432ffb3f461b56f2d266bdc60b27a9c2ed691acac872b7d72dd290affd6c1c9da253a1ac51e3e12e483f5e8eb0f7315e4cd4b9204b567a389b88e9ca230d83eb7522d2dbb7f265b7f9bb046f58ca806c3c843e65937e288e3d0221661dddf659eb320828e11167a5e20e355237e9042f19dc902f2fb1d16de9c0a4a523ba2a1a15ebf6d1df475e39ef5002a7d2fd17c5389b86480d97bef4a37b7dacac700e9f85e29fe9e8e6c7ad14bd57c47cf1ff8af819cd8b91ea3ae3387dbe65d696414a815dc01f1edf95d1b05d54d57d91645cbcce4fd100b92ffc7999e77ff3d033c409b5b4919f4be47fe28cb52323e3cc5de7d3ef09594e4688cc887c632f976b29f6477e1b3ec279e5cc6df5aabca1e7c6994160b6a341f8d5b427ccfe697120f92dc214657f0649b8423a98388d140132b01a488ae8cf89c97e0d68ca475fa2d65631ef5f8630d0e5684c8913e04c52f754e6146bd839723263532e1a902daa3e8959e956f4132286f58ce4e86662f4d44bd91a4278c496e0053185225f843b336ba6bc02ad2c6c244034e14d09859895e5c109da2da333f5c6f5c211adf2e84c74f15f11137dd9b10ea9b9165c87fb2d4858990d47b7f6c8bc541402a42fff87af60e1cae79fa6987b360cd892e5fd90e75b60a5686cbb5a26e178d74bce7657086412f3eabd36d5c7eea4098daa929c0b7d26e3527b9d7860ccde43f1e084883e67021860107bb6cb2a4c6154c551e9c0db9eaf318336cf73293f52c62fa16eabb13aeef0852b619a0796b5d50df7070647c3240408724f237e5e21f6549c95cad6b5f68efdc4bdb6cc582d3adc2384000337aaef4ed286f2ade7f75ecffc5048c006242a845ec19f2ab02b2ae87e59f837a6340dd9ace49a5133c3c5f670c567e59961ca1a24966bc12e934e35d660ac2c8d136ffc22e71cc2e3564eefc2d7e24f463c4912b88a71033fd681e80d15530df1cb8ea05fb7aac564b22d72dbbffd8110fe7c226443d6d761760d968acc83b0d6c89769c92ed3de3303993ee4ac7c29e9100f84bd080805a5e3e15e9257e03dde0cb85906d2951df193896b8e6a67ce7c7ee75f4d700cdb7df11ea1c442f52ae7c2e8aec31d456f5b64c925e573815d347884d298b9a828a8ea19e070738d1d8834870d51654f0d35d1f96fba6c50b2a938ceb2c625cb14b40a5f56a9fb3ff50d5fb8a923675efccb199364d4a9fa2c8693b9a63f8a057230b0f2cf6cb4567a92ee5fd10c33c73fcc5908ad611783f0b2c34e60e1448bd7636814e0539cf344fa5463a947cad6b442135f1f87bef22cd4ad8dd40106a1b0a7cd31bc19f2022b9ea01aa8c86183c6facbbb0a006b87817c6b4f180237b63746316dad8f3895a42752d2c519ba5dc9c61e070afcf786f6609d3e438c0db56a60a72cfe94032eb83d1af35a9c6379b34938bf88b834f77c472e03b3478e566c3aeb4bd61817dbd955e915ba01783e4aa1f887f26870a4629b65a717ff4ab14671a6672c646613a4dd81d147cbf4d93361fb407ee64b4fe9df4fc6c9d3b2f9b08104caae145e2d472762e27a188b9be8a42cd7372ea2b8fcab6821d08abb82d641758e1f573a7332f06e80d8e51dc0b056369e0e9166356f5924d8270ce2c1a4d0432017fe81d82a0c241d52d5dd3fbe371998953daff19cd8964e7017591fe99d98d23296518e5593decc9d46dbed078c4e652f12d9410d8173fffd871a1f32cfd1b6d5216bb64febe18c6d7981888bb12c59602f86e9cdd30d9a2b2cca98bb71e8cddb2d979debd1a4eef4a00afd6fab6bfdf10c38f81432763aa09377f1ce45e09e45706e816638ac7849b34864870cca404b57ccb30a3ca182670977b14b1121f113f5a4adfded130e416ca609b8154db6e1177d40ba84b63e8705b2caca836d1bfaf8fe14203b19364e8498f0480535a04bdd9e84bbdde9205c4582e335df8c1513be6732c93b91eb493e8423d0696fc8bbbbd43181ed23eecd727139342b2c3ca3a449e8a917537acc7275435048963bb10cdf17f0335f17b04ddc45fb7ff7d889ab4568348eaa24c353a3f682c25af502f2d3683f390dfaaa52d95c2b1cdba4dd9e2f9204176dde882e97510abc99a6fbfbe8efbf4a69712475db96f1cd076d970f3e5fe269e1ae1c61ca4e5ae4b5c6df48443a23ac1b43b0fd55fa1e1e875a40d2ec58290b94b81257fb8a83316d188520bf4bc91bc0dec2caebef2a8125f74949426e111aa099051ae97e50a76864c553ac93d31486d81942fba6f304f625500da6a51662b542b49e66e33b076f7490bf3bda0f475049189632efffd204631429787b9cb5e432e1854fa89632e813744737c3a622d4b0868f4e3b05786d26d9317043c3779e815c73186990558cb0e3cc80e091c8ccbd5f1ca84cf3592a969413d99fbe44cb2f988db706405bf20fb597770e572657d1a0e912f27ea54a37de0265d98dee3aa892eb7ba0a37e8cd86674b6eb60ffc6f345df12b73ca38d9d1507be17a5614500200dd901909f03ac41711397676149b935d396697f16f3b3e0667bd6c9e34523f0f1768878cf8a6ec30fc1794a553ce489862095bf8d1251e14a6d9f2dc28025a1d70e16b7cb46b4a75bebf4f8e9ae8d7b27cb95a8f6df0c5e7ed72c5cfb10adbb8599e02787d378c1cd0e5c8062bc5f866baf3b2a6383668aa5e392d5d85b0d76d6b6ae800da631cdd0e838a6d9493b2c07ee2120ded715fcbe4f21245ae330f7be2b782a94a3339f75a2f46536e279fe1ae7a3761909b53dda96859564ee2d83327d49121913795f40afadd5b81790f18c6afb167bcf2b5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
