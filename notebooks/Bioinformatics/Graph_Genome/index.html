<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a18c796a0b84b2696d3048e0a00689610346d35b8256053aa7bb7b4a0524b8c742897389239cd2270e675e91ea3b7acafc9b803b0532c53a2a30bf22d29f7edc67b997944a2780c4fd5f877ca595f34608ece3ffc192f67a72a921d67000eb3212e41b7cdd89b49e5bafed18fe22feef44b1d11063faeea1bf82bbce8a3c86ebdedf1903d6a67735a71e4f89421d47a7f1b2d96ca37abae2ca9bb612bf472d3e46946aef1c2ff02e40b0f24a24ae3a01661f629b793b229cf36c38642098e847fe3af37c9a30107b4a4f3f744a16efddaee990a4c187ff0670eb0bd794b7af76900ac6b6c7134d5c1bf070d17465cd28637f14e9c927119ad83620f6198d866c9c1b37668de72336ad2209bf36d99a66a18b4f94a0abd676bd39ef051f7ece873fe9be64a5cb8ccd1792f4cc168caa62a4e2503cd33d89d3296849476f0695fdfe8c749ce7f945c23e54614560f698badfd34655e6bead46222c77c75bf4f858ae686fd8f6506157ca7b1f93fcf65ef73bc1d13a9929a05a5341730bf6b7069f105a0d42ad22d42038249d16ad2d04159f1a451c236e607cceecc3a7535c0ffd4ea8194ef355f5f5acfe063e0183409e6c3ff5c190f6cf4175e82baa3d3c6ead35146a5d8612039cea7252a48ab8a21ca2eedea751c430bbaeab89c1afff404a6d50d96d2b8ef020ba94b4a236904ff10894f9d836e6b2bbab4a38d93ce1bb6b958b1c614fc3ab1e0854efe95ba5402a44e5d78c45d0e62e6db7e36f5469c1215df4077bc7144ca6268602e3a82c2d929bacd8b7a6e703c8bafbddeb4c0ba100f3db22af96962091fc92ae8391a1129071aad23818ed756cc6ce2eb0c4f9623974a260dc98d7bc4ab6bd864e0a68dcb8e21424c0f9a159b2bd351728109ccec3b0562bba17bbf7e15adb591b46e01d75f78a107319a8bc76f2f764a821d2212bbf68eab54e1d02d3db140e2dd8d4ddfd6ab03a74b9a7825367b22a7830d410579beb2534f53ce79b58f748b6ddd13307628a12f18902294d2e64174e9b6118e2b67cf6247a28df4f7c47ff5f45003a6dcdede9241919a91ab44785911e83b4a694c8021892432e38533ce866fd938a93a58981e97d70d16aac8dad1c7de0212f53fe44317b6ff41d81d19a05a36d5b36a11269f27bed7c59325623638f87d67f54c44e46eaec941d868ec996f2519feeebe8340e9d366f29b9fc3f5f186d499c4ce0646f7bd872be8ee91692b406363f155f9caeb8233bea9c7aee3f444b4b8f00241e0e3d5a11203589cf4831a27fbdae3280188c92de2fc3224282a6174c7a55f1e6e54f65f09696e8da89aac815acb466c96ae89808e5c0e4ab1386af528488be031440b135dbe64216b7a0cbd67b7397874653f1ad515168132f8fd42c1d0b3cd8d2cc740dd0d53752859e0e15b1348a33b3727dec7fe24ec5b070f4eeb8d7940768b23617eae932c49accb1bfba7bff5887fe7b31e60b098fd567ccf6c343aa227b5746669d112aa87c67b5c78cf5b10d02b9ce87e64731f1cf30b631e925387c2604cd1834d044fa0fd74bf0a7720514ff8cfbe6d602b3ac92e00d47b724d19bc5047580078b75ceefaf7e78a8434ed8a825b74df75ee2c2342a2e9f56ac486c41f20baeb403990dbb1c4889d8b3ae5963628f2b49a3de8d8a8778ef018f60ee102e063863be3fc0bd66a8ad0553e0034569f91c67f2e8454241d9f0f7eb842519a8219803a91c66f43eaf8f2cbd709a56971aef5c2cc89016ef15f464a9ba87b0a8e0b69aa1fd0f54e70db644fd150bbbfa584cf24885e2b2c5cadd26fa0132277ceb6cf4f6d075c128506e5e69daa7969e2d2257f0cb0dee962f0499e39812d777b9162b601d2fabba142ef5aca09d69e4148ea68bc007b7f8f3cace5420d10e28f855ab13e4ab1fc3107d3ae46e8a2dd55008c7701b2ca785cab04f8ea8a70f22865208edf62ce1515538b9e518df7a5aeb58eff45f94f3d787239ad63adde7dc7e115f2d5da3e0c34a33ba160056d399f14635e5f7a8432ad654394e6df8b2378a658df8e31a4cf0455a726a6dcc38bd83b240db31a7954c6a51e787cc470248cd5a2310e6a9d2ed90f2fa083840b46276a9f684edc7344e95c16b286b362b9d18a52586abc3bfef0e62fc7d0c2dd66fa8434920b753351dbb47ea5463a8ba300d2d6ad6dea47d79d55bc53f8616a6ae6c112a408494ec33436e65913f2271cec4ab5d15d03165a6189d22fe923d42da138db160fa7cfe361b413122921973c037482ea0d25cb5b7718db21535ea691fd3f8fab5b98908904aeb288b483326a9db538c6ef30416e507cfc2e6cab32e75cd9db7824ee364c0458b8e9dd3f62258eb9622606a19551b5e916ed0caa6e963109b2da3822debb422aeb936d8472b2ce72458b35998a100613b569d6fed7e0965fc4d926e8ada20a53113deebe108da4af7940c19ff279c12f88f3038ee9322c514982d334487898b3deebfc050f9800851dd9ca2ad23512b1f87e7824d6231ad44a6c3254677e3b405f49509613e2a9f0200e1d130e20e63aa3319cf0d88d29c0ecded7b8a56776586876178f1d7481937bec669dea2dcab44684459e17a69893d8afd4996d002fa1b7be4abfcc02fbc460676254d2220d8a1b6d616ef2ef95320ddfcccf5801c42e5314f69fb1c0935c01593f2831b7b7444f4b0bd781d4f272daa47e82c9a70b6c27bc3b8ed2be6eb7cc07f155b6d856143c3214f41ed64bb720f240b1e5efcc472d5644df4de7ee6e3b2c72d0fe8cbe8413ed84d4ef0f6ae178d45296dabba7a8ee6355c2a48b237db028a3d003c2157589c0684db3ec40a8c3d45a024407cd4f8a779e4963d7e00d74c09da9f5b9cbe01a2556b83187950a265aa6eb71a014aaeacab17be3443f7746801f434afcabac830cb4591ad044b3aeee9707fd02b1b2af6b1314813f8948cfc27bbfc071b5b3b481f933418852066a1c54d41173254b3f87d9c038f51e55c30062830a992b5fa70c5020ae173553a9c335553237f48800da2eead562120bcb4d68eb01e5c1d8d60b7be7277e18790cc04d58a8443a4413c6e1db42702323bec4cf281f4bc0a624bc840a367fbe664cd11a76d78201d1f7c3bd1c3df0eddc5ea756c849264f4521e80651ef86e156fd49fec642c3ab10817696c01fafe2fe7860c7db5b5078906b749ab0eae917c0da8fb741de27520d1454c4965ea77e243abca17c04a5506e864d0c11b71abc6695cdd2e278d2bce8fe0e78835c97c7688de9068b7a0bc9cde99e4c057b39e979d351eff9cc03eafc4805f7c981324b5d6b6c1c79d59c092bf8c7cd688897b2f70b9f3b99ae5005f0664a83c2cd4a9576b8c85e8e2135e640533ee1009e7353983a3cc09aad198005527c9ffe0a3f5dd2341acd2137a054afd59801b9971e8d0c13a0b17a7f3c1583955990bc7668486d2352e8e5887b2e10fb3690c5e0acedfe481e866d73e8b4e5f8b6948665b8912ec9850c705b4c18ad08bfd921f66145e15c9b81e259fe2cb63b40aca6bb9a85abb4315cd7c3050a65d6fe7ef12e50df778525aac7719fc644274983c72c394e715b37fbdc29ef2f1411396108f474ab68285efe87f4adf093bdf7ea8548c02d1d1b66a3ea8704074d5aa6c793a12517796e5d413d530e618710b92de509d9508093308fa7c37948c9ca7916e1cfcb381d5806e80fc677648bbb85c8c2ac49ca0776f0fda2750932c460435a02ae7452436756a832f1bcf067c126a735be15e54b3a38ad3f40562caebdbb50411a211450cacf8910ef75ab57d9e4bbd727c0c39ea91a1071e084a1fc27ad6d3a0ca19c79e877ec8beac85b5bdef6495f2f69a4f0403324350dfa9958331429fb0447e9db9ccbf9f4f7a57b0a861bb246ce73cf7e559a2ec52f07c872b8b66c2af941aa9e03490fe4bd214efd4347243608f3ea827e5b2ffbce5b02dbb62ed7978c67816000e14073b9e07890ee1b9074efa1811cba3ba52bd34576154754be373efd68fb06b7a59e713a871f18017165afd1694bc8deeef8b81bf6aae268db3fc230deba359c07f15ba287861e15e29d77c9de96e5d63c1b12638476bd62d408cef58cf52d175f78f6189490455c572f5fdc1af8732fb2754c14feee37e74783cc639a3b9e867835d58e51f0b19933583794a8f7a867979fab2b2197b339318983a24239b2b19efeb7d1c7a364b42bbfaf6e0f057a81eec18afdaaaae4ce195dcc5f5a0914c5047843a4e3f5e7b8296e1bd63fd91ff18f9f49f920f36961174d8c6a2f4923290439c9154aab5b015cd972acf5689945e4367554aab4245775f32804347dd6f7e91c473304ac2ccb349fd58fe2ba2fb2c2fe1a3619127346442624ed28f7c7b8dd050da0e918dd133244cb18cff9b5e0a04c95a19caaee80b2029477294cf42a1b4e6770dde65eacc6e9c441877aedc54813a4667e8f1ad3837ecc00c8978de8c563850751642f316b1ba037541f96ab084bd6c55126d74536ec4bcde6df6bba6bd0896d959dcc629587a62a8f9ec69265071053665f78d55c296146a2cd3f0440b397dba24785f400b2c2febb6dfdd6c77ab66e8d95060bf310254dba2578cc3852d92c2c4120b54a27cc0cd09f15ebef71d523e8bfbd9384eef7a1094137849e70265e055a867048830a8f032f2613ac6a519f7eeffab26464ff97c3e5edc48f4406e0d3853d02beb59eef962cee89d12964ab90d3ff7700f3b1a2ee219c2110926c8cb37869ce241aecb7be537373770b93a3f786821f97e9d99d32c66c6bd561d5a7bca5bb99d24326b40ea765fee529579d745f3e0c1397c4d528becfd4dfcf39957199976dabe610f614814df382c473fa31eb91a99d48efa23cd54b8a8bb949e9ba7cfd7cfae7ebe7f8f5bd8f17a58c8a51221bedc9a7a31899cdd7d9e0c29cb6ca01ec5b85776253ecc9cfdc0423b59b5136414e5ea5034376135b71efc3305a31e3871ba89b3358abf8a5976376f43e399bd5d642a189dbf536dc9270891a2b95c0b9dbbee8550fa96a90d085427e6f499665e3e80fe74da5d70912f4882e218b4e8d3ccb390175dc85b33500e358f4c35dd68eb40baeb9b888a2649df38d60d666382cc18000e7b3e292563452384c5ba4b8e55a5da2a241adc3c1dab0df9a6caf6a5c79a5be992ac59a0fe42f82b04cf67ea48846b678c5169d3d4126a1382c271a7a907a3ef3e776fb052ee939f99346200d4b78c59dc4f000e6468b9a70150d4f3c1dcddc30176a06e6e6e91a5c8099552621aa5a7d0f7b3f610ef44918e08f52a7c61f381b99beab3f0034eac6b5843b2e0e7b70a85a44dfe3f33c10e8eedb3019451f39245305e0cbff90f5bccc68d895cec878c82415b9e0ed840c00fb217b3f601373d0a5603823624c78e67b737b73aaa52e8233e83a7807e12534abcceb95a7786155b3df713d218cc49aefd7282eea35acd0bac74119eefa28383af009793dee83e16a82e1a2400791634735cd1842e349f70229eb8484abbdb39de3c4928907b859faa9c890dabfbf8f612418c565a208708be1c47864d2fc171afa679e140b0a50e20d9de200110ae53a10c19c26c316eed049788d4c6f0a42d042bada68332b0804eebbc6d989f8e59a444004dae38ee9c5df608bd82f7e76401557dbc6d2f325ccd1e24ce2bdf8785f5f838a9b5ecf9408bbd2a89234ce952055e23a92c5a0c6faebcad64d52daff15cf271c4334b0bb98306cc7c02224d4d2300abd965940e78788f6b6ac518061920c19a9d6e69376de799bd14097cc4f789ab83801e61386cf96827a04daa8349cdf899c07fcf7698482751c6e7ef948e414815a6cb31e6f25a6efee2f48406f6cf2c7dc35cb9b97cc559beb9a4641384c8adca96e3be86f81927d764def19316970805c300e72916b19558c7e2f37cf7b1582e7fc1324f678b8e484ff8cd15c126054de6fd5f90a81c76248a7ee4a73df52d2e92b93332ac60272e369997f91b13a0ac60eacd98ffde839954e061fda4cb0441b8ccc7b1f92a3d83fe2cfff1f15f7c9bb8d737ec9ef57f6bba557d2d4ce659c137cb45205756d8bc6447260b869a4bd978b9224b4dc27b2856da4cf1f4c3206849ad0a518660a8b2a8c025cd3e4413ba9e50c3039bf945c0f1e308bb6c222ff92837b54cf19f10a173771684b5ba33cde09bd5a5cbc8ec8f6a85f21180ac453e4ea7bf14badb68f6590994dd1cfb6041c0d81e0352942bd018d4fcbed11d1de7e2b36b0e78b32166c9b6145ede10cf216e4bfa91e3ad46db03ff08f0a05eb6a61f0fdeb9f83aa92c5b6d25a979cdfda3d48d10deeb16beecf7f4b99d2101cb2f25fd5d8a073b6eea06eb48d3f00306f11f1a48c82f3718c52a66351d352c92b8f2400b9154a90e9e2c0ab59770ba15bbad14d039cbd85cf7147fefd82221698ad8a4275c74870d708f56d8f8008d1fc6dfd4df9ef4f37e3930c7ae80ca2bbea0430da8a4995472af05e6d3dc88c4ef9b6a9129e3523fae41845727004b5747ca43ee37a7bbd74378c582849aff1b326b0ce09e9c48ca471efc74430506b9d8237233f5812a3af32b8a07c21051fc60cda44ddf773f6d5c1383ac00ad200483be7fa0074524e513ed3051a009abbfd0fd722205ea6c3221bd03d511504816baf9df5ffd4d6dc90b3ae50a6773594f92e7147271357d8ebee969fe08789423f044b14be8c05fbdd65a4f4ee2830af5823a9cc0b844e3cbd5f6b840663e67aba8c7d72942bf5a517a27509e3fd7bd609e9070c90c174056b0b4147b4f92507ac6d8b06b8194a14ead086c43b66f53831ed4ee624c07c6e41a24a0fb1db125222e6bd1ff6738105d7de7425d884a0560f5d6405644ac2b78a75c6a389d2d69dda6175b3149f48979cbd4e107ee5a5ca15a63a82661a3264e71f5ed885c4b73337365d26d1bca0982af80bbe5beb1dd5e54c03f6ef848372b1c0be9a44c00087b175e2ac21f6a7db288b9e6443b43bba07e126491ce0dfe00b1afc376ae66a643c4d475d631188981ced84070bcd38301f66cab86344d28e3623e034a5618e358bdc20569e197a10adc389ffd02840f05a163db75d353b7902974534c42b32fe74a2049c7a16f9adeed04b36f2ca1e4d3422db62cc141d6e93752b30d126c085c35a40e3918f5b2baa06e70de9b2b6c1e470e383cbe54391b13605be442b9f5255bb47ec35791d14153cd16dfa8178965999622aa144a892a8914cbd693a9535c051fd94272aa8543b0420bbf9f65ea7fe3582841c529785f0e82234e464f6844140f6fa90fa499524fdf306cf091091f455ebdd0995e83db5164e52689f9352dbb6f3b23af284b56ba916dac1c80b94e67b55dbd2bc69ec2b460d8ce11a5dc32e9fdbd93fa4a4495ee5008ccaeae3f2298248f9abce186be5d0ee07faa6ded142b64affc109f0bf2e97e8fb1d9fc7e789e01d0a27f1d23221c7ca213e2fe2db58996016d27e7f05896692890d65f32340b928cad36f981c47450cd4351745e1a6f53c245bc551bdf34b84161afa741787cf3d0fc977eadc978d6f86a5d72310a263b53b22e1106bbc25471c288c87dfef972d7d7f3324021552d40a566cd2a00ace4726ffea4278f7ae4db2497ccc3c74ddda71a258b506275ffc4de7d0a3f40142dbcc3e92a4e88b651baca7cc7bee3a87d5b0ca040a5ae735dca04c0909cf4c2c2be6916ea0f8a9489bb512fd06635b5d661c15c75a20346c414b45c1a26ba052336f4ee27dcaa6c7b7210467867d9d73a46d8a28fcba485ad223a155aa7c54faed1736ba74e20ff5a2c88d087f610eeb0ce5650b66703e9ec2a7a8cafca77beeedb1b80a04a68acfd61975e4b570e1cb5d4e28cef5bc0911f41c1b1c3262ac2d63a7f215e9d0ac3ecb2c282a26b47647f4619f25e406ff07e7e2a726f2402929aa005d09c4ef4eb534802e9dc5bf47ec1f0d03195c484008a1f8d8749e794bcae5735779458b497f25831f2b3f5c832dfc873333b1a4e39fdb9008f90bede20b5c1f387e9c960af2774c872e73c332ed3c41836baad7ec46104d5e1a63f882f796b088a978e46dc8e2b848710d2cb31c5f9973a066bf56984400f40d8783c1946fd0a3099e79c7080875c8028ef1ea3965a88e1f7b6590ccb603d18cd61876811f3aa7eb794e18ad312cb78beb5815825b2925722c6eeacdc7c5bbcb4b9d8c523911e8928252f4078d50aece960cb349d4992ce8787053b78c1278a20cdf18f148961dcd43a5422489c42cac4fc3cad249ab54282a51d06a2e5372c24349747d0073cb8173bb211199649859ce02c08c22cd87dcb116892ccfabbdfe51913aaaaaf823df60849a9968e3ce78291b434fa46c67e21915e0f0aa7d415c49dcdda9bb76d6bdd730473eeb85134543b8b7f2d3e2a820ddf3f6cb8f7f164a347ebb6a6503645cdb749988e1f097a13be64a8d83f27deef43588aaafae261f6d3a38176ae38469eb188ef66d7c24aade8142b269008732f15f4c81352c932f87610cbb0806c5e973b4385ed87ed126bff426f7cdd831ad33f6d56da7e2bcd0aa642cf439a272b42f70145331b2a95f0c64d0bbbbbf7aec685bb3ec338edb05f0a42fba5a4bc313b9d0b776c1c6057a61ee4f0c740452fc6a9f191233a77ed2e030b7246b2a4d3630d49da51e23294eb4492ab096eeaf6c0d66070b2001220d3a01dcbd12014e89efceee4a100aafa580d893d1c54e76cfe2c615a5aca94f51d42db7c1e08432929500a7b02337c1cb8daea5dfe24f9df8bec3320fbf3d49ff4285572ee9dfc0ce789fc87f33e7c099ef040ab56c82a85b3a3f4e31a821c509d859f7e6ab7c14e51ed6d863ab254b85b75c8c9bcfa5068dbf3f4349be5f3878f1e022feb8ceb6ebdee6234f7dd35123fb5e808cedbd13286d45c8ac81850db8c22cb77916d23b635f4ca939a8df1930a4380f96e9901597e85c38eb199670e5705d38e7a39da43797b50f3502af17b991cfe6046488b7c612aaaeaf45dbb4b1572bce47fdac93c062b41ce6986d58177f738e389f0e1ef29fa4ec440e8134c2ac70b6f9c262bd30b8ebd96c53abc5f07e4b408451a822008f68857e332e3d212ee7c237c88560ebd8da68d67e90c2d2879b4ac56c01bd7bd587c646967d1080b7d772d04654eec0fe921ab797bcaf4ea6137baf8901e26ee455d23cc65135bb31ecef946c2d5c3d73f39456d60bb1c9a3f2540a24de360f7ba6265e149f20489726e274904cecf24134f685925af596ebf6f90405d987c4e45077e406d908d50206bdd64c2b5c422097fefe890bc1bc3f99d8297e1a25a83e5c569d2406f1f6314868d0fba503e6cd2de978e800772e8d2b58c3d3a4c88b57f9116b4ff102f989013ec0ec29a3248adc6006bb763dfa40e6491e5a0073ac2cbba1da142ee770cf55de8952f52837b7d1c5312fd05edf498c188dbcbb57c85c4c34036e3b3502df8e208e18e4c154434c245b2570eda7100700a33e16c92c12d21540cef92f1ebe45a2bd4917b54d8c9c80e250b1164636487dba7ce9dabd3fc52b144ee010cf8bc23e5c31a30994162d9cfe47396cf5b1aa4f124930e01eca6da7a47240250499e200252870e3bdc2769dd84415248347a4ee89c4e7f5b3c998db7c19a4058ae74fffd177babfaf556d09ea5a754d261e177e9470b92ed2a28b2a5bebb67261fe1bd25e09da7397a9c33d880b842ec0448a0a20550cb763ed139a2f9dc1c54349965673e037af22a489826333a93548904275b0ca2c922b85cf8dba4eca470a337ad1e3f55d3fd08b944c4ce922a33ba08e7a1ca0c51da779abe46390e69be3e1ea039791b1395415d5f52972df33e8bbab2f829a225ee4416725839937f2ce111921ac37381d10923bac36674167f5d3058aa5c89ecf896d1ab8eb4e05222d13c70a533092e7a607e58d1480bb8d4e630650c0df4bcc70e297a0389bba4a20e308f7ffa65ce236b5248764d296c14ae8ef57847efaeba41d64370f4952bc67373ca264f24cd508c455f70302133a82b4d9570f34d385e94fefbae56622456415dd5dac2c5bf6e207680733d2c3838932f82c0025f7abe4a918688f4fca322ecd9f488d6622f03bdacdcf5306ca6b4996b5958851d2c9eb4b6b98829e47dfef4bc194ea06056ddb9b85ac74f79e4d7e813eb8501934bf0848ee2ba893d9f4bb585cfa93db95b6d229e42c8873f02ed572702c8e79d2b6750ee0be68e16da125dfb5fb0948b590f8e26a00e6f8e65bc7be3866682e63303e381beb3530a3ac198da8a3c8586f80522b87bf44f80eeaf3cb8f12c522647360ff541d311ea90bec42f971043e746bfc1a21892de3e045ae478eff417e27c459f4249a2b325255f6612d1180ffef12d4be7db13fce62d5d64a2e7a8f15d07ba85eec42ab588acd9835bc2fb570fbfb8099aa503e209636407e936d1f342593b1b7d1fd7598a5df4bb63ca51bfb20b0b22b7564bfd5bd8fdca0a4e112f57fc623de66e7fc180659cfe69eaa3237c9505bf03e7def56ff3a72ca80788ff793a129061a406d51d0cff70460bfdfee943528ccd017aa29f1183abc6423627a3b008ae89b2b9f3eb5d27bf33464ccd7281840e9c9334079e50dedc7b739478e138e73f525c4eaf83832e62a4063f4945695f8284b1eb20fc45e77147314a67f2bb492d0f26046a25dc221eb9920ff2c687f2f42180214de80293646191b1ef0df207e5b3ac15deedd75ff55b457282cb456092288c9ed217f62045ebb663eb84e667f3decd2411bdbad87d9ec2138d9e524148f3ae84f015115f4bd3a425f4167ab2b31ae3c8cff277d3627c9e3df84761c0aae3dc678b5a7c7a6d7d25708912afbc1967c37ed1aad59b451c996b87b5b8c9571dd82e91486d5436d868cffd754a7e486e8ad840ee183a9c95834d694dd2bb3174c28f465ca83636d0f55fc2d390e2798649c8ad7b849f2f1002e05bfc0ec7142a958edaf6e5fe3231a729af5181b38c3f5b2c31aa8808ffe8c780290c7e0158e9c0f30fe2356ee8516a82560d38aedfc74df8556c1d1ac4295663e95b97c9053c365fa3956abdb464de6e686704fa7e9973ff75d01275bacd6b5ca4ef7a66fd9c84ae4beac73366491719a0cd8963dd042c5a4bebada6bfba19f9737dde4cadcd672bf411ff5f98f1d84637bcde119071c5ca65ddc6c02408b0ec50b0c0f181a41d3ac49299a63392f35951ba7b9bd8f1a3c56e556e9fed734f2959c6dccef2bf303e4f316eef6b277914a0f9407063944df01ddd6abe4eff9cbde3c44635e581d67387512d042f62e8ba51d6593c25a915fc72f6dfaf0a4bd4607fa04a68bb2021379aa852eaab5583426b07287dcba70d4f541d6f1420c14339e402b018ec4118830504e069295919d058e906ea573c005b17e7fdb8a24cbb588c5a9327fccbda5669c24bee3a4dfc05b5890e6ac3158fcbe26b125ebf9200147d8f572b3d6c9c48f930d0be68d6b68615905283f0f0a7706c797c4ee4fc67526ab484b97df7789afd138f1d8a3607a0ad1146006b6be44aa43c458506f42fd7f2dd62046fc5be6483f9d27669e738958c484025772f6a0e098586feff00b0dce0470f84743bde7f1322e02b6cd28dae18481babdf06d18a1f2b5122ee34c71fcfda6f0f2e73b60117ad7e3266b91e760963288bcd426967e41462a57bb21edd8ea7bb582ee521b45015fe5d35a9245b44e71c59238c4acf61463145140b3e1f098af45e9d92b6264e58d928cce969955ce97f77415094e0635d99d91e1dc0970d46f91ae5c3d528aaea6a3e550b9f485e74faf2918ab7cd45c8d1c6f15449e94bc45f4af923e28c198dbf23b96fd7addc2f703f2f3ebd6c3bc18a0ba732060135c461d94cbce4528ef86da0c3eafb2342d54d4b580ec328341141f5b11c27e5c540546eec3d559ee587b405263fa71471a0bc303cd1a95bf4a95a34d0bd6a937955de9995e3b3abab985248c57bb3099dfb791cb6585edf654e1d9864a9802dd67f8e7040f000ad5931b028680474b4e38f4feeba1104ad96a3044986b4b1030ac3fdb189fe9568d07f25dd8e20a17de2c9fe47a3e94859deb863691f0db6b4024332a962c852bc86deaaa5b706f389e3d021f02a2a04bb867c47618fd20b9c438e5f6066b43f301db69d1f73957c778a4290e126f88e49c70c7bbd75e771dcc1b9aab347eaaa590e4aa554de3e9bbebeab54a1dbfdc040b16a0e5cf799cbb4502588ca0e3593cbfd0250d6475dcc93d0f0f1a4dbeedfc79fa6be622219a6ce37a8f9a002f905ade13c890bb9787415cd2ec47b7c24e2661e9a365997c78fa705554f75cf4ee86e25a90c35872ca15bf8ecbfec64330ec1e65f7da0e7ac1db78072301cd099d09630401ea12bfb9789a3fd77cc81cce35fb29b83faddd259e364aeafe6a7182ac3fa21f24d3d06e270b9ce4007651c95afa9d8a95b1e71858713731f4c39bc014677176455535eb32bcab65d9fea1b876b77079be227a7ccb8ee0327b48fce436715f234c6fa2c9524f7346f45ffddd734a8c67c16168fd6f853007285ffcedfaa6311fd627e430b5173006ccf02775abffbd32ee8952126ccb2e6227604d474831b9e065139aac64c45a3e5cbeea1d87dffaa5a8279c3a19bfa88a0404606396abd279d8a36dd69d4ff90b6583f2318698d272a05ea0883167ba56909cbf14101b6700a95e5449a788c3a632494ddc5ea231df3f5cc14703bc3559f04078e75d614b6029a32816e6ad6cb1084276a472e851a40e11301c778f1c295675ac754a83101561d20df55079f45bbab00bee9a2417ff764caaa6153446059ff551c99dad2ad6347963e6fdb3c6bd5e54e8f5b292da92889afb88aa3a9acfaffaa206521e2e098c264188e2f66b3e2ff0b2d9d720f8ea0382e00d27840f4970bcbe7013c26fc2a6c50a64dbfe87aee6d64b75506142f4a16cb289b1762aa354824526ad309dab09b52677c1522965fc25355a9b811cef07651c16aa6f01f5ef49ea666044e6752d287f11f3a639556ab85a2930100038e7b04c3e4a169d82f75dc89908dae9e7dac57e91dc2405539301ab0f62cc2eecc6f696fc9b7fa4749e92c860d5346e1f741d650e91dc316476f18ff6439502b0eed1115bfb185b4903acd265b8e5a768b0e02a682d3cfc055887cf8a8319a54d79d5ed18f80d079d7369dbe17169be5b054be9919191dffd7d10a83fda2a8a9e38a6649c6f2e5ec969281988670e4a19772edc1720ade09861e6cddc2aad8b80bcda4e2d1838f3f7494cbda70bbc070adc9ece9b7b028c1d25de11ba49f8d8a80c034553ad8c2a0b666bc305d63841e8a9365aeaa2580a33741994f51a2534cf1f7540c433b8267435165246a283067da2488697c1d151a3ca86b5bfa72f86317ed406bd324613bf3d0c308ffb3c91f1e21a09f780bb918a94ed94a3b70bdab5bccea7fcf7b1649ad5b6e5eaf05ef680a77955d2ee05fd745f6803f52f9ce373dace3b6e84a951e781d261e2dda8aab84b491ef08e817d34e57d54e62af5e3c4e7973ce51681c30dabc94552d8b53b17d29d22899ad44f7122abdc7a617942f70eaa6a5a0cfa60cd135751031d48bde6e404f47159df32b4f54a07eb60d23353fbe2ddccd2c6e34e71e07177721cc9989050f0c144628a3d7b0c311fe233e277280281862655091079bfe1ea6a71cf1171719e70d1ec6efecb1cd4634322271350791acf7b789ceaf06fff01b2b0a561cdb2d793e165477fa585c0d9ec0e1916d7cd2ba59e9bf89b4122e9a5440a8446410c98dda1b509616a2081eb3b65dc88621195f410dcea306be0fd5d8817376186081e53fa6a62b71e5e0f60b3c90a394d9bb791f17a145277e74f2e3dae291b0012676deda1d1ae46174317f8d4f8955e234cc1c67384795170aa1621fc921309e2f7709cda8db3cce9fe5595d5c0b7e5b769512f86ea4af847b14b100e4fa0d8599beb5dc7b38d0dc60ab2032ad78ffc3be40ef23fdf24a92793b16297966b3841dc75a365c94fce6937d14cbda3daf1b482b3d09c338269f19fce6dd47fe33bb3a5547ee3697b9b8bf0b57eaa1d9c6e4ff01ffb1ab3d84f03ddc10e2ed8eed8011830f7d454629db272e037da7ab71a4d474c7927e7f2c405b310fa9d9b47c2d0659849e7086cba19e5bda567994c7189f5203618bf132a97ed69a560187c4c1af14006131854bb0814c053cc00c0d33a85a5980912c96347c09f4ffd9d9b013ce615a46cf9d8e95c6ad1a443d5522eecad715b2ad30de17d1a3789ba618216cf90ddc7e8a8aa411db6285e2a31c278cb0fd326231c90e7b3f60c00a83374240b7b2e79b341d4a8bca25916eec62bea4c5e94a9cdf60dc8739371e7a1a382e12036745f74a4fc9f2d42336194c056de7e94b8999a80517092af26cb85e68d6643c8958dc2cd7e1ac8c3ba0a174a8e199b235d708633c24b3ecc5522e1b7922c0cb5c6e8f23580345e85a1ab419d73cc8cc55b98127c2d704b9ca869a63add4bfaa54fff4f8d6f060e26220956886d6ac7279f57402b3f910f8719217939666592560d025771a0641f4c92c1e7cbbde09bf7a997bba491d4f1452d5c1da044e8a6e668007549352d824556d5b411dc4075ff39e3ea2df1384289ff299287a1ad111d581721f11d232c0cd20c2c10c4a6a1869dd87c85c4efa4223ffde62a81a99bf85aabbe0bd6cb9de849b80b44b3d46982facf2b0d4cb4033a0dea7118b3afc8561233f5934fe8b2e96ff0932139066f4dea2294f0dba0b63c8829449d3718f50e8e79c9b1833e8fd94afa8f4920534cffcf97d35bb7f621c8f3c57809a6e5a74f864080034498ba7dc237586c3084225d47623aee3706503aefb465a1187406123649f30c9e3a09e94268de16680b7b26d041e1dd1fc78f8b9bcfd5f5b85bf29390423a0044688109288952fd10c100f993dbf74847c52d0238563b611a7ddd3ab0ab46a3348c57467c186ffdad1fe7589c28faeb1e84151663159dc1bf39d485c211d722041b4dbfbb83ea5ae5cb6f6c786e1cf637c2b81575dc1cfa48b0f2bfa247b670218b840e667b7def5e74cc7c5e1ee4021fde9542263809bd75b13bb8506fd63df5542cc0453bee126946ce1a35a80724d8e78a89d82bc2d0ed47684248b0af02a89b79eb6c93d429c1f7ef2f0a2b176558dd0e55e36e7004166318815b6e6446261b3ace65db0686064cb020fc6650a45e68392f661ace6df47999223ba55a40609779f4ace3e092ff85784c1cea38692bb8fbce31a82668fdc5cb1a6bc514782adf82c7e77ef31c127a9d521efc716668f0d39677a4d11c36573fb7bd3e36fdf6cea56de854088baf783f8005f890540f212bc7ed1a9b75e9dc6a07e8ce74434c19635a97c36f37b4fa92bc4d95d259889cbd5f5571a0f9b503379a1948f1314420811e06f828f8ffc831d0f0ec0495ac02187c4ac0b767298d793c2598f477a36aa17c7f27dc3cf0d3b0c89632c6b052fea2b9ad26c8a3b40ce40513994513852be9776480478e747601ac0b9ccaef7fec04112a4c3a8045f01c457982f9bc8776484dec306a760aeef3f9f8bf192e95159fdaed7f4bef82bd571f10f434c14f119ecf6ff22ad3907dbcec1ecc066a72e31894f2995f278127dbff036737a0dc654593df446800649bba8805ee991e985a698bcfe61ea46fa02c8a139c10948def94760ad282b00e75427c6d4f345bbc80728246c520a0897ba5da024c9fd8158931a79d694f8f87b4cc6ef2060b8abaa4af50d09ddeaad01517997486ade9f8b43b42fa1df1b099c007d681293f09728cc8dbeba62154750bd7746a6a812260a30c80b52eedb3dd1d4502d9759ddd23567543de71a77b5debf429f72ffe22849a20bde1546ee56ca79b06fdc27419d8ee5d11e9650f04906e33d164b5ed5a1b081445d4e9e6b4f7aeff4116c670b95e8f2c2cbe4e09af38315c052c477566cde6cf7beae2fa9f31bb821ff4652f75aada27cfd7427f0b29c21ee2994c67b0879758fba5ab0b5e1a8e4ef437698fbe09034f13fed90464985d1cd9084da1c338d03e2be4e1bb19f59f835ee9da443c8907f5a4080221b2461d5bc01aa7af6f7507322cb89b1e5771c942b59ec75ec902c460a89aef8e61ad80f1d1d2eba0db62b15929cfcd58e8add055d4a404332f68d6dee0d1aef6d93ebb4131ed1fe5fbc24b0104f041c1a4349f6d995d4cd2763d283a4c760c88a0bfa556f4b3392943755754bd5d7c1ff4581cf6099ef4aefe349a811f0e5fd4ef04b35fc91c69e2623ffc4d9135f6250314a9c11c0719e7b7ba31e8dc3bddbe6e327bc2d904bb89245ffecb009dd9deba1b3109849af6a2ad26e7b47f51b4b77e970d6adb267a61fe985445ad2d625906fa32808930d9156c31693ea2014f1da1640cecaf887644a7ada049f046c69712fa489ef69ad5a07ee88eb417eb26132a54f18440a1f89f2b54e5cca5d7c2cd776ec054371703c636a8687ef3f5ce0604b13e969b5067f31a747c1fa428b85f26103c5513afeba2897c5b8e4f000b8fc6b7ddb16d0f38d798756667d1112d40818ba9766ea8a2ec4b301392d1189c7cb4955816a7d282372585da26e3e34fc4b3e74284e3049b6746b90f8aebcb990a556bea6d89c0e4686b89a6e9b8e050268fa520dd63445bc9147e7d7d7bee0d706598aa87b1a32492093eb55fd39eccdc7d788d9669ad0281a7912f7670972a43c3cccb27ffc8238857f18f1063f577651926d8b56546aca03aa496b2b3d30c484d3a80f7658ddc37eb60bd49860141971e2a5036a0e94eb889bd70549b6a10bd97b7d74133a7eefaafe278e7582cfa449caf4ad9edcc8e7bf1b9cdc23fcaab757317affe6fd7427e0d64a9355cae8bd4844437a7ad8c76f794ba803670f4d94cee7758152ad5f24c554d2fb3160e8ac68245f14052f6b0c9138beb9d6ceba45979d09260f8a4e1951beb5584e97e9ba1af8174255b442adf8d805764a217cb9b0c47f78f35bbfb4776776aa6443881f350291e00bda1ea783b95151a3d5acada79ccd6d0752be745b6c9336337cca057e530f2c4f3a6053a3ed6fbfef555b91c69ba9618a90a5dee6139f2fd87da167bfa9adef6a3c99ddf80c1b5b03afed7b9c37a36c82437901bdd5b374b87b82ff57202eb5c763215fb4930159be28d5968c3493e76ac85f9ac37c843030867395445d291a6adce38be3f820fb22e8dddc3ffaf24bbc72e44fd86b5d9d5f7e97b4f69997bcf83c96f85a8decf1b83930739aa74eecb2d3fa970bb9de3419ed164bdb60e93373dcd6cd6b2fb4f0b1d60a3bbb14d1d5283c223e5044781930d45e53ec25d0ebad30f6d6865fd4cc7394ab97b5c4ed5153ce248fc9ab1b3cf4cc9f9c1aca59f920f40ca9dade79717bb475432c17a623189b1c88fe4eb76af5e291ac878588158b872fa436d74560c28ad65847abcbf75447b6b829119c5cc3d77d288c229249217aae0b7315fbd2d231543fa9b45e7b1c409421416b7086beadca1d98743ca0b14d7c62c02dc9b1f25f5002a666837f7adacd4f7d51cca186546918c36dedcf9e212995f8ca71c96fd128bca3f491f5a54843795eccfceabf429e97c338518699af60b3a1aad7ee3f1f5e4d3a330fea9309b75e6e3e58f67003c367cd1c1c18436bd49322c8f8ad096453fa4447374a8db0113f621ad403c6f71ace8312fe62a31eb7f57bee8d397fb8ca729afe33d003f47b4e560e5083fc47cd244680212551929cdec19433d7ff8c3a7807bb42e19afb487a8521079cba65a9e893e466fdbda030773253fa47b468709a3b0ed168eac39c9f58e95dcca734a55cdb2f2fb0b56d69aa70d99319c13c1efc935b31eec1a1424463f9e095aa157703f08a39d15524ce00da54a8917f03c16accf7c5db030ff3f83fa6b0ee6e00ce380a6c1cdba6e3874fd24980054d621e08700ec9e6ef0c0eef03dc326b97dd1e161e4c2f10839ed167daf2f9a1c2821d4ae59de309701806569f13b4f91385425af1ed6cf044ca07b80896b58668fe00c8bbd6c394c9dd44e9d3b6022414bf18574ab3794cbaa726ab7cb498a88f99cac20a5abefede02cb30a60fad14e0f72d5ba4b94cab23504aa2c62d16725edad27ffaf430372f90748ef886b29da1e6d45e1e9b5c768fd005d2e501c010de927a2ddf1343c4bea80055b9059f825abe09eddd5a0402bef4cda724ff545f1e97d7e6c091df6d90c78613b1f923a216ddc61c257ec1cba1255c4222d4155a4bf359cd8f24da785e075ac813434fc421c7684964fa3558eabad7be2be50a76873cec829b43c858a03932e4120406cc2e2f9263732e683cf5a57081d330b370a6a67d46f9734adfceae3dc7cab062e54d819025f11f78f38584073010b2dcbe8f85fd8d65db4c4281e981c112","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
