<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2fb807cb024a3a2b777c6a442aed93ce749c51239b5de72228e54657b7dd11693576b644d4c3d4bfaea3d251e4d3c1916fef99b215e76587bf67fb23a77aeb5898a6d74e3515c07721642b3e29424cccc459db6735e32662c0f9cd54ef2a610c1bba348f76e530b9a04890393dc1b8abaa1ca77b874ed66d80407c5fb86e309f3fb627d8f1184274455122b92f23fadc54c3704269bb568f508c097bd855ec58fe2cba1f37fc845069a9c7446c4ba9e41d6a3554fe6b67d343fb9eca1d3342046b8e0c2f4db7f5b79a4aaf6576340b577021179ccd5c6e58db0ece3408681d50ca7667d7527fc9bd90c295b8f23d7a8c273381986c4badc06b5e95f9c8b341d2e5c49b2528d0d6cfa99a4069fa62ac1dd350bf0d0864958b89b7835527a796655b28d20c52a574c3877f5f9e74032a6832460d41b31d6a747cf11fe37308cfa96a314891d40489c21e574e974fd9b87140379646b69fc3741413cc4b70fcccb46efd067b7663e23afeb8b6bbd82d4dbe46b6bf9da50d10428f1967799c15898bf8011ff0880a61464c241affc2f6760cd2d476ead113ff48bc9bb24c2ab61f9e10bc670e0f4a24f1c95102dff08fae294f670f438b54a568bf710db1930384532db95803a4f741e984b47f57fa503f5465108dd4bd7bdcfa2fb58ea6d15ef1b5a616fee4b8d6d277ff63001c75636043e8967b35c55e49f0827f92de4f10e3a49711069f24ecc093fdfba1dcf26a6bdb13903cc8d8975e181801faf4589894d1e7aec9e16905bcab6a5a84fb67fb8f1d93b5294514b08b82b0c38a85b03911b5df3aa756a1c6cd2ed7899639071432bd919b490bf314863b21007ef7d5d1a8bdd01c2ee137e927d14f37c3470b37538ab1d1cb46347c75c8abf458a10931a247844da212798ad84ca23bfa494dff9778f439dbf71ef366386405f6821eb08e02adb39d29e455640a1dead2689ea0040a241aae886e660f98e24cae1fead758f0369e2380d563ee543dfe63531c280ebecd6c76ee2ffb54eea5f142c747f00ea50d70a2f76097c40ec5f918aff9f5964fbb26fd185704e173a0447f8e3eb182de74af9b01635a736dfc52ebdafe6d7a611f2ef3f9489c02b121823a6635dea781154637d1ee4af40ed83872c7a0c7c7595dcc23ab7fa9fcae1fa95aa4f52b79a03d1423a1dbe88b7dffdaa72faec2de868cd2277692409236cadad980b45dd6df9a185413070ddcf86adffcf6dc009d527a0a4e5209473029712578e74c45da86599824e303b74443927996c9ec599c361f9c1c4e237592793ae700834b6aa4353c9da91a8ff6f6fb97f0e27af7b708c8e7953faa36cc33c8bdf760dc0d256575a24dec09b74cc5e680fbdb7c31883c37014b63aac9a2b5f1f29b95c8f96f82b101ee912aa6d37d97dab3ac16c30ad472dd0ddb574499d027e90b4caf6778afeaf2941a6465ed8330458adedb65cc96241d87ce202acfd6c0b9e036eb486a27973e7e95579e9d0ad0436782a4c792b042ae9be969fe93f7ae7a86cced01487e4b720a1953c9dd1b5cf068ba64ac5e5f82feb33c66ef49a8c4be14e7e7701cd3abd5bd052abd9e1f8ea6282f5aa1445654fadf79be4aef1e94e4b21f631f01dd27d35728eadf4f0ff477705bbd3c81bc25e06801d19f1847023d7ef215b26b4b47b025809861f1059bd69f4c172421453978a4fbaebf74b94b7c21b92689c3d28bdf8aa315e7863bb77cfb5f6da6fcbfbe9a5567457a0d1ecdd9bd511c528e52ec097ee7f9a8d4e9ad43be30c92844944916b3c091fe4da26b5cb9f297b5f50589b7ccaacf05cb9ad4dfb90940b403143b04cb3ba6e080599736b361585df7106eb48271797024b4ab066e37d1282d88fc6e6fe2bbe17f8265e0d50b83f130f59d9d9d12f311ceeaa32913a997f3ec8df5e87a83c88970a457ad34ff2cafbc2fe2bc9158bfeacf08b756dd965ae1d08669b940c834c29aad91ae2bd9afbf3d13c5ba8d65b2aafc2fbf4b378afc000e9aa6dea5466d9cfdcdbef76e5799c3c4461a28941640aa7a03d456c0236cffc20774ddecda066ae9f5a2da0844195341e1941827b18b687b46c142d9ab9e0f6308be9c9eada8e5eea5c930093cb1be39ebc627bdc282c84cf28f127033b8c19e42fb9405b3d57318dccfdc2d84e8771915c81b9b61d2a5dfe4aadb414317ee73020c68cad2d7c6014cf1fb5b6e285f9356af5cd0d59bc0d0bbd90a010f455540de3020dd08ad87aa33679ce9898753c0192a032424fcf6be6e623578502d3f596b63066d08cf459b77be8ca4a92d31c62de00dd4be72c65950a5dc2e2849f9d068e3af1056ac483e1d7cee72ad6eff82182bbc17053bae722d2ba240a1bc4d93256af7b6cdc00a2cfcf3c002e0c50529b2488319302563576c456b20c65ac2e9386d5df95e39c410eaab51c79d9eb3c1315fba4b880b580715597e84b5ab8b86793f5fc39af1d31c3e0c03a9fa82faba7ddf853a4c355e34b759b1278accd9c38db806dbfb2f8a1e5b234b0cf5354378a2552de2a24f673720cd560d0611c94f7eb987159b409d0f47279f5ac06782e566a4d85d2ae5c68ec885e41b45f5def4732126e690cf8f1eef36bfba59916618eb2c656c2dffb110b854b3cef5818da00cc748b39a22d376c8c8de7206a07ddc37d2a485d429748a36bcec23a33cced5a4735798ff4821953272845f3428a844388b57564da6d8c843e560f9bf29d0bce935536c9910759f4da306799fd2f493426c25124ea17e0e9a6a9b7da942f46e39204cced0d2f46156ea264ef4a9afc4bfc9d389961b36f298697a2a571c26777912563cf42bb8778a4785e66fb46bcbdbd9e7dacf46fda16b77b07ce1bec9878bc5228d92e08ae09804237c3a0e274b52772623d6109948de30f041db08a3154d047a7cb2637820dd17dcacae5bf98c171edd2c64823dbd74fc299eb3bd70b50a31cf6f2d45aab1c6fedc4290616e0f1fae26ebfd39b3393637a0bebd584f34d674f8692eef8405448c248e8898f583435d078ccca8197454017c12ddc6ba06581622c06baf1c70c605ce0ad83de8333b115abb3a0ad39bf95d01dc4e3585a57f00f68bba82488d2573f5cfd6edef0526fe92317879bce1e97e32176599dd968f080a058268ebf2954fa0560cba163e157327e6b84b9f3c28c326db7ef4fc13600022c98918e89d42b5f96434f42980576a5731aff79aa9358e5c125e6751aaae52baf5b68a6933f1e7e24be45900f0ef0093e639ea3485156abd3909e6cd57fca80175e9050248e387dad86dcb90f4e5b7b3ffeaf703e134e17ce9800e0a4e0c5e34a885a544f6ca9cdfdcdfeef2f0416ce609004df036fa50c2cd75e71595057c50212b403371ce1a50549859fe0ac115f6bac48e73ab03188c94864cded543b983e7a38202ec8e64888b00fbf5a27f8cf53fb866eb7beb3e4061ee797946d6bd419e528e5aa82be1fd71963afe3f278a4aeaedfe3ae70ee5dc91cec7cbaddffad2091999dcef6139433c664508919f4218f5a0abb0d3e488c3c48694b899157320050d38ace5cb10b573e40c4ec1b434874368d2177f2479f2d898bffbcbf71d7cc45e680dcc0122fa7ab78d3eb0834a95a8af8716aa64f32e655c8e9c3a32ec4c5f951302ff657f046dcb67139f35efbab261b4e5f5777de6f255df58815b1a78cc09652f4e05e283c60fc60e40b94229d4e7f1a5eec1f447eb9717e7b4d6dc75fb12e406702ee3d50335cbb8530e4e8ad4a7e43e81723aef70cc369ce726e3873ce736fd3e2a6142c183cc11e8b1898926aa972ad09bdc750dff51c93506c32ded383f53e3efb8188bb6e625def1eda5b21948ed993d86519cc2b5e9c069906f521d5e07c39be88fba88cce330ce974dcad3e05cb5f2856fe1f68775aec06d2d18296e5d57382759a4efb516f5d21df7139e11bd1c98d58e424f195ce69b924f2650fd20db06ecb49f9686df8282f3d43b598863b768502e5789c47592cdef83b48782eec26741b173bc8fdf715d21754156e539542658dc3307be9843b5f0371fb4a39be090781032395d7d884c465833cd0f8318839f7d7e591fe8ad629e2f82a6237350e8b71af8f11394115166184ee67cf9d91f487bc1223c8d66482ab9a79a4fa832a4d07d25904c3a6537881bcfee9ed9472b5cf231ed625f081b0146f9f137473ebe91ecefeba900183ec039eb21e7f218ecd2155f9976134dafd604b1416729787dadeee2197da4044e5bf6cae0c58aa864b14280492b50be49a087a217acc14f8c739070e9fbe91d1608970c6b391862f3e1735e0e2db5e74306d7fc233c4d23b6a5f861be91d53d9983d4a87dde22551926b196d030249817b3026f25152b1d22935f078bdbf430e6de648279e5409f56e1df03466c152791303cf0382b6f89687f80b8c2b8090f2731079427dd12762931a826f069c387db59b0e36ed9c72befeedd921d76814057d4995a636fb8f36412f79c8aac1d54888c8fcee53fe13b29424494cbeb6ad6c968c4469459cac977b599a9d2a7e309513874fabda95f0dab856d6d1c438d620b71b3baeef8736bce8770f039ee300c0e4c4b00d79add63b12416dd8a173b4d2ea19859e2616fad489983b4c8cfbd40aa12705b63f5b0e4fb11d115122215c64e6c1afb1ddd823fabc63a9682e0e4aaa56d2e2f180afc9a6a22ecc5daf21aaf3d21516282f6d97f8f7854142b37b61bde31b1d2a31fdf824594456c77af39efc652c28426db20558b31015777662eb1c68591e4dd8416944b3d1a9ec5650477ae142509b494b498ad307b4623dfaeb3f64e1304fd2df7d9b136caa6bffb360fbd355c9ba9fc250a677dfc208d0ab02a780b53b9b830f1b891a0da93f435be30ce135a8802ff1ab6429e4fe52a8554f9417eb369e082f32e7279a91008a36ac7ae077fc6e09567e94d918a8437494444cb086afb1f4e1d1cb7df50c5d712582d5509f4ea8ed726d0aefcdde8fac99cd369fff9a4ab7d8e351e6ba181cf908a2c133b4eb898d744c55d5881a35832b6e6e444fdff291487e79f2eca117569ca62d0411be56da0638492fd8096bc2dea7f3a884edc7ad31892cfd00e9c109406970634b744db3ace5187f6ac279bb0eda932d3d1a13de8d43a7950847f1f00cae8ab1e09ded7bccfae90024e4a1d3d33b7ce2fef01afb2bb483afaaf8b7ea047ca2d5a2e518a079465241738af0c46fa8f15ec77a5afe5e25eecae9bb39abd693ef82240ac17b95fcae979cca7e8f7df54ce958c116aa30d9daad3a077f956bcfabc9eb41b85660ac65145e6385c8395be527c1e5b35024f8fb216f1ae7e84a2a5fce8a9239a62b4056d50569ab4c05daabd94a7f6a8ff1efb2910eb78aba4169f7cfc4dff9c47b4155c298bcc53a21524b2d4bbad95196897406945f5848e8a744d948754aad22f78cee5f37f45c567868ff9064031d524629c1302e37c71b25a2ce3410be0e71dd777a37396f1696666bbc829fb14467aeaf71cb6c8a39b40fadae4abad7ad0430445047b6b2bcb16c05903413ba0dbfcfd085efc8736b99d5274b466e46f7c5e9d7c4e5ef23bad167cbd30f2f66500bcc7ca04dfd91814d25f65a55b7c775ee0136a52479828ecd8d9a137f3501e1fedf1932650a8b7a60d67fd4be5585f2f387b472b57d19d4a14ac0304cac2329943c06c084f87cc71d1872c52028d8428e95fde5e5bdb06d92050d7887e585a77787da4828e67d87291ffb1b4e00b11df34ae629b3c9a6cddb7044b64eb6ffccac1c82f1f6fe33574d7d7c52d1ad6e039d6f9a6d1cd34328f0a1197fd5855f814d364cd76a791568994c38edd4207c4a2d73ccf5a8ec19819fd3690de281f3279f80dd9214d3ba2381523b195585119ed9465a1f24097a49cd2bd1fcce54e8d08dcb018e6f3cae1369d9503f6957d49e19946e55016c64be90dc1039172675e9e4191b36dba592c956dccab4ababd901a54f36a25e316284cc6789de48526ce834ef28a64b77e0846f737cb2c7914458c55b9861439dcdc9decc5ccb00a5f98837b217b0a362f508e2dc6ee12e281ec7e344eb66b7454dda4228c7c40c39aa88952189da1a98719706507d08240b2c1cc6af8e881730da1c75336e303bef26273c37236e6db55de39401abb0a63b37b11b61972c03adc3acce7388d679beda1aa6ac5c700cbf3d6741de1101a021bd9c56d71e751c13389ca095551d7d6603720861e89301b43e09e0e3506d34c110f83665063a20b17a1968e6a6b8c8f2816d28298968d8646213ab4eb2502ff639e985aa48ce16deacff5cb55bd4c626ec67ce0df088b29a4270b6b1c4c3b52590b403cabe5eb4e707b9fe66b0fc881ac06be6df4c96df0ca6a12a6f3c179fd8df79ba248278a0a344cf8db36ab2abba679fdf4a7c444d332fec8c21685e24c524b654dbdcad5e45607c7995a308027edd749e219b1db130ea93c7f0882a7240079e47c5106beef4ca9707e4fe236e2be2628c902896c7c706e3925226c3549866d17f7affd780635e1deced3d492d69741e18bcb22fe0554baf8b385d7a3756dc057e83db34128753e20e01457cf29251bc62c3f621b0057bb4e82e5b5c14f1388e74fd4d08085800f83f9f6cb99b7abfd606117a7e6c660eb91b39ea0918acff2eb16d1330103782f8f1105ec20a1b0bbc6614070706141e93ec5339f52a0b9e1e89a511f8fa36e1d024688948862980eb4061954cdf8b6fac910f560942c494ceda2c99eb2ccde160961b8315f745872e1ca6364892b11130908a3425cb676499ff07f4a0ece75bad7cec4dbe2025e89ca64f71d50c5d94ef7ac336f28a990d199347cedb5cb50f5d3fb52b14c2de2285d7adefeef53fdd75629c6470e8051807fe5e7a8eecced44361354eca7f165ea31a17c4eb408383ef6ab90894e568010f525209c99c3561bdb81d6153c0c59cb8f269c0c87e671e8996346ca7d3fca3e1cb8532e0967bc6e467c375fcbe687266592039757f8aadc7b9cc60a319ba06276f6ea6050162573559711ec8730293b009d1ca9e3ea2f003ba37ec4a6f2a6ab411cdcdd03633257ab6510eacebb046b55b860fd2a958ebc57059e3a8c39cc432229ab1ea592629fd236de1c2ad08e393973896ce32f80a43fad25981b98c23ca0e39b803e9fcf56e3a7e2c331871e0aa4c34a365db2c7f1a93344eea50f7e7d4abe297d607105d029aaa9d6b457ca638c6615163f2aea2d9f1367740e661cb21fa52a11123e0e8e1cea840130e2346ce955881b987e15dadb70d39144506e92e62a24d5706481abb93e05b95a7614b14337c9b637418e9791c954d5e800843469a10fc955316ca107b153f3a742ad79c80ed3f47c0bb42fd7635bde1036ff06bb799274731750d6c0efdc94fe6a309fc07679a16d469e087d554b47b6fc351c34e1263d1f4042e411d6b9790150e1e96a57174dc96542ead0cd446bf696f5356c6b85e748c9b8beba9464f1deb2ae7cc6f0f3d186374b2e4941c12fb327e10df4247c011bfe8dc37d459064a93f36ed6fc6a4da712781dc3e44eaaa2974e0fd572632a1bc0e085c8070680fe0688065150eee72225be6e556058ce922768dd761d98da41c749e5abbb40e67e81c25487d2d6916076b764f3d75032c0c6af709616b3af14a7638a9a74ebcb2675341c539c2d7faac2aabf6faab2040aa4301971979c4943c57d67a586bd646433ab20c55dff8c911936b05ddfb9f4584a13d8ad9f00f34f63d070e0ade2a0642638f4dfa12a1b4db0a7ae3818b32ab91976216f67c907bf3d001dd992c5cf552f5e9fef4cc55e10cf8df2a3edd06d7c9fb0abc2147ec5acc4161e7b4c9b988ab9b933aa0eacc6b9d78e872ab68ad1038602adb8eb8d08cd4a63ade388ca8c90596e0a4b041a29434da7e7a49cc49a389ab8675146a8e512640f820121e784e2d818af2d0d3e5dfa30c438c5a265ec88063fd029fda26622ecba9e2224aef31ca0cf79abbb70adde8b52b9509edc4a1421c33bcd551f0e5c00a639abf10c6200b1eef579b16136a2927f513811230e778deb832ea44bf3b4d9d9fbe36d6355706bf45659974a940330c27aa6de2be5cce0d51d63c3b270a5e5bad767156ceb7f12e88c783b505c95d3f942c3fd59bbdb2079370249565a7614f04865ff62115f811f4fe9a50f8fdd7adbd16965f23c3f00e303c493f968a7eb6edd13a31879dac902509915fc11b9682a4d85c2dd6ac6be0b6984fa5670f18305288be96b3195caf35042327cfff289279e224277fadbfd70a3496579ac27cbd8214a883afac3ff183c0bacfb3649ea3989a7e6957945eb9ab6ffd9b62067e9db15b1b00985088bbf0b622be8be80a0b0c2521577b5e990448587423e5044ede503b8cc9c53d50bf202998c2710c637c069fb0249d6ceda25b45ea40530868d6d7dd3367d7b2666c03a674abd04b9f7e354de0f7770621a5d61a62ade1729435d430a28746982a57815c18f18e032fd4f88c68264f8a86ef34685fb21f134d8645d088114da392c90642ea458bd074b530976d048d1861558786c8bb24238ec4fe90bcab4e0c188760e8a03b9dd0143f633395d1e23f527c0dceebd6a6eb7514c00dc6ed32a8f8232714ee4aa04234f3ed637eee1bd49b939ed5f8c6b21c96b4ee5e573202560c95abb4db6892435d15fb048b6876ffe1cb876e190f6183b4db848784527298bf3b84b33a9b0bd06d78001ae345636b939001a32b1f1254440c3ebe1a4d94731c71e76ea3963c783ecc9518d4d56eff179d015bd5a27384f278acb01d2298a9f515c0eaddb5819a91903c78b08d409be039344894f29bba505795c585703cc456ac97b01ed1b867af334176488192dc57b3fbb4005ab90276e656e606ff93d7706cc3ef4f2f46b6fef1e3c7d8647fa18290a9edc4d7c4e9b45518a9997064e4961b5b39acafd3031afe8cc1ca8b06006858dc99e6d62b5f87cc1518edc5d0a6365ad096926537cf4020f3da151676c41a8a559748926e29c295cbc9e36fb85fa5304f35c331e1c905258058964be8be8db61e1e0faef3ac16cb4c208e7afe26ef260553924890f120d94fb1647867b8f8823018adb92356f7502e960465dc86dfab048a1cd5742adf33d0f36c0a1a5bd0615ea1212fe8c85b9764b6fde29fa7c04d242bcd38d0dadfb3cc961493163b2d0af2646e6205004d72cb16d5afdc06878a099c31cafcecf2d22261c7e2139ac2736863eb6dbd2dcf4b6fab5a2a2a0232e506e0eb6cd01b2f961dc5d1dbb4b6c8f7701393dcf7dbf0ebba939db52165f653cc302af9ed93145cdae87b51b1dde663ec8ef209e6081d1800416fc484763be4f153f76b2d61fd12bf7a072569a3a7b59b75570684d56405fb945dd7ddf0b0b37d6f9db12481126ae058b0477bdd3b85bea00df77092b4ffd009f9a7e3b3131e0363d4bccd08b4e66372eec2392e7a6c49e1963431ad27d0218cf826d74318cf0bd4f97535d49d974d6cbc0c84e6ac6e444f40d6fc66b43ce1154f418e916e6716ab389fb2cf8e8867edc5c431716e5125d503e8561c0b349f97db6813513844cbdb15baa3ac1bf7febfcf08176b2efd0da8ec3862ffb18650dcac81dc77febf857ffca2956b2dcc67ce228f8d3ef210cfbe8d69a0a56349b1da93afddad69b0a0c64d5966837ac48f9560ffd88e7eff7103409ff9a658f7632ba297445053476373c2531015d60e6fe76b079263a901f8244bc9b3a5b19d6b30be726fe49a6f5e1216e68c4f23859e44e2c5913eca48f5234c3d205b7035a3a25b4a38f206e291e85785765df128c5c1dbb117d396abe9f1fa5549a4bed212ef581b69adfa9bdb823778e514fbd18dafa08e85d970b63e429db399dbfaeb4c2624df1ca2fd6c3017d03ebd4a33d04afb3dc4afe3a85df54a4da3198989bb15128dfcd5ec7288bded1d2370a21020c3660510b41cdbc38c13f7b35d051e2587605d1c5e623e1325d433dc05f6d6ba38715eb2545794138e214eab0ea0f994730c74c474a321d29d9c275477d1d7f18c807ecbe23c2d8b8abeaaf9080ced2de6ae78cbbc41dfcc6248a582882912737d03cf32f10f100f5544e60c5ee3b4ce023de2e4dc589a9e2ecc3fe962167a1d7a1228366bfa21bb82583c93659c91ccbd3d0f02bb4533e0bb7adbaedb96665d877dd32e5666338683a470cb998afa7dea2d36c0a40550b81ab406e0b8b3d0fe868d1408ddfed6d29c3c0ecf6f4f8a1f37b8a1d836cbc45c1e6928d18f81644594a4929c0f485a3e80d759273b2f57fefbf036582d3885c604836aea02bfb11ec260f7e598002ecb1a542ef10b416c4e1e311e247cb5c69c70358753df68dec025c31c179ec1c381eb668e21608aac6f5d4442c98d05b08c940b4ef93b4606c8b85fe1343ff54b7f7dc02506257aee908392d79e27a505a7111dc1e96fa6c2b71681d8088dfddfd70f4261557051a22eb83dbc39aa7491aa972423b84b8c3564f756a53e21cfd48c0cee60ddbd73648f4613316a323ae6661b874f302ef204a5b8040b354217c03cd4fd06414a2cd179f122402b571bae74fdeb3f70ec80089c587f947c84cdff7b8e506771237347f412499493e7bd358a3a28c30f4f651a2b45308be998df1437700f4c2ea9bc24f7cf9855948d08b819b9b7ddecd3e7b6392d8f5faba666f352518eb6aa676495915a4f70d967349f1aaaa07e60e625c092a412bbd224650530563cffe9b21a5f1216600693b78bd5b902ebc3549320b913ee41cc6c544e49bfbdd816238ee438301de687afe11f7c7d653f5906196ae7a8649192c3868d00a40219fbf12254f0608ce053b3d01c0b847f5c431d28932a659bd0acee15abe1926e5f50350ea849d22aedd8eed0d2fa08543b486b4df10de53f85752751c91145c4bacadcf69becbb406b8587180e0b61f30802210aa020a15d808cd6cf2ee804a7c38d08f547fda451b2524462c283d0c7979aae594573416c4c44410c0a813bbd9880fb408c70b5c4cb12b5d531fec1061dc62d39f8ee63b666e248e4051e5e36b89de06f93ad9fa8d5b163e12eed57c568dcc8efb820120ab8bbd3fad1a3bd62bb94d23e1c8c177009a031e44c0e87455933174b20975810f90420cfaa2cea3dc06fc6b3584d1160fcccdaed432430deb496c5a58bd590f7097e60fab7a9110351e03cf0c9aced22d47b2e5f6626db1f5352db97545e6a246ba7556bcbd8daf791af83709d7d1bec14423179bcaba142ca1787f11226c6d8601bba31648ace3ff3df7e56631db123a36a4bcb6d73e612ce2c9605e27f450304165ab778f8e5646edf493bfc9fc290d74cc2b3bb532d14e1b21579b984283c36845c385ed64ae0429bdcca4e90ff221416bc07e62d4278f03d23028a9b4c4ac8a939c953ffcf11783f8f5f8d6748328f043e990cf6bdcf3748f6f7fb1b7368efbd414590d9c75b0861feb6f57eb9c283b02a1166b26cd31fe09b77787379ddffe9162b7333f011eb870cb80178fb45baebd2c81c6c5879f29cbd14eaff0e218f5062c64843aa645e6e3ec52bb7b7438666a9aaec78b2e78d32d7c586dbddbdcd5e2efed48b5ce6a84f6612817ea202abd4ea11bec3ed2e8eea22f3381bd6dd2b2e674ae97ef03b540328ec29fd551f53b2ae7e1a382c77ba23e94bd16c21d5987f4511630ed6e3aa90c4f4c38ac3424bbdca4d69067fe5ffb6324de72d40090da10c5b563dfdad203db3a5ede46d929093545608b80e6a5ebb6274276dd5da32b79a69c7349572c7af0f3b44f8ed3de2da740aa810c08eacd387c2c5fd707b83eb8a69dc4e41a3a462112930edfbdf04a1dc5bfd663c148b9b954a30ed1b455b298a2968de01f5704630a42ba9b413796df04305ae8dea2cf671c44d9ac28683ad6e29a22abd5bf74ef9d6eed604da8e3fa5d26207ce3afae7ec09eb78ebc8ad82a8ae27bb9f1c8e957892e54732a64453696fb3a58ea8586a16a18441179cee30511326f66a44337c52e690e034eac19d9059f07a9c63e2b20de734c67390161757b7a34608f52635e5933dd5f5ac5828839ccad28d9c0daa1a7a7743b94cdea2cbc1088ac16f8193c65686b6b053e7b3711ae4578506ff32604db975021145f737a1f9ffbf821d83f23490a39f5f85fb0cf44c88d2ea0b76bfa9312a6b95e85ce1696f3323b94925c4c22695b3c3263dfe62ebdbf9c0631ebdf3df4698db04b7a52073fe0f1c539d804dff59d13c21ee5ac4dfd92de919d04c9bb37173972f8d457600bd9e16dd3dda99ddf36b92f28c7f37d8e0475353b65b13ec16e56a0c811c56214b0c44803c35635dc9c00fb71d5e0631c21466c5419f5794311e83756a505acec4875178826e2ee6886dd2f84ef8bf5986dbcc455aebf258635188a90c44f87e195aa3b882e082ce4b1786cf925e163cc7cee7bbca74e453e6278ce128875ccdae625f803f346c4589bd0b1296842f316582d18474634aaf2e4ac23885eff71116530e69419627a646c14f2812f91998b1fa1a2d368edf1bdb786fef77a1c5585f959ec63341c503923ddd302bd4cec795be484473cdaf1774c0d51c8565b8e40e681c19e783bc10a609324a508534d09f32588db9699e685c6805792a6ffe30cc2a94149b497612168591604f5fd03f8fe5f33bf66554b7e09fb02b64ffe79f82ebee99e192bc39151b392fafde7afcc914819e3d0d10c54448626ad866f946337b1f8fc03b9e7cdc13472fdd82b40f60f8cd922a636491d5bfbe37ba028362da51542c4b4cc0315c352fb9dfa2d7699372f354bd28079729897ccc4151f39ab1aed628c66294194abb100261410c0d3f37c136d3c6d3c3a4ac2bd47ed163c071a84d06f7617b8cc075b10c6d993a2cdf7e1199f7b892e7085ac133b1cee2eb5191cbb0ef86aa3e3d38eb1803c26c7be79414754fb76a02c09628fc0ae5ba913093415819b57ae803441e6a37b4a8d9d1d202aa2a0b2b48522cc340414163fe37faadcae41dbc310a3872d1faaeeef7c29fc4ea5a1abadaef192e3e56499488086ed48ac9c02d45a37d09b743e5ec62d45fd8c7af60726bc3c6e70fd74d43c007a93164cfda34e1d8fe2c0202a7c261058f6ea3c57955f08fa68dfd862b0217d99ee8b549193524dab2000070bfc40cd2e50b5b4822280d5addff7b629714c3c9c5c1b32efd8576e605265f1e042068fccd1fb1437ac2325d39bf44ca885ac3b9208b8626437a4871ba64330178930b049e3b43540032a19e64e69a4c898aca52599d86822e79012f8c25821cfcdf9468b8dbf992382039e2849800b936124d12aedeb341cd1744d9c3df5031984af79c7a9ed21533a15a56b826882564dabc7cfaa9332be6cc3b18ad12996172dd88db655593b26cbd272216ce8d8b2c57142f81cef005820e3d93b46c4bbb986cb1d40610ef97dfd1e795260996b6a82d387132b18ab8946b578630aa2e917c334afcb6a83c03e15c9f0153c9d67ac829b5567c621d3a85aa1c0aa479a4d30522583a51cfb2cfc6be4988dc27c6a225538f5e5e398eac8184907601acd212c023fa9860948cb3477c75cfcc55a1d78493bd86fd711330ceda9ca05c5ed634ae29a174fc1fd747070dbc46b19637938d4410bd46f9c6df661c584b366ea0de26d7c6a23d1b98795005c704c3d8ec5eb5438e4730b716bf9b854b445a17932e2e84c2e5feb1e13643ca2e393779c546a63f788f99b135da9718425e537d60ec11d43d49a58ef0a9ede9edd9fa060c30dc767f27eab44fc464db58537d6753175afe1ef401f2aefa82f19472ed447b83f2dd324bc711986d92505710b245b257992d5b9002f26d7a6d528ffa09b8ccae6ce0aedd0fd59f0738ec0035298b722fa607195b7a1f8e1d335a880ef135106e0822a69164a5fbd09b2127dd8e6ce53df77c603d1320c6e0c6fab67435ddc75a095eafa8746007571e52e026a853f3eb6b9f32abbeec88fb5b13ea817fec0753754a4dcb223ffb89567c18b934b551b11ec43035105fabc59e2776f09af137139d92c3916a0ed6fff29cdf7a1ca89fdaec5e3e5d2f3a2ba08755c1e0862e58a31d058cdcb44a658db8f967a575427af2dfddc867f2553acf49eef4c8ff699b0a58d11e775caf42331c461a1b82ba4b21d269b25513acb3cb52407939f89098f1e59e6f5eb0c2d39491a1e1ace9617f4177bc47464e9d4e42827e7a754db86888a057a2588a3bb34f0b0003797be0cc5716eafa1933f415c050ef8b8ee634e8b9f2dd44109e3bbb715cb97c2c8008a5553a45a7cb53a702c19bfaf09480e2796f0610b8dc49e84224ff4eb46e98b4701865f721997498314cb2699507c27ca279561adfc883c68a3f83c4fbdb8cbd52c96f34471a435193bb3226ded18dff0c4ed478ab4f85c810c18f5231dc0b46d5b245ea0b8e87b762fcf25a83e0b44538a3b4fae8d0bb080cff3d483258ea3c947b97ed3a197a056b20d11c514e5869b9800fe0a84302083377b7b846741c1297f8c113d5e7c819f1133a8d8f08f5b6622f4755222801362805f85c7fc524be22ab0fb20196fadcdec8712055928132c0f256571171ed05777d2f3267e926d2b0cb3b0426aa9211aea43d907e193f84de50047dbeeeb375b4cadc171c902ad8bf1a60d3db141b7b43928d6221be36feef650ca953772dd9e72aa24b0e06ff5011f6ba6beabef8476ea7d06eac1a44820cac36d1854765ab05cbae0b237fdaa78403ef83cf6bc7198b42a0426861c27bf7189074647d4edf335e183c27f77970e11c7100596651bc3523fbf4af47518fa0c666dcb4ea2a8dfde4147364e052eed34677504a817750242a5f6baa6d5c18b235c0da108dbb86b3d374a17e57386c67e03bfc5ac0181dccd3666e5517b52e7f3d1cf49d646e9beaa3d1b6ff37a4c695a7daee6164264e9376448a8e843fdf21deae85f3911d87975d03e2935ab7cec13c97e60f6823a33d0639dec860234e79b7fde4cdf14bbea1245c9da19f5c5444d1dbf1157afb4e36b4b8bff1b6b55655a18a9e91b4dcede1a50560394e7bb37f2fd39b192cc945e0dec41e127b04831f1689fe560cae93e1fc834a950b01445b604314952d529505967996f1065eec23b483aaab926147c3b3ad71fc2972a7b737f8f0dede3822259f9f8f4f2d0cbebed005ea0ca7b49e926b39756572d4c9ede409135871540a2e52eaeab6d5cb450efe28ccb01612329a609b71cc64db1a14964bdb617cf74c8c8270d96b76964da643f92c1037d39d185922f186b2ddfe0ef426bfa5acf05f50a2c464607c72e78c25e9eb23449d6e7b71507da8020aa8372488f8ebb19b34d9714c8e56a65cd4222003bb4ea0ecaf72dbfd0a5814f36ab7cd115bf4796b5ba8dd2b2e9090ffb3d5a83e0a06d15485d203d844d298ebfef9ffaba82ade2c2a9a3912235d362fef300f5194550b1880a800e347bfc6798189dcc9efc343d7034c162ea4834955093079681462f16bc8dfd1f4b5974d99154899b26a44d18fcab93bd39a29453939aed30ece44f9d93ba3194fdf7c57fdb2b648cbb3c08b664ce3c2d31adf0ada2cb675171ddcc8fbb22d1712b12379b4e88869b35f5f3b5955088b6a2d8836cae65df5d5f22a777ab075bf3d00d8eee17c1fede1dc0606dfaba12d9687f60d3aabbb06033a49f67a46ba28b0719de1e4a557843dd4bb68385b29eee676eb659d6f3afe4d296efac99f7455ba18a35ca0830b1fa776ba6a2050af001bfedc28675de8b8f55085335fbf76bfe58f42ca265ca52da90cee70614f0c65a4813bb010f5afc84f582282c5d29a7bc4763dad5430eb2adc5df5eef3bbe1487055ea2a84a29baf3da58487e16ff4a1aee1eda6dd54cb06a6323f5ef1bc715aa61e3061a69a9f3a434a970522798ba2852153a43553a6a93a00b686de7bf6ef0d679793b0d6b271498cbbf267b2ea0bfe021e392a59589017ab2abdd4672a9752b6971bfdb41115808cd0dff3d5fb518c42508d51312aeb7d0a893ada509c06a13e5733bc0fc8d7a16c5aeee6186c9a8cfc2a5d529ac750204d01ee3ef6ffac32175161419d4573afdfc5cda4fb97f9645dc8f7175d3469cc887ac83aa07250685403d697b57a46ea3770078f3e59d03f20f6ae0ec31a0cbccbde985f80dd5768a6ad34ce4c99bd182cbe356be6958a20e1adc74af2b3a09a588647de88cf456de265816f34ca1e99e15cdc4a9df0dbbf0e828ee86957290f06cfb87bad514bdbde14cb66be592fcfaa7653e2beae2f71a646899cfaba61ab2efe080c730791ea7406c85f2242f4a4036dc26ec61902c3853ed7fdec39c316b6cdba99e7b3e3567e7644d5701ff4c83600026a4ffced2c41769a47ad3c183c6ef94d62759b3ff24bc33f48d8fc37541e5349db0fb5186d0fd07b37e97dbecab6577c2479bb9b3e101106291b403e53dd66a0a70fe689f46cad538f955f1bb843e3aa400bd858fb1d62121f866b4adc98f7e0db613dfbea2acf5793757a738029713730df34f0b7802f2fdbeea5febb9e58552959c397d1b95f74be0cedfa16a2763d55cf04a0725cbdcb31941d59ec542fb85fa41044b08281179ee18885dcf5a2bd5d66c795bc7efe200876c42ee6ba7e8e1637627897eb33d1f7ecbb4617c891f156d1f962cc05d9e23bc3104a599429c24f8db9ca4a29b23b5b20e222d69372581b75c1f8a051d40af50e87dff56ed369d36b931e8f1b2feab66eede3c843d1db109899136f31ab04a7cb1846f9e8f192cf61b0e6eb1f571a713bbce0769c4e779b2989ef3ae5e2bf1d72cb0bfcf5d654a80309927d5e1ce04692088b04a13964dfc93997230c3cbdfba1546ca533bbe5cd0f32665aae5bcc271ebc2ceafa69641d7c114322252343fba31ccd1b6b177638d32aae5dbf9d09a9f2b313b600514b088a324c57df15ae239b06ef0f27c67777a92eb8825c947ffefdd3343bb6e77198fe8537cf675ad314093e547d934675e5916ec8b62c2313c504ca4475b32fb26bfbfd9de2049944583d4035abbaebe8aeda692e340f0efdef4005cd2c3410e44968d58829a37db05e5ef530c2d8fbc44308f05818bb9a52780072ec47e36aea5a67676fe11fe03a788fe04f1a712cba659b6205589dec5f707073fae33927c60e102c3a9cf4e57e017a622cc5aab79274e23f6e54cc863d5480b8ed9dcc73f4436976cb8bf65c05979441d6163bd046253951d457f842531c75610a3f5b5fe83540c835b7da269f18c957e90d5f66b6e85e0dcb6a126acb214504a92edee48cd88cfc6d9c702b3bf5eae8e0e2302541baf9afeb5197f6af7fd3e0f807202b1c3808980066288676a791535aa6a442037332f87b99adb2b3c36188d4c83c4f3fd136c67b1eb450c378e1381f90258b904762d0e79e7b7311e46ebba69534d25b7a528f161c7a3bf5e92946882861931f5a8a200f02f9c25edecdaf6f111289c709cb618469502c9ab724aba3f9471ce1db9e83f08405fb400872c9abbc9026dcc5231bd67b2cf4dae50ad32947f0d4982249f9bff6137caa98123bd2bfda6e402749f39ef8c3f4feef6b2a5fae4e19122e232c8264af19655984788253176d270d112e0843f18af4947962af4ee6ffdb6e1dffefc9c8343e8961ce0ae531ebed61503bfbfccc711f0232733ecf690a6030c820c92ae9ec4ed0698b2261e0080af730bdb698765b2d782b79cf79400b10afc2c56204511279d56ca309e33baa76dab3d069d95715041a691ffe6439631842a72d7a0440b781be3623cc088a388e13fc16dd3d2095e8c80ac5495c613f3a775f6f0713f6ad80fe7b418c73fbbffe7df0bbb5c6db5a1fdae11cf14ee782f41e99bd503edfee84acd79de0f4cd1b9452bf32f15888b0698f265be014b118977c8a2ba8de5c56158232ce40ace72488a0573f2b44d5828b79ec146988928ed77062ac2eb128da953b58fb5abf1f432cf6ba0f54eb99f8c89aaa2d9716a9fa07e0727fe8b9a27dadd808aecd43396bde5a300b48c339ca9a67b346369d4521f825494cbc404c725c36e4c72e738f8f7d0c33e125528bb7cd90b9f8cd344e7f9b1082cc32a3aada2453dfe4770b11d9373b61af1dd89d36a49342abfc96007541966891bee44d60a8b9816db1e9a0ffc5897aa3779d0f817cf10f2094207cd1ce82b62ef5f04773bb6c0ab19ed67e116a5547d6f99fe979583b32b6f00ed1b1c2176748cc8b680c0437bc862dc03a0b61589ea62657cd58bfe8be561fe4187aeb4c1407f0db4c65ae091a3070d7fd45737f00d8ff9b4559d060a1ad5da82a66e6985692acdc8017081cc17984f405d162697c138abff604a86f3038a52ed6219a7dd609b803f61f6d4532b30a08ad59b4559208b3e9cce9fb98da0ac7416476fef38739b5ec2cbb7193f8bb13f0038eb60a8d735330fa17d0976cc3d2ef77434b37ec87ccfea2963491a3c92a5cb511d7493ce45a7e930f55ad13863e06bb903d625df1917ab4d7d8c4fe8cc6789caad3e01eee51f9d2e6d1432da088c2f6e57f7de97b81da72375820ae570d796febeeec76a04f4d88d89ade730dadacc5d16389cbd549ff35a0f403ddef83bc476aeb37bf73efa4613c8a3491078ad55ca5352289ba3fa34d7e2136cecd5bcf10c86fad6979d72f39ea8b9f2f9c8f245e0002f11f3b8c1864c3cc9c455357882f57f561e775154cf03ea5aab1e50d8c10ae26dd60dc3bd1745c3219e331f12e6f5214","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
