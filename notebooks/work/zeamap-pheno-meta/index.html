<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d4e8f9861d14a3f70e7a8e5501fcb076f6ddc7a68d8684e478fc491014e529965703079b955699bd2ba2a1c96f37f3b5381816458ef2ca103d94b0cddfecd82961a67f6aa9015433c482951c9aa733deffda424ffa0eb3dc282f3c2e4fc425874bbd8cb2055ca0ad8bd4d81c43fa1cead841eade57bf284ff843ef0823faad7cce85937bd3fe1aeba5ab1c6d2ceddea7cf6871930aea28dec7c4c99e3d29d5e5a8e16539c08e929ed55b362b325b87f879c34436831ab08c894c4623d766a73ddca6fa087fd21f65ee7236b4fb9dde2a5f4df9d4ca3582f50b46b5cee14b86dbd99bb2991a96310666a578f373e5777f5a6207fa2ca2dec460497f7ca0e0f206bf6339b6d24e3be5a36f3196468fdd090b68ba53f70dd2d60c005c7c400a00cbc0abeabcfa57fede7e8bba96421d0b0bfbcd0fe29029ecc216ecca37ad2fb6a7763ebcdbfcf9068e2103a6ddad3bc3e0fae97fddcba9587b27b8829f9d8006cd9bc09f8c06db9ea98520092aff7049b729322a283d922aa7e4ec6d025e4b282d8764c30cf5ce6c693deae66067c4b8380aaf6303f760912d7e7a752ee67fd38376f590b35fe864f7c0b53e0bc7af0d2be7d7b00320f23d465fcea539743acd322d321cb7e7da059cb3ea714fa0e73aec07799b08448a5bd8e18fbcb2cc071dc5f95dc69b9f0738ad50b07a2ae3253def037a3b55cbad1085ae7c80ae8dd494adbd83991c73d96198d5cc1fc1d3d39cd7576cfe5c2305c6ed3c9d08c6eb72b7e5ea4528c7877ceb503eabc9e0f75a8cc234f8e3fbef82fa37b021b69732fa44aad8822e886d5c569b0c1ba27aca9921ad3ff4faaf04bbeecce694513059851bb7d91e0aa57e367aab862a739d551862c2d8a0578f07b998f6d04088027b77a5ebe3db3c431ba17052d90ba24552028f0e6ab587496e49fe52e37cc1b7a96bf29b0a1a30fdc0d6642c7e3016fb356ee7b209c4eb5efcb31ffc960659965334be941e2309317348bbb7b5186c882413bfc3569242a49f392fdffe4f657399bf5d06a012f00ada4d55cb00bf2595f01b742b33616f2dd43a8964b3819cec54886107a4537bac8ae5aa35af962eb59ee81771063ce00859e0b3e75cd75ba06bc6e0746bc50ee0a575362807047ff3df1b0def118b367808fdee53e446925257cf3733cb5da483b042f602d7cbd069247632fa39389179c67d9a159fe5fed3c50fd26f89c0f1e6dc55d8435c4042cb50c476b02f848cfcba547fadee52a992a120347da103ffc53c8fc5a5ba2b6f4442441b7c7282f96473be17c5d7159933b30d85564f37104ae62c0f3b65aeace28c50ad2286d0361654171c085d6e28d02e6dc28d62e9fdc96381f54e9e0ed9958b6df09d732b0c6e0d3492c9fb870ec04c719dad5754ea3b1dbcb59ed1a5e04824f737ac6eeb11503ab220d8f2b4631921ea6e30b9a549d3d42b104896f0c641e1a5971676888f08d4757a63e5b9de45e2c992a38e45a204f605fd2a45c0b690d2d1c69b5dc8f865cb3764b1027d1635b30de633619e648a4ea1bdef85885b8fd38ceaf22a1a29b95534b630a777486c4b0e6ff9d8544a4d245415f70b12e4804608db497bf39d8bf15c599bad25ddfb5042fdb2177a6b4e7ff2aa380bffe812787b445c98b647fa6f02786642d61cd7891e2f98170d149f1b1273f2b132fbd12f55575e045f8ef42fa1ee47ef0428246c796976f1bfc4ce6fbc02e2015b3e3879777b3d7bed57c5c5f61e12ec958257fe6ca4aebac0736cc73a7b1d846fc434fd9b2fffa450f67c0507bb3594b5fe80107ab09df56ece84e282a80e1c5f5388d85afcdc3ba3de2e7e258b274af3b977a09fe27c347740191f21b02d89beadd3076c94cb5f992b03cf9079a8b373326d05b6f88903f9890229f478c6a2d7e25df3a847253cf96014407937b3ff01560a95bd2e97f37684c870e542b6ad63c66894c82c96a75dd2f1d6a1f9ec8300091ccae7b67eb3c868ba940555338db189685f60f8a45e0207d8737e1f85ae83e4261d48b4a0c0726cd83d5b433496c6594d1f3e9e361ca4c172d12254c8f31d7c45fe85e4998fbb219ad8e447615991d19b04f9dbebebb1e55566afefe60eec0cfcc26a5d94bab04f22e3f049898d260d4b9ea63c605bffc647389f0449293dd147c838788cc6d8f640aee783c3c5952bb63530cfbbaa13aa0bfd0420cba701a00c09d6641e48e1b30a5f93a4d2b8a43b556f777543e7289f7a5276226c341e5e5232feccfbe66a56e22b9fbf27ff6ccb2783d3193c27cb2a4b69addb5e4ec9e666f5c06a3646eec86094acf48db9f5e0775b33f2bc1037097260713f7d35dbcdad883ac6f9fd2befe0f678b920ba9b3c3db064e1c4e2a9ce341e685edb5f2a23382be41a6657a2472c31e1b767462f37da9436bd1edb8f778b56713f7d897b214f0cd13b3679974cd74b7abcada180e2bbb2fab68708fab1d56dc053bab095ae7bcee02386afdca06b5131015cb60ee4b86261b7ba0c3be0961af177f6a39192028356f5e795f6d440c1f71967c3313b5ea0aa4237e68ba6ab0a44b0b7bdf8a70b5f8834823ae77429c8ab37b9ade8d5966f830a4d6afba3ee82fecefaa2349283c215e791f6fcde25ee3eadfe19c320af7c1e6b0070591084ba043f18e8a2d4ffd79f13869c317a32f73ace2d96daf7a682aaba56694b8035d81d25f8d0f937f44543a64e0dfd0552c6bd38ad75b5eeccb74c4df8c227830f6fea15f9aa38d7eb5c76d159504a7de63734d3496b6c1a7572a1e6a3bb92fcfd163456d47a12f8ca1f56896b7d51469e393353cff26f65f39baa6a0b4551ebd4f4a3581ac1a571360401d3a7c350842f483ce483fec8769fa71f60c9edc72485e02734adf23920aaadacf994a0844f9339f6d4b89f0ab34de8e516eda7e3b986699be7e7fafad622f6e76bd2fe7b45d37c1c0b73a880d83e461db5a19e4c807f60aa77fe43868d59e946e5daa8547a5619525878a12ec8a479549e6e5f395b1a6b8d7ad9cf9b79a0fe7e70d01cb4caa75bf9686fa93b0dd7fb0ff4193dbf40455d725325ac9cb037341e9e0fe18eb09e32b0e0e28eb42373984a52ce4bfcf31ca822a5a389c66bb9f123de64f8fee90f210f742ce9defe15f168beb7d921554ec25605f7467d9517750cf249ae8fcb19cc895e0c4eadbd5878cb31cc62172c92ed940e137200a8ee962490234af7fac7fab80f291b873fcf7eba6fad083de3e662a6b9e57c18f3f51c7e2b19b46265b72322f023b931909fb362181f6174db2299c5e9632bfaf8ebc1faf2a2ffd15ff872135eb85951142f377098de821cf04b25ddeab33325c0fa23352165b365c3b8b98d833d2da1b7f3d2a0aa0e5069b7917ba1fd401e6fd9d138601a705c5077cb891580891125f3d2bc8373ec6ff78bae590765b7ee50c988faf6d60de79e07d494f3ce06a461a69f8ccf6909f7970a6e76d17e4e54e4de161356461fe1176a3ae1e1e28850d8a417cf537287a5eef453acf9db18ec7296166d44220afbcbfe6a4ad3ff774e4b9144818fbde0454ea34fd3c2ae2be46c9236d4c32cc9b6639d34934f2d846fdebb64fc6683c3ab517a16051ec6ae0e278d3b110916d823d29189682da1205e1647e2df262e015dc38b99effc6a59c1e646a9bdd7b02057311dac6aeb069647de7174d84618eae8772d527755ae071a40450426f4f725134753da50098d416e8f9a4f876411ebd46e64b5e96557b2d9ba7f225865f18c14c820f33d5ee64de92a1bcbec031022308b6b2434d7f27d041c4fe7970b7676d4a5d58c7a1f286fae2ddb51b4d13b4e7004a156d42ce5569ca18a310f97f5a7790f1ae9d99fd9cbbc6695062fabc8d6a71291a4ff745c214dc240e8710481fd1a7b69d5d239a3fa1b9c898bd869b8404cabc9a0d0a8b1c75538874d0ed0675d055e377a8e9c57f67318e4456ebe15b621dbcd17b4821aa22d2f71d06ea02133d085c3f00583b498fa32fc5c9511c1a2961e16aff64f469a85097455ed00f3008daf6f6b6e287f247cdcefaddb979c51e486f5ccb7a3a8c2c60c783a698e6510c9dae7dcf655d0370886e21460aee9d0674a2112cb9608985952f9a469915d51f41c38c92897ace79e24c733296fa269f81e761298bda5ad3d893fe4c24f8fde34fc6dc96cec690c98e2bc3e79c88015b3d777a88400764496d8cb413c1c6118d60d59177309fd62d1bcb9fd38238adec40a08b71724de05c6b697de3aadbc4709ab4a4de07968a43b903e9a261cd1ef74d2d12a6382bdb22a7e386d2f3466233bee91fef09c70ac774ec8661c4cc62614c45ab8441db0ce1cf249643b7f8fdd805e15811ac79b8684ff0d494852a7586e0f8915b0a75055d418c448734e20138cb6b40b8a63da027f7964c1d0a41e31c5d51e81b6a82971b97b48a695a525a370a57873f55bdc68cb6f69a4ed8776b2c04bac266b5a151f848cb322d1f3b7bc9ceaf31ed45fba3b50cac919d7da9286c2134b416a893b9f2a404d6998eff5feed728bc848f6ed9e1e1054278a4c952b82ff1340740c6c56f8ff717ab82491eac94cc279e5e672ef5828b3057737fbed952430d3a5affe4e4945eb1bfe7853221ae8ea8d85f4c04676bf60046208bd3dbe89dc4f1e3dde211467088e65c2d0d68162e75d50fddd09bad5d2943846951b45159f9dbf16166311e097f12dad4e5c0be7ae46317257c6ad47c8747ebf61a8df8789f84b7ab6ea9206622c6a8107166373ca2cbaae58675cba054d7bce22b5aa31270b9d116dc1e70b5209ecb9a03a9786f2c3dd89c70bb25a4789e712f8e7500f63611718240490a687a6f4e2c90e0688b9fbaf3eb1839df86a97f2312a9f520e1aa6d3e43c1d286449bfa84cbcd0d392c07297fe5677327102d8f1fcd761b65173a764ba4b594597fe1ffef323e6188af68404bde9047b4a77a46976d5b22a320120ceb67e2c7db3c99c50522c7712c578f433ff5390520786f0def494a73662d0c7f010ad2ad4dafbcd0b669f7d71c1d2eff0eb0d89e304d0291a59d1877ded5ad8c29adbea9bb0edf4742ad2324424defa5818a584350c3135ee73f0997c9765a27278cde82d99ef309c522b52ac3120e554dd71d62edb875ecac126d34d9102f74d6a14f0549f565ab6b42ff29cbd12143f339e7522021c9d828894e2b9c1ca8235a0817a346d76a2ad9b28aec030f7011322c630ce85a952c369272a944931734fb4313c3686414f53ed2c268a37e58fa69119e6577a20815a1e28ccb15c660da752e2a1e087c760142882f9a9ca44163caa8285d72d0e98a078ce2cdd066d014e689568e8af7e7b8c7a037db5f193cd2b399c61cb77b533ab916d132f60b562bfbf7d28c440001ab0503c449c74d40c6bf363e87bee04968eb55531c47a21adf3b3e0d1dccdb181dae6c6e45a7fe8962a611a66c052a693609e318f25053c6f63175c0bfb204f81e9125e47d48a25cd98b747557e4d5c391bd000a29dad3b6e270835c6a6a50572e21574bda6131788956bb84485ed758bde9afabfc9dc7ede520fe2655aa6a67e881aaaf76a0f4f246ffc41000b831082f498ac94fe075121e0ad51a90c0607abe30205462ee1c674ce691e4ff5dbfef4d55843965f874d40c1df2871ede83edab5d7a7ef690bb1e7d3d1f5b643d55d0e90a93e692e8ba31f5d4649cef911c92da4342112f6e6857e1845a208cd58b7ba6fa60e1738d45282fff2c3bed5368d19ca7644f9e923af8fc14aefd55cc2283c60a4c29a287367a612e9a319e132f42777db0aac89068a9eb187c2ba5652095fb4374b26200d5c1f01d80b4bc98e7b1783557be48d2f432997cc3eab560765261d4f0e6ed41974566fbb534ee9590adb7e9172d2d2a05776ce7e44b623d5354f53e59a15d99caee52d3edcd55831c98b1c8969db227d1b7acc5791471fc9011667f894fe6bcf5370329fcce6d737d4f9e8f2f9ba9f547d0d303439bb50cea20d2d2f2d8519cda799a0de2127f7f70195472ab092e355e1bcf0daf4ff2e095c957f1c606114a4d37d99423ed7fd2db47234a9c39c4f2ab62d9dc60e48774a607d999ee106aaf6450e8c8fd1e88a1d9697a0f7e0e978235bf0aa45c2bd7556933548303b2465bba59f143c15238a789d97125116583bcfb0b1549a4f65b72680e9338489afcb5bc549f10455df7d7e7523b93ca14b14249cf19ced8c8de1c24908a0401e182d382b5e9153e37303913b8477709b12e9b39449a418045df4fb20542a3ce1f0bb984a84e0b2fe5949729c010ccf0cfb9cfc88f199ce6c1c263366de8d14d7f2d2e87fb41cbec35a9d856f5b2cc477641794e492fb65cb361912a1fc59eb2d4f6332383142d820d641522ebcbca21f88bc466f564ec4df8bb97042ffc0c9a94504066f41097bb36570419ddd6cd5b926f5e019103585e98407371f65e4b9f7e169bfeb09a25a379e514090611ff4b6c26d19499f4f4eeb09d7ff87bbc7b02b846e014a390e9d66c0e6ddd24bfd6b9bfbdedf19490867f14ada62251c9b7c0591c60b056f564c8b5d39ccae0938753774db631f6f2061c306f8342007911090e16ad955528264d325f7d2999d0a35738176764942176c5d604dc01462203d274ddaf99a8739debde7ec1e98a739e83a3459d16e66b17d0818edf840bcdc451093a371a02c155d3ed91c56567ed93e1c66735c8001712479677cbc386fddaaa05e1b5a74036e9888077f632a8b110c749186a9261d6c1e4b206a74eff7ca4aa08f9183f33eb3f4f21229a02c92e3610e76365d4fb4455a734bc8f6536ce83386704f3821680d57ec641c245b15832317d57e4daf9be85775fd4b3cae74c28e1ef77668fae0aad408673c7ab3d103ccb9f2566c9bd6e8c7271cce19f4865949519c42147572a0d1e9c544c6c9ba216fbbcf52fadb64a6d9f1b4603cbce2d5114e3f9fd7c26dfe177674d2ca47dc2db56129343445bfb95ef4e6e95dec385eefdc17b541217c07486c47ca8098579550b0698d4eac7fe5f432eb2471ae2a4ad7ce0e93e25d8b56efc960db27edbdffe5f8b57c20d732785e75b5cdf488148e094b1a2bd19e8b5ca2e7e003f240a76d87b1377d024e77576dc3b671b959cde1043f225fa13aa61f771938a150a5ca9bfdea320e106c7b37a5d8c313f72ba81493021180c1da80ae8ef3e2731fb31be3a887be2c5a96e1feb5586377f621baa7d3e5ed2bf163d5b7a8d474f617261d8d09ebedbd06da64a544cc4605f450e4f6865034bac1293a7d0dde5327bb308873c449baafad94f8df3333bc580c6fcc3dc7fabf74af99ed9037d15d14bc0f23cc192f30860d4089c50ac6287471fdb95115635fb46153143f134d6b53c43a0edb1fa96d563d8b869e8936de3f831555adf3fc5a095e56b1761a5ec276864122bba6ea407cff690a484e95f3b6f89f45efbf22e05336ea783c4e231671bef28633fb80198a7c673b74f9681d3ade2974ec9d0f5db7b533a27e7d9743a090a6e83d97f2df0c9515c2cea98bd08331fb8e588049b078f9d2d07e0b44ece0f7618c21fcbbb33328a9b32081a03ea3f7214a84342ce8556a04f1d00cec6507672ec0356f269c7ca566c6427ffaa268157eecac2cd45b318f037c7534704110515457c59d2081db197e3992df80ee5d96199c91664a6a8c25b69c1c88d6a1730bf647d6c5feaa946c6e84e2415eb76859cf5b592f423ab9fff1daef4eef479c503b1f04c0a8b62a201aa50125347c16ec64ef7afbe0f791fc89d59cb720c3c2d2fee2b22aa60d0386f806c0184481b852306b7f5011ac702f894d936f8bd8dfe61b07313064be422b080cf0903b9b67f598e34e6719191951c05ffb102679f55d58b77da0d2e4f6682ce565ac4383f24ec8bebefb6bbbe1d1493442c51648a71104bf3072d1aa0d71c26e17d3e89a5733c54efe71b2afe5a921539d54c8376d837f6e7dcf6c17d2242665a5d671663dd4e428841301afc262857c37b3ddb321722018bbed60be79d2eec5d166176fff326f86916558866009b9300933b1a7667e4ee28e85c0567fa165ff1a1f9b307fe0a6f3e794235eeec6533ad6c9bd0be9d1fd7ad2560da30a7329b156ff7000fdbfd9421a6ea578c8faf21527fdd4a7b18cf5d248d5ef3033ba4a6dc52ca6fd963b1864cbbd44ff337c3101a34ca7bbcb24ec680924ba5f1e6428c3703587a451a52c1e32a6cf1a8143b6e6de01e7eceed448c7ab933b0da82a0e72b1838445022315f61f3284032a9412f9f3a66078937bfc9153633461286548d94f2390166a6ca5aadf0514e396e446702875655dfa566a3cf1870bd412d1eb719b292d1c818e9fe08e57bafd2203f9a512cb09ae050b0a155e4f92c16a3e674f6c68d460a47b3442ac1cf8ed9de197a75991e3dbda0e11cb788bb94fd6c684bdf60074c33d5fa3d47cc0f3dbacaa54b0652136ae348bf2818b708fb7fb86dd3bdd5d7b7db5c113eb2e26323c9544085bde688248333c45cf6d8bca777078bd4478d65210a1addc73a954e93c2011682cbf17b07d388722a3c3831fe1091b139b204f1cb9f8e31f3995e8848704cb469a4ff59c30c55d12d0858fbde4cf1e40115ae94e20cfcc53e33d091594953240eb3892e0752d4b37010809615f8282bb9bb4a572c5e00db7a1252148dd08b6b5dd24f4edbf564fb73cfda698f6f04da8516c2f2d0e28b58e70c6b5c7a95347f8e62d058f7253aa7fe7ed3f7798dead3dd02cbe8fe179e7bcc8caf6837392f2d5ed9f39cea5110bbc47c9dccb3cbdce228fdfbce36b4e84adf2ac23e3107b8002c0cc584cef439737065adb06da2a4fb341dbab1d47a36d6938b6705fced259c42b254dd0833c8242df1fca924bfbf4b5c5d2858e67d6f7185931535d02cf6770a2a542bf1d79f2b53c351266c972d7970dc1c11f3d6c12fb0ac4f7303c6fc98e0eb148083371ea0c2d240bbf710f9477f4480c571baac6a2a65400e3ee7f31808f6c6e225a761f7a731250e117f77664632aee1045ef1fe3b219316ecebfaaba37935241b58dc3df89627f178a3036e33bae65899396d21de84640355c330ba06aab20240f984ed7d8acf9376cad82d7a362571d2e5ec00097322aab5ffcee3be0dc112ebbe3235a4c251bff1cf91a07d8af338e0f67d68a36d9add0d441bbc6db9209f0b22c7eace183afcd79a14c7772ce5afa0857d1f713096019a9b66cc049789a43cda0b9039135f4809a63f2f3ca6ca431835e6e2bdbbff309f5af0a7a6f7ac742bce1175a21e88d8acce57957a89b7cc1f7f340b5cbde31fc3e8cadc451495201b776ea09c8959e3193dba4e24f11e684a42f63eada477ea8da75ac5d4fc6bfeeba830a10a477cac28c31c5a57908bc1d93f58c5778234fc11622f281e078c4bc53e60d97c325af242b61cf0c092d7c78be9284152c896b76af159715a1a89e83019e030fe53e3fa8e6cc4d1f141aeeeabbc1420dbf7ae62d16e577aba5bb80616c24be84206e3b310d164f308b5dc9afe616a5373c58cc363d6c85787b5540cd2c4a586e74ee7ff27721cc284be03d5973e502b21ace24c2a21f2c9f73888652e56c9e8a7cc56e9fec4bb71051b000033c4fa24fd36b295fe8ce4a8c804e72156b37de85f193ccbca9699bf76e38eacb77c894bd67bcedcb836cfb5ca25542b253499e3e1cd892ee5917141477f98567dbe5d2ac05c6b29f6f6117b6e3df227c0c3d3f507cc6c8959f5869d8f7c6b87b27aa8706d49ed0c2f5bd8e90104d2135198e786c772d577bc64b891c24ae77ae9f8d23df44e255be384822fe3b51d050002ed7cfd324bcee58c896cd12c8d91d8eb4ac0442e3ad758163ee32d05b055b951635923dbc025a1761cac529ec76ec52460be78c803437de4b8e6d5c5214c46c6f9452286ccfd8b63d4ec1ffb9fa1d4c3eb2040b91aee09adc6727c9702d2e2f657e38c5ec6f90039a842844fca24a17f25ebfa02d10ef8be73c6c62cba0cb5fbf2ae7f0618d4f75090e58f2511baf19be1a657f43e577dd22f3a6d32d027ae0d0d3b305ac3f25bf4c41f2678578e5c894751d2d613d5d2b2f34c32eb496a8b5c3b5958712555a342a1d552722ef5d3348e16809536d0ca8b43059009576d110ab4bdbe0ea03f2247a01d4810c8f7831dea1c71ac9dabad85afce261ae30a782750d32f4cd78e8929748ed0456e142ac2c474e57657316dd37d430955e7275cf0e52dca8178b430431404c7eb9771af6b0b2b31a9b9a00b2ac406c1a69f791280b715aa1f9aaea3f8ea3494439e4efe50ea6cb4f1e04735aa901dbd75bb18e8a6ee0196e23b66ef54ef3ce2741cbb116696867c1bbba14a6db60e30a49d4d8aec3ceddb776fcfb572b32d709d5ddb0f1623844b1ec619ace2acd589c9f56d73c0c710572be0fd309e6d13cdb1ca6fbb32245c8b690f1943f164a96f00de3631143d387577d156b588cbcef2d2f69ab88af6bc0a346ad16ae1896d99fa415f2e6356c549c5053a97abd6dfa6e975567e8ba8808ef336b4ffa603572d7ccd8dfa75cfc7ff39dfbcd0e1dbc97e92950bde52c905f03cdf4c822b69934d3d708379afc5d6ed53a5dedbe617fd58e96bb80339f4edb2309280a4f33b2f9d20ed561c393687c2c4fb06c989996e9d346369125690006c2fe733c161f3be006e560cc2583c93bb6e88b03d2481fb8599662c3b5d3d3b713d67f0ef3b5d70738020f4a7a8ea0a7e5d21b38cda83318ee3269f94811f04af468d68e9c76f0825c3a2b7ed05b99167f9eab06c89a1bab49cf9641a3360c49bd0d5b97f623d63439097395545da1c982d26f09d87d8a3431d00b954c0b0d6247b038b1763c7152812f3a5e604d34121943f76eee4870445271404185687319faab9ca14f42bf27da73f85ecc9581f5bf7f3ca54f55719b81bcb3e9a72ee8769e01350f885bfc9bd135ac1647dcae6587ed6c664efff643737ce7a4c2eb94cef9d6d8295c9deb1f3b68ad46cb874eae192ca840188a5e87fa1faa5da37a68ed130df7aafb6dd80ed15cbe5262af23dfda2539c33f0204a36c1374151aa28f082d151cc183f8251223260e54f130440116cebd7d39ffc6b66165addaa51d704e770224c3a1dd9b6f4e999830cf077f29c12afd686c6d4ec8fdd7939dcb98c5f992f4856ddbb1e8241f82a3b786c779cc8ba9dee2c7c336ff1f6e22c2af6fcc529d03eb3a92712dcf2ee3f32bca75c4031049991615e8f73ea33ef9dd81f69917f43206a5408999f9255112595eed47d97e4316beb466d2729adb55a1cd2e96e5f8b0f3281002bdcaea86682b7f4ddaddcb13ba62e6f982738af524a6a1799897568bec9e4a401457e21ce19b061d3b7d98a03e9bc2c891ec670d7ff5ca4ebdb389b026df0c4e2ab1fcd140eeedcc512ebf494ae7f7d2419aa24c2fb57066caa1d10ef55db3b931235e82ce881af847a2024411f2145ca22d42081a0c589228498077fcc4683178c5a2f37cf932afc6d1e3d5ef3f52159781d26bbca15ee8e99fc8d13f93c3c49a5aee9b75b8cb075e914214579ced7349d3876e613fd39ef3bfc4780c2a185a0e1552174e529eafd056d0f00e15a7d67bac09c58e7f98d00c0356bd99e775365cfe219ff38ca9fd3ecb54a381059462c96b4850c085d5801794acac8aac7385099a3a575a4ba1f9b06b92b1cf0b006bb2042a99f630b7825043533d1a443ee0e47f4ec64b183db25eacd71338e1c45b05887ff2583b5e1076508c778f076a5cf070bdd7b4388bcf769d6a0c424b865aeb6abad29f4e2ae3a144fe55d961484e10f8ba5998f059f4704b7827a3b96eb02afec2fe3a42012fd2333b505ae839019e59a2a70d03b22adb8c92d534cf82ef1b200e38c9d8fb1cfeede31018eb68f7edf754e4c61eb334d0e68cbaba6ffb4d4ef6bacec1576885a06ed2adb80d93fa8fb33161edc2b62a84d87211bd59b58602144c25ac52bd884f98bda38bf23c70adadd51c2f6dc1f77e71da5be270e1f2296493799f7b19acbc7275d85f634ae8a130f9f5776b70f9c3bca416814fd4b257187b1a05ebc3848b201c00e94cfe0213b93802a4ad495dbde0690fa3307c8599d1c9f7a4d814c79db3cd1e77047f6fc4259c4bf78778e1cca0a1bb747989328d49a3ee2fcf8bde756831d570e3b086edaca39e6923e85350361cf8dc05e7e70e8d5495c8db1b1234af2e9cec146a0e797571997e441cbda55fe37f848a1281dc56ea6d7860314a24b413e9c5b8c78ea31694ebc5fd7bedad6e0208476e675109c4c8b46045e7492f7dfbdc35d55c4448ca90dfe73180834c68fc0e3ad1321115303daa224eacfb9af70d06aacbcfee68c302243c72c0be659913f769872db57170ff8ce6cb13d708f1efeccadf770dd1719aa17eb6db3b6bf0e682992ee86541a8d087abba4cd13a22cf7d4945f52d30115439b10811236bed7c92c7619a82c725bf560f19acc511189e2297d253213b4c6053f7816918c959343bdab2c315ecdd9946e0acb3acd2e4beb026018af7119db999a1313f045ab37c0bddea7ee9335a3b3a6afa31abcc9a34d20a4720401e3ae7710348ffedcf69bf472ab9651f39c1f85c94f8f90ff482fbbdd9d40e7c92f7cb4c55ba6b6acc42bb633bf3c800df47f263aaf02e2fccfeede7d8a0679d5a5649477328bdba425e02a2ff7ae9ff46046bfd4d23719a67dfa3c9eaf2551bb822e53d1eca9947a054649f5c4d957e78dadfca4f2d702dd4a19abf06a209612cc389a9bd5d4e757ac11cf56e891fea00bd4f2f47b47c8a6084f07551138961003852b11b6df83e2f7dc6eda0fde82634150505c7a3dca1099297f0b3b511f124b8b5da39bc7f418d7d6188d8a70649da522598b931007e0393c2f22bc584a32eea6da0c4b550165dfae8cfbe3aedd4bbf0ef86352c14334289bd07bbeab80a0b5693fc5fa26f8e6b308cf29fc4b267d37fe22381eebd3bb66922cfad444cc79e186a0dbf5fd44f172d0e3a04c239c3664450d5f2c48cadc52fcc73672d4b12f11e714650723e322c3ad3f31782c50e70412a16402f476836738daf8bd511d2ec9ed7fd989a4c4a2d40606b6eb16e63639eb577a973f8d603dcf56df1cf57495aa6503382b1456a877de68efc3ae79f924c3966a6004128eb16387376adcc4d7eff6824d0343dbfe34eddf5596d12f8731965ff8f0c61dc79d02b61f1ec3e2cee054fe8eab6b47755a1dde6d10bc87538391b2310e17265f209ddb9e96fc3614e88d6b79cd5fc97708290154f91c7cc466cef40b842916b0cfde9e8fdefd79750fea2210783220b00210bde4fd17e26f76705247759d1247bb6768ce95e7332ac9f8c7618107110461f088b1d9eca2126a22f5434301ca36ef53d6a68aa5ea1739fee69318e1278e7a06e6f504aa47356287630d0862ebc281365684318b63b7894e644a4737114932d86ac43fc83fd94e9698a8201291cdb8bfaac7e4ea2f454cf7964a78b1ff743e00e7cab440718a7e0a0d459181f10820a3e8d6e345b32a5a7c6f1a3dbaf8c15a49f75623ed234145305e90ec05ee963202d4072914a0f5edc888eea1a26dbaa4f5701f0a9f65a26a3a58738ae241b9f26e16e9eb1e5a7fd4ab600a689d2c252d2c28132dd33967ab868ac6f5388aadaff7c0e6dee421231ddd626d13eb7def4d6ebc8cd546342f4a3c8334f701513a93d5062ff9102ab8e740747a40301a0749fd9133fd88a5d1b82f6843f1025342d1e630c14c317f0da50ead58c63f09da42f5d6f08b6e912798dd2b78ba0b371bd6dc0a8f1acfc5c2a3da66f56d5c90e27f0e610dd118fcc01b5ff06014946ab47abf1f9847ee20c8a91d7fa04aa89f3f11d7ca2f2da5e34d3dd4f229e56a9086252e5d75e5af7268e59d5e461baf4c7759d46255d4e27dce6bbf6674a3c51d07ba92aeaee4c5dcfa38c3f1dc32a4e810af7f4a50628a9e92cd64def39c49faad9b218bfc7e6e69694a1d93ebb0aa7c8351b145e2f9277f65ff1e463f6d1dce13e5a5ed5a4fbf3171ceb9da785bf99ee460e9f887e7f0b5df869d4fc7bd3f83f390de6ba522ccd3f456afad445f1c57cc603949a6d4bbb586100fee29defdb4b0d65dfb9bb67a6754f566b77bab68e1ff86fbc568b78c602da1f6b3264e3cb7e8efaf4ba83e8b6456c0f9a71536fe0d1acf73d8dd19e010e7eae802b181b98d4152c9b5e3e27458f0e4dc73ecb7e46e4f53faab0f48e492a6630ba6d4bcf9daa6a05ad6323518b60b9f596ee9d69a328351776b94f94c5bff3d27a8b2949980c2a7aa6934bd20528bb033feaef21a5a34668e1874b0f620f3807ffefed255fa5e1cf04c92d3374dcae1f73fc0e503428cac3ecd84d98a2175dd22b43ef7f28d71f7c03bdb177a854c42e79904fff412a0cf3ab3026913fd88fdddd1b1f47480a2270f3591c244db510277998cc77725a839e472e345b8d05a861f37e31bd7586f466c8a32e128a7389ca2054a4170792aeb7a390327790724f86846968f0525ceeb1941d3c61dcd6e5b164b456869b21780259671f98583278a6a62e27fc64e513efe689b6ead7bdb0466ed4f22d8d68364b6b970315805b7dc24e859de4206a9e61c84f863bf709a12f13a526afc719a8cb472ed1f4011099d20803476737bd527747c9554e0884e57fb45dd791c6d75d7fbf48f2d0be2e961e0fe3612a97aa48eac1cc5c29f27fd80545d88dfd247082a1e271cbb452d637a5880af0081bbda77dcb42ff73590ae82db0142b3e85645e821706ff91834806d21c84cb24b15be8083c432216991b1cf3b13dfb4e1832145baee7736a067b87925604c8af3baaf976e3b05bdeeea466d6d8d9891e71c039e886d219e321b08bd58abd8d1136b28089b44f442378c6257e58f709484b8f433badef7beb993d531e9b377bf4a97a39d5bda271ce6e8dbe65103a37ecd041738d4cc2e85ad9390d6a958df9809c548b224e27386197da118fcf5737064fcebc43725e6aa78d5112c5c192c2d9286840190536732497c5a96cb0547c66c221485c47578d6806751fb1c4834b2059173bac656ba259d4ed53f72accfaefe42de3a2d1a436e728b3d1dba45ee7979501bebc4989c488934879444ffb74b0780b3b9896954e7c6fdb24337a7738f48c1910168928f0efc89d3f3229e201a05862d4e7dfa803448b933284d9114314b8d0b4c0d62b58405795f9825cb0770a6ed08eb9f60173fc3255e105788c6231f216f0fc90ed9f6313dfdfbe32c2823880ba5146e6d9e6856231e382bc105fbffc5c77b6f044f77c015fc43dc87ccd2ba8b2cef28413ef4e1909bf659ec6310e9f1bc85f0cbc804ec23b56128636b2913277c33e6e2ba427ab16a925b9a52d528c4b993507337c66805d169ef592d7940b993eaf33111c05603975c916230f81c2ea299c4b587b591b99fb9b86cb24dd4fe0501034edc0e84eabc575957f344249e94d47400c86aaa1b3ff1477153f937a184634a57503e0b4245dc25ccbf39617b087f5d2bb7d089fb88b5fbaf94398b55c8fa457baf099c19e8ca8ef6dafcdbd79e1d4954199df030935d031a91375f2fad0daa1344a3567deca405cccc50dc04d1f8660e84e777398939c03c7e69ade7785b9c279d207bc8e8a89929f0e8f8863abdd10aa2765f388f40e9c7f263b328df81cdee30d1461819caaaa93b236e3b3b66a01367dd5d8cf7855d0d6de8fdaa1534e450ca966132a2c5843dcdb724b9ae9ff71e57c8b1c2ec63e3069fb38aa72822a3d5d0d5de98e672fd3a7a1f6d9a7a75757dd02a3b1c0490e2bdebff63194cb5372b00746efef15612ba0ac751fc39a4e882234e2da99b6eea1881789e4a12f0a0174ad132ddf2063cefa42c7c75e253bc18de5a57ee5b7bd565d59f846061062963d5b512f0647215eb37a4d76aeeea4f23aa16b10c664088c4f099d7849d5b9d9db4de1ca08355285da670b7477c53c475bb014a5bf7f35506fd5fe9a085769b6a4b7ce89604e9ef98ad4761d9959ed2c0872ec716866e189879706c285dd2d72eaafd3a6e06f7be6b0b472597fe183baa12f541edfce8ece3a3e810d6a92bc4a7db18fb6e02f0847adb7ce591de8da52592e9ec3a021c7d91870ebc2478c27c50bda41ecf89677518dd88118329a8e52e6285597f7ba59fca4ac45f98cfb347c8025f0ae83ae9b06cbf85e6212690ae2392bc9b4fbd19d6f3e43eb5d4c4a63edcb48c3d2107784216e1b04d11d8f5b9bb666a0a14b9ee077e85b6f3b68578e200e53928d664d9028647b3eb6165c165e7845090da252f91c9cf50c11cdaaee1317f1355869f85f8c64882580b698b80712429ea76edb93a9c92bb1e561089320cd2228b4d86c172948d88e434fb7611d58b71d4fbadad75e1458409ee9477ba15fdd22be7a59e7b43d9d9fa07b75df0f07370d3f689e6877064926d35718d2df4d58b971ad76f3467fb59af12af9d18ae68286187991f2c7f19f89da51d49895a460ebfb4092d3bfaa6c115eba4d1c735dc03d657deb3681b314b57df0ce0c3f552d02d38ec3272f2277c909f8d8946ac637306e12e80a53a90c05ba97330f4d2230b58f44015227e0d7a3d92058d266ea55c2a0c582ed5c749c44a585fbec4ecdb2857acbc5763621b82482be37a412e22b040c710e6bf7478ac5b7e0bbffd37ceaaa92d45dd9f9b657225652cac813c340128342c00f5db29a9f81a8ddce268288ef070e9a6d5d83a5fb5e88ba54707a4f1786b3c6ada7de4b17ff09bfae1a85b20f83810f49d0f9aefec0840e4678890f90e2ea8de5b2a2fc377654c1a816332af282088bf1954a264febc5cfc718511bab722c3e6ed22bdeaacad44043a59786802d1a5009d6152f70405251088b384b2d9d9843bb64e65a63cc89b1c551e4b7dbf08037a597610642d9ed2dac3d78ea8870562cc452f566e7f018d1dcf1fb8b4f8f27a914e93bb05df4bafeb870e39808b7be259615ff66963accbac817cc51c9372496ea4a5c9f581517a2f44a4cae09a6949e07a95f3c14807534582a4234470b7cfd968f18a871cce596cf69e8c36fa4e1105821d3c0287b216c6c717ed0c6ea9b453e626c36698ba9a9ca2e96298a7392611267edf5ddd3685e21ec0804f228f8745206e2051326c6a15e8a95189ba33a7069c81de547fe5777dd4f9b2a2dc7ec88a6344a48beff574fa0e2fa99e686c7f8dae90983c9a89d3dae234772ae446d0f35dcbd60058a634e52dcf4f18062d47b83b1786199ee712da8ad9c95951af9383c9ab06cb06c0e90fcc5474a8f96a63f6a0547db3a3a21412527f8340cf5db5d71e901d61053f432e1a10e35583559745c761330e0d600c440b6efb81161ca8f9710f75f079c3993a0c11affaa0d900c7421a7ee36113ad2d866f73075623691d692bdc69d95852eaabd0686b6f2b589797b513b6cb2460759cec332ccecd23179606a423c84e8e4f8623ce488239a8ca053e0a2ce87eb93e8968f123f61d1dcf84c4d34118876f50562fb709159634788fadccdbe9d7a98dc00e676842bfaf02c6cfefef2be249cd23b95c9a38f5ae081fced02e45c3d5a181a2d9020e94647e4024e1084443f4ef09b95d2d0946ccbaa930351a655a1fa206af40a29c373af684eea2d2f46693d422da155f8e4f2a3432ffc31978f5df1493aa8446f836dd5917f1d5298bf7e4d748fb4b69d2e0d42057c6ac800d8df22cc7b73873d3ec56ea66acbc423c0cc4722cc9e4436a65bf352cbf2e9e487c1803518c500487b3c7411185681daed2ff666e6e791eab7d2e91b2d7419beef53f26b6507f1ef11762496dbb030488a7440ad543f0ae7688de271e282ac0181fb3fe156c3436f45f820153b0a2bdcb19bbb177a002d391ee774e50a6cb079d2b0f9d63e2da8b23990c48766e7ed0e1fa33fc827f0ba78ead382f17d65451da115d8a3278bc52aca5b408291bc32b20dc7009bcc527a6566c86b58d8f68b181ad1258f3139e8ac6ed3fad0a71b8dd0f4b12adde8c2af2bc4f7614ec66c4db05d2127aeeda6d0dbfef1d78e7efe8f6a351c486d66c5fa3ab059b31642aefd899308ea0c56ed122faf3eba1182d18f2a792350909224a0cfd9136b563d2b881987f586ae8b3fa99adf0d31d767a499597a9045508fc7122ea7679df6ebab8485f8361208a0b0b66b1809dc4f3c4e3bb6a90566837a472e80d2bb981ad7aebe0021b56db089895281f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
