<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"804cf0d8989c26eb266d0e2899f70d7b3f437159937115be05cf9b17cfa3ca1c73885ffb2cc56aaad229c6795e0f8bcdbe6c1a0876c5b1e8fdff2c58d38c6fcac6d81fa9bd27f1f3997d47b8341f26b810d0824a10f1fedf703b99695cf9024e452c2336affb435717e3aea8e600ca4f5e1c21110b0b4019c509ea72259a1aa72c67f982b478d66ec475f7b00923acfa6641bd2a668ed114a03bb49c4591f044e5fd42719ea56da1f5d1ede72e5ca796750130def7fcf35d66e3ae367d9af6e83074427290e63e894bd9cd0b60e10dca956ad0090556cc5f41e1e270254e9ae4287f97a1f65c96e3ad495fd05be585cdee9195c5c1700b392f73908fbbadde25dc8b1c12e9ef9ffcd3c846dbafbc88635030bf2fcf52e03e2db6da811cdb07337f06e5493f57b1a543ce378a31581e260d8aa40a308d9d4e8cf2ed17571210913345b10bf064618caea5840b456aec30f699d4cc3c74e5903a32278988beecc49eaa99e57e31c39b6a8aa8fa745ba8006708f323601f2c89508164b8d33580345c822bcc353570d4678cfd379896297d984f169d5d02122f38ffede5ee1bc1b60925e280417ce36e399586a3181473a464a5bc66252d2182876d987e978f27a6304fee34eb63b18642d04119238648c4ff877a07fbe331e7055bb6a21814168180b2479e2fa9328ce72a271ea726ce270932f28ea1d0150a843802b748c11088d23852fc0d9a483de8bd975bef19db0aa0484c601526e21182f965db859b0ba408c77208711009b7eaa076823980c58d8e9f822a21d11640072050ca8e97c8d2fa94488465cc5e83fc18ac14c8c115faf48c9ca5857c88fc7f2fe452ecd51e130d989eb355d57e8e31fa1942f1edc994f32619ed24e974b3e9296da6b0a98a95c93e3197761a72c5ba193d9ed6d0182dc0129bf7353a4c94cb63666ede8625a9cd1898105fe550f1643a912bb12e4d88228e199311450150b87fc5c6e115a98c590c7c8219caa26ca4695af3ef29f24cea1e09c4749e2ea151be077f083b2057eb9adf3917cb03f7463e9a7b7a6669e2d81707245fda9d3b2dba821cdb0d1ca9eee79b3bbef43c18c48c4c5da322089585b0e59dad3651007b5e4fb1c13800780dae07ce5bf0cf4dc917d69bdf39c5c1eef2f07a4bab6c502d92858128809f4cc2d2d9f2a569d92a6418bb90462a0ec1ab337302cbdffc51c8f28559486f7bc8e1f4387419f1c7f10add3e2e4bc6f910a3ea529c9e3be6ed346bddf6d8bba61f1331293f9b12eb240ddf22d941b2bf5f33cf02551680558e76bfbb450265adeacad3d544062ff6c23858bb70d487c9d0cc8f4ce14220f68072f97fbdb447d7c5d32c41ad8e92940f4287ef1f26f57d355415683726b1631a5d03241c55812ade28e2c037b1fc63e9e38647267314174980cc9349b68ff853edfbeacbd262210402118d5c4a67fbcc030c8f607f7829a446faef484250e66776a0fb0f69912871afb99721bb54eee66122c2827a36f0bc1f43d3a59cd1d4a9870de8f8873df63f81a7af70eb417ae8d3bf6d571b965b4ca0869c57fb639c28acf6ac0761176293539df126f66d39c19b6a9f1b583c927b4ae6b52af6b51296012e23cc4fdd7ee4f37c4a71336b6fc75fc734b4d7dfdb7c22f1debeb5ebf63d5027f3b145359f9df1262d926d134f40a3cf29fb9fc48533694199b2a1ae30088efca6242778e3c61dc8962821ccd6e6b76cdd9c15ad2c62845e35e39d689baf29cdac88782d0e27fa1d6701234103d765eb954506266a2a175d2cbab7c85d08df56298cd7a0a976af45e570e22fd3f1c086ef983e181615c610d760c7c4b6ee8145700c1ecbff508ad36dacd266404eeedf4b173b8409cf6d33767ae0166523affa64a218f89bbf060e0cce1f7da9198f48904344d215547b38198428582dcf9b51b9fcff3e5a23d4ef5ec1d17be31648ccbd2b792304ae4ea100f175d125b140962ba26e5b6ae48a40c91558035d15e975067847b79b21e8e9e5dcf73008dcea5b1f4dc32576d9ed2641d4cba2cf3c2f58da1724e78589823a70505c6df9535e96e5ba882855a06416b407092b07ddc57a19df868aa3b965fc4dce5dbc129dc72b267b9f1ed678a1be08f7cacdce6ac303753aba0dad420d9f856b60f89531464def3d4588effe5a5b9444065d732de397ca9f1e4b29f99652857ce3f7066d65505aa29706fd88a766a3d11da462ac586801ccdc2e41ff0ec7cf3123a137674da871e5e2bb9bd7460531dba2c356bd7aa9edebb0924d8da35052486f31fe3ff019905dc2979e7b6608e3db60eb3ecd7aaf40bbeccd474ed8bff93fe9eeaad3073c58ac0ca92cbf9dcac140883ad247ada3444c4aaef92e9c8e99877873e2ae30c97bbbc87fb88b9af57951e989e07d7165ad129e0593531a167c39c4924423efd1a2ec57e70a5eedda573aade2676a11a720659971153f96a0ec6e33696e67fe919ed6dc890aeafcbac6b28bfedc720c77ea3830cdd861051c55729601f7f8678d92bb5f0525f64fa1bdc5ef88649ea405e8b4f1259801e8c33a09dc9ecdabca9f8a4c92ba4e2b3addc428ac2aa52a820dbbde1679d29d393cf28f8bfda599ae9618e10175ac1b3f5204b98459cc86889437895bfcc1c882d32fb75465759a85f0000ec6b0499d39c440fffcb78c218f7fdb0ace336b6f1eed3ebe2afd5d11cf32352638d62f403876aed064383797064b6bc66600f70ec6706f6bea3c57c6e7a0d858227a8099b0a07d6d558e3034a3830d739b4f8e5ea5ad0d74f1c8c181642b58495dfd1dbd691a56e75ba266b6b68c058e52e80ff8f184cdb0581e9833642d188fbd83d55e38f001195e840167ad91214843ad67e8800aa9ab9d22db074ff300c2065eb582fcea25713c5853a890238e68759a2a0c5b1c75bd310004b14676b8d05481975c683413a763e10fe750e76fb9d2f5ee26bb442db95057c1fc389b24bd048f146921e390d64ab83759f606bd75e1e28391386091cad4e21e5e1b671ccce68a8b6d5d46fbef12bee0738e93664e84c9396149370d4116b3ca0930b02a42740eacf6ca9b779315fe666fb7179ada4855c5277c755ed3e22e5c503b1addea8750642652d69412fe3b4b8466776a819c52d0f5b3ae78508389541c4785497e6382ea89c19f1c82814795b1108b4165b5e983e1d3e506156a32e5b41f08b5e9926c1e2fbd72dcea880ca6a0ccd78bf7ec5aa22709847cdad54d476474a74c91d82e62e9e01c6964038b17cace8b14f025f48b8c2dd6290768027bd1ef8282c79f309b70381cda67c805098db71ea6a0521a55d5c8e1f0e8652dddafe85848b53ec867b2a2eaadd4d683f5007c60b10c65429429cc6c117c56f0d509084dd859c75d98f5acc94d0e4f09156be53bfdd418ff4cc46c713009258e5303c5c8c1753fd28b0385aa0f250be33f017f378451b844a20f9d6159864ebaead95fbaa0be442eae788885c9fe9371486388abcbdcd9c0b4621fdbd73b6b60b21158af0c03e1df8a3320f20ca1b1cd0cd719da54890344c454f7cbe4ed4d1bfaa8dcaf5e6523861171c79e95d220d5f1c82e77e735c605ce92ab0842d55435a038b4a62f222f4ffa7edc67dbe7be4fe217996961adcdd2028c56bc1db3b96a2de720260ffe03b39dc1105cc0175ab21e7982ccad8d6e9e424cffa040e4fc50a0edf6962ee5660f7e9b19a7390a34438d7b6bb59ba7d4d7562a989f191580da34f6972157ac28b9a87e51c443bd211a5e972cf0b61fe1ac7122c1e6e5a433e94a1cd4d6f1805cff30df36a832b4e1cbc55877d9b5258588b0e6caa4c5a98d630c8d7a43f69112c40b62c5d54f688eb6d044919379efd15a502044fea4d22404c4436a598e79451d0273094ccf55ce527fdd43fe0e4a8053c81a761801cb904f20c3db560b79689cc9e5b62a5b6005334b4001d0b150a303e316fe4ae27711364f258478ecffcd702b71f6d53174f07f2ed206ed75e423d18585453a73c6c9fe4811e9226a6b357aadb8b36b8e783544e7dd0d65ca8d18990ffcf7d219b1b15a3ee8b55cc1bec4b5439b976a4d3fa928e1d9903302bb47314e905879244a6a3622770d7761fa92f100798ad4f6c93d98f0c4c70c204b409921628fa1f70279b0b990f1fcb619a17ed01361fd4193757331bf14550fc1414caf6766eb64c7848fb1069a2d9d9c9c50a5910f7ad19f37adc28767cae0ba04fe16f06353cd4d917f08f1a1214ad1ae71267414a05f20423b6d970abffe7648c969602fa4d8050be699aa633e9773a84c7fc4d9549405eeb54952c9e7511e8b0d4a528c2bced2977989211221a2f4096d989db4d57e6d661c5e8edb9a43cf81cc2957a39f8d53aca7998d4eb9912237b02609971b0615ac60f0e5bb762c896c9b430720862e125d55f9d2f42b93553ce8c388c3ae69cbab9448593749ef517b7a4813b4f29e494a60070f21575ade907fcfc37dd841301f4e18649e1ba0bfbace4444aa439ebe0b315341502fd0102897e197fbe4b555da9cdb43abbdc576ad391931c4d2dd0d5e5636c08bdc80432493a92bfdf2441157ae4472cdc42958b24b6e1b7c89370c5443455182d15d5392279ccc513558740fa2a162156bea8caa85226273918314a8ab59b3c2de79492225957350b30c8df7555ce4462a8c647cffcbf7e0087af29ad950f03392c8342c21507d317a8c4866145179d10dab60d082630eec568df2dedcecc6d7628d4331adca0985fc76ec5b6613154ba986dd8d0e1dd1a3bb8e0cf6b38929c56185074faa67f4c6ce6a90cfd7e55ae10390caf7dfa123dfb7f25e4b9d0a9ed4f50c7bf5b9efabc901173758cde4ba9c4affc75db2b8a03060534be3934e2260afedea24c20e11604ba7cee23b829e406486958878fad64035eadd68053af6e20f9a15f5f4684c21964f4feed76e4b66627c1fdfd325c40fc293b9d9fc55ef8a2f039430c0374b33061092eb25f8ccc1efea5876390cbb7faa00deb93792ab8d55e04f18258405d86257fb2e7eaf57402244012d9eba82c28f5959b732950eb8e547b2182b27e5bd64f6b339efe4e4f2f1a322dc882a7fad4927895c43bb737a7d0a6fa45e9fd20434b38c464d708668e863b5533fc81c481431a446b727b773b678fda5c79c5437ef9f2d14747aaea4150bc57d09572f8f1bf8b5cd9951eada66b9496fc6632cf59ed1f33eb9a896542615e67811fdab90d9318226e90d21d4fdfda92f51dfd5890098a2ea0a7e8aaf161c9e11e914d0562ddce280d43702480c94beeda88bf365b3312d38aac970ad04b29067d543f3d43d264a2b52b3fc4144f20426ec47880d21a7fedbf4d36841b8e5dd1620771bb6f252bd49201e978cb79ba147191e32e1e1eaad54734cb0757426f47d5fc54f8942c61d5d72e17ff7c72900297bae6471ede42326c5dfacec66737c306800d30b0b8649ba81207d26025b270a8277058770cfabc1f9c7e575342fedeaa07cd1c6c4f6f024fc59625f333372a19bbdf983614c0554946ea3a6c8f89dd16cc172382a3e2b848b8510bb8c244f216d0d0486cd629d2896e53abe0214c4b6b671d3c0106acca7fca5ef5b28d1568b48bf79a7e70b240ba7114c1b10094f867101aa67b34f3aca3c3f3b7a1e0bbb5e219505dd97582dffda43bc8d1ef310ea863aa39e9fecbdbe071143db7bfbc157248ccffcaad4c743f75e7eca23890e462688b11b076a262b8af71d2082ec84f66afbd8838fb5eed409128e68db70007860d4a09d4f691fcd9ea677868b5f5822399e83f0ee2e0bfeeacf1e9287d38a0aab282e5b2994bdb4146b935185afdb42d9482e6b693a9f9d1f2bc41945cec6a19a7c414b8d6165990dc5d88daa8cb1dfc2108369138dfed5b0517df6198ce010d22f197a68c02fe88d5b46af24d9bda22552c6fa1b184cac0febb109d33ba5fa75e13fb0e2c937628afdc2c06bd64fa79245d1b6cc4cc9ec07d227d23522ae34e4c5d70132828092652bf23871fa3232ea1a88cd1792463f7e32ba96ad36783d023b37d7d9bbb18b7abb788ad4c967b1d4db42622431188951943c9794c49755d814b7c2574f9e330c647b85bc84358772bc7ec6949c1333dc5e299b51ca6f3a3aced84ca98e315853291b6a9a8f9991314d2d3206a176a3e984bcacd7039aa8640509bec1c416f2bb299e98580b9b05ca7a90dfc52c098a0c4362b0843ae09b99068c4d5641e7109294fb23a9f07c6233b9b666c5a6e364f8c242e160471c20e8e0d90149e2ffe18a12c249e64acdbde98409f313d3e408c8a3732fcfa154dbf24ca3d78c3727bbf580b096a0730569dac4413cc20c3bfd2a65622b5646bbcb7cddb5e2887a64a4c10713f8f101153209d73ecf0ca74508011aa7da49e932c4011f97a42820660e364e35d004059fa16fce5652c5a68b9a121d03a146d98b44c8154429b4e3f66560cc5cd19e58e64b0feb40989d95e35356d6243d5989d6504b3d407bbf2cefb704d69ddc6083aad0d26f1e85de83f225c749592a980379c19228853a8a655c694db32710030e2c959ade3aa18a6d3fef83f7c4f81e76dae51acfa8e56e132b68c4ba3254aa36ad47995223cc4f120543aaeacf41e62d593ebb4a578051e58d4c48f650a94a3731b53eba4fa19b641bbf4e3e7bba4ed708aeeb8a5234b3f08259b19135ad6bcbd05f47ec8a6bd9148b526f1be74d47e9554e4af3d3cedd8bd9a94f5ee55723a3d3d3707d5e4db2beec1d999c91a26a4235dfbd95e0a37d6d758fa04fc5e924174aff3f88374bfbfcecc7fd873a1f26e88524a4fb9e5b7be3289deadca7633de7d4f57bfe33674efa62709d6bc47277e0833fe5fa3827af095f434b50de06ffa660ce8f8b025f6c129a1d3946e6312d3f6388923cccd6b65e65e4cd5a29a56d5c5fa106a0ca8e0bb25091518a06748beebdaea6790cff2c3530ef6eb9e6f60b7eacbd5f01706c322d32cc13ed95f7b2e855e39938fbe2266a190944bbb0455042492d9a85dd80ff35bf6603cd58b65dc5d48e50165b455b7ad75347f0211346e0f1b383a7dc4b18ee26a62c1c45d17220c412a4c74017cc21757a27b27795e6887608d729b40106d01dec605e6e8293a3823374b2ca5b2d6db26a0ba76fb4b0b075d83bb90aecae207c5cbbbd4cbb2174d749a87017c000f0c39ddd7c261535ae517148b2a9173064a56ba674176f53283cfd253903a72a037e1a40c46c9532679484c79e6672c7f65153ef241c2dfd4ef72a62790da06adcdb32b2dc47a73e0f1a781111623a02d22e93cdf8068a3570242242d21f98042d66c77edfb49d4ede91b90c42dc31dcd50bdf8b213060a435af7b1b4ec904d433eecdbb853889f8177b3a55eff2d773de583752fcb930ef1913480c20dbcc3e422ddebd3eb1776e6f147caf3d1cf5a14a6d86c2d7703f1a05f2bcc1378cafd4ca7b352aaad84aaf5228442494c53bb965dd84b1d6832e95850de51429408edd719146cb4eb7c3f205d21cea118aa65c041dfbe682c291780002ef0161393b585eefc17f52b508cae40b30001d4c43b8d75daf6b9d791e9641f3bb5cecab01feff6adbbf4dfeba2a15c14f517f90e5c628c2e11a8c9b314be02b290880dbedf025cd6bb2c93ab334eadedf944c1f1d54c4fdc0ecf43eb089bed6f3c96224ac9494a5883477d1fbd8a1e5cd6b6df3a9d3dbb3e272444bf076c88922d1bad5df289e6ff22d768414d94c9be95a34ecc1347ba3efc82d8f45781c5483df23c25adc5d62347e522c161377421a96599015d1c088cc02c9dbb6ff6aa9a50efe15a5b9ae2dd05534099ef0725aeab90a9f7ec774ae7d8a7a6b0b0e9192808e1859b4a5187fb9f7aa51594e0016923271bda07be9789255c52f0f841c91447ebd8bb8bdf390a6ca8af963bb7d8626d79dc26975b74bafe46ecc26553fd0be790b543575f741ab6139078253173d238d265b0ac3b4f13951af173a272b506097121e38febd9e849c36222ca81cc39266e5decb837e6ee7a18f54e92e477dfd8a4be160ec3f2b46c54031e8ec99ef226c1bfdb03eb377ca9c4cd6066d6c82f441864a83274e6caf35e25d3525ee9db88fe49f8a3bd3adc0df9b560c7ee22d5a98fd4ffa6d8274db2c3b599a5f542c5a6b73cc4b92166df2035243901337a3958aeea0ae582f23ec56cf2713c3ad515dd8440da712192d1938fe41586c906a41ca6a1ea57d87b5d980d14977e2655cff4a6433fb3a8fb1344d1864e4b19a77af021413e7ad1f3bf1d0e8f2c69b68740278de16883397497864a833aea03fc45318df2a18204d5936a7d3b7bfbfbe98bbaaef82a62664b6171e3f1e39d40c3a2618501ccd29e710e42439ff6bd5e8abfe7cc42d356c3f4dec0aa02107586d2465bf1ff385ef415c2b2f8313711172dccb3cfb666da77f6d0cc035127a8abc58e15968c439740899bc34699828ca366d0b6f9f7d3de634207b08b8842cbdd4c34ccd38eb4b06f08bf8ca2af7cd84fd719539de0f67ad1597605105f5b0b5f73559be31bb93675b062957749cbe5d732acb293dadf2beae022d21bc02e8b9ff0d489f3b3db338c4d3740ee92f91e36dbe706a05d25535f70644413ec13633240eb745654194fc1f1c631be958b597f54d3c0c17f7f7fd6eeaad4f6fe6638f9c81becb513c3173b36276e14a61bac2c5eb6f64f3960494614926b48455ae7548b7f7566fc031dbeaa2c3914ef27847f00fac582f7eda5a73c21dda9f54f82e46da5372be8920218652e8259dd4e82b10c1aacec6b660bc72fa87fee3fd9cc4bcb5dde1bb6dbf0f481beecc8594310edf257c64abc2e59e4ec10b0c31f21530ff9a5a01db38950ba755b8811888ec3988c74434c980bd461747f0a8b780fbd33ad11a3b7a203fa1cc1432f7ca6daa1a1868a5cb01e6c57e3db3e2d21e998bf10e0836407178154f50f689c371847b8d167cf99dd1da13bb8904c22d15f8f019d8fd963df39b28aa39ec629c977f9ccebf24a6cfd873d0220b190640ed4398bff48ac9cb7affb41bb12116b344f8765f5fb6b6c55fbb91d7098ee1a1156cbb0503285a09aa0c6a4d12e8d0380456183fcfde932af3392eaedc7cbe8d99571550d48fcc814f62b403467175398d2982e89f8669814b3bdb0edd2b81e8df3c6fde59cf37b3f30116b1b9765d7b89dbeec482de0f5c50a0fe8e0600e89978b3738648373b5788118455ed59df645770f8e3f364a3eff212b3f4da33d62ae8fd227e0273e46de7ae817e9a75270967b2ef66bc015ce8b7a20d6348ee0be964bc8c9b41633a80f8104d141b4340bea49fb64474ffd69e23e974890886d4135a1420bde10770a9beca92f58c76f00d610783c1492d553a2bda6a8de5c70b3c3a672b49e144701539c257ac25266adbe6f04543ae8a3aa6448e1ce67c0986f50f54dfe12e63a831e5581d483897a08e5791cd9d9f82d92cfd4ad7155ffd8f57508d9655624dd27a30a11f0d65b4412d78fd1d2029a500241fdcee8fc9cafa34c0b441b31d3df61a7a2540d5207abd03fc02f09313890f3b1d1e4f7b5886fef57580dd023e2d188adafd1275321f9213b158f2f4de238aa87dfe9de0301f1f921ae2ac87b5a0a886dcae562ee8e78fdd3fbb970bd59bf1089f897524580ff7c42551abcca46df2540af53a4bdd776660d03453d59484acfb2f9fa7f53b37c17d4855cc9716823d7380d6add8117732bf6ac7362ee5338d7eef2cbf6fee3548215b8b64a407a598a32028ae01df34b78194abe2cf086c48e28ec5ace418bcdb5ac9d45faadc742e3bf3caf316909407d8506465a3733b0ba4224e075deb263a05d7f15b6483df8330256c1c7858ed644e5416221cddb1399298c2e920a0b418a3e62bee5aa18e3094bf01edfbde667b2138ac85ac883832d01e017947763762414b5231f6c5ec292943b88a3ce04467261c249e2d85d67be64c6c1541c837bd6e41fa1d6e050e88ebb0f47928c3b861e25b20581815691cf7ec843902fd1e2c398fc0df1219b709ba6dff22299fd4b5ef8f8ef2cd5f591af9485baf12c016b8572fe716e796bd4320c57029016847f875b16870cf9b4ada9a625b2b7d8d85b2890bb0189f6b483553506225ef7e27a3757c7ed88a160416712019eafc9cc050be9e276fa4a68962016282e773d992193c4c0a67e369cccde461b137bc082d07b9ffe203ee04ce9530b96f254b127c0f533537f4010372456665a8cb203aaa0c1fd6ca58ef0244cc27c5121e4607da63e7aaf722716fed866ac8586daa2d6c88b849a299d3d12383faeb72c3992e13b9477d12da47a137ef72c808709fe7c1440b7bea06de3a3acb169dc85c8983b73a70f5e41a196ef27df9fe026577da95efe41926e37f2bad2df63c8051522a0a51d84d257a65f8b9a673f0d881c3300117a2310127b6818b4bd5eef65771e58df613ac52ff65cd645efc8c6c52d271f0d95609bb689182d4aceec45adce2b9957e220b31bd38adda93f3b2080568bb81abe1b34bce11724b338029245a4cd683292d0727377d7e4bb25ef8f654b1719ef0963c51bff96315f534ecdf5ed9579e79020d53b70d69349d36caf0a88dae19472d1f55e9898086b1616325a8570166db9b339c0b85cc2b894122fa3f49003ec6f763fdced5f5930496d7cd94bb979891ab361c001c012ad32f60e793683fb17d22fb8b74e3f9a923ed53e5dc8bf5859270954136bee5abe56abf026104ffe6c368f9ac612d3ac05eec86f6f52e1a77d35722f6bda620ada1d0b237cd09c6a26e4abc2e7eb29f44dbbbb875da5481cd2ce906e3534a20f149caee9fa9a261be2c537e3ad5a9fbc763f1f1c59473b7be53d4c01d6d74fe6a02459a6340d2f733ca9e4e50f7a11a5efa9db9dbbe7568982cd788cbc92e25c5015d8e2ea8220ef094c4607a07a99aa1c917f769bec39a1b1cabc5d869f52a590cf2da279aa1f4b863a450ca995060ee981b2b2acf9b662b9819c718c0a5aaeaff102f3b41f064474b2312ffebd084e697b17c9e7bc9fd8ee0d02126395ed7601fcbea205526c1d57a0db1f88e5412455ce37a79cc1c39ab8b3f548f5072032c34b82582d134d95fb6ac18ee7fbc3bc8232f5ca095598bd55c9d83261443bf07698828e4701ebe082fd2e06ee2106d1666ab9e1dbad62680df0f49a339310620aff6f167eebd01261218d1855bdda92afcd95adea514c979454f4eecb9cb0d156506f11dfa1a22d38714b34b9d4ffc0b274be434bdbb6efd5b521161301791f596dc39ba8eee0ad151746c50533aa011ff8ad582aba22ce55fc84792779338ea488f8d63aeb7d59f429a857391b7f69b548a44bcf4b42c1bc1ee0e25b36837e152887486e90fb00ce6afd9788a3b950966c95d70376e5b7c74d23f777a1134a4a896fc619e9a1d328d4b4f254518aeece2fb7c1682eda81ca1180d7e07cf4cf58336ed5f7996208cff9c99d6bb950307a7ce18fac6b6dbcdc74091e7511de7b4523600f84a2fc0779e1e5ac739b081deb0f1a601f7fd04ce9252e47d5b0293af3df3e2726799737fa34dc6a03811fd9bb1b1e0a138cf8048f8199632b3ca624e862cdf8079c2a4394498781437182e57d5d2ee4cc4f7d29c0eca19362d71ea3ca7d72aa4847249ef4ef1ec481b0cfa74e5b0107994a6103b54d204b5f3340c6d1681b75ab2db957244c791252fd252b32d55a7e45cc63f340a7c6028b33cc454f636a59a3f29a71dd3ccf7693b477fe72d56f4c5041d5d6dd695679ab10ab52d97c852bdc32330bb11c5956ee7144128940d8ef27a7ad855cd481959016ab97dad732a4de07cd0a4576a7b0bcd39918b1c369855784142c43e0871fbf0d7c67bf9ebff0b3a0d89831cf6ad9243706873abde7d7a4ac0d22062899886bcacf360203381dbf8ccdc1b61ebe5a1adf57c0bd7fe9a9288abed72086b3f49bacfb56b5db5384787a86d75323f1ffa14be822cc31461e27bc97c9535dc08d5fc746a77a43a03e4602811df75d61057dc32d8625eb49a284251b808638c22fe893b49b5938c96732efa0360df2fb23f4c230bcfbbdd32d8b165e5573bf518409d59f0e5fcd297a7b449767cb67fa3ad70a5f77a2d1be61f9e0a013f9b371fea87e97f812f81e4e6502418db583ca6f4d27b154e4a756204f5accc6b9e0e07b866eb0daefb7b613a63e6733b358b017341bf635bf79ac2dcd008aae5ea8807fb98a6b5219a5e887e603593f321c72aed17609dd838d0d0a2937038a7b4d1242607198b67c08305bc75844380e011b4b31bc8b7d0a418a0272975e41e7b35cabcf3b5cb900900f8a392827406fabbe7dcbf91ed2ff9d26ee2410fd8164cadd3e402ab18567580a9a1ccee770f696a1531a8e6b9a398d39910f859a763549a457d51e96bba7bf75fa735f0b0b18297e7ce82452397fa41ef6bb2658e1c34a92734b61f217fa6d06fbe58fe001831b2c842695c205f8ca4c27dd9bcf39b83c6f87a28a000d76455c5a323a5066e5ebe2d0e4a9c5910ec0618000a3a5441e9f2ab0ea3b549b6cb494f30e61c61854470898d12cd3001bc38e5439ef2d668bfef8ef4d4b2c30d3b18a227ff8752ac7ade48274e9c6449f909acc22d312ba1eadad4859b0e05008e2e17c6b44948d29970f71f01f5ba2229d377006fdff285b5f101f2b7a4179382a14e0ad2beeae3e94ceae55b654ee9f73ca96f940a616e1dc365873c3d064634adece997c686928863baf2e66feedbc225139d7bb56989d9134f34f1d41e36712ded8563d3f559d15a8e15d237769470ce48e89b9a7b37e8f8d0562d63461cf6a5bd5ec7cfdece5b8017874bbb2d2565ebcf0595f59e3e1f1c383a9d16166490005114c5ad1289bd2ac804d7181bc48c2799cab4ecbe44bd8adc35e7063531bd8c28c7617ed3315d4ef773060940e011ef5ac5349aacd2ef99ccb3c95edd38e36370197e0b9ad2640798da73b0fd5055f698835074bb2d94e94e4131d7c87827f0ea5cee616b028d829b0daafd8a1e698951d474dac116c36005eb7cca50fe31bfa0f74bfe3361017dae286fb8a3897b08ab3d10034e59b5dcf14b7e48ce4ec98e9a240443a5bb54cb53295bc8968688fbfc5703b2422b81cb4e9b5dca25c2af11f548deb6ca2db18342425509a9873ac8535a5e73e73b185700df659ec5bb31ef099581affc7fc5fa74d0191bf791f1c0dff01cba774f4a03a8a2c34d0a8806e9b20cece1b1ad0a6b27964acba5b4860b945f51caaa39b211b12e872c34e2fbd17d04d1e53bdc1b4561067bdbfdd8bf179339d45446ac5cb55b958d126745060228cacf1359b5c1e1700a36d24be3e605849b27ac9d74358c2507396af59c0cc42f8e565dd393efdbd52cdccb1f20a4eeceb34175073dcf7a2c46dbff3296c12a91cbd5c789cb844561e753061030bef82d7af6cf0059c528eca4eb4c2cd7a61041c72efed8fb623ef33b7ef611d84637db27572ade5978e53441f54fbcd82ea7b34280a9fc55194566ccf7ab63b2052b0dc0cfbb3764d50641ea88037c78d5783a71e50c182343ef91fbe3c7cc1d2db652f60f0f9def8b00f6b2549e7b4c80a19f852ee648c670a8ef2b672ea10c236747463f1b6fd111da8af5b827881c3dcd6bb8dd6bcb0d99622dcfa051aa402b70bad1e037a830e6bfa851ffb5b3b913f0a8f68237245ace76a1d9adc45e7c5decca8f218f535ded757f2ce5c241114d09f70f3e2ac568e14b74fa5a6f5375593373a4fdc343dbed5ea588ad969100626667d869b75c693bb3cef8d72c75024b686843cbf8e76794fd2d5aa5f729fdc00dd6fdbadb1961c8328187161a4fcbfe5ff4672b6f75bf0e143c55848f6d0f395f6255ee8dfbd9078ec2f42cb27351b99075314e89895faaad236de13c4a77b12efdcb5d59e6937abe98d5ca267bdd649ed3709930c49e70e7e340fd05ceab10c9810118b50c594afba032ef2b7345559e9d94f3ffd4209c18a8fe5fd60687ee77341c0992d77a97d3a9974bcf97ac1e0bc3be8438152646d17c9ef0e385c9c97a9dd08ffee116c57196c606920e331e42131a95fca0820ae682d277a635ae8de6a07db257c21a6fa4e36c0016c5cd40331b5007cc580a3913bbb51f5e2ac489c681c6195cb05dfb1190520501a5b33dc59a9a8c3204097baf39b33b07cdb5f91ccffdc1d4a0f6bb9faa95d3d2d2e3008b042601c5b6d824c691dd05dde2cb9559b7c3abd15fa1a26aba52d813c222887c2bd2aefd9227c4f63f07ae8f690ae896a6ca02b90e314d650ea6ba02d41b0c6369dad89554ca1854cc2b1723bfd867935732016fd232b60411579ea179895498dcd3e6a71a32daf6535e2c7ddc886418beaf6f4c344145facaddfdcdb60648cb21d0ff6c9fa0f795fd54f2289d054f5abaa46577ef19f01a0ffa2c6b0c98e76a20eddd941d387b2d63ea8d32a5489d328ea65f7a59df4d2a2df17f1fe68023681d105fbcabb677bae81467387af3d0c17cb53e50dfd9d364592bee8cdbc8fa46d1e7331eb0b03772a937069ecf40fdcd87ad65ee543076b97774b23add4dc8862032228c6b1b645a6a24b8c2db6694ac261dcbbf7426658fda7db8227750b4d290053a18c51f6fe9ef90e4a153da26d5613ba1e982e74db91a70209722bea01b373b0cafede995066a2a70b9ec9bac2e30c337075f0026e38f2690111fe104867d5474fdfe6e3ec3451f4b74f2fe77c962e8afd5b14461740ee4872b62dfda0c74df07b93a49cc0b61f836c12a3bd9bf9ed65843bcb3f06218b56ec3b263cbdb1b6e000a3c45f5a57cbde06c5bdc4273fb1f698889ecad4fb9d99160381ea8cf4ef6f14c8afde6856a3c01a75926ed5ac30f8b562eaaf2c739cd8ad988a9d735fd9ea71c0d723b54adc078773a7e93ebe5ace2633bcde53805dae5fc57873c43fa498601a613d37653a9c302b8dfc6804033df016eaa97d5036f9d4a4e6c631287a1bb008f556d40030ad708716ed861f3cc3775e7b86afe4543aba92816c19086082f08657e24746c16f110968aa2c294976c1d7c9282ebb11ef95ae140d140bc4bf1f6080b4ce162f60f9d965836705d68af35824c4d29081c7ac2cb5759283d8c35203f4d7b2d64fc067a80ce6d1b8b2c263ca90b5cd4eee244594f29d5b0e8623f542d6a648e7557da76d124c5807451dfeda8a2098821aef2b361d0c868ca006e87f51e8c64b23c7c35f810c154662ee90854b899489ff3c4b6f382fd9c7c1e0918a0e5beed12906d62ca26cf29e19979050f0b8b9a7a84e0416ae4d0463e482bcb434e8be6ebe2119e16152151f451b7882b1f1a0010d6340cc0ed56bfc200eb7ec21c5b012c3ad91af6d88bd430c5a5c650510b10bc8304060d4701e21b03526d4c86ef1f1b7e1b07e0d2dca8d06edbfb87e369c8313cf0cc9dcdc715bdae69f3bbd91cf1ad1dd976750cb592af6332323adac8ddaff2c1781c4d136541dd0c38e3c56b666f9eeb4c4b6c7c5236ec5d07e79ff7d397e6193f977c56c778d3256d1e334fe4138582828e95d43143c9b98b40cabe71242c4749119e86f27a1e5f9fe138d6ae5205dc1987720c980ee1a8e84c913b7c1d0069599ff406f07810e9a140de26014989fd315bc450231fb21693d7ce44d5e4e959176320170a2c7b9c73e3a6d5bdb521ac7159033250eab3020806d016d34e5c8542be213acdaafe1a53f932aaefe1851efbcb9c4e2fb8e1ddf26e55269dedb07076e8e3f1f3b96c35c033a2ba2279ae7ae79166862c8fd57bb436368924299b6d2b8fd7f45a53432e54e27abc421f0a32ac171c5b540b2fafc168084faed55d39ffe47a20139f8c04657b9ae1f3f07a66d60f7a709456a55fb4b45be6dbb502c10d972b769202bfaef32a31e898f73fea0c347b1d7523910c58b6de83e0ca63fea05802dbc0a75d8fb339093a2bbdd59cbe4cdb5d73f92e0048f9ae5d1dfde8dffd52b1d028886677a68bf45c094bb7e1c87e23745a97af5e96d3fff9fdd0b567ad51aaa5064c65aa9c3c2c9e8bda9d08a2861b32bb5231a212a7fd775eaecd2bb36bde8fbfb7eb69e04c6216bd7cbb4921f83dc1409eb4ef3977db5ad5259fe0463e52ce59303e3e84d716b7367e9ddfad04e6af93a8e423399b9283dd41908262a725f78928e69ca6db360eb921f7b06180a6e00a249b0611f6b4f31cdf746095c5030cf67e966e849f4e434b26a034b9f7b5a52b07e7cb02a2292b963f9559e7331175388e44208739066a1d95f8a861b05af7c03e0c471441c202dc38502f097e9017339801a76150144bfaa6c3b8f88bc0f66038a69e3c92582c03b8f9609bed5e0c4523f1348be8d6c28b7071b8b9a04195d468eecdf537ca6591ef49bbdc92a391845afe37117637b8da29881a9383da6f861b3dcd93fd78a9dc3d282b2f3146e365c6763183cde84614d455c91cfd1f69bda72edd8b872f7b81787b6a79195febf53c8c6ac501134bfbede9c1243f1e84b516370e32443e4843aea1b414f0a3b8bfcfb4be5ab2e5319883a2f32cd0c329b23133b96251193777cce51effc1c23bc278c8af8143267ca2a62b321b901eee7e6fa24a818ecc67cc7c645705df77ade626d57c738f8e29c5ef306a85a1e4d2c8202cc4166a2e3a1d7a805b1304dccc37755997fbef7a143e1acb3f64b0047cb20f5fc620321066fe56e7336d1a1b4864247d5fb6e8dc69b5e0948f0668928eb6631476b29f91873169b24e2484d926ded91c4456292f18ca48bf351753d7f3e589452aed120a1131ec6596e98e4490365996f5ac1c1348ca78cc256230f37934f3658d002f92df0ae141c31b1a275a8cd9a952f47e42fe3feb0d25ee1963ac9f239909a845352e458d403eb5679adfb6e4273005a107fd92b3f83d54c3d0a1d002c4454a215887221b48eeb5da394c92854cd10c4b4df9aa0f22990fb7506c263345512f3ea7885f055b381257c083cc168b27fe9fd0ca7a33568a18f594a40c243f80151af3feaad3c74d6294b11490b9d9b11b71768a6bd20cff43917ae0f9d704b3cf8a37dfb174641ed95ee9f07a54d1001517f6b24aa2bba5e773aac2b72ef5cecb2ff55d7a6785041c63fa18b65a8b34e477339d36fa7716ac772accd94271569f422aaf3e2994010dfaaf5ce500248ae8c92b4532550d68fb4c46f5cec008f4d230577e6daed0d55f6c0b00f17b996f84d583cd95395dc97507c84664a36ba9c0d385d2df1be7979a45e45601c37764dd29376667b1e25098e6286c04d6c304bcbbaf657628c671f47bedd70caf663aa7e82207f177d75bd722b1464c18b60113621e530c02ee5f043d0e57645ec04d38646d50ef927ce4103e4c41b54d8e009f273c5b0482ccf733fbfd74b60bd9260727f5e903b1c5126939e172e764076d95a5127cf51924b3a8a0c8f0546f18e5eefe1c88663e9aa4273a2f0a2f09fbe4b4b6a3f5a3714a5325e502f326dab7408533a43ff053f757db9a616a82709767cb77b03d61f609f5f0fb429924d3effb507a7d098ed1b7cbbdbdad466d323557e58e1022314a44a69c0d8112d1b7e746396f8b1ddc0a99f17c69725b8a05d95dd374054523dbd909c86b3c9d8cba6aa986b3b15e3d227b6ef4428600f39f15aacd7f90958074dab1bdabfee2dfc8105cc27397f52130b64e36b4c9209b845b534852f39455ad9f76c2883b2e4ddb51495d8c9e6d0ab150e787cc775bb54b8c07edb6fb6a34691c128800349261dd22ef542e82110605bccb05810a75927cf20c53f44024980134c9eee60a772bd6b2b4fa28bd986f83f3fec967415665d348b32895cebbe59a176beba868d03c2278f88af4e0c67e78f22e3d1de81ff167f04901e847627b5519e1bb91fb8128a13171153cd5d4ab58fc61db99cde288743ab20b4dbb4fc9ec2339076d8eb69b69ee457e2295310aa094c656b259b02c175d9700a5a8787b2d2cadaa7d8ee6a4df3a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
