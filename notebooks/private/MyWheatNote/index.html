<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2f48f4fb1b66ce0e170dbca19ab0cbfd2957a6cba228e408413205fa1da8cab5b52f7e430b1485e1b66e85a6765cf94b2736424e4c711968ee1ccb0ff2b5de8e36ca45b6624da2ad6238d98ecdf6233c0b88e90a93b9412e7016c6ea98d668ff644e90aacbfd77f9429889fec9aaf9e61c7fe3604a86383c6dd3ebb93c4c7133394d42225979d601fcf9d670f1737000b898154fb003296778496ed08a4d62879e6ac246308f742971b0359091d019dbe4be4ca649f3e94a7ca435b83ef3760450e57df1e8d3e20f98ab498ad9dbcb6756dae656ccb66c9a2ba33c5152a220531a0f8a01a05e48d608605332b85bb7bf86373f90f74e698b78aa0edfc5b841cd8d69589deab3988a0bcf02d7e88c49c0becd0e29213e54c27c162879cb0ad6d2c15d7d4029b13c3baa3357bbf3658c45a29739326193385a6af25d19eeb0520f4e189d3ec9032964e77a2da85854e1b4011481a30b6af8429b1db0bfbf05d368278f42b43cc7a137133ac90eaa1065f5ab3e2d3071f8954ba5125992f574b1e9b3435288faa5dd72ab77e690bbfbba5dab96ee1e3bf56abe2f292c32c4454c939c0c94f52c547705f92b36b22f7d34e5c1768ee1b0bef117f75e9f7e00efbfde0bdf0f89237f59e3ade1e29e8622cd7c98bbfa67ca16b278fe5637c11c828d6796e8a2394e3d9ed1f572d2906484a31020e7717316aa9fb4f3a2b31012054356c002f712a63e50fbd1d3b3fb5fd9f81646f99261449c6c84b1bfbab630827350834d453ed9275d85c4ad91a58ec176f8d028af1c7589da7b85d1caf6dd6d071a20fa6f05358304e9b270312fe55b2ea1d566e5333b1bc3e746b2d2a913820ec20ad215f93618d07fa030e7ab1c4424d4feff7296a96fd16c4b3bd2a7f80a5ff3005dba58a1d60590114eeca90d416c21da7d44e5ea0a19a88948523bcc2eba0b9077d116e1ed834d17a0e79b139819dd95bc0d76771141ac5edf5e6e9e558bb378e52fd8de97e4b37127aaadd28dcf05f729b5ace69a21426b062df9ef926da80f925296e67a452b09bc1c7c7cea1fb6d2d0bfc868527622e719a21a6a7d1f8ba1c44d13974517a56462fc1b4cda29f7b3e99a45f6c67e4a991ff937acf62e6b2623fbe40b05a96e60a8fa4354513312d86d366d1c334fb01627d8fb098d5a1f0c1960445fbebae8c5c8d7dfc9ed95e5c1fc74e00aa9dbedd174db3436f9a30a4bb67ae7929ac98b13038f9297ee4ec46d7aaf12edb9a574472e57be3ec16f8d258c65155d5b230f568249c7279f25189249f3ba547db860de0cea8e231bffc04828ab6a1e0fac1a074959645029c8cae273aac868bb1155158c583c1aaebdaf1a1f1d81c228796c2299c4e6b67c32da9aadc9175cd5844b05a2d3543cd524cb0a158a25bf36a8d5f8559ba2f6eccc4e162fc2370ebbb1124abb75306f8814f485135fc9e359cec23940796dd7e1f481b06647a70df89ee4effbc169460aec2a2dff001ddc8c00d3d0679e50ca817222b3c393df1fa1ea55615e3a4ec518f4cd2566eab4fbaee5337b82a225bf159246a2a1fa0802c883cfa0b9b07755c568ef918f78fa01da42d23deca458ff65fb1348790365262d8215c82631ef3dff0b2a602b2b33a7ecad456f70ff2fca866965278c72e9198fba0dad032060c313efbc40a62fcdfd03dc89885f4e320ff95c9e465ccfcde997b62a943e16dfb7992e5016d510f6f1e7837ec32ec3a8de05417933a5807f4c37ce0c119cb03ae983e57f62a6f942224314b4e1fbfdab3c9c73c696bb86377e2e656aa69113fcf471cb6eeebfe46dbc65b6f47c492f0afd04e18d8cb97325b21a020c2649a226dc0f917b56128b77b737dd57a8129eba04c5a4efbe64e2550ec9f32d18f7bc58c8e087b62322b1be7e9310f04133213a90f75853cd9c2c35e27b212d5318c057d04b8bd3aa387691ea2060586f2cd6f221b31f8fbf6269eb38b29931d5926f53f4adeab9f169a477812ea33495c397998baea6bfe4dee2c3664fd9fcfccc4621bdeebd836bb2cc10e224659ea3e7ee7990dff1a76e9c8b1784cf391f695f2a8c94621064bef0f1e41b5f449aea31131d2a579e4ca4ae5d0e0117d9b8e824556b36cde9bb38f4c308c0e409e08b32001ad9908ae46497df5887c7210b1630daf7e63dea40c861c1513726b1a77b1618931c66de3e5dc0e28111d12b52cb1d6d8889b7bfbce16db88765485d6bda92c77260855dfeae738e4f4e836f4865bca7b545feda57ea356dbf9af56e4bc6f402e940d04b7844e2e4c9e90e1876e9b440e416e7a2f74b33b483a0d5912ee845915b1127717038b29665d60c7e166b8e83f684ba26c88fa1dbc2539c8867d667358a32bb166c0c559c64bb779cc478414c1758b484a34889215132497526bfd40d0be66dc6bb7747a0e499ca288cb03588556e2ed6dfa0307d34581ed36beac8716b8401d79d479d1612855218ea1ca6d388f97cf0469856f1a3c388ddf1c0535ee026ae04e571f3f6527073caf2765534f0ffb1deb8192e384fbdfea7cd01f4c56ff887cb41ccab8ad02cf2b4af54021e5a6c88e51bbc422be0ed11e297449f38cc18ef2694129f61268b1618aafb110240fd07d82df13b18f0e8e6a13f533aa56e7f134f6871e96cac6826a1d10d9f7a9d11f33c40f2568bf635047c936ea0284a19b284d1dc9d3f82a4532235f5ce30dce442c0e3b2b66d50888a40309061acebf51106eed0aee96520282a72f0acd62f40896647157bd3be64509b4fd32ca7aedd4077937170be749ec389a468c5920f1154bb1210925c0a895b32b553061d5c4b3b83035093cd11f94a9e240ce99974fb361c108d53ffaa7b16ea3385801dd428bbb9f1cd255d3ee454f90c9656fc2af7dfcbb1ed1c96dc6f8df9756f4824b568735864fedd9c0726ff62a8567f5609cfe3fadf7d6855c19dd5ffa6eb7e270068cb9ad5a23301fd5d93d957b68ba40a7fd93601e935951d77bf8805920b627984466298b44a2beafa1c91510aa9760b95e265950c7887871bd1b26d85911534e073f8a8d8d87f5b55f32537f64f4ca2bf1801b9b8710b22c42282b0bf0eebddf340f8718e4119991ef1859f373bc3680e7eb53156e8b41439fb4c5a353d4300cebdc2d63ceaaffeff61038acb6e196a74e8ac2497f66d4faeeeb442b2bb81a077efefa6e6801831db5ae16771a32f6ac8bdb697adb017def1f559f45f1a0efaacfbecfe4888ea35acdb133aa596d4fcd821b38bd574161d182e8c8caa1a3a938ddd4b4a94bea0f3aa2116685ce0c75a4e21642914c3fa85f195f1f9bdf6b35236bf3958fb19ace93be048a91534bbfffc5c1938c9e01b962ee218110d87f0e6219f9440569900af388697c2121d19b5ad8e63629e7f38d93cbdd426113497a1d6f6b88e24167f26c28dc941cd365ce527cb51188c4b220a1f2128d095b01ed5c3b9ec5a69cdd96876739119a0e28595a44e634c88395833819ca34092a396168728443546e07ed8bbdfa65e793f257a5cef917f117107ec27c7f6c9ba4f3e1cccb14c829cef867ed8a9fc0a79ea6b6277f219e31780515c3ddebd46c99291885615c05ae098d11ff18f00fd353d5f1ff90e6ffa6d8198523e669008f8fc619b0b2705b25e1ef57db647394779a9b92e1042b544f83b1358d18cdb2fb29046cc6f0220f9e0acde4b5170a85b2367e9743788e616d6cc16803ea26b32db0cf3f46931cd96a07a0cec1f5736b6bed494bb0eb2b7e0efdebcc92e936b00cc99ce503df9cdb827ecb0268b61d33ddc391815d800addaf1055527d9c7ef774993b68242b25d7ec5a2cc2c7b48c2029458d2fb3e55e381df906653c9886c6785c3f83ff1b3412386978080d903bd34b3aec6577a25d5cf149dcfd2d41e0dc28e7c1fb2314cc3f2deaeeae3207e5c6da76d1bc84e55bfb99996543c7fd35c4bf106fbb249558bbfcbfc93b1a45e2ec3387a93f465cbc8cb8f198d8a1fa6a85e3faf47e4d1c28e814b8824fe0003ab2ce3e4998ac0d2ff216f0c6b8fbac67f98ff6569173062f4b2282cb8b8d6680545a04695eeae0469dc11e9371aaa0810fa0afacad3520d04ce812cb240cb11a65a749079860dab98648753539e9096358cd329dc17ea2e11f31d80527e589b7a85d0cea450643730fcc8d42ce705f11856a115d54a7bcc83993b0c4dd0d8e0adac4056c1329a6c0464e1fb06980f3a6bc73910ab69dac01639f9e3c4a99b6ac6c2df155b6ea1f174b161589d8b582b8f93850e5caf2d3b0bd3edaf28798d11e15d326e42d989a42bd5d9a6346c694ed7c1e09a87eadc4f1688043c74efa8ef7284e64589a69373131488d12a81acc0a5c0428bc531d6a93c1ba655b26c996d96e74a40946442df8091582d6147bac0627367c495c4ae8fbbb1f3bb7e4dd2df68e6f7b68aa2f5e409a2f151784b730d7f8b82f4e1927d51b760604b5e8bd9e7ca2b1fcee9ebb4f1dc381d7d7c9d556f3bee9d60ea8143856be6b2d8e7f1e7e918822d5ccb80603ad4027c53e474122e23cbc4b45dcfaebd6837ec3a4829c8c6722bd50f78ba8b0e41e0427c5479bd2270aa4469097b97cb6569f21ae289bb667f337229e29523684cdf92a7e79a093a020ba285e6982abb946b97d7c33177c009c50dc72e4f3f82107f798d95cf5a252f38f166beed3b9aabeeb2ff97faec7af82bed99422f2a8f0ff1506f8234affbe524ea86b0fe5b823c0cf6920bff2877e0af0b7a482e38cff90a7831de5677655402598c9f9fd7e7de20c91d7ba7e38372d200ae736d26f81bfbeda7172eea21b76e0022404ebdac7b038807699cf38e7525d05c76a9e65b7a1b1c35ad28606bfdc23905980b11a505bc9dab6206a99653a38fb765d354a0c5dcc7f7ec09a8258c28be30a44d23836e58e0f970ce8df30f3930e3a3679fa4d6c0139065beeb75d1f24926fa773cb31e1167464b6d44312d15bb00cc991d1766f020030db4d2a5be982043ebcd76ad59381b06d60351e5f503aded3162d004aadb6e48e813ac1e7fa2398cf04c3b98bfba045f38a02b4947f37e1c374cb0d6949a6ca374cc20c745e450ce2c061e55ee5eec54225c3df95fce638f44b3d11c7ad1ef1d317fbd8d278bee200de2ba72a0d6ef6ed1c912f34cd331493f55b785b466afa0ccec089ab02dc28fa8185093865112a5b2d328f6b3242de5238b614a3ec13419d54e6818b57685bfcfadd1e1d59f4cb091c69135a149b3ba22b49585f5ce5e8b84db98589cf1e5f2dc01e2644ae29b86db0835ab34f01cf52470eee1ea462f6655ee38052ee58dd9b6c1ad2f4fa7804675f2a603b12455bba2a2fd681a7823caf0af383b437716e66b5f4a5996857504e9a508c38aa1a905f888bfe0cb3519df4816834e0bdae9405ab0a4ceedee902be1325f6cbbf26d391365ae31c682aa48d7d8414f7dccedb182aee110c749d1387fcf96be489eee25d856cd4a234e564c44c896f9055f1fea27eb4d8de1c428390caef6e653b8bd547b7b1bf3384de901b8161dbf4d6d2f1f509dd489499d97cb73abf80a9d73f73332d55fc4ab11526c1ff2ca4485097f01f13a3009bd0b762eccdea544f0550c29d0dc46a3566add4cb89a279398438439e23d60e31610f7c6202ec1ddf25b1991d12cb043f03276e86f1cf0385aaaf8438a2b9a42822f8d1af4558227fd16e33b00376ef88326b6b5a92fd43a55c3add737c8ecb2f852b235992df49a36554a009c66909222d251920bb7175e48d849ca7fdb40e1efe5da2dde0f4753932007f4f46fd7157817b18fb5e0002187486e0faacc8e8f2788e81da4c1f721f1de1ac7f04199a4c99b61af6892e4256511bfced2a17fec3ee028ae5e1b1d5ac0d25b6684f1f3deba76465ae13f8ec5baf6c3bcd474c392cd5a8f43ea2bf3c5f69b8bc50dd2d60456c197ae35de583948de6df724e8c48a5b4980d36559f43f93a229d25442b0be0fcb4e43c51adff809b46a3da175616d046840ba70c764efed7bdbd2d26046e791b553d7de8c09be0d4cb6e4bd4515323c2eb696b52d94c4f48ef3796ab076feabbf3d42395e3a53b5330aeaa9deed5adefb7b3985878e2286a3e0db8c999cba857ff98495f51c5ff48d23b9433008a4c5d1fb3fcdb2cecc8e24813c822c8e307697987019c95652813d519392e40bbc43b76fef83fb40dad8d8df72871e80dd231cf3dd7912ecfb6d54d00ad9bb63da6b18cbfc9d604a815018a730130cb83d256a8f7181f9d49c3a76a48cd161e2f52615456ae9f584fda3b53247bcb8e7ad5396a80f97a3603b77fd149aa45c2e262a3231f4d50e5a2b7db574349a93aaa9fa69e0cd9e2b7b3adb2c15e60181d18008c2b282733ba9927c394951e728010ff3692afc45e7da9c912e9956f6f5173b5830512f0f1ccee5a2b5eb9e37a6ea1df60bafffdaf65b2aa9dcbf07e3534af10968099b4fcc052a6ceb2869cb9b303d1f2433e84ac23dc9047d5e37aa82a18fecbdb220ef9999cec89b13040a9067f9d5757aae6b316f62e6069efe0beaeb175d10c36da422bee5b1c21800da3cfbb0161f63a4f222fb4455af940ad65d334d92c9c2b4f7124e5760773dee2d44cc2a0b072a127fc931318b6ef79b307c46c63068112d641a491c4244fe1e8e6d642383f606a8ec98187668cb9f60a7263b17074f3868d8be43300134c5251ec8daa502b291878fcf15cf3e3d79bbdb94e996683af58f30ed7dec67c904b29608f09425770fa4e0748d91f1e4716d385c297e7d803d7f22639482b16c087d0cb49d2df2c48294920e49613a2f569d15fc6a8ccdbffce64301af67987e4bdb97e1ba0a4f0d04b44c45da80edd268299f05e73669a0c1da9cd97b5a28e754add4a59b636a9ceff460514f23bcc018f2367321aa99f17e94eefd34f01721ec6c4d3c4dee66a5f39f3c77e6f5b471d4aba08fecad40eadf5534178cb1757adea48f856591b69c774fa90fd31bd7b033201d496d13b756e547d2bee583824aedf8ad08a3c5c1620c2cb48a180f5677d6f6959460ebc73e4d590dfe752da2a20fd38211340fd300e6389b61745eccf8d012158920a11baff91a10cf23d4daf53f437f6d1cd722ac053a2bbcc391b0f47bd5fc7debf98bb49da31ee2384b754d7ad1ae4256aea831b98e6ab093383ad88e696080d694510536b724984e80cee07063b0667a8598529e7450dc37ec561eb3476ca4c5739d49811b31203220671e483f8992e8f1b747cd4a05033680c8c3c4a204e0063ba97a282109570e33587a656523ab0a4f0e1c515e6d58a08c0795cef945137e9c7fb81544c0feebc49d9085c030b5ffa654bdcf52d24cebc55cce527ac3bea6390cbe7db851a6eb4dbd39294f7f50b6ca1d786db4f8979da7d07c2c28240f5730bdd0fa5c96ab112c3c2f76bedd4e40d700c67b137a33f392db1d2ebd6919f1233a0a9a9087dc588264f3ec1277966431ef5a69fd14def50746a46a99f01c9543669bc57fd86188da8c88bc1549863c9c30e767140a5ad859cfb66542215ab2df1bb745ecf168d547a07f903684a63f14cde5b45d012804c64e8f8ae994f0571987b0d7e8b35d5268d06967189025e37a9341cb8815df942e0f046b6482f643f573e9a0fae66c8a4837e8f3ced2041635abef466ba3e513249500770bca23d61db9e90dbdaa8ff40477d333792b3045c31f870479dc492a27ec27383afbf5780e2e123bd9afaf7ced0acfa015095b57bae486fd2503163c84e7c158a80fa26c9929eacd3ee3bc7ca31b1dc7a65ea724b2e324e20f53555eb8c6cffd86fa6dc46e497a949a1403d2571bf5a5ea9addb75805c5f05198fb359812214de01cf6dcba4b2017b5c6017f88c636f4037d3067c7f1e0702f6dbdcfa62709dd9fbecb65f8f143c950d7f9dd557a58a8c929654ef666c65fa8d668fb92b8960ea634132e8562d1784868e6209b069b4e623c73ee31d83de7ac780b37cdf031811771a2c48effd3be61ed322e8276c5e8cce7c7e60eb06c16d2f2468250f8e175dc9b2bf41dfec547a1263bca25fd6e74b714ced011f3c9de91046cb4a068790d11c7f74e5e98a2d4c4a1bd16b59cb6e4d87202163f55ed40136e2f069098d5fdc30750bf3bf457671ea4bc0f4c910055a2200e8eb97ed2b5a2df07b5bfd05c827818c96fb484a8c9237195058a1e0b71360ae5fe964a94fa2d221a7da195e3356b5df4e649c56dcc8426a6b6383226b2a6eb9c1acd8f12349b646a2eb2d77811a72319a9df746bc68d6d72af95da13ee913db7024ea2c0abd5211c9440f4bc64c23285d5f6c35cdad3de4798e61995ae6ddd3c65fd818a5e768c2129f691140b5528a5d341b981f66795ee2419b3d97fa81aa4287af3907fd700a0ed1758fc97a8b3456937de76702d8d5b397f5b3c05bfcd6a8fc4e61152689f94a7569e1cc11502ba414dca4c2d2a8a2d0a5e9c51c28a7a6f428ec753aa42ed4b80f9a550e500b77024816d6dd7779112475ad0774ded95566805a2900e0c66eca8574a3530f8529d65f8727001da58163af0791092680673d6a5adf0a4407824b3c5d3a143a032bd65f080d55816b4035c2ae3f0d0da707a8ac91a3c60e61f5135e12fa38a7c632f2992a13e5e5c077dbbb092c8ca56136e25975e3292f03bf552116a800fd4bead93e657044cd4bf14c95800ef97c4183a4f0f61fc8c0b78dff63a7c76ce13d1c66067c81a6fb2cc8f675fd3610cc9483001de813654fed342e9b602d41f9bb164e3456bbf34f2d6f7dc49c66538d004082dfb46b2ae5071594c17d51105dfd05184254ee59538baf3611c1af97f9913d3a71a46ab872c9d74f8607a327caac83996c100e99b9127a001f14fd934a7c52f65b3710b1aaae8c20349c82fd9e7627ef950b841cbe3df984a13d1d00b07b804b6cadf8c15477d3b13d688659844e68ece82c112d5124763dc03ffd07d44f26e1faf37a9cc1599429de6086a2e397df2e88989cc3b93034b5ee82fe46adea54f935cf25188c4f507546665fc83057fd4c89b80c2319dffce3d237c91e7614537097abe751b97e03a18fcc4514c793dae4290bda2bf45cccfcf79c36ec9a6ec23f3456a3c315bd74cea5b4ce7b0f29f5934ff041d51fd3f09c13cfde9ee9165590708ab8a0586aa3c83e5a21d4ca4b10d9c02ab6629e61a6a8bc5541ccb167c2a452c19ee6bd2567b38daf0aeb47abd471df1f4f44d8e45f63dd2476db39a4cd521b4dd149685ef00c679b4f89d373e1d9fc55ab5b4339fe1583beb3ed0533b1d452178fadb0709aa8dbd8e760bc7cc29953e16cfbadac7e7af6b00a9afe91ab34cae5f8e58d357e00e3be11a23e038f0f4d489ac684d7ce8871110dcc6e814aa97fec92e42d598471350d33842a669e94d2fbc1058ec21093314bb9012394a57e9261bef3c39567a26d45709436a152ceff78092a15d1c0833bc61345cd0148a235bb98ebd50ff54bfffb99e89a52b88877d644b8ef98e94c612bccf7a5e9469a8b0fb860616b2c86972465830a9b90d2088c6489830684725f9780d1ee560f568edd945ef791c774da1d519630e21972f2b088a347de7ba7982949afc1e00716055ad4e1b2c5d546b47a7aa3d871a3fdad1a03ecc7b7d87ff189b549c12e0de19009adaf672172626a2becf80c70c80662f63100b9e90ad78d36f009a430bc1cea363d308465d6e8983d65095f2deb39a8ae1fa54514b4f64abc168171807c34f6f56680dc847adabefbef46c42516c3d44810e9aec0bd02b8d9020c5a93612444a6438d65baa1b731f757377625db5d718c27d61bb8e5c1f73d4e898965bf6a894899bbb947b6d23f30cf46d960b7c49896fbb2f7a5ed40858c66890d8793dc579054385320a5668d30509c3de070b2954f493d6866de8b8d7034973e040928bc681f495d839da915ffad6cf420d38ee525c5199c0d2239454900bee118e9f919abe61df0be53ae794dc28ec88522489011fbb3101e973e884e210f23e287fdf9969e075df79d2ba4a3f65d38e4fc6062d3652513ca32cdadc46b9a5704681fe916bbf95dc88439fe1f245455ab54dd35c0620dbec61bf9c80bf9886d1dcae510fcbe3e49d48410eff168b142bdbb17ee42463b8fbb217e8e567d124bff85801d228f6c15402d3f97c7d33db55a19fc26874e11b843ff77f62dae78c777a1ea3757da285b86387858f68ecf289cded65f6709587580831fd1d8e1c8e8d0cf3035ed84ab0d53099056e7d5574b92a360e5d2dd57abfb082badfbf9faf4d50e4d9b56987d58dce74514322428bfe8bb2f721956a6171938b334194ab8520d3cd233a04b7987c1a13735594d3b52df8d00df50b8098812b218b647621ef260886695f27c894e1ee478f9d7e3a920ff6ccd517649d2c4ce22282284c011395b5b987b196b48b2c6c672668134340fc2b0fa083d0064c49b026829da7c6a18359dea3d87e4ea54653e7835348215d15de2ab876e7148a62c73b0dcedf95e60631530fd18e76dec782609d4fbaefaff5b17e9ffef77b99271b972585a1f336cf0ea64dc4ecd89824b09ae01e2e73178cab13ce18c501f22334931ceecdf00aad8baa4ae8b0258e4ad66e3aafa3b1d3767545b3a5fd5239f0228d3453f169f26514f2f76a8946be7f7ac01146b916b4128b8329d0afc74ba6a288d3f3c702f4f5e170da321f649034d91d8e1d6370f91824b0b87415b2621baba8d4c7214c56c4495332c490fc5efd43e0d766e49d9ab1f173311fba0d3dc2e2aeec5c9a85f4dfffb283e5c072b302e6021057b3ee87d7aa04ff97f6c59a36c36b9c6e35e33268b43f6ad5f9e8c97cdae365f7fb0b9b743c0b4a841ae8deab77c1ebf0f6b67d947e1f2983cb3ae42a59ff77ab7e78d7e45c214628922eae58de449cf628e97f06e289e2dc802985f23253ff7fe65ae835de99089949c00cf5b5d5214d90ac43c31b4df379657747068d7fca0e48eb9044032d0d5085ac97b2bda7f9f58b8312f701e2c11598e6f89eb8905cffbaf2c503f1ef47a3b0875d36d80771eb2da82aded8bbc5ab1eaed0e835bfb0e24206dba5eafeb7890f24cbd918f60f59893ea997ff011b27ebadc874ae4862e8c1d342c2498e36b8258e606a491bb1d60c1827a0cb95f4df5638817ef53770be083693a107e1777d1ba6f8bb5f132b6eb2c6ab3e2513f299b255c4803d737a256085a46000fed5ed675cd3dc3a5c3f7386e4c12d2b5818341db27da2cf87bdc0defa4cf96e761dddb6f17e4394c8c49d8ae4d57a3dd6dd0f8b08efed0c4014d3852e3ef77d0893176205238e0a791b7b725ab11fb9ec29858137add49646835c9d041ccf5bbc27a0eb992a7cd24887c074aa572d75c12618cf5c144e07b2e4200272aaf4938ee2f047e40fbd4659fa7aa89a3b1762831f03e4383d7eb3d5acb1cbd27bb4df994d97fccc370e68023a701d318662c725a2464699ef37bb0c09c855a14ca4b1f1fb75dc50707ec71ed9c897e4e2ec5c2af1d6c785e63d5de84946bc15c22a94f40def802a4c0b74ed22ed4a07f4772de6c25f8c959c5c871ba04888a4065ffc5d6560ca0428893e72a75ed88ab58a43e5fede4cc210729722c188f43e20d352b732003d2bcf739208286ca467b61a4af098357f726b93e91e97114d1f7d4eaf1668e492698579e2df872dfc628992598cb41b1a3563137a657cc503d70e2e79f475793f6a23d1faecf30c4ea0d0df90f6ba326e81931c7086962b93dfd63faf8b225adcb094a955d873dc2cdab8d59d6a43bba5e63cf19c9e2bead349040716bb53110ed69dfa2784b3ab873149aa274a86f5d381a37d1953fca476610cef7852810fbdb2275103a9dc62cdcd3b7fc61bf701b3351fb22b65669a0d39f671ee6f6cabeca5eca2929981ede72d102af42bd70dc7536dd3a30078118e7a46e5fb63b5473b7956034f6d094cf1b0e825ab2b4b603dae452ee27b3432f4ef187810a48bbb71aeee5f473d64d3d3945e8c24b1ba84fc53580d5d075e940756674ff6b66076434f9165445aff5face813b55ed7ffb5163feac6505a5edd04e31dca330d7d265864be8e822bc8fe54a0315d30e2e1e4ca524426fc78a105e02b84231e426c5904a9a8b05e4ae8526120c3dc7dde97fc4e5227207ccbdea155c268f00ad86cda998a58bdd3ac2fc5cd51567e54c5011c8471688635dbc717663bd0680d799262275e62bdb335d185ef4f24bb33d7f836cf93d41bdc0012459c3d6f3dee21154ec9271039ef4833c7829e4b0895bc9ca556c956483db9ae6f1692da061fa0f43800e970fd03178243ebc36fe208f8e16624f1346cc35eea4c3c1764158bd119311f668f9d6f27e8f2d83fbb1e89a723a160b57ca2f533ff1789bced36932a36ecf3d73afe5c01127ecc7cd78dc6c4f5be37314efc09263170dc962a3ddac770f70b4b9c2120581b7ed9a0695f01608906e2c4ea087ed9bc5fa7dc52e65e2d43013014218bf047e585c1d94eeaf3b60349d0d0e7a44d8c57a732c4a33e9798c818971f521e7d75eeff1893c61816aeb003c1f8b4c4eedcad087b469e9547b4d473f4897ee490f28434d9804ab596e727facc1e2d0c486ddebd4954b23d38f54a6be3eba865cde6f548110e67e4747211582bee54827b64d6bfc6dba2775b518ca5974620e5eab8fa68950953a211654dd13e583116694ad09a1da1d330f420a68a638b1d78d13e69d5c0e18549eb960d326b05b711738b237e40fe634b95b82c76de3d68772e9e2396fc06dd217ab012b2022c92efe8b18fe7ccb3aeaf0fc8e6b736903f50625a4ba77e55a176bdb2319f01f51be16bab3f370a7e6ee1bfa5d8731504f6628cecb1fca2233fa9f181952e18ddd954a2c077747f3c945916a1f3cfc96a5c9cc79ae1669e818f2a21a1456ef6e9a09282b52050753c5465c64a54f957c24c0ec520917fc8b17fa165b818f2e5b4d3c1a064365b57a51641f751785ffd927a13eef126968354e4b0412478acbb95e400e172abcbd40c9142e0de869c97c4fda558ed6f4856563532b3aab220cf50223b891dc757deee4234fbc901c36dc89ec9329492bc7e874bcac3544f00a2d384bc03b127f51ca038292acd7c4173dfba7e259932d6277eef15c499c5cf7cb02ff0ab893b630a6b9a0e35072bd6b77f1edc367adba172986e3b5034fb5caaf6b17c49247059c608a59f3a66712a80abd9a503f4734bfe9b88f00378f99d5ecd864018acf5061e3203ebe2673e05c58e76c2f9a0be7902122b8049e1a065d9bc996e2e96f61366df28fbc07df4468981060572279d0a5518edf91a91bda351ed923616a3541936e1a301f9d6970caac9f00329566d07a7746ef3d51df4d3ee2764106e5ebf8c58bb72a9004f60d6afdda082ad68ceb95831ede1248af1e66a1e2bfd16cfc637da601d9955e3659391431bb995fc42738d7c3a55c72f3ede236314e42b92aaadc678aac9d67201d6196682becf047c2b8845536131486d028b0c9476dc6a2198906771b60e55a638b3f19a4ac578eb21b82f6f44467b0f230551161778ab5226aae5f60c7857f322ce3c4dab3e8e966b0b573c033de53914e6355087bccb6457b6f221b9e7cd050afc0af7ee4dddd202a9f4e609927bf3f27743e8625289bf39d2ace6de501397e2481e5547dd05d4534197ab5523aa471c461bff5cb46bf693701aac052fea4d719ceb3dcbce1434969abb47e9b1ccb2af147b4348ebec1dc3b28fbcae77f74092a6a85a0cd2cab6b9ff3626662dcad5b8f57a0e47c87f4b9d94ae7e86549b468dc363f10ef581cfcf3e04a6c5c8ad8f86e849a9c234a0b4d00f01569685d5838261fe2f1c94bb0116dda5274e5cff11b28443b40df7353c0d15dd57fbf4c2811da63c8a3891405f7937843c42a4bd0f78592a6a57d4f99e0e226476623593bfe52f531f79c39f195c0757bc4080132d791d8c50e9027f3c41b4493d43298143b12261dd9f28a33bca0ca2f604e1cf8a6783f9ed7276dbb206ad807348a9e3adeae100b63c9ab51ed341ea26f0f7a1811091518aed8ffdd133fad861e47cf3112c7307ff54012f6bef4ae9a8fc2dfea470df55a98fcfec03757be72d91862c314c3c223b11d9bdd300162b2463e7c2f1ad7b19490ed8d98b8d61fe13804d4537cd3358952b488f72b6a5a52678f2c96b85a64f150b3c64d5ba6bdbd82478ba8d067048519bdffef6653ec7c1cf28805c875ac508ff7e38b56fc8210cdbbf72d6a999f4855e25689b98a2c6723477340bcc61be9360d27862023b2ce3d6aa355e2d531e72eb7261fd200b473f3e33f6ea2c5d6f9d3a565748321fc854a1033f2e91873883d2e6fe781d6c7e308f6c9248e2398da1dacbd07f818ffdaab92516572f0c02cfccd19f2db77e5cb754c943482f1db2b2e4d4f566f2dbb437c545eff9ed8b546e44764ae6bbaa66e72b8ca2b24450c119b881ab04862eac275a0ed68c147a86c2da323d54ea7d44339444ce4b75e619621002986b12165acf7dc161bafa2ba65d07d230c19831863addac37e051be2fbfc206a60f2feff6ae2031ab7699ec702557407d21b9af331f5adc6413a27132f5dc084735f276831c87521b67fa61a2ed155138c04125e81e4a33f38111f7dae2f8719d67ee246f21f82731f76580432598062aed1302be5f5f6f7f4f35b3a4ad7f43ded90e1c1b1195a5090123f8cb593967d4926bf349ec2426185e3f9ccbeb48c3060ce76c877fb1fb868a18915810aab8f9fc1f1cc7d4cf952933616fd4fdbff1a0579c3d0a6e4603d82c3b4b6f72285a988e9bb9e6b02ab59fdc2497a9ed169050a60de21b91ea7952506b1a794c5993d4d4758e4f1196985a025fab714eb1232f56985b30395c837a038e14ea8e332312c1d2d64d848b684c3cd17462ddf871d71b64e37d6e1b5e8681e3377ee80b148f959fed27098946ab7d2415d1e5dec1717ac2dc75bf571988ffe9296f97786471e6da2dc7d16e35419f840cce5a42fefaac09fdfd650a974c632e74349da03f0aac2f33c6205d22851a4597378516b703b0808252040e8ed477c0f9942e134fc56cf52ca6ceb888f17c875adfae8f6717d3eb7ceed38051a1a5676c096ac24e09474b6073af7953558e401bec33ca59a986d85d0adc4739caa28108c33936850f9475670ed1f1270b144b072322d8517bb1e50d985a84a87f496593868589f5b645d6c86b62f882baa9516ac7aef0787e07411914596ffa5951bad06e5c45f780ece28c49265d1f8f4564c99290941f935b062071f9086d2cab98fa9eec6eb9cfdecfd522892d8c0038a79cd4f65e15bd207d2df6ca99ada73839557109dcd48c23e332363c17be44daada0902603489fb9f471aced7350e64fd6bf77197d65dd4489143702746f7c14491aa4cdc144734852cb7ceb2f985e5b2d8a0d09a80f86421295fb6f7014a73583cd6bf80a726a422b116cbc590addb88af83ecfcbc3a323af34e39bbe87c42b2fd622c9b96461a5c88bd0db194aac37a492630c79d07e4d62d63df84b20db10391a0f162acf32f57430bc7b1f4d54a223968b4747b4ab91aec0bf603d271017aea4cf02254e0a06b299162001923d6d2513564b45fc1ba8144d7cbd96db56c5a25bf9890a63559cab7de6c6925d2bb615e81afede6a56f60628a8d3f464980e1ceafb6e18cd69d7e97ecf0a00f8abebdfd2f83e811eb55363f36ed676a717e021ba066b38e3f98af5f235b433ed635a61d9d6c14dfcaeb1ba4ea7b18dae14b412fdfaec3a39245b0af573f43b459aabb3d62fbe4e13bda90472e340c166498678118d35dccbe7088047bce356908ac44ddde5e400f026fabf5de2a331f38c14dc0a212b1e6ad317ec46571b157934500d16de44552815fd9bed1d73a5c6ad5712b3c0cd7d7b32b0d6a6d5f129fb1884b795fbfd7b7845a307c674000e1553867d34be559193c8d6bdb264952fbfa6fdd72980dd63cd46d9570a4f043cf6128856ba036b41908f5c750fe4d0f6cf31b38f19e0c6ceb81204bcebc58d555e935422aae455dd06fe76abca4f26d02fe02f97b5d3340b84a6a9b966873ff976dc9f11657785618f4e16b9a94d02e756072a3fc40dd09f3ba98197088214dc2b1743dbbee67b7f0541900b5dcb8adab82550b6481047773753f767adfe0cb7b17732ed0df8abc184feb24f6c1d69fbf310eb1d50a3aa9b4c4361f2ca3ebddd004c77716f3216f69eadab91a6c868593ac9bd29ed1b5498c303335e2372c5385f84fa17a4fb4357020fb1674dd0807649e01442648820b5818de17063d293fa42a073fec498409408704ff65018fa5b9ed00dba3c77d55a402b8e99c70b982d6cf33e83af42546b7bc2f76b95015b405e5ed249abfa8363b9fe7c13c9924e74ba8acc12e817fd2c53a4e0af09e9dd8b1d94498a428a7b102828e142d924175c9128ff140e0b75782be203178527c2f6c6250cf04aa1cf7842453bd7f5c1d6c4eeeea0daeba529272a2043453fb83bdef4f642a043ff48ad4a9ccfbf1a2143607d7030eafa597881c22ecac1adf30de3b41b564feeb1bbd88f58f9f523131404b862bcfca5e157a8f85c0bab881a63e99d792b8a4fa3db536e3d403b98a18e5584bd899a718edba4dfb19f102d5d81b0baca71623c516c520a847933c3f6bf596d2b67fe150a4d8c6072409160f2df3092d23b467ad0e836da090b201da1e708acdd320affcbe51210d6e9a52960cea230f2e14a87c3e5b76756c3124da65d83ac61227accb050e4b8885a70eefdb21537f511bf7b8d7b7bf8790eb4a3fb7c6baf209c632dce7ea24e7aa801997503fce606607ce6d6cdcb9006fee22b54ae258f52d31fb568915e8f2b8a267a23d6f7e60cf58768f02ebf46ce5d6f70a1651a15cdaabb56594988a0475d4adff332c4f011b9ef0b1ced2671fa79d709bbc7743431a4ebcbf9caa0cdf309b3770d99f4a5d023a194235b77b0a55bcb335b931edb9e483d12a362b36537e53ee76dcf6c438e9d9ec3fe773a90371bfe0ec92aeed26aab90b035beacbe9260bf521abd01ed991c9da73fab13fb9e93d705113251d4cd11f61abdb2abc393c806f49965ea6139d02c7ef72c8842d1237f9f9d3b487e8c2112746a68459e1d000a1b6031fd209409b065bde9a3a9fc06751c330dff0576b998d5390a7aa9d9278e71408e3ac8f72497d2a1539b26735b00fffef1344de9669c1b8b178e25a197ab0d95f471966964a61cec0431347c52b29fbaeae142f26f1e0284f1f452e83feed4c066449ed2950f9dfae4e1927f017dd7fb5d3219a3dedea05b7ffa769e64498830ad9d00b9a2f470f015f68238455420e45f76ffc581a2302703ea898c4240393eda31b7d77069fbfe6b034cd62aaaa82b75a9de698b730d204e883ec69a3b97dd8ba0475a811f6cca1f294ff5014bb705ce62bd27215fa375b9f32eac681a3277f078d5549cd0d33b9fff25c9b940751f21332518903700f2f901c90c01810053e7f808a99e6852b542c2658428940951c63c9486dc0987e374c97dcf2f01a88dc0a503533f72931ec84f41a7482f6823db0022f0a6ae3922937895761cee5f78c18c0fb90e81305c13226ef9933ce4b02ee80d6e3a43bb105ee688f39a1152f842080d630f147ae8a78134c9b921ec15d294325662b5cf69549b1cf51f96d124e679082424245c5d632ce2339cdba8dcde643e559f18701dbd2cd8236f0c89676c9c162f9947ea005b675e5f5aaa9e9f80d88a9f9592e2d73edc38c33a0e6847a52bf0ec5d2f6c805bb28ce72b9138d0b74f600869dc507be04bcf074d3083b32e8c4f8fa5612051a7c104ccf329cb993206eba5fa06d1c34e0f7269183de7d4ef597e1ab482d8f14ccbfbf2597fc9bae7c4ebff9d173c17461f534cfd69dfc7d72ff1c049afa4ace7ee09dfb1b3404b45e2e64617c4b15259dfa2765a19d0e174105babe9d01626480b496bae92ef1c19fd770768b744e12a0fa76fd4272a7ef41d254e4d1d13f1eb2e8897df6104af7c7c1d97597f64a482371f6b97eb85244d0385a59e290f1e22a357adf703df5aaa89d4206732df71f55cce0faca89b4c0a1caebb7f44f4d4b489909f59dcecbc134b1b74b8b7a67d0d143279cced5710652e4ec4aa024d72070ca69f6a13d6d0bd529e524e81112f309ff1bd0f51c40f638606687520fc046d45c91582ad55371c8e16af0ac7bc97485586ba507a6b009a411c2339fb730e95330b300abd1310781f78f1f2ac61a4ab971f756734fb8e9d22f045b0a9321bd05c3c5608451a9ace77849a9d622e52a614a9c26fdfbde3cfcc1080b51e48bbe3d1cc2b12b9943a4ea97110ea3b7b43a54adf0c6526d957b6bd846414252f09e9a55fb929505b665e8ed87a17cc3678040541b426ea53039f5c37dfacb52809189f1c648d66e592eb3c97ef08462dd1b4d84f0ddf114640b48620f22db667a7e049dfc7286266f52065bd0190e40b8914500fec91b736417fea465e80ed1eb5fc398a0a6f3625e0d0b8c32c4629c03ecdc4e89f50acb6ef215767f540971c3b0364354b310b833e2c11be8d19f29d5e5c4ceeeb0116e605161c4f5e551052d888b8345bfa978334f41296ee69046e054c3149e36c3c76bce316757e8ed2d9580b335936de8c9328b578c77eeb8c4d1c654ac19169aed6db74e26c201570e8370872aebcf24aab9e5bafa94de449e6e10868e34362ab9b5079287c43e2bb2e5a245fae6cbd00b4028315f12343649ec788f99f67543411ca4595a79736ff117a5a97b65243298aacd7002c6ba92f2331ea704cc950d6ce546750695ce55b12e184ae168f43996601c6b68126701f3f2f8f456a385f2f616acca8efcad4cca35745eb4140e1684d5102821cf31d5740426053bd5006511f2fb72d555aa55ca661008662dc74991a8f2e8b1beea2f1708a699140bf9c373e50a9650c5b5199e33099ac42934a8e95337cd909f74bc2775cb0999bee7458f798a28b9d02fabdc7c06b400a9b5131b3e30f0a97f0b73546b0a8e9f39d15a0ea5738a15daba056ed1e82b2fdbf29f39d0016f253e471100b47ff9ce9a92f14435b38b32b1a6bc5c772573dce8e3ef353edb4e0ac197095304e5517ae8ed18ecb2bc115bc0bcfbd1322f188c506f4025aec52444a87ebc8b5a0de9b88872fd50f04a636bd4cfc70f41d4b959e407cb73bfc842286da6fbfd6ae794c3b6e12a34c61e09647be357ca372145bea4a29fdb3b76c0a95fdff2d4735d6887ecd272d05b4c34011c320e86776e3f80a1a15a670d28c40e08111d8da7a8a58d639d58c54a4c0a3c7f0c21dc2ec98e2b97576aff274bafc689c8ee9604f3e0c2c79d98e981758e8672f3ff3004cde67733b8a6bf81489db8d6ea91acbf9c7789f6466d13fbd1719dd4a8c1305671c5602e970045c61a2ac231638c77bfe49bf3097105d0adc61dd26a7a841187ef28b6af6926673acd3b0a16e7bda8474b6e07b02e6d53de9900dae3c6ddff1dff8aaed87ea49ad75ab431c23b90ef10020d4ad3dfd5648f372f2d6c6b303faefe469704dc599521f383ebf2f90e07573e11b180febcf10a97faeb3f8fdfaaca94454eb779762d8d2d6074623359de58670fe6761b5a45c724e504bcefacbbfaf20094c9c234d7b5639435f6dbfdd99c1711b45d84c50d86c52cb3c686fd264f19cd434404ea965e4541409ff27af2f26e5d53d6b20c87c2c8487ac6fdbcc2a3c2b669499d20a6c28b24b7aca75453c27b2cd40ba57dce4f6e481ddc153aa1a1a15ed8dbd7e51972a30144a6191a1b21ee22d4b475cd25767a6e03c3c3328cd34fe5b75b6d30758aaf2528ce20c1f5b0ff98df83dbecbf0186f27ec2cad1a40f333466fdf928e1d3a9c4f088502cfa9ce88cdb66df776786e9657f150478ad11ebf9bd29ce1048bf0fde6477f200854e69a4d91b403757148cc2a256ae536fc5d6040e80b16036e15f2b3e2dcdbd4f68bf1f03b8f59e0e9e1a563fbe6de09a340a35fed44faa8d34a03f6599ff54f4e693f9b91fe9b3109e7263cd07885fa43b76f2348c94bbb2c622bd686a5a10c9b35c51e37a49f65585d35cfd018bd1654ccab22866b0407f7cb0d2e6c5c130994994bae01741073bac77e7eb0397eede7a2df569efad9b6b9ae5f1f6c377772468e047d6629ea8994ce02ac543df2d8b2ddbc30a3aa6af194b91d805bc5b75cd616d5d608167ac4359161cbd8687bdd21e9fc9228c085151e4303b126052faceac120e375d7d13f1c025e4e5d4077bf62e68c10afffa43b99fb8a7b4342facf20d2971df429fdd38aab5b46a9f3b83c7990b864c5cdce40a11cfe0ec4b4bc46aac7794670c84e198ad0fe05de25a19012b6617e1b47baf49c99f1cf778a7a8be9b7fa9e78e8f8a633310de0d62fa2f8900e5f218c65dde57a6a3378f494dafbe8d6b98bd59f01d466602e0e3921236690773f04709a7b2d361f399ee3988d636235371853627662ec4d1fe1b8896cbd05decefbc47e21ac7ab02039d7596918aa3614e593b23ac08e1036c93d1c23fd243d0b0fa9cc14578a9d0dd051fe1e6de8e755e1a1e37bbdd55232f2bfc7cfc3300cea45a1ba32a60e00ea107db998c2250ca33d531c019d98025b6ddd50bad984e38ce68fb6e68317e2342c7b950fba0cf163a27d103a1c6e92a4ae0925e9c12268a949181c1ae037acb8692353507155d1eddb5e117ee4cbc09f520b23266cbeedd5aa226c56a36f84a9bc9cc33114f085e2d2638c63768e3edc3d9dcdc4c140419467e032bacaf339c00b9a2f8f95417ea0c8c68010b122d207a2eeed1df068de6afd8898fa34e2ea21da0e6c9fc5a553db6e882c772fd66008e4022fbd38c4296cc25239c9c252c79ceaa0d34afef44205b9ad11c34773d942da999eef2721ede359598d823eadb893bfeab2328dae7ba608e431fb5093514a598406866e6ec2a7006647c624769aa01efe4c315086ea1268af8e45fa115a27b80011fd0331fb2c8f8d7222452f8f87ebfa656c91ce67f8d0f1a8b13502206cd532b2cd360cdf1d4459b194384ad39a43b3182fbb6a240e2d96e534a835497acf965d3b6c55b39ac486a94cd23db01e29eebf380eb797e07fdb44a91ced2423c240f0195bdd3f551bb40b0f290ddedcd6c79948cd5a2a35385f933a9f44346873fa6f6ecf4d1ee077b50e36f1c01f4fa45de58bbdc647e9bc0c26341e8dd5d8187b1db046f523fd3c81c99002f82c64cd5d1de45c328d9f981e48684b67b2c635218261bcb09446b7a1467e234cd63b058046d89ec706823236c0f75f40c26c59c1e1f8e7093598e194a9fa1d5c2195252d97da0af17cbd81c08652f0b1a5c5f89589ac25471","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
