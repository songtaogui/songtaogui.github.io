<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad5ba8ee7fb97c06fecdb1d9c5999b01de44c5d4ec099bbde70e1a93d54a404f2330dee167562d88fc4d9a247e8329087c14cd38cb0de5bfab278071ab206e5aeede4e6288061bf8fa822a4c984df9694d52f8c03e6aa72512626a41f73b94b089a7ae228b7434f878c0087a48f7fdad1e48142caa2b3663428bf3d5d08e0075bef83002d67685fe556adea34f39a32c433aaf0ce0a403edeae7709043e73e8e5cd6ae031dfb89b7764235a36e6f28947258f351f702b62773c4694922390f28abede60929e2bb87f1f8aad72dad224f219b4241de807aeb9d24a4241600961e3b9c2e40a066053389ba4e867f087f7e8ad32e7374478afe2a6ea79f44b3ff899a9e6f359414167ef41d8ef5ea7de0cd4fedd1aeaa23297b069c19a1024f069306a6cf9abf253989a9478c86a1a15f8bbd69ece460f55fd73c4ddc12e59d21cb1821f7e0aa6e46706fb5424dc6f30492a1dd110ea96f92547bdbce5dad23367e783ca941aad3c7f7bbc98da81c04378ba4d656a58bd8efe2b820ad914dc315754c3f40432c9f5fb954bc2531a53f6fc8fdebc2cb12e7bfa2f26fdd493e1501798be537342f93cb11352352a1def098dfae1b192a611bd664a78d4d10319266107fcc6f95d495daf7ad485a100676beae6b63dce7c0e4d554b892966665fc5834062e288c1171df62f58938bfac0ae1ed45846ae4df6e54f28a7da999ff22b36847d82d7e1ee1c63ff85347057059e9b90c8cee46992c0a6991b0dd5a887d21ab0fd667cd16ebcddc0cbb07da7b3a2eaa57e969cf0593fee50b2cef92b816e6e484522164e78eb13707f03952c9ba94012837462457a8d2373735e60e78e47df7ac5ff72129b2d8d5070f1e98a0757745b2f04393834fb67d8bc52452b4346eba11067b4ac5fa107f244d440ee1cd859c67584b96f8c69a876eee04645eca8c3523e2afcfc446ce75b645bbf5595be3c307720b7c08f67c6dfbd6c9225f021c7b4a581417fbcbf711ffb1e925ca5d074a7fc0971c5d4ef6fced2b9871e02bd1c7a1b32f5624dec0d17ea864bfa616a75d66668f67afb3e8cc6fde487dafe8b7b2a36e865e89af78bacb1f1e9af786f76223c2c6d2a2bdeb721ba8be28786b1aacf6aa7d00e57ca363c16226b0a8c48db5009abf14ebb973d4fd44e7344bd72ea1ed624e3fcd61584b4c9882b5ef2fadb7ee661130b8c1404e12e52befe429ac2df80188c44fa24983694fc50f6c1d6598d1c9152eb0e8525c681c66067a811a97f4ee521ec6a4ddcae843f634d4308ba1aa25b33a03ba48c00a7858a1d42b96eb532d1c385d2244f45fd9b34c2314e59db4a06bc406627dc901da9a72a8909d5fb9544c35ea42ed94cc830efca516139081bd51744c98d35c11617b499bb01f90027a17869b19519d154ef1bc595c935a963bacd80705b38ba5ad17b8c7cd5aa3a2b1e2e824a1988d9091edab430e57cae540f6e366610ec7098dd1e3116e9ee7d0724b776bbf160d04c29c751466f2d1c67456741c9e19d7cd0b19c735eef87ac70428041920b17668d908380726d4551431221d80e11e6c73615c892690c0453042f7119d8aa242b502d22c3056f10798553d049d83c961032aebad01378ed93315d7287584ddb6b9ca3c4d1f009a645ea8b9518fcd10197d70cd7ecc853e062e5cbb4364e09d7172edc3698733e6d5f67c7283aa862bd69655229b0816b9895a5b027927a40c060fd5b669fcb4e6862f4b2984fc497af8f4c85345cfb9ab25a9ceb5e6c1d8d41366a30750352a9dbef395d6de5f72ab1b7be903afdbce621483181f8f9ce97f2aecf974aff97504fce4f9cd84f3348f7a3545955f6bd88a3bee6cf7a16021a74f0bf96ea9fb57b05307ef63f59bbd4b89f03688a4a305e49581fa5c9276dc12b465fd5b0905ded6493ed9a3154c37cb7606cc067c0f2ce33a745c6d6e233a489a0ed30cef7583ef0513461fc659c1b2fa08584deec440551a2f0f73298fc8b133a7870279b4f4e31003cd6dca370a39e2d91d248a588d46db41a51e63328327ae750e116e5514da85b40de115bc666fe2868bbc82a0616bae73a39f66ab7e6160c3dddb679bb09b20236444e4005d4f648db0775e6431328e670b863df5f8f387c4d1cb676e0df8a4a4b01859876ccd8bf1ed7709ebc035aefc51e62de1e35d53d1e3d470d7732598d6fec17554fa845b3b2663a6eb0b3a74b64982a294126453c88e013e9ecb5f5bac3fffcdf6ee0cec8e6bf1e80227192446fd025eb06db0993c5256b80cf96c0d31a08b475ccbe8b491bec591f39124c32bb8e0e60170259febee2317b0dfc52ec696cef8c86f44acffdbc3e53775c559cd0a3cc3076b8b93e449569f8569455c355d2992b6ed5ac04aea3516c58018ad0b2bbf7fe64a59d556bd83157f7bb6ecda1e856e03bbe4a7c8fbb5764d06f0420c4ad0ba160fc4081f891b2f766b0e447d732dbaa697736dfb4f4ff7b08a89e9be4399fdf083c3508a5be73fdf746575edb8e88264c5acdf563d9f89b78c3060b0621c4cab429c8578f2e8e78c56ae7332cbc523d9f62ff625de0faae12654c23357e985d2898e0f8806baf4348916c2ef88166db81ea2ca3b7f3645c925758b42d2496e3c67785c0a5988f8ca18b6902e464bcba0b5429fbadfc799d4be27810c8d7641ef6b64cc2128d8d55ced862f88efe75d41e703d7a18ab85af5e1c64e75195df4a1a757277ef5dd8175c2681e2f36687d89ae0734e9e611224644010deb61d921b499d180ece2cff6e51eb05e8030137d0eb36a16e660bcab1a9c7ef8ed7b4cb01c3347fdbce1939ea3379ec9bc7ea1c4f3323b56938643b63bce74577fc99ab05264201a2429581ed7ed6328cfce57b96430a8c3eaf7597fa1c63937c3aa2148bf15ffde5e9179a021549b4562e9f3322ee21f032a39b4cf129dfe449f1a51123ae7a5e2365a61111c2b70e0d4046ff170f60b75ff3aabf3ae2a51becdbd7655c4a4b32e3418414e859db4cf60977eb45ed4fd2483928eea1b77fe9ba86407538080f1b11deb253c67e40c7afa0e629018f8b4b2e58ad982d8577176594dee2b6ee11a39b5dd5dd9fd15f2c2c873be2744052f3e34583a4f56c5182919069028bd2839a33a6460b66733dda61f66e6dfa90cf7729b9d1cba69a39e2a682be550e0fd92332fa53ae4e35c6a7aacbb125f931ca78a59a0aa12a6d4d3501f15e03335c43c012bf7a5cda8413931f60fa6da0a33ba5fa7539d493ac32e8e24ad5594144d134dd978a5c2aeee53af4ddc6150570b26160bf4f24b2c87548fb0ca0d061a410c853129f531b5ac0e5f5bdd20fa748671f468cc35668abf0a870c5e1f12c4e0eaf8f9e007d745c0fea4bb059704d37328f34f05c62f2de3a3cb3f1e8c1a32d020e7db0238d41a9a06b71f8427d10c97000711b2d35f7435c22b7445b81a6a12ca805aec797b8225241befe4c0dfe6f79d411195fb157e8e31dc7f3a85430ca4ca6e6582d97e85f332d658b5f6c07bd4fd19663ceda6bfe757c588842bb8eb6d9078a7a6ca139d5de83635523e6469f456c1697ece5cc02797c2d75b244c6764ebfa5c07a092b560158ac1cafbe391180b1812e27550b72dec7c96497203c5a4c3686963f0a9fdeee65455a65ff7927027810bd7b34787ca823766b6a3e402f05477b3f6ceba8bcfa863bf02a0d63569faba56168b368551eeebfaae8de526b26eeeece05384d80b388c2cf84db8e7093145d849f9bf016dbff5f03a854ad524411f4fbfc39b1a86028ea15bd6787824b00e6033f3aa83d3450aefa4c2423ec8aa12e53b55cb8ddf04ce089cf938863080136c3466f849c741d84ed529bc3cea409a6081f8f336f47469bf88cec76cc9c3e8800ae859d7c53d07e89c440ece3b4e5498eef3fc205cef51c0f91caaece398c56267d2c6e7d128e56eda44f3ca15d79b49ffd3bb8f90ae7fe862f9a21d52e2d68fcf045a2065427c142168ab201a2252bc825ccaf933ff4757e5dcf2e74c04cebf69d047043877de9abda1ecd7d856b7b62f06cbf8f0b918aec69b39f805d5248f79f1bdcaa88e8e8239566d80b91497a9615cfabed146cae9bf917cabd8b723af541b568c7181c76c9cb807c6c29d714cc495ac7b4ecaa269ee1ad164d5fa8e89cbbff45d0ffc78239a43acb3b70fc2407e0e9727369a864b57684c479cb77776ec677b5e248aa9766bc9f7cabba75e2375f012c910058664f73669da1be1bae7ed9cb8e47376d7a629734af67442c7a3c6afd4ad1c866ae10c26c4df016ca857b250f5f82e5a36b105df4bc8d4341d4aad6c28b9f71f9afbdad7df2638d214debd204935a6606cb2b03c32c121dd31f72a3b5c58fe8c1ebbcee20d51dcc3d0d3a349d2aecf90cc6a85fef427045a746180d749652036c6316341141ca6c3c39244718a3939d17cf90a9a6e5f45a1d363a646e17f1be7eec064c1c960ad805e650942cf59fe3b68166083dbb9c9a9c20dd577f07d4f3973b6ccba6173c6a10e27b6fef5965035e414e91d86dc9aee1f0c75b05a4aa8221cb64d225ca4fef20cc6bef91b333c383c1a0457164e897ad1cd571ab33657c13136251b15f28b36bbe64dea48e8a5dbff331a14777d6533c3e920839b06f1303ea6dbc67d5d39476896afe88bfb713a5fd011e8fd95d760ebea5760c86f7ed823f193b0847e0fdc1acc0a6ae36ed89678ce81bd6a97f52262c8c3a6be8098cfe57d5fe045648e738e5ac1b5be468f9df4ea2c879f45f69e863b596df7271d39c2af1c5c7b1d069c2350d0b4ef7696f0722ae4f6aa5aa8b9d6d1f7bfd5a31f6d58ac8e7037fd92641d8f6e3a81ad88144831673682bad9da1a70f1ebb688e66ddbdce4bd186108492a3975481c433ecccdf4cd2feed71c96501471522cc475364949d78a76cf0bbc91c545d909690f6363ee1c01eb161db100e7ee04f8174fd8f784da7d4115037bff593e0abacd277a986d5bd58bdd849aa188161b14948d2bb9a8e5b09d4b20447cdc688c992ff0c843aab455273bf12ccc400b4f47576787b0a5ba4c0b47e27a55fe3b0debf91dba4f18ed663508d46f4f179b02b80f665aa29c148fc91899cf2d526600a20ffacd1f9b24d86fec1c8c081f3de58f16f51ead617bf62157805f1b0a9c67caa3a50591aaffc782d3ab20d121dcbb8fc1c191bd379d86c996591a108e638ce3ab3f9248ec26c00692cb30e23a91832383f0a3d4537320b279d7b540b4dfc03a771ca6b5bff606f5a67a06ea8fc96f8f45cc9865ccae319b07457cd947272c915aa9e8d007ea8add95d331c37fede98970f95b63d7b2fee487f094954d17d776238b24568e61e17a104a3e363f26ab230ee89b186886e92d20f280c7b29f9f989db58cd5ef5cdf13228122886851170f09d81c49bf38546f9ded029ed47826df7684d4769db052c3c903c94b08da345dfcd30def1cb9db45643658fbf55047702c4461db105af47a475009f2b5bf2bf7c89e3441ac2a11813383fd0e596ab3846f51d3b35d16b5dd84d3e467a660a40cec64d71df86cbeae5f47285b7b6454e2696ab2368ae46ed6c165e3a35fc4c4afe167b8fbf734d5c38a42f0e15395a0519de6d6d5b747317debd965d46aaaa7883e24ea3e73f9c8780e88000e772a7515042663545317c3787120582bd21281ff5195e2f8386016070809b7994270e3db3c2a8ae5669ec30484c7d1af01bc715a5510a0e02ef026171180642ec5af09ed41cd65548adf2d3a6127de45f25c6a27b152481ba3f910b1d297abe2bf0f8d843b6ab38ccffc138cd0fe6fa024efbb4743b501eb4186cbd5539824f8218417fc57a40648c9d1b81e6f80dc64eff224d4f976f98740989a1aea3a505a5e98e3a95eadb100cf6d91ceb0ef815c4ec97f4ed668d109d42131a485b0e1f80f05513b0d82a2fc8225c426004e395f2364ba90accb987e45ef98b9feeaf02477c639759805f45162eec00e42d0f496a684835d69a962caefec7fcd5b4e2c27fb481ad78777a8dc6bfdb2ae3b4f95e7ef514dcb70dab13052a55cbe63e728ebf5f2b29a9798dfabedc3a8d4992fe27cd11de2482243ef5b6bf525e28b46592643e40e465c312db861bbdf2fb0fd1c6aff591f2e725528f7caabbe69eabaeb6fcded798874878ad480fef9d4e769845719b49704f32171d1324e608fd0945a2dcf83883fa23fa6824781ecb3195d3eb57a0ed227b883fe6556b31d784fac2a216612a7cfd4ca20b796b25185a8349699d63077fc24221d56823ab44e4004282924f2dcb20f1e509d6359447505d7602b1f5ef968122c64eabbf57cd0293e5c7175f1d7e4e18a01cfb4870c419c0fddc6eb2694ac60948da192e9166fe925f04e279585e25142d94f3be9453fdd5618c7c036ecfa4124e10ba291ecea06b08c53c1772a9da91b29302c93b861d7eb021ec6663cea75284bf883807d2c5fbb1134bcd44c2b24882181d5ce530944af6e7febc004838e4ff3bf7cccd1799372297156faa6e6f9caac070f55cd969bbae9b4d9175999f42f0c715da5d87a7884636ae0bd351f7cc10089a57e9d634ed90d14a72885bfc4a1e1e997c26094a389e2050aab875a5797b478ecff9c1d2ec9378651ef505a7ab14683da5af43fd251fa454153c769bac704b66743c728b54d8eecfddba7c4aadd410731ae9aa484262755634f924550249b8377a24fe8282616b0064beafee1c47b899f386bafacdb57734d0d64c73af2a1c9c1ac4b7f31a579c1deb7a3e4c442bc53e07627614d0a1146bae673de88cf792dcdffdefcbaf6a4748915234908b552e682bd88312f277623178d129571d1697e84d4686c4d2b0ddd4eba0b37fa3796451596fbff12973c9c43bacf8cb0d1620747f1022a3ebe64f7031f20df0f55d197c5467f51c9350c818389f9bbcfe9d585d62dbbad53ebba8b30c73896e350d4b32cb3569a43641d7ec1fd1796c320f48255c7f312888c6383fc52bcdabab9573fbcdce5db94f1cf9c6657adce5c39adbb37c2fb4476afdff1ae71f019352bb2506b566e63070644932dfdbbe2d1a4b6ed5cb9f72ee53f618c239fa4f4dc4fd07a9d4b5c909582ba063635c0b8b9e9022751e419e7042135351df855117714c22e0601400885256aabe1978a7b9c27e4e6405957fc71d1e08fb9303c9761e2a54a97774cf72e68a9adb8284ef927160141a13ffec36278785f153edbbcabff3eb40e84c8e890cfd3aad6ae5306ecdf9e96b3d6500a3eb52fbfb675972180dc3f3e09e71553f9abafff6987571c87f9d004ff2aab4e125d3688d6a5e09c8c77addaaa5550639a6ba7d2f97771c1717740b4fa2d2ac68f75bb3d1775c24218701350cd65f89fce21e3b716f49909e3026aee92539bbe8888fbfa7ca5eaa94543a658d636fe95664f4cf249398dce0aabf81d76b96ae33727b2bb28eadd965418b2ee9bc3e6124045949e582e6b56cf4b5326106b73ccb606e7f229c61752f46407bf962384109ca37d37e1a96108c06449c31d4028fe37e0c32c465a18c6451ac5249bec1ec0d2b3b006a2d166cb82a4824127b3970b888980b6b1596d7ddd0a6d5693d2f261cf93e718e108d89d8b15a545cc58d557d3cf95e3b67b48d4ea349e43fa0294309c9fc1366e8ba98710a56d2b881f1c338e6e3d336f6e88e230a01554f4bdad53117db1bc6086055821a8c0ac1d675bd534b2d1c2469370b3923b3eb642aead39d0b40be3456b0bb078074d1c292bb57382f89343b73b8a549894fdaf76c0d838890b1cbd8b68ba33c8760b731bbe6b2bcade6e0f8d56371842e44b06f96485cbe015ff4b7353311d3bc7979b55c442698aebbb175121dcc894e19b681e6078d18f1ad8da9963cb1a0a2da0058565fe177565c6f1cb6d80d186f306b14e00e3d7a6fb5f3bc9e00632dcee65df165c21ce790b532aee6094d7a64c90b6913bba38182a4a8b14329bfe55064df228da991d375984d3b5c017a01df8c5b109be3c80c6ba22e140e29665c51d3629fdd12fc7f6644febaaef6535ed446bb45a30231dcad2b46ca4021dd3517c2fa4e9ccca5c1c44343ac746a01b43cd64672b24cee5ce3ae393bc7a912980f94acad495b771f4eb615ba9c84626bc427e969baa7b1d550b96f5a316e4d1fe9fd5f136e5a509a8b865db19d8bb0a65193ce1eb88befc10fa08918390d68e41b060d214de025c2c2ea6d6bed76d154bdb8dd61b85f2888eb0b43623b6abc2b882dd07236d5ab7da26617a338a4768d3095ec9fbfa78c1a67f52dd60eff52d15e9c36f32bc909fdf8689546144a2a82b187a4f01a214084061f55d6f37a5350e4d80833833dd9397eae0e0e60180945c222cfe31c3802cce9dadfb521d9e239a8e01a503e3426e0bd5f1be96e36b551e83b406e068a221eddeeb241214bb16b4459e0083200e7a7bc8c9d98c70eebeaed200c3fd1d966142fc0e6b2fbb7ea1b51402c4cfd635252a7ec9fe8f48569c6218f32baad87084d721b4da7808e9c2926046ac820ba91b19c5e6727831d04cfc0ca43286915afc5b5d3daf48764e8f449a27f36cb94b2d56acb7258764b74b5c8f918fc36219c8953312deb5b01306b62b520fdd4d571e474defbadabd36b4cc31e5c0de6140f7f81f621441f67d04061f0017dd5a89950444ea20a5b29401d621a71a735acd8f181cd9cb128eaa4395ec700db0617a1a3f0156afa8d050444c553da445b951526dde8a4791e6ac7444055c066356b6ff039eb250c3940739fc2bd1492560fbfd4e083ed8611f9be64857ad60440df88e29809cc143a322d0b739503e05a0a231cdaa4864223abf6f57a17ca7623cfca50810bee9b3b71f26a763f19d245138e79376d6dd2a1bdbbcb4d8da9015c20b8b1ff35a5230f10cda3b485aab313162d3fdd91609a1c3b03eadc3d976f300a34d6b33082a9f766d8f9425bc30c63f2af18554037d35a67f5bae0d6a4e87bc380c21cc611d62623a5cd2bd70408f0d6939bfda52d70f6b23f7ce846c09cbf43f6954121aec6492e447c4123212313c24fa2043be3f845c755cf062e503d29324f359ee59e3064baa4acd72e7cc21869f0293e95f3d0216a6a8122a73d385d7617e0a04d75b008e8f8ba0d7ebf9f33f6d56018b2f8d7431ae537174b6d5b1bb4092a81c59bda9e00843db43a4332e6e694cf1f221a26f2619a7732ad5fc164facff7b886c3d87ed6e7a9b6f0fbb638cc8e16b0a3cc3713d64af56ec502db6141e32cbf6e23d2e8a2e262469b1b963ffff7b6c33cfa5504f06fb1d2a71a84597b7ad9b3019ba057bfafa5c86b71e42c72579887005b4f1bf9e2ed8fd6e574dc910d70ee18d5275dffc9a61e9bcee7a866593f8e84c122e0361bd0753f77f516ecb7feaed0887b7dad02fce304ed05c3195496d10e5b5fece69432d5a4ed4e82f884dab473d90ad0cefe85c2ffe28a43bc95605055bea13ef42c00c49cea5c73bad6a8e2baf326056c47d93122a490fc059dd6bc3a995b42a390da961c29fabebbb7a35f184430e39576f0a0b101470c249ed15425ad025d37e2f04a1a783b17e051ec46e7411a0f26cc4e1c5d13e5472728321f672fb6a6dcd3acfe285f6f988234b9114b14b6234ef2527b64544be6983e36faaf3bba53be1b07f0cf409bbcec3e4870a8f48a34ac4c9807a053494f810a77ace6f35123c5486dccb94980b8b29e6b55f2361be6d9fad61dcb9a60146c4c592110707ff93cf3c68118f385b68dd55a16ebc66b2081200ffa0a58354a6f3bb5d0843f8c6b506ee2600406d905d4bdffc6cfb2746a9b38027bbd3c758dabe9d3c319c1071c1f016713795de9aee2cb4d9cf45d3eaab085ad8155387b21442f6167f7306494c7f1d722e7c1430eff159e924fcfa4f6e0f6588d5edaaa1c490ecff2b0864868b942ef9271d18f9e5c55aa6cd4272b520171a156aad6b36e753e6fd017fa9204cc60b1996264fe243371dfe6128a1fbc453a551093fe72c07469fae3df8057b1089230d00bb838484f442519fce6806f54c820785ec0bfd05903c62b42493b4d48b792094e35796eaa83fff14c8c64c51cd889b316bcb2316e075491ccc5f685fbbfd48885e9eb8c501b8553d50a0ed1741c26f948fad4169d1488d24b8ac0a6fcdc10d94088d539904a6a2a23395e9e65118324400703f712601623902485cf924dcea8bef2fcc6c8eefe12e4d4a7a8b8e09efe0ef8f8787d8a534d25fc3b735b07d8dd83c0ebf8553a74e4221fdcb0e085ec5cefaa716bfe8df679c84c374a46637c843685c1599c6dc21e8367ad20e614d6db1fa656a5115c619197c20a43dcb232ca4dc218fe20c5139569b64ce53ec248d1933467a6562ba03744f7707bc94a0d7669a3452b7a1558ee9e0dea9d2ab884425ed3bbe707d015dae15b9a1aab70723519a83d6ad8a4d12a12d89b8fe5810bd05a0cfc9af87fd0dfcd64b467d56d2c0fb4057bbf18cbaf94fef314dbc52e34f1408bd35fe7b76506adb7ca777d7084cedabe400b9cca7172d28ec7e302c40b1c794fae8bff108bb7d761dfaa2c129261ea1a4a2274e48fb4dcc0730e1aa6aa6a6dbd084b316a872739e6b4d1cfca26ecaa244ffb63d2d415a66312f950421cd109bdec4afa28661d8d593da9696ceb6f81322f4f235e4cf878504fb6a452b13127b4516f27de265fb493a9bbbd4ee38375c88f2893c551936fa7d1075870123d62859d8fed91b703be13b25a34f39a0cc28d753c615ebe7f1a98fd44845e24f0b1dbe3336daaf0669cfcb31e7dba7e260bda3d6e4aabda8abc71573af4747e7ab35d24d8bbb61cfe4f42e47a5f91e00c8c1becfddba4c28509683cff11c351109d63dd6bb26e56cd8dcbefd069d084b2297d94ddd4f40aabb522a458916c8c099841964e0e734de3fa8163a70f58815157858c509c0f267f74a68bd246577e725e1e850251e20bb77dc947f68548fb6b90aad530b212e33f6bf7eb2a237be259c57b7a14eb283eb6ac5167e136328feadc77f459c232477560c8a5ef9676ac9a7aad91945b1c67c0fad4c18b5be78072201d8fa43f143c39529651228e6f29a7b67b159dab282b4dd033a32dabb2ac16b0eb3d02f6646d18923f4d8cd6385ae76d33a2b70d55f477a562be81e9aa547d5d37b16c9e1a0b30cb70ef2c2c3b74e069b059290028fc3d2aac88fbd20eeef7887b6dd399c713bea53ad000640e1c9568680828db271b3fb9f159c1c9694cf730644c6c45d744c364558cea2d27de59704fe8f3e374fa73c59a3153850a776fb83ead123d07028de8495b3194ed78f2f6dc1455e06ba6f429a750d3c15ffbe7be53f5b77fe9a897c0e7513620030494cdabb1141d4eba0c4df0ed08a829d83e143d40272ee473f92d8904468ea4ab6b7375376fbb4ea29ae1eeeb67af7d4cd2ab9d8c5aca862f6e21bcb4d0a286d693cf2174376978bf99a49a01eaea39fc048bc2d1f30cf8c17852acefccc938b08e7c98b1c529a8a95b268a751326f484cfd087f7cd59df38b5aced968f7fbc66f9e3afa17f83803a5bfcbfb48b0472037a7cbadcc8ef1f5bac1bdefc233190c2d341e65f7487d7dad30456e2a9b375c71683fc13138d067b8ce29d84e376ee74458d3f9afe105b4f12f6cf0c427182a68dac748cbb0ae8cc1e9aacd47bc23f0e89d8220625bf458158ef0c5daad41159ca1c31fb0211f913b58a097d183b67b65f7b07007201f8c52112fa9092db900c2ecd67ea3b77040e80c3a9ac9d36a2d70b5f2311d2160e37d919a43a5a84ffd9db4b3b1b1e747a271808b9c4cb434a5dd49692a51be0aa9c7919be351cef750111196a7da505c38a02466164c2fa8c94d624b0d89a38f433c3f4fce580d54077144cd013ec248c1a00118d87c639a16b290fc36350e8ed48f3b05df4244acfb8926ae69e1ff3c30729de5d6b5bdf9225b9ced477f6d267289830fd5b3f4401b1b4d454738b600e789807d3cd0117f3aaa5f466e9c2631f7d1c218da26c0cced6124479db15fedb588caadc4679a2f0dc026e6dc0e835e051537e5011d1f64f3f7795d69e61ae606ea699c0bce71396c37c72abbe93b30e5f3bf468743985dc458e78e7c0a83e9c428de6c7847d356d9aaa0bb107b5de40b6150dd37540182952835321eb867f23b888d813ad7098ca744402307442887c195f26369a19c3008ca74f29dcad498d00608e93afd7d908a0622c35f3549b93ad57472004029d1eb08daf27e11bdc9a4d8a24662ff1f572699f6baddde73a6b3d1ccdff843d0665ea71e0dc47d6bcb080d504c5be1788a03e86a0b1e1f610e1d30d6ea1b5e1b06e773707063fc5371e2aae191ef51c444c56ce871b4ccaf2a41b09ddef625a6bd9c57fdedd18defa10740b6f6661becb91216e7347d14ac814d2f00d074ba1ba5fa6a7d7a6dcf592f38183defca32ff9cd16b589aa2cb9beeb0f28cd352e89cb6a0700979cf569f2c79a9f0a2ef1e738dbf610a0f184ff3af6cc6c1046450dc4ccfb6292101b213c71f3122fb53077254852356f47fe55a4492655f16d70160dcb71e193a22b403424ba1210335c3d194246ba433da2978136042dd6da5fa90d182e5e5e848949429abadf0505999b7877cdb6ec7bffc226a8af070836960e790bc04dd3cd568b34d01376fce9138ff8ae275ba114896388cb814d2d2d07e535f31c867ed5cc5f486f892d0b86a3e9ffab7e2b4558827e6e2202f3070914689e9a7c2e2ec974cfe299a4eba0830981fa8136202d3bffca9b3045128f069d4cd81df639c713e0aef25de012e86e632a299fefc00b7569f1658ce0244b63ea0c674668c6cb512dcd15c3475e5370a0090308b813b4312501a7d27b4936f2ac5511518abaf78d69569e95ad6d23fd7c97b8cf9e64741f4ddd0d7fd2f4427b97e2eb9b73ffae229a5d3d94d15dafa088a96bfee97895cbd35bd9fb7f9ce660c5408fb6ba38d96331ff7d4907dd4f7f654c96e553258da3ec884ee0b6370cccc2394f9993ae14e6039d9b36a96548446a693e6d90d84408779fcd359a50ecd6754d00fae75ed6395cbf8006b04fc807e74e62915c4f03b25e37781cbdfc749d43e6fe73fb93541b0e85f8894c4dc58d743d187edc520f58534ff424f24119ad0e853f8c24631523bca530bf181a24c05bebefe398be20c0462fe2d9ffd014bd36f6b3436bf79db9a53a4dc4bbc72aa868fe33ed47e189ffd18a2c473dc49c62f13467830e6e8f11e2f096e28b335a7e25db62f804bf886d9afe818d334eec70b9fa13ac6e417e721110fce5ea3f89fc552fb2a641a5486df2a943f20be9c4430b9a4798c88d13187e1b58fe5cabee1a8caf1fc6f4df71fa608a31888150805aea69455572c1432980bc3343ea7b3e2d28b6fd7253954191dc71a49d6e05fbf68005221c9202bec2b17bfe7dfde26f1a84ba23f410c75cae486495b6e45875243e0bef86bbbc15da3047320da5e3e1b613dd5b50f4552dc323f60a55ab0f0a994d2e4244b958227c3a882174aa809cc05ea242635f297b404a0e10386a1c831007ba35dba0c920f9e00b56b404a3e1fb5dc59aea93d728f10481080e4ebfba2943c087a48862058a3157512b29c59593279c005437946621fd3349be9090771712ba42ab6eb9d88906f6bfb412b33eed9c4b718a6fd1c523d9e85e888c2ffda9cae2c963497a08f10332d0046fb1b2f3347225f112b3487badbe76d3fe4dd4ea93c3fcc979ee6aa421947078598e09c183d08bc72088e7287ee2d7e2c6aef2c5c45f3eface6164e6855c7ca0e57861b4117c304d14869478838ca6d08c5235030930d9131a175da35c516f116de49d6246eb24c40133ec1da6303c27b6f0ebcfdc73a90c85cc068179c0f27d80aafc0dc4863496f8522ba826ee23e2e2b45a3a110c4cf7a43ac6f49ea077305b1974813b1eb8dd1ac7cfd7cd2a978155c235cdb72d36cf6d54359833e9a363c0d27b0b59080ae7189be6c28c331cacd54d5bae7612f392b10894c358a6a7b96b9974ae7a31a9d94dd8c6fa9d9e80f8214d34fb096cc74ea4dca804d8272802271e4920c85c59884ad752b752c739c264cf4f97f5581d97463e67a60347050d4d194e4b5e0a446feaa0cdb6f00e6f7e6af08265b3a285abfa16b9d47403066be5dcbef90cf5c04d35577556a181bc37edd5925783411c1195544f09832cc1effb4992de512b3f469957a0279cc58e78992bc0ad48ec77b21b1c177dd0865a629c9776d3b81fcf1d300833b7085c486f43da1aa153605df7c9c48d71a892c7323043aca4e30f919be55f1aa0b2639b9bf7b9a5207677681f733c2de12625adf20e43515b7eb35a2a9236dd22fe461bc3e2411ed8b5034378a2e28e6fd99205d1915eabfff913d7c9a6f560201b37715f7f65b4e1c11f9312daa4b49faa93fe2425732d8f2d38e673679d1c58f5be45d30e44ffe297599f243072de61fcb7370c3de3e29e1ca0536cc4933a1827fe75b7a887298b0180cc6f16f583c3dbaad2e2ed584ba20c285a3c82026190a2366142ca0d14cdbb1ce42f8485d9b6d4aa5abc6670c80fd1511642502c73d2616a39e07e836868b95b7cfd35bb9adf167f9695345e7c8c0222cd2675e62b91393b89c3a7bb8c6cf46225a1f69dce57d242b8afd70dd5310fa779b9b117afbddf301719fa155d1839256237bb27527f2bea3dcf48bb29f931fe36cffa048d1306a61a982b295789b3946accacf8b1bc00e013ebe76223c59a479a6fb8a839263dae7fead4e0d99952c471f8b8a1f1f9cb5f7379ea9466f8b28d0f83c1390df6de15ab52c5346964599b8f7f018cf57e774aa426182fab96be905e80edbb417d0d682b8e8ce2c53e225cafbf5c63f0b81a56299d658297401c2e71bcb3836f150e31bbb74621eee1faed95e2e2bf6e48f68421684a4c57e3b882ca3864a28b7e3181305758717f20cbca5d8e952cd27c28c4f7480e4788bf01c484521a067ffdbd41cb34c97c2648ee28f699563b8e8fc1d451a6dbdac1e865059d3fbe77c41ae8d7f0f75a4b69f32c5136ad6203e0a0234d5df5fe6a7f31fe1098d99a5e54c01d18de2026b269f1791c991d14cf2a4dfa382a438a397a3399ce56e5372e88fb89ede523c3f5b6a25fc4eef5f083d29dc77575c3b0f63d342df06df1242836ced66e5f9e326cab73899d52dd89cc7f4ccde491466a6e4f22307a1806be5b1b78b2bfe1f86174bc9052bca992a13617771ab84d739a3f28580c92d70ac891073ffce768ef09da89147caf8d5f651b3c7e83bdb89687fd25f3ff26e3f227cc402fd66bc65777dc4c588d21cada0ae16e38ae9707fc5eb7263ddc9cd7844b774e98379855aa8200e2891c8cd3c7b69356d5da27ca226a911f186207c115fd842927f82bbe9479012d274a1d127dcd98c456e28b15ff0f600d23c1eb203e1ea278a4075ef26b2fdd08e2d3a99c03cceaf5c3350a9c5f16d6abc74584af61758f5af88d0c87be972f3e6e9755ceb34374cb4d6866fe7a937cef62c445a95c6a2354ae61443598a62c5dd46bacfe6af347342c4d86f999aba23be40bba94e0b8819956ab2025baf6fc04312f7783017ba5495fada7488a5c03916c290e6394437676f1db51a0da8db4c002da4e92dfa0ac4f407eba74ad526c774adee85469f67a94be73e58eba79ce20af899db932b2f4aabaecb7151326b54d59b747bd860a945c54a12ab2257825d97828c1c587fa8cb16ca195da8e7cc949262ce6f0c5f1a6b9c10a6e77892eaf67ffd0751210c36116ab1299fe87097f598454100aa9784e3ec541418fb484b719724d172d05e75082b7c428561b73e3480f17e607f8c35cfaed9211bd7e96274bed3795f4d161891659ec57353ed1bb6cc7ef73e7d112777c20687be94598ae1d4740d973607f264d11a6b40feb699a2990987a2f933f0e85179fd4c58bf8fc7fa3a2b70fe0574b580a6bf22a8f61357516ee07ee4df672843d4ac367e2a0bed5f19900904749c977fac48bec6c5edc1f948f5492ad4840736abefe69ff8e514eb33df19210c7998a5278293c91f20ed2c3ca80300eb3fb3df43a42c18eaee681c1f481aa4a452930e021b7a4e88a81c820b5a4080c54e62029e0b232dfe71c329e06d536dfe10b3638c5e7a6623ab00eb0ec178c2f20891784dc7b3acfb12f746e425aa204a10b18847893024f4c21c48f5265d2ab62653fbaf00034851dd65b79beebad158600f59404b3b91136943fc1880db6e0dba28266a5ea4bcadbffe7bcb077127c4d9ae8764e9efbb217c6e8463021b0ce006a13a43d40e091647e229ac744094b9ccdefe7a1f693be4a0c62f3dfef41450e31f4ed1d136411cfd747cefad00e00cba50dad78c1b687d4b6a61bd96cc8128f58c1444b81db9944ea5efb6cf31397b5ff48785fe72b8dee2378b6460c43c5ebf948e1c13a08f615f283da821a22ad1ededfa6b78a22e210377d1f3411e773cd90e3b173f5cddbacc370e82fb6464789c5670a19959d1bafec4cf009c167e41963faaa742dc640a371e7a41d2f66130e401e9ca3281518bb46d6bbfe211c846b59ccbe190131484000a2da8ae06b6969420ad23de5d7cdc440477123dcc4351db13fd4dfe1f60763e4d343519216dd8dda1890ac8e0ba9acd86dc797d2bd70438e6f0d7dfcb4ce396c4b57749dcc511c9a811c5a6c182ec715a09e8c5e0fd393398f6cfb488b69137ccc9b754e095a521a824ad96dd9d936b21726c8f2aed5963a78ceb58f38af311c61ccbdd9716ba893f3cfdd8033914931ec38bae21ef59b87f2b5d24d0ab3ccec498cd4f83cb7d2dc877c3f75af55f33f7fcf349236f88dbdba2403b735d6b3a21865964cdaf69b6dd4ed2e8107f7d7e737eff9660585332e026fbf099f7be39513ed6590a187e55033bdd23869df9e973336afe675e97d320b79eb47f3a359d684f5fa6d3f8b77c8ece200baa6270aaecd5471f49a6b50fd6a0cc7f92b93a33901ed8647cf883ae017a45bea8afa33ac43369c2493a4864fa21e2bc0bf8d3b2e9a34008b61af64f1b42b2ced92634c7539ebd32e01631b943191dc8904aa26520408eb01c82c4cfbc01fa309a59d5648d4c153969261715c684a6ad7eb8778d51bb8965de9145943a31162c486107deb3fdfc406399e6b9fbcf6445b2def9efa80dfef04b7b217df95452a2914e9b147905e5921804c312e5e2a7bb91e869b110c8750358c67a0b58adcf922ec9fab0018ad3ccdd3c1969c396b8179ce81982bfaf23e42218a836813a9150e617780bd65546c9f1d29479c6f61d0131448ea0f6f22774aa71036e628e4c5b53db162039dacee43d5f4a1b552f5c5930d57773f3f7df1a51f6367b00a0089e1a7bcc1b82fc18e994eb57b93918ff354fde140154452b0a9f90fc60d1f75124a11c5930f0aefd688f6b7fc8fdc4dfdc541ad468a74a330bf5706811da04add073c700ce43fcebbad409faac35e9cfce992db8c53e0cc71915a129f135924858d00d907870cd6ef1bb09bebfaec5c07fa78cec0fbb027127dbc15fa7342eaca944f0d2da86e8380a5b4fccade63bdfd9cdfd362719e279a8c22a7bb1ab0d53236fa39d1d1c6513394ada56e0f6c18f6733cd9a1151b07240d8405b89ec0e61aae5284eaa2c3774a85e91316da825c99c6a457d521aa4f5b7460b6d5b0f0a9bfc8940b80dc954d560c539579820baae8f9411fd1eb3da84fb1fa5be16ae541b1ba57bf91c5d70cf99d1b9d191f75a322e2ea4a33efebd93d526885021ec04b5d318b682a931e73b78a264749d344aa4b292be79012a83bf414fac738534a5864024cdf368aaca1996c7efe4c4784da17a9f52eab2b5906c464df3e0744cda5308eb4b798bc8cfa9fbe11c57b4a3c9574a9e6494aa602217db74a06519a035fbd1dff71668f35b5ff31c2d7ac8956d04f5f12b9fb74786e5de656f5350ff8c3664364e2c57b8e8a924f2ded35640e827c14c63b482bf5a398a91adebb976cc03219636e304fc76e1dbf8815d9f906635ddb5b307fbeaf0ed038d349587b1d87804af1dcd5e6e3fab03e868ce0a04a6720f32d385564608cf31c906d33243958592e8aafc9eb771ebf0dd1d3baff7541d75b213c0d15eff855742f283ae37259d7ee30684eaefbc93d2ac110b87e0dbafbd51b1d39106bfaa3f2555ebc7f877c14a0ca53afa6ccc6fa8260fc167cdcb5d700375a12cfd9b4f3d65732081ac094c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
