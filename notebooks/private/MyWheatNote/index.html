<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"518aab7708cda44b84744267a29572850c666e81ca9bda5f40fc507bf26ccbcbd842bb21fab2164f48c42bca142dfb938fdcd9cca53e0b1f19f5123a273ed3b55a8e4eb5a8fb4fcd16190d4dc8e70153c655eac94f74bfd941f45baa25c6e1e3a40991edd711f66569e57d090ae9f18901cff29ee02e38c078469775749bbf2388fdae268ac44e816dbad4d0198f10d8ba443c7703fbf0562fb3aae8182b18676dd4a0b5917bf8922a0d941fa90427135d61aaf0588ebb8436142e89504debf14f382c8a5ec71be0d6da7dd7bbfa0380aa80195b9c0bc74cb0d5761cfbdaa79c9d2f209d0308ee6fdea5ed0a9ea5e68327febd318495ccbf13d06d66d1bb71e3a6897079945b51a0691cfde3af7175cb1eef803cf72167be12362a6697d64106becae6cd20d630f65b8281742f1e954426461abeec1853f10057f71d1688dbf84341eeebd494b47c0139c3ae5eb7c0eda45e11fbe209004dc615e8c32b7572d8cbe41b77983cfbc3add2c99fb691e194de7785d07da0c53bcd618cdd9abb951fff6cb690055eb7c1a13ebfa6ce6aceb9b21a3f266e59195d99a9eced7362f79b85fe0c3de19822306da64ec8ebff7d312e543ba55da1e70f7c9d9766925c8717f289ef9cdc6b44e40260ecd8dae0efbd3d9dba1869746a3e66a76134d5c842d9c678890e9fdf3e1548a627c5da74f9a45fd43b2f0ee19e0b5f288234c57c3843d26e3c18e831dd24291eb6bb3995248ac0265c740d7abe1f7636e4c9f3d9450c51e3f985254c849ca6926aa8431bd4a1a972bf4ddaf04cbb52d787e3bfac4e0ae3428f3e5c8e18320a526cfab9f81c38f0b978a41164195ba30358a01e4dbc80a638a43f228a0990f4a01e7daa95343fd9f3b4e0b11bb6006bad74f547365046be004356c140a39c813c136617c9a1b2e9ce277369498e7bb77997babb5ea2a93b7358c45b93ec23c498daae7e722f27edf26d4b822088b45fc192d0df67e67ea19ff374211e2f05e62f40ae46734bfd77c22eb396a5799b28e2b0034c1a2ada0cbaa97da3d889499044d2a6f1397a34583aecf95705c82b0262eaff081615e17b52e2cdd9daabb0b544d75326014453ec0ed06e9d9fe00e58be538bafd6b0764f5b55ed8ab16c76ed20560ecaa9cfc8acddc95dd0de20e53e6ec43d9a28bd09c686ea8b07506a79de5fa1387eea6a069aefeb137e61953fe4ad83847acd7c1e9afff1ff971e5682f8bdbd7854e1faa9a55c82899cc16a9ff04e465936a1119d07c276c269d0340639203fd46ea5c7082c62c8ebd4816cfd29589256e1bf7a9229fe5220725284d86bb2d0ea89cae14c5837cf2c12a9158b475a23cd9cc400b8c68e69fcec14ed948eb6074d72faffdae10dc48a4c6d38be2a53655238b5b1260c9286b86661e9f7100eb8a99c3739e517669d6fd9dd5515dcc61d485e616be11c8abff29611cae39d9cfbef45352e98e99a8ece0200bd8b3c9a7fbf5ce1b562715e66ee954c22b5ebbb71ab2e038d2764359e3e9c254c19f6452ef9091a1af364d5b1265c8c298e82651ab07ca1b31d6446ad91ecd1ada86a9eb0536661c58614b11b3008fcfa9f20b690c12b9d92338b8a1e87a966c41a797b7bc1bea4ab4c9a0a6ab926bb7019ca591104f9272f8f1922c0c170575052053106a36aa479bbe69442258ffe1d47cd2c35aa95e71831a0589969d89828972637de2829e45fae83d18809d8680ebeb204813d5f09b017b3d0e953e69c07a7f12eec7041d9758afd90710bf9396955b569a439ddd00779216a277c2edd25dd5b657468842b3d667f2b216368d787501527e61c0e8c0dfc534dbb3315c9176dc7220ab71f7fd86601db4b1571f33f852c90becf5c2b43e7fb6ae4d8a4d0f4380ecef4d3af5677151f9c6bbe1a52202a1fd5fd69095034340cb75a6da0f3e62e6fddc3858aa69e461ce8d4ab1676a80857b10e60fd2e904f51da8359db38fe4f479de07bc93c812244b3f6f9702284c884f9eff07425b4fa71c7c6a8235afd383b046a99e0f829171e010d3633fd687e2a2bd45e21e1acd09de4945508513d20317ceba09c85d8bb29fa69dd1ffb009c720dc5bc8dc7faf9875c896508b6099610af4adcfa8bce3260c30ea665df323aa7e329ce37b6889d0226e9393e0ef5059ce84942251c581edefa62c5d7242a422a33670f481792800816f11ee67eeb0d6ba3477fb5f3c221facbe309f6f9a21ebbfd9b31b7ff654c8af007ea22d402635ec9027fcbff26fb9bd5664f7fd6a867fd67358cb0267bc559cf11cdc5dcc9c9010a47e9f87fd1b126211fa663d5b88d2faafd1afff5f4df95b5bca7fe30b48335b889f03068d4714297475e76eec063ec07e2b37a8e3cbf3a3695cec8d5d4eb56635b54f090d127fca5baa004d85810ee46c33054822cd85b24fa5640b9e377b71a5e26c60cb75e9ba91ffa28e3130cbaf489ddb38833114d27c6d5d17215338f5f6cb3df4ed586cc31a8fff0737cfec152ef5a70dc89da35bc91e6207e4dd8cc9781d04e2d43acbea7a8655bf4d8fac126a2a2692d0500d774b7df764fb86e8498281f72351b6bce0321b450f52f7f9e24c9eca17c2f0c23fb56e68608fca67821ca49b8fdbd6e1109f969118aa5566ec325562770d0cb57f6ec15b8137c49b62f8a00ae967570b02bf416510ca1c63570596c1bc3a4befd324c2e4149f3e11a884bd0a0c9e6003bd00baebd65dce945aca6286fe4d585fae6cdfdf31aaff6f9a1b62ec06a1e3eeab678c9eaebb7ff1a6e11d4425387b1fd7d813dde63554dddb6139897b5f7a22fa8e1e6f9b99f19286767f266a34ab07192e2c39f970a5396719f9b5d17fe15aefefafc53e25e14a7effa337f2622eadc6375e18327add50ccd6f99a875fbf24b050f1bc38d1362ffbea4c731e7acb68579c34b85ab8fb1e09eec0428689145630d732dd0276814497d8b080b10f664e1027c2c63c545e191f0eba1c09e8ad67d920ed22fed004f92ae1526cd1dd38d9ab7fd154a7620a7f3717a88d314825e9c35566a519716747124dad8b3e319f17fb3e86c534a29dc214dc2bba98410d048540cd4e25b28a0c1ddca5d4980545cc293945dfc06386aed5937dfb3b0fab519b8b9839f1b2f45d12fffe0700e29a9d7639e3a13a04f6ea2916e4f9dd29d798a578fe828525678ab5ead4e4647b91a9c33d7508efbd5a7fd7de7e06f3c7bd752463d469a57f6d7d3321e8b3399983029331f515a6c2d5b452fa8299778a13ba7e818a84d2666b28537fb6cbe5eed9466d327937d974f7cd1d8e026bffe592880f9395c64a5ec5cf96640b73a36cfbb051355898ced1dfd08f9175d8629ff8c43c586fec2096acd240c20d3ce35645cc6a2076c25b3b144590728370ed5f2826715d3c3ff7b9021d425c9485046a6daa41abf1aaf4499963fc6b614ed2dc9364a940a2fdbaaf58289fc5b33dc7a539e01d93d4329554a0ea8209637a69dac9d60e5c388957b2be2bb06cc1cd892ecf0ffd9f28ba028d8ea381b82d4133adc559b5f0c707ae3989f2fd4ed3ed1a0a6f299eeec16654e90984956b5486873de62104353618f200b90e3e6fa6805d336e352e894fd78d3f21f1fc573cbed7c3b6078724f161c577d8b6653cf9c3ec709370f036d8e6f901ce6e3258f0204e1b40c5dcad94086829ae654d80ff909760d9f221b90e025d252a2caa28ab860d7884eb8a4997b264eae310f1705ef5efdf2758bda82b3a222433cbc82781837c0c64fe71e360b1eeac2bfb027a2105c914ca982dda976cea0f21b6a15c915f55cc748824b1c8b0656cdab408f7fb45b1b92b7ee2b284898dd81a2dc18d46ca0031660230fb3bfda67042558625f02a588f4a499fc5041f585203d9688f16245e55f35e3461a13425a05af48393836ee1ae2dd654d39d4795cf7a067596f4489a09d13c19a386673d2737fcbae0a61ca951cc191951bf9ab4b3762f865ef6f1d92ccc7198bd0219d841caa7625f8929786337e29267b4557e9a37c50c73599099719139a99bacc530229e55ea3b4614cc669b956202e6f06745c5d2ee66fc4cead9fc04b4ee88dadd8a6cd18ee143428c105622f5389f365b06cb0769e8892ff49911139cdb8b29a05d6d4f897fc19e625fe74218a4e1347137a371ec146c07062479b11ea3ac74ddca89f5293f0509b2482c4ec093b686af0ecfd1453b68de35625963ed5f84a5b5768f528c7e4ce45861b74dbe6af9a1502a3bf94370618c7457c5ce4c4a3613804d7a1d880be5c2d9d4c447a117e519f6fd4f67ec0e68df4643c0cd67b1e6b8fe196144f3d86ed11e3f0d1f7867c328ad2cd2b8a1f33eab590538e5eb835679f7ee3f1811eea713245fce6b1f9fde3fbdf1d55fbb0f2bb3e63d015fa9fba4b0cfe21f1ec8d523aafa1c2ef6c62fe687c0deb821744dacbb2459c76c4160b591629dda01e577540b29d5548eae1edc673408539493a67fb63fb1de006712ca233147396640bbf7bbfd168b31bfad672ca6da1d7ff936c3be1570825df29466f3298581cd0a3e38a7ee708c4e086281073dcf0b34352f49fba22b82ba5cbf3f940420204753e6ab972f86ba9a0621acf0bc65a6921b5169f9550dd1acc2309b44d5603d54e4731ddaabb606afbf3ea0fb2f0fe2f195e262f41dde19a3d703156d17688ef821a0d0a6993bafb9935d590d8cf0ea0285819852629efbe9d39b1061d6f5a7df37f9cef10c2593f4aaf5f565f249a436e088e89a40b6c08d261345f0c066ea747a2789cd686621e469e510440128458b5758c6231887d9b17fddd71a2c413154b9af91ab355eb4d53eacb714c4233999660b586b13e6c117989b0eccc116c9ac07551fcd5911e1dfc9336d22c1aef8cb47b4b9709a12baba6636e58fdc5689fff1e82e93081dbfd9368bbf3c23c0ba0c11f1d8ed45250ed790b2d169c37d28e9aff6e220a740e8be7d2069cb61f933a1082e8e19232a55c80a7002bc97a650ba6d0f0dc832c10e8df1917b9a4cf7727617cafbae1ea7e3d1224a9692e105808a2043bdb25e7c83cb68c543820bedec4ce3f6e8cb519d55e83ae6887d5631b242fed50cdabbd45bd7c55a9b88554cd9c6067c6f9334eded75fa11010d02c3366d70a0a858ae0b336698605ced249929c4331d717491a4e75d4e75bbcbc4cff96f3ce5766415c979250f52055688bf1396604e466d4f325798624b75956265d71a40867046fae74d5ac16665a022a287356a80d4ae558bc7596d6a929b622b188f19e143ee4c047391d0d76da3d4b499059478a05343617f025108ae74ab006d26637fe07709a7611db1fa2c77da42ffd9eefc033d878d46ae2a1fb17a9e3341857d760b4a9ecac2b35cd71664978403a099f15513b7aceb7cf63283c4fa5a873395161891ea07aedbdc4faac9fc4a69eedcb09aa7e26ccb870d7f7fbc51c02b14bdd8e13a035ae9a3cc3f3252650da2048d0b80f9a86a7ec791ca43489f5c0ce8bdd889478f24c998e9ce2c99fa16c7912e8f68fa578eadc4d2dcd63dae4c2414f0de2117a1c5744e39caed05a226841b80037de3c54abdc6a099dea2b8aec3252495414fbb420fb8fc7718b670145578b90aca853c5f2c08654dad7b8cd056bd9d3f4294611e532c209da1029e17907c2eb8d32e4de61ccd6e1ff3fa7f781ac7a32406dae714cef77535e26446b55fc78ab3d1540f979858fcaff0ba17c6f3d685741fcf85f7c2c4e328f29e8b36610a30b074441ad97d98aa51904e8d975e9b171157e8b0ae4bad2b0b7a567d85ebdbefde51d2bfd38934d6f184cf3bd7f46cbf14905d36683803e6b7fab656a8daecf55289a90bbe19e9219176994168125ae3325a252c61569346ee8783ef724e10f1afe20d45775dcd4a37a30a03ad21617705f9d0ff6ab5624682b130b2a0332b80c324f0d4e73b40b9521f047f9fd6651ecdb6903e0e014b2e89d9b3af320abeecdcfa9618f9a3187076eb06e34bb63d9820cb4fcc17954c8ad4933ad0335cd5e2198e9ac8d32aaa9f85672d02b6c1e1a6de6a76738021b0989c87c3fb4ae372bce22c2dca7b0042fc262054e24f720b0946ebcb5818204b30be74051952c594aace62fff94eb0187ec22967484c11d9ae29e4ee0bf637efde3e18854275c7b1ee3172767bb8992b1ad718d1395de514aa277b9fe76b16a31f773e6dc0bce22966daf7479c4d53e26aae2d991c4e53b7e2e1a3f7eac127694038bc3216d469c2e61d16e8a17090fbaa2b930a3aca66dbf7194481df8ce6d162df6e6a321badae13496549403f9a5a19219c08d55105db7a5f1944b46f48f372e2dd29abfcab2175d2d03837710eff95649dbb48c6a7e51ff74552c5878bdd9b7b8894504726d12e2d6c70111052af4d3732ff59667505723d9378d9ca12f9e5cb7a3560bfae065da4674dad3f607a0c738a66a94b3067285437d6a1c58c3a4223dbca524a4acb375d81dec4319ac0ebdbbeab6db03738bd80fe08194f9010025f92f551a5a0977ca4d0a748bae5d3012adfebc4bac7e154ef8fc5842abffcd6af856ba72f071fcafec64b2f3724f4b88af07afc731c2cbc08493f0eb142f4000ca7be89647b3468aebc498efa279815d5f3ca2a1aa5fc17b8b593d89e2a6e0d382e378068ef109ed9ef12e073dd20e000f4f59da6481f73bd884e18ef4dac2ce38859cb7d53d27d5d6c63280e54c9a6ad86fd2f35f5cab38cc5ff8049708fea956e3b614682728e199107b17d1fd220a44f4c9cc5891be6e1b92e7a7b7bc19a55c7c9f98dc615be55eaa6fb4c8537cfb23e000a5a53cee07e9137619a0122349fbb418d9cb71ce55d0e33652e170c217827d93ab2a10ed494712ecfc05511ea97366a95a606b70da362e827fb9891c7a6888eda4ca899d5ae99bec84e313ebb7cc240864ab9d499df8280b5dbe7a8cb2b9650df1be49c4b75a9fd9c1f5a5e6337fef41ae30e9019f42fd9d860306dd04dbdbde7c60a24d49d1c585d6ef572ede8da3d7efbc9a0697cf520e7a2ce51bae5fa2a81255d45503166025fafa22d550234747dd356043e7d0247f1bb422649bec770a152dd5f7f9e2fca075195080e04ee189bfc522300771aa4a8ae8c9c0688fc4d015f8b8238a96236ca756f963657c5bea15c0788217f1bf6665dbbc2f68a60c98620197b53a1a2559aadfa4d07148db700a1be5b321c88fa759ff7f07b021c5619d477706262883bdee236539d4e1fe71d4f546f76fe5f7682bafa13d1f0bd498e6a4b080d23883551bed40e2af7beab39ee58312dab3aa2d2f22586edcaca2b078cf3e924e5fd63ba95286a0de3f29e1cb5ae261a6280f4d5550693d461b67f79db1ff5420b3c282d5c6af4c78d7e49b675dc64e1379df4164cd42719d4f6d39960487c82dbaa2675b645eba0b741ad0c2db5b79c430b2fd2df012c361b5fd1328cb08f9129ef71c48ecfc7d07cd13f60e37308d3f751918604e3066852ba79bbec87b10e9a641327c1f0df396f9338a8d055f226d119885d589169a8fc6519b4ca2981d3afb3320abcbb432c995f385f9e401a514fb87e0f8393c855b1bd12fa71d23d12163ea1dfd8efa72758b8383ca3edb842974398b54141d7accd17f4db712b778de324e885af84f5d4b114074bc1024422d7493ca785643fc5e070876d0e314de7ba310d45b7cb7f8945597d6ea711d431d9307ba435bd6933f6ead313bc99becd68c35b0c08c3bd41d5b916a0e0bb5b990e3644697658910a2aed06d189dd0201c063633a343b584c1e29cafb0beba648269da5aa86c9fc9889e861291c8ee9ecc3e4bb5ee4550a8d083a10faab2953ab1e3ccb7b239131d4a16592aaa486501d9cb241fc3e290b75aa8de31b875103ace4fc80dc05fd529a7f311918777c588da74a3dba6e07e00d7232ea92deeef2e43d2c982ab80835e1def3543bd8660e53ad8770cac45ab987a536f2c927a1a4e24aa0bd7b293608da79690ee53b024e5ea056fb2066cb23e081b6d6406fc50c76df76a99552c3749cc79c86b17bc2af5d99ad7d9a5340cafc03e72bb5a5b921480e1911275eece546ed7d4c0c06f2d33b34ab52cc43c9bf5309c8b0782c1dbfd2dba29459042b10bfbed97abecceb5c0f7bbf9b84700fe28273bab5274f73dc3a99ef68fccfffba4fa4e220b843c2984cc81c51ab9a4cb25726ef3294ac22c4f9112d597a111e64b779491189bad4cafaf65d45a41e81d3becd7eaf5ee9b42aa688ee7d3829344074b50a64bfa6ed3caa8472a9a168d2736ec117365cd93c7d9a11c7cc73e7b0b8e1cb0674aa6846c99c09b500293b35dff5ed9ffedd3ba263a12756e0112f5da67b8c5f8242b58af76dd16401ec666b38eaa868cc1676140f03641f1b8ddedcdc22ec17ceb297dd77bd3f4beee368efd1d7d3d791f50590f8007d0d991ebfd89971e3361a2fad3e0de6d48895672f7ac09a0c360760e7979896fa26de24d79583042dbd467fd5f2ef7a5faec2ab71abdd619584198c95487cefd8ba2b997d12556a30b2e5bfffc636ee281932c8b98bc188747e139ba30b90d9fc2866991ab06856c18777d227ad3fba578e72795d34928cece525503dcf1dedf698e553e885b31a447edbb933f70a9700a9b98eea5459109960d8c48857eebb89a8fb78df78053900bff1eba84f12667e4f66d31549abd2d8c69423a8cab7b05b70b2b903ed83938bbae390e749e358c046f59b95da1c4c79c0058ab2ee15f2b8490ce8937a81d932be62aff8bd09d10e0d86ff9981652a58b1ea0fbb15c7f41519f9161c76bc64082fc95c847dcf0b29e715d10c5b55df92dee934ccfd46d09e1c49ba5e4ccca8a4634c2062ab41d92526985e3d511ed896fb5de99dfff5cd468c5614386e3950218b07666d14931f9c6601e891efb6ed6b9a82d618bc32437f673c06884847a9c99f2197bad912bd8318704cec397d8e1d685cdac08c714921d094628f366120b2552d6a913285a5d250f553f3dc3a5d6f612e09b92aaaea635d5e22abc343d730acb228f06bcdef40cfbe7938af55d37a2d9ebd8c7103b69dd9f247a3b2d36386e3b72856c18fb4325b871f6cfe53f3f736e771cdf4d5868f91d490a239ae7381c4de6dd7861de2b0b09e51a3ca2e1aa42f4fd46f7242e00bfc88943bf9ad237605c124a76349aa30cf6194a7e1a6b56698a3668766fd9a3de84541efc6b111440ab3325d85102d3905c4356fa7fa700d7d34ed59a8faf5aa629cb62f7a8259107f0a3d5ed5f4e6ca133c8e9ef2d2d196a955245929a4aade7cc7839c59a1efa9363e344bd686263f6bd5fec1617a5ce041af7fc7953b2d7a8b5b73002c94fc3fe6ffade8f7033efb0703800fed35955d0da28617adaedccb3baf848c587140575800908ce7293c57dd9311022565dd6df1cdd33d510a04cde6a3ff3eb1c72ccd053fa90c3a5d63c02991c3fe447a26bb233fdf40210b1dd82a6e02552d38055c390a32055eb5376b51c072f301931bd3ef508a288a61d6b30279e22c26a61a1dd2c1e0a32680c9333a7ddf8b6f583d6f1d7d36caddc1999bfc8330ab25ca44841fdf058fb17bf9c1230430a770b5e9a9730968e1a9ce888bbaa543288da314ae8b9189ea28d1a97938d8ce36e8e1e0b28a41de856daf56793c9b0110e74bcb276856eec7d80220d61cd2721e241257a5148dcb1d2ba26e177f43abd0e22ead2ef27d388dab8ec983858140a0355e3e26db04054a016d946597b4695097aa12571541369ad2183eb958fa87e053992b518704db958a3f399b86efced6d21776cf767c8a257a8a6d60bd9df4bc219a8cf3958bf85f52fd8a190f2796645839dee59832457a3a3e6a973f2b0f0b8a6ac30f7ec1ffeed9b1592dac6029debf722152a9a9c2985cfcd526c88fe27d7e52f41c06b94a8e0d2821b4a09870ee26b6a0a0d22d93256f98ab3f73a048849cc429f21a423834b80bf478e727de3936c64f9ec27d678152a6cf5fd3e127f7086221db8b2552d2a5224d372f07a2ec33a2076830704cf20b9d1c51da16431dfe0615d35eba0b4aff5e679272047c1373043e5244a9063030ff41b3ee1f59c51e49b8d57391f882ff5eec6e1169e48ec4cd38f308e7373e02af42039044579235acdb37c9969901e1311a4f820a0c14b317cff49071c0f8512595f6580414a646d4aa28b228ed8a118bbd17a255e34d6dfa7f31c88bbded09f26e4904855cf301510658078fe694cd176bef2f91264adbcabc75d9f333a02fbd9d5b03bbdb7fe13358726d84c343236a632bcbafa71d3c379a96bdf586ba5afeb2f062394de45c90b40eca1e4aca19f2bf66f2c8a05b6262e65f9880b62fb1934f2e1b0750b8c1e974a07523daada76c70a1bc8438b476a6eaff041ce33235efb95821bcc27f25ed4a7acd62ea70b438c02970e86e9c50d4604c9f011b050e34ef98fc374438d1414b49d0ee9fb8656b542593b7adb2b8f01a2534bc579bdab0fa5dc7b220b9eea091d1f41e7a01a870988bc93e7ff4a4410d3c675f3c9d8eaf98b2bbd3b4705b5271eab2423d09b89e51d90f8489286829ca64958c8a74fb8a97b383b0a443eac1dcb2b53db2dcd9714883b12670c8481d8dda1173703a9528f73bddbf5ef3a2a592d16181caa32202d5f8e8f38aeffa4cb87217ac5db4eced114414e45bd77fa69099df8dfd264ba9537825210ea01134a6e2ee87e5c16aee2311bff1e888a212124098981be8c96b047f3b7397b0b2e1373e9dbeb9692bb696852844938fac9cf938e6156908b0e62927780aa3d676cbc2795389a1096e4442c5b11dff2a5bfe416cc97ba953f90905120adb5e0dda270899eb9b7279c38ca8ea54005d22bb35c108b043a5a20fcbb839b2a94551e993e9e6cbbe527bd3913bb52db1f51e88f47e31a252c14e1eb70482969421f70601d0e90e0121b76c7fc2a4ff6f49a52d0c5a60d7cc3036a00d51fdefe25b9050eaab0f187b348274f44c6d80dda0f296be34887b373553713b95e1bb3851d27ac100517c7da30b81eb3cdea130decd72e034f51f7fddeeab0ca814a48f37e9e41dd063fb49093a1218adf3d6ba634658555d4cd8ed15a51fb33ede7f9db034130ee9b4d80e5f9f569e8fb67701c7c055046e8d99b329e494ffea2bd10ad31930d125890e3208bbfe7c503cb6444feb513071743767bab4416d7b27ef4073709b5fe7e8817245ed1331c9aa89de93dbdb42910941d347e396ed999f079cc98e33efbd7726267400476dc204f3eb785ab36e1329521532acdb941879a60384a60478b64d4146057295426bc50e4c790155a8a7000d1fc6d37787661ce5be340741885ce26ad982cc5d9cb40b4e386dd22235c83835575d5ad5a4b24a3ea3b471ff4f43a08488995c3b487503c3a107538c4ecd4f4468fc908809cf951d5e9358586882546056d736431601a8db5ccc95e6c33f3f16d9dcdac945f863021e2fafdde2c1915022879929b603f1b3fee9c3508f0d4a930b57cbb71e319099c3942e05c0abeb3ab9d194bcfe27cc8978eb86ab6f499c3a287ba011443a896b2e00bb8e688bb8b77ca5b8a128b94ad5c0c09c51487dd246162356676b0a04544c92e5ae4a9b409b25656d4218b06132ee02337d44af7e10e10ac35bde72236838d119dc6c324a2f2f9fec2727ec4c093c42ad78bfd741816971eb13f2ebe09a1652d971b9fe4e11e72e80feffa51400f33c3642a3625a67da4c4d040f326b00b6a810877876df879d5008488679a434e1fdf81dca5f49d264f8607a390b4ca35fc88efe3d7b405115554df25bff986e5494adf71034d812a7497079a37da345c5e91fd76f9460668128751aa8aa74c83954c25a02c266f6fb6676d67b73e3099b4789a470236c0b7d7c882a6fb5b66dc0fead8f17d638c918ab4395b679dfc56b7497ae48c8bc2d7ab4d4b6ea2b083e624692a38f0d1569e96d42d1e13afe428f5d041e43987b343f8c86ffbc4bbd92bb5898db9f41d120adb5d44055ccf0c3e0adecc51f3badb6e58c7ba319eb4538dd71cf3f4f05c3ecbd83d957f04d220048aaa2e3d75924d544cc7e715adb56e4db689a38b1f2ee3c54f86f0ce59b078e3bc857cd562ef3d5de2a3459bf6ed6482722e5faff7a94ee16d57796855ee23a99688f795e36caa1771ea54d0882274a4f6ecdfa963f8d7b360ce757d66841a8c365336d2e4c3eaa3dca7a2f9a14729658134a74af07fe4104c93a7543eacbf591b38ceaf86dda45fab81fa425d70c6574a549243ecf698a14333d1e98307810773b930297989c7a2d76913c8794aa61d4207d5d62a0cf7efa408a22649fa26d15a548be406fed1c1cd4555f39a3f60d390a2aca2dcc7193d88e4e2daabc999e695446860743eab6227f557573b09261fd4728dd4ab657a88e91d32fdd651135f551b97ebb50f2804974e86cd71324a82df7f61645fd6563f10225643521bea935f57c25afc467db9d115d3a4e0ac01131dd9edd38496e10ae0ce479eedf433d4beb2fbc179f6450625f66f3c3fb7d49ffede114954ec77da560bcac3c4da636b3f127daf9e0802b47b763beec57c53fc03f4428558abf91b778a88bd11d3d75d0163ca516e93a9b88d0174a54c6d8494fdb86570a21b9a23b2def4b128ad681d537608325800a9b51c603fbdac1f9fdd517dae7c503d98f7eb850b74d4c8f002da555c882e8171315551e74298cca8be9aaf47bd82e53cf3bce8bcd71d42e56f699b96281a6fcb21f32e97ba4a6fedcd24d600e55867b2924b081c0ccbf3b9529f60766f141a5fc9de307e3971cb44d95cfdd356cbb8830b75c69b85627d6c75bcc6c1702a02d96c9e9329e5233885c4da4e9c16e5d851788a53ad9537e52681eaa80b041a59cfeb36189b59d247d448fe6af9d9e18d3c070e82941ca4c45e9f7a98aec2543c52aa6af013423b9943a57394ffe4c49c093a5c71e95f3b1159a5493a0e90bbcf41d66528d88dbba8e879d80bc9032f64158bbfe9e8af83e51eaa07145b054ae803e5aa0b56c8dc8c0de91b16b668f44c9db00de39f69c2b4b60a2f66cc09866e0d7c9874f78c7d994fe99eaba8527ebf6e8d0bafa10e8b81f022198bf6c5c64975c7c6867f7ca27e221baa7120ff3e87097cfcd570d835ddc811d6e6f961002c819f71686dbc0108aed72f38b7c50ab2dc3f301a0583b34c60199f46bc18c1d19c3293c502a17800e9ae49be85c398de1c4c8995992a17544de9b42a6fddb7997d58f2730a47887b1cb577325e29ef408165111d668c8114274a775093904f658b0b91d2c1bd413d5aee964861654ba3212b519ec9ddb63ff4c9dc0558b8f69cb65162929e557ee74b0c07ffb3ed26e79950e6d25039af52771a184c77954c4d8a77d7ccd57de6b868cfa12ff41405e3b1fffcf09b308b510822f6a5ca72218ad1a85800829952eb41bd750bb6fe903ffbd4f88686f01b882e1f595464e9740db2f82647a5a48067e1d2f2fcd08db5ed9c23ef2dc3a4bc6164a3e29c02fbc408c5ab110b5fb0c68c7620010c3bbc720692229f80a2e8b3331b8afc7ad16b96e467f426b86898a2551703957e78fc5edf206c2468b7ce40bb51d538006cd602783b8b238d6a73a247ffc8a2f33650c41a149298ca00ee7c4840c92ec01b599d57f0f6b6cb9ef191b3cc6a9b5fdc37650bf8e046a2ef23a1d998944caafbdf03ec4482b2557d5cf4dc120f43bae2a01676bf6f7dc5dc7499714e6384c32cf65c74a113bedb22abc08583806ffcee034319a9cf27749d8c5a4e837ab3c1967234cd3177c8d144f7174a98d40bb936a0db431270a260d6ddb23716e978b0fad4eb25b76d4c52d4ff89eda804b6c5a2b19d1820d44de56e32fa4bca9f9c02a59f79a19766f69d917a78472bfbc750870cabe9f0f7b6a62ead44dcefda833cdf98e61f5255e01dec79254cb32f6a2dbb74486b0281f8b52dea5dbada5cae33ecaeb18d74e93b63150f32fe62d09560c70667a271b46941ea73a1a7d986b33ca7e37b91ef814e942967ae81252771e226c85cef5586a03509cce101bebc8a371e6e76da4413893bf8938f3cd68bd60af99ab42601cbbcfff3f0f5ca6d6d84362baf0ab67ae2412be4f80a58c13336313ea6241dd89c9e7a027226c5a33804d6caa0356de533cde7f84d2b5e017c6b04da8747796ac14763754eb860f15f82784b722eeab8a9fa2997a62e8024e8a91201a2ee6c8c4f47c5f1834ca5a54a97cb418aaea3fe23569333beca14d1652abcf3d5210ddf87cd215c84752d256f6ac4080cb5b2e95406028eeb58ab32d429d07d089aca39d106dc6c2e8a671f4c1407a946fbfc6408c5c0f957c25d29cd9b447cf469ca2eecb5d4a6c33d91c1ae48e546c111fdac6009ea0d41218877591d6a8d390944923f4c8f08d55d0eae0bdf6d4c2e3e3f5d1d67a4ac681fdcf039617afa95f573f2a2cac653de7be89ba940c16a7529d5e63f7f6863015a435eadbf7d813a61aafbe14f3766a819b6c0b2c410195bdfbc4ba654243a39a6f3a3df6a79075c370fa3a19537f51f6c484fe6bb101358ed5eb74ffe142e604d42ce80ad891d0cefa53a5c65845fc4f35d2102e1b85cfe8eff8899853f0218683549f8b46944d8987908fb7485ce940a77affe36185a2ab1c11205f43f88ab564fc3fee893a510d503bc1dba944df1a962f7bd189c1aed65dad6734798422b90b8fef4d02b6b2764d95ce08cd78d2ac4fef69ccc0f1f2fb1600601fff554fd589f0b4aa9fa3b9c4b455e2a29e1277388fc53b51ac5cdcb485b205bf1ccba0e1b863fd7c13bf6ecb5204e7f0298bcc9590e8498a5899376301011763266cc4d567b14fbbde99811a3d468a2567a30567c12759a0a1877e327e85ae83cdf974117dadeb0ed933571c4dc3f2c20610b6f31681254ab0f0b6c5223bf842e491d54ca414f658eef4735f6ff881fc0c79fdf6a43db6f9b18dc5e4b72276983d4a2d3ec8eba806950b6f741bad781590f71813e96bba9662eeca7d63a60f61b3c8ff070450c45a8d22370d7a51a1b859cdbfecf0eb768f60bf6a2c4156bdce67c9eadf4f9289d5f67703dc8d44588c1a86c433993456b716156506b70f2930aab40ff7a84e4d3714983030e416da04095ac04157ed1ff669e6b817242b729bff226c24cc712f2ca215109384b4d13df1008360d9d772c9171b030fdce41a3d9991c71b82b9dc0e9cc9aa3375e2097308f48770dde85e42e30854e4672ae44b43e75380986376b4599b604f986337dae76ba087ae5039a6f4046496e3dc8a42e5badaa0657f412528bd0de94da4d34a67ef54c21bbd8a3ba71fd742350e5e2fbe3675816b0ad09e26c43bdcff918aa043ac3de2ebe5ec99eeae38d4e794b0c9cb583788c1d89f74a38e7295721af7f4ae48201c0a217158bc1f8259a6861fef4fc309b2ae13620c0eaba5afe4f93761a472c64604114461c3025cf6d8549976bc291795e30e93f1c2c09653f8b405b8e9983a5574566b403f85e028ca842625b55c0070557a5056b43f9b2f93bee7f2851bd6409efbaad680c446b30e5c5d6252d5a2d7164e5889d1214dcf1e039d50e47f83477397fb7386ec8d64358a0856701faf83f2c0e231d68727fcb8a01b40be700c7caa4d4cda94aad1966f14754269cd9dc29af4d54fc9ca002b4963ac518eaf5d6e243635147974475dfe856e1b187a635bd735d080943987a174cdddc99d546076daa0c96c119043b513e1f04307d9e59b148d652375bc84f9289f14edf450469ea64ba1571acf2ff8ad82aef5906e5a315e2890b6b290d595fce97486998c9747aeeba19f3afb891c6903d3ef2698e8cd502d4ddb0505817342e67ce6451ccaa0cc9ef3d6e3ed9468daf90fb2ee3990bc1fd4d4e31f1530972f14a861d55194b4f99f99a642b63d6f4e72e4e71d9a61adb75338ee7accd7a7523757199674d3d80aaff46b6e9ee133aa4ebdadbd6e712eb9fd1c870e014409cc0edf942c089e42c64cfe51dcb185168319b6b97f612aeaaac30ce2a8f7d65cb0fa18a4c29a28955b8a2c1f027d7f23561938db819294b89533d5aa731796fde4cab59937e49fc4ebcc85744d558cd814acde1b67ab2695a416dad1711ea1b430f72940f3d88cc226183b82a7f0b22728d1ba0be2af9b22437e5cc6f9388025a72ac1313e0cc12f979f7d5fc2e1b35733104983c1543bab3a5ab29e052e7f689663bbb04c6832cc30489a48b26b8e384bde103f16fe7c3f682048b9f13652cba5956dc2417f9e6ee2781514f9f1dfd709b2cfaae17158b6d09297838ccbee15ed61670d447235c28ed2babd373bbc29ea7f5e93a68fd5130f08c61431b6af915c3aa315df5abb63e9cbb7f56cd722b0f1e027de40af3bbeba856eabc8ffb877496eb7b47b168a599fdc32b6e66e3030dc1b9ba10197b4bb8cab82cb563fc9e34982e0315e21f943d37f44633e1196d13f7e814eeca12e75ab537d04f17f6485596b899777f820101da95a00b6fee67e054e68a5e29783b4a1ca893ab95b9179aa8c1e97317abfeb967874ff1e9d2d45b0a1e02e90cb85ee0e5b1fd5f58632448f1a94af32197c6ae5e72ce804e443a6730ae8b8e7554aa4287a9a24e08cb1bc1a48c05c75a8adb14b63fc034b40f278ef1fbfc6e31e473bb6b09c73967c5b5c2db7686f7ecbd6543deffc4da4cebbb1fc3b0dac2539b9021749339bba6423622375e4acaddc54176f0c7026a1dae1a4e1c638ca8038eb5d2b5bc8a0a8f256bada69807d2afa24a58864ed7fb4302619a46fab2c66727c0e16e5799e3e31dfb87af13e1ff79d9060ea68e2f68bde4e3426b0a065d1ab75e6d9549df0b9f627087714050136ac4388de64b821d086c59d4c63cb315501c0b95e8baa59a0b7c8a88a33765710dffeeffa1dae558e1bc389e3c5521985d5a2a5ca0fdde3681a550513f02a2da815bc7e79d426e1cfbcbdb7382530bf17f9aeb883db2d976f7d4ed36c670747775a7c1234963cb5efd277653dcb99d8158ab866fa8daff45bc035297112bbebd14fc770c827ab3e298cbecd27314c555453b0ce96e76ccaf08e773a7c50e00223fa779b602234f02e1bf667d48a6c67b6b0b44a77ae397ae39500aea2a8828e3bfac4647fd7d6072c03f78b8bf98e5dc81f41ad57f1a5a35cda9e1fb4b0f93cf4f1e3caf68a52ac882b1452ffecfb7ccb5807e4d1c3f57e68f7665979b2b63f5380a8844cf53e190d4e28ff81b5b085e975f48b1c40f37baef6ec4b6ac1ad474f15c2a59e1c516a89b579c281a10bcf675257bad42cf36dc1e0450e6cc03215b127c03d40850fcf26b765ac7845516984e897787480f7e4408f66940c3510243a98185e685cfeebb6867defcfbd7eebdfecf58e93e89d80b26a8334c8434ffaa97fbe52d3bd599ab48f8237ffe06ff33b56cbdbf579b31f4cff4de8de74fa0ac5568db609dafead7b110e9c244720bfcc75e0a9a9fc3be1125e32dfacde3a604c28805b09e7b5b5cbd75ac2a9265ca7fd8afabb34b6afbecf716667bd93a55b8c863abd2500b9f8e86d75a0430dee50722414441beab01933176828d30a51e9994e1a3e50ff5af0837b6c88c9a2c09777ed53fa721ced1665494f081682cd365fa9dc3db9380b661959d3a0fcdedc5ef9420ac98a9a79a23a42b84106a0e887c1f58a9f875aa6d7e85fcdebb07fe0a5002365a5d7d386b50eded843edf7192bf0de648348744c7b38a756b00292da67b295b2cead11a42b49ed7bfa9578d4c861635e8fae5c961570bb27096b13f48997a9529b5ae8d802164c4a87b5315c06762c57c2f5c02f9b2ed6fdd8a58cabbb2e23e4e71e6cdc03406b01a624bc774614933d8fd400c7ea528061fbf39702d30711d750c7881a5723b96bb83b5f7f0237547742895a023496ff8d11f4aad6ecf0a8ae91a718a59b6977c455001c763f519ec07af1f84cdafc0893df79bc302598ee594591899245fc540cac19e0b7052eff51bd0070b2fd6f6685539b47d41301424dbdbd61289c7cdbe04ae6a7393612b19d47e3d20d5a22bbb130def9f5f722ad49da5d39dc9caff66be444a997a53a5ebe43ca07dba98ddb5b7e62313330799e7cec88e19c04ced7640ee9ccbc885e466b09d50c08fea3914a4888a08853cf665548c7d5e4ec374c5b8d7fae8b4135d37aff5f9ce5419bdaf5fcbb5702cf565b58b3c42c9e92908eb43cb78640fbf31b47117c20cbe617e4710fc7a36468f0de68df25cd340030d1326cd382670abcb18b8811b69f1e809cd2ff5bf790ac19627ad9c85a6d7bf93a6b1157fbbf432b119ece43b84445387736f0f7d780fc83b6054156861b55f959ea34cd786072877fcb632c5b7c95311c88ffba49338b563f8dd0c4e50fe078b951ab30cbad7a11084008d423fb19ddc918a0b34d1816ccb7a92ff3db007d460c5578e81a4cc0519e759daf4664b4073f39deda75c6010ffdd9163e26e8dcaf73f561f7b985f902379c9f545c8c71fb727b62acb0e9b3f3289b3e9b51f62875c4c848811397c7496ef6fbb1f7c5d17485a77419f920995559b92efb6fa760b8492cda58f30a00990cb1d2ea411c20da96e093a5bc03938d1840777b01558c318da26998890461355b6ea3ede7c7422fd63ba4f1bac8dd1a6a4828b5a9aab541a59487cc89bc660ca54756b32683073976dad819ac803c01d5ca44c84add3bbd9fba6b6223cfbc3b067ddd58e54ba3aa53d68be3da4cf7100d1f7315a6fca79d80ec365470ccc5f6c8738e893462976675d6d1085da2df10f8d663c0b61bd685dc6588e2fff6d04c1d95ad168f44a27f2425472a45f8b3f3237159f8ade1b107d54cdac223853798edaae7a95d6dd8256f29b8f5eff318cb4ba82f8778f882da884e13a0cf9f0eb4c0d3f059f6468482afe8b9126d5e79b8bb8572f68dd6bc3ba574e3ff2eb6a0cbcda1e95541486867510dd4a4925dfcd971cbb6ddebba864cab3fd5ddc876b02d7b23d8174a91e4c1a73c2a8de4fc377085b4b624c796e3ece2a41990669739ef09ee02c82067f7666fff806970714cdd3d10d0a8c92032d7f38bfbac93a6ea85b5edf4ed207d89ef24bcc6edb9b0a4dec88c75d2dbac6c36105f689f6c7d07eaf968f5d1ace6d53f6c31ebf7d52f28958a12c0a69ee63460a5b3d470487fa48c1b13c59ebdbb2ec75fa7a268812425f055df875c3374746447fc141f48ad73c75735b8e4f24c634d0943b895685eadae7d1a09bb0c905f7f66c7db4352655800f5c9b223fb0f50eab1526fc9644a78c49694f5442489aaa607dc739e262fe5919016fcf2cba3c6e4e43143a1c417f44e777104ae3954d157ded4bd4bdb8d3b501f3e4da27ff1ca09dfb3a19822f7d7ef96644606186eb69a5127e8b9608ff186abca703ef266b9b5115752d51c2fdcb230e20aaf9d5bed83061a12fd086371546b60e38f6aa699502e571e6d452912dbab39e3fb65f9927d42a318eef0afae514c07ed3512ce98a87a3886f0b00f8e94b00ca0c426d1685092d5908641480845cc9f749f354dbf5eb945c8b9fbe66f372c8e020649369b1471093d2a3edace2920bec1ccb2065981dcbba2cf23bcb9eae588cf6dfe72027ac290e7459d1039c3ec0f4cb74305b654a8cfa01d630a492e49c051084eebc5a3065425da143a045525a85d906f1bee55d5ee634edf9569accf0af3bbb15420b8ac724b7a046ca96b6daf8d518560082753dc59dc9709e9acbf8fa7d0116f5b509f8e70dfe4843ace4fd3c24221e7d579e231308b4196bb25a021a3afe37fe759fe01fbed794920d920c7c8a0d62208dc2ed08110a369c72846e4b6978ced5bfcd6d3a77d00552130f5c2570f5cc0b0dbe33ca0b5af754ccef89ec6664339d4690b0d1eb66221901b8d036284ee5032733831916b6dabcf0fb8498facc9b62aee10a773af7b3b4dfd8b7e5cf4a5fa7605fe6dfe872fdbd65d071a575c87097b41b33164884e3ef8bccdc35862906fc6c7646aab03a824f5f06087a7f0d80c19fcb7323aad6953f6ac034846ed7a6f3715af6c1624b12addfbc89374e706463de56ecaa587913c66a61ac242c2bfecac6e0a50cac3b47643cd9917af306e05ce3dc504401d2b65939bca497496970b42454df7ef985103df2aecdae27cdd9aea29d8ef296c15b4510103c2bfe8869406171e965772b6297daf441d33665bc4395a2fbb9c04fe2e4b7b9c46883ac4bf302259f5bc7339efdae8f4a9927ebc2e2d60296f18fdc0c971efd845dbf27cae548f0b14b6536997b142519acc9a561b180fa0eb27ee1a5c78e4aea344a73a16d89199365a52df94942ca461f9e15567ae34a6f8d65f18e545bd38cff03cd5d96ddfd3275c1b03dc0cb113e60c201bb74125416e8726d959d0ea7c2ddcd084fa8cf77963f33bba6297522f26bf4cb4a6c3f3e6622d9b23df0d649f9a0051f68365d880c76241e46b1fd42e1983358bd9828a9998290a304726f8112bef21dc396c6a689e4a817775d20447d33a5f7fde5b3be79e9e8dbbb447da725fd6a4f5e45387b32ca1718abdbf9f53f1e6f39896668b0f7e8178752721fe49867babac8693839cf7c6d702a0c686bf0510ea5effcfdd51762dceba1242059ea8415aeca2ce081f303f511edd0d8a6e9e91db64f220c35acdea4a416fdf666b33bd88d2bfcc579a07d6a11adc8b2614b84a3f0b680546c2036bbd7ee428f88a55534b3f536500324909beae43b9133de671068fb01e30d882a46d91c69c072dc7933f286a27c62346494d8d945303cd4af3a52c2b4ee7c7b2881cafdfa4d1dfd7377e8853f902e211f9c4d757500f64ec186c64360ddb8fc11278f38af0d36e4b633b209c5e0d22f3120dc5afb2cdcdffa87388599d48c875c826b4d95ce3eebb063ecbc30987f4ea09ede642d0981a7bd49e039cd59064655ec802541e4d1f07d35aa2b1b8bfe8f4d7d4e17073b8378060f9a364bee466011ebe26e539fa913a6acbc157a4a63c9419166f6196dea534ee3f6203e301c510b98faacd40db50072e14a80daaf29a8d6f95105526171ec3e2abe9cbcf13d052ce27ff514c8b403b414a0a0d7f3b22df2752c6d35672ae367f1dde6ff8c4d30872096f78fae6cdaf62baee15b20acfe3f3c7ee6f9de6dbf1e8b4f4a2f4e5302e55afa2f25064d120d986d3eb12d6dfa3103db34c3d84c260b4461d03bdf420263800ec2a29c7da6c4c487a54dd65fa8f4954e3ab9faef590f58e7f1a8edf64dfc4cc783326db27dfe2a96827806ffc60004df3dfeca7b7f74fa8842593760c04bd5eabd09913c9a7502c0fbde325d43e8ffcf4a605ef83cd4c83f23666f33d22f0e687149124ea3618ac7e7f5e57d72c4c22a18a648ad788bc2ca7610ef27f480","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
