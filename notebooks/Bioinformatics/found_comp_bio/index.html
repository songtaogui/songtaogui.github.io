<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33ec6adafbdf29e217292b9cb810e35c0f46b06cdcb4c35635dc78446c260c1ddb8f34ae660fca0e75905bdcbb5bc5541324b7968cdbd8b1dfc12974e9dd6467f3e1d134073e6346de820908ee51f0830b616ed47eba97ec68a1b2e57a73df99079fc1465f418ec3cff9cac9d71150b23a65e4ca19a54676907079695d7c39f7bfcb5851a4857b60d7c7b9ca113e4f8b55d70fef3a8c9b5b4370d483f07ae5b85ea8fe07cf31e957d07e5421751f77ba6f278100a466bba32a1e0fd6fc6d7cdab7d2b5daa8266951ae61721037ae138e1db7aa0d5084dd013834469cab74dae34703443831451d5368378775fe9ff7603e95b0ba24a9567587307f0367c79ad4441caa5e6c1df43823748c1117826ab7324fce6fa47f6e97b98e15fac1d074ebaa79af7f1fd0db2ed843a8ab1d98595fd75b30f9490b8336b6c750caf0dbbcb7ca00d3253eed480eed5bff657d83187fd57caf2cfda0e1d4192d0889152e48c1bfcd71f3d0407b01b66101a47ae72ff70a6c142b9c3dc0604a8bc8e460deb164891107dac0fe2c3a2cafc70a02463aebd9069f62643e36ec97bfcf0007e8220604dc16b276e6fbcfb618ecf6b46343904d34083427c7af4f935ad765af03e5caa1a771e6dba365c74ce236a7aff416b95f555833a3f2ec454b7cec72053284b612a96560192774a64d5074ff9aaa6f283d467b73469c446c63019fd41efd3ba336316263e6c08159acc6b5a69013ce25d8166f89ce2912eca86fa6f05ba35d4f5918ebf69d9bbcf74e9d552d0ba148fdb810758e1a795cdd3e1221da3d1286489542a7fa305120ad95c128d8afb9e994c14b3e610c6763e57e957ae974f8b81b15f80e6f6b9745a453c9a3ba8f0ebbea5fda1b3b439fea6828a0537b00e45a9151fb62dcafd1a04607db5b2310ba924795d5a1a2f4999fc267461bb6ecadcc18ef4e83058f65b7d3a8abfac5c8428157ca484680b24027ee58d7b362b7237b3049f12e8d6fd35ce7ede42115067f7215d726262357d0701721b1e0296680df3f8665af8bd2d5f9d847a4854b7c6ae7cc078543daa41f82b7d90531c984528df3f5e3240697104ce2d9567fa28685f402799f27194e9b8377c77fabda40f225ac576dfe9925fda52cd311f53d398ea5a81970486f2a642064345aee7c5da118d7db5cfb441bc9df00de29de47b9c0a96d785669cd8fd13e03ebe9cd1083ab180bbcd5d817bb84d626a049006002dda7727a2a7e159218067adc5c76b0aab616af223271052ca31291cabd9b0462017ed4d42300b77e6009bc3f64b560d5ba2f1ddb8466fcd26cf7179e7f5bbe1f34f66cb61afb9c49061ae098883d431264ddb66bf12c8be55025bedf26598038df0282531d598920f5b8c49d6c64c37e9733d0da4b045729034a9dc7c4056088a0d624b6324e45175d37b2995ab5a02e937be0e935584c78b6cc1e1f785d2e4e783458e75355dc1971acaa92e5c337d4e55e78365bf09e541adfb4045e1168d655d4ee8259d27bd92af2c0c5a8c0a96d345d1ab2a12c31e5f89b15761269a827f1b08875796d3bba661185b333fc5556445a7505d9aa8e70152bfcfdd3ed229b546d90f0204353654126b73aa5e2d1b75f81435c7233939a1734c827e6dcd964e249e176fe0d086f5f9e5bbdcf4eb90d42b782dfcc837118088c9715f8e4eff1baa4ff0e5aa0a5662db06e9aad075dfac93de4a5dfbe788d56c063d9b0222baeaf581c6e1670b8ab848f2f0788bfc41d7e9f1b59e3d7b0bd5f7b946ea212be2a11911675c95fa6fb82d8babaeb124cd9bf37cfb8ac60735b858e67dbe3e486236d5eef46c423230da200db47b36df61f552cddc5efa9d99f126dd104157980dba7934aaba4b454b20d57f054d1e8c4ecb5a636fe781f353cb170afce3cb3077ad82e02c0c2fc61a15784e95112d253393bdf9c65e227e816cd0e1509036d0bca2f64c4a836f3155b42fe1332d4b0b905e24be94c6a2c3806f384c3a137c938e09c7fd4561dc034039c4ed31941c86f6f80c20562568be61526e262d6f61eb67427dfd51710cb7ae8ca21d58ed3697c90c11144140e02083d296bcfce29c6c0ba30420e22d5b9079916c409e85b8a6538b478d640923417392d299e9aa471c556d1b320b8447ee464f477772daaa91e44bb2e4f33a072abaafa6a43ef282f99dcbba838ebdf2f449a8700644c4afb3a036c4d5554056bffe248be19ff823a1873761a5ba53b495165706b90282e7410df8574038fcd5a8d73a1ff10b779d77000d93dcdba6023f1456582a29f694969c911c084a2834802aca2c631679edf7b2ba7fdc2534b311125632b4afbe15eedf7dc0fa2c7b089a7f9267b2961b5de6d0d2915173d676a6c9946f9cbacf072389c991fd8df9ba01030a9efa05268f60c56f173d682625f3e06e1796ce93f6e9b9835e76a8c7ef920dfe935de66b4168f0de5e6fabbe604a7686ac9f3d5d326b6a4408373331286dd552e036cb78cc9e885aa03defcdfeea82f857f0b176532ce0c4a85b804ce0acb11d41baaf4f252698e4906ee1634cfe61d9aa5a27f5d3b901c3212e51c732010832d7fe36c2e05684abbeafe0a7e17b818eadcf7d35b0297bcddbeb6f8abf9bc5f1a63704c5b3e30e42f6d7123826bdaa53dd85f143dff744e4e38cf827ad9b2d02d916a78e0796f50e17b0da5cd0b0832228a93b05afd7cd03afaa906433125767896fd69980f1578a4a401bbe4fccfc6bb04330a3cf22ed2e7c7acf05f5d09a4f2e3f69af0a666d3a33afdd071af9288ab393c766fd05b5d5eeb5d5c890bbdfc0f01058c6fd0b7eaee93a75bcef60608b4f292147de95ed1d9cf8fff3a9f9dac4f48034781c0d2f4e442dbff4ca3bc4e03169a41086a3964d472aa2f311ec16129d54232a2a95bf7f8c62e48e898bc0e80180ba4073fd7beb6f031dcda05aa84caaec5d3e5605dc40d607bbbe02c89064e771417c446eeeaa950f57caba0d97021ebbdd30ae0ed130655a22622537bbc89cf63920b9895d10df666785ada687df6f37ba35e75339061881ee786a059ea0fbf0f0f121762992c0f4799a262db95f109e0173e1a8c0b6c3e1d62c54a94807d2e19eb62d7ea81f7a8fea3b43d6e1c1e865c8806d301c9228033ff1597273875c97d6794d15063cb8f4a065234cf60d56b561ce68d6f20cfc66f8d6fc827a089508b9cba864bbcd6bf69d0d57996c24961d096aad14953eaac36c44353e7c872b726a14a4c7fa87f81362a4292bcfee7b593886529a8d9fbc42e2ced94a5c97b2343a40ee1fbecdfec30c52381767064f84783b2865f9ef8d8c09fe19a23ff8efc346a158e4448bc58a4492929837c0a8d319468f6205505b537cb864c549906c26e4791e5efa76f78cf5224526478e94408d0c223de1c8c96e24e3bc640e851d7c4086ac16488a08d0b67be9cd157d2567a1d5c6aaef5ec2c35d736e14ea0f86dd7d82f9bc0fa35d18449994481bacf183c15dcad8682a49c1b1f6aad75f52aba9b56cf76367556128b836d9533fbcd236b88ff5ca6a5b8ccc846e428904a69f56710443832c0e630be38e1cc76eaef9f4239be4133366da892b6da35fb1c73084cbcfb1d5fed70d4785729e923c5d11f731430ff1ba871a19b97b1571954327c97077cf539f6159b5f567e0facaca658a310d6c8a1c8253adf322c4037197dac82123294edf15c7912faeadaabb87c36b80590a3c12e6124106f55279cbf00c8667efbbb2eeb1b926d588b903980759ec2491a9b61b765c98af9295ca7e31a4cd33ae08d65503899f3d5ad2a245bf5bb1cb96bdb8633a68f39dfbb04fc29c57da15f966a1be12c4488875bdd20998db190aca655bb9d18fc68b7e12cb763a9a8f2519a1e4997b2fe55f99f77b8696781c61f231780fea5510d191378d2a884390a4c40e52cd20b634eaaf08981698dd028d54b25a7c970af7a2a6123fc290fd0d225f6daf6c9bff1224b560b7c0c3da60bb8fa4bdc3be27b580c76be8459224076d0addebb13e89d1bd027206af6c943ec9168b9dbff701aee507c8e557c75914663f134dd6197665c19fbb8d1c58857a0b72ef79fc2120946ebfd99db536feed3310967cfc94f34a6481ed390ad6e70b43cd48733e662954ff04282fbaa094397b388f836c58c60cca993e605848bb32d4bec2d1647c55e81a8c75686d0c79146152304a44a4b6f6ec0818dce5f18c357c8ada69acdf246651e836cf4033e5d6495b5768f21a356fb5f247464240ea255ba1084bd652769d514dfabe2cd0a8f5788fef957eaf53606849a07fdb145823fc6665205307261815512f9e66f0c158f44390c75f83d9a595ee696f77282346d5b107367ea4527dbfe3b5478214086fce70ac92f12a39fd6190eced467ee5ed4a47f50dce8762cd9254a54f7a056dfa335af77bc6e3eb4151a50e6d299e744ab6a13192497446174b8dfefaeb0a81c87c970bf63394ae2e03c075d92c0a5eca6b2b1644364d9fe6eb5d1de5fa89d0890e1cabaedda360b9c1d1867a656d25268dd3dae316ced93ef547ace4aedbac9b1febe895d3e209339702d4fce1e3ed9f2fed1dc34dea7e6cdfea5c9372c5bc4e3129c97d3ca432a61ee608e6f4bcbcf10e7aece6cf33c46157c953a750263c9bc92b2781f41fd164d5d71da9df1441bcddac45b38ab39f35a86460561665f03ce0081a0fee824996ac885e08ec048994e5156e012feded76df37905ec35210d59df441b5492565f7d0c5d79f9e43bd14e90e0547d817927cdaca9908f06828c6b40e6519ff8fab72d1c3c7d6735b61463d6072b9b3a672c3fcceb3f5e12ca82572d41f1a2cf80a3beba7f5b3e0712e7c2ae289dc089dc7de0df8f37aef7d5c2585dad0a135304b31f856c187906a54e65b9c4b850af2adbb3fe2272b788e8edbc3e3ccf67417132a53d48caf7ecfe4843c2274dc42a64a43ffbd2823c56f9b1398f0ad3c8d3e6b1904227be3f8f6d8dd2292005078da30dd4e0584a788cb2c7578aaaa4054bf992f5d74b1d16b3634eab5e5fe2ce791974266589be53ce313d9cc2cce20ec6909cc727aff07461efa5f46a5d98442cd92081725c0143d01e41c28e68578e2f19a751f34691c471e81b0f1b2e767de36efba282774ad5ca892551dca462d05f1129e9444f498d6ced544de8da37f996063453070b0f05c980c878f661c118eefd8deca8270a814f69af2383b60b9e1eb5e2633c39d9ae3623e456153749e38969a84ff0dd8a2779942a41ff838e7c74a83a19090c26a0e031b4ea13839a954c3412d455d84c1f4b42933cf9c32e6b32a66566971cb903dc02351afc559549e2da2f8993181518f8a486b5399125b40c08735d5075f888aa67bc1e11f278b0dc835b2002ab189e5d63746740ceeaa440b9bbcc86c50a05645e7f7f724b27ea44a2a751311c565d8abd0e63ea054c1e0df9e430b73aad95b16bf1285455f7082cdfba067eb5460eaf83c77bc3ab0fa473bf02805e3c78631db62435634a390487e5572e9cec93e8a8d41381b85a0cfb6e54689469a2a8b6de0545a833dc2345b99704042789edd20945cd7351443bc9d373d57bd714363ce21b5fce08d51e4accda63241b072a6d7d1f6184426d559f0c34a5fd2055a135facc60661f0e31181259d84b7ab264235fc8aa7a7469be1c126d5a37764b4f66e4dcbe43589060986499dfa7dafe3abc3a8291c053f14d697c3e221ac30460134336f9a00d2b085045d5fa3b73d231a48885008c6b261b5b7b779622e238753d93680576d489572c5c81006c41eaa48773309968319225d19a45069ee1355abdc76409a4e8f248cdd7cd3400cb1b3cca040f86571b7481fc41a3f8e2953f36ed9113e2d68a510cb329251f4965924d54ef2d5e1c2d8d0931bc10bbb56417e2817c4827139a9b9e343a4d3bbfd7243c2da8d3314fcd176ecc35ebe4b7afedf4133fb874e035eec8cc4a3b0bcdbef19135107d61956d6a0c44ac6dc267a07be58f8a7bfd5feb21d0aa3f7a1383283e45a48fa82bd6b841ffd45e5830f29e421d8114f5fa7cc5b65d8e9f8a48930a65a94205c2c488d605b769447df808b8f60cf6691214c213c5156b2d8f87c3e64e174ebf6cc218725259013b7deb2f7d4eac11b82621dd5a60025c9de56902d7c79ec5f3202b20edcb35467ae11265072f1c9f15f5dc6e8e43260e49580ddae630ec6b81ae9d604885c1867b047acc921294b1a3b91f7d9516674d02b24460e2ddfc3c688384be7b6759fa8feef1f41d1fb888f767f46e0117c7d383571a7ab0e9bb44d2f1e8b130361dbc03158713c60670259f04aff7a3dd00be39c53362674836ea02449e1d50db25d84465d4026e2d865d34400e5d6b760196b28587961a4c5bf0eeff96eac5fd947cabe4d219a41dc47d22715d652676aa96ca6fcd30a6e11844af2043d4735d990d13fa0b616ac91b727a99d2aa1ed33b55650c84600c2cfc4026b6a46190b7384f77d3b7615a7b15bc1938dd7a710946e2ae9dc55e178abb7109f0eae8d2862f94170276f616f9f8903d219d7d0d8484c3605e3e30de0858d97e49a34a950fcf6a8d02ab691c873784f853120af2714d47a60cbe321dbc81c5719ab748c1f8a64b8a6bdb7cc8b3c2fe08a05522adb8ba97a647476df0023d0e85392c4e337632e6488459b79245cb7f19b89d59af34986b520f675e2a45fb8bd7ade77fbe22231bf60a809d9018d7e4a9234f0af43b349cf4818bccb8e66a5b4c1ff257271574b65bfcf8f5a0b0f490c5c4369480a0a3aff4ae1cff46e63b779cbe97edfa4695a5109f2dbc9dbc238f26cdf1c29090b0e256e389b00d9e346820a9ef5f1a62936c4308a5dd9a2564f61eca7355b4a91d393fa4af640715cb9ca13c6200499822e8d32113a98493535f6c7e2b07506bfa56e86f4b8d4ff9900c50138441c0781e0a701fcd311117faed4e24a05f2f07fde97bacc71dde41318e208888f92fa5506892e61321dfd398811fcbd8ebacdfb97d94701ee29482fcba9ad68707acaf7775ac31fec091ce1ddc2ce10299f5010f0072454aa3d94a0c51fa64e7d4ad78f2f3ee2b3f99160c1c13269c4f76ab5609866405bc8cb10b6f390d9b7bea68e39e0451850253977113b23da35118858abccd2af83f8d65fc88e74d8f95d14bcea100ca37dc14ca716177c88bbde40f9458b0ce86c7032910391befc6062056d2c67dcd78b88c1b7cba7d8315cf3f74f6d4c6f3d8f493099025873e7fe2e42a883e95327cc183b22e2b6b2f614cd32238789ad5aad717ff7853f2d8b4ef54f6280084bcfdc1a57e0fe09356339100d67f387bb50800195bb8a841ca00e83e135921371b13010f2ca72973463f2313eff3411254053ded8ac83bc16dadfcf603ad95e4e0d514fe92ea3c0f893272471299ecc6c3f2ada186e0b57a6b6ade6f5e091cabaa8f9e2d54b8f996bfebc7fc60d4a7a2e8f09d0f47565f35dc4afd2c47444f5925bba90e66b4848165ba033cf792d840a4ab5bdc7df8b908055cda5df5d200c9d06cd09dbe537ce4a8d686f635c00c21029ffc1179e525694db68c198cb03dc36fc59968573cf66c11b901efb2bda0e6bb2081385e1d65dc4e6ae3593b6731948fdece1390c32be8d7a30e0db0a774f4733521966eeefc0276c0c67f652474af5a3b7bd6f8b4e519a8f6bbde678d1bb3c2db80b490ba0194db40d5a0675828953e93455c00b108698e1aa95fc94a9661bca69a4f7b2a12b02adb9b45d211b2311a38254a4092edaa34bd83b6d9bbabbf70c7005e9ad02392584c050123161985ad228b21e18500bef3246c29e0f9ab191e7cafb3a281dc88f40430b9de3837bb8b85333ceed6429781b8a89c6d84daf8c2bd1e57132f274b0e4a2201aa28c54954e58fb97d163b2dec67650b7d742d595e50538ca060c3e514b10c909d91d309ce576aca61fb8c0eb30090701c7921d8e5c9accc8e72473d0bb7f43e23b14b4ac4ec889cee743581222ddd2574df812a3a79ba9c3a3dd83c5232cd2696b792162513ea14e12e1ac61209d6204c25e1b40c543c48f0a4161706ed7a023377e44081d0765c5c5789b8832873164c71a05c6131d895f3513db5421a888a9fe9d891d147d8988529691a1420c2ae7f9974dc5aef86d6f1ee7fd671027ae7db9298e559c151b3432422d38adf1d2cbe9a0252e5469ffde6626e81b1445ebdc0c0826cf6965571dc4ab67e35866284ac6c879ea18cf7d0d5ad0981d053c3fd5dd793816c9d09f9b9c903ce89c94b45940e5170ab217177e1e5aab2b202e09ac25eaafc5b4198ea240ebafded769f81b2741597016cfb01fccc6044eabd74f65750c4f1313e6f847add2311c5f405bc82323c12072d1d84005775c97aeb510fe2bd98ddf09b1bd9b17818a48b5d8fa28726431a41941495a0dbce9cb5fda086e49691aa71b76dbc73b4f5477f52a0bb5d9b762f778feb6ac6258535947103b0de32aca2dbda791e1a123b358e07f916221750da8ab28dfedb4a6778390a26e78808401ff13778d62eb089f81fd8648ea90a1d925fe63ce5ab14844ebd93f0afd463b6f2b6fc21e8818d53601313b6f42cd73740f63c49388c0eb54bac15c61208a8ea9fc7885e15e8674dc0c277bca7a1ace95305a7743c8eb475e3b5f265bf5c4ad950d705ffa1eecf0096aa04a1efef333cfaa00832e17f2996cc625d04d43dc54e8ac285fd62c9bc1bfb50f470cc6ea2e28c3793171fd8bdb0432570325106dbf5a2bc5b7a3e1144a7ef4b14284f6c60718292fca42888a38ef053ecf061a9efe2f27365c8011875cda0b65a2248602c3bdc5310ea1b6539833a085306763523fec45b13759b45cd05cbc30395ae2fe3859ff0db679ca7c3c6cbd4eef400910879e1c6426dc85bfc6313ae474ef6a185d7d2b2a7b4efdc0f42aea8710de6e6a9ba3a17cf8c7bbdc60ae3f5767d41152ba7413b476b0e4d728b6f43d8b27676d5b9926f4a543b23610708dba1829e2b030a5678403ade3376eedc1a184ebaf4ce79da698a81802a44b7a32738f6cbff0a371ad7747a53d9e754067173cd5bc507ae7a12bac90fcd6d747d1eee80df5406d9b8f9e7b0bcd587804a624d09807a223017a84c31d98bff9e87ff0f3f7019b0cd892022399c4dee5260cb788e2c47f80b1ef5dd63ba277e047529b7ab72a05ae60c640a2cf0be917dc860038dfe005fde9a26558649b0a665eadf18e934a392e84f0d632aefbdc55ffc92560ec0f0f898cea0980a2a7dcff463f577e64942158af7795542db634774cc572d6f87c6dba0296279295a28ea2c0922d6a857451f516f353cd65853d30a6609eb49023c72055f16d6f4b9adb97c9c5f95e90c99fcbeed66af93bfb69026639e7fa90bde13439488141c12f61e8b4da0489132de6760bf75d7b5d1561fc45b8e373c5084f47757555e773bba6a5ad53d151234b07b8e9fd10c4834a0ad3948339ee8b6058916bfbe6f221d5faad67797ff23d60691471432e9649bb053a819a908d1abbbbcbcb0464e14fc5ff7375d21c07a9771647f08b654fa47134f098ec2c46722f2fe63b5204c77ba66bd49e095e5dfd3198a38a4303af67dd377f6603a00332ca032ab930a9e548c6f1887658d5580cfee8b4c396af96fa5d4d390df9baa01dbc5ec3824bdd4fe931f78190072c1e9c84776362b0b1bae99331e7fe8512b4a09c56ca4900d044aeede1b29d33f59eb13c8a17269dd8cf536c5bd2e90a560a025d27c44108d0550208cae5860330768bd6e24ff51589ee85994c9fea8ce0ebf89af2b022e2650d518ea8319e7f818f7a3f4fcebc474a6c24c724ddbaa498cc6751a622e3e0b7b7efe075ef227bc8707b8990a77e910298815df58c43ec882c948bf401343869c5b0c3ada698a2920cd772fb0248f3ff3c2e666c7423f696f20d247d2976e14f370acb26808511cf0bd5a10b2c83449eb1c4fa4498a1d4ee0cbdc4c79c121bb5c90cf9fadd4b70334c670b9ceb741c74a0a1cf0b83670e96dc9b3d2569fdd305ba32149703cb01fbbf82d92202cb9d017b789f504b9470c5fc576efbda78a2855e1f83f7759c0c6af274d1685effaaa98e2ea1a839cf5924156c7a9ab03425662f95061643102be9e724ea762bb2b9bd0d06c3398e030e8d028a07dd245b5c51903e04623daa19d4397df1c1a1e18c9d2ff7fbb90c9d4e0ba4dd6a9598ef2892e587a144dda134bc46e4a0ed2e21a05b766163966f5071a4596057690a9fe70a6f218a2f1978319698ff43fd6cf411e44944183665f7a90552a9ee1c727b4bb11e8a34af49944bc14b3c50643395a02fd960b321bf9b5e0fae7880e8eff9d1ba8346eab1aeb471c8949a1059d76630811a30d4bbf7c568b65a99884f55612350c3363a4b71205a48cb040c86c2fc6e371b963eda5774686abb81c2fbf9850b92d1259c8bbcfa4cf62edb83e84871f369b00ba72ec82bb8d5b6cea928b0184e3f74f901e1c4277bafa766278dbb3b1f578ce0f6d9a6d7fb1ba88649a923d67986a0919de34374dfc565a27d7263f637b47c03083738a17e792286b0138658e66842ea38b8235093d11ad55067a4e3737d9ab8db9b8fa6921ce8ab9283b494201723ed6d257f673a0e4d08eb49d4445268f6ca6e7390d1be3bb82450d8ec33652bbc32e6174663066bd982b1a8eb7c4780e3ddcc0d07f971843e8247b5ed7b24297b7793284fdb31589d819ccdd6dbe0d2870ed3a343ffde859fdbd348f740b2bb0965d8a8032857c3ed3f625ec9db710858ab1d44282aa45bc6c1a98a2923b484dfb0e2c8a7cfcbb45714b277eb3d167c691733cbd77c52e894d29a22bd4c1447b7de18ed3fe0cba79aa6df548d5f39343815e06314a044430fd301d09064108689d88d1f44cf63be09810b64a7705403fa953005d2f5d2a1b3e005a72018dd370c80742709a97287e193e2288aeff9cf3ad1de4cb2ecb510c3c6a8c28f18aca8d4a26943bba59dce5aa8cfefb1ee8eebb0b410924208be313372629516fca28fb8f3a8fafb26bd034dbcf3c50c94adbf3ece84e05166132c5845dc54910e62d6f8cd355a0ebe62af8c64338b9b70a2c96c29ad68e9eeea2c3e65165dfc02b745ae8dfe41598985817ffaa34a43e26922f2c8f5c56de87e878c0816b7c7c6a2385adf8bac6f3cf0ea24460986f8680d7c2f38fcb88489efd6137d996877200f153ee0919c858218bc18ce15d06c1c9c9e0df4ce7dace544054727374caec45eb80f4644202c7489b4b75fb379a226ddfcbb0168f408070da427a72b729fde69455afa5b055e8b251bd4ce6b6d9be8a80a5bd297c59cdc115751c21d2b89c21013fa03c4313e7845464daf06270855d43839038d695de7fb5564410c21ff6b526f48200d6b7a262bb0d6ec5691dbf967ff1bb4fa8819db551991f623d9ca479bce79323d0ada36dc9e6f7bbec060b8f6ac65d5de4ba7f24811943ced2a70e5e57592526314108439c80b458766c880e930614c1c1e2188c8b1f14a1767333b14460c0f65a3c3c95b1e71ffd2dd3e67b7e4db77f71f27b33cc731ad8337bf490a57eb83f1c9d2011ff7c506875cc2b95fa29a8eefda6cc7980974bb235ab690058f623f4c0d6478a5a4f82ece3f8ff9bc91b53b95050246403c33a14f61e74f1ed4a07d2ac4af06dbd193f1108bf0e1466efc5ac0f7d3a0d2d03b6046b5269bd761effff7b730d8bbd734435dd7e7c4903f8903f5d9d265ac93e631330c1292dcf4f1208c1fccb24a0be28b326ec9c5410d089ad912c60a61121d4d72b0e798686cf61f088e9b5dfede0f38f3bc32e4f325ecfabbb4e290056bfbd068b0466415740e8f18ed18533a9515a87c4c0af7bc70c2a31cba3ba45154338666ae6f4b81cae43f11ceecd59389236b9b7ca3984e412efb2e85962fd64d9364c5c3b22398464380cb242c9f0927e8ffcca1451045cceeb9dc085f55720d7cb1797371a6720924abcdd767255232d3cc307166590bb54d682c09f86205d45bcc73eb87bbd1bb2532bec7fe2f31c3e66c6fee1dd58130e99fcaa42e5fc58b78e4fd4ce463f3a3bd9b02bd2e309b00a29401b313585a8f8ebe6616fb40a66270d0606312c5cbbf7713b40b045f6343961a7e832149f36b7ea82c863604ad548fb44f8fa8e9aeb43b3e02dc140773943f17d8151e0b2e4eeeff6771bdeeae019daa70b3529db1c87521b9a9842949cf84f425474c834aef90951c4b6e27ba7c2524ef12e8531279af49bec1a9e3fa6fdb3f208ed2b5a17373051e4f08a7b20492f404a7db5452d38d351755fb16d7d9aa0c5f78a148782769e9c5dee4d8040c163c93d104bae1c9b74e23834ff01fa25936bc21ce7d7e1864d36c054f5e9d8674364052df7f0bc8430736f680b1de6dfc49b8e5fd09d3cd4747f9fe9552b8a8a6938fc8a2c8c899e768d8ef25ce670b650f7ca2e7a44c38ab300f0fced572733f029e1e08290e7ccbfb2beefaa5f1da7eb646b0a94f5146924c25eecae992ddcc03b5056f68bc5791798f6aef41cb9ac0cefe16d7597063efeefecbcc34fbfc56e37d80b1e18073bfcfa57396f2b1724b7b6115005c1082c8fb6142fae62435b3df451d7b7956a39c0345d79939b0ce535ddfb1d36bbd1302029be2a64dcb9be3f559035043c213c72c0ca16c5b79b30d99f99d655c8be503211637631293e626c293f14bb6bf78da422eba37be88ec3af947db6e55330c0c589d70ad9772c799a551fff63375d832a1bc7bee5dd210e11bc6dbef5724ac9dc999b523c750a2afbe7593d6c67308c27b49d76b590a5f0b86f298998b4da347223cd4495280dff93453138e27cda4757ba2e463e60fcf08881ea82bfcf3c16807d2ed5f0427e42a2298bcaede38175ec30b13447ba8ab17a3f53416a685256a8e8fda179b95740fad21cd3a66600d1a2a594152941f10316c327eeb5eb1dbfa27124d081d8e6b865802b7ad3926487a9ceec19f53583f210aca1374923f6baae29510d07f61ad9dbb88c73525ec2c61cab81fcd4fc8c06d257893e3f491672f94b3be48a31471c5b6630e78f0b2317912f428be01a7411a8dff660ed08819f2600a0b5dad1777ace82fde4ea44e38867de6f6a1669b16194a0e260f4c3b979e36b2c2199cad022cdcdfcd1e20b07b51dad0fe3e4e731f8897f5ec3ae9d5d28c7b247ce862dfb24b75850d8f545a129d8da52ff804413e8a8675a67653d4e0f70a769f6c0ca76f91ddc477cd108eb2ceda965053f006c79a3312ea78b07a591e530cc92569379f28b8eff50e30c5653ae3f6d92e1e05b856b6eb9d01e76b288be10d6ef94a3ee90c542640a2f76c48ddb180f5dd7cc5dc1722f455150d7f5ea5d1ec36803a18c32f1e99ba9219cc76bb6f538ca928b819866c833acf5dc6993dde17b571c24bc5ad1e15e56c401f5d80e71783c656b2a28f162208f3c825896f46dd0e3187a2b7fda403bdbd0a5bf9313b6914e4f4f83c23769ac102f7ec2d42f096da4ea1b1b5b2f1bb3166c4f2cb0032555a62816571163c6d7a4feaa77b2301e3baf15f386b712075bd79550774df54b0515a5efe950406c8a96bfdfdc48c84386c034ccf3cb2ede4f82718b848da71a162647cd1582459791e2e5735e968f1641afa1b85ed8c7604c44f978cc9721f2db4123b81297b96fc4d2d625dff1c00daf10e49124130dac89ea37b56d0fde60ef3b9071e7785569bf47792e4ea2867ac1fdb0867981a30aced75637f9d13f6c312f7353325869f2a5fc9c4e99b9b021f8baf41673210c6bd06b43bd7f00a6e2bf6001d4476ed91e2207d2db24e29341fa9c0b9c2bd7fa7c216897f34e0f1d3eda24a7ae87d6f808eceb3c220a845a1b7bf9d4687dbaa5b337b713ce08d2d1a745bd6039c1157b146d89dddd8a4e6f722c0b38544ddd076925b3039d37583c22d64e5a3cbbbe4729aac5a100793d29652d76a3fe8759aa9c7bb224d9cbf8de3633e3c7b39b26e2c8ca34be33b8a2b57394bb21172afd624096b25e64aca4ee61b14edf523698d5b22555a936adccb1e9a37aeb41c568187578d144b08acf7b11b06f6458ce4c4c146b914a3e84d86102bab5b0e66a9424695ce1440cb80ddbbba08037ec81d6fa4b0492b84f4b37537147f4f2cfa329364fc171fbb39c944a9b3629397c10fab907d0f0f15478dc7948b0d7d37ecd0c39398a9776da31bf6b0cc492c51bab6c1a8e533f9a606be3ec8f3f13fb90ac91496763bcae33cc20b52d88ecba9a30d259067cfc5c95561fa4a36740c5b496fcbbd670f3182d9312c54ae663dc0cac6f920fe570edc72a278c062c90bcc1da898272f42f3be23b558e993f1916f822a27780b042db320c551cbdf5ab3fccec1faa609cd289b9aa232e670e2bef3e32f569de52275600caaa3f1d9602f80fef2c0bbcc4b12129c146dbebbc8b0da5716abdec3d1d3d79e85020e29a710222bb8a902ceab46bd1f8636456f8a980772fb8e599ea1207083619557a88669e399a7c224fb69d169844cc8791b9b50747d64bce1ee3f338a96687045f8804a170315ac2026ddec34a20f81e1ab7d6cb7c700e89d5d46035833ede3588fee29ca57f73af83cee691aeb570e8f232a0cc5b4b924c6f7101633a653452d2960fd57d2694d3b68cb2b6b2892839d541cbda3349fd52548c2899247a2eeba66140a3d34e93f985211e10b45c0dfe998f36902e09f5cae204f070dbc8d50e74d83940eeab92856bf8b15361ec4ec525ab9fbf73b07070583bcac9246bd52d2ec023dd5e3875ab06590e6ecd3a1c784d922a28ccbd124261c4a85a7a6f04c3de30633d3f87c1e7af82d9f602e2f60ebaa4a574394d253aba92b2a16d8a37fa44ff4ac19517e9692c489e24ba846166a07f34d537b0464d0e5d37764445d36fafa38954d414d187d3cb24ce1776ee113fbfeba8aef6ef314c3f39665176432a7132035b8c5f19f7211c3286c351b05790137ff8300a68915d62978d3103d00ed47c4bf915255324b4efdd0736bd90239fc38e50cfdf2a4dc7e56f23f88dd0a1b738d593a26ae9d20d5158619be93888b7c4bb1a9be0b62c4bd237bc67412b22a14d28f6db2af6cf9988124e994e36fca8255921ed41bcf67a2d558f7a46a0b7c91d9c723aacba719be597400a8b94fcf0b13483640322605be76438251dcb3a327b85c85f1dab01213ee6ee7948f52ccd57ba10a92361beee37ef8d2e8904e956cb9c0601252dc8b4358c6ac2ca846877f89d33e5a479e09e3843b968a62a4a88c44d338b0fadfcda7e8f7f1536bd5cef4df8b1139eb0a2cc2eadea33b1f75eeca7dce5a34fe967f80647e57ee5043e897f365ac48958e63882830befb2ca40a156c9a77bdba43b79a356d465e72e3af9eade72b81cdbdc8f93d436e0c582289f937d7c2545f5bc99f60eb8b7966a20fa014eba8d7937fa49baf3f153a2abd50a60c7514ee965075e3ffb2f976941dc722379391a74316dbe923e62926838825f64bad82a7767f3f877e4b1075652e5347fb81878a8aadd0d64472b27e2389abef7f866fb6f03472bec772141b4340782552a14c4b86a068ebf58d070b890bb6b7d260075e3241c25fdf7c8fd8c42c12f61915efab07342508ec73dc6ca356dafc417b484d220345de1b75205c861746c4ac1d34228a634ae1dc255bc2ec5ae9e7fb65af7f32f3bba39978b95f21c547273337acc31283279e2f71381420d144ad6d247f274725fe1d310e62224ecd4cb390421346951f9a8bc70e083ae142fa783299e3ca5a1a4d0b601f6b4a2627f969e47d2b331d0503db2f71004e0713d8f08b73350af718e9c7add39d54b6c0d6fcd7b7c5434ffdfde25b5e49f5c1ff0a29da77e2277e9af397b3f7aa5da1e129f6b6c2e04f48c67065c4dad1a330233ea109c6215586f91e562f9fbc48735944240d9d23aaa50973322caa51b3da9e49b0f2f8874e0f49ba884281d83081ff900512b55bc242720fd0dfeafb0438a4976e789b9d35ea75dc3b24fdd58853f22673c6c9c3cdc5dbec933eb4cae2897673c766f3878bed4c21fb40c339ebecd9b4999d90531632cf4b003e1844af3b2b34f612a01ad14f3d19bd6c76a666dc92d9d8df70cbbfd3942e357303a3159908cfd743ca85ef894bbae2df9bd1b1d53619f8793334a48536cd0731f56ee86df865a06588efba817cb37ddd8d5bf67aae6e68d596e75228d34d06515ac04fa30402de719282f7bcf8430590bb613d374edfed47808d30846e1e7a4e509459e5f77966f04864ebd3eee0a27c8b8b6c62eb366f515e6782cf8146d37da3238eba8c1e1bc36302c1ef1e5c7840356fec7454e71021ad152f883cd63db7be369778ec2a5e387d00ccf6478cce4499a4078e8acfabb5c1857175cbb04a8bca9100d34f27471a0413d453f9982cf93d251bd58c472b941803e82358c416989453eca60074266c26cc3a7a3e8316d45a75ab7821d53837d348d543f1ef04d00660e85394356827984c70ef713bffa911454208055748d001706984915bee22f8904fcc0e6c3b3e7c0ead9c38f6fbf1b0f3c0882186bfb6585537ba49a64f6df7422f9e34d4cac398c61716f84214ea398e43a4ac866e65037f23b872410d2b09ef5e01eb64757a778c0db8d3c329c93f7ab0365a326dfd96697123c9f509e85f45a93de7cf3d9591d1bf1fe07459fe5a125493094654aa47432da8890c3a861567ad9bc8cdeb14e8900131a204a5469d00feeec73d60db91f3469fbfec7e909a45590d408d990ef404ce95322503c12e08ea88f45a86ac78b26ea803a6db94ba93f23fe28ce8079ef0b1da5b79cd6f007028f7ae096aa516839ad5b45024fb5b65313b731e2b80507c98f2a7a6b097d11c19f8b25e317d2fe68a0943d91d828b441e6429e774e7fd2ce72e9c966fc38c8085a57e2cdcf39817160a138eabba039e2e9b9e83894129dc8eb7dbbebfeaf9e260d696f4eca08f937f73e15064aace4c9f9dec1299102cc9db74d37a81c8e82e0c1deb36e4e19f229981f93108b6fe1d4b6cd54002ad33837aad3eb256298135922961b25ea593e61ff5f943550551a5f2a65a99de8e3a2c3e06ddcc60004f2f0b57a24caba229853afd57ecbe18f40743dfaec4f90cb937c6c8cda0bb3c0281453827e04c99192ac6800fd7cbce2b8282f7cc3b5fae63e6d53c84060bcd84a07fa338bb2d98ba810ce3d0116d7222eefccf19ba61419245985603b1b3f6c09cd975d26b9d9687dc4d851a3e4a8e30dd9fc1af7d864cd87a81f2da254fd3c5d0fbf6acbaf4f168ab230f24de3672cfec90f5b72dc3cabb10cf3c915544b41ac471efda26297a66a8ad2875e7ac41adc202cb61d47360bc7f29486fa58fe7b5e466ed08de51e61ab9808203e48750d2729f6a82f0423e066fd9d74a70e637e4383c344d84d527371dc30361d0c0cd506f572ba7afd16ae9bc1cdf01de1f366e5eb360ad0ff121dd3376492f19d6738be76cfc1235337a4e335be15cd7c109ca29bba4394a9df1879e028191a93a4db713a6c1de039d16073ade2384ac2168b68b4057fa07af7fdfa0ac26c72201db1894e097e487f429e3a388ed87078dcb1bb40a407012d4f6e535062b014cc14107b1fe3b1e4a0c7250f1d9554b822e4af136d1929faa3af1ab3ec8888072149270e9780729a4d5d34da395ac60b5ae73fc08120591687ee144d89f96094f53b2ae629f89e6afb05143745230d775bba8e7acd64f22b2fab50c26f7be85c49c151ca010ad03e0c7a7e0dffdb675465d6a4517aeef34958f6156df8cf3dda5acfe5a7d81d7eb9a4595f29bd2ae9a5699d940ec43e1fbdfe9b233c8457989c02fb705ab0ef1c395aebcf4d7537c2cffa6f2c510aa0603f1d061bb9d1af4e4036659982e98842461dc65d10271d91a9437ca555b8e86f99548f7ff4fe849bae82f4d3550ad51c536016803d88f6ccfb8f7035b8a06b5ff31f2c176ff20356ca094f7da0a62601cdffc85c9a24ca97bd70db1732e57f60da8f03b5bbb18a7063bd3bb47f5e964fa0f51f128414151131dca37c130d5ac6726bfc89d80197b68e5e229145b36d1df312885d1d5e28e831c1e280112b01b25613","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
