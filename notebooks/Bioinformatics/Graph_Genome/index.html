<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b6b09fd94741f5faaa06c938f8527ca2eb6c147ca9057183c7ace96e1352e4eaa38a08891e20836395434096100677d471ed185bbf14d12ab7c9ed63d11603fcde67c7109fb93966591b605bb308df5b64fbc4c6574b8c14ad2fcf766f85537f5b4332f4748b8a3bbfa280a4ac59126797fd2bd0c109db5e2077aba4571b0b1985f5f6b29adcd47eabfdd2a7519093db5fad465ff160d9911cf06d4ae107110ca8ba3bb6e9b7cc59fb974254bc415723891bd277db6c0c5a32cbb72511807b08b695edffa9534f8aa69d71b812b24e231d93b2e1d1d83024ced5ac01a20223336ae34bde0a506b2969bbc6854afdb4a508042acd01132be42fc3b6f896c0948e825791709d55df836a8f24161d9d209395172d4e3f27582173c5e6bcf9301bd24538458088775757a4a928af36d33f52dce4d552bf273da1d8d51a1a9bf23d29762726f0145ef95c3ab10dba98e3e1f488e091f38771703d915d8dc96730df4e46a87fc1efa5d265927af0be0c7bb169149afd19d09a5578ccf4d385e9eb52489c538fc32c1e49cfb7b31edce67beacdd62c870bf045f3b522bcc96f2e404ccee79c24811cf30fa72a154cae2d6b436e08da7082926412efe705405d44fc7901cf48dc7eec7538fe4d4e32f9ed8aab017d7a5edcb5f71bb5ce146936d06ff5fb3e817b7cade02d5c85547a331f86d5c91f7a76b1aa4c729e7043d97c2155b04a53d45d2ed97535721225bd6c5c5ab63aebc7e9df7b33ba28911a235f5900c7083187dd1d29f11d0fc837056bdf82a1b0b45a895991f38f663e461131c5cfc6a8dd72d2adbcc2d8dbb9a6283cd503f77f0c9711197a24e23f2f1f9c967c3e53ab3cc76ea01587ed2b4b39d38c5d0eca71a7a4bd66e35e93b9402b99411e4e3b6cf43cc024a08717ff768eecc14cb882433df2548127e31e5bb9c6aab48f26b9e15468c9215d34521473f0331e66a33871442aa812280678b02a3e4b4fa6f94a5ccc9671d96914e61b0feb123c70f8bc21d1ff3f22c5c725236078e8cc1a2063a91a7761648c92c9036817254a07f4f98fabf46086deee8b4748480a6596c38040674abdcdc9f91565f0eeff7e196faa1f3a9686fffdd8241a711c5a62c5ff7ac7197b917eca3854f23a1bac273eb87fe2fa9356624ff5e9fff83c473a5ea0491f6ea90e518d5f6b5abf12282291dc5c4d9fb02e7f74ea168a95988e32d8de81e8dc3801b203ccfcacfec4cb204f046e63e8ab10daa101038eac29e16be6bb264f6dd0270a12064834cf176b4305a67361528f89537d429b815da6efe7d3607befeb2442f1e346b9e1564c1d941d5bea365f24e8283dfab75ee8232ece02373eb94d282c0c71faed9cd5aebb3451d135501d12464e666ee62a85a2f3d989d877d1392ec499f2563cdf3db81d80a0946f8f56853dc2a334e429d846a30f311976d7843770a6f6eee2f4dcf3c104592b6b14e302abb5f658455b162670bc77c8e2a8d79464c6f5d0a61bccccbb014d41ca8c9d530eddbb003162a736300adace081364046836412ba2604d58843f355c1b907bdbcd5952ea5d8db20bf4dc77ce35a26624185fb5d5b47a17f377cf8bb3c50b9e9502e6cd1d8275b72944e8ee320be0e1f9844d95d25eab203ed90da06e0e4e0104d57cc3ef24fdad6bb25d140b43839baf5d7f5a5084ac5795c128b52c4e6092a1813e3dc38b85fd5f5c3f16883e51a202f614c73c56872a20635bcb5380677d3b3f1afbf645c9f420f5b763ecef049fc64c5eb701d9cc4436e9774c2b22ccc2a66442bc82a981e0df44c9d54d02fe1ebb3e312bf94b5704945b2dfa4d42d3fac5e227307e16c21ec2dc9ec23332f9f05ddd79dac9abd22eaf2d1a02b97a316bbf4929d369301cf2f81a19d4b738e070c2ace400eef292ad3f7084e09a2c964f1afd3c2f1e54f309467a3c33f98521911c3c1e16498233783a02a072891067c1aaaea72cd8b674a027f1d012668cf8f84094261b07126950e11c0305f25d9923ba668545bfdba5b55ab7d9db485a9cdf06d3cdbc197717dad0c713ccc84cd61d5675cd1ead65571b66bee6fde03ddf005ac7b9c2af5133d2e4641444dc661f3733f214e2efecadb0f25272dba50129a7ad6eed538cd18e5ad3d86b924d706e2482a460c60ce3853831707db291f65d6a8b52f9eff6ae4ca5fbab0cf6048f85622d5bf3bc6d611c300ec07c258986e67b4b5959f71ff36b0c8334318f5f4c481cdaccff21148731ae9b26118d145074424513e1ffef402b4348378c1f5649b9ce373e085d62ca1c6fb8b19ed7de5ffd0d769518cd2ff5c39edf5835ff20a39213f5ce5007f9681593bd701ee090597ba2b5c834319b293527351a0bbd67cbdbdd98d178857961762f36d30dfea77488a92dfd15d18b1fecad1011d9b83b8b52d4dde5f284008aac13796ee8cf4bf01a867012294cb51423056099ff2d737907003b626b72727f8e93ab3bbb88bbf598194c8b6b971fbe9646fbee0273db9f41b8a0f11e2a8c63c7e2667972d5b07fa26a47fe1294a108881f5356a6b7de2d9abd64d8944300dd153f26e5b69b6c164777544dedccb673d9ae36fcae0688ffa8e1c7eb342cc21d61c452129eff2c9ff951038616c113b95eef1750b495007c5b26671ca56e2b422d3d8e07a6c7195e2a5a0a219d8c2b5f90654883870faf980e92003edeb21ad9ce033a8085368e6ee774dcb58e097d7ecf97135082f2c6df38a4a80e3f68c79490edf0b52465b2b92898e16c9d920f76d5d413ec571586633e66fb97a750430afe27d5e01e2e6be0819a2b6db713bbe37cb4bd502cb5ae37d04d232758fe1de0c709e05bbe16b1f41e800792630f1edbf121c5e2cffc12247dd50ef5ca70d99379f1c0c2d6e0e00d583245c238d1a80493aa2250383e1e1690bf871e9c872d19acc1ce3c2845cc11542694353e54e187108a4531e4638323f1f9bcceebadb1ed4beb71969a875b902d598991d02584c2bed9188136b7e7d531c77bfbe363e64a65c3e575d96f9dd8bc93df3fc03034387311cd5b9a808b7a1c93268da1b4fc841ad00edea9e4caf23f3d19b988b2765e571429c4a33f36a316f8918d5dfff2f9c969258f4eb260b7ca6d94b0f572fa392ee67180cb91c9d0f0b84c7db92caa2b48c0177f121c3cc7356229aa3e251fc9ca6b30ea967f28d908a1dc3f6ccdca7a619eaec1729184508eaff62507243a67e4ea90b5ddba15be11ef4ecb1372ff70b2acc7bc4dd86e9e465d0a3b710a8c9dedff359da9369c1328eb4e912fad25255d2202c2d6185757c8b1d0f46b702bb4ca9f873288572c5de9cba6de03f25b1dceffac218e3cd7bbd1e25fb8104f248c86ec87640b9667b847d5e94c5529be7fbdd3105f13362e028efed80ab1c04f66b4a1e67615e69452afd51669b651a2b5d63476af5b9b9afe77bf4f615bcde34148ce1ac44c7e380ffeb7de9b4c634b84fec9c4900ce52069754165a052b2856a13fad6f34377eca0403b45bbdc4596cd6d4128eb5a9b882607a8ba40c734eb5118e9c8b2674ff6b10a5b5acc550f1991a95c7ab2620888c3913e7acd9449656aa0d021776c71c0bf9b34a39b5f1c6663e53d08b9d1295bc08e20f9c426bf7348ba4d9a1c246253e765835be5280915314fd84a78cad76d4cbe93f92a7b28f20322e089c4b3c193196af988816023a9b30dd089e737b4a771137453442b346e736a048ad364d00b31d1e5ea9c8de60cc7f740d780b2043d39349eece03e23a4176d7df8e598dc02eb64e3e276d6e5db203c7c43ef57375e5ca455843db26b497b50304cc7c8be3f2fc94d23eea5142f74831aa9b6cd9ce80661983977f1403b4329d57559cad109d4f6c8245bb41af630261f50aade4a0674a7f5dae24da4e5ba06bc4bef10573b61142900260d5d4e133baccd30ecc86a8f7e73bf6604f84960105fbd26eba76ca1cd890006f795646bcca1ce76053891a8e154bcf961163796931514bcdcd6afd93a7a360da95b395caf33b4fbc437c87bef3eaefc089c5e351117911c87376ce4f828c67ba78c7baa3771a7116357f823c7881defcb2c68c527d14bd58b445d5d37d70b8e792d4a5b0ad55ab40b4d3f1be29da1395068271058baf5e2c9046bbcdad6380964b5daaad4278a370da62e392d5bbdfa8b0dbffdcbe1a7530da6696711d0972114c92ac10c959c30f54fc8783408d8998207872c9ed62cf1af38d1d023029e79e5e41db7b3b0c8ffad1f31f10bc6d74f511e160fd3c5c3184caa8c025477a140126510e285ea59d1e45270d73955ea5eee376a5c22ab7d28c96541ad87180fe8069341de295ed10d865685cf126eb177a4197ac48c42dbb7894e8360dc7d2b4d9f86721dde1f5d403cb2de3a56dc42e6d6868ae2a29470deae0b7fb10b2ebdd7b1fa1dafe55b609e828d300de1290899916bd3d9d26c15d586d6635b38917d92103c57781b2519bae4fa7534ec428447cf74015948d48dde227bdc438572810e7470974c6b8861f56450379529fc4c6766cbeb5cc71926ccc274eaf39c9e32450ac7d665e83933a0da8368deb90d3000f234a913d84099e29b4134a6b57c0d78c208d2f011088fdb6eeccc60e7dcdb742eed9ceed66b0519aa44854f6553aa2269d49748d052abcc98312734027a047b08cbb81361fa49cf0e88f38676934f3e55c9e3a4324400b2255802d0d5856415d6469c47d6bf9873ba94d8bb3506af487fccc4276b4a632b5795cb05171b6b1f4f1d89bda7143f0763bc35764d784cdbc28f8b05cd5277acbaefc05049087188ded5e3f71a4db49c1fe3b55b6596abcf406324064def73aff25083dcc1512d3ecd7049b4d8532a2c05b77b9b2b2acac01c5afa7c26cf829ff7e88398410ff9cd9bf5195eca669202a3ad0b2574b3b3cf316fd72eed1849221883c8f6390065e4a285c2d398f378cf324e28b8dcef4331bd5eeb13f637f3525dc37523a7a4c885431a15974affce549f2eaf6c06284903c41473cae0ae562f83fd753981199064ba4b2b358f4bb03edceb616ff0165327153aa7d766de79a9dbb328154388dbbb3412974cae95461f3d29d853b4243e695f8c260ea2b0ede4bfb6615d1002a0c1534c43975a5fda838fa5abebf0f6ea7cc18f3dbfffb23fa34e9d33247d1f32a2a676e9c40595be5524ae754e61f39198e93af694bad88963d4e1daa3d2905ca90f133885a03328385b08fcbe7d87b2805570cfa1e8512bd61ff76f67126d446405fced959827ef08e719d3525ddb0f07456f6dd905ab92a1dcb60e6b7337f1a6bf0793bc1ca6e8c50b4832ece4ce1ef343117483937cce4858d4d059da5d7f3292f00c70e6ae1faf238107402db1a111dedac589c297e32a037beb367af0dde2f6b4b1c4f82ac372e6638bc42573be76a28185e37707b967c226f9ff7d4f7be1c70a47804c9382de6fe5cda7755569103b728aaee692458b4c8d36d359e1ce2cbcbee7c3c3e6251e7e5d68486dc6a895a4fec94823b853627702eb734d88f23100a565b06b30b5214fb64c3ad72919dca960d8ce5816c82f89d7039a1b82fd924247ab831338799fd96685d2c4ed7f810b5661c1c0b404e8d439d8625ee3947226eb0d7ebbcd063e3db37c2425a6904009fbe3985fcd2b8b8f703da9ceb4a6169522d2c5388cfddd2aa27991099db5c87f028dbc22c42d5ad929aa8127834dce8c209c47f4742a9ab2f1f0113e9b0c7b647073b4d1be41f86de452900f9ea832dde50c1a567301478984fe94e7a87e1dc8dd7a02546241f9f101db7b2f2662353eae5b2c1710855d80de0f1beb58c753401ca9a84f0096d5498fe7082f213ca4b651aebf453664d7544effed93f627d99bb11e42748dccb35f6f9d338862c0a0385ceaa019f23afc703df8467405c1f4c6b98f548264848efb4941cd4a7eac4681f62ba9dda7207682e5e38023967fc855a4c4171087702df988a7b5c1a68a938a7b947614a7a1c4dcfa43bb9856cc3a11f25cbda7389f667f348770bbc61f7878143b98f1c677ecf6dd719d2b8d5e927a7cc9070b21a9a6277408f2634ced2f4aefd2fdb5d5044624c3adff5215c11ade7c62932ef68801469ec8399670de2b87fc8cfc8a31faca8aff5a8d8ee17a2789b1088e322ed1a6c3391ba233cb245042b54dea5aa17da9ed62679ef824e940b43a761ec9523ec32be7e60101b70a61943eec312ff3f97c83e9181c8cde135eb7b3baae0220f3913fe10776946d779289b34ad348fcbbac1f58f1470c0241e001ebdf4c19e9f2890082a5845490bae83b21a8ca88f57fcdf4a32e88d8e30e9b22d52f85268f53dc6f221348971a2061563dadc2064dd5e6d7b9d6a7cc826044b905060d504f04ed7672f2a700967119d156a14201ce494549a95f51af5354932306b048e8e7f441c3a7f051b3e7ac98b401dcdc3db7e624d205a78e0880afec39b403118917d61d751534d59c99724dce86f9a1b791c437fd182b6d8c8cd07484affdbfd28a6a450d42f4cfe7a65a95b0770a008bc16e77ccdca919f1e125520ba8c6cc4e654a145cee6a82f68095c21793b0ec66ad53c4f3130d0e37ffd2a5bec7d4aa5c702a3cfc05f844fd09191a81692ce51dcefaf2b1eb1ed3f29771686898ad8ab1ef6635ec1a123389f6aed41f3d8fba12815a1bc48e99f231265d390e20efab56a44ce0431b9a7e2bb03fa7fb871cadd8c5c95a2388036cb79d90b686db23e107a2f3b6f96c2cbdd3ff909816680077ed7a0c3f927af152d69a51104bcea12567b8582e1558f00fb8a4e9940740aff82186b9c4a20463d7dbe710292b550cbf7d8c55295042701c1e15418f252fd0d80c99fd96b2a2d38d0c00eb2de50994012f4297187d7721fe73c91445e1680b77c6b05a983249c6a9218a6a83efc9bec18eb0f4cd0e800546ebba1024453089d717f86e80a53ca81deb9a76b51edea1545bc1478eadb6b96a612546bf765961f5f5df66333d390fdfb4556af1ec127be1885e316d94e8f13ef23efec85ebfbed55735d67c42f81f88241b9d499648fc8f673a945c49d6ad0ce8093d7233ec47545506f1ab8a0ff8921820f76dd9746f9749f2782a5568071d9e69b19e2a11710cc8d5270b40ec8f9c07bcdfa069ff7a896bbf9834c915b363bfbd6a96ab0a66b5b57e2291a4b0e87a2c0780b11e5587d404b678b6b5539198a1a9371aeeb27247b4d78aa9b63f0344e8454c31478d60f4bdc106f1ee5a2c46a2874cc2a73044e0559e7b6675d5f25359dcff8f4b75448e39849f27a2bb40f954943221875be16fe4e1aef9049625dd3bfa1a1ca21a77e295c580be5852eee92c24afacd959e12e0202e36965a71397e9b0a3cc9002d40985f3c0c26f81387df330e9c2d851eea0c7ed89f740a7448bd15b436368173bc7b072b153909acd7a89da2469905137e7914803cb3ac623d68d968142a3264b7ac40e264c28e97516489af05686892a7a8b8cdfebf80020ebdad90b9387a7384ca3d890007614ba0c12897eb169a6f5dbb38d3b99a9a5ff986d83fe5422c25b1424fcc9bae0e55d0fc1f02979724604a37205b5a0dd3b1d772a8cd602ecd96a92f94cf560a127950dc9de4c273d63ecf44af27055d4e1e63efc9f83c7846b89d71291b2f08f7079160b9d15cec56333f571788ee7b8c7d5b6a6dd24ffc7c319fbd52afc49875e3a6e5d9daa49aad3e43a4da02b9ed9f747e2e353e9374bb87a09735f092dc83e37d8f0df31b4b2bd49f8cbfc17e5b77cf90e134f18f8f8f7298c4aa85f4dd440c4c394629a3cd4e892bc5fc1cb4be0a89486dcf511aac3b12020d286dfb436b91c31c7e830d8dd28331bb0161e8fc19d6bb54a1a810d9a10fdd4623efe6c4ece1122d68b979d849b20763d358055133742338c6c554eeb55be0a9d928ab9cc1824464dd54edd98e09cbc85e8bb3d533d0856421ede6775ec7a573564720d049cd35098623936219cb244d0f2b4bff5f3bb7e5639718cfb28425ff1fbd9931dffd54bc15c105f6c388491ed407056ecd162ad278e8af6e342318fcd887c68d3b8729befc554525961f78a96f79b8dbe0925c709109e2fc55a25c5252812b02812b83fd6cb28998ac1a8b53372832804f75c10836b0142483a9feb7649528d01a3ef84d12ff9754891c914f8eef07da59069f54563ec12ccf2758c022416a9ca453b4c64050d8102599ed0bbbdfa020008e6280c86a4cccc9b70004d6a14ce4cb6e9506ab7e7f42ade4a9d3bc19eabf96c6ffe90ffea971544c556c6c8642ca41591f58ad3ece4d3d4249fde4de7194a4e4541120bd36c83694b94db776ff3cade51bf762f871bef88e7d5c11deae52900bfb7e9e364c6f8258ee69f51dfabbcc6eb3fb42eaa3fcfd4becec159d6c5236cfe81176cb8dc7582160395777214413980ed4e9bf7732b4577eee6208d4796388879d193c1920d65a8bd91feb6a3e0180d0d94caff23a289aa391ab3223f9e66d1ab5e4072dfc18b3161819bb3f64e9fa27227796615cfd43e38e55e8cb088ad9399e486707096b14649c27a8a6bf89fe1ea3cae79671009a6236cd9fe7c6adaded0bd6ab04f595b3e135aff49699533aff7b05138a0e02f85a6048da7bb61ca85f9a23d088e905c64b6308b702b9d377d593307fe9b850ee534bc70a9ca48855f1ee659a08fccb1a7f609332ac521ed27360b2e61505b83d0c01ba6ea741335c90de2e33e7ed8644266fbc6a0ecf942b71fc11eb9aff96e43c551aef73e186c88cca6d49e7d9a9661c6506284b077d5233d28e6b656ce9d5169599210c129fe40b84eae833d5d4b47ce65cb3027683bdebe5e9111c3a6cf0bb055d164ff473b2ba7b55264d52d3fc86bfb26979f753884d16f415019803452296f0ee0ae78e01ef56fac2e23094860c90e6f22b58f6f90403bc8678accf96c4718e385990a521f42424e66cd17643281b9f9c6922bcfde0215378bd7d98ef37b01667f77750fd792f7974c252f309cd528ef16351cff9aed182f12e5dfd7c0efc87083c6fc56d2a8af9330914a914445ab28b52f5f363a1dbbd28b325655554d0a62a0e2c6e341c789a7501092a2c2d5fa10e01e4f456b4b0b192be7da591ab041ced2561d9a33f56cf58914b1e086471e6d5177c7bdf3ebada5df082d33205854f9440a49299880ab8eccd825b84d0f43f165f7939963baa16bb7e66cea577b14ef46cb765fcb0cfea61d89039d451bdeb196de824d2ce16d7662590db7036d03f32cacfe93ef7c3b73b2dc9a29fd75b2f6bfba2ac832ece555fad028d390ce4e3fd069c9561758cad998d95f95f5d2b0f494d5e7a88267c22db0685b581bb3df6abf19a875de2ad1dc4393707aa6dbd2149e11ddcafd542295c71808c0a48c1f07477a32f28bcc8eebed517829d6cc5c887ad97ee14485009ea117deea1cf96c42b10bd2f87c26bb1a14f8dbafef6b7fb19a666ac047c02af63188b0fabdb1a8c223815658c90041dfff95b2a0dad89dcd22188f3225a41ee7c2a9953fceddf6a9958e3243c72affa590e3396b275aa149d030864797cfe4598732c3e274858cc25b21e78ef4008a46cfce6bc439ed814bbef261c628fbb259821dddcba789910f797595dc61d6b7ca40052f06295ec8aacf0b08ba4e500da0054c273abb5a8b2b2b5e2b708ba48aa116b9d964ba93e20a2dba3b06928f550912dd3a21e077af719140a63b4ea1887270ffd9534a84320b8110b86edc5d8fd45b4b4da7ffa58027aa2239ff28ab3e4521c71fe7c0f04891d6db874567a1e263cf3394f0164429d32e9acbb17e5db235f9c63dd7af2f0f90c326332b5afa486db4305df600a9277815d0ff813e7693ea7f16115158e0b30dbe069719560d8a6effea0f25dce8f7a818e850ac9ed0eb3b66d6cc815c334819570d1accd85c458c0dbd31743b808ff52985574e1ccd23809592fc9567ca3d1792164c9b2b19c24713aa1a641a58a4ad89a2d33799005df7de6eeeb7af91b963c13c37a48f60f8458dd81d1049969b6b6ce40ae0bb4a75192321d1a41e889dce1d2cf1c8acd1597013712aaad7f557eee9dce854d446fe473f2535b19b1943d1566d57890a8903ab6a7a0b56003c230c0bc47bc39001b7d21412945f0a5886189e55416a77414c78af9ccad7d439fe74175b5d9da95cf2c6b6b5c78da34b89620a146d49bb1d2160fd6c0b42b9a3011107ee4ae0556b2dda396bb6fd7627c93b34b39e2b19c6bb97b6519f3be39677a540ac454760dbab54cfbd25fc2443eabced163711bdfb178e0f1932537ae246ac71fd9d051419816c036941fdcd8afe917f9e8b8d4e1058d3a0390737c2aebe05c3f2f1a741a26213daaa416b4a7d671c587e5239f8dcbd25fb390614acfb0fc2c70102a5f00d39757700331c65b366b5bf1203c3d13b1a4a7d15b354f55964a0c4fdd70e580c564e7e1ee012c7d53aad33f12e2124fee1468869c06f7366fea050c1979355e000a7b93f9ba70b3e5bab7421d957be64e4ce3e0ef43ba39a98ec9f7cb9f6e0663518d60134d35dca8429fb6b9b78c179dc34c075d1dc3bada73d828dfab4b99c9aa6659d7d95c4745ea07afe482a00d60bcd6dd920e6700d35e2077763cc74a0772284a835f19453b93cf2dc9a8bbb9451e9dd16b73053c61011c813d9b10ff47d8c46b3ba7d03d48ec813d3a041a592d704ec360b8d4dfc8647a4c325f9ca305a2fecf4b814865387f823c5e6c43d00496a3920fe5e0f7f1889170f7b5170e290e9a45710448bf671004d5d9e94da60a2a4071a5d908a25166f7e458bb9a1837bf4605c8511090262dc3353e20cea7ad3facaa89165232a8be2fd456b483cbe6f9ec53bc8ffcc97effc6df09bd26cbfa5fe699dd5d01d9e4b8a31f84452a214a32aa720a96c5baae86ab832ddf8752e15a6d25eefb0660860e4294a467969306cabad0aecf33b49531e4cdf91cc10f21cc4fc91136a6c38048e2fb606578d33938081cefa168f68904c3e6d588afdac850cc1f9e7272b5931e8219a2d37daa83ab16e9c47464d04950a28cf1c9a2a9f8113e2570728b5253dec0992f4d0788eff77da7d60e740b9d82d97b6b5b68910760188047ea84667d6c2eb73d22469c649b7b69c3a6835c733d1504a5318f990687e942540cce6d2ed33c86325a98728d2c2822f6ff329086430e18b6aadcaf82df4a0be9624a2283451a0e00c6543530f60a3cdb6a53bef40c5edc931b83177e483a8c9a1cf97b33f1ca129d6e365755ca733159fcdfbf1822642962762782c625e77c0c1aa00af57225d24d998171705867693e06f5349efbe4a7bac2e08f5f396b30f0cb864c0e689591457c2e16b36f56adbe369895b50dd72b3d5750133e571c234a837c227cede40446b303d9ed71afb99c9c735f18e7c96b76a82b3b46677b46a1cadf0be476982e5a3e90d3a57265e2f0651c622399650ec6c70aa0c93a1260fc73358574870a249ec310de3d3ef30dee68d036265fa370548c94516620f5f7449f1ca12572744311c117bd27b7370fb92d79f71d1fbcbca17c0cc51997df4cc68f5799196bb3fff6d7c123f0b2cdb6a443c99b2211f5ab194d5621c0d80e357440164d4f973c59b76398fe52e88883c7880e4f846b4e1e86a873ae5129470ae73f114da93a0bada97bd1d29730c85026acfc68c3ff1f9daaea5c522d499628329f0f2be89b7539e42e0d654be0c5706390da617797b3740dce84f649569405ec23f5b2e6028b52868f7b52aab0dc2ac0c9f0d190bfe0d59a812f66b934bb3d4c8f552ffa3a9c4068e53cc893e6813430492319a998dcfcba57d177d1f2a62e0064ee8981ddf8b920f2f7ed730806320baefdcfb71e04b9088c9ca5e49335d5bd451c709fd051d0fb796a03d2b37a7b2b977461ecca439aecfbe9997c1c43196b426b5eae7d3c8ba36cec6f9914069c17602b4e6d344a4221520e782b2dd4132ffda7b997b9a61b19131f25973494e0738d3e90a87d780aa6d39b8a4b3a621b70b056ceb3327571c00f24face60774d7c429ed47cdcc5cf045f95eb377151430514cb17302e736892dc1b1c9f7349661a5ef94d861afbe44eff773f257d1c77d9da33703fde91a729d34cb77484cc00bf77ba1567e8b90edccc6f27c75d325931e64b987980843764aa726965579d7c09a19619392612849e9825a0c75a351d10c51f6c298ca0f4f8e27e70077a4c13c2ead47050ed69f21912fb353dd2bfabc51c08d6a6cd822e7b992466bfcaeeff94ba1b65517f154d172e899e9583c1bfad578f7cd82515e520c9fe672e868a56422b9e9450681af53bb9459605afd40261e82f55ed4803e94f05e1784906de1a7fbfd99b3283e21ddb48195181ed90e630cc795b752206043e2c699ac24acb49d622eaa3a1f57a7ab9b18835374b51c98c4d7843b22f192ac432344a90ada8a02cae2cfbafea94ec00ca729915e61e585fd97ac6df7da612e7c58684cb8d32ca5c12fc221358b44879e46a436de999b252e868dadf6f567532d936d059c21a7301c1911fa647c760c0aefa7ecd1366a1de2b6fb32663833d4068fcfc4187013479800f6b86e43548fd876810a94ba15b062b4c9bc96110b2525384126202ecbf57c0116b6ec223488b6a7855392b0d742f9e9c5f07377e0445abf9adebb304a2b10b9532ce6de1fe5fa190890f8ea408a62d959c5f1cc8a984a954b0eac86d5bfe75cb8e00372fa24c874b2e4e8395f326f956e6387c932385e81ea1416a5d051661a63f6238a1c7a5764d00d4b84dd26a58fb8bffe9e0651d093336efa5b9a43116089c1ecade6649e8e291a5c0340450f7d1b3241bf3abeb0c6bfcee519202fc17430474469a90de2416388571f285f16716e80e0d851a19929bc754d52ce3b365d213e25ffa171359562310a8202fb72ec087b8846f00b93739101a225d738ac6594fc53ba67a36d72a1089710592dfdb4be6e5c5cb3001bf793755222c6780c4f860472bdc8c5884aca2600222221f191492d804c064660fdee89ea5830eafed2de4ae50074460c2ea0b94f9af189ba36c1c6d629cbbc19a1e55edb69342698eff6f4fd2f10d4447c097a7a668906229f7dca19189a7eccd861cec565e44a2130a6bbdd70b2d088fd76e80bb3b1dc190a40778645ab2b830af0c1ec157560f2ca2ef77fce289f93cdb3c36d6c98b3d44d41da7210e47f115b784bf9459c5141e1490b0713bd78d773fe0485891790f1150fa1272b733da68215098047b13158b7dc7105e259572c122f6683d353ad56c27f9a759990870676bd6af981b421476adf9872caa70728f552f2469b2d1e10d84e13f75ded225e735bc079b3a6e5690ccb74bd5c2afd8b5dc39708e097124634be4f2a1fac21faa746111a04c2e498aa88561054b2aa249d3ddb73d701e7a2a94f303e69d28a84668d281bd278f192058736ea84c9c6b077ab9e9a55b826ffb47bd237c9d44b3c91a5e184d687ea4ea1aa084955ac7aa906a437566ad6d339c0dae30d01573e12d146839fbd848b28a0126e86f81c2fedd6cabce43a6ed25b78c5325964f9b588ba5ac8ec580b0a4aa5cb2507bc102035fdb6dc29c30a8cb79a50e334b7f195544f169ac48a0d8c36277a682f7b7e749939de177830886dd010c243399a747cc1af7a4745742b81568cd094575336845dfddfbce63ffde1fd854808227652edc20b5f1f414b747db5e22e6c82669c56065f620c82dc2ea5483f2e62da45d97982a0d67651f40a3e1d32d7f81a7268944e77f0986c4c077d1b657ab0acc16fa41c230101e204f9895cdb1e9e7b20d8aaa489372fa23c90c6a2c7ce8104ecd8552f62bd88ca666d4ef01b82576e238ee38c36c66529a2558b26968d85f62618841e005bbe33a6047521a68df2805a616d85b25011346f3ae66827a3e8be49c88d9e0367f3fc6abfb39f29ede95fbaa0b7c75489bb4bb67a4b59db9d8cace8ba2f1ccade06b75c9a1e19676a596b01df6543c4555901d1718cc075d3fb3b6d1a1ca113aab6e70d93bed56518330fbd6fc17b738014d27013a18a9e9b0f621832ea7fd3bce39cf2070d4509858d419b81d84d298b7107359c663cab2e05e77941645362fc55212517d414db859009b11a52aef376e917bacc7034afb3917a58505c01ed282dd759337409bd063bf8ba68ab121d78d7f9c976121454ec7d3dcd3d1af5b97f9ac1db8ec76dbd7cd81c46b6ac603ec00ca351d869679e370bde6b3fd23271b4abb71a5e10f55a2c10a8714f9400e194774459d1b04088157f408a1fa692ecf2a355c27b05b806ccb706457b0598834c9681cfe54f02ca6e5b98ba931863a3b6e90f3249721728c6ca3921748c1cdb2690d24a9b3358248fc3b4753ad75588c5f32df63af2132b8f0c04a14feb9db3db6e0afe53afd8bb4a3aaa9b8bcaa1ca8b83e30deae6ac395262abe423fa57e213ae2ce593ddd77432c66ac04e4772d5a2139d7504729e7ae7b215cf9c99d77eb935a019a61ad1caab4a0640a0323d9e9193b4cd7cedc0bbedd3f314d08f9713337d57d3d795ecc7e444fa48b7e16023fdbaee2300155a90189b008a0fe27406b83f08ef227d05e1d9571a44bf10c7a8a4aef50fc946dea616961fc1a73a00e308993ea5ceb8b651cdbecb57bac8594537a4d5c83fe66c5d3d4309811b3f382078cfd612753bf8a6e626d08f44eb6eed7c73d8bbf6f58efc31b6c768d15cb2633af919660198adfbef08110144a4c87fe58c2fa6d9ff7258bbb575d6f74ae0d06af0078e295606b373102ffc1a8faed350633b1f92b30907f7df908aeb53161a8e914ce86cdddcab73c0d93ec7f3a28ae918e3888fdf35da2e7756418d179a52936d4739c2f710ab7dee11581f4a6642b203f7caf6d236a7e09c0e1dea6512dc12914402d809419bd2f0bdf7685001ff0a392334c591a508080bbe65d848f2c7f81a8b980ce537ca82763a533710c2affb67da434ba89cc59dd7095421c4eda3ef6c0427648907591c26ba10ecaf8a167be65d2ecdd5c4a8d0b56178a5cc0415859a782249f71993254c2b0993c0b66ebc98b0da53b0a9dbbe34acf832af8b7b77232d3f8121ef6a4861f0b659fbdcad804786f073427d2370e6f8ded55e741b2574b665a9303be758f11e4117b03d0c65eadb9794bef91d123765af1c057349cf9abb69c23019526e4f23d963fa65218da36af9b62ebde925f79cd342be07541a9c517614e4e6a556757c8e426513802feb650c9cbcbda07c8774977bccaf883d00270dc86eedc04f85dcfb9119578553ac1a579316ca2afc6c0903ea8e09f49e9fcc6cb2e2313b7518697b91b50b0508e8157b35e8d7a426fc20810bbef64e2b92e0226d18d17a87d5d61b53ca1793958b10fa9e6bb9c41afe308a54f078afdf4a9fa422a9b9c496a47b2460c6b2c227159c9cf5db68f8dab1405a13c10ce2463c1c281a0fc111c2196eadc4e791f9d583330dcc2e64da977c9e25d32143a38b9a70374a31b6d5f8e6c6591503b6645a753ca0094a34d00a09f4a144ccdbc159b14dae472d7abe2db5cd676894b4c5c55cfd44f511934fe965130191aea708a0448809bb78edcf84c8045afd3516799339b51a95b78e14a333d31f6abd1e1907ab985b9b846bd29b62edd3e11f79cb3c274bb88a272ec5fb509a296b4d5da98309df5ed9cec91cefcdc4ac9aed944d8a0aaa62fc0d602ab045f3270c940031d219d002a34f63643fa255a7ff03dbcf888b49341dc2766440f914f2571879b2bed3efe77716f515c8615783c71d0959f557786a8cf3b3dee34cb62e403473317d1b9ff537f7577f32933b5b83f4b360dd8b66d0123721cd01fb7858efadfe0a22a9ad0df30e0c4179ee4baa6ff468e743d3e73dc32f9fc08f85d6c3447efcaa33bd1c3260a03b84919984f42871ef7934741876bf9188d50d142ba96b1ee085ad58af1ecc76cf88986f67a05eacc4b5d2200da3025c9a33ad6e7cd30639c9d8874fb2e15a721bf984e090588b038a1295945f2bc595d726b16a2308ac855c128807403bcee16fb648c4ace3f811b07f80627bb227bdaa191e9c8c9cf22dc23fdb9738e4c6347b109273bfdecd25bd6136bd3885b240c4af43e7478f59a94e883211b0591f9cac43d103d69918776181b4195456a5b48d62fe63ff5504cf656f296dd59c5c16e880ae1a54713ad6d2c2cc53a60af05d6898cb512213422dc1e1e7cce10e2364add62ef8b0c91c790b33f03d68b4049d9210c29c0c20b12b55b6df8839a3b2024a6f18d4588ee0822a6b3f9b91f5cd7d64f2312155dde92b56a4654a5c6408c5c7b76d8dbdb0b1898eca63bb669fd269c2787e2018f20f70af7979c9c4f610a05bebe35cae978e685f4d8952f956da8859e7c4b8162eb21f9f5951b3f3889bb08d37a3626029cf50cdbf3c525e15314dd0b8fb2993bbf38d4da328948d8cd2d31101c8dfca06061a143a21e0b31d4b7c80d144fd0dd7f8d140f934dbf8caa00a3e1d5126e6437415c9382beb3fe6f6b2950049c8da642d1a5549fcabe170d9f0b0902c4cf3a272ec38f68327539790ceee78a05b52704654458d090196824edef81cb74c84c014c8fb8e76d908323350b2b732a5342458a09ea8599193e1ecf6e407d0c8fcb8414b65ac408da57e1e82849b43acdc5fd1659051506042c17a50f841cd2b95e69f84cfee32b5bc6308ac8d8a8988e33c55f1f55c8588d972a712be0b3d5c7e94206db8f5373783711064a7e0d5c5a1bc669b59c225615f5d1056302e599593a93bf122cbddeea0c697dd546b12a1cd5768e1be0b45b19664c4aa435486987ce8359aa624831cdd720a7add5042bd307e7d462cf428b6624f5f09bd532a6eab2f54d948721c7dadad953c851b54b6e4c9343d8c385acf13f035eccf15ddb130ea70b13879fd9265464de00c3466f98018caf5ede94bbf40b43ac8ae042b1c361edc4b6d663449aaff94902e88031f4e807b01190734310a311b9b231a08f0b32c152d40ee1abbf7d54e2a33ec899169d37619cd5f48a0ccef7492a25fef29f581ce2d9c9859139a84a31f70863480a6c643212ed45a5fb01ac1e96b2570becb1cf94e587337723e911033774d4bafea11ca8f62a39eb9f8f5f0928dde6dfef4a7706beb99c0f548e15f022db99e936841ec94708c107ecf3d7a72131c5e3fb8546493d6ceb15de5c0f3cf0dc7d2444afee5f2c022a164ddc6add599d28e8034097f72b41495560430cb49efef67e692616d8e8969c7282d3e6d522dcf664c6625916141d0f8f50315c1e6e31b4ad70e6898436310017840d28124ff29e990d6ad26af6166cc024a3fc84e923dc43f22023a076425ce7c0c66d56f54086dd98775f1ce297c20fa31825be463a04b61205966706ef38627dadbd626a854b52ea287fcbc20bbccf020832c298dc1f86c8fb3aa8e63b46a42b7c73d2fda03b262e9e9e922bfa171d1efddc0d7751d074bcaf43a5f30f56503555557cfe2848d1707eb35f735a9102c265b2d3f45c0a905b0db48f4f81a27f660b7bec7092fba4a149029000cf6a3998d025ba4971f966361fead36fe82586bcf5a2b76717ee06588f62425c306faf1292eae93c33eb77b52ec333b7a48c2dd3b46ddf6bf3713c398e3318304cf01f247c86aa7c3f103984f9cac78237bf5c263c450765e1e3d082c7e428e2bbca96026d99ab5afd8549a193bba5a6a0cef77cc05475ffd164ed89f6a1080c308b1c73e214505ecab06d3c98294add17cbece6ab4f05213a43bbffba26bf3995d434ca050cd4f108c7b59b7f7ce98490a8a4c24e5838b9fc489003abd6154691d8a69d688e7a0730aa5154b00249d039b562444a80dd90690a541b7805cb73b5e181a17d548bf9501188b6e02c3364c4e4296d512870f3b78db083486e0c291650f66ca6e6cf012034d9bab935bb4ced200969e3767165727883f503854d7bfb992bbdec14d045caae1c1592a383eec86783e7baf8ea49df40fdee9bbb850072803d526b258dc92ee457bb1a4b1991508640d7aea09e6cda5f03d7bf7c1ba1808dc73e5b06b62938de5084ba7a8652cdd6bc9dfce323203cb2ce6d5a412f9287a8aba8422f36c25f9bad4a4e1b967775eef6b14f39190641a598663d35d92f41c220f9b7bcfe216714187e71f13649adf64055d813704cddeaf74b773ce9ee5a761d7dec662a63f5bca755596a64c89d2125028ee81941d29ae6363e4f1c3f0bbf7712a67cadd7672a257e6653acaba5af647210d932b03088c5b2551a94af1c6254d2e4c1e3e9c035bf399fbed1f4eab34f48294c2ca602db63f478404ab87f33cea260e4244767fee707a41663b4a41d74873aeaf7ddb03a7832c19bbe86d4c70063418ce064f453a3d3834efe6493ee49b33a60d9fc0372fd0b846990f38f39a126","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
