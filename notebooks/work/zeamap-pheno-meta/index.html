<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bae228295bcb35c0ddd7aa14a4914037cf8c8cbd866c908056c5ea65cb83f2062f472ab4ba7bed8ff5abd40b3db2c66a29bcc4a6b68ca4ff4c92dfc3431a2a5d645afdf79b1f3aceb349be685aac82499b25d220a1c9efa363e265252374c9ee8f0d9191b7511b25e00d1920994cdb8e020ebaaae98d7ca11d16036282d76c6dea881349abec61b59977129fde44c6198848b5af44c6ea35d4141f646273b6cabc83084b77316fb07ecb9b5a9a942641f552a6ad51e25507cd4966269596aebaf8868660c0c6ff6d8bae5f82381dffe691d9c049d273ff9ba5def2d1234f0315e17dd9c1b024250294b97078bfb5228936c9a793e2cd472aa90963a5857135c6296788a8a5518af516e77e26262c0bdb66b2f38d482fa94616dd8a7167bee80b30fb1fa8ae96223df0481640118ad6693bcf3e3a2ebcb4c2618f10fff07dbc03bb91e2ba4672aca11f05a397a3ce28d462e6f50851e7e94e9d6e47330186a68090ef0c250004004fc21ea05364886650d2c9359312f6adb42ae188c8d3c1f00dbebaf163de4733619673be8a0f8371608c3ca6701ec9acc5fdf27fe52b9fdb5a27cd3e8de140b1498acb96c7ab29a3ada261b17e2b657cadf71c2540811dbd4740e9885051755fe4783c7b5dd55d88ae4aa97fe5e8f5c406b32770a5996a7e704206ca564c135c0b5d41ab69a07f3f48650b48aeb950e51fa58a1bfb5592ce1617f8280a5e84dcc2f75cb7759f643d190bbb98c3bdd873197167eab39ffd76ca4097352e88146683b9ff01e078f66404badefd2c60dd5929b7f34640c5db3d6ea0226663648a953437c3892cef600152a66f0945409a6add941ef395689e345452da8c07d555536aaf354106dd123cb4af4ae99b50243488f59186ca58fe0a50572bcf9e0c3dd477f2e7e250969c4921a5465222eea43444d509795faaa40d17ca3e25901caef2c4081d3e5f7349e159ada8d4f90762c0de1058f87da84239cdd016a7de7b56a512e6ce3b92fdbc0732ace3f8099574e5f977a1e3590f40f48370798e6c4db154a82e62dea0c5f119d4e228efd3b29f0ef420171dc9c1b543108d88e4ff30f61d3073a63a6ca05647861a698151edd0fb47b5452040d9c9b50dc33844f3c3fa683666a707a3483138484f14e60e27a6945e9bd17fb0ea5ea4133e2140329f6eca11b9464a79a579cbd6d655408b852190e4010f01e7a6bfe0416a6b6564957241af2154932dc63b5745c8bfa5cb9e65e09d0803713bcd706506f427e2381bf55302cb00fd3d8527f7f7de254e15ede0379727d1d80e097ea92a6e884073b8fe750ae16f7d45b2ca60c4319cff2a6e42631de7bc53b0ec6f1c5ad1e9060fb8295204efade32a9bb92ad085add926dbc0403bc1e42683c95a526ca4f20484768b7caae3ccca32c3b290c7ea4b18b1a5b7b3a00ee21318410a280075d980546b92ff4a12e70dc535882e13908f4bc341152b23345a5604fe65c9cb4dc69a04e80636823a2abda5eb5042c23de681d2dd50c374fb5f39b151c4f1a2f1deaaa429f753955889561c14a49838ed53cfe172121c629f77ca7cdf415c39b9f76e9b097809bb7d0528b584ff66c6d69e4e9d6c7d81eb623396f656f624f79d7103ce21948e81a849f0437cb4c9b0ecadfc8110905fd9146ef097e03b3d278d927952eccbb6f6d82d474d614c6d5337597d352eb0530167f4ec596a28578cc39b69f6f90c117b841e481c22492c86866d837ac2433a9257f387ad131ddfd30a24d5b9b161f82eb3fb8897e9d1f31ddfa7f4f57639f71a524887b9b1f42e93e4ff00431f3d856458dc2264af28898164fbc5ff8d13109eaf7a8a4bef7dfaa47ff256229aa8d9ad34e64e06370df711424ee3e529a5ecf5ebe1d5cc07c61e2fe9ca39b12908c5035568ce14dc334e6d300aee06122ae2404e3eb5e97eb151e4b647307371ca2c743da4d54cf3fbfa79c07f8413dec39afea8ec6ddc74d6865b8223e100b271611505173db992d7ec41b399eeb123cd9a188fbc142d5034ece4e2c740c2428388c63ab1e1eaa37d54a61d521fcf80ea4acc8f131f8992287854c5ecada1d2a72d99130907d88a7f5777de48bba1f88cc3b7e5bdbc5fe8e1be22e3ca56b082f03a05ed4477109f30acee0fb0a7c6951b2e1de65b2b9ba1e270677dc24a5a5fa0ffd25008a94f71ffed8bec7a5fe1579fb7f998e1b0266c92edc53f724a4b03df720d40e0d04dbab4c993edf05227508e98a2270a01aba90c133176f092f97e7ff4d13ee01bd59a06ad4cf7c0ef67b536cb812b349c99eb4fb198422bd0357997da3a9783262a2986f784c93f52e323598d585712cad4b39e48a47a1965626bf735481dc52885f3069979ffbae1c97e449e4f53e354482de249f1169873206f5fc943059cbcbe6007d7ea2a0dc0baaa691a0d46e9a047b6b85c3d8d60bbc4375435b9c134475b3eca8021e7612984cbb03e988c9cf5de93ac36f36a07f6ea99a614932e6b4a1d250e3027c9e5b4b9ac41290a329b4ab7de072a8644398726f65987c7b7ee8cfcfcfd3b2b5378210f797e0d0b34d9d62bdbfc71ac17bcd1638f2e80a8ed2a3a5490af210d9bcf0e046f3018bdeac0fcaf8648e916aae485776329f9b56fe7c6456cc7d387a5839147e4c2b4a9915028e25789744dc8bb66a923775f081ab477b87a91f9e3592d493d436c57618ec66c9f603c30af72762c4664ccc20b645a9d7fb2dd755d1774fb45f69c09b4c7b8c12393f3b16df27c34105be7a74d3b723cd0e186d7789bcc031dd219b86e3343b906be3f36b18250ae99dc70924d2bf3ffdc3a07b000072e5a2696019c2a1e7d505c0a3daf9934a4d12397a14c505cc3e722ee48204c752c9229589bce8ba35596e17e25183e9a2335f9406fb5c2eed897e1c994198e19e17899fd1139af6f3555369b38ea8f948e51adf864f0ae270c6072f45c3b4eced17e411bcf0880e3c0fc32cdba82077238d5f302afabcc8d14974912daa5a8c2fbb7b6d703db144449396e0f6f2e3dea9fd22c27c8b7a262902a207d0df86ed75cc632dac517e59f42b928b5422b8d0593a5ffb5d3ab876f6e7e61a44a4c7106231bab2902dc32be03fe6291f63ce840bdc129dbdf31d92d2131ee6d24b8fdab59bca592f9de5db598995183f7777783901f0150c8be66d9a863b0d9d5e9f8eb70f0af99914ea356e65d464051651896fe234e4e740173e21d5adb66086fe1f2d58ca63ffbb2f035f85fba6eec61f35a073637de17038e4b3d538e490d0639183315a6bc08528877d0f4234e04bfba2dd315c8faded08aacf896bf2031d62974a4a75efd24631ed522e182d74e4213344bf6d2887f73f88e647f6b6a7e742c1de08ece0e32eb9322526927d498bce840cd5485a66fbc34491df70a2b871e551c84c017fd9842a9d12f234775de2cd16543d579dc9c70a3403487ee9254d76022bf463135e444e8129dd64578fa414d1ffb0c48b949577f5ac5938c379852710755fbdb4cf186be72ec2916ef41abf788a0ae6990c057a699e2a27edce2880a4fa4ce957cf47e924a261dc6b84d486de0ed714fb5998f0e7bb5cb6363d9750036c2742d0a7d007bfa255b0e12a279a03afb9f8c7c54236c791e8126465848e2092fa5cbdb5a27897e506be53a06d20195cae9d6f750e03fb04a932039c396ce917df1e98a66fd6abe968e64dd6b09ae9f587cff4d437b15506f1e8f1ff162b8ded01717b89c05ac95c4c4769e669a71bfbd927b4fdc59173607ac858bdee59b24214c44f3e66b9c43dd3ad435a2c63ac6798e7c2d86218d0e631e4855bc6b028f746885b3ee7609af1ea022c8d660e587c6485b106f5044f8a1f34396735a83d4606598f42d581927b1360ca65c6c85a21899c761875b79692aa0e099b55e8f69dc9d5ee0de778d4b93fb33c031a8a1a90d5ff8821e9ff98a32e681ba968c2f14d63501a44bee1e09e6d1f475435d934deec60a267ac6b5afb9b64dc666f30d6aaf4a5f61e7e57468183b5f54326e233f98b9abc9184c8e5645ed542ebc55bac848cb76fe32843fe908c7f68462430b311179b0b3c92029265edbdb7b6ad2cb4885ec1412de062aab37b834e7cf107595a85d95c258a23235608a42cec8a43a526470284b40a1d85015bb30119d7c97618042a2c5983a68dc6031c7681b93d6d6e4a40b851d37bfd072f9b38233b054bd56168573a07531b99a7daa0ee3da717e9834fdc0d59ec3c098ceb9acaec41979537b53388a091f0662104064f4533454f570680fd81b8651e2580f5fdfaba020be144a7281666205fb2f97da5cf0006f91e45c9ebdc3e05ac307d1ac7d985d94f8005ba34c4e79b79c0d111e2723ca0cb54933e481806a74617ba5a7798f55f854efda5cd16683eff17d7b9888ed27f61e807c18216d0b906d5daf98974f174a640a8c7c25fec9c61fb27dc36a0e319160e5a34b3a9f0c6dcfc425ba63aba7a6006946d2bae4cfe73de3cfb724ccba936248e5572abc7309a03984457437f077ef5fc54ad677dacc59b79d90b1d94eb25f8684a61719dc8b1625d64e870add051d6e28f8ffa42e55ff77571b377d2051c6dfddd6b9ffef6b5380778b5df2aafccc24356b5fcc3bc8a82638eef5723b2df259b4da5bf937a2fdb8132a58862636eb1deefb46c2620e46871a5fd177361967b8a4177e85a77489c302ce79ea27a0ff042af9d215cb029c5a09b9f85ae6b55c570ee1825d96826a59f4c632e594bb144cb5a4b352d38ffb87eddf83a787780ce6e00606c428fea8d3805373cbf8c9da8234aa5a59d0228d2617c10848e9062d006776f8fc0b61ad442021e0f131c9417907e806d6b1ebce25e6bbd38872337dd76c569ed98c4a7e21ac84ff1d09966c14a9a6ebcf23c843f9cf05193004e03e10068f85923bca30dc1ada2aa77dddbd95b015ac24f558419fd67c90759beba4a5522b65b8dd43adc045892481e4d7b3dd0a7776579a68c270924586925cede550e249f23e8dc808c59f126c09817cec84de24b00b2021dfbe863d88d72d3f509e362b48a48ea49cb4bbf50e406696f0d369df3b158fc47446fd8d708cb9ee6c729c6b20096c9105d2ef5e792a83b8648cc41bf56fd8794cbf04d15c8cee7fc879cb9915d48a9f68783b5b96d3924ec432213ca0aef4aab5f0959bf88d5c042e57516df567d34759f905cca86a53cb128abbb0a5d05afccc417940f872ee64cdc02d3762479572944583687ca1db6bb6d577f10251b3b2c3bb572171fd16621268450dc7bb539df656d054bd65c7a155cae6c980ada82be3fc0553d995369d15a356249faa7ee79fd1900ee912d5075b049876d3c95fd06a05b5dbc254351c9d4d474272bb7f19394f1bde499365b7d19862beac1db12de3afede3115d3285792c7fdcc7a158f60a7446e7433c3991f2a92223642b97450c71bb86c946c03d113042c391989f73cd09a97c778be2c4d148dca48b89faece1e759a1aa2e73024472c2fc2ea3e56bc238798471767afc354a5115dada40e9c6fbf89d5162d482e928c9ebb1f70aa053530a46c46496042398f77b13b3972356eeb3a349d6dcf174ab1dfeba8a82c7d6297283015df9e56eee3930abdb676826ba18595d469be35725b74e877a06c0d7159f9cc4a25fefcbfaac1f2058fbdef455b69de36f156b9dad10529cdf80b6082295e8ca7468087c0e7357c0e481edf7b16d9bffe1867f655a272f61ef256560442ab29bb04d0e5e672a045ccc2e80563d5f694e4fff0363a32957f0313de64e1f577891af2946dffbaa88576bef9c33858314aed1b5091d85bee379c025df1ff127de4ba06dd02530c99a39177f611a9a3b528b888a8098cb38b2fd03ba3a34bbc8106f2bad70a3700a5c592d4996f023f70d69b498fec7d24b112f12dc9be16cf9e5b473f47584ba9cd6c63a3e0c74b975dda0119e2123426233d92979c236bb7ba50e21ab0283ab5391845a812c7eb04203e85d5d20a8e687e74c55b81815a4552a81acb3057737e3e17419465ff010497c0c09042e46172799f9eb462e5cb14146025a715732a3bc2ee5f9de6e592732d6f6f49a5bdab9c35704cf769032ef6b97e2ac27c84e8cde2be5d7ba88a9bf4182bf393041d0f1723de694396fbe631afc1d4f4cd45dfe30a1f101022488c4dc17767026a1163948ed599b6713a6fc5deb8d794ace04a60c8850c4e6eeb0c4c4d7f049d4bd26f9c80f3a4f186aef061b2535e3d65d94ba185deeb5e719d6f09439c8a69ced4acdaa77dd232ca02fb4639bebe4b9bd88582a29d385dcaf55afc883655e3b0cae97a8d939d2069e3431c3db968c35bd27d044834e8c26469f785a7ea47b3cb0a143d37b427c661a9f047defa60e371f17e5dfdadc908a82e2a33ab592cee9bb7d93ceb4a4cd77d68eeb0f1a43992b816fac081ef24e83831e48af5e63991103330b51c7210b217aaaab6762f246beaf9de775a0c783a660163a90f494364cabf9ffae10b36b87cf50e2d6ec91ab80d6e858a2b3804c579b2640bcf8c4cc75b93ca5a096ab4051e24daac2ffd82ef8ed9eced32279b409e9589fb0329fd022c19dc9dc876c10fece10ce31e2df6f3c7e339f453236c65449aeda45484d6e5901c3eece1a4f7419e6c7a5a4cc93e7633f45d5954582a78e2adcf63f9acee694cdf7599a51bf83ea963de308726014ef3b253ef30ef6918b64a2e9733b4616fefec8f985b91d530eadfe3880fba444f05a95780db13afad250361b77993384595ca1f0a5176d0a35e981faf246daed10170daa95bf2f9b0a126d3c3c87d1ba15781675e1afbb1b2c0ba300d2766f4d451b63500a9d4390ba6a56c7d924a144398c24f784e0ca0c66e38748025eca2d163d979d23b47fe8e82ce0913094047ddd948a25e23bff91488a79b105d9f1ae9b02bff99185906cc20db980e4395cbbbe469567d056b3a01193359d3c1db993299e8975bd5ae9e042b564768804be19561bae40d25227027d3d0014552e3a3a5058fc24467966a0949900633d66a59e8792e04b4f4b890f8758a820317026b983969a864c9fd1c2ef8b35a33e080ab03f1ce80e7d33eefe79729b3833b2ed88738d2181c9335f41540445fe207d9e4a61f5ec9e6503bf38e6d0d373e1e37c105ec5aea66b2282c20083b7e27a8454631581827ac608f2fb09f32ecddfda2e36a98151610f54dd54fe198c802e035df3fa3efc087597982ed1a794399339a1b7afe4902823e95b961605d84b7e613cd18380f235849d42b6e0269d30b861add0eadd746228a5e526b368bb79a049c93e0c8c1089b733693068da4e8e428d380bc6085f1eedcf3dc1704fe0d48fe976cdc5b0b5cfa40d43d022a70c507f8c39befbf949b8ad37991a9d5c8d1d07146b710d774ecc030a1e261b1c3f52fe7fee3e135028e1131b4cdadbae49b236f76b800afcb0fe0336e92118e01a1eac084191f054421e30c226de702be9d5f3c923ee6277d4631d2fc0180d18fb3e42b7e971eec0b9900bf83f88ca00dc07c811490010b29d0039880d1949d2bad00217183d340da44eb4f6e94006b3d3084471526eb2ce9db8c30d290424d9e93822bd453c591f6982a697a8c931aff16b1bb1654c1b4ac60fd20d9ce44cc74d7524764867e050bb5169327605b0e0f4c7061352d16d83a7c6d3c2bbb78179a48194886fdbae6ba95771c8804e8647e389a2a36264b19324d96f2282ca7a6f543ec85869061c72352854b280371d69593a9bbe467317e8aa68445f218d5c654f5f696ed54cb84ef3c32afa950f638d7fb4ece815c2678c6d0f7d7d7a3fd78d69e7ce3b693cfd370e167357faa4839c78dc43b8782db673778bba0c772d2b878edee674634c2abf4c8e1f651dae75ccc3a045836e3a767247196f958dd814e37dedbe85dcc23fc3f0f97642907262819a4c30ba67b7b2e3a4b0b3f61156859e6547c9e7b21d0d417d4540be89dcad0458dcafd70dd9d4c3971209ec71354e7df9e6b53989c67d9a3dbfbfe58653a9971cb2fdcc8b11e25b680beb3e524756f56bb8ceccd2e5b10c769a00669b6ec6b376c49e2f4afa6b4c1ed3691f9ab8ce08d8b1b95bd25ad82e77ccaf94e33534beaddacd75798c58d4c5e5b6294e6f6a819d5feb599a791228ddcac41a6acabed00a1858563a621fad79ebb3798ba571f1b96ff92ea1d3923f444328e83b7fa91aea1a0d063d83e0054a1ccca02efcce58a56dd561c4ada0563fc60ce9ab660fa4dbc6f757910bd3f2f6156313714b7ff3d4ca8e349ab8c75c9fb3cca7a707aed599f42aa0f053cd4970d35f53972dd7b35edb04fcfc13a9b396f63921f59016d10fceba56ed6e28d775b36a1d3d58d730538bbce6ade1c0f17092822f41f24dd16e2692d7d9b1173ef78b0046a18f5d5c2fbf5bd9d96bf630130fcf2c8e405f141f55600ee55b9be71608b83f3d3cdf11441f3e1f21db82bf39a9d0db1e6a82b759f94bbe26e370622bf6d8d0f659ac468700e856539a2bb17c9de0df1d935997453ae8d7b66bdc65a66997ec42f57d6a5e9ca0adf2325cba6fc89cc12ca51d3b315bb3b4455420334e5d451e6b59469f5aa72fc4245295ead8a2ee4a3a1d1a88ee9d23c6873b44d54ff4d838a2d777cdc1491957931c95098fded6a289a52d463a20695f736ce134d812fc7bc6165a08dc76d0ef9867ef5d990f4ae3bc7f8098e68aa1b022f28325720efa654a1e9b18df310af621268d5696fe31b9dc6d8486c1b29217d1e96a6353115014dbb454c3829ae007f729ef80132f28b21d989ceab1626a670ac403b6e011ea46301222157a32435931ee7e34281ba3da530a53072b91f0af6055fa35915e0e8da0837d895189dfa3f51dcea87327f308809b463a277701760a47f4b1b17cd474934d2a0bc3439c8cd48708a860ab4317ddf5260f000f15a3962e3d7e9cfae14f303881dae65560e80e6dc5f856edd6a1578627e94532e269890e88f21b00095cbbd6faf17dec082713cd88fc0d42a2814f28f7a7c4a739437052ee7da62d4937aad7e5e41c3a6027e99499c1e66c4c29555310f62bfa68317cd741899b34de48b6b32875036eed2bb72815a7a4f09ff7c6246a03c86a919722009865e28ccecac046e2a1db13c8b569d94c4586868604c77ca4818cfc2c3a14955be81cbe9baa058f65c4ad42ef31e63ca2a9fed6d85edc5d6aaa490dde01837e7ae568e243ec7df0f583b46ff0992a73a85886160325a6ef14171b983c76135b5b554bdfda4302c584c8e1dbfe99a5cbca589308b9e0933d88adc960ee2aab520064c7f410484a9b9965dde34a79bd2ad204d82b0065445c21c3fb700808220df24b84d26946213285fdc8ec5a3e1c514683fa94428bb1e771a0477423205612be45564a11ea9a859689711530bf778aaf49d0a4ddc1e4e4051e50eb7b688de85d5d26b52f48497c06fae2ae7da800a9a2e6ac200063cf4ad5d5d51002919611b9953f3526ef217635dac490def5c50ee307ade1fd3e958c31664b4d22f2c24d44918c7cd1fb9d029ef34a874cd001ab8a536ead05befdfd252c6ae3f1876aefc54435c71dc0103af16d729c8b653a9ad0e323e6f00c5ae0ada3c41fff80ffde8f356a01bc0430be06fa0d16220827b4e8933cce2eb8210d7c048198609319ebd43cd45d46ef7d94c5a013a748ccf4edead00f92ed77cdd5acc136d78b71ad3d4d96fa6eb6b9d8c134726d2bc014c66e2963e59036f9a34ffef4044f7f09875be925cbdcddcc83916b77bdfd4a857a387736f4bd4e2caae103149706712d3695481404ad34a9645ab4e5810dd5dc901ebec87c378d9e3e73cd572affd06933ed81b431fb721b447acc628b0f09061716a68938921ab06d474f96a3f2cf5d5b6de434f746fe1b48555b8d518ba088bd0aab32b61edf4e873c4842c47b595618ab718e994bb84667177281ec45b6202b923a869cc37b1437724bbadd0508e103310e6ca72bab25ef10a9ac1b075554e33d2eb46df423c978297b9ac57b8ac91d6a6f9221574568bef6489fcce430f1ed076b2926ff799026d51eae2bc38336c92be794dd410359e768edfca4cc38061e179e5c6e6143fce1fa6931c739d86761fd1993599a5a81b12b115572b6b32a66a216f72a4558e45182cf7928aec15271b3fecbd626cb86e3c38f51194f5c2ebf4586e1dba85613a29fd04ca9a5605b9c8ad57da1fd49f69665b4a32a2e72f02bc348f03a34f3c5f09edd9a28a88d5c8e8acec5c67360eb36b23f6b4d0f4b3892abbd12af106d26c07e35cc0d31db10217092ef0e265cb2a071c097c34050555470853ecdc2c33d0cd11582e050f3ded9fcff43cf888022adb41b35a7e5a2bc5154ef53a9fec91e455c0015dad10bbc5c8296d77c3ec0258fce8c7ea71befa174c79035959ded63891abc26c82c30fcc6794f0cb1ce0670cbaf38270e70cf7ed019064d67ea67b830a62883825d29cf7d08ec5dd4ad5d69b52ef063fc3bef458f7296a2a1caed26692621c3bdf5e721e104ffdc00e01cde88f2fda6ef3da806fee50f5f8c9fbb5ee0cea47ac759eccc745df55a20301985dd3819c670d4036d39a96db8d7c775e7bd2441452870992a587e05e8c3c4a5d5bdd41a52f39792bd5f9789bef959ebd0c9b71d92564b8852aa7aba49bfff11fbc0b4eef85e81e8b6a9f96e2ee2e1a1d6a43348d617a7b9d300802f8867ce7f9e0d950185f56e681fd670ab75bf8922500a245b4e712f321b176ed177a7786e033955d5890e149419a0ba1fafa56372f13b331e871904fd644c6fd3f49ce3cffc69cd2fc9638a380984957864588713d9f33875da1e82be21ffd814a95cf4d17d1b74706f1a0f3bd650892a4b3ce878ed650e953b7e5cfad4a5bd2f736255be8435e028a98c2d489cded0cdc37a90e9e4b67897c3a43b6cfa6ff3e749bfc26abe9f70f39a8c74aa05cca10722baa788182feb777cf39412baead66e9ca4f7398cebc780fdcc0579878216afcc0733239fd4543228d5ad62781662e31c92d2c2e8ec1461ba1701e692a0693d18b6fa50abe25f4afd9f4dee39e0a6bb37b31abdeb50a91f9512723a55c4b92013a537ba03aa2f4a25c595840f16620b3aaa2890eede30d044c3093c64ce035c16fb861e199d30ad1845bcb462eadb95cc62770bbaeed010e45eb3a4fba184a9b02d8b553285ddba4d0ade3019b5db39305e0fe913a9b1ad1a5b053bbdc0020229ed07b8855928b08c94140fb14df53a144c3af49f14a592d03bdba91813c6b66c4129c4ef328ff22203bf17104ecad7010c39e4e71651a7bd51e9d011a98a4f647fe83567715889c77d740ea4e6a3588ef54029b056df5bbd02599621b5b4943433e93e472d458ce393229b9cf4ceabf203117753c1b8ee5f76a5c531cb15676f269bc8dcd96009dfa6885bc1683d53e73517b2e150ae44758886f35932f6801a2b0e66d3a4261caa23c8a8ab7f44a90c73d3f0eee4a4739d81273765da2c9d0718a0d4d8111b957ea54490a19d63a1b7f142665656a394b9843cdacc4de38091ed586a716836c5282f2f1a92a46a4ea38eef10a7dd4ba04e2d0ef5af85a24f27b6002cbfd7303b3342653d279d344be55de92d4a44d99f80b341bb753a31c31815b74629f3fb51a6b273dc6829adbbb01f8d2fb2f2a3e32db9a504daa8cdeaba2d8dd2092d7f623cd728a87a2993c8d253ff57c943f55a4f357b2390a486fd3e52e690aa5ac3010f5f6168ba1809647e5183a950a29e53c8f5971ddef37d4702808e06e859c9588b7035208e4942c25d6145fbdf8f09b3094f21060e674949908c61503a06700a69780e5efee7b687b92ef3b6135e3244d475832a2fe8d0955448bee5a69b56e760d1b2f1ad57ca14b0b4aff673b1d5365bcf29c7de947a527a9b217312e24a0666b62c13dfb16d7b3f731a15ca322626141e96e8470fe3379b4deec64cd5772177be2ad96b40b4fdcc05afca91755aa060509a3df1d25857f80cdcea0dbf4513b7838f4a0adb7879b3547ed1e0397d4a13426c4c2493a00a25df768131d3539ff61b7f1fc856b4b43595ddf2a8ca74013f96bd65806d77d8455cd1ead02aee0e8d0057a062ec02347ad9f461f0edaf7d05b95a85c4bee7c7dc4468c1ed4b46153562c71b21f446e6d5e794a28b9d069d9f396fa6728b24f52989a81a13df5a6fa87feb597d46b14f976242aee5b74cf8dc09222f097e933558b98f37d9e771754c042f109af1d55df3687df6141b91e62666bcda92dceb5a30cbca135e1e1378c863370b3801ded16155d6d20679e5b7ea8111d80d4b85990fe7f119e60e3320c63de2a6147588f5492935aaa57dc72cedb3f4a9efd8c54aaa5d04417b69967062aa6587c32adbf77bed6f315947cac5251c3354fb1087e65baa09d8693947ffbbc94c5542e0f77a28b6ffbf646fda7b670983b4ea96b3423fb9ec940afeabf562adaa565ec291a5283c6c3b033ffe1d153c7e7602abad2005ebe603b3970df1e49e60cb33b679c3b993fe3f1aa55f21493b44bd852ab3c19d4e567daf22b231bf18516305b5d5f64b96e751445a6f1fe7bce40419c3a64bac9e20b48de9f3be7194f81531efda284baf560f9b9c8c87f6a1dace492cac3216b55b1de95e238e30267d0867c9211b8c4b113956e0bf8df12b688787796aaecdda5acb29f41ba3b2edd18c6102e5608f23fd1b6d5650cc3cab42d0402fa52bf230461a13689f13948f87f490ff113745910b02cfb5fa290822b1f63ef13915861bac8ce0199844f49d57fa01226d0bac9da8269604985dd3e36a9916d57dc2e461c3f301536f93a5bba53f789bf5f2e818e63982748c8fcdeeb1a99a97e82b9486383304f6c213cbfb278928db5f4f9d099f6ebdcac4303072b30353756969476332c8c17d0ce07e1240f0f825a03b86d51c4380efdb9212e744b2b549517f0a194846edada50dc2caf3c926cf1474c293435170854fc38ada29a3a8fe4edad4c45946d39137695ef49a9f225aa36a6466fec5e4f726962a8dc2afa24cd65df5983a5c16aa361b5d1d48175a91490f9326b307caf9307b9b68455b455c7671950ceebb8c0f9007b84536cb3473006ace80857c73ef42991aea0b786731970ade7c9b408b5093db56fbad19780b5ce83376fedee9043aa1f5a3675813ad5f1eca66930d6760f43d8c56671b97331192669693053026834fe1b720a2616b3afaa4ed756fca2f48b98a4cbff428df0a36c29ced285e6d5047c4ef485a7dd730c6f66965b7fe88ee48e145ef9b606d1cc42553f3c74e70a29bd427d10a970e809020b47f576a4184e2c860a3d53eab5e693de9dadd71636cd3bbedb52000e1080278170b1fb8ef17b625c43df878b2c604876837c0c184f3801bfabbb7d517e04d03dd10e0eabc980acae90d4ced4d208e4e7701e1ab9b16eccd678f0b127a581d2b61bbc86bf10cf6c0a44c226ab391bada07a7320e85cbeabeb4e7140bba488be939ef3cbc7f08ef8a23f426b1e5b40238ae4640a77b7fea875e4196b82caa04c84c5d7ddd09ffcc1749f24a3c9d365cdd6a79f60043f40a5ceb4ab347ffe645f422fa4db8350c9a751d4573bbb11d869863efc8157a72fb959c8ba8dc2b2739bb4e90797d6b75e71dcb05e2211d5acf125d61d5982d16bb312dc29ae1f559022b5ab2174a247d6126dc83d51377a01dc45ca2af9852819ba878522c261481bb2ec025850fef9b54490ac156ac3e73f2774f6e1cb9d1fba9cb685d64a54e1803685559739aa71fb60f724ef1f16be07aea451b214bf3872fb0895144f7771414097712ef4ad04377bce4d96c6cf8b5068cf1a8c29794d0e22eddb30b78525ba0f8639cd184e4db0997c989a1e498bde37eb928570a760fe54fbc3e117031537e8fb4e382b90ad36f95bb4634f25475af49fb4576a3e31a42bca81e2c141cbb19bf97f2968bcff9de86463d4a65f3778dd5acab997417b2d803af3f7ae9f5d737f9a71ba7868265c5a6aac9160b7753f93a39c2f9b4defebcc6f681215d90f18650824cea8e6287d84b85e438cc9d53a88646e890eccd71e65355caa2a2a2e6539a6ecf8359ba066de1fc58c0259e87f4bee14da84cce7033d9136a77cc5d7851a44fb5a5c95be83807cbc8a49e672002226eb5457112a37feb9b8b9f3253e15b483f8cc458c65311344e1acf540309dfd0a76daa896229e341d24b89bd1f7ef6ad1b361f7cea673a53cb30411e933bd806ad73ffff8fef35fcad6aec24788432224cb1d5bc016118cee8fd0e205ae8ffa290cbc01cad37c431dee78b586b719c50b7be3c4261926c97d6f3b7a11e4a8b28fa1eb4012060073538ed1f964bdc2da35d7460ca10d14c58574c4e88a58e47fea25f5409ef2b1af0590490097d02aaa6e75ecc94a7cd3465704c50724752c10f5a7fa707c378ad94e082006fc3d6d0e44f2623a7c27492449b511c5b76364b0b2f33ee23bf6965da2c307f012e6cfbcd5a274c0be44b192e92d57815d623a4384a77aa1c9d0c329070c8745de8d0f927955a0fe0c797b4345bc3a360d7ad562b2e2c0f638eab3432d9f99b971186717364649a7eac56efcf46ddef375e32bdd15423257e4a1edee32393ffda94ebd9c2e35e8afe8de8b21e63821317f291a686202bd91a662fb542c7a33e8c9f24b8e8cf3749cda45bf85633055d2e06d7c5e1af8758b0ef5525c93795ed1a171ef7fed8e11cdd9bc0d742668579b98afa6ba14278dc7823e095bad49e7cd8beea7a52cf061da30939bea9eaa4b521b8df1ac2fb7578f1748b65eb870eb58d11e85c8c9dc06fd3828ae95f55e0cb8dffa178348ffb77f298448beed5c26f69a859c1e7a21a9512745818e7c3a101b193288320e2e4e956ce1e262f3186908468a1c1ef6148c81b627a91ef18544ad4da559a3cec750f2c4dd98538dd889a869e84d571b0e28e71e5aa5f9a7fa182f036b46f112b5161259510363745ad68c3ac880815e75ee77129dedd7d59639df417bb1a88dd952fa9a0730727b29e1f4f9c5f5d87e4d11f7a4a7df9714b10ed14c255dc4fdeeda00430f9727b24bdd48c094b15728dbe5bf74a7cda2a73091b93433ba757d46fc0f9113a61194f7a1705b52e26ddcdb5e7785806935f198c865216c16b70c0d7abf11982d8363423f85b7177ba8d2f2e6ba1c5244cf2c1d7c74aa64458e11d6c77116981961995e7462fe1195a5e255b1028ac6ce7fdb926edf4fc0ca8948088e1bd2c771d39f7629e08558ea67465f2fe8b0803437e87f68bfe92b659d4cd92f0ccfa0e67550f8484aa508d57ad518199bc5c59e839cb133e518b73455f1963c798aa8f8aa2f9d2f51a072cecc8965a1b5fdba5fb2aa7bb69c32d58576121cb28b996c965a2c3b3ccb12b0bcda43ba9d38ca5de04cf507296bdd12d79df35a8d20a38497b2ca6183d8cc275914deecab9e94e6395e307dce3a21bb547ff3d7f9df72f9babeb422fa9f1ed82a5638296def92561d021998792fbf55f4b31885302ebb8bd2dad6a2ed1f7b292c4fcf9a3dc9c70d1dba751573aaca3dbf6115a219510b39b7251333346a2708bf2f0a2f3d3aba4ae305996edb187355ac8dd5fbb5ff9dc6dfaf6d1d6b0f34c1f03ca75e8dfcc26e919c25665a9fb068d29fc03c9838dfe25e41ed5dd7c29ea68ea0997b290a8b0cd9c652a9656f74ac561df568c511652933aa2ea3d5aea655d7ec0632f3c7cc4c1c6c9561ac90bafd958c1505bd5ef3a113b8f013d81d059798764fe4c607118024704ff3c093ab0d12ca831f6107840765c54b721228fb904a0fbd66f7eec7971ef689876f5b2aa5d61785291706e77101dce5846824295d591877f3edd906b02c7b04c06292691212679e8f09bf702d9c2e56e4ec35a4c4af684f27133012084fa9a83f5fd0c4943bd936c4d4959cc6e431fad009a240665b7ee5661b979520abdaa63caa5c1b94289fc64e6a53bcb46a5587db9044ce1c687bfe0d8ff00dca47e19c09533b8430660d730dbcacf8048daf9dfa1ff83559e829113dc28311a2b5f7d77925b7114df0da958466e5dfd19da2d846f74d8b13fba6b5c46daf2adaf621c88cf9c8859f23a464cb98c84c4812fc7edad427a682a3dffeb25a173a479c902f6e75ce25acfa032cd4e60f4f7051330f5def02144fbe935ffe5e999ace8615e979c288d00cfc1d197cfc031ae12b7c6b9106e2adfd83e7639311ed042b75337ca1dcd35da00a1f49f69117f28fa324bf185be8cfffec9a2710729c297701af50f662804bb75a646df436f85c13e110b5e4267aee6261fa3914cbf2d09e3802dbff9ca6216124ba3ddcd39ad5de481414365afff8b037dad3331cf19dcfc63b8c90d42d7d2ecb2481c7c8d7c958fb380fb3414cd8ea8153b645bc538757d9c6b102a0721342672b8a755f4fc17f82a56a9701ab3225bad293f59d07bb5e8c9a94a9254fd8e450a091535781577ab721c4572440a1daf5deaa55335d3703023ffef8a2b22b1c68b45d0d69f9f94f201a159328985568a833d48b842658192c07a339d2228a4a2b224d3451406463e7a98a81b3cdd2f2ca2387d5093d97c2e2fa99638256e11e5bd2e0cfec9577902c86b20c2083998b9e2e19c5982fa3536c91f9c33aca738678570a26554904a3074b8593b8d37929f8cc52e2c2e01c30291fc40923b38be5dd27ac164e70b62810ffe020d46898c37d9317baecb5351c1a47b7817f378cf1ac2c3e2df2059a318dd0a554591e7ccc1f1c47b8a30a6fe228a8cad862cbaf6bdafd7840c27f8a3c04694c137b38fa8af539a24d6ed4fee8c3de5e5f51fea3a8d0c2b217beed9133f1d8b12b036c1114bd8c1d5f62e2bb3d5bae4067c616c527f4042c241661878926e0472336678c557325598f1d363d5b8c234fa167c94117b7b2bc2ef1788d34101b52355accf84e770e643018f2f3562beb943c6cb8095d5a5afa255a4e01962ef0bcb49f9faf42fff3abd8decde72526c1439a51d972c82d662eb787cb706308eb9b85494625b61a55a0d0bd28c54036ff3e898aab9980137ea6b3d427ed7afe9ae634e8e5805b2449498b31fce3fb79883390d7c7e94d14af08b14434acfaef5db6e885f3d7f663562e08fbec2e6e03cbb33605ec6527ab0c98d420fcedc98a3183a54540e6e14c6a302c674020e89670152acc4e104d7fc6b08f871a0a96865fbc263d70120c547c5059770c67dc559c83557c1217db4f7262d9b35527a2c634c752334f4d776dac3b0cbe931b2f4f9041198ea1d6d301b6ad7eb13f5338c752f3c51c207c6322f9eaa25181e72c472f9666a2b944e047a29e37c24bb664bdf579abd287493eb0664c932e51c9ac01e3cb3352523c2ab56d6368e5145ed1cb99cef0a5bf2bbe673828b21c3c9b0ca2796a9b604896f1800a18946d6f0a8c15ca3f2d059b339b5976b86704171a8effa7927c1932d2c1cac14282ec6ab555c2b514afca1f1835e04a9bbe922f881a7069cd2617e326565300e357a35ab82934854ef2a393f7dbebbd1a903e5b2e68d68b861d2030fa9c40478ca5c036f58804832feb2b151df1f2f40de93b88fd8d26a95c3f5b25b8c146869710ea07270ba134cfdaaa67102586a79f536de55cd7459bb6faef0c70d7769e3c50623c9594e21be64024e576a1407befd98eebde0ff4f908bb25c06883a1ab395346f2b9638322aee1e93bdf97f5e234c256bbc34925c81cb79eb303aa36da6380f2fdb01a2775b95d3f1043564ab2bc063822a45f6a40d6a4c4ce9049c3628b4a78307d49b36a6a362b140832af7798c5c0f212de4621a96b68ee44e76bbf4173bbbfafd6770a9a0c524441fcd30f5443ea59db5d6f76eb384aacc7a1f880d7de1bfd65d563519b41d7f0d287ecbcde10f4f19271843a0569cf2d9bc7c632eabb7c09c2f1c0052482e9018dba25e130271824d5ace252f279909bfe8466547a9eaf13f9c03b105bee781e3177940375e5e7f25b0cde2b0b2a39165f5d6bc0c8483f56f9aa39af954e38198f256f4cad5ce0dd28a9a44b08dd2538fe3cd4045f6997acc1e030251f959f418b8ee9de2fc92cd8c04fd06c1c6f7ea0e04f8d19c88f376c42761095c61c813462ac06f92f4316b7f02e510010bcdb16902962cfaff7cd85ff93c390061ea7f42fea2eb786c9199ed2d6c0afd1c0a94173a418a3c7f9ac480e4627e9e40679d14be11d0444c8df3db02149ada653a5d89583108194325e515d8ed0ae24d668958e80646b909afbd2e9dfdd75d3d6272731b5933","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
