<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e9048ae377ffdc917d3ba604d4cb399bb63958fa119bc9f61adfd25fce9a9afc886c842165d4bb02f5b2170eb488a482f8ec503a0d33c86cdfde0992295e94a4e25279dd5a5cf656c48e6b9d3075acb7488a009d07dd8314349455164c13e1e9dd08155accf67ed529021fabaf1720d5a324b649bafcd93bb265740a50b1aa35d1d4ca58787f24ae95d6c7e590d4f91bf5bf3902c10e79e36e492147b7a3c5d0cd64c5bee8c1bc861dbe9ff8533fe7adf279bee1e0322d7ae69961c7cd7090142ad1b7067f2f8b43af2100cafcfa1cebbcc33d7de1bd8fa9259ec243398b4594c99f252cd121854646fa00a0d7f65fcbf7495e76c0a9b2285b2e5237e64135e2415d053e2a75ba55fe508ad1393b3b57935c38db81fa3c8cc8e5c5d116d738ef810ff9a6f2dd595002c93e9c975500ff3d2543c7d32f84b3b406590ae91ca104b5644f87989f2f013890ad85e4115c43a8e417bf2231109b4b2181e7d0fe88ddf7e3a40057b52786e9cf67c9c6b9a13ce6517b201c8524e707432e57601138435fb035d490d469e3bef5ec0f854f760ef2f00563d862cb0e5eed730e2c9e9847c16d2a73a106fde21c8f3e0cf00366e748139c87e250ab47244e2aa382115d839734c49ea358a05b152a9fee789cbf6687ac7b91847ef7b1532316f94727af6d11e0fb94b4a41d450b0fbb9d47a3c0a836d0d4c045f476037b4c4c84f687d204405e9387b7d3ea1c04593191b1878605c895336989961171a7b725a9eecb3977ab1c373e3b40319c6e18d484fc5b1ee7666aaf295ded5a6d83d49b0bb6e39ccd81bd86e1f629df8a64457631ca3794011bedbb8482f0b78f5339b51602f1cf51aee7bf8257772fab921892819829445d5e20355e991d0c4c7b000c24e9b0c6a715199c89a48324fd2f2bc31ad5efe2799105c88ec8e116e0a6e273b360cafc6f8f43dcee08a79c7da5ea33e9efb06c489600d2a98b095781b301cf54e852c99226707f26ef98347a627651c4008e6d50550748d7c22f47647b07da8bf583696be4f3c5753d758578d3a8946099cef94295fee2c6130eefa5b224290950887fb11440e823ae2e571957e3200c2be23db8d1bfb8b391fce8037566de5d30df3eb8f0182b3208482c6e4b96d497145d26c879dadb349d20c323730088a495d11663aab82031d1b7c81cf6a84d0616485b2455b58aaefd479207e6b4735ab3e47a8e129722d43e82141eda2235074281ac2ca6981bc9e2a1e76fe518d8b49586ceeab3572163edfb9eb5d54150a7585a0e0a7ee14be2228c89c6f5b58f089d217e9dcb5ffff6b2508fba9d181e8b316f47d939b92489d0c22be3ddc284e5d780b3bf3fdbe49c9b943d9b7e6a869874f8c71ca223c68f6a94f5cbd5e8c9267b452c127201e8acd71f2b53aa34459751f79c682ce888fb0618ea5ddd99e3acd3144511ab2d129654d2ca99165a3bc610cb1694ff185dc274ab60bc16cf1b8a67fe3e032829c9049743f7f704273ae524e4fbbf3e2d997ea747eaaea446fdfe0131c3a456d582087c364cda3b4600d11424026fc5d01aaa8ed22a6b030fbb3f162a582f811a817f541c8ee04d93d56e18013a9467748019bb6bb9e51e9ba2180b0d1a8aeb28ff356fdd0ce4da4b83997499591946cf06aeefa6c6d2ba388a9dc218a06854f691dd49e1245025b763fc1afac60829968289b56d7a12e13e4d67de387c43089a11d21d8b80f8fce098c9f29de40f16f5c55f5129c638c7ed4ffa0bfdfe2c4d81b6e12d2491ca237faf067e48673bad75b75bbdc54425066ca3a684223f8032f0a3bcfefe9732678e128e9c69f47749aac6f0967868005f0b90f2462dd335279d94ca3b0930178e1c46d844427bbbf4a93ac2ce42c0e1b46371d1e465fb1735fec53ab58fbf23998838d6791b2433643631c3b6d2047ce137b8dbe862b70dd347f8ae254d20546190a6b58d05606b5eecf0389a27b64e72b334783aeb944442da07c2c588cfc5237d1886f8082a3a37cbbc0245b0766c4c908d63f0faad3f428d0e231a57a5cb65922f6f446c1180c3c55825c12897aabae3185361aab449cc5f093f14aa0c951b0e2ba5bc988554ee40883765fffd2ec8c921769953e78f8cc925d0d8637ecf8d4fe0de39ef7d7e23bcf139ca34d05a65e1d2fbacca138c3b7980c032e0b2d4d864c1d66e80706b2c3df505657c7662b7ae93f11458f0c4595f8ba97d9a3b9be86255121b4dff6a5a06b261b2b623167fdb79995e330284c8fdf04b80d725fe714fd8bef75d4eae91e1e214c9ee004447be3fef0ded78fdf82b189de7df742f51bc029adf8cbf61b6ed211559c828e56898d9011bbc6c4bec0a6d5d17fd74d8715085982d021ad3f2622d635d21977446d85efb75b695db97b65cac2e7be36900c8d5a8d8b91ec1b0aca917dc0c9ddef450b1f23a0b19c79549f3d4f2229544d91692364d40588b739d3fe0096aba220f13f83184539b20602485404159c190f637dc9977d59b01638aa1f456049396b5598c740b0739709a809f57dc57cc411d147b01f01cb0d1455547251aceced171c4a84d4c8ea813fbe9d078f47432bf101e5a268e82330a798620b0733dd3dda4c916c1f7d796e6259caf011bd18c63667c5f2b4434213717ccf751224f5197166c553b3c16cbeec9bd4b8b2594644868d9a5dc9bfdd5590fa06ec3b4c8f8fffe4fce4af7e5a661bd37d09a4fcd2a5fb9cc484c2b9744650289808675ac37f7f5aa09af9be57cc02d1a0e845dbdf6540ecbdaf70ccba8fdc7b2d426154d1d6bb4a3c3cad5a9f4c656de62afd19129f03b7cff2e92fa2f188a023df1aa6315b33d3aadc30bf44c2338ee66b5852b72d2d4353cb99a859462d3b19131f9d9e81bf2f4a356292a900e4ccca07563b2d9b8cd9d4631a1e48600567ad4dc934bb07dbd509f0aa9d08df73a8fe20419f1ecb268c11db314068a13e67ea38b44e81009b07a6d914137681eb94b3c6b67febd1b2e69c6581a090d06fcf354888ddc9735d551db490bd1ac9b89dc8c770cc9fffc12e19a11b5ffa2cdf5a61a291fba580093cacb52500c23bf9f698c9bc505297a64096c5580d07e0219df647ccc9675fb6b4ebdeaed5d312b898b99c6b0115bca8a96e12ac7818d179f934e1db05782833d7a773c4c27f8ab9a057350db0832c7db0cb1fed5ef4aed8c435a1dce8bb90165e9cf5f6843b1b6e1403ba27ca2a1019886304615136b7106a1d220a5953a31c0d9dc3edc3bbc21d642667f986871b719d1436836df96c8c678990a12bf2bb0bdf2280f30422153520334b1698d8a41cc06f88a3aec480a8ca902293988b60ffb3093aef75a51e9bf6b4006f63f8c87ef4e6a255f1bfa9c0d27e4b4ed9f3e82dde6a1a6b08312eeab9da4a0bf378948401a2e7b89625e71b208f8cc11c1401ad0f101c5a71f81b1a2ec0972fa82820b8df85b3b7b28ff92129db89e690214e05773310d9a16b47210923d63b188d820f325c46938d672144d9117219f6d8f95e8408ac944657d854b757385bcd4d04882a0aa5b06e4f9f34ae89662b34943f19f473faab4f6413cbbc650392561c767a83e4c028e32c8d3e4010ecbc129b96fe13106590b21a9a1ee4f6dc0125833597e6352d49bb992ef239d58afaa04ef8ef222327e6a44552f13fe1575020b74da94f355f9b499d2bd20e66ea3b773374b6b299bb51f4cb61055e2022304fa2cd3141c53cf3e19453ad868d683cf78613a8d3c711928168ff473c6086e27eb9730ef557a56e78f8534327e660d74ef4dacd9635dea27af89a536745713279431284f6547c99a360979c12f2a8a40978052d0ec7a581dd98bab80ae3744c3240f117096b03d8ee9a828125a10cf6fef924cb8a35cddc821916c4b2d7636ad039d1175b143e2a1727c1cd01dcc6338942132a02ab734d8da3975f101f017dd5741b6c848a2b9f2f1b4879b931118a173eb42ee55b7a7143bee162c01358515b5800bf5055b1aed8ee493e6f34790465f0a759d75b74a30c591ac868074fa360cd9a3517e4630cb75e15bab1dfbd5f23437b213d5b967fff7801a2bb8c362147e60966a9ee09d4e48a5948725382dab2783e7b9d6d2b194dfbb2d0fa423fe925311c2a562ff1602f79fc641f8b27748df111a646274bdd308c5470f9e36d76cb3bc6dbdd4623f0945958009df6eff0217831f82e28ec26ba6c5b39330ee63af637eff61c2089a0baf908f2bf5d8cc735b5f0f83d2b348a49dbd667e346b0f9c3530acf565f53c1bedc14b1e6dd054dff7ebd80d8a31a7d119f51c9acad32c660049b00d2e0bea7896743979d7e64b23628dbf34afd57cbe966dd7897c1222832ec9c4f44888a2e53466922482f822ae330c794f8767f3d018bb5df296689acaa3fdb62107d83851093747f6c9863d0dddae8e5efbd36006aaecd27dc234bf65f84c935d8cf8cb2f0b21e9e13d68f2c055b12c437be9ca107f1da782a1240c1b38b56abf240cf76b93dfeb63d3a85fb617f913ba50349ea807b77b59a688aa62d4ed168f9621df892a277e42596937828c34e27edf8c665b714cbff50b4ee7209ccedc81ef2dbaf56f6f94368b911bd5fe70f3c113e65ab769a63610ee359e4e1990a4ff1540e5b0d2e43ce3749a6046534e6d1651c8d8ea28d30c3023a1479be0ee05835fc4841f7ed6c7812467cf80118392952b2c4f922d690239a61380eafebf1345976675b75f8cfe2c33277b030486a242316386ca3315bbda42c6331124b2964517a02bf35908be46bb0b626cb92f632024f89569429ed1f11c8ca2fe5df84cd788c7d613b5d3dbd8899ac2e1daf248f50cfbbe8379257df7a555e61ae0fce18956cb98ee28e68c59e4e382a2bcfa2ad0d2e38a8e93cd6440ca2e7a7b4d08e6ea0bfe5beb340e452acdcef727e2b77abf964e9481512e07ad42a8a221861521423c133e266ec5a0cc8138df2b711b4da88f98d22e33e9b5befd587fdb1bb1c07d80b3cd81c95d60677ae8f6dd5d91043600b9bdc6d0a576ef4da13f5ff233098ad049486a542b1e26ec052718a875170bc3f6a2f9985562cc9e4fe983fbe02946871c6fc0ec8ed835c526532b4e01a0078aa37edc1d13eebba328e8e5eafd1cc33a24564996eac927767c29e2bec3a4405ffefecb68362cd926dd1e3220daa8390d01f2cfe0aa5f07b218dc077c394c73cda92d842a6f26894136131ee2b8e80d1654042357386117462dd11035122d026b0e012ca0beb95be01afc75a887d0ffb213385bb497230cc96d0da038f54cd05a46835eecfb5f5d95ad359a792364666092e4fcb0f6ad3bca33cf4ac70f1ee68d38b7415715baee705e240c83b22f80a2da2770554dfe09184bce6a68e9e7c80586fee97c55307a159a714e190b94b71f0a27e304dbc2684f6b6d60be3fda987939afefea8eb346953ea431494553d1801ca0e37bf034be3ad1282e65ccc28e0215a0f76d4aed56572dd948e5e7294271985705b669593ef6fb0341727328ee7eb66f4bc9cf912782229fe26f8874a211ce211ded85c8a53daa6b99d9bf7c3fdeaec8a2ae4b288a27e0846cefca8ee0ff5378374d175c645bb92c5bb464a736229e64f4ea40a8dd000650754c0a8271227c97067046f5f3a20261e8da276758c533eb5784d2bc6af9b62a066bdf07b622dfc1bbe639f74ffd4bcc2ff9e363efcde6d67943e692b4a99a794ee7aa43c88c1f1a330fc1022810c60fa232835717039410ed57c1b2058887a5f76112d1704e3072b4489338c6fb55f3f6cf91591c1ef7402153ba3a33d7228e4d21697558ac06eb3be526cb03d87932fb3a94d9431957da412292eab950dc113a6c2cad8827f1211b8bb8eaca99d7eea3ac9750b28f37ecada2d50f6c834db3f9fe9209d7521bb7d63052c9c348016a5cd47935392dd7d5f9b8cc9b948babf15832ba83722a13804f47c73b7141f166fe5c0f62e896d9f5ffef5c69205feffadb34a7b8c7e7ee6499896103aa9c709e18c97f6e73d5d504313ea973ca3fead2e044465beae6729379dfc87e07c82c08d3c20e36741061e012d647f0c3038d170181cbea08190525f1740a087961e8d842c2a5d97d8c61d5b3145243df8a8252c98d8d307930a3f0641407de12d9380f3f61531ee22e63dd434e581819abe52aeebd46fcf6f74b936da258b21b3b801b9e73e1ad70d0a9c5c248e5ede0c5c062dde55bbe942d00e31741459ee91e46ff4ec4f500532fac397f4126b3cbcb445fc705589c1cb0c858f65b180b53892bb3e3a07a08ba35cd30fbff5603e858494b6ef61aecdf426fbbcaa6b154e04ddea6b43bb52c69f06d14cfa0c0758ff26a815e950e44db6cdba109c33fc50d9ed6d9affdc141e4409f4aef130b072a4c1d6187737f524c78572a22b3c06c8bd0fcff216ccf850cd3b5d196c6ac21cbcb9188ed7cf15fa5730a1769ab7d5f148da9df6ad1744b51dd3788ed169609d28c33d480e8a6d7b9f264ade7c0d17344be403e6067853d4e2f9a8413010827c8d95e8e04bb8e72e6e9a2f74d8d5c6c7cea068cd2505d4f810e60bc5eedbe0093d731808ac35f1d85b23b2d3422462eb33cb67e785f60037cf5047ccef4a349cb1af7f0e834f7ab2c93637d1b2cd6550bb8b8a5821f147953add45b26c4082fe359186ac3cd99e9f26703dd8aeda1d0daed2890fb851c537c0223300b2713fd4d68ecd92947fc13056609917d5c7e432c958bcee2e0b9008cfa8670d8dae168f94bafe8197b7797d6023eb1270f5ce109ed579583a8490b8aa63e9d766f78cb8c2c6c273a70562f3526dea00edca306ac3108f24b2ae7cf678ad0234bf668b494d18f6d39cba8605fdfbab74b12e898e955de0892547673b56e1474ef7c4fab86f70918103049bcdaac5453f29a47b4f02c160b3a5a23aeb0bdf37ef97d9fe5241a5e070a347a7e4698f666b695ca266f587f3a68a709c433773a32cd9e24e86e87f09ea8c3a73f1cb505c7d5c07ddf8204af8e117500458b61a71768842e6ca553654a2b98a8c117188016427ab3c7e7a65c6d2bcc3ef2d6b536e57573a68a49d3514e7c4c14bf19ebf9909ea7b7dc5d9cdde6b45ba74edbcbd0b67c822bd6d749725af8b3168056e896884e02e9729db63730e23a5671f764f018683327f834f542227656150f2c95130e727cfd8f99bb94e2a70d51bf09f737a86abf41b2719970c30ab3dae35212b9b28ef7eff1b62137962a5c517e87acbd8dfa08fce68e6e2aaf84d4f933cf5e02875a623ca501ec7088ae051d4ffc0724e9ef83f1b2000cfd8ff3c39b16181b5ea7043649b0313269b4dbe585f2a5b03617bb38eb2319de3f8573d143502fed8916bfb5422a824f98cdd1ab2d52641d9b85e62889f28860c129b7eae3208fcb3a228be619370210a21a99f937edd0212bbb34c5739811093247a87db7b144f2291ea33cc993ae7d99c24bd1f7f38d13d518d92a03a1296e5ea799309ea4bd6e395858153020080aa8f18238508669369fab589fee7a76eca54bc70d1749c974f078bd45dd26a44e02842678903ec3ad14cf046115c6702a038d20ab08a7c2b81660b28b059e9b6164221b98c534d2ab559dcd257196471583f7980bc5e7b29d851baf47831e11b5bb61e159894af916ecf997a63b48b65fe3e690a20740627ed3c7ebf88f68f478962df226be489d8a80a315a02e54ac7634b359d691e1a18ed48b9b4529419387de6395c9367d7fb6137278e9c136222119f20a43f6cd5cf9d804f00a8ae8328c9d61fa84b1d009ec6b02410b0b9a4bcb7c51798ad022489cb58aecbe4581cafcbd3b31ce37e716fb66d49c13a95c6e6295baf9d617c8d092ee9f008416df6a520b2748ee25d0c8f499fd1e53479be8ca688a1c5425733ca47b5ce5312ccdee8fdec3e855ce8ba339e0cdac09f5acf6af82892fa18ad67e65e579c58fb1e1e4306a2f726e1e58d39206064b5e81f039ad3935b55b1390a695830b5272415d0e824abf16e0a10bb5c96b64487272ad3699d1cf262c58401b6097cc6740760ba188d1f5435ceb3622e9439177c981b854d940bfcf44b1d732eb350da11fe255766c59e5f1bd52f23148c9da6f579546412ee115d3936aaebc43e0c52ad46b3bfde559a35ebd0b1a6457f0cdede3aa5e894a63c2fe3ff488fc6451eb97be2e43cea938ca8f7c30613f52b56f39295fd66230aab05f2139681d39a53cf50040079dbbc3097f2661f679a76fde44eb906951546a911a2d9d5ed23b545abe74d49d865bf3e463efa09307c05ccf6006e639f021b1d541f1a3e1b456b9e02f062a1d53fea2d6f256253487e9f9efa5de20490102a5e561399623e21ba8955d70ce8be3d41b830bd04d03009e22d6176995bfd1eb242834e62b8b8e0c0f22dffc115f09a58c0ab249cbeef513f8a657d5422483c8cad2f89f1a9b70d9f190fc0026cab412c59d21f62215569e619eb3e5e6af6f4807bc2170be061b0e96018f02f7ced7a9001c81ec443a5441f7c014badde8bafd543bc8eb192aa09e0246ea7bb7ca6295edd9199aead5205a592e624f2e1c9ff66ccde6ce076c02a24b61b5a247a47fccdd0317a2715220302ca99272f3f9c6bae9ba3a0eba3a2cfc260f329d57e36f9717ff0e648e4963ee61a707d82a3431c504e7a836bfb16373781fbf49b6d86c2e5a9e45e11f95bef3320c4d7c24ebd5a3237ecd45da2f3fb533fb712e795ed1887be1e0a0d80899067bc680d139a78ed68ef24d33f2bfca7e5769af8d285e8d64843df55e1c0abb9192c6187f6df302a8a7be04487041c5dfcde3c636470f9899087be1a7c8ef740f56541c23b2eaf55ff4972743baa7b42b78ef6f594915bd0cd319820096efe6dcabdea8f6bfcc92b7b67988042f611f82a793352d378801c193420a0d775f8f8d12bc76df32331652bd76340a65e5d02d4993330a875bcc2318fcf657bf9236eb4d18f9b460adb28832b79fffb3ea0d7e11f1eb278d905606cbe371d1c6da3af38fda596f2395807ab435de996dd18ce75eb5582e346f0838beb0b87ac621b5af70daa71a9a48be476d29c590e60a8d0cb6dd029e3b4cd3862d98b4c7c75754b4b32f3ee22508340882f8ce8832107bb04e51f45907b1c988cba1aca55fceb51ec7ec394ba3736860d38f1ec32f8ed5b89fd75f565f03ab17cac35ed8cb9977ad72210a096df42b0ab296d38c04968abd7657c580c7f719b1ff4a64deb5204a7a65a80173fb57cc56de7bf1c2de6ebc127fe853a38a3ba619768aea8bc5aae59e0181cde5260f47e83f4404b2cd48237e26125585febd332c7be5dd6c1bdd0fa5e74852a1ba80ba0c3f90c6beeceab434eb384eb17a44efbe5cf0c3c3af34dedfdc8c90001cdceac0a2ee0fd55f5c9264fb3328304b49a238bdb2b299ff33225e2034ad11e0c1bb6ddce14d64c42322bc932aad3e8a5c2f7275d1c079d4cc22461482322000f319b3ba5c06c4ca62131e6107463e7e4210ef329cfaa797a25a732d8a8fe4ea23a3f3bf9f66f06a213cf91424c4da2e9b4fc0e7190274399f8be285ec7c2df8791c17c47ce566aca78e5f7936f9d2c5d49675e4d986ff1a9c045d95e1eaf802509d276ac2aa092e9c544679ce1914875d37456793f92abfe0dc75d75e9a730e07a2e3be2f9e98bcc14a0f5c501da297582daf12e18d49c296dbd629a83f62019506564be2ccfbb7aaaebcfe64a2b61268a1682db021e0814095fef738185539f27c6e24f8f1a855d7409297c72ba89b610c15b7ab68a0e6df1b192b2b3396125bbf9b393a835c59f605e26f2a08113ad96e2b4cec4c0bbc21e2544de0d19b7faf1446232eb5d33cbac2dab564693296d6324dec90ac576359cd04f37d3fc9f89ece5cb6c86e57e4055fb50182479bc4014b019ebba3ca2889d66381f3f701be09ef0228a9080ec9837bb1c25d1e33a0dd1861df87aaab0daffc3fb81845c3029c124dd769c3a73d7fef26ec7c314eb90eb6f854e1ad6de3fd24de67f043b8e81f61811e2e5bbe471da6f7af4bb7aded4345d9e7cad025d63f37bd5b1b5790e0b1c5317fd3b1fec13bf3a109251b466058751ec558cd646c8a6b1e44149c597e2f69a1372b812ea62b4dafa4e267becaad0752e2a7d50e8fde39ab37ca2076bf36bed704c72e0f35556f5a0c26a4f9414feeef2d4308ddcd647b048e5b80406c06de651c0438197c7155f688001136d5cfc4f87e55dd9954534d2ad3dbea79912dc3102f47971e30f08904e1e6244e091cf16102af60445084ea6f7b687c46017827a7b4d1295c4749e51ce4c3081fc5983ca5df27566455385c255ea06128c25aace87bab4162854d7920258f62ff10e12b70680bb3d51e63269f3dfa9c1b531c3a6a23bd51e10e441069f186529700549dff1eaf472b40c010b5b2771c25275d715bbd03f2ced45bada766eba73c76487653f61c554d8e1f023f6b9bc4ac955a742df5192649137eaa5af88e998ebf3db9d4d8ec6cd71b9c3541d73a214873fa958283398c8ce1018f9f37db3f93032362b7e4e034d70a4044665ffeb8df66b5534f3f9127c2b5c42ce6b5b582662066e1ae3ea1ae45b18478ccd5196a8cfabb211b79eeb6e9399dca8404fa69c9186419cab94f208f26384f6c78c29cc6723c32f8d54b4ec1e9653c24898c52a8308fe53f6534e66549b30aadd79bbee97d3b7328fff12e66cfde8ec760b6afc0725aa2f7362866226d16c75e996a4fa9cc63c09db7349343b5c7b3bdf5412888d5a99a9ce8e2dfd8b6d8d31f5fa87336bea8000f00d0f99c44593bb23742bbfe5428ab6005223f1986c83513906d1b04a4be721ea7d32a671b427293549352edc1eff11b22a2593033804a6c4eba4732d9c863bd19f139bb2e0f9a37150e185bedd316db077a5741f2f0db62b5639a09901d164fb048c010e718e8a8cc749cceab79a8835057ac802c3109f9a63612772419033d2bd36c84e17e54bc4807b7b2bc2a2c3c10b133697fdea6ece7367ab3e1d783ebe5b70efe39361680b4644aed69fb48c5fdb379b68d492d8639afc1020f9e7b4c3a473f5ccf347769a4eee5bac1ba640bd53c4440ea7dfd83ec7fea7116e4b06ec82d0940fd057d00fc16b7338f7a54ff1e309cf91594a1b8aef2bc4c0e75db1ac08c5a7da139becb33602edb99098614c268d66d52d584bb7f74a6dd2a77871157c25267cc60d426474ab43dca5c91b1aadd249320db135e0760bde56d362778efce25fb81eb0dc0ea5e33f4df730a600155e5a0cc20e9a6147508100083e50cbc6e0e4b5eb199d6e79a84cd8e57894f188a32f8bab62f1e17a44e7b1166703c6bbd7999af23e595a3b0052bad89a2035b53a1164cb27bc3a1aed9c3fa898f90c8dc2e308ae89c94eca6acf95743d5a4ec91921631b3ef44193b997a3ddd7529c1697572dac13124f478eebf9984e7c2e7f42a198f1973ea4e0b941110a677e10ea8c2e8a4ba14041bfc0d70b68ec0eb1da3116a1ddb3a5f5b1d96ba72fc1131d5c5cc66bb03da5fd15827a79fba6b736a0022112ab81c0f1e412fc13a3f076cef34108eca46b9a8748832a61e01d25b3faba0a603675fd6132255b7bddcb1490b49316369a1714770b896811af96e633b259ef91d1fae19c45d3e09a9da96e899e84b7eeaf3c7c98e299138006d3405e0110592d56e72acb32d6fd885527a81e7af76e7d265d885095aa97e3a624a0b13551b855a75deedc2b04d5ee4140584adffbfc5ba3fe6890e475829673afb77674cdc1ee93d047be81f70728550c3d021989d424dbce96dfd4930c3d3479d3b948d8178061e58459f04a663fed35a9c88d36c39445fc91f946a24cea5dbc73481328bf8759d98f56082579ae704b382502119e897993f3746c6eaa7fcb06a83224af196fc8ab48b31df2c01336ba626069ca50b7187a603a778ced8e249bd722669868627ed75a0e435fe17506aada1d0cafbc223ab7588aa094f4a441cc049ea601d2c5a8008806ed47635de8a06838c9b9ceb7ab47248113276478f778c35cee3e590bedfb093da80bfcdf984c539fddd4cd5838e285d4f72a6cfc55d95ff92dfa1325584d5faa6ea59c57ad8c83f13a78c7a80758292273cfd0b2d8f413b1fae8e9424ad443e9eecd0a98117ab47eec12fec94ca5f279b03845707a4b41207505e54ad8c53b1512d757ba8d3b078de8d89cd39b6a2625ac5676dfa0cf1a1f23ccc6797228297db21fe6ac2374ec6062536fd6cfff970cf67669d5626881bcdd26ed23f082d045653605bb2501d343cc5d8adfafea8d3c38bb169cb8297c6706f5114af97f8c522803098b6d004d738089df588691488c1fcd3f6f5319d3a5e20f0b668482737b9ea99071bdafad7440a897ee6b65682776ea2cc67237d151f61aac309d1a7aacd587d410ec89551d19a24168543d9f2af579beab2cdd95520910d1872d72cc70f7a44924be3f702bca12d3d526dc35444361913dd4023072da331c54c907eec80acbf2db743eae2ee4272cc2daaccd6537b15931e3ca08bd125e264538ad532c6ab7685357657e55933ca0cc315e604ec2731e88a8df91bcea8c8f82d12ba4e523a51d593a1ae6be145955da50f8dec664495519c6dab6c46f9b4a8c695e205d466484e9746a08cf8e055bf4e105c0a7b58d642472eccff9b712f5297278eae4f9dd1b7c7a1a651bad2bcd6ba8b65bcb5d2fbfbdf3ac03d2051be86746faa241db1aec96044f047d9a5d8ad56803810bddbea77d72b8d6fa4a5be3d76da902cb20df411091e884dbb45402af425e19408ff27aad0e28dc8b5609085226f1c4f4d52f6115c377dbcfef1b037c609c1185715e6e3997a6032a25782ca3f36f8550db43ea95f5b29762854f42717ffaaf91a5ddab5f2cc3465896b739776aa8e4df6950af5c681a42505874cbae6a61a5bce3ef2537d200bae5e166c9d4c9dbc4655cd1a028797e79e050e8063d1e66282c338a0e158253f5d5e13d0bc3e4cd8b25d2fe38266d42a9c901aac1e4c2c79f60ae2f01e108f2068bf488b3cfa3e55ea93e76f6ecb012a60332486d0c8cd5c8374891dfc523f52ec84f69b152db18c716ce3917d4ca0d79f996d1943a5a9fb1e252a998626ebd7a1d070ae81dea87a823d5cb05c366635cc17ac2b73375610c6dc424239deebcbc9652cc175d0079cf4842c9ab513ec7df8e87bcc549266ae107885a9f24672a60738f9e6bc1cb38ea020a5057e7c633936f858d34ed44cd5cfccd9b0c9d223eae0715a695acecf67a9905acc0c5d884516b36b6cbf4d7edbe2c4539713caa06ea0f1af3d25c60787916dd22e7cf2ced8f035ffefe9b9ee56e40099cfc43f938f90b8cc5f4cd705c337f1cf2fe362e6fea5996538a5a017818569a1df0340f4cecb8d22db305535f1da1aa47a729cee7998d2a860dc3ba740ae3279200884fd2a511c856bb98b0d07ed5edfb89f2932392df85d5bb73b153a95781c5e8dfa6ef4f386bf6759c5b681c5e9a2d04d1587414ede4a8e18aa3bf04924da8e84d60d34827b545ed2c0bb9a5212869b4e63e340bc5b83d9fcb954accd619df90c90caaac8bddd174043dc7e1f58c14dee3f7f1edc2ea667251d1bfdb5372c4ddfd9155a5218ce253da4799a83093de354637f32cbab24143f7b057891caa929982f0fe29a9a90f63178c173e4805c2e1ee12778909283b9d9a04d2054bb559b1877fb56fa2fe946f8d2bf0862852eec3a0a5f3e90013cf681df4b0f5d11be04496894134aad12ac51d28f9bd8e8c223c4840f1105179e29ad74cbe0381ec54ce63358911ebeee58a5173935a175a7234f8d4f185ccb1072769616ce91a156e3acd29a6addc7b97e8445715980e462c5ff68b43cf9fcb1530151f0d23c8a85d68e0b342fab3c45b80d8eed00045bb80a9bdf9dcf95b4113a271295ef6f9109a8ecbebada6547647f492c5bddeef8b3bde1067e3746743128e37a64ea0e727188f76ffcf35e4c384e3ecd274060e43ca3e5fb08c479413863221699844180e30a55b95c94ddf4ab5a185e75645150d3c35f6cc59fc91b6447cc17aecb8c75de2a16f50af8f76e2a49252d9f07cb9d7ebd259ee97c9de748d6c797a95c168cbcf5398a5a6e14a6876fecaea237a3e87f72d6d5663dd45ce1abe86f51b54a818e3e499237279a1c2ffc8ae1bf7de0cc42c05fedd3b1c9c0497a21f1a0df92615afa8346c0938d1a3f41424fb75df6bb13a4004f1a73112721ab950bc47ac911b72018368168ec451c9ed850b5d35cae8034b28ec0caa9fc2de7715a6cb40eed5674388603bff31d636754a8ae6be79ec0fafed5e83473fc787f06cb36b2078c9b3a0abc9d13eb2827ca9c9f7bc6d7f10a648011d626f05e6a874f837f0131cd8e8ae339856cc198116c1079bedff5fed7ee6149ad651b750d86b2e0c4b5ee874c20eea0fb3fecd303ca88a23cfcd4337c01dc9da9af66dfb8963ad70174d76949ec7a9fae43a68db1cad51b0d11ffb7ef2bdf857ebdbadb04ff1793afcd682addfcd506d94646e19007b8edc769d81886fe64567fa477e719d6140dda4cc2a321e85a06bbce154f6503f9581777c6a612465da703ed8706613e1a8113b4bc565d93701af90bcfdf47d01123df91ee2f8fa2556c7e1c032fe4a4026097a1fcc0e380670d4c0986b869c25f396f95d8cab1ddbec05bdaea23b6e9973879c3b77200e4cf9b2f188452f1b535d8d1dd3fc1dbcbf638cf5f7dc207043c7078239a48348ebd5d9499ae6267f6a5c4a4f4ee55d8828e136fef49a894cfcecde92a1011e6426a7b2106b989414c522c66aa7185840c8555b5cfc44316b0c534bedf44a8c49f6cfc09ad3f50fd91a44bb9ec380cebeddaf61da9a3ec5e952f013f1b27237d1de8f40cae18764afbac4f247e080181ce5b4e793cf7ff4f5c06c16212d2c36ab00925184938c4345aabe7dc6e9aad39bc3521f76aa282796b7d848224538ef5e2ef77a70f462f91155b03306ad6732605a1f1cb90ef7d16c6fd85a39a4b8aa58084c4658ba9dc4467bd9917373abb818843cd29595c3a090ab2716ceb1603ba5e850ee05c34afe50f374fcd8d79b53826982b3c61d7a38859bd3cffebee0fa1e372503853d65551fa619b521d5b6e68c0ceda27ebe4cb842ac81cbf6e5c3e845cb114d4973cdb413cc1fe7a3d847c6d1b6561804d72cfd0dc54d621a203b054f0f98316f490031e9ca4b3838722d697c45f3cf7ecade8e915827895c73f8600df62247146c20fab6cfea652d5b3629d668f446887a0ad22d1d0b7893358b5218cc8499a699e7be091334f8db56e66675fd462a2ea247a2e068710b93fec9ec0eee856a986e0ff0ae6eb99ded34dc01f602fb1f3463d77c61b460400dd1c2957961d3dc8e6b347baa962d752c62aea9e92bcd20df63c463a1246a3c8ba5aa57ad2aaead30557da03bfeca446999b04484f44b824fa72bd8994bfde355c09b40aa66185dd4685fa4eef02ec374617918494319eb91a889deda9161084f8da6068dc3a6d7127ed9e3b85c55775125b922182ca833c5c8873e39bfafc47796f49e3a90026c04bc6592e20e71ef386296c0e6fee476dc3eb5e7240d910c4d704c17df530b3160cc8c645e3463df2af173312fcf7d406ba3b7efad79e9facd6d61b266477d9a267ff73c86504cea924a965afce794b34d3bd3596a5a27fa38f413da7646f1d48914ae87d6de7e9c7f4b5a0a73a9d7ca9b0881f839dab6dffeec6adde970f30de7d37a477bd1c7ba2096763c6213308484c0096adfd1d36fc9557cd81868ae61f67a8d516c83efa8fb1f1347a96b761441969bbd20b1a2510d9ced50c4390c66e56b837cfca6926bab509a238d3a8ab8b51e4b131103c66d3bd0c5745bccdac0ae56408de1b9ac2d6aafe1ddf835bde153a63a73af299065186460189bfa4f78e239278343ad7e28322fc0700db5e57c6453a0851adb5d53880b3ceb2f76585f32d3e683e3ae7a047847c23f4a3a7261d9a56059326a554d7eb0957d0ae09c0f9435baf5be21bd80b986137a216b4e1d59d296791f937c462b908402f5b170eff849cf404e3b2ae997b648f1c53fa79455a8f4d67d020122d472b7ff037b37b0e9750ee606f589c7426e8d3e0975daae31f9b476c71f1102f074186c857e59cbdf4f59e6f3805c494c8cad6a763d2d386f694721736752b9aca820cfd6065d7c56790a609707f0c9975224742410f6657467516a9cd2a444251573ac18a18f354fac7373ca654da683ff901c9ff1f6032642207dcb5dae8a98835cb7c4f37b1a73eac3d6ea59dfe7349f006293a1368577604d07d87c79b2c6ec99eb375be468e4e0b24770f5aeeda8db1023f2ad26541cab2a4b664054ccbe60f9f4a3f6a82465edc93b01cd61c6829749aa53c633f4f53358bfaa639de09614859031ee7443dde1c49f9697535ba199029da2c447f73a4294660583ca7a12e32cbb8e64e0382486901ccd3b522452257bad623ab7112b6f7107c96d14cd40edf78dfaf363ff724aada9851a6a8c578c4279cf50adaebee625e919544b97ef0eef6e1ac2a8b21d30c23e055362a61a41b8446e045f5634232668f5494ec52172c3fbe700647cc3bc1c42a62ff3eeb415cf6365ad7d2f91192d7202ffd5ae5a384c67561353b8c9cb39a09efda38b1ed28835fd7b547aaf609238dce6709de697ac85e92907242ed91b919b6223c7c297efaee91125f8953e18e62bec78db790977ba8dc1ae5418c8bc788c477c1149f182bf69b5592a1cd890eb2da5cf89cd9d5ab29b364665dfc5d668d772726692f2d2184494ea073265302226c99b10b3edbf30e4c63b551e33be4b786651d6b95c134b8e0547a42a938644f4169d5d3ab576950313063842d2d3cd2b4329b6b0d54e9364f1a7fd29a6268a0d73b78a3aca07487704f149be08a0f052de61ead8bb195c6939698d0cb639200c52befe54afecf8bf5b82a6e25bbad38ae993ce709e1783a258f933f2dfe489a05ad323c663c923934d266c8b758c4f098442743378c631f3f202a56c99ae7ed85491078cf5ac79e1583f361d67d485e6f3d0ed3287d66c091aa045cb87a60ce98821b4e810250514a3d6076abf67a5585e9921b2ccdab18523344b7e9f1e7c2ab36534b6c62457055b2f6d342ac19cef1baee7da00626526df40e854900870e166eb3c1b3ca152bc724074868a12ab1b11d11e7a5459cb4283f7ac21651ee38b5f795e18b010031c5ed3ff4f96251ea07ca8d5f65f5e5480a473d3730a7cb002c9e739555c5b7d4303d006bd9f6baa82ccc8699ba7e4a23d0844acbeb6b978603253af9519809febaadf6eaaf1b4eaf6c9218802b2cecc2ac3bdbe3e9f6281f73e9b2ba5267bf89f9f9315681c8409cb3337d08d182854393d2bac835366d61254365b3240d0ea9033493a1b011e024f58661ba02667b84e9be288b63365414ebde287735b57fed91404395afb5a93c370805e3d6a42c865d1ae58e29a6cc6b519f64821f61805c8826bb376b6d527af38df0df663b1906c4b73a5188b023ccc41b1de37cec42a2a1f447b7a608606db3e62812fd945536526b364c00e2de31f8b5df3f2f5909823b069eaf433ffde5fd44c2d4e85bdd02d4c7d2c0e07448ff38c7ef1e0d19d511a3e3cc3d20951e4ac926b533afed15d302f3a0b0a0dfb038b36a0deeddea0dfa38caf6f06fde03e4b8f9be134466bd5aa3a78167a94f5533a1f19819e15f6d8d39f924a3c5a9f346c4460a3c06e215f4c3e358bfe06cd6639d77c13304130e4c10170213e92c7369ec015647db584c8e0fd5835959127ee32fcadb7c0270ca0a57dbb0ec16a6d491703f0c27c8db0dce73c73c7bc7f706d30e5a5600d9c4291753c5104a1946be845d3a4272ab253c0d8b7735ad9983cd3b201e9fcbe27c7be6f3e634425fe4a4b7114b3316ad77048dcf0b164489c9c14428c1f3556eb927dc1c6eb0b3143ab7e52a2c195813abb3aac0c6615622985865c3579ff09011e4e2452023af24f511ffe46c56b323fe5f3888aafefe077a804619a62a146fde140ac05c2daccf7743e3577aae168586f7816a57c4689ed25076e3719e9d278267f7507c1c7d59148a690effbcfcff0a34dd20aab1e8176044098087632939ebd803d980eb1520a4bb9c4e07a7f091848bc470ac0245b8b66f3496904729b1757466d375f2918e055716079dc11d59be44288cf076de7a2984f6291a82d53ace3a74500ba6a6504a9717fc92599694ba8f81fb829c240111d6842cd36e09a636f05b2bac07257aa2a1ac742e66b95eae4768386138c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
