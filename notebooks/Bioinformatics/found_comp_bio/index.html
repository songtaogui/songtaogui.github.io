<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3ef165ed545874c5bdc5714ee7c014439024e88daf46ae6acf7c7444a52fdba1263412d9f9d6883859d3c72993bd45483082c769b724e7dbd2d0e2755f9c37b7f176cd40d58d1121d18b6725719b635186e169d9d09f84c2e2fd2dd86dd314e9f34f194902788561d3bc6ce583c687d407de91bf9cc9b527f0e6e4ff8c14930b3900f0ef6520d6c8099d7cce3e88e52c8b384daa182d2c1b268bf7d34eb086b2b89cf280d89d80a865efc04b92b2322a72d95586b9a066077f2915c772a18bf72badaa8920bfdae5e15e988aa48e5ea5ad8fd1da1338bb4aae390d9b77f42ac0874b29729cf6327c053fab8cd2cd0ff97862232bf664854c62fbf9c21de44c801e808b0ec97bd01274c9a62640b062496433176737dc15d191f9ab0812bfaec379b3df33644abab7aa42f571ae5d8b693ad53b4050e9de3562a98f9179711850323f8af49d3cc15e84d4d05956a36542c74da3b02b42b1d8fa604feec5011569a28a1625e5957b3a4bafa4569d273afc426f9ed7f6bf2b6942fd68f50944a8ca9327d7a71339737adcc37b2bc412f7b1232c90cc04a807f3f70554971325a8b825d052539354a6a28288ecd669d1116fb4cadb21b0d714ae85171c4697173819ca30023046c76c3d45386faa42fc474bc501df1b90c3c74f822d59c05cb07946ee6f33205d0ac782e6f9259947983c93e46d00de4d3acedb10a2445d9126a5078deed026dd0409e42536326d844144fa05162789e2760ccffd361e5ee5976db6dcb7fbc25be07a032b0acd743323a665f514c6295b0f00f9e275f1712d23465c88e92c2675cf55c434d6163a31167345dbca848934c031a66c17c56c9d7536713f706967d48a3c1db0babbfaa8d28c659f4a4e712f646be83510f7475876769193b8db41109ecc1cb441b4279342bb769302b5164b6901cca51d262061c3757f9384c51825ad919e96bca3827a004e5994e314b5c5538aeaaa6c5e66d1f58b22f88abcf71e326ddb95cacbf42c24bcada40b591171275d31949ea9155566e4ab245d4372afddcbbb7ec0f6a9487731de9057fc395e7c909ec184d5716a4836a08f06029d7090ffc1a340a2fd357ee465732a84b6ecc01208c4bea0afbb8d7d36ba19d93039b9066bced4f5deee569d0f1a6e4625cc6ac581705e1105d7321e35f389c201a54df2a28b970d548864ecc0d891c9d23f6951e57b2cfeac6126285c8eefe1c88cd5eba0c07e3a7669839b91a89d8e344ccf0ac1080a052a3c40fc8fd289e0cf7f8708a7df66603f029be769951738ea65a4575377c5ede2ba60944fe07fd876dbed12cce8eae8325f97c0a1ea50116c9b74d398e66ed0c24db4a532349a1ad726572c85fac3a04dfc448c199509fe6cd4c19d81b1d193a7871d15e2414d5702fecc4d43530b288d2a6fdf884794d1f15431bf81c5217960cdc3388dada64ad7a4f81969bfdf765eae5dd49c8a99611523efd8b665f99cdcc3154d9560c0970e51f4fb9b37680222eac90cd7f746823827b36ce45e926d0eceb803616063c5a7292511c1055f0f12e1bf9752c305e183a20c4a6dfd3e24fbf0961d62b1db34b3027733913ce31f1266d27d68ded0eb5517a73dfbc866c44ca0532f26e59f7e361fe3c52f00b2591ee432154bbd4c28257633e0312903e36ff3f08bf3114300f86fc8c30b0c88d999e07b93ae4c89caaa659c6a20aaca5134671b96835df51ca99715cfb8cb1d51cb41582c363201af2d097247b5a626a2be5c61ff1609f9e6b50be51e3cc882949198c85288805d613884598f2e1b09acc0eaaf614e080ac0f9f5042125906503b6c2d428545148007140c4e7181ea65037153b575db82e2f669a0f7027eebf557523f5c2036c7acc1bb959eeffc21d27929f5ee5af67cd2c5b5f166bdcb39ab768a058a34ead422ea6c7b4bb8ea0ec3fe0ef3823fbf254206fd35f32b860fdeda1105501c67311d5e60947083fc7eec0f6601deed897660e74d7be3d7a19c7ac458332f0f2212862e3230b1e2420f4f32ea23298cab3097156011bd8b64a6efcbd22e0dae1e6cf8579796e71b2f97d8794bdd76d2eec08a0c2b64fa4b4862beb6c08968c7bbba6385e4c590de7da5be03130e75f2c5f62fda3726026a31d725eb3f77d2febe84019f8e1f0485f8380b0384475189429b3cf85914b556d69b8059cab4425c62bae3154427ea5ebcd1424e8a94c34aa136e7c2af7b6b69bd98b2ef4176f3c1de7f4152b23d856c4a0ca3a3ad90903f0c31b85089646671c853bad3b653860162e946f5154de50544701e94dfa1dbfda5ac1da0d39f620a864b96c86623b63443f37e72884fed3e1e096c5bba78812585859fbee4815b6c13a0ce372921649583d9176e16404933a44ea5c82288e6c9a73eb2eacfcce7ffe75787ff48fc910e3bf03c35f4c282020f066036fc03283b08bc7ac3cc99768296a5f7c57a0269edf1b19acefceac1dfcd68ff4e680edb24b1f0227be98924f7a9d69ecfe39363ad0e8edaf86f75021e6572f77a7df868ded132dfd157a40fba300ef0914fb664319f834bc60905525c26375e314b9d1be890b36408f1fb378971271b5015dacffc80da16f6e79ea717863a599b22255b2ed3aaae9f5bd59c7dbf4dcad368071289c9a5fc3c829c1f45972a05060edf43053e61a8a3db384475f391c000dbd978049137b11e059f233e9301f04a05561af820dcece81d6b687609b62f75b52201fcce53a9d85b8c6528c9e6dbf6b9a3c29e4cdbdca0b634fe9a90899fa4f4d803fccc7c94867d82698d5b74585f05f1fcd705975e987871149fec5f364fc278e7fbb37f02e33fe01fa3f007d2fe6b64f3a06c0f562871912e61f92d4089b47c2e6dbb43cf8e76d6041b96f0f8cebb162add1dccac57a589be4e11d1256bc7520c0420c9d3429dc441a7ebcb1e2d71791055e7edc2a7a378acc267728ae0e1ef78cc8ab8ca81fd047cc29778f9ddacb860c905da6fff44500cc41525ea211c70a67a44bec586da19fba4faf69c71865e933f23af6009f98364ae2d440a25735e07a931a1e52fd4ebcc7ee8fa4aa98bafc4158198cc5be92f524f9422fc72f5f8a05fb5eee0df1d5e4741e9eb98b07aca8d59797bd3750b8fc218bde00a305b7da561ebd27476c0516ead12b07994cb9445acb3ee3bb1fce855621f36c957296cb198cfa8f8482bc79afc498227c5af6dc243809af50a49e42a5d77c472b83887db8752c65dd96473ad514f759a0e74c361bc8b115d8e43de1d583644418ff4bf8ab79af6a1cee8ac97442dc988225fed97f0cc38e1bf3b926008e0636a67b74821866e2adbc11ec839eb76cf687a54e6dc359c238eaf6aa5c84f2def6ae526a9aa3927365c77b23deff36b90d5b37df3dd75a6a8dcd33698c79b5bd3943713f72ee28e7496d462b38af4dfe9ac5359b758c1ba5789ab9d5e27630fc14daa6fc5e71a5242f21bc283591b643767530c77e28183d22de37857f096bf9e9a522518c3062231982ba8eccae320bc8f0a3aa0f77fe3c1488410d26d4e67979ec7d6f917b6dd0df3c646f3322c0321ed30c25104ec20105a68940ca25470cae0cb4bde85462a9e9e7dd7031767a654ce6e64fa3c6a982b5528981eca374b4bf9287b68cbef30920abffee051a239035163f9b4d533fe8b8cf0a29139c3fa84b8c8f20ac8a0b289de1d103bbd5ae25808d6ed4a9e0e148cdb16e166cf59e684789a3f4c619dcb7b750ffd485c6cd1d0b410b13c0061332244eca7110d1c808c04a07dc1102933fc67ece5176811ab0ff1bb7900d82102aa11e12f7b24196439baa924a7057adee7026940ee3056194858f7698b3b8bb821b80fa8e3326de7e721809d6bbc3b9ec236414ec899090ec2307984dfa3e1b9156be2eca8c7664fe46380a76363ddba6074e871cf5ad044205be08093dbbd690be2a1310cb7e0b5ab20ab2083ed471f422f18031b1b5812aaa12d729124a6ccc105f5be68cb4f7f2a7b31f941d430101a77182b74f8629f7cfb8ae05a2b54b8ddafb481771f283d8840913d42c8be1925a81a56821026f41dcbc4029fa382878fd2a6aaa55e11fa3c226cd7456dfeecefd0960c59fad7af2ffdb2690567fbb0ecf125f10132993885bbacf0c86eb15b7c8fb472b494e2302ca3226890c2c0b5ab09f846f8c6d1282c7a90f69c0dae77734e7cf13650d7fdbb1867da8f30e0a6c877301c8ae71fe4e5de23be6c85865a50ddf841f17d3b0fa0d86847f0214b504ba382febd070d98b6a154f72f61fdf646dc264bc88b9d9db3e1453ddcf6749f561cde08b73f16d5547c89995e8a6bdae65c8228c739a5dcf79e7b6b09a3ec03556efccc4929213b9d26450f067a4f9ca06a7bfc1f14fcc91d055dd9c65fe1bac039e23ed1bec11248109378fb28c75d5228d86060012ecd9937e7c1232029c91b6e1312d24f2962921344a8ed898ec1fe373bd6b97eb7ed0c5aef6c22ad0aaf97770340ce3e4ba185e6186c981c224219e8dba49dd3ec8c6bbb9dc4de666c36160220ee78d91e8651a5769cbeb6c6c9636f7322bddec284021fe63b7e5fb83a557a5b0f666bc4da15f003505caf2b0aec008c39110f9eeb3c0abb1e9940807723d483dfa19bb585ba1ff0e0295cc23e0c0836c6b481d94f8955bf885674e3831d89535e8c939afa1c791419731480eba2a49275051b4b8179931aa5772686fac4d23b4ad5af5f9b0dde540b814fd7dcaf61a50d2f663f07f132121785b98c285df8abeb035e1e054260285545d0197e64c9112fb00f7e4d179e666719a41e06b262d0264a45240793f85d6066e6449561bfe67fe808de57b16bcce4c450d5f758f973e1f47af9d82e8e86baf63f70cfeceda91cf0041dfe27b02b14a8e7db8cdc8f9f1e1b4f0740c959d7bb8f16f604b0e494e925a011d48aea743181d594c914fa10bc7d0a2bc3ebca5ba3824bc4e900dc98b77ae6a963208401bf2308d30f77d3854695142c615fdbcab9879971762a3f1b5d80d6cedd1412b864358c9e99f5cece7f79b15ef65336b5d9b08282c9eef7a7c8dbcd2dececd6fd4209962de8e0ed154387fb7fd2d3641b0837bc47b65e4c8ae52391c4adee6c00ff73ae1aec730fb69cc9e42e51e2b1a2e88858340f6c4ee2ff682e98bf9217cc1d9dc787cfeea9f85aa708648fb83b9bb5cf9b97696ca8f50f5dee81fa245dc80d0c6399de79f9602d87a81e87f4f813710b0ad20c2d1eba7de0f01e94284945542395a05d4fdf61344357fc9289a5c6e84e508a348e502c0147a4370988d8e59b18f9dc4ee9753db79ca341bdbeb2714375e5b4b5b23f8541f43a3e565cb7ac3f9f8ffcd840948a182ad478780ae9aa9ea39946da94e00a6c5e015ffa8f35d0aeb38bb5961556f7206474b765be61a1327a99f6db5c2c39581d2a30e95b11bc08b56f9402f57aaad25a2856770fa543dff66ccbe8a51b6d92cf04e016596babc94b1b79193db5c7e810aef4a4f75167f3cc89739e624e5b43b8a1a981daf9b62aa5fb4ba185a081a1dc40ba230797f1d4c26658da75b9cc9ad7cd390ab51c8a87b478c546b0bea263901ec8a90c86b5c1ae7f2e54e53bc52de904fc615455cd2b50201f5762bb28e05c05f43c7e1440cd9296dea166bb1d8054027b68f09cb0dce0ea67f8d1dee3adc1212be338d8c666b07e375d5c9abfdb6c8497231a2eca1e0e60e6bb57b08084ddc10e7f12cb71aaa894311580a16b3782e8ffff13814f6b95c47386fcd7c5930363040cccfc2f7a6d208099f868b2bba26353b3e6cef40facb7a97c2fb32aca1a6531aadc8706c09dbcd32ab86938190ca60eec2e559f7e1257704263bec58cec75cf65452665a2a15bb5bf76c9f794d9609c1cd0374799988d315596ec8e8dccd672899493cc4e703d19ee6b15389c1ee04ea937679b52eea6600fa91f2e3abec3817f14c4fbfefaa169caea44ed59c0890e7e670634a393788aab00af107704d5389973c46c2ddece1f868e9abfd61979c3a017c7f0b3a2ae779ee16658af4deef19db6ba4fb01c381018a7543b7cb790c7826d4d2fa36f73848ebb66be223aefd65f8187612f8f6fe36c3981e6ee9ea0f2bcc1b732bfce9d51186d16b2809c52e5d4706c29332ab5426555b24f4334dea8822bc2195cb25f7c5a9f45ad43a360ca9da62fbccc4396b5b1e8039f08bcce3a13ac3f38f5cb08bf6c922309c0efc4ca387074c74bbefdc8c52872d24bc63a856f08b18ae9ca6a631c6b5b67e122a1bd5a75c2cd0462ced5d81d6840b0f01083e3af9567091c98341515654438208b4fbe7baca1f74fa39cb492e6b04dbe959862cea76d9331d197091901a0bee6951db74ea08c46f0f5fe0a9d95fa322748608ae3a8329237e0a200babf1db021e711b660d36a84493d2db70413161f71ef17e47b9ce7304a293a52214cc707a57eb151205bec028ea5da5493bb415812e9b1a4e6a680f0d9cc325b400844734a1077eceb80ec83d90b74f7f1baced5f9680357a2161e601cf0695f3ef3d6067d4e0f59050bb212abb89b3c5a82e9f4e88209f5bed10395aec4332f1849e1bd5a4ecd5c6f3b139b5211c1142cc22772d1bd83c696795ccce2409f0066f15425c6fc730d5a81508789cee1288f82a9747ae2c1549b2fbdf475c05f4c74975003c3b57a53e30728cbfe41bd273854375e292314be6155db84b174279670d51921d8836bfd716af07709247df4fd6ca00c6c9f9a06436fcee279776445cd650964a72676498157cc40215e35d0e9d1fe8a98b3960e0bc92f2e87adf8a9d5ba6be4ae97b0875adfc24461ee1708c87122a905c9535896cf8a540e75619cdb27abe734dfedd9d375fa76fc341e654a6f0a0d2eca7e0adab9f281dc147b3265e0b31a4208a46cef6384ddc7540d6631d0cf4765238168499708e5773d35b59a46b0b63a72be633a9962b649b16286829899df9a1f84fdc041ab20cfc71d41306a62c66211c2b3c7a918974484b4b9f513110750a8a7bd9cf5a96e560bc3e10d60f5b4fd0f1c00726302e29aeb0d585ec2353163b0f6e32f3b57154308daee7a653b7bf57e2332c870b8e21670221699fbfda752059a8ad013662ca61236a68d8cb97ed898d6c40da3f797b4a587b5025caaa766313e5fde73efe3f3fdb25c0dc6d54d330333ceb8a948386c9831e2562010253dfc502973032cdd23696df707fba7f4af5b0bffe5fa954c3f2e814959da237658dadc509fd392b85f625ffee393dc8708563bb2a470a5e3da62850d1dd3996279a0ff2ee5c2060005ed7ace33baf9cf00e591cd4da423677251c22f9d976970a45c41dc0c323d87900231865280042689841e6236f82dc9ac6b5407c98d7e50f461f5e01f68217d6a60c6990de985a668c6e0fe8a88acffb1425f268d343a497f6fc15614003ea4ca88bcc5d7c4481f9213fea18890c793f35bc535ac80f1d723ca113c9338f8ded83de61883170b4ef16fd494c45a8b3b96ea04df9cdfe2519f193de49a1cc83c9464adf534c71720d3d23aa17f62ac31fbaa43e575ac9f26efadaddfb02ebd68b11b730b3b0d390dfb9945586b02ead6721ed5c2b2eca87b080a391d22388e0e472e211ddb83ab6c06bf1fe4fd848945c639ff66bca60cc9964d30a813d58971b8f252a03b602e393da76d46a80413f515e7d51380d8a5661cdf326608264f2778eff7b7a353ebca87d6f4e989f4a238d538e990f87735a64f443b9c8d1a56275d5932a62367e3f9aa599c9c9504cf0350c0b0dd00530e872e6e39907c74d60142f2b1ae2130ee51a61a311b63e6fcbf76b1647b1575ac02f17da18d78a35eedec22d01ffee15e8121b395a8bf1f2856b183b1fa59dbef7dd0b9b0a2be1ef546a93267c821e671bbb1c40112f092239a7d65e3d26c4f7ee93e7b731db645ef40e759b2769d5ae0ecd79ccf02946698d76461c039d526f14d5ef221ea1290d8702c81d0e45369f28fd637a0878ee373afc4a1e68b7e3d6a7710b251dbb5bf83ec329ff7349226038dcbf004a1ea109b65906544beddfa96d80577f034dad5ad85ad065ca928bcdb58a110b9f46504da148e981a9fc1a969e808f59ebc006d3e44460ed63abb683c3d24bfa7c5c45f7dee8b6db18f4cee7cb839c5b292b2e05c25e29fcc725e712e1e2d7a8404282a44a43f9b8520d09e6b5199056ee0aef41ad07a227246dedc2b5b40995965e0e6f7976711a01d960fddc7a528959cebb3b373e35c9ac0f0d1e9cf43142683c2eef91f9912e3831e8e85611a0b85b385697c77f113cc222ac1ded02ba84b38f52eb9f1d24dec1d6b76be538229d83f455425a1ce288a0fa2535e43e84b88281c2a8a96dd78d5c763419b0c8ee3e7a036724e7f6ee125e1bc40ef31882c1ee1aac44936c2f48cf1f3d855163ec143b99e0fe2a7f83da7f97178cff73da6d1a4ce4556378918270b519e391262544c75a32f83ecbb96b4ec8e64eb7024aa174bdef047fde8d8c1d54045ede6e7877f289a68b229607a6acdb364853786a3cd055cbc2dbfa1ca3b0be21739cb66b0294d3f3589147897bdad747be884d27cfdb23fd5bf5995bdf5246de9edca8db23d5885ef4974470c1737ed95363273e95bc411ffd57fc36b691cc1bc3db036f75f6f32da4f201806d84b8fa26ce782404935418afeda7d31d45948d586349ff2ba321888c2191a1c8a08897f80d21db2b18e6ee8951d56331dfbfd467daa48076df8a7dc97aaa16dfd70c9f38f289170e8dd72f42787cc50ce2f8cf7a331736a348a17a62fc1c75e796a90471db7b07fc42ab6f84b1ee711bb314ae84a988ad6dc98941cba88b366138b3bbf6ed6b78988e56d518d4b57be7a64f7ac3934ee0757abcb445a32d65d1d345a7449565aeec5b0e96be680ebfc9679e53fe3a5bcf43e727faec8f7df22eabded81e316b6b6161720f77029ad159be49620bfa2dcd2cbf0840950a39e19c209731107bf9cc8f79af18bef4cdec13ec9dc98207bad6178a2dc8d50e247dbbf659558febd48009a1140118d75f61cc2d7898b9b4730a6f17f87fdc9ea16803af700fa5336130e788313f6166c7b40770015d72c505cdb3ca070c1c824c5bfeda4b240303f98e357bbef3edf2b19bc8c7ba4ef8eaf55630f24ec7abe10366fd894fdbd28800636671c9a103c2885aa98991a7b0c2f07c76fa74fe8ec1a026febc98570cadf93830d32304522865d9fce34c55b74ff3b505efd65a48edd8a0c223404049d0a7ef4a0034c689e267cd81aaf014e395a8c4777a7dcd1c2585596ac938eb62a1b3705b02c1cb2f936acfec746676098f3f2293585ed20d1071425a5640dff59bba0a35485dbfdc4969975efc8cd7d0baec4b592a8305d5b1e9b078bcc3442a42a66565699e9dd416ddbc34a4b70ffd14f7771df371e651d47cdd53088cdb795dfa5a488b1dc899cdef1cd987f9b858b0aa7fca2d915ee8b1de1cdd9a284003a35cf4a8e9dd62855f54befff57ee856d3f84ea6c1271481c940dc0ef82db3276069c7f1e41e17c78c0804870687e80db7ae509cd48ce49db379243b1dc895034352978f4558f65c88f8b28760f11026632281f13c4d8e5d2024069a403abd3c3abaf1be88c8e9f0d1b64714d93eaea39a1558ba92e56eefb6e4a5dfffc6ec393632ee9c270552463d404244ad327b75e172a92ee7893d0a0c67810dc250731f59f8b468c7b0aede0029735836e4b2eb0e4717dbd9605110046bec90c91bdf8fe214f41743d44e80c7ad65abef0c1110f0301f7813bbbbb9ffb7317952e27d711ba9638ede733543869074fc37846b0a3462ea1ad77de65ad76391cc549ef144e532ae9851ae7351ddfe543b2f22ad1e21c59f1bc680982fc85b3c57ad1b2717b4b7a9e3f5a1baa40a56b2e98dcc0bfc7700fb5a9c3860fafd57c37bde29cf33dbe26adc696567c4891ecc1d3ca190da83af34eb96a349c89fadff33f8f9ae774c1848bdcaf35ea70e401570adca4e54d7b971a9a8963b129dc585b1c6061b0df84ea76d70fe58590c50fe83a6a2705d1923219c17e43d52e612717182fa07aa85d6a9ffbe0e8e11717d619e9aec92af6241cf5fdfd3e3d28ba402daf02935bad9bec87e21163bd698ba916137c37937ad0c25b4442c9a79299014877736b9ee0ed26595f4893cdf7b63097ae2731ea9ecdcdabe80eded8c233770c2c47804e25c4ec09c8a3df9a5af9517f1541ce94208156a698d3bb7b2eb085390e508b8d6d64550e844a8c663213120c93f92d3bbcbee03daced2267897ff8c169f46cfdf7bab533e25c55664cd93318f32e5d02d358fa46a94741f920960b51dd7991c6e6ca184819090d10ce897775dfe80715cfcb33ee1f5c5b8678040f85ecd5405f4885a8cd39da74be53b957ceadbef252b16f21f3586d42a621ffce8861d98d24b7fd80904a75842baa5cfd509a5de07e450f28a4821bacd499c137eeb7fd40342b287525fb14594e0b01ed808504ffde65b68d80c19217025c4a9c70f6b3ee7ccf5c3a56c7460773c17977ae0731d7890cbe87e0272e8dcb7c45663875e38ee609230e747e3367f4652f7a8076563e190ac03a385da5a150c9fd04e9723582a810990991e4f83a965dc7557835253a42b496309fd808c327b4cffd3b0c58aa2f0d31e13da37e33741df596fe0a969bd7b530b44601c5c9e32ade757d7e4f7c0d9b83484fd8d7446427b1e5bf219ba7c1ed373a28181fe9777366f92b855c1559ea67c1207ef830a34e5d8567b26224b1f35a95ade64f6ef46301fcd1bfa52b70f5ac461a191b0b311432823c0ea97dd7c4bae8a3eda13c0e5fdee1575fa1f424595c2b73c85a0b70a7b4bb047472ee5ee370c20c2e8400697120a4a6c9c71f1c1625c259610ea36ffc87fc2866aea53ba4403c3bc9673c715f9c3de24c9cd1e75885eeda3e459d382e82734d98d35aca520b8d96aca1a3fbf69540a251bc760cef0772f91d4eb5d17ecf8a84d0778cd96647ed5802fa5670b7a694d91dd859a2386288444efe6aee70063452805d5fb23b26553388c730bbf8ca633a3ae617e0d77e302ae07a4fed6999456385041677d6e1b8e0bd32a9b9266be416fa0ea85e910c47a7ba9a89912f0c755ccc278f90aadf62a2d443b82ef562244d84e14a3cee4c3c76db92620537b7d8917126fd25fe1876ea5b0c6c948e06db223cbccf7b3a903ec3b278376f4c5a9b406c9cfe3fb31e33c3e3f4fc0352558f3ea38c6b611f957ca6a9b073695892322b6574e50b657512f9343e338710dec9a7a6ea0808ecd8cd5c7e526f6f26e375ee18478c0b62ce6b508b5a05a15cb226ed3c44cc4a3b9fc0ca49e2d7bdb7f963268d47ee6eda982c7812ee1de840abc345f551bed23db04b650b8ef66add4b5416b748889a82de4ab8a8a91322ac09c9b63552f26ba18e5738e875cc7320d835c60a0ed264f67e6915c0c473b2fdc27385ea60eb26be23131143b411bdd2e76343ea35d79cd2b2b4c0d525113935626abe227b77a48b68b244cf4d04423761ea5cbbae4254421ca9bd4a6deae1afb4f9e98c1a7e7450026ef71bad46a4f6545b0d255e383df0ea4fdd5e66484856e32fc8e4a8ae065db80db209205220050113eda89f3e24da9f9f7142b61f8b0e33675df41f74b421d8c55d4311a3f47ae9d936c315e6542e0cb0ae7d99d7f7b47acb61379f26d8650c510423fbecccf312f820375df62439b07b46cf332fb642b3534227683587fa6acf65761fa5e959649076196839ab485d964fe10d9b984f39bf3b6434280767ab3b6767ab9cbec56025d6ba3f6fdbdf9189286257430f170be6293035cfe19222c85231610fbc3c186031526ed18afc9b994b8708a7c04b6227333420293ab4a7d9ffdb8bf7815d023557caff436e48caf41f53e8f8e99f7454e1de4dbf42264cfdaea1e23bde15435a69ffcfa0894ed1d4fa63019d62d6ee7fa83732957f4def6d257f6e475fd47fe4baf99a390bba9e1e6054ca5fb38b7a32d898afac7dcb20c4f13b6d045b46e96a5793d0600ef3e0b25b1b894d2161b7fa475ce70b5a78e28fd92ef6973840f80db835868bf6eb2121b5bda4b2bec4c1cbbcb9c5ed73edac990a16f863ee9420e289577253055f29dc795ccd1596e9338f4ad95cd73f67d8bc855ffac5528c2bb4a9451651ea5326c20622d448e4a0075e00c07622ac93410cc3423b7003ff5dbd970a73c91ecadb9004bfdd63e6cd44aad3dae5bd1062518e31846623a7ccad8c0a6faea4cc2c4f22c9346ca44225f238ea89e8d94f8addbdd3a7f3bb227b2ac874841a4cc993536db3ff1e8d7edac89ed5c786ffc4162a215a2962f63bbd0cfebf50c4850ecd51d9b02c33a71cbf26dac610cd4c8cd14d1eb05830c9fc722b30cecdd38fd17ac5d94279992329e6d5978a3d50f70359cfbbd723d704a5b21affdf97bf7dcba75b85934f15b7890300cd938a9099a40dddc9cf3e7be9bb76af9035619bfe2e3535c8799c356db064f954640753835c1ae5c6df1dbd941accab6f8cbc6309a56016005556f9c08a7c70909d25d031208225c58a98fbefff8a576e5ade308e94ff42f2a05ff7af97dce8f20224c4cb91de92710bcd9f3a791c7bafa90bb93cf952e38e353686f13d6e8922c0101140d9d36168a0ece188e49e83566c57ea35e6956c18064c9f21911db8a768719a3cfc591bc549846bb7f76f0f1bd1f30f17d6c0ddb18a65f720fc4f8378e45ab10d56dbb704a545b633e8030aaefed4665c8945d10828d3fb33f070748fff9a6bdb6dca4bf647c3a0d35c1fbd658f219582ea3fdcf9dc8177f3a7d41982d369d3e85851c387156496ad2c2efd056827699d81d243955ce3d0fb604a78c5ce4d711a999d2c1c53d59e200df5dde949f5999c8aa16f42af0b0ad654ef2926dbaddcf388c68930f004e49114007ec2499a295f058275ac2272e7a7ecb286c45050b056307529f701e899ff4f177da3de3c817b67953fc605eb70040ca8bc56da6346e9761df1d24733d361e3db003db219d2e5286fa955eb74f6f24d8bf16cf5629191d9b9668c64a3200a5d4bfd88fb08d4219a609255044dc42e873a704fc29e0cd7f9d8bb7c77482bf2d694940f75212b2398423a3088e6c9b48fadb3288a11a011ac86bcbf57f39e77dc5fd8c7f22d9115e6a7b613bb8863fedc93bcea1c68d6bc02f2acedcf6bbd3d7ac95fb5d67bc519cc700bf76aa629767055afb50eeac4cd084b244f08fefafe0b1b78fb9e5aedeb765c684506973d68fa7280ce1f3147d9b02bc2e0b152986bcb3637e0932db9854b623df14f6b192f2f7cc5e7f7fa573286b3a3fd1d5e504a0d40748654f1e413f7c4a11017c5a7ff4c1c28e77a75ec9260bae2c3e47e39f639703a63779047e9d076fbf9331241a042148ec20dccd38aacddc182c996b4d06ddec4fdce8dc2669a38a460e8fe48955362a326d3548b9c5027bd80f2da1b8be61dd6cfebb3c1514a33f150ba303fae9b3091205606570ac5a62ece2383b03d0f5b7af9a1b8795601a09caa3d0e8dbdc9dfa083b8368aa8460b2e656b694c6afd9bfb96d20e7436a4a90037607fb5f0e20a51970bdc8dac4d14b9629f7c0859a4d4ca67ad5e5a290d8dad46fbee9512909d8dc54787768fe2edf206c9525b7443efa9bb66dffae9a42c6125de21397d92bf1bc150893c612ea4a88eefcfaf82955f7cfd91d15965aef444d8521e162ed598fb9eb34b1ea8e56e4c427fc58c429e452fa8447fb52829b1b2eaefd1a7113025c43aafde5bc26ab2cc1490db03e730ae33567d085d2ae31ac02a5f651e928ad4c753c5c5c3c15ef6aa2925781f5524b3641bd144c6625842b2cd0a1e5291aa121b39907375951ba74d41b183dd27f356b8c4e370bd4052242406319b60ffe86fa539e204b7ae676e2c7ff1d7396e066ef34fa6bff5816a081dd3f83acad5e6434a9bc528a53a9c9fcc708226e2616e25556523ddfc4403a8460f6f63c2355808aaa6071e02619c7baaed95f34cc6b3b4901389a8b70bdc435cd6fa2fef921e93742df2da6629c9f749b4e8e6e38dbaf85c2ed9b3929ea24e6c3e61037e577ea5ddf997a55af3ceb6899c5e4ae4bd8bf65f1999034ac80b6e19da18580af9e5629724bdb28bc3ccd16074839bc52ac95e105be2d7e51d7417fea72ab06f4036df688fb9daaaaa23c1778bf9b60d8ed609043ef8942587e2307e166536f7baae7d912b3943e66d0255a14a0710f151439f64ad61df4c052cc63ce932cee8fc301854efff0a4f1acea59e91a9f7865abb3ce9b6630af5c93a92ab52ba628f0ea05a6597ac338f1f5bf77a2295603d760177802e018b25d3cba8ae3c5a08edd3511ccf8e18919d4217a4dd98c5a169664161f5bdafd3ab2023723f72bae8b7b4d8dae0db7132b8d252836c83a0dd0d9ccef19accf5a459482b8995d7749b7c08294b759dcfb3a0022640b94d670ea9d5b6ddb7067c1f3db2e2f40fb3e3f85fbcaa60bc2c8e553277dbc518b9d79238cb83ccc0a9850e44301a9f59bedf1283e41e7dec2e2f33f8944042e2532ada2b035a58162599d339401ca827cab4b5a749ac0b355121cf78574e1f86ae4a2e2c4c914cf11680e6673fec4e6578c3e088c03dee494a12841c9b71ede8713185122bd1c21c2597e3bd81463e7f4502b371053cdaefc828de7beca3f9412fa33840400ae9c79a029108207b0665716df132132455c75e5903a5487e80424d90acc12814181f4dfa36d8e0cfdc32f550cdb38da449b735e0aec52194b0d328e5b7a546333ac4389ba559a8d8f59e385455e218a1661842cadfb889ca60d715382105991580de5e93d3d7e7668100b2153072071b6b4356c526218e0de86e1d753fa6014597bf8e9511a9c7be8d54c9bcbf167d5eddcce97b5b5446f89cd04b1481690a97de9729ae850c3ef58480f7249e2cbb7548bf8926ffc85c66a9cf7ef61f2d85a25610e242f7a93a5bb1c8a28f76c2ed990364f5488e397cd4291fd5583ccca49b99357cfeaa815940f7a01ce93e22839c447b56f97a99584132e4da82211e278978ac32bdc838ace37beded22d5092e2976fe895cd3efc1dbe92818dc249bf3de9c2899ace2216f3f632e5d981905953980d410435908c577ca2fb386650ca4d64963c6a8b10f07bfb26b6d5c463ea652aa355861cb89ace675766f01159e36f17e611bcc735897adf3d5b36ba70f8f2508d16e1090bb77265198f1e376c10e161621cc187dab3116fa417aa5766c22055155bfd8c1d35c41788ae60fa8f1618e8c130a60c3fc5fc308de7a27b05f17faf53964ee8aa1b8c43efea8d04cc257f76f4ef2b85e05231b234af1a489ed670eed2f8d72369dd23022e34eccc59274505366f326c84085fac058ebec209f416b5ee462f28af8607d704c073c7710477d1b12284d66eab3c24d32757054ed0010831b62301ed080701ba2f0f546a275c1704490fad76a0e27e91c24a954db98930cfce184b493d26e3d9b1d75d5e1e5410a390321d048a1ead32868c8533830ed1c63f9ca22e1650c6f84fa6f8a4bcc24982b4d20bf98a0c186eed52a380b0d2fafd7ca5a240e68c2f29427968d09efd4112c090558d5c9be4423bc74798dc6ebcf0ba22b9276da1304d47ba061ba2d5bf307a0aa48e14a6188e0591f5691b2a899790771350e555cf1773c704fc9cfbb2ec0d8296902df4d4686a9ffe062af194a8ea0603748b8dc95dc382480145333601be7fefd65648ea69de2ca7c3a73689aa3183da754d0edca3aaef4f11c4a76bddeaf6d31fccdd1873b1e6ddd658673c65cf83d9904c9fa371a52aae49f94ea96596b95b05a32f58aed45fca9e7be0a550946650aeed034a290cf1e868ae3e055f7403187f5eb5b17a95e461d59534e95fe084cec652f3af9b86a0cfa2ec88c7336ab530ab74f3e1fb388a7130eb0680716d303f298b618eb9297c76cf62cb999dbdebb07adba023131d9b00d04dcdc36c9392f1e5ad2baf4eeec1c7433ad473679a4cc34f338c15425da699a7768e449664c0bab7218f651baa572ba967aacb1b75313a3b88ccfc8010d5fbe5f5b07d9f8b8d40e286a6f454f53d226fb86e8c87c27a339090dae1af351130c23ea15ff61c06c8f72abba72e817a3ed5cad478fd3f5fdb5f1bc82901a6b06cc1d645bf0d64ee05a1f85574814efa06d5abf1ae4d14b5cbd7c4619fa87e8fa99272bec4566e42edab68f7deccf3c510654f09e741d41f98efd3fd51f71496788e1edfb78cd3650aa4109664138515c6ddba7987e968d5ca5e4ecdd4ed1183d55df970492faaf58dc5a21ddbadbd82df2f54cb2b60963c26f4539b846c25ea7e78065c4d854a1422cdfc08c3d5dbfa72cfd653fde249709383bccb3153f49da24f0dde32b2ec808ab7f1ba52b6352a54cb5ba290e2ce778480d2af2b194d2dd3b47e15b98cd16cc88c91c77124273a52920b2d346192858c211b79ddd929b482aa83d5b318fa2dd8f871e4b1f7b54ba82ef1023a5ee0b4329026028d3e3f396803291b24ad4c31379c94b895ec697854d544f9113541e7c367b7417dac45bd42be8b3b2a1ca0dd56fc9c79a937df8f6f6e3bde3cd2aacc15b158c22eb36b69ba13bd8f4ee01b46ea05e047c4f41750c5b686d26c82c662b9f5506bd44064e56e4dd1f0e6a9631affcdf17733664801253d7eb637b0b0868192baea42854622dcc6df0b43f9f419cddf054cf4619b702a2bfc89aeca23ef785f48a9674bce8005d2a3ef4f8e46b8ca1e31fd9ff05f05b0b866b71be965b290deea9b6e46b2ef86482e691b8cfdb3268ab76db6554af8b78bfee79caaa24f56b1ed468355ee4c567ecbb66203f0514264f3d0aed7db240b4d5b2e5ec9aeb9b11021c5e1524282b10c6adec66a3f5db8a657bc9148dda8e63c6a5db43c419dc6ae453cc474783719602a2b7104384fb5cacf280b9227d26e00863c41559d78150f8d441c7661e9ad9d27f53baef2b5580dc25fe6ec79f4600968cfa7459be37beb289a7f1982f9c428da8815778f2234dcd0cca1a760966894852901169529c74e144d57b852a74c169c5fe874230d9156875b2d37187b9ab1b03d7468166ad5e957fe7b409acaa88208f36a933464905577563200a7004086d01917f9cf8c4d5b06613061f975456e9753f3e99c32f3cb676f0d9680fe0fe120361fca50b0a3f57aae98841ada9a646955f7908081df62941481e3ea7469bca07a4dcb82c5732b7be3d20f55b40ddd89e57a49263869b66b102f67383491c9d57eb9293502e06286c60898331b38eecd25b911ed817414f9adeff6c76aa51bd139ea3915968697a2fe454d8348135690fbbde45c750d6e3313c1dcf78bbb7da2a20f60c6e7e83d2023cd51e40e83464f573f1718e8fba6db3f07c03375c922fb97c654c3480a01a7e9ad616ce43ce8574248df7e3c495448768e2377fbb4c23ca6d4457010b18473dbbcaf453f0acb5e06bb4320c3e18f845b12a24e0ebe69b7395791009382acd73af8d11abf774c376603daa8bbccd5d151b6971ef32beea61fde0577c6396f1af3c9f46e9f43833ff28e72251651421774ccedc068b6b9a3dc849c68452c5c6f9626ff5276990f5f6ead3c0ba4850975da957d5aaa531cbab8a036afa512fdd8041ebe87dca9d8fe2a938e3d02b3f37aaa84376dec6fcaea4ac693ceb736030d915abe42d456ac20aa50fe58e790fef50a324fddb31d0ea43be6d2fc2e0cccd6516664993208a96376e1c52dc021045178a2dcbda219940edae0e66ab8d3454603070a85d8897dce2f634e884795e4271c4a9842a3c7514331eb9a7cccdfd6b54d811c9457181d995f8157b6ec48ffa335367caefdbb813e68d3b6dd7226cbe6210892d0e1ab1459e8a2707b0f9f8724664bf005a94cbd1eeda4cab7bb684d45cc27e80d1f57a40e73efa0bd1ea5e7c0d243cba536d6e7addb19c835ef69eb13a8ebd6ca03539c45fd3bd8b0081266a9f04d74fb3cf5f3fdfbc4bcf1d8a0c0c8d0cfbbda8f771f2a2b24ac7f67cee59c1875f50418e2d553a978184e4b7461526c88a4a69fe6e01bec5d28ec2516b39f02af4fdc6ad4c6ac8876c6dd9f8d7bb8bcfe8bcae3835940cdba1c74fafb1ec2bcfc03bc76cc6dd51f1771926e700c0d2d6c25103fd73e9a115d6f73c6fcef294413b85b33f4058f1c04e865b49db7320c070e7ca8277b5c74cc9244cedc99d010d335c87c74d79db53d1b72fb7572862ba55140a67820ab1da942a33bdc1bd792c8fd12768a610b685eaa5885d10734b275c3580bbc0ccb3b06cf5bf365909e3e31847d64a637dde7bbec2b21912","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
