<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3c819228161cf51749182bcf45d024f35f96e5c4163dfca1f50a60f733bce2f451959917fea000ee4fd769aece0aa3e50a8253ec4d17f8585ce6883d5288e23b228d78b8a2de30a4989886550774c8dfd1f936c591b3ff05b16acd750b4e3d7b65b2260d53c776b699cfdc4b41f50a718bbaea99286d75f8db7d4597e9d05989659f2d076c2e986335b88f8a58672ec653955bf43f5be9084373e8f11c7e8626c1ea8def3523dd7328f03289fb027dc79ecef6b928863ce78439e53f3e7d113a1dbf30b89d05b428e33cb39781d3222dd19b367bd9b5308881824902aea0e89c4bac1c85921fea8aa3c425e5a8c10cdb1860af18f0ac31f8648a364efdb00e277dfa9727987dc89251fd934cbcf8a22b8e0574fc40ba1fc65a66de94ecdf724aecbe8b16c4a6bdb2cb95820496b8d17cee1706c5a973134864e52b61dbbc00d255d2855173ee2700240ef10b690e393a67b692812f7e91cee75121cce87e131719db7b5e6d3eca8ad5f26d5ad226ab59750e1154d7bbfdb632dee7ba20e61846d6bff8892c873451a6837e796354df877da33a5628e64439bf33348017ea19443bfffea93c0a8151610dc2accfc3470f9aa7ee834c2868bf7ab942b1b72c25abc9197a86825a227f75d7c9bb32134a737171b175d0b95528373efd9dcf2279fbb5cae70d65f9d10b70c193d94856482100057ab6cc737117a7058460cd320e56a1b4dfdad3a69f6ce11f68ad439f49e6a51a62e9862bd53f61fbe6557d31575c4cd730c7a60001b1371476d8644db528c4006af8b50b6e550b330defa41e15b3d995e0c3b5df562295601b9855d7c4ed798773dfbd78a1afa6d6611e530878eef2a482bfe049adaeca8346c65007e7b2f923a85aabdb1eb818361beef13b7dd9086fdf68faa525cdbf65f0d83acbdf8a70a0b3d7da5b59295c68c4d248cbbc0606f9fcff3cffaba5f8d67474551d16ef289c0fe7f21006e472446ff0962a8f5b39a22f65c1f4d7698d303569fb8d46648516f9eefbca7e45120c6d17be96c8524f053a17de75d1ee639a5e704b3a35302b93aece71ec5ead356971537d68983d8fbf17257a4284183ef0d59885e4cc54adf28d56456e09c5ab6fc65b34bb073b177f12c47a6bc96a252c62689103422c60ba0016c95974dcf78c00cdaa126f7d4d1b705f049f081f196ccfda9a50b63d7e17136e3345b0b704f87622618e31fdc189144322996267b7d0e1bb85d3efa4bbd89e95828c44cdcd6ca98836353b1aaef500c2f8ac967edf536ec1053b38869c183b43461f2d4fd38ce7b2020f08bb46601edd680c11b16cb6e01a8901cc0711db90898e86ae9f937b095f3ad5a9ff27ad27786a9e39641ae1067989979a6dba3197516db3f0c1ad8dded456c68ae81d5ad1f3c2c04adab432c697a90b8bfb0df8519934d0b251ac3d7ac766aa54e2346f457634e26fcf76495a365e80f7d45e327471fd05b725e5d328f2393867cdc3ae3eb5a4b2a94bf9a314552dc2437783d228200e9fd6a170604a45ba11ecaa689bd0f06a30321b8725f83fa65c46d0d03351cef72024b18174cf63816b8225891e1958ad3a77941b728abfb9e07e05f2a65acf5dddcc8372eeb98f1189ba89a31b8ce8d4f47f0f5f5b1e711540aa30fb62fce2a64ec1efea4568e616bf03e56907808f9f414ad07d53caa280c906bbd6fb2eb4f9c80d7471e361b465d28be56ec8e06f5549fd5af5da953c573ba478d61ac314033c6091ae502268b0e4b6ee34e2180a6b3e374f01c6ad915b3f7652d1ff119b1465b0dbe69c08786c06ad065aa46b0390d3c8f014ebb202804e94e8a45ce7ea7b515310e1c711ffe3b5d60baa51b2a82f2ed1f3182178d3bff4b55400e5283743f5c87b847ae3fa5f54e42d7756765ff6e2d00914dbee5f98e423310e3be935aa7d1626adedb9d2caec8aeffa210a360348cf3ee87d0ad4e9b19d7f1d8bd3884d0313c34e6bf0cd7377b3bfbe4b69493341b4dc2110d54c8100b6c0802e5decc3eb8f08ac07dcbbde5151ebd854f17c93c01efd6ffc8d609976a6251b759400010dfabcaf1d2dd7d2925ea547e098dff60d86095df06c01df4cb5c303cd667ec3285604a70f9c824c25e6036712845a9493cb72d534448784bf6fe54dd475eb5bcf897cafdc690f30de5e35c29daee54c83ff1d05c2410bab40c5d4533053aa26fcdb291867af20ec2a9d6eace1670ad49898e06a1575507b08c103ca121a06baa6a2f51a38ce6e4c688993b3089acdc4b54aaf07dcc05e256e4ef2c53676c350e85d398d7546f42924287669a6c5407d95ecf844eb869be90a59f4e3e3e40bc054fe016ebb7f6434ab31022ed5e4a0ee5557e8abe87b5f48e9f3c6de55d26671dd7c27284058534188133370e006796cafdad5dd0bd519788468a60461aedfda3edbe18a559f570a2514a057971bbad2d85d56c749752583eef0559b8c1ac18d740c6f06e46b0b449268e3ad4b29709ed4fed88594d0b9f33218ad4f4b99d345fd0e2d11d4c206259df43337275b0f91981ef270f2d1efba69d1bf9426bb613f8a040c99432eeb5eaaf42a0874cb7bc0ba3e8608afc27059921087b47a39eb6d783fc713bad17480a2dc2b9dace038e1243e383cb1e29b87b4b92ff2c9f78256c747ba001a343aadd0fd4ee0a0f8f2398c8c3205a73e515f91640042d37c9c1ae08e12019df26ae8df08ab0bd43fad1b5e2d004599125ce37bee062fc69ce86d6dac4f07331e41c908f7c84593798bdb2584b217b2a0f07ca54a024ca2be2e1c0415635ee6b8879a12f0593aead8ebba75c77f33cba55f30296ceb8be2b19b8a91db21a4ec667787499757b861626637dcb09fbc31a9e53ef1462a17f29e86bcee330ea9dd14ab56b14e48cffbd1627a9760e2279ec15b26159b9c3d53cb0fd51e67084b91801a3dc16ca13acde20921ef369fde6175034349811c3ed4e1b68a84dc1976fbe63be9a82e0d477a9d890accd7f851d1af12181856a3e71ad33d613ad4241110d1a399ba075c77a926f57e485ddbdbbe5a13c8d68ea6b8ae7cc958ef5d18aeede4a624cb240a36762ff71f944d8bd757683369120ff560c58b5e03b3c148289f52e8b32d71c4f23e8d4c8d08fa92a7c7c270c994db7edc4229558ffcb3645b61d95e903c1a5865556950c53d29c3146fcb0ae1c2ead9ffe8ca6dc586ba03ca7d434e82024b56d4b7c87f2e182885140f513159d3ccca54b7f1545a1ca823efdcc5a0f3431eba548fdada900d5bfcc0ce2b71f4bf4500866aa9fdb540daa0d102b1ed662ece1f293090d95f6d7ba7b93a52d0803d19232d970334021ddf9db1180a1170c731a04705f8c5bfb242987c2f584192f618862399591e412f15a6a2465522bcc6050448b3b58bcc922ed40732b25e27fe746314ee2dae35dda29741cf0036f048d2c07e0c7d827fd86270348c7694ea8b5cf1cbe9ad1c598a38c3dacb161858ae2cf24c548ce98ac7a9192d3d659086a8a231fd5a56f33cde3a95c8a4d6ff6aac4b392875f018ca3a2ae4296ce2b1cb82b202e2209041eb23d69cf5b1ef462fe8374400a1b681a8e95f15877c5382921bf0659f7886cff005484805f743b9c19a24a14c65f70ca5fa93c48ccd281b3fd9889b21f9c3d2de5abe08cd3754ec73c2b490275c7c57354f4d2f270297de2a5eacea5080c6ce5db27c3b3b514ce920257eac9b0e468169cc771ac9b6c0d2aae3abcde17be3b1304a945d77b7fc997e1e0349e2fb04854e9e4280f07bd262277e01318ca2c6dc2e5109e80363af468a8978c5ddc5a9c77ca2bf9d6f2be32cc129b35f8cf009ce11e5f20fc1d2b067ae645a3627126dfecc278a1a39f25e5f5a608ef44e284f788c8d9cb01649b7c76590a672fee15448eb134d041a36ff83d33fa396273d650c0137bf5eecf28a85932af97fffd0625ba8248e95d7e34575ac7e5ce51c1ea606c5823d013044dd90aabaa469e78c226a7ae4c24089aa22fd034edf38d6cdc7d3b89a901c21a66a1d9d62d54c4e54e42699cb6f84473d6343466ab39338f92e3de8276f092679717925d9429964bdf684ff8945c219208dedc2533548aa63a83a9fe01bde37089aeae86fd966893e7b1695c51016c0c693419eb63b17293337dce632f4b3d2da9e179085cdae51784679e675be617b40937ba339a764e6a337783ee838ce31c092ba58811ad13aa6c05dc65a8281382f2959fc5dd3021b3a1b81e89421e5930e7437a4f5663690674b5e14c54b342ae3048ff95ca0369fa96e4ee5dd31676226edcba6bc18ab50791c0e7798ede73631aedb002e6f531552509bf03e2d0ebb1f563231889cc365e24118e2c1f880b85758583b4fad724fd85e6e14a29e6c905686bceadd6a51b3e7515cbe1811f759b186cfd6218fa35448d181869bb6210521af0f4b5397f29e8ed0026c87c63f1797b3134b66d9a74f5fe82325917f531f75da98d0639c6645d0ff49a8861a77c5ca48cc5f60b30e6e6a58c2bacdf4ff7a0351a799376f10017e48920dd018e34af76ac17c3bface5b4db1200cb09a2c177e4d2145cdf2e0b4dd710efbad9af4f03411206dfaec5ff84891a54a375c77ae9ad734e8d4633dad2fdc3ec1c63c69eae6bd1effc9382723a0da817dfaba98b199584125485775eb7a77649d512d34dc51df4266e83f9d4b9d8890b3bb4e77912bbdb068577ceb52b7abb0c2a381387ed31ddfe86816c99cae28ef685ad16a862ba61b843bbca1be8f2b0e2914711045189535cce05227c2395c96da6a286359ba4120dc24fab5a1cce0b4003e577ec64986ee0c7f6d441fb5327aa17e4c23bb8819bd3b9781793e7539eac48bd54bdbb615960c1e71afa07d99159fc810adac781198ba77724c03da0c5f6ffc7e309566e6d8e9c10a385934a8cfeef1f5ea50e0da6278ca9e90f15688e324d867db1964abf18728b01c42d3434d357e638daedde3e535a3397c6f7e32450c1f1500995cd71b119adb08541a72a67a2029c37be4364c7277cfc380856d8e4c4ade90cc97f77103bef5dbaa62295e45d6c89f474f61a608593bca8b71dd5df80d4d69e5aaf6d07264ae242c49d759531c12895da0ae6d275bfbac8ce595acba40d0cba2204fd2ac53eda1b2eab1f6bdd594391671dc749bbd8d020e2595a2c67c1d0cb7bb7637f7c870ca6fc770eeeb20431dd3f66858f3546f6a621c9f5fefb8bb7548b2b675e5cbcde674d76e82ccac45766486606e2c58ace8fa545c7e48383ed789c5ed6d906ed106120afb486c587d091d5ccb7b4c3ba3b8ea13a7e1987b76a3f790864a33379118fa87d6de6f0b139e03c3cf92105952eabf8233835421a0c9f4497137bcacb6d103fe6b97b5ac9dc0504dfa6ff4b95fef98f4aa721eab977c986f2eda6fcb9fa232f24b858ef7bf15cbbd9903d3b54bd87147857c024b17308fa0674e899384027c458b6f591ec5783feb755bbeaed254c857b2a42ad946a291c586e3ca9d9c6901ef1fd1673d72997d5b6e059392dbd89b927d47c312d4291576824fa250f11d59ab12a3623c495b98797532d0261f6d22a4d28204d736f98b90329b145337febb5c57518fffe594a309cc209c530d60772184e9600733a16c1d51ec87f9eaafe5efc70e16934929a1f92d530fbe827441df5208f2063784017f012ddfa349e2979ccaf8d2c4f40b25d0603ff90fa9f08ae1b267450a4fa807b47b740184ddced60e822ace7cc1bed331c13c94ccf5573f8a1523b83c82700dcc2ba0c2d57d350c941bb62596b2b92b4112e0567291e8f4eda3a119a53abed55608689a619bef397f58fc4f565439b697a6e0bffe88471cf5bbc163ac3d207eec5d0264740f69b11eed74e9a010fbc138b7ac2967542a30e34f1b238a6d79b289161c2dda5b130066ecd117b888e71eb2beaaa1138ed760dd5efea6109040d445a81335d5481c8419d4cb2bf9d5816febc1815917353cf182e77389075dfc8d92a15d1ff41b666851424a697fb0497b371878c51df36680d51a272167e1cd36f7a01259623b67b91cb32ff7133ea228ad226b5dba78df54a43d841a5fbbf06f56ad0fb75fb9e8fef3ef39f97b7de593b2256663bbe93c584e34bc9124e6636344e63cc8091a370438a6aa0a26ff8660a1353ee109505f91011151faf2c8b26afb25d1f025774d51de68f1d5617c65aa97c9889d2589ba9d84cf863de8468f9f00d7e51ee17732047c5ca31f8cd54a55089e48f08504b38b806264e5a92074114f90905d19649113f84c9b1c3e978bed2b313d4fc10876552cc5bff7d85e36aef0182d6d07526918d1afca1e791d8e26eb241cf30605a23fa9759bba05f4ae17e3493b2915b730ca5d6eaefa62ad0dac999d76653e4d2f09dca7f3f8ef45695f88eb4905ffb0b008e8d881986cdb2648792e46bc4bc101e93f646df3e2f118b9f84b5306f34b2681093c7508e61ce562170daea0afa9a4c16e5c82d119a91d432018aab28c214fa7fad9d2c5737411e6bc3f4026ef7fdb5b56b9f525084646216beb85f7562e467fc1759716f2c1c6d7a1736a20de13d95598fc0b204cb2e8767008a5671908e1e9d690872285747dc67b600805efe17cfb9469dccd3b1e7f0cf21271c14827c64d4ecdc192e2f58f297609c0c45ef36ef0fe63041f51dc68c1267b34544cc903eec259aa95c11993a3e55efd1ab3d0b3623262344b84f201c7b261fdd28f0c782a6304163b3333f58fe2a81cc788430617d0f4bf4188a809a196b1a29df83ca925350b8244b994187fa79cad21b08541c968fd4c3ffe731ca64164c043f05612903b9831dfbcb22dd0c93da95acc352927d98b4eddbf12cbef6b2a0a6e204ecb87ceaa48d1eede70f286403fd46947383830010c6856da2072262598795571d74cf17aa98122249376bf7e7cd1b7b05eaf037afd78afed0559a69a6407d727ba9ec32f07a93e45cca265e1c261259ddce56039d6913f48e884afe42838d096ab1119f6947a5590715db0e767fb69da87eb2a53a0246a3bf412c66beb43a22f5226538af1347d1e431784a1285c4fc59d5d0ed189c70b20bdda345b9adbd2c0091181ba71d940cac6f505a2f6302cfe5456ff105e78085c0de9c8366fb33157279cf46d9db3b5275721c79fcdd769916871c5b91cc7524bfa277fec740e4eec7eb8521fc3e0b43cf5fb4e5c6f9c6dddb7c12645dfd1cacb630dda93dfa7fbb6c9136dba6c75cafdc9853726f5465fe03557b71eb13c4d6edd429c64a18549852e82184cad96466cca314b1b1bf7c2b3a34391a8417faecedb82d41ce4063522c6d484b11ef922eabae922cd54808ed7db4927e644e6d25a9f71bc974d1f7ee0cc5fc935c17753a9872b4192de3ebc15074ff8dfe21c9815740539ce0f060b60f64c5645cc1ae5708f6e90e90f6b46031ceeb74153cbb5383596acfc5ed6d832f1f164d12660a571805efb2d40776e59d309128a9706321dd788d2d6fc3e7fc63aebd57c5c05de6aae1258e79de4fac211f087e7978a1de8b284330c7859a1e9575977551d8f93a9df27da3b028b9e991f42bc09c846a91d47a65d5b9fbdb2e693b6792579dc061c0d4cbb30fffb855f31fe2919b3acd2d874ebacfa1ad390a464f56f64c882f7f01615e1a0c635626398b5b56e659fcec2c2b5bff4c8bbab958fb5f5b259fdefe3ea7900207bcb032e932a71bb2bd2b69102acec65c3db2e08d580f280201804331821ffd8efc7a6d7e0edde51b2b0d8b7c5ffe49df26160fb7a18dd0db0052146f6a6766cc6f61d6df23eacc987b805ce4cb86ea40566b29660ef3a25d5afca49f1d5bb4284424afdda2b110d246918e86e2b354eb6591b5f9cb0a1e62cf929afac76cfeba416cc87ae500aa7cf927b6d91b5d348bc4f1d5267e57fae36272d7f84982e986f2715ebaa2c00e5f24804102549a016e0cb9adfe5d76c6725ec3285477b33067d3d923090089217510edfedc871696dad99a3e338b616e62e84dcbf7d9129ab0ee2c061f18fe6792eaa7041926e595feabc07153a7b81550710d0e7982293e5f58ea66c8c307ea4cfdba76716777a6da7c353cb980773dc0eeee4ceb367f3c519f977afd827feb2227ed132b8bbc1ffc0b03147439fe7ba4ca9274e5d4a67f2a359425d44fd00bd25efba8deff4c61e5e9b6f80add0f60f4c4d309f2625441a723f81ebf1083cdcf0166ca0e22853d92458a009cdb5b793620253d936a399dd0666a0ebafbb00f486ddd99b97e7a562644905d026e41616f28aaf794f3b69ffa9c2842e8705017314f6e1614ce94c553eae11e5dfed7acda64acdee45fa338191d0314a1ce2e5cd75260b64ae9cb8e4b89b78761f097e2c2279271b0eae3c0147d6b0ee39f7ca08f8bcedacc5cd0a8c497d8198acc867dbfc98cd041659c17ffa0f145bbdc2b7b7ebc41191d5d8e2bc9e5424aa4622742387010d1d8733e5c5851f7a8064e03d9a6bb14053280e1b460170f6497cf757948f40f1f00768141780a4234163b9fe780762688facee69d047ff2fb56844fed9a05a0c1f9480e4cf829b58ba9e4e12c483da489aa6e6eba1489365a64f2f731818892a697ba1ebf57d1f0386896305a542643d7428d7b1c75483aeb49fb5f94e09aa03e8d36b0a4e248b6aeed4a6b1edcccfd487be355c41ea2b9dcd5071186647b2f35fdeccd698b9f39d74eec81b9298e93df41644250b2d1ba4de273cee3402d48b7c73864d2e9334a4b45d72d5ebf057c94de192f5e0254b08e5ac87893ba12fa0f0428dd7e6f026d133f9a1c08225ff1210e315a3bc381aff6b98bcf04a5ea7c8b9bdf2a6f2561278a9807d0518065a247dff3cd1c0514da27f24e30c7c52fcb1f81bdcd98b6a30fad999d4491dee875f9185eeccf7f21fd877e41725f5e10794b6997a5077a577efb7211446d26c341249a08bd40f37310c44fe7659cec1fb19d54d36761f5ba10d941c9f6383a3a6ea5685024955fb7a34e15301362b886544187d3dea3040de53facd0012e1e121c65fc744da9aea1c4c1bdf5a5bafec829eafe31bb94f2e8be47f5f5f8d44784d45e7136532a65387a2409a396c80c08b33eac675ef718136e4f868caaa48b05814f0149390fe88c17c221350b34b399f47d694176da992d5a8417bcff98532749d47b8ae19c6e45a6a68f1d59163989745bd0c1477ec770c385b9a4ff639763b61dc0ec535ba6b7752aa7c0f24b162f3062ced980abce55b6746f634e8a42b9ab1aae417e8a41da2d9173e860f9d2b742d405b18b1b8c86459ab3e2d9a7f865914f52399909ad957144d94095367d9c304df1d55fe6423c0e35a7ef3f4388fd86774ac79c0c1eb90c46ab57d33d10832a6e11cc48151662ad973f681702af08c4283bb727bdb8b9fd0d961ec9de5d535ac420c9cfc3b2f4885f1aa86877986be883e4c66b45c5cbeb8db8f5508f15504edbfa4ddc3f45f34250426bbaa2f8df9d405dcef8df6ad98fef0c36b9377f03a98e41d473e38d4d6d0bda58cafc2ce4c20f92883d9100647d8d391d4fd1e9d2b3b2513e383a1316fe4a7b3eb63b8740fd1aabf3c0be6af8922560cfa284edfd99080eaf1bfc34e9a44905238f1b47dc3ffd48a63233287b917cee22b0bed1f76cb35ab508a3760c8edb6b60467b6bedf5a8985febfa301ac1732d3784c8e7a2332dd331758f2d9362a21319f7c926b2289189c889c84ad159f7a071a32b2b8c10db6258170176debdee097916f4d4a5565114df3e5860390bb1529e5b74993d43cc7a31d80c3a6f73871848c39539365d9a6f2201f84efceba7efb6d3ba810b9a748907dd98765512a3dc3331bf9a4459fcd69e7bca2a5a895ce34167304c54cebeb467b8e3ffb3ff5ca2d9c86cc792d4c62638b99181a64c0a555da76816e8f78c1aac6e680cd63e3a063995acf24be4204106467248c3b9c258d97ecfbe68c567ca0b83225a27998e0337dc418c6bf56b645934e6ade77e8ef3a2c7c16d74396baf753670fedf857d36de887e4c5af4858e6bf41251947d5fc82a32c9b20f610bbdf6ab5645364c90cf720c38c1798c821dd305c7dd05fa67dbb6035477a11c384504908f2fd133d64f56fa41997535af3b570b1dc4bc9d83007d696a5128ba729f3caca437107d926ad31c0a24a0386c212ad7015c018f487cb431c14f71de59f9df8f7028808caafd1370c858c4ec1f8bc67fc36d26cb0dea171450ebdeeb2bd8c81c2e8fbb8ef2ef169b32bc747762fca4fdf44a6bd433dc5239bc58f44c2edbc6b478dfa7d8d0f0e6d41acf980f4e5061917f1ea220da32526143b362bb49d9d084cac5fc42f4acfdc6b9fd2db840ccc6a8ff4b7602815da7becd3552e24342a36aa2223975aebae6cd14987cad08390a5f73be3ed468a4866468cc7b6f1f5f68c917e7ec338fd17168d96ddefc6c061e3db5d80c4c2a60daaa3bdf85433d0608ed787bef5e66b8649b5c38dad0114190c052c2aa68398911b40c883ae06f395f2624fe2e2841b64635c208c311f578ff1fe7a30d22fbd5b1a05aff83aac3f05168d7a57a213831fc53f3eed29ef66a0597ed77973deac07f4de6d60b6ef2dadd39b3e50bcabfd5e732e6b05942cc83357bc8ed58dd645d254cb4e203adf32c1e0cd3808f4f02bafcd6e6cc62a0fd4ee7d64198378547042e18614556068f46d2e38e83fb2cb65b456ff9375330d349f683ca725a7b44866565fd1c1101fe87aa83c3a5bf632b62e1ffe6cfe7ccdef8e6dceaf66475e5420cb6eb2e28b84ce9df34fd3d8caad7f16e84bb17d20ece4b02744b0f1dedb4cde31f458731318a6fc7be33701f6b1a222c40ddd2797554249ed75c958627c011e4ece8355f8f61d3ef1977f9f44aff7f8008d39aeb6a029dfa4093cf7ee4e4489cda0a18da57687a7295891e37d3f33327d69a199b157b57230f9ad5ff519fdb9727e04cfae0cad5f0942c9a6469ddcbaefdfa812abfd0bf55c098af81100b389a80a85a40f7f82d2b1db5554214930872d99be0d8bf345ae3d86e74e76ef3dfa467f66e227ac5943165f50fbee991b05ab4396ba015120f9b812a12998cc9de2829784f1d785da0dc0ed421c88c79388f8c9d95cd23e74f0fdf129126d2706937f2120d4f50269a68415bfb94ae11a591101b811e0d6954b9d943bc15b5f8f81eedd2dd112227ede44044bf3f3f05663301d01564ace3747ec3f9b9df4a6b6f2571678d2a43fe053402df4a5fc6a2830b6e01a25aa4181b7c71f5b5f7f8c361b91892752923407fa67563808a92f8f1ab6d672e7ce40a8ae5f5ebc5b0adddf0c0cd7b1b750c1f01e7f75a71923de00b23b914a8afde9fde973d46d896931fef89b4ff6d679fa486b70487e889963931824cfc7a9ff2e45d037aeeeea1b31208d0c3de2344cc465b874722e9516af42b45994456d9b206eb465753115211f3b31849d96adb00cc7e89a3fc48d42ee9dcdbb1c8e2c9fa4fea4420517ee90bbfd058fe22e36f52d646dd0e484b67b1db5f45aeb8508ff62f513126c6790c98106f8af081c87faa08aed114517f003f5227648e3910eca000a3ee6078f5de2a7aa49b1df6ce85462c8c0cafb7d642886290dbd7787737459be40dd277efa77ce3c300b8b242a4e623ffc4d98c58fcd5cbdd76b05d563e4aa503e1dac0aa0fe3e2a0829d25e8691a1e831fde877be9c68b6d7f5a5c9949ec95634635fcf4dbc5f0bdd6dd18a05f52099df44bd1495aceb5404396215e602ca099193f4e4ae0d9371c7080cc10dd246ac0dc9b632acd5447fa7b7b83a10c9c75bddf7b7515bd7f92ec157b162c08efbb09e06e7206d8cf611b387e07980f5a304efcb93db7355306e833dcc0b4016f4bd55404ac772e6de180d1addee3a515b8a6b9049accae119f5428c805de89db08e43d35abd02d3a68bd633778d24f74e87b361ba4459ce7fc098b93fb41b9ea7798a9bed23da3ddf57547cf5343822100eb0d37db0bf784e7ce292c1dc781149d31e2783555013616a7f56c961431a8099c709c22e21d1f38ef432b4bfeff68bb73998ad32ea6d6688809b8581e219643582d6297ccfe5d300d037d9f9d8034e9d7e51e07b737bfc9d148d788ca1ea9b7b97aef7379cd2e099c2556a9fd2fe03f4d73e3fb7a2f4237af5d87fe01be2b827565daab55a3d9e8e2e96c939ce88cb9eed8ab2aae2f119d56b0da19899b1d5228dfd9ea7dbbff2ea30b0df09b56f4eecc11feb33d22a4522607b54ccdaa25854c358c3b5701737215f8ef83e35433fd476883a53b5b41b221a02d65551cda004f4d3091b4c8be7dc456462f4d677938eb6795121f8b98259fc376dc7a3574db98ee548b0f769b6326ec54a91d3a69981539e92c1edafd6e3d7fff75bec62588d1edf5ff305e1f5c14e1c3033573f06ed8fd3a2dcdf758a762cab7ea709c7f811285b445535b1c215dce64e4121c32ef14f8ce749f81a4e9a0abf5c6048c3af460936080d301582cbcf22883ddb10f68bb07c0d93444e7a74639dda8847d48d5fa0964a938001ef389c2325a2ae54d7a818fc18cc6a02cec071d9bfd843838d37afa2fc8c62d6f9db6093294a383f1d70c356a412303eeaa6cd98d57ea1babf0694a6c526c039446e6104f44c670ba1a24758e5a2416e61e2e91818b46956d5d3054552eb513e7d594925551aac00efcec0217f4580baded5ee1515fe1097ad950b6a24d9d7b64e1d206ce6d459d11d4d80cc6f6a7b6c943ad4c60fd0ccfbe6caff0eb0d2774e3d26b0dd9e8b37e3804b43f75789914aa1f5b852f72085b12ff396b251637095091e5bb8b3a08fad15fe551dce55680e5dca8a4c3d1a3c4979f577090e5d1e2e97fe1e07c97f4125faac75f13553be233d6e37f23e71f42ffd529bb1b58cf2a2923d7b3bfb687161257fb101a91a160e51eb8352ea2ff2f06a173bde518082841cdcb8180f2acb17c1ecbe154bfa47bb59fd6b68c2e210d6b847b0c1a398ff5d97791b200bd2431e92e21c3325a66e3e2076cee561bbe5663f3182e4e56b9f82727e734fb36c3766068e8bb40661da431297ed519e355340b6ef6e55d76a7a131ed187e964ba3a74140d89f80f921a84956a85e5344f9dc504cb1f6357f05ab40504f7e45e1193920eb98988828f38acb3c8d17a55d213ce073f1fcc0024a2d998cb3d923c872db7eb71b59bd7a66619fdd53d797c56e18556a36c6448c4126547b6563f4db25a15f5fa2774acf5c3fb2931d7ae711aa744862a73edfe3e174aae636f27054c0b65348c6b77fab1a53306b27fba5ecd8714cf284925f80b943acd4aa6c467af19c93627f0a4bc78697ecdd90623918aa0a50b2e0e75ecab997263b1c0bf8fb8aec4aadd5c9dd9343d2c7fdf61ffbbac62f4b466a9fd86accbd778791ec6c2ab74a6d05daa37d5c5c96e409f72df382d28fe1dea42fbd76cf76153b10a8d372394de6e02918126cb1f60c5f63ad741bfa7ee75b4ac78a4be0494eac96aa931794b327c62216e6fd1eccbbedbb7b913c7c3f7d8bceda9895c2c4f5f5550d9b7b0a19867b53e2981168e3ef6b2b913bf150133eacd6d58d923b796da1d2e27a55235062ae5abcdf9674e9de72b595a3ed34712a80054c95d80eb3b59c29a31e423f95fb7778ac368abe79fe9d8010a8a2fda8c83908d8dfcb9acabaeac7a1eca32ef6e5e5cbf34cd26fb22297ac55879321193f5859f811fe7e7dcae305b3e6739de9f0c19f8925ad56606634cc04867c37a9592e7ae0fe96f129da5b3bf1307bc65cfc679f1ad0b1989d3d0e66d8213c16357883829f0068c95bba1b7fb92235c620df049b088747cc1fc647ddf6213d7613546e404e9d2c180182df4f5ba8e855fb6672c9551ca76369b688c13edd8413d2112eeb5100c108d6a5324da654927e5db9386ac57290036913e1c8c5fea3114ae81d0651450fa7156c66d605c729b7bf1c03c1c6c918f612f46f183bda9ec1f587c59ba0875364fa3da6b3daf6109feb67dec08466a46b47702f2e6604b5a49adbca261285e33a3c7321890778004e6b28131e72321bf86053020b7040e299a78769d36404ebe8f14ad8b31435907dabf4138010663a3b4f60ea30cbc544f1177526df1c2c18d08d66fc6cfa9e567767dd53188cb7e5fb600aa9775a145852c8021da1683851068eaec73bbb23ca9e64144d2c971b8ea26ef663199f25d092d84f39bfd8eaf943ab7e92da826f310dd573b61aa2473c07650eb5d021751293be37b1dfc6507fb689cf02fa3fe3b749ae66557968deb7e3e082cd2141a8f8c93c2cbbbe6719029113898553a45e69ed2ad8cc313a962cfeca71be8dccca3a8f35ab973d88715e4e6ca6cc556733720f148d8d6192da33d6b4f5baf68fd3c9421d310dcdfa43d5c28887a9302cfa5b00290ccfe4557c63edacfcd78553bd271283f78e7ec775eb8628f52cc11c1cbe63e6798cca303c80b32873241a62ccbc15c3b4df0670e4e8b109a173fe2c6bee023bed892471c4c67cb8f72d886261b229cace025261eaafeb21fdfb3a348e906effcdd78bff8c77a53fdd1d39fa040711f49cb184428471c4cc51b67e94e61a091f6cdaa233cb16e6b761bbc4e8e9983d88a321009a354bc840d33c33d9648844f069196c450569c3f79d8cd6cad9c074a735f08237f2318d96147fb5e12f8a2377d45db3ee53779be5b6a16845680bca2a7ad63066baca766041ddbf228f8b8a2fd4b3ca50dd69d91b9213ec5f4320a4b6258c6d0f5ab7d59ccf152e61bd7d59eddecda57ba4f4b46d3460b97a969e6c17d0d3c6f124e5909641407aef640cb1183308dab3d752572321cf5da242939409ae844c7ef03073f929ee04efcee3aebc46a2348a0a41a6f67eb7bf402588067874cb7e8dd458223a67b5d1d8a8d6f8200bc51154c0af843980578a4e00b4d2da24ad9506afe8d3e884c82081d82f9e298640b7fd55fcd07269ca73606191e97193e7f99749b26153dd98858711e8f3c96cabf65ba9b2c9f4979cbc992f30c9a0584e7d437acf167eeb8751d4042266da687486e8f7ac026026e6816e62191ca5323d597f583b924085fc0e3ee0d35f31dcaed3b9a0b1be9763dee34a60e5e56d413424a9091b9de3ba1b9996d608782b58497fc9ae5639354daf58c4946a4ef070ce3cd7b6c7b954f4cfa1ccefb6cf0381f92b29d5fef6c1f254e6566850c85f062d06caf0d3576067d60c115067dd40f3410d623a3ebbda7ac7ace462fc382f48dc96efad449e12d90253a59323c879a8704f5d23c87d92d302f09c4768c8a5dd41cc6aef144154ca13319768b0d56e5c9027490bf539fb2731cda0d3b4a9263c7eb6bf466c595a73577f2c53f72f0598e2dcd0a01c810be7b91c928f43ecf0eaf9135387138af495b40c58832c0819c90fbe5029852fe4739114786ad5e01ea153ba13f140f612a87c71fea66150e12af2dc754a3c6413adaeccf4f3a5d37f1e69a419221926fffe792e6afcfa712ed99316eb347750afd200a8ff61894c5fdc406b0cb062238e05373b1a52b4b320025a65e978c93a76d658146de91e85f7aa5fd21a2217ec8d294a405f28a1eea92d01cb9e54e87b2f38c7d341818ad080a05e58b8d49d808be4994191387910fb71325c9efec99c12d6d6bb8823a911d561b82f538b21fdf07fa90f2cc5301b1a58baeb19ab5761540b9a746f0d8572b3c1e0510232bf8628097093bb6b5f8e1df4a4dd5fe2526159e1ec5556fb1d72673d13336b842cdc0c271ff539fb42224e0bc798c02ca6cc45c79a94ce53d76eecc4580145819913528e9ca108cd81640480cbdb7f1954495b4df3462c81e62669fbe1b6c82dfcb1934219b74acf24df3437a3fc29e3a62f12b86a1c500f12133103d8e572fd259ade6ebcefcc3cf24e42e2a86f703d19588b0f0047de4eaa27da2abbb2c4a2b335b4b5acc6f79442a289722c9f6bc8cc2dbef352056e3a990bb3c0e830c2998800c520a71b2bf16b0f914580c1186a5c199cbee8462334687593863d705f35ff5d945483ff216a2b9531644b79cd544c591cb4f4ee93c35514a8ac1bfcb4b0d984cdfff293627bcb2cb33b7b7a0c074c1f8f8f0fea4899c10c269978c21aba58320bf13a910d8c563c8159c4bea2fb7686302bba62169246b82472fb1bc376e934b0f83a57b9733105f6af3eaf3350a200ee3bc01dcfa351c4642ac8e05ea7c1e282a041a43f488c7e90f9b558e6c3af2b76856cc0b35622a83866d002e5720aec7a652dd78b852a01820f17050ba193a49bccc13536b24e091b2d2c1870fd55f4fec505d2d3514a17fe0e5ba9af61323ec86daae695aad981b66fd9057644860aff2b944b7044a2ba6d4299fea0b867459b03d0a34859185706d3cd68c941c5eadd6d22469c2c245471fb140f07292432b3bc3ff54b84c327625787f09306a5e1a0da7d1b411b297ccf45fee0ce8453abd189c396b5062a8501da8ce3adf8dbbe054c83f94bd21855add8d2dc0d912214b1f0ea61a05029076cda311bbebaf1676deef56794a704f7738bfc011e425ebf08f79a580ce430e9adf65d1a9fe423b0c189748155e6dd51e55684e10dc4ea8aaa621685b51ebbdb050eedee07d4a4b85688635337e8195e83555948ab416714e25ed9bd45768a2e1db5bdd9986d09116322bfeb089b6b1894a0d7da392e81533e43edb93085c310fd85f00cce235d2bc634906897f8c20a31ca8e9cb4b5b1b6875ea099286da9d5fff9de4a44b38173390bece60d47057f329e82472a091aa5a86a427373011a5ea1d88cdd1eed15bbd724a2c1ce3465f169082ba3ae71680bb7f79751a472556cecf022b1d0ed2eb60458c25883c09d7b607bf032b4bc5bff802d04fb5a4a421d18ca59d52754c84b4050e89811b0502c71e09ff1d13c9ee864b7d59a24c3555048dc18b88701baeca596cbfbef789a37fdb091849cca6b1e8ff5ab73d05e0b24dc93a54abcae0b4c11c4736b96df7d22863b48d22aeffc7ad603db6b5dc6aaf129ddb695e23f862bc2296fb2e09ecf422bd694582df8fa0837dee7495ae82b0fc1b125771e882ebad54e8e8fac1c46bc5afdfbd869ca9bc7a00487479b3decc0e47f97bfaafe4ea54cf57e5aeace495aa1ce5282c072de15f68b9fce5f9f47620f32eecd25a96cd20333a8a8afa57a7dc1df5c5a8ce9f14c60498861d2378d535c21927fe30aca75caa062df666aedd086b0d52d01a7fcbf2b27686a5e849ce4de92b5d05bdf281d03d6f8f0403083200bd5fee19a0a618bbb1fca51f9611906bd25c53413fd7e31496fc9814a2808d10176d5a7f9934f3f9d06ce0c193f94efcd11c5fd926ced3bfaa1988da2c625db7fbe7268edb70966dd25aa7a12ab54e7844bbb3cedb0fddf23da78c68955093ced5a144463921f81fce9e9ad2028bc3ea58facd4f99e0497fa4f61d571127ef495261584cc3cc9a6ab94482c69e0d4a6d34030efd5eed6bcc6c8663517c3d88959ad48e524fe9569f8b33a729fcb2bac41352e77c04a830374d46512df49a3c4b71d70726c61e076d395309f26a5a58955f092558ee1001c1010ef00caf8e505b5b309ccd1a96a880e66f2a1eee5ed025aeadc2fc543216f3f95c6a51308d11d76523dad040cc82825157ffd8db3d11590692ce0ec721d1f1ac26178b2d4ea54cf6d6c65827b76ceb2da0523a0a0eaaa7d9870181a2caaa5d6e71e20addcfaa17102c3a241ec43e64c863892c830e3bbeadda9c74286e0bcb8d405373f64e2c5ade87f8d0c2ab646b4d9a4c56f9cce2090120bb0318b1aca58a88cd0468d60d2e48fc0e691251c83281035e553681bbe40d60b393f5a977693e90911bfeb93b5e7a83713dc75936bebde735893e7281e6cf65ad9b4377a8fa530207006da418abc4d216b083516f59e3b7cd47b3b55244627fd6e52b15fc952f44bcb90dec7e6aefbc5c4c138fde4ef85367cf369d94fa52b8e6e7104ca7436ca43d61c31fa38b7519f653e8969967a9de1f1af0686f6bb3c05659058b1ff714927ed2d8580e1c8f3606bd76b55ef68cc82d914de52bda079d88b12af3ebf457933390d3093e435e7a1c653b4e35912271e629700968ac74a10e05f2a793210fbacd5a72ebaf64f5f09f36276d94bbc151034f23d039ee82a40ee26931f43c3203f0487a77143a9d10ba0affdbc27a64bc5ba680bec86d618cb088564db525c18170a1651699c6001f269110aac1133e79efae6bf75f94be2c27d13a12e761c59baacbed87345dbbe4578dadc53a349d47a00758c398011699f8f8fa26bdd3014c9bbda69cebd646653c68ec7fad11e64e7453ccde33fad8f6ba9e198a48538e6ee2ad705c0c455b317eeb3c16c7c71aa26bed6970cd9d12632be9b02f2530081bd6c09fdabd427a5adbd411c09604db2249950fa15e7257aa2d23fda23a0cbaf9ab4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
