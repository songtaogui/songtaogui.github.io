<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66c331dfae114666b5380905ba3a14a4b7558ccb7a5a9b4686880aa1dad4cdafcd0717641ff84edcf7d599db1a01d4e44a2e6b69a74538baca2ccc0d59032c84da550d082eb921a3ff3cb2e6efd099504bcd0ad117c9360f944624cd422a578f04984e0f126099ac9aa0d33c70080a0da971c097984543806e50c07392a31525510806f160945289a37fa470b4de3c77dfa19f2b7ee495f10c5e38405d30d227e9189056e8292cc062fce071ac68cc79b88af7bb614461e84efa66b6f7793df9ce3e4834a6a1696f6706c54e1fe6c4bc197bb673bd523e85caf832de5f1c3997dc96d11fffc11a57e7ada355cb4aae005fe6772861e0f6a5e6f94a668dce28cc3465eee6857e8e39f4433a96f0fc4b796de56494288371103afceda2307edccfe9d5a0d5bddf36d62459b2613d12d001689e8d1326c437126313d6db75150fcacaa4d5a630bbfe88b6ea305994a854423767f8f9b30cab16be6a3604c9bb2189e688dd0f2f317586c4d46f6c24448c0a3a92427d51f2e9993e09e77f18d1fb234ed37edced12f78e4846f2efcdb51a4bab437fbc623e3a03e7ff3583c013a71c32842fbea6725621a54ec5d8d8207b39347fbb6dddeb39503b1701d05dba57cb6e9d876db443dbfb1743c0a5fd58c19bd49ad24011612274787bce8bfb8010b16c71bd38f9bc6dedd6a4955241eed8e2cfb033c93d4d35e9c8ac927a7781e4ad22816171db28d318ba1230e236e5667737d1dd6c65254e14c9cfb87a7652d592d0dc2bd051f61b78a0317fe11e0cb9961e630faa25507fd5cf8fa3c07ac883e426bb7d4b50b63a007f3a3cb08e290cdd8e6ef012f917c7d23c51c51cf9ac48770716d4fb296627444083dffb73c5932336565afae70e40370651602f73adfbff8629bed142910f69582e2152f0cb8644e5b1922565554d81c3d6825f4e010f30197dd13a1d0d20d8681ddd17ff3e812c4806fa41d00e2c27f584c899ad21e024ed9d82a32726e8695c90bc2dea595c28ea4eeaf098d4f038edd7b5b071b4db0c08db469b955ec58c85b7a68a274ae93f242072dc13f09dfe9e3dfdb1c57d704c6dde95650fea071668f5149c6f3c7a5b57d98c13a27c634a8d0c5b694d85e48b51bad5043ef7f56e1562cf72dbd9651d162908b04500354181c08e86ee417b580f716bfb2cc98263053a6212c49a9ae466e80dc71f3f4c626fa14e641205f7b333ebeebf65cbcb6376c2f89f377e693ef3b14717484b7a1849c455b54bba0e1a83cc3eddcb7723abe85ad70abea47672df8b70e397520ae11e27a7973676d9508ffccf91c389c33668fc24865707b83dde17eda5b32282f04c9641193aa312dc61e3bfbf15a34c7170c8299c0b3869057841f0c0987250f561d4d965e300a1c65ad2e2658d731533f3793d6893118fbaf7c78637de8cd9a5d6a079a8f8fb14545a6885ea82d1424c27bdadeabac90dc3ef136dc39e4c7b7b1580274f44bf3b1552c0a2a194e765f7248b1a5e93ed00cdd84bbc64841733d426b5a08b9940a75aa7e887d2e77a672c100cb31028630ff86708437a62949d99659f236f819ae708dfe3337fe6877fad6c1f36a5034cc34e2a6a615545a9ede5bd380644c382dacd89600ad9d3cd72a2edaa3006565771fb4a09fa53edb6c01e14987c83fa654cf1381d51c46f2d234aa2c8362a9a482c35ba80688464aca9dbe80ee490d02b7092336e6c142762901d595ed2066977d3f64f108b94ece78e7891bf59a0125f11fa47feb7d492fba289f6125ec6eda464d53da73e76dc137143fece34f169e4294d73551142edcbfd378a545573cf4ce3d8e0b80db378bbc8f96f1881af486270de42b6aef5c9d767c28106f1c3204af0e6f1d37650aefbe55423c6772bfa6a4fc5d6e1dd01cb418ef28c5e35fc6f04e2524a5c1e2bf9b6b60e924078b2f93966667eb49ed64be0211e624c25616273dee7620d3abad08b1bbe0c3858c44ac1f1cdbba5fd2e70170204c22dc7f8ac1281615f0ea90428c45e6e6cb2e4f2a86e3387253bb262a6c70d9a581e5c43d74b4ef33a033f1775cdb39beae8f14eeaaeb5be4781112abbc5134d488f3eafee57f205774cb7f5807568d1dd711a2746deef0c126e7cd19d9abc17f81cf779b2b1200b161a077e7db018f06034968654655c52cbb05d81918210af451f62ed2162db83ae7738b55081fed2a5bba2542f3d04d5c966848554072129d64511e96150c4f7da2d5c1029a451d41bdd9d2c2f870b610e17dccebbaa082bbc97606d090203f7ce0edb7f23b365b7ac116a65aabcddb6c67010945ece383f3bc196b21f831539e9137a6896d20712cb14e2a173002edfd404ee29a28e66d7e72460ea19b5b467a540429578debd1b2bccb1785f60246ef0aca6892d921cab2504f31b194cba657147da6172781b1076071ec2b9769ccb8c7d64c37a2e41e8826ba680883e71c029dd9d3361cf6f3517ca6c9686f62aefbd23bd4cf72bd5315deefba22a9c03ac59beacbf3526a4cab2009a95204923f53d621889daf0c70eec2bcc12f0ebbe14b7b23aa5504c4149fbcdfefb1c85a6868ba0d2974685e4a10d9c93cb53b015e56ad0d50c10862269ff35505e0d3036933af843c8d826936cb9f35b6cd7959f2c29bf067fb49bf0e5760455a5d4b5f4478c1e0247a3d0f536451893012761f1fdd0a92e151750970cd17c1314ddc29d2ae80ba875da97bd26ce799cf95f801b68dd58c9df749e453bb841e528602ef9a8e843128b9e1b36241fe1e0770797c9269d0fd1c6160278a95bb31225d16bb6b1e4ae21ecc1ed84ca52bfabdfd0c351d5089c9d353d815ed462a949fe5c3cd46dba58f65290efe76d8d9f0684e6793a1e134191e307bc60396ada0ca4ecc61bf7aaa5021fddb5f7140502b81f56e82cfd5adfc39a955ea32bd859eff32148447a317318ed4486ac202706cce1dc0b1bb8ad069c4ae9fd2cad7d4a19472a12bee859ddf391ab964e42810be9756026989e409060cfcf10d42214ce288da472f03eb23f4ecc8d4ef27ed7a5aaa9d741120276dd1d2c87c114842197f558c837839b534bd96bfea5a9205835073a7a45e5463691106344035f33de5ef3b3ae08f229dd06671dcf6987f2584b4a59f4f86a76f5c41110fb5eba6b8b9a9d5584c1232d4d10abf21192344b388f82c1b31e893f2d8d4170ecc82ba670022695c0c7409bfc81270ed5943ae4e6fd3a803ca8d183acaad2be1621b9c6a627f167bdbe2fc2b2b02095dd05629654afbe631f25a3fe97ade3a691df512e3b5e7eaa85fe1f9b818c70278b79ad89d0275c38a00c28b1657654aed5248f24db55b4bb21c5c9eb92e7ffe12ee57193830630bdc6ec7da19ed59d7bcfa8d095166f712510f28954390bde5f72d5765c17e1c1ee2f2e095d3fb6709565afe74576a78b91436d48733567f2825aa22d984189f6365326bd4edc6415dffa3f4fab7d85f533d433308a29372a7759d95c8a2e52aff6e344ecca79ee01b60fcffbc56784c30d6c49b5d8d9d022e91a19eefe3d735697e325268ab916a50347ba6f6c0287485ba49415e66e06df6b8bd09ad586d0f306341a0ce741c08ed30330a2c0644d777758eb19d5caa7a9c3945563bca403eebcdd01568e42d51228136517eef9c3104676a53a429496c7f7001aa3d2292bf7fc08b311f356f3c024894e3e103d233df498d90544eb7a38e599361af17b8abca596db0b4a24a2718e182f5e0467812225f09afe6d27fad425eb19a10c567150e1dcac19628e253f8b2fbc13d62dd88e9e25abadce11f6351c4d53a8598a8e26a637279f4713c6c0f0f3a83bbde40472c4fe7883ac65ce0728f8ba9faace25dd397bc0abee6af722fe5f0c6e5dc3f08b200399e06458d1efb28dd107cc1b18774620e4246cd37e5a22026b58418311b82c4aba2a61d8f8cdaa71aa78714283c092406c90469ff03aae7298098326a8fac647e564e131867388e94cadb64a1d1873ac61c5c21b4b48a332b08386d63e2a70c62f1e50f7b2d0dd3d83e33f393bfa48d0ac33779bcbcb80cf9f0fbbe1c55ba9c550c18541304987a8689edac3d062afd0d71e8d8385f063324f69be471ae616894bc2cb966d20f3d9b6e2e71cdfa1c57bedd4beb55637b061ac5ea1fd5eca910280fe8fcd0589e5cca7c55a63f7cb520e8aa8a39ab64df5e5350bf5c56d4c1bfa65edcc9693ebb230980a36041448cb8ef271cccf94eb57d303c08d98ce103d5ec60997eb78267f0ea4cedbc860a7635d718c32b20f83afa9f0f22514fcbc3ebc085bc9f16dff5f7eb8684f0315ed7959dd0d88a8e2591e96ab6b2f155dea2fee60b81dda1e989b70cbc85e2f12f8da5b487ed6c02f395598f80d151713c707e62f6b2efc672d18b70cc1c67c9b3709ea03be395502bc992f1d5ba3a8292311e2f8e111d2edc247a9bf9f4f33f1996d02bf483e2c059f8c753460cd039bb83b06948f50367acfa0a4079e4c801419c7e9e9c407268e8886ddb2d573869298f232f78c01ae1e2c40103633149bc3af2a45dfeb1c8d86ca8b12ceacd958a0700c68e8645ccc85413a36158a5632795b4c95f7517c88a5c9a8a39cc112b8fd75b8ea128d4d3cfbb69c9983a506ba6b9e8563fb4065e9e78dbd2c7038ca2e33607972bff08552e5c7abdf2cca88cc9187d9cd1b46d0a291ad671c8116e63ef5ed518d7fcfeb195abd802b7562d30e4ab9f79a0bc98ec02a3a1a682552df648b1e1b19a44d248f8bfa5ba36690301509dd7b2fe5bb352c908294de5d53619a2c26d805547da36d01d55e5080346eb3c9e2f614aace80aa316ba8b470a13d40edfffd4428ad803b7b494a2dccfdf0197159c76428dc67d04328a490717df0956aa395bbcec3980b8e4e90538c60dc77d5561f78c7996fdf5d6281e87ab5d5c71d7f12b5c2b0dec31e52ef131b20bd5ce43720d4a2f8be9444cf267224c49e7327033c8e1a35d07ca95cdd81aac22f59deee7f2676acd76df2e0d2e734c21265962f5ec99d6debe148f631dbd79c12927e352de8457cf3c6225eb49de0769ab0d8ece730bb83acd1b7148a6c9e81057ce52a91668da67b8cafc54e74399e1151f4ff3ccff5fd68215578f60e8cbcea6cfa7d77a9bd87dbd2edb112f26dfcbf63799f7ab9316e9257dd61e82a48af31cc091f2ae8642e5502f1069fecf2df211188c008613239e760d20a9388179da22ee21fe07100c3b25a0dc9f666d1219396ddeed7a0dc6f4435d9cc15f9b8f6e2b35245cd8bdd4e0aecb8ae00c3b04450d52c82bbac51edd274bb94513651a1ae44a7e7003eea8315773e10e88b3434dcd3fa9d032c2311c29e05f1d919c68a304db7216f7cdfd0b997aa956dc9608f70345dd515a30390c62c6f80d66580ed8abb7b2553618ac8bd53976d1a97fc7564e909c9e406a09bcd1e66db8dff72b46d4331a2d272c5e3f53ac317e8790df02a844a6d3b07100b6223e8c288f5c086b4657f811b8be73277bb967f3b4aa072bbf7666a4d5f4979ba79b2ac1c57a828a64152eec1b9d7bae6043cc54ca10b635b8e3372ff9fe6ff12d4b0de993cca1d4ce0543c0254bdf5cb5f5690a969c5e12f9cdf4175465bb67b307f0075f91f9e266a71c4e1a0ff5141ac8a3f0f45c8f5f099532ff21617e81204ec00c33db3f8da8ea4aacab5e941f7e11c7cb9147a94d000f9a5fb49385b158b2ec43beaa6fcdff942f1746bb74a7b4fa3858749d6c00d57e70f8d22e3c2f81a553d21343bb598ebda539599f53b494dd8ff885bc879636d85af162345970ba4d4767e7c2b936102b826911b2791a450abc2b1e8cddbbdb477d4610127f6d776de1e05907d5fbff2004b54c5ee4e8ece7e848d771cc93112c310abda0215a84032c70417f77ab27e1a2ccf18ef01b973c766bd4af640445c63651e55a91a7990bc1fa2e54ccb9307e8884038018886fc30bf0f1b79b54bf265a30376eb2e5171a90d2c700ceb7222f327292e13fe282354ad2fb121b93c028747d5c6b26921d93c19122ecd4e5d4f75a3b912ac9d5a5755104ab6842e89ba5262f477a748fc417bb7dcbcea0cdd8466e1d1bf192b63a25c9ba85497967ff6b2eda07c2cce73a90261b63a4650fddd366d485bb55ac584be5595fdf200c87baee2060b7c53ae58d2f211d5a0fab31fcc53e4dc6080bbc7e299b7b8088be5150ec4a431492e62e7217735ec8e1132d6009e1ab12d9054d658c4595bd1b7337f9a9392726b3278dcb88ba681c6ecd0754b64814089bc690831f8619a600bde0bed5e68ddca764285e02a85d30f452ebbf134b885ad56e9d4c7546b46c035d73639a0c241d871b4d77e1d7cf8dfbb7f5c8250fd5d84953c9184c43dbafc0e9fe54f4f481a59ceb3ec527c6ef620220f7c36c0fb9520d5d7a39f101ff1bda0bf706216026d243a33f952cb79446f451bee2a0290f2d8d25638ca360a58a6f5afc819ae98dd2aee54b59c256edb1e32c491edf1cbc1ffbdea9f0433326eaac9261454662ac13360b2537ce2a9cdf47af16339d057df50ec91744f0f8c75e21c3aef99f32655182205de15406e720da00a5b47c67c9d111ddeccef9b43d7c4cc32cebf8c4a2718bcb8743fda9af0626076e0aac1ac37ad65e3080fd0c9bbbfb7d0c04b81845084f4fe407b680b902be98f7cbbc59187f61be294ce036e3042a9081620b9bf615bed62c6ff5fd20063d381da504aa7f00822ce781fc406589243cbf636df8eadcb7a16c9de5daa7b5bfcc83a596ac3db25f1289c2f833c4c39b61628bf88247b8a416d53c46e0fa2d5cd10f94cc03cb4e1be9cdf9c53a7bebc74744f18f55aa8c869cbbd15f551a9e5ea495261bca4b0218ac8968b19ea58b878eccd0071da20549d38304c46fe1a9ac7edadead1273fcda1cd36d461fc7c9ca112046ea483e5d50731f520a826d3a04eafa9339b46e9fb24b91a4fcc72e35f9af442b86f991eb8a2246c719d9a74ddc860f7c38e8006034b50d50160c4fcb24f7469c6670e86845c835b19fb85e055a0fb59ccecdf369baa1ce116807e8b52c8bd0e781d5514821d273749480390e9060b80f76679154b82dbbe9796b503af97ed3bf5a49a76b34e79cfba5171ff82e4a45dffb501d2ad4ab10c3e82af52a9ad5a9739527039d13f2b3f668d7af11ec3de5a50041c06700086f47281fa16de883b918b62a74b16695bbd16d389c2fd24486fb694a14d203f8f37b757dee540c6eb83b7bd3f82bfcfc2e36a685b0124452fe3bd5279ec3983bee6711a00feaca914d5b3da4dc2bd33f339a058927deb294edd9989f983022cec70cbcee6ac1b16064a0b87314faecf1c3173db9ac7a56ea2b3ae48f981a82319ccf03e414d5e17e48f7510fc0fc73f0fc37723b7d16b977fd2d12bd8c96b3f0e7417cfb3cc48207e121c0c804b7a45aa832fdab2504fe60f8b273e0a69d42e46f50d828c6ce3d06a69747816a5de6c1188c213338df7a20a6acc123fa37168e8355539b792673acb08f8fa7d676655c17edb4ea5ec7d02d61a40efa6f74c8233db1ebbf3a3eaec93a4dd85003d331972876addccc31f5ec32ee53380eabcb4250a34488c4b190f590e8090477b5315ee07113082e085a32e23d0be9ab4d4a348dec37a54972d454a2647e50d91c8bee20b63d9f6226895f87a5abde9121599e256ec2799be00f364b891748e556feb17b4786a5ef428a627456cd25df9f4d88306175f0079acc88e56fcae3c81c0dce369b4d0dd8760b7ba0765c9e3e2702182f81c1218cd134ed0289610f03444c6b5200473e07534cd30c086c1d1e8df369835475f56fa99970fbc2a32a14315ad912449c7ea3a19591dc175f5d915ce1614116572f017ed5130f6499983c99d036200f4b2a1dbbe445797015a94a47f262512dc1f00dce805c74c8c31da7240b62f12d61584d2412985f90d3a4e50f86aad3c9860aa1b31c36edabcd1ab31e617063ba61551a9e1455f6fffe898b634b946f56eea2006f0687f89dd3e843f50a02a841b0369c8563d587ca905fb4d49854f05067c18779b28bd63d16023ba27e7a2ffe4d02a9148714fd4518eb6ea9a24b1acad659f7b08b02d00f9b2a71616daac1756c5415011d72c8aea9242d577954058fe39a674cb10f2ad7939b868d5df626f4a3ed08ff1672dc4c8e6613317189583e8cc7482efb109e0bbac1fd72e4508f86526c2464f2cffe2e0b16cdd39fbc08d4e1128f3fe789e55eb82e2fb83c53d0e1ad0590066fe8825866cecca9a0a59ebcbb0287f4c79e393872494eee1715bd30af3a73bf6d1c427305d75ae87f64df362c0e1ccd6d997382148c41ab26a12a8d14f0dc172b24803b9ff01b96af91718e3d1e4d4c0a36c00438f23b88d4ec712026084df43dba1d024e6ecae5dc28c4c9c41285ea7901432107c63d0ef7aef7624daf5739983f47db70dd700e7ac6d8d2722c71508539108223a0a274973da150f5d2af0557a7f7656eb347fe2910b8c62911fea5862c0fcad6644d57e123ec4f4d42e1897695d8e5013560dc9ede52952fd8d5e92d258d3b93a27735ce264c1d57c9ed9be1156c0e535bc54ac35142abfcc287e5a8958ae4609b9a251919d606f75cb6c53b7b74886bf3ce61a5ca113174506a47f3878d45bd8777822d4522b73d8b645ca0b6c275a26b32f1240e9831efc8949244cccf6d250ef9a5bcd39b9930b557c4c54203303847301e488a52ad877f07b4b5d56e651e1c1ccc5b497d24602c3cfe01663cd9d052dac3f40b5159d3f94ccc8ba9e922db0969d4a11b276d879c8350d4b78450558a040697c0bf0c30c0bac332291d7a00c15f43415adf10b88b5456fb4edc5747c675973055526425aa9803d7d542ebe665d068ec91918613e0f4930bbe70d5a45c94a4fcdcf14774d720c165dc619775913697bf092426f75437f62f7b05147bfe09e19df7342dd533ce3923b7c7b081157b2e516332d0596648ce7ee44d94014a15ad9c5d8126eab0986138128b4ce06801a5d4fb8ab55873c14d802f457aac383e116f37d3647dc72a80c7b20f0cc2fa558407759d7b45a436efa855f30cda729d99f04413a66df460bb4aaebdafaa219cd5330a4030349cf08bda53a24b139654d7aed69a23902e399c9695b2aedf668d02e924c4f3a85ec6e7febdd7678a24cc93fe4986f2f70b30fea455263b0b702d21aae95c4eae43a4564cc40a34b7daa3860491859d64e683e37edbea7a497dd32a5b5da432e8f7f82c3f81281b357bbb0cef72a73240e0fbd6a9d6969773923f8a187410948a02a0b43636dff065b5a1da8f2adf6ed6b675f51a94abfce2530b94a3965a4de87ff9aaadf892cac3a702ccd05b3010cd98ce6f0a8f2e912603857022b46d604fb1a1cd20d5f24efbcfb13fe0fbee2fa6729b7f18c697356f161faaf956d4edd6065b0be4fc1eb841177d80010f99276d895dad095b12f7ad8f67655b77dd5b4531a97c3030ab157a96679692089e4d0ddd0cc384c5c509398ca4107947ef137e897cd0e4ae98a14cb80a1e8543eb96fd27ab571ec8d6e4f23749cb6684899122bcd25422b31ca2cbbdf8114411c21365996a74ef0497a0c63478b563abd0dcee79855b499e46f72fe185c2bd941007f48663a783a261f0d7b0bec6ae3dd5df31b94f243ae8d7ce8fb3e6eed63e1d03bdf98aaf3ceedcac324c5fbe0c70b073732f869ad885b1900b491a337b7368004e64493c95845c822ca84dccfda8e036f1998c66858b6ed5675374e9ffb637c8b816449fccb48009930f66bf1b77729c6c4c4a6008b9528b0df32fa7b9d2c3a03da835cfd9768813e5b4b3d03e77d4319aea8f43e7dd92a41cbd13dc006ab80297bfe8b1bff376ccdf512af123c5f9325bf6ef6773a5f864d6ade41d267af1fc52a6fd61e6616a23bc9ad18284df22786e8d82854e317c94f1619af6c823b4d4c819caa89a497898010e55fac913a70cbef0a6f267a5b43879eccfb0677e36bd7129f931468af8dd05508d2f4c2e1437810a5804f1779c63ae238d0a2357cd05dedb988bbc1d7fffdbfbb70bc8a6f8357b0c1c96f0b17fe3431a97c94fdc85834868ed14d1a997b99643c810388f6c7dfaae61d72f94728dfafd1c5590386b18710753ffef44e298179ac9e99a33d58340322933cb0a4313029d32a3aa4285b8c1c28e5a1c587e00a5c927f286a86d9066e8d457823a6ee8b5e953a2f223f2ea86b31c66d9eebd8adafa285d2119241116a9a7fb209085750ea1025eb84a441fa3992544b4c9c4ef93d2ef0229e90a775e5fd6b1f06fcbceec8ca14551ca5ec28dc69fc110b8c913334c9328e98858228165efa9874a091dd0e746c3075d1a1625a855a97218154c4b0555cda6ce0719ea21da7b5722cae8d9b5d0ea404779c82784b1e5e752101337bdd651cda73ce21e82278f4247ef0b59ac4bf450ee2e6f073454d60234494c1b3b1ee4da200da1725dfa35bfa3d571aea93f21aaf484dfa80e6d73eaea4a6e8c45ca4c7f50fc96116deae4600466191b5036aa8ea57317f1312de03450a5c6d3d663b4dfd9a70a42e2afd893a4048b0aaf779f935b48155554854fa6f4662069eab57df39f02fa77c7b2917d4149caba98a58d348533669116034463fbde78ee8f9ba0f83a7d149db3e10fc0dc7ce5ed07b725dfcf1586e7130c9b7f4c47d502dcf5e5beb6861ddfde9c467ccd8336b1749835c532b5e43f720187e72012bfe285d46267d154a74b0c53ba88b5cc0fd46adb1deeb06ea97f24330dfdc672da19e861cbd805defd8546de3d7cf2c30141a65d1b3c34ddd111e56446cc7f025a6648e0997106d4fb978b89df4ce02bd81ebfd02d5a3efe9c7e55e4b44f30c47ae131a17d4ff2c6f90ad8749acac3e899aad2e9d758445edc1a536305a1d61c4f3aa7356b24ffc834a4bdfc5f27003e905097abe6d7bbb4c4c9460b287691f0f97ab3ea0182c65859fd6cbb9bdef7b1fd87fbf00010afe10e9217791baba5e2802bd6fbf37ae00e86a3978e4cb878233538e68412a8738fc8f12c57f4306c3234e7bdfafc83f3073232c4f4c11d77fbd7a0e766a334a858f4021f87f70eaac6d7ccf728885abb3ff90759f787e24b95056614d1e891ddb72d0699639eb2f4d291fe2828a74d6f99d3aa3f57dd6d1312124f02f330f7b4d8c0404bd4156c1f1ad40fd6081b43199a0f5ace38c92d3b41c6ad481f0c41d33262edf546c3df805c179d2f6975af46fe0216b05c18ea5a697b2928284718904485c151d1f278f547df73d90aa16b1344f86942de65d41c863d64c74a93e470e3166227e1dae9cc305dd5ad16b6e337957cf7cf8a119c2c6a5136d2e8761ea5b480cfd03d39c6e22cd15fd9ca22ab6087015f0404bdf57b8f746e123fb5fb6f0223f82211224099493eebfa582a690a5a495460652cfbf9d6fc9b0502ec3c0500dfa06a49025aa6e4e9a8e1568ce077d6fdc376ee578b3adb96e296be3a7a7ad539e20c2bfb79454f2a8d02d16fe15115b69018f9c2fc42bfc9bfe4e941002278ab73acd09d5c191ed6da6c5287ad763b069aafe853d2ad2cdc6bc6ce26c270db044f221a62db8df8208c21f427f1027d2ec24669a41d4bd816500346d112c9d1d071053a2f13bd79c443e369329be6f89f82f9b598db8b696d955c7c495d9f48df5cb2d2dca088abbea389fbd7fb66c47fdf2544b9ac0d841127680c36a75d037f60604c92086d6f6413b77a8ff44ca7bf034a9d65ea9d794664917e00c0c8bf1676ae82e6e6997563451a2963875fd8c11c5940be9ee5f88933262579a4dd763a6dafa22591294e4d3db67accc9d5c7c415e5092123ec5ed7c1e4118426ee49677500301f2910cdae1aadfc16ecbb844bce7eff9496d7724c08c3a23581960294814482cb7881dd3f159f3fca2f05afcc0acd1dd35e2d1d17637407c496e65d297e6d5147a2f66ac91ff54a69ff3c3ee64a3dc2694d0fe3aec7ca7dfe8f6b5af01b35e5ae8b7163e92f159f9421b7b9ca78b7c07ba203a163b2c36d972293243741262abef1442c7d73881acc0cae468f906becc7c61b640974d69257aa13ecab136c57e2d20ef1ad4171042b169e98f5d033579749f75afafefb7a5876e1e34755cf9eff4da3ca933bca5df28bbb7cf01a525fefd25a37bbc4e66817549c22d7b0c6dcc8cc76e4363df68f6f4a416392b5dd33846e2a30d7196d8dabd39ea4ed0e955bc09b0df53b65d95fc3b08b1d2e26f966d4a910c7cf4dd0cb2e05414f43493f697f9d03613672d7cb48bc1bf037709538f5e1821be79947f168b46f302a737b176f77f4f1b1055ebd7599a3f1110e1821d2ab8a1c42e11a5615c2018fb42c74cc53c38f26f8d91db1e4b35755d3439ebf9402a873dd2f4b1c4c530f3d19f43c39669b392e7236f5e84b4040ce5d5d28d8c09efacbbeac1e81727d1813c12c9101f13aeea9eb72d171e579c7d8a03e9a6d689b0f1d5cc6ee91a28b454525d3cfcf9ff718ac31a950165341870d38a0e593c287019f67d2cefaadfb086937e4bd457814cd62d72c65ac02263cd6512fc5c06591c4f8cfdb391761a1eee443b9726e1b1f1f3631dd50d702885de08ff5d28a715247e671c5b83f3ecbb58c73eff99d3d79d0aa5cedae19101c5ea25c739cda9a296c583fe0f1ad2b7edc5140c9f853a2d9c5cf36aa7acd68590d31c905412efad71de172f510b586aa2d862848a2b36c0db182fa62ce0d1e9979e3d2b73238e6a3a1074dd74cec48f05e40e4c16003d76c6b69ed3a17d4b9fea8d0e563131c49aadcddbe05be832b5b26ebaffcf9cc1d0e5f89e5b3550b8ca3e22afbed2483e33c174de98dec0046f9084d0e5c7b6ff1449e73ba11969080e9a8379ae71ee5c70344908e237cc387bd5ab744f2a1cc92a7e9b6ecbf8068ae0900ac9b81e5f78790d0c45d5da7d6a5462265b362230a4da13a3e6fba3fcec4c17b0335fb82bb4c87c7f175cea8e10aeb5c0ddb0d3b0ce329116c646a6d1c60003c75eef962c832c216114b1a85d3ce804ef7e1a9206056d0f5ed9b6ac2f67e7ec4f9e9124231ec6a311a1fb180e2357114b27d36ca7e3931b1b7271d44ee55b9bba1f15a79b34cbed936b90312dc01f7d0a93c92ce59ef86414e2b956ac088eaaee1e7629b213822096e79ba0dbdbe43a4acb76274f5cc8ded61fee801a3f3e6a0a853a9f2a48c500d7c5256bf51bbc948823253fe32c670a5774da7a9614a3d499f8cae3746d6744ca318c277a1036191cf252d41f7282c91d30f4aa284e908337c9cfe4bcb6a484a561b22178cf5e15c9241ee31e86d365e7b3fdb0d3f309fa5d60f615cd11e45551a59b36401abf5361f1a36077773de6fb96a4c105e842eda08d0e7bc103f48de780a1f66e8d3b0a7a489eac1abed9c1405facd415ed49cd4186d3445b4563d5a610fd05ca1f66dc57464a01e0c8ec269be04ee100253750b9da0af9049597a8ddb67a4b913fc6e6207b4686a34aa2d819f1514a19914c00e7a498df41607c3b96c0112c00695c3d6a042a1a73b1c10fe5a98930e22d7a9107cdadcb149233a25422f84b0762d8ce1861dbdaa8653e63629f2a7beffecd8f515e038d2757b13ef1c576651dd3b231037ea058fa4ce735ffef912c2ccf76f9555638f2fa49bf1ec3398bf74ecd486cd849c46431f1c2ef0fdf3989bf66f6b068ba7090089ada5fae8058a2d64124195caa29869eab5568c091875ec7ed42fc74221d5040001ad1a719b277922f7526ac3b72ae6e4b9806fe6664fad015baf1be4f0e3ccf22a094e5d4b18249424b92f62fea8fd59ca8ea534b4340a0cf45796ee6b1a27ff405afb1d2820b177e41ecb3d3d2fe5681f2c7ea85ff1031a40474fddbec6497ac68ec7e2ae9906ca75867b3dc88db6d112f13b47a3da46f495a7bf74beb4d2ee5759a174560cbada6e168d9b7e2139012efc1c2e2919a87e49800390fd6e762eb67b795101ec0f0cbea4bbfed1a66ba7d90b78ec7f05c7ff152a8dc520d66024e72a3ebf97502620c5d2a0b237172217d7fd2579684ccc0cfc99f2b5e357e3416add02ab0c9552be2b34335ec26f600a9da999867b135b3f403a42a82944c21402a0b036e9560d1e43223877c51f51029f3edcaa2a40b556a15bec92b110ec687a4d83455911e8d601d783959902998579597d0c923dbfc0c46159d89ea26db785769b523b6de0ab82bc0ad6140b52c39fb31062e2e64a90560a4be91ba447a6d589cf7d140c75cb336d54e36047d4352007fe0f6da41f7cd15f8c550fd27502bc9da44f903a50c59ea31a9a159d65a52659451acc16dfe935dd5db26beffb3b193a0af4a4f99ec7fe1a2ee19115484b69ce1cce541064941a2bdf167a5ab41cd9cd7fc1a5eeb3517df8346d917187cdbf27cc1945dcf29e4e7b62e1eb47cd0cf5bcf1f3dc50608977f7f9d93078404cbef19e0d2b322528e4ef4f6635fdc30a83eb05a88deaacdb086be6c266471ad69d936e68cbcc78d88e5b3d174fe2210f8fdca47f7f248c4e8cef0a8061d6983e3dfad3143e0afbd45ac03c66e79adba0b47dcf01d550c636fd3b5825e642bc33715ef0204e5b4a595863f387448115898e1d1bf48a1c7060f98a51d896d93e2170980f2ac3bed37030820b9b7f3da857c696952298db32bf4812e79a5cf24e1f84c02f7e34d582a7bd936f582d58820f633b158932ef6cf5da939d35fd86affaa7851655261f0cf3f3a473d924021ec091a52dcf6dd0d996c15d97966acac0df2687a90d0f12e9e8382d708e6a6440912218b8784eb4f4db489c769d88876ad442ea98d236fb49819bfdd4bd2945d1f714de99a549bb7fecf6652a47443c45594e1bb3cc35c3fcd5813a5fab17dcd8391723779a0a8c984cd929de533ffa9bb469e64d03191adaa1fdc21dfeaa7326643c7f72de49c0e6c06fcf3c1c9b38be6a0e6fd21939e793d581a568050a4787782ef9d83f278914307f1a9cecdfc777a5d94d35ccdcb1650d3904d8d5b2ee5bb029ea806dec4f0a81191f402747eafe0f1ded565b0a84a035231d91183813fc03cc94ed32ea660c9ece5e0f6509fa00bf0adfdadc75ee0d39e864860e3c7fcf9d83dbfde081d13b119a2abfe6ceff7bf7d19e986d254194e393860445ed7d489804fee9ec4986c3da4615c3a122d073e7f4289c1eebc3983caeed5946daabb4bfb93aa93e807ffb01e4ec0b4e67f1d84610ba5fe6f7e42e08a480d6ab0a26168e367e986eff4d0d7098f290b2d0d0a66f7fca6f3bd35c705a641f2fa3c4826de57a7a1181b1bdb73ac1168526d29ca99b8f39eb2fbe3f0f7d20a008ed092921f0d6138bad3a4503c0a12b99ea791a0640016f7e2cbf6cea1d58e7a199cbe0707109dfb2876b2b52628297b63b349854a7fcb10267c8706037819c3b532b0142d1e070488b155626565d5904234ad8b7ff730fa28d2c972eccf87724075da597fe0f954044b7409e6c70b9dbe39847da4cd80ff51d5991ee70655a5c7275c9da657587c995dbb892dd1ab0ed298d255edebb63db0b9600d05edf074b901bd993659b6f358df7fe5d3f89455deaca6e0786f64f6fac87e458d02eb0727aef5eba60e74185aa08d9677e65cccd261deaa10409ddf26b95a2126c18d4ca8f13a86e7c384dc4152265662311c27b50be8abc040cfde5fa22fe3e0dfa7b349be74129b877ad5d7f25e78cbfe615fe89d9ed9c7e1cf24837d7fbcaa96da3ec8571544f72512e60443cc6be421b85136c630755760161c0f8b797dc15f218cd52b471e9c8473d4225a21c1517a6db37a495a3b9e4d016d58779c3a88e04ac0b53a06911bb6b4b5a60e42f11dcf5d9aba03eb3820db142673020a419b8368da1e22c10fe596b9692dab8efea0f08676fd98ec1e78d8ed097b16b36b8d7a898494cff9e262edfa4f4524760fe7ec06b25df0b0615dbc910767000996c61cf88d2d0311c66a7aa20148021c48cb10465ede53e37212fd113359ae797c0b9cd1ada6f1d41d1498a626ecec885ee1f9b6dc049a863fcd413c8eed127c3682c6ee65e9ae6670c6acdae1f12db4da2983399d4b699e4b967655d257015817275ea6be88b6354f8f69d355c5243652df1346f4fbd8091e8454eaa8af14a363f8d983699cffbd91d0cb2ab577659efcdc44f87a6358e19c0f9259ddc6d0c3f58739a81b4b90194ef814611691b5ed15cb468847755f268f3a0c06df611158e81b2c14ef2e36cebe6ab28c37c8778ef8ea9a05d1957f6ceabb2412f97239da10bcc60ae3b0828bcbe0a94c7d57e86dbb2d418237cde74a08dc2ea10c4f6bb9deba8a0099646cae6d7efd655b651e6e14d02855f76a24dd657406e763caf3a3a0b9c07ab2fbb9f9827d0ae9070dec1b3469dad8b8521d64fea387f98265d8054a9574ccd2154fae68ff112afdc48e3ce3009d834c8e2e7d50bd35c954f6b151efce76fd12739ad5c8482da34785113bbbe70abdf82eb6760e7b3df4a6067b0c28288f80a843c45a2a84a0cac17b69eace234ece9e8768b6d1f09b0db92a80fa0b50b1d1b2952860f60388800a29dabe9415425fd175788d11040a74c4aa5fafd1a40692bff3f3e4ea39ea7082e944e60587398534971542c7c7cfdf269f1af27d228f95621b852fb5ab9056165888aac1e6313c85280d5230e9fdacf4b0420f594378a6fc2d9ab6d3e3a3753381823aba8f4f9729ab7c9bbf4c61c8d7ee666498e8ab9540f6fb2ef69139eb4105c9853857f7ecdb45ed63e215086ee988779df009fb09896d1e468d9048b2301d8f41dfc395474f314f22545d60ec7c9b98f5a01f41c5d343e69e8691e13a7e0c4251b6244ceba0926e014d8be38715e451d92a7399dabcf32ed1307bcd17f156557c75b17e6185150aa66d5a3b68edff97122991fb99f2795a97badc118a7222fd1d9c8207b686bb7bf3a898dee9d9ef3e50c9d5a1d2ea2159e2a4e8bc8bfe83295c002e77d9ab2a3744767e9ee04be55641ef74062851c954c11def7c14a9fdface5a090291be66183c1db362c5c7e8086797fa33bf5d85d56677889c5f0cfa41acb83e21ed5105092e1b815ccd868a581534341137178f685f1d86df523ef11ba6c5e83ff6182c07532e84ece78af37c3c426f0484d370a9d2e6cb07099eb301b86c90535ba476b10d9b98d62c876a32197542911f27abf3678e46653e7e9981d6daaf06fc0058d6665790bec9dc31dad8cc95b48272c409dc3b97978a2bf0aa2e5dbc4112e7f6f87017e442814ac02636adede70d34e3a33d13a506554e1caf32773eeb175cf7a4f9755e771cb6f240689ed1eb18747615b95871e8c4c5fd9fd16aee65275bb2e55e1609871a519b8af22fdbd9a2d9ee17dbf8ebfd7f0f0e82d0d612c26de59f3fc297ab365f59e29f83f08a98ae82636e64c2b7e9176615002ef5def03a601814d4cb9a25021abc0e864e92d36ecebdaa514b7df90192ca90a8381efeecb98978cfb8cca1f7ae417bdd7cc7b961d05feda6a06d3d83d033c16f56a88775d2da20e9373b40f3309aff74940f0a5b307f2950209db6de24129919f4dfa391ddbc5c8e37be90c07cbc98bc1c182e2b237adf13d81c06ecfa58c61ad46ccb2930f4a871d5693ae2b15d97e46a7e245faded0a4d0a4949f6d0e7c41789ac4c079f8569430cbc6b5e3acb2dc30631ff16403b826c68ec7be4fadc9f09766dbb342cc39c37d22ee190a54b9dfd2f8f66e989309a76a40f4250c38f0b3881b7ca888482517d7d5723a86380b8e53a6e72db388ecd61799fee7c8686817b26a8ea2e4741108b7ed9f8de610bd03025306d8e47de558b20d8e31c95bd65ed1dc0056b227165da8e604adfc1ba1097e89533f1b8a422c9b61ea81788647fbe24e1b80caf721779cd27e2650c5498cf785ec74476325e107aea4d18d5850117ed5e55ece14cd39bd58fa184e223ad3cd2a2cb34a7a89cc4c15af44e21b5845f44ff76c372d2eb2b82f9fa01644ac71c4565c6219a60ee1cb83fe5a25d1e6689c90e8fbb24de797de211a8ef0f972564d160b5b08ffa84d1d189c168ff0dd024b5cb92d18bf12e676bc4a586ce25e9c4a8882eb14d7057f6e0ae7ccd13df515dfe232255b06d61b885f29723c87d16c5ffa081588189319a3d9eea3ad0f41d759a222510b567235de29fb9e3c1b99edb4ad48892ff1a87848cccff1342eb9c4a4a5289cf46fefa3cd13fee7de82f3e93b478bb3513ab","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
