<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f19422038062c680f2c5688a44b43ab733032faff7c38734692d594db833d32fb68c75ddd14c094a265c86647021cf54fe771e6ad83d104bb8decb38278eaad6f437c12740bf3647431bb1cc88c7c53817ffefaccd79a00c560bcc2e4b53bb8c7750a8835a6ac292c16a25449802051dca711c988695076800afc88f2b4367df89887093e34de5614d550f4d7d380220db6fd199347eaf64e2cb454da0f43adb2e799912ccac8fa3e0e23f311f278d1f94f113313151cea099f22384f45ed3633aad70ba3eaf0f6fdb82a3e441a0b71942b0bd3740236ced9c880ad1ff11850ff2c4e5bc351abccec71cd28641466402177c8628fc7c8d143506f452adee861da1703579855f9cc043d885770d8ef6122ff24a181949cdc6c735dd51b34651ec4b3bec8d00dc871516282c72adc5a39aa9eb72a5bb445e4608f89ae70eadc067864c8f04c6cfde81d738cdbb0891b2498d9aef0c3227f16524a2a219642a7381285256d6f0181866bd78e8ea55890596773eb674d4a02141a343aaf1bce0220bf5366977c29ca3b4329aac026427fff31c06c5580072f1276dda6e8c8318599ea158ccafebe8c923ba67f5bd132ba61db787e0fb744ef52a4add979624f6694687caad4d9f59b2528cea8fb00ef760ae2b1b5764bf76285652758f09a64558f3312c17b79f1f66dc511dbaf6d1bb5d561264ccd336da6ffe587b6a436626f1d23db6b223a9d8ab94bd0190e548c861948ff97fd14c161fde52b1534f7313832ca24f12e639414ddf1a09779075076910fe02ce1d432342a86c48f212c6a914a421960ec7e330104bffc3f7111771f35d3fcf22b63f89c00d79ed5ad5be3f621e4cedbb31e3672213e8e1f6e14cd70294bea70871a027e2e4741239aebdb14dbd8efb2ad746b8eaf99fa624e884be612e4f8b588da74693ebd1ebaf60bebdf0e1af182a3e7d7c6b5f148ebbc9b0766ef3a826341099011c4cf9124e90440481ac7f5786e55daa07ccbe188d051f42fcabd067c221479d7db8600ae199178dfe0d9503758150394cea773e897e7593e1525ae448c40352a1e379a333b4bede78691f668a451bbca04894dfc2275b57c3bce24e27152b5006c8694828a879465038c385a92f02c357a3da2792425e3d4ba78dd502665d4e667edc7a3715aa7be2f35b247caaca06d39c321db8e9f0dbf8529976ee13d03b2b2236d92dc9ef9e4c06c010edf078b6b8680f94cda987ab7a09cfff1b5bdaca034ce62b3469cbab9f22afc4ad048fa89c6d8078568fd1b490ea64a7eff67a3d98b2cfbd6dbc3f540365fc0ceb96052747b3187e4cea8751a3d7c3e8c132a0ab3fcae8c4514cf9745ce9dddad41dac262df92f75328c5cdff9a8fa60e5dd3a9027f1a6eb56bbcc3de61bd44f5927dd6efb8316bf77829802f03077cbe80113a9e7f42f4510f7bfe3943e4760f8b902ffe7e7ee1e8992ecbda37156f7c99936e62c9b18a411e5124ace293a939138f451846c66effd3c4077bfed366f3b4a820929636441d8de1c7ccff04cd538a9a72785d448f6440c45a3fc6886e9b816734cea92947043d54bc2267c195e6889b7aac64e2e0472eebb210c874aba453bac43dc687a4a72b62a4ae5ae6021570f0f2ca81fd203091a0c1fb3674ec676a1d9ef97e625a6c7480608982fb39f154a8f55dbbec0644c0f7b5402483822c97d5895ba746185fcdc91d8b1096f524df43b36829da12e229da8dba596bdb4093038a4b92f3b2d67dc48a1eb6934d0eef9698ed5a2be2b65d8697aca96f1c07ecdf8fc2fbe9faba82f6ef35adce43e84626c87dfea92d42f1cddd25f5712d1aaea54a4854825375d51ee60e954e978a22fc1182b85b302ddf7f034bfbf1d3b69b6b703ca2436401c0d147af9dfee87e60893ccd5d69b3016c7c1b2d41be07d9a299653176412c4802021f8af136b2c03d46b02dc3391fe6a1d36c17fd5ae21b4fcca1a64ff82353a4f7527625aa590e70bb609b71e049e0bca47e7834a7131f25ed0d2c3ac6214abfb3e9485307f96e333b91d0eb04f728577c48174cf1b3cee0197acd1a582d2f7a10e12dc4ca1d13ee1ca5e1cb42e33def4b763a0fd9d72e5e2928f06abb1a868fecd6ebdf34434c750abf51b334ea4f8a593553836ac5f9030ccb1ab9d528dc9bd9298525d2a1c764f26c14477fe54048df52f73f55362c66f541ee623af5acd2d680e403aaf7b57c50246676df22e8c9c633ba7a4ecf593614cbb029c00ccd6d0be4be5c3dd1d287c99895237811d1cb3cb3ae344a007d478b41e040ee5169bab7baa7f34c7d53e483d028903ad3acd2ddfeccc4c1b5810cc197a6d45d5b7ca190bf8a4fcccdac81132a94a6eeed76605670fe1718655e7c1627a649e79a140439d1e44490d7610581caf6539f976c1510813414b25c91f97397e27a80526a82afcdcddef4d961ee3db6fd9ace3cac20eda51bfa1f4c8ab36ed71b72e1f566fecc3faa9e738f18a46a95ea92618a1ccbf9aef64d6b26f43bbf9f45dd5f4b8632300d7563e9b13cffca8aff274000cfd7f7b6a8a7ea468553231b6f690b0fdd4bd0b22607720a032bec4952be7721b31ed996e9744d7dcb805f96db88c153c5cd4f2698fae422f453a337511312148f1b0ea8d868cc66ed61ec880f8e709ec483082aacf26775c22302d8130df52d9679f17560bf382f391aff83f389a4a1bf7ee3374b13f9887df0090badbb6b54a8fc38de27600a3472d61541240aa911982c4c44ca3f9d03766d31931dd0cf6416c9dc54d69e5a41c19266edd142aeee8e43bafa752b8a632f50dfc51a81ea4b4c62dcf3c1d717b5a2ffae504ed1575e4a692810661392d1c25322610b6f6363813443f3868f7c95455d595440af119a36f33fd49b8dbdb5cceb0653edcda8c43aa223c667a8e1b1e64048496052a5ad24d24193a038b72c5cbb6c75cf96cacbd811f6868f3c69a9e769b974b38410db01a9ab294c6824d74bcbf3b8e888756c687f7674b1f5e94c7ebd056e0837cbaae0834968e040690e02b9d40a6817f5c002ec85973436ec60170c83a35b3978c0c7cf1e5ada3c8e45cea1fccdea9dbe1487507931ffb143c8e3c0d4e5f5b10c1e95a9ddf18f123b63351247534ad9bb8d9efccf60b6662fbd27222065b9f320c1b80577405f4cf20731bcf21257b50897ae5ec83dadda6541fad3eca83e2cb7c9bb89b2349d5b36e32dfdde08742b003bb510adbbb82eabd30a435013a90d76f1c441ae23c1eb5a05df24ee8b13a767c073133007d62a54c235e0f2d2232f7f769c503ae5247eaf7ace88e8dfa18716b2a51748b1e21d1a063a83355ae89bc1bb554c12f68bcc838c91077444e6b373cac6308db60298abd26d951e79af8d25d46d3c6b6767cf4551aaca4bb6d10e55198094627e193e658f6575f8ac45fd7961eae15d82fa7a77508e50379db46d064d9be50790b3be261586ff3f924b450a8765cf3a97290dc4869c1753fd279cadd5407887993cac47906bac253bc362470d23adb015e690d83c4e7c753fd23a7d7f8caaf30998b4c85347ef3aac566bbe2454cebe424974e10d61d8fee54ef9bd05c7b2c29e81c7e1234a7200df3468b2bab3c642e65a1df65150781dc7c73e4922dd93bb67bad19c28641f98b04ea5f17a975fda4f86996b4db12cabc2a3053c45633554a489be8e8b61c9682838e5736ba2684d152e309b62568830172c0842be2cfd21721f91638c3c61ad0e8cdff15f6091209014562a8b731ab73c4f233227e95f2fb7e66ac495d3fdd4b65780edb1ecab4f4e88aea3d8f1556c97edc2358b242d332de15a52ed87f070351d121b2028b2b4a894dbe05620a059395d796180312b3a11d997d50fe6b052650e056c625691b12d0dcc79a61b3ba03f391c2fe7fc86e419e53b530a4e6179203ef06fe83a4969469fe64728ba4f238798c998f8f1fc061f48560633890b57df9f63ef547b7bbed3b0d01fb96755883cb5eb802552905a58de357af3fd6a24158ce0f434275f53f1ba80aa9274b25f3ca45fab569d8c325bbe599c46a0e4372e89a933b45f844c9909dcfb50c21277d58b3103963b7ea72f0c297fe6f38d847e58180170935bb26ce3cca3dcce48c9d3a0376fa90f3ae176e2dc5602b9502ca9bb8e4a7158790da452102c81d1ba4f0f846d2c865fb3668e8dfb01e2721b1b1c7d1d29dee1e5ee770650b9d3f1f5c7c2e2b557d16433379858a775e9692b68cb51879d629ae96f6d0b824a320e6babac3f0fa99ebafe36c4b9a5fb66c70bff49e850e6c0fa123020fc6d5c092c989d6acf15c4b7c1fe577848f3059c0cd526b30538adc0d3eab8e8314c5a8cc91584da10de3db18c2c9a162c45620d141ae26f7ecb83df80813dea1ccbdeb5c4078de7456fa6a34f77558c00d9e88e141bbac5410c8ccb55fddc9823ac6886e9b091a2b7cc0b3ed643fd160751696b924606d185545db39bc762356a45ac533ba43093bb5a282e7fb66dc0432119805d6e6b5ba95c541f7ffb169840ee80267985d1b9cad7d71a97caafee74bb37abb23859478fe6f4415c2176818caa2efec9b688afd80c244baf79f8c8fd0a2c06cd2ec6231198d283cc0df1b1b7b9f71d64718853cc05bcd421fbed13eef50b6845d58631bc9f1892dbb9b07bc8b8271113910acbf8cd284970d6c8a37083009a6f1d38be40fa7ef8d918d74cb3c1e782bc248bdf68c9064fad1f65a72189881032659710753b6c8bcbd82fbc9cf9161b0ceea8c70ba103c458c67155e24b7f13c9ed4e7a76bfe1dc12059784457044533ddbcf3b56fc25e0b942fb40a64fd70452bf05cbf42ee5ae337f801f44c58cf36c692bcc1fe6f9c6d93f94b10a3f379bda77a2ecfb57b05ad8b77536ca8cf99677b6a4a4bef3b55e380ada58ff54ceeb962b6575d4670a5e6c7a6f348a48da9782f530b90e20de6fd4eab63021d0a25d05f004ceb2c269029e596b1ec65a79082d75c0971a2b147913194696a11ef86b1742324dcea6b9813320269a35aafd1cbc368a89c9e7bd3cb66bb8e8bb221908ab92a0bc304194ab12cc9e36ed2e0dc3e223c45c45f000045f70b2a22dc363f3bf4d0c3fa59746a59d71354956221d413df6fbe5fb236995e64190d549226b2e4ccb84434b70b3369f55a9dc68271430c1c55048b7e75a52bd22c0a3faef8a3bede95ab728b9e0f0d44023a0672a88a195aa5c392de0beb6488e4252ea47a5090177b4dde83f6e2b494f560037d034fc806970d78229e8a8ec1f1217eda6310f76febd5af8fcd210ae1faab790846bfbb71defe12af6763c20b8751733aeebf04038641ae082d8c00f39772960c0eb09c6fd3377177089b1d6d92658e1ca1a66b0eca8c691f559f5119fc868777c9dfc01931fdec9e0a6e22378a7657c2b890f35a629a6425b2114832b1a9b8288b3d1118d2f850bbd9e40d654b2dc8812c257ba3453d003f7b2077f923f63dfc7e8f8ee5e662fa8a04915da6c7c24a30400a97426ed1a218f50cf33cc53774b632a65b0756ccabea7a62655c8eda90f295b763fe0a10081b1743d0e550a0fd7546e4dbe94daecdd5ad2906757b40756c7a176cb78e98ac1b64ba035e445c7b8271e909023b9d973539c9ba4470dbb6ccb363fa1e4223e62edf75b5b1dc01dec1aa3c8ad48e4bb7c1f20791f4255a02dd65b57e484ff82ffddebeb775d3d4c6800d6959ea77ad8300a88260cbdff22fe959d8e9c58ba1b0d4a9db6f0f672960fe34829e02058a814294aabe83009cbd94c733233047220968d3a8e4af9fab7dfc2c78ecaea7cb318a6ff231d4b62c7d8142c8a42979633f3828d2c9ef3fadc4a41144a1f41c5246b6a1858763f9f7f3a3c20d8fb129d36284ca1051cf6be0fcc2d3edd2cbe39acee0dfd5d7ba08226e412f776675a5c7aeed9d8fcdbf86caf718b21ba0f62bb44f192679ba3d510f51ef57f8bb4bba07e91ebc7a06ed379799e20fbe39e1a7296dac1134bbc9f3e8091b5dd86138a5d336b74dae9db95aaec9ea568102e666be94e72f17947d48fb785c94787ab988ba0d4083aeccaf3388eb13472333e86835d2f40945f04e12449e8f1ee9815edf2fd2b927a83dfb8ad1027c348c1096a1d28c4302a6458b18da5b49a537f24b6a68102a7749ae7c28cc9266472c516e0ec109997e7a462b69d75c0575555153a5dd7140e79d2aba9e4b7f9d82184d48612b2d153d0cbe963e9021f9d72b79fc4fe8faef0476364cd7108608c5eabbb5df6effd7068abe442499545a2a6d57460027b74cda62795831562b2dc24462e42a42f1312080b865128659931b7227558435ca3ad0c6d0ed9970bca4c1fa426c2a8638084ecca7b5a1563174757c37a9b912e3e6c4d07ce2fc2b67a282066da0050429b4127db745169c43f306a5c85bed76b992e55cc12cb74255f09939c02314436d1543208db5357c99ae57773bc5033492b65f16022f92b7807b867895f1b0993f74b4caff219cc1904637c1d67fe061318a72e6cbf051e3b09effd63151d0b388a0d34b52e2fd9afc7979e4ed72bcaab0281345e32265dd6e3e55a0c9bcbb72fae1df09be195b92edb7b594498a24540527bf29ae838fefd7bb54ac642b5436ff44c6a1defcb226bc80de2cda60ba67bfee177af52324a0be1d7e0ef627a244a28dc08f401d68b56a3e8959ddd8256a120d3e884787374425c1a2b7dbd553fe5e346ad18bd0405c8ef76d3b6ae32ab2f528a8feb9f88e0d2c412aab355fc06a929b010280222a40ee89bd865c1f0e8c349f7fe9b2d855af233a16c924c4bca6f1ef137d757a1deff784dd08c4ed8b3dda6fcfbc7001da6f981addd9b78b38fdb90badff165b62afb246e8663fdd873fa69316c7ca3b450648774e5ae8f96437a7c00f477defdb8601dadbfdef3f98e6a2b11b3a854fa394250b7f426a9db24f845d6bc04ffb4fe9a2dde6e8d3d12c1bddcd517a45cf9068ad0c72b206c3ea91459b9a07413d087b326a68a4befeb53ee8b17dcbc694f711be5d6488a2c9df77b1f5a34b17506c7cf2d8a5bb9e58d932cd6c47d41a18844acff6fa0c929c240e27507fd99024c3c637b41dfbe8cca1678011fe2e85b7cb47e6d359ee2db69ae1ee109d4fdef959251bba33e62f7341f5beacdc04724cdf2dbd039338172c93b7a4553e426f2309275a208499f0545d675b727f3c6e7d80515ff275faaa103ea76bff8f4611bdc9f52048ee02347311f7459913f649629fdd9ebd294aa3a93d5f72fa519e1c6eed0e3f8c1b36c928ba0be8d1549f35d085b8c028e9c958b17b2cd8c20aeabe53512be8af7b416e946bf58fe483076b72f4e474b1aa06cf195ab0fb32ceb74e25cc8e56fd41242ee696908be53009cf41ff42c6d90ffa2eb05c2801a33db62bba2e72635eb7430988c569d4e948cb1d74a3bf4afdc0327107cfe063535ef0b900d3baa2e18d42e2fce41e81a51efdc0347b5412f5a2223c66eb1b0f400788ef7e67714359d6caaf26f6ee100a5b2d30729b3deb32407d986198b386f58234ec8ef4d722c84e54a6791bb5ceffc0e170836a9466c8bdaab69e47895121b48f5c9fe8f7e9202be8bfe437bc7857b14df730ee805bc73750523e45dfdf7625d9dba8a954005f7186e74ea61bb82bb5b5c76fa76ee2c443e7e000f649ece7fa2a69ab7f4f719234c92e83f46570bf820d67a09d3774444436fab54722a184b3b10ca7b63a66e1a63ed6fbac9419cdcf444d7f023ca7819f4d34637c3a8223796fd9edbb2c00ac87c08701b38184b0e043196b3c86d01b46015f7e206ada09228d1df0a240d805aa0cee2798b744480e2c4b7df18c8bbe39f3a15244e69ad0ef18bd6d7bb94d84ea6ff870381b015b9c2433019d26786be64a95c858301d06cc2c8c5345ef89b6b6b919a5be78e4e77f8e7eb61405fd29255a6fa12d4c95ca6314dccf583f87d983b25c430c96d22d06b7b9beba121f7b01175270ae34d2b68b8c02d602a4e531e83ddb9f3234317a03ead168c992a29216b7ddc715b93470619acc32874199244eb8e3af7c4048beb71d80948bace32478fbb2bdcf6485563da1808b7b29d9edd669fba435738867ff0390ec8903d358e57c6ce16bb3d902f54f97e8bff053883277861ac4877ad6ba0a10d7e00bb206307eae1469bc0996bea931c94f019421e5de463b76d1e897218dfae7a139c973fc9a9af2521620c56f3d395b36ec2fde261f92508589041e0e709c239116fd1f1cdfe2108be62e3106d14733e832a288b7a52d86d6b3c9c99e24c30a2f6784d94ccf59e6ae0d5907b165fbbf9c7bb01d40f20dea14d9922b213d64394921fd028ead9d4bd74b555371031a07121072e51f4ead0f8185952604fcc082a86e69d10f41fe4307e1b95abea53c3d25de4be3fe36bb0e1b7e4586ab5722476fabe7e3f209680002315dd837dc0118b8ca7349e4f8354397ee44086fcf0a5c148b0c046ee0fed93934075bd516d5edb88f2a2a614067f468acb293195a10b2e720cbff625644245744e30f897272c8eef7f402d692779ca9d10bd2db981285da986fe95c1a162f1365ec90acc199c7a5a68d9631b4c99274c1bc233a113dfdbaa6f1c83301c531738526a87d0497f67cd31d8ebb77a210d4cbc86d3c6511bc421d347032d49f47efe202ed2bd8203806c5601c91c9df84fa08ba2de7e349bda43c4505b8c00c9b3ba77e9232fef20e2cd2deb0867d6f45fdf7e0a6df191b6bc60c5ef7cbbedea10cf5f09c614f486a293c075f4c302ba09faf3ced807c327a33a2db6fd2ad5ace20ccae976c6116a2937cc77e7d0f15720485ead757a85d4f5a101f2773203b84c8ed30765bf4102e99c987ba326eea0f55b2c79605cf43bc144242b159e10e4874174bc5a6b5c40710e43b898181e2713ef33f9576d8c245f86db6fbc37ccfe13920a2dd5f282efdca5efcb87294fe1eea84bb494e04225850e30bde27c886aa48928e1434c5fb9c698482197f6aceb9b8ef5b6edea669a03fb5b46b06a649e2ddb196c6cf58e0487573495ee6bd5ba6aec94322ee348277e3ab03116a93a7aee1b5901a3be86351f9ea5444dcf21b0922ca978ae38752777ec0158e0912506a3dae78e2630cf7a5d63445c05db867660687d0596e89f2120f8f550f7b22d7392b234307675a23d71f80ba689ddcdc1d44af9c065ad4b9bedc79b8c3e66a8f57d7870b23d4af158bd01ac71fbb45dbb39ea10aa0454e90ec2f4d7f065c718e842fe5632a8f03ad033aed519dcd97517b48ae2984022ff1cb52ab3fd975ae2dccdcfee9a2535a8a97349b69ad51d1f4d2a90e52ec463fc1f77ec3fe61ae57b20530f32a148b778eaea31906edf7ef149fd99418f911c860a45def63bbdf5ff3234021ef503c4e1d150562fee664467b4187399671af7564d5bd4475ed6ac7ff24fdae11779d650996444d3b42d94ed22387837753b59060cac5b8a8bea0a917e4ec960d18cda7e52c8d948ed19ead678d809283ebdbb1964f034a8ab97319af056c0e8c6e770c82b08cf6081744cb87bedf523595c96b2b3d744d663f5355ba92b8ab83a71f6c2d13fcbf70cecaf8fc762bef9bc18cf89d1a72fce2311170250671542b5987c4305914bfb922cb954f602012b21bdb52f726952fb6cdb74169442faaf3900733c80860aa1b16b1a04938e8b4cd7ca12d5193143034f43ca9e491c0f93d2db175a9a1f67da4bdd7ecbfd002a8ef860b53111f7ab6c5efeb745706f06c50f5649534ad9f9ea8ce8068820558e943b4b98f7a0a7fb43430b95bab2f6f41f696e325df222c1764370eb0b930c3739066eac2fa7747421cdfb25b3140f4e9ae15a4727f954ede748c5fc126103fd62add083497e7a5f7266738eea8323ecf417bc8a0538d0ebeb9f252f34013bb24e63b18817bc87c69e14a8f95770231d042da677290b3caa3e598fba2a514e121e0e3379c02e8726830e5fd4f846aad3609d7e0d460c5cb28bc266a13f924bc1aff61638939bfc836f38ebcf0108617320962424b74e85e0bd9fca14adec264bc7c76e63076fb3c8bbbbabf3d629d9c50851fd2b4dd12737c9eea9222bebb67288124cbded11ff659279c3f2a67cca421dc13f7c6667517f53e0352381fdd3965c7ec30646b832854c89a73a26e4fcab306e5a0ef7126dc0a21221c1991606a24867c54071184cf58e63869c028deb7d02119c4dca2513beb53a5e6949d22e39fa8f2753c62fe45f4793a9a1a30da13926adb47d46691d8e74cc4e7d908a669668cfdc172d63f7a036c3ec15920651a6baf797ccba258c9e7183a9de861c899c1291645d00dbf0c696018b94abf3ff9d87a228596ea3d41698e20802ac09d4f8c696b9c5115d90ec2f56aa82fa230a951729e3203b7a8bd90f709270daf88d68a41fcbf87fd413e6836f7e67c860eb5d475dba1142317bc0a310a0b1fab806ba7f069902abaf6333a1c0a09227963a86349939cbb9fb6f40632f0ebf4004a55bd79f22715576a27de126f4fa170d1d512ca10bcfe0aac12deae49a01acbef9e6ea4b50b27261c746cdc47014e1f4df92b4f40513ec1b25f0b149874893dbd9a030199ef495d346c32f537f48e0390a311e2a915e7ba6b98cb51350d603f0b0faefae5dbb2dd3564f76b0502185afd8a41052092054a59214bee4b18119bb82264fd57eb10dd8b4b0b6f5db7278993d61c34320de10846dcc60ac7eea104b2dae2a88eaf714a0f002f60d7f445390e23b7dccb9fa84ec98eb7e3664ec0f2023c8c9efd9c74ba3bb9899609f4ccaaad54fff5e46867bfc1ac0af80d7ac4c778d84c54337d9e9163788399394a57eb194abb4c565e2ce3f821f9cd648620b4d41656be7c28900fbafa5bef895f2c65324fc0820465ea5b8b8c089e4591c9794d0bf3f62898e757523e5550726d48abee92cae942f8c6a3c55b85a42a0de78beebf157d33de296ea56e9367078dd18c0fcf61003e5f50a5d2b692282d099b0502f84bc93aca46a1120cc7d61b997f99900f13b01f0c305177a4e5f2ef57a5dc82249777b654df77f68d4865d6450f865b0b15983df2d583fc39c6ba40909baa37d977f6cea3c187ad083e0972fb944e95d1b757c76251e2ac8f02abe36af6d6cac779a2c1780132e9c4cc2ddb17b041e72b3536fcc0dcf5aacf17bc0fd11aa26e2cc67135aea66053804f5c7437faafc704813a6eaeee19f1b1f3d28b04fb0c68407c01b6d5acf0493065722682771f06a70c2f1a997bc6ccc6eb6935eaf12d0f237bf4b7b5475caa80715aaa4d31e5c85ea6c40f010d731023c9dfe0ca9fe4f2b963f3c665860426ea64d3b4f73fd28e02d1ba68e6a1b3f03b5c41dc9b7427489a263e30a07fb6daef9478dd092b79c4912da8b1b41271d88cb4ec24ddb7c1a0535fc4197a14c6d3e9e7025e71adda040100897565451cec1bf3ec600bc08033634b8b1c6fbccfe0cacac938a8cd2a2c340ac5f8c1a15bded165fda80513e93588a84c9bc29400a93af14ebf160f813532c8135f4ca921da5d4a7515e65f4b355cc5ef22e50864385ca37e63073774c1c2e560d9551437f267557c8c7d2cfde0f0630fbf7c5ff99bdfa584b076ea669e54b89b1e1f4f86ed29d8213bd02f62644d319e6dddfe0722ca1416ed56b6c7b672598e0e01b9ccfff7e4594146a3f1ab8067b8eeacfd34559179c678b6241c058942e797aec9cf6f3af2a0c1593e80f1c880fad8234f23608828235ae5a753a396d12fd0e1c6af8b6620782de91917d54ccd4387220b224cefda5f370025872e1ddc05aee549184d3b1ec893ae6f079378ca73ed3510ab3a114dc3e65b9eef2f8c669c4c737759e1141906e86060764c01d43456c6c1a2a6b512084162c88f7566ae34da7bd20bf2a02bf38377f1c537dafc5296a111f8a77a92c40ffc7eaea20f143419d0455bdf8cdec1eecb45eb75e3cef64de9a0436904fdd3cac488a788b633a78d9e76ef3babeb70f096f896ae126428c96a090cbc2269e04f6e88c99d5a5a3d713d8104dcd4be241aa79341f1add26a32580c45d1c75aa7b28f433b4dc4234d43d500b129d7cbe1418d9e3c8b1767ae0bfecc47518945c5c292a3585d62998cd30403ea23a207884875355e79481280f935a8871b2d6e3065d03667edb88deaa95cc64982fe2bddd9831ac3abf14f4715fb5b29c7b7083e6775e194cf9ae6df709881c1f09c2de14621f4f8de6a0144f7c12c019bae0d9190cac0998b45ce9e2d13da2a8b690ef5e350cecc7354548de6fb4a751ef83bc66d86e892ee8eb9774d52f8ac2a5692284fb00fedb5e689021236b8c778182be706150fc2070598179181ebb5059823fff6d99e53aa9f6e5fe010297138b21fa532fd847c7c5f10bd2ba876369c584e7828c6977a89e477d54bc7309669f5f55d2741610f1c449a140aa02ff12930e42f0096f7987764c6d2cb19eca75a39888de120f86d8ab3b2118c91bc61fd0489ada00b689572e666a65b14ef854113800e4ff7012e64ec57d7d47ffae0772ab9081ee7af33dc12c541bef3a9d9a163b1a02d617dda13f51b593a1878292675961d4d3e52609fe8f87e2c4ac4199e7a1c8c6db3e817cc968cafc0f4fcddf11af347845e4e878c08f7ed7fa6345f533ec618908f32a47d151cfa8932a85476e843c86ae563d4b712bc2fe4a02fe54023d6320b662f26c6605c50107e6e1556456657890524f8b4d23aee70f8c9f7a80211e5f989f9c62ffa5ecdd9141f78c52abae836050ef0edab163696cb437bb58132912c84913dbdc8805277fb576605f86cc24f4238b9c565cdf76e9b2f438398fbae8a86006af28a1ffaf23122948c6a4d883d11020b927b433f23df7716eb34d62c03a56d97756bc883170ae8915d263d070895855b458dfbb5c0a1a9e218166a692af5aaaa994365d72f99c6dd331f89fec84522ef22a6cc3bfbc9558e8ee3d37b12c8ca94a70290552ed1ec4bb7b28ac596f09ea2b3c1176080ad567ccd71d596fbf5cd291478c4721eb96bab90142d33405a28866d383dec26e845002049e73f3e52bbba67aac2ed407cc343cb50aedf5d031780f101d85da772542d992192c6491cb7b7603e8ef8e8505c5b1abbcd92aef92ae160d7ed78ed9b7fc0b89fac9e530c14fcc2d674184f0b52fff084acb9a2c1bc2bcd67aac26c6a6cfc44a3865c59f18f6a1f609a488076e854856535f164ab0064304ab8e9bced418a2f1482fcc89256fb03c633e24ee7c488c44279535975299fa8e4dd679b945d75866355a7098305f2b94e86cdcae813b74795a8b07a2f0652ff7e0094f34d739be83772bc7f73834cb6c2b6ebd5d625dff1a7a7818c62264b0438b67feb5ffbceb9626f459631180e360d64568a4ca4599d50cb34e111fb6943bf728e0b03e841563a06ab97df5083d26a46a227efc0605343842a2bd5993e0e08f3c818dae85ce12e2c7be0e84d7171159f11c654a572565b614ea4582dfd7d485eb06aabee78ed1d561a15aefd6f5c12865c3cb9bd1977218026a5949b19a9e1ae0466a1ce4933a5830e8b394a27b84325efdaefb48ef19d7ef873b43a3c517a0dc3855dd7c68387c3f3ce355b0ed4ad8fa5f2b6c803f1d852cddf4e2bd3166985f01fe82916dd07d3c98ec12fba5eaa2680a58f50cbb8188af9d07814805c4ba5d6cf6033a249a449b4c8b5193ebf16813b957ba70641289dfb77b450a539c3a059ae8c82a28f49e78aa9fb99a49927c80b9a70281d526b74a7036628bb388f85a8bb50315be5f86bcf2da91f5ed28adf24fab54540a709d64e43245561c6b52e4b006b06f159836b5807fd3a649991e4a1c58fe9a4c1d17e6af7281deb1d270458b8421b5280c3a6eefb83e69f4b1c6be6e211ab72835a9b0ce534732eb77c566ad7806bdc910086b7b55f4e1f686e3420e3b6d036f4ef25c6381bb22110f3b5e5ce6fff2b2c0c311965ed3c5ad887585cd547b78c0969776156b870adee98c346a76be087586c1159f2e0b82b062f2f83141185def87d32f860cc99582d602af6d6313c4187336a8c49afbee7ae5ec83fb1f06ac1837a2066c848cd460fbceb6cd9d3be5c437e68e32099a57726695a576be9cde62d75bc9132fa784fed06d1b2875a00282c127d28cc9b98c73959b81db26ac8e8bf2674a62dc029bef790545ddc1c24d646930a6245b981a9b8af1f785f314881a60a414ef7f2095211ff96ecd8d2569a3993ff8ae7340994a8b7535ac829df991b6a1ea9129484035f4522c7d7b01957f4499ef8e9858b7806018a569fccf3adcb6f6454b934fd45a6a55ab1945779539a295302a0a2cdc1e6dc7048f1251d42bca94323402537dd0e734067bd7fb88966277a309a16e1b8333f94a4cdb26537633b2d38739ed4e58e65be7ff463e34c2a8bb0e232802578a92f24b5eeae29026b7fe917c3fbc6607cc5496543440378fbd9a14f1f3623257f460aaae9b40f384750f229c1d1ab000918ff8b8e4194f300569a68870b520db1a0e70d39e715e6c827cf4e7853cea8472876073340c6ecf7ff9987b507a02dde1131bc62f863a1d4f667c9d464321761c21363bd5be73d4654bf047fecf9f67eeef5784350703978a4c396610ac7ed780ea6ff909a1616dfb1a50251f674f27c2192c9b0bd86c3d31ffc1d66eee9b9068cdffb34a1d40a99ebffbc1fb1a75b5eba967561ff4d190106c31d6838d7e01e9dd462447f6c0c6935503355cd5acfc8f903674f0ea3c9eeb0697de25f8bd71ccbddc4f0671054d2994fa2019bb1a2cf9c58c2de8d218240e6456964d15532c9ad267e2a7eb877fa11e0f26c4523000d370d0df57b38441b6837d4cbc060ebaa66e6f1b43ae68b8202e961926200be9bb4fb94239e15547004f865c1f5e473d3cadc5d44d50e6d8b33b65edaf24a3fa00d7a7840cebd9e5229c4b5dedad878a126270f9ce1f5c179a97c9244791ebde8ef7a2a36f1352cb18c6469c24e1614749dd5f6509a09ab491f0d58c5d042a8440849e6dbdcc2ec7330dc3bdae4665ce170f851ec341da3c09efef5b5d54ad833a9e477fab24c37cda7f05e2440d72501a5edbcb3926f705bbb0e45640f0ea6cad0d0dc65865b24f5a55d1c1ce336f5e2c6299ebdebca0767236ef87ef4d5216fd01ce99f5dc6bf0786a826e59c6e7576ccc885f6d166248c77c67c465f91793d3eb5f569758a1e7591c3dd97c89ff5a84d369c8645ce7765f5d61f47e71024a931d01ca5635a40e7377749858df78a4ce50aca5b2293d12c8784dcf22163089d313b72be2253f3d677285fa1aaec530374e461826c4d5061890e3bd1c572babb6105aa1d3e5c75664b8b2effa6841455815d099293e8aeb485c4bc79188674db8f080e406f3a773a3e2fe2715e9cf82034cab3e89545dd386e3f3cc0f833ff23419273a7bc46cb96267c047081f6fe664b2c11e6ba583097f45e99ee46df0fb263454facfbf1a6e55c8db260f28f298b9e14b7a58444ef909ec7b6594b413d6975c39de05e5931d60ee6af4042f40b557aa422e1c2f1841a5a5938972c41db0107ca2d17d0755a813ce7746d248ef84ea91b3dce70d125de50c3545bbfaed5421b6d3f328730593a49198a79088ea68ae6c207f96192c895c12971a2dc21936506ce4606d47477fa0a721c4ed9a767712bee24622668026ceff61ba05543d54e69822f0a11c134d4435ff5c0c4321d01b1f5584a06b91722eba116b140acea0997ae6e3b8232b931a5c8ab1e4b9c99905547e0f8b92b9c73c99edeadd34313d93838555fab19edad7e51bbe64df12bf9ecd5e1d3d8be49f6411352e12c7c6bb5188186f19a2a7898115c067ade5c350058e182dea8f071d54c39f1e5d2484871fc93b10ce7773ea1727bd541dc11a33b92eff9c3a9a790c95eff8ac027b782a0823ac6ef26f374b7a526e43262af2e40b44f706f52457db5f60a6122c69dc0cd259caf07157c1893f5eb364ac5b5dd0228416dee5bc37f9889a970ec6cf76b75fcbd0e6b83f30493999c21433209166af5419d87a4de7d7149dcf71324d7dcf7bc7dd4ee47dccdd5ff76be7b76e4a9809f86470fcc032b2a63c7fb8686190f9d5ebfd44af7cd644cb860439402abde173dbc53afb523a9b5bb9e862ee7d36a3e012657271d350f36c19196a91c705c89c22ab23d3cb2f2ed1e1854f08ce8dda5f50a051ec4940813c7152121b187cb36fd21f915fbf50925f815f9453799cbec5b93638bfba371786a106f1baafa9cecc4912a825543e09acf46b5f5e0377d98cd876ebc52d93eeb6251a7d3926968919df92a36c483e10cbed2218106cb6898158a98c1f11490dcbef5412ebf20b83a5418a7d747042b9304a4e377cfb9000d72a3413f63edccecec33133f353758f39af86c26705b64cb12da7da3670100e05d6c186c378d54c706139eed3e3f50534de20c68ed427495ca4b5342a629e22a314337b20a2177ca33eaca858412a0565c5dad1d5b3570598a6a86a11f2d2883d6a4b020fae5c9a73162f1b60eab9792d4bf50b0ff91b60ed5ed4ac9fd356a9e23f13433920370ff76bea98ebf3987e7c0153c5211a9a243db8399e8fb4c60356bb6a265b42e6715e74539d2b3a914e9399743b3112b9451405dba8216d95fe8f90465bd3ef9a8ad9ea4a9c08b370f396cce5e0fd9260249a6ac6cca0c1bc448139fe48c8ed335b4daeb08219dd621c7a70f9cbabd5f5e9645c51033bc90eb56242655a0b49fca5942ccd6082f1619416412a93dfcab5c9427779e200cb2355da16b45c0507b5e7d7ddb6007f871e295060c06fa8c0d7ac4fdea35a12142ba046efc7b64e04c9c10aff78ddeaee35856eb5b9df4149743241c46757de8f5e298bcfcebac3d96d0626d6eb94d6eaf9555a4900a33044bed4c7d83f288d0fd0217a241f2d239a3409f964e34a19875c4c9f0803e9e0c7ec9bac8d23522992f8cdacd462661aed892988679cfd59fa9179fe25287133bdac5667cb00d3132df2f00c37f49044c7624eae6d54fdbe685622132a66a64dbf0249d7f5be287489ba445a43e37f2ef35ae56d3d8057debc14c38f8c210372b44aa984a37fe4bd2111bd54954b134264780244fcbe89dcefc24b20bbf8d1b45ba8008716d1014d5626d5a04b5c569e779b690e3c0cc8971ec8df51495facc978b7bd77a69984f203e91506ac89aa2c34366b6d0a6ffad30bb9e7704cd79bdf12549b1443015b4ee3772737c68653857122098e50a0c050eeb214a385d3705dc7fcc26c32bbfa1b0893a97282c6a171d8b7df55465dbd7d8e98f4ad22e80262ac03f6e712efa4b109c6b4749b7ad6a2e2ca32c0a119674f900ea12c271fa78082e570d133d793cc954cfa835fd7aa8b6a32f77fbf2a5aae36c2f4ebe3a3a508dcda2c7fdf9e45bc2355ca1788b8212e50145074cf0dbd7dee46df988b369c293bdf7624fb0071c361746072782a5ae9ad09dbbae048b951745c5e347f440cbff573eb0367e5a00a6b9b4c998596a5474803d3bf587650f6fcc238f7770185d53830f98ad0f8ae6b91999260f9054c7fed03958920e5c8e05c8aaba767f1992b1214aefc545be8b2b4be8288c19d96b884c8c30c25958e53a44557ad11c47b655262f85171c8e9ae6dcedbf352028efb8465a523b6e4b99bb9b0d019677051b9fa02aeed8b6ae7040ba1d99ca5b04edef16d8245ed9fb4b3adc46c67acc8464fa96b670630149e617ef80901eefde3d8f2f2ca6f8c6113df3d294231bd27b913275b7cbb9dff9a38b9de552fd26b68d886e1036b6bb25a5e65da6cbe5ba33071926abb7b79fe18a21a7db9c76c194cce72d91da311c91c8155a1dca8b40dfc150a9ccc21246d1cc4c83c4fa1d1aa20eacea76820d6a96fb564faea8bee5cf5747adce9edc7642655ccd4db1b39c40b7ce85494392cdf4ba699a2a0449a965fd23386b2d67c15280dab3f7480605fd1910cab002d0f1bd3bf459884d666b1a950719c0bf50a2948d216ddddc06783fcf451dcf90ec1ac668b4febaf003a828e7a2b7eba8b1036aee819533556650d284f3d9d1a38377229b44bd9ecdef1d4162b97ce860f0339c49029be1a091743cf926fffd3fc800d136f7ec3f2bffd964b36abfcb724d6be0b60ff7bf1a89c492462244827283c847deb4b7c7d102fbf6ae2cdbeb202b3630e8d73fa7556ee6520171b57407c98544b943d0ee9bfe9b43b286f884fe858d2ad2081898b6cd622df57a3a157c2f9b73be86e3c192870f2e74cbab538a71d81a78c406cdcea1605eae4a2d5e393358fc43773560bd5d706debd5d99fa02a98bae1f0760abbc2d81edf8724d41e8e19b8b7c07f5e92c032393c19507c5a2d2dc6807133ffcc7c7d5ac9a12931485960db92107fc3e525c634b6db97f1b5b7dd74a64af6cf617409c90e9ef526f87d7c603598bc3b430406161248186b2af1cc9bb134289562887c6ad41b209ead96fa443e939d6dfcfcf3d9834de6e03bdacadaa230b1943598e7004f12b1e866f6febfb8e5238611c6824ac6c8370f3c09ce61a28547e939e8d38a1800e3a3a420efcb760cc4d7de487380fafcd0a4a0fb120fca7e118af33919fece1d4bd0460ad6a5afadf2bc21c03e9a801b5222d5a8e0504065ce8f5275a7152f425e02da09ed063060","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
