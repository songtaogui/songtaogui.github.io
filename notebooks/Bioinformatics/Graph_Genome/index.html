<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24525cab90e14307003e71e9a05a7d686d6f02369420834acd8d9bf8e5fb63dc4723465491871af02a5a169aada51fa9c7f910d2d4d0393f0c027705c5f847cf8a280ca148802fe3b913d3f99ae6409de3ff7c81379e1f5c752ef08dfb5683310ba4bb0b08289b036af22c1265f28aba45988b2fc2c9126bf5306653d4119b71ad4b3de0b85f8d2d11f7377de859b6e29778db75f70919fe8cdc0b8ad83e141c8f5b011b1d3f944335ebdcd2f9653a45c89b2d75bb4965b7da4eeae4627b9145408374b68f7b8c381e34f12b9b764c6e38dd893a755ed4f447d43004e090ea2598cd6519a2f4916996371bb2dfb983fee0b591de12b58d1d4086d9fb8123772d666f8943321f5741e8151e09bba6a746b8edc5e5ab512e4cd10ced0ade97113fa77a62bf3d6ddb2949dcf660ecb6e62981ce52b8d4296d74da892fb3f5545f1d29da2e3784106fb0b4506525520140709acbe04d317a7021fa7a4212deb634332b7857777624ca7610a344c50ba15e25cba190c5d39b040b9704468c29248a0472e3ba354f23f6b68eac27fa2206dfad2524db1d068a47a90e52744d11b40c5a98b81ae2ff8251e3694df36eb3b2eb33baa77d65aeffa4504bdafe0a73dcc21b4155d9bed7ebd1cbd80d348c3d825f2a5e5fc7d986935dd6941cc1f548b90a9088749a12086d78c4aa9d0b40d840138d13953c7235f6198f3a1ccf1e146856bbd5758acc9fde778115f464dcc093c13154b188953c949e9d116de776ecb2da77e556a5a5650060fa594aad1b75da0669ad198fc5b30af8af48394aa1c3e5599564f29e1828205ae5c9a1b6f800fcc8b501e875041139269b66a0b0cbd682ada9c002ab94004e6a08a57df0d6de021961b5563543c03857d0ee280237d2b8be4697efe449c89a99940db1911fc4d4c0b62e55edbf3b1479c8ceec3de273aca57677021c40121491b996d44cde9359abfdc7854b5e742fdfe7d602acc672fb53c9ac9516fa30922d9a9667e8c329c819d7d7f2b1997d9bde92291673095bed123d2e907720e266dd5c90395b73ebb45502c60939759512c0ebeb79c0b7c420ec046512af808f33c691149c7ab7d3561b4aec3e69b4f2932f351a72792e211d3645d0041b344af3a86f84b8ced363f5389321d2c2b7877614fcb15812fc40f076b5f8970b50899de5a0a3c475ccc6b41ba405d6713cfd11be9db155564b22d79a447d3db1c9d8375fdb11a6325218c9a2f693926541742c335682463022a332e17d38b7ad883d23d0fd91ad91cf8be70d907c80ff78a2672570852e67e2f64346184c9ed4d22052a5346a1dd89d473af8611f403a630cc0c1a86b99a47f02f44ddca4d273c97d6048f3b6510bb95e639ee0be664bb54adcf5362d7f37819abd3da37767bc43795e39c09714c75525e22e6550351ee5285dc5f0640942bdf1245789f65ec4cbfa177e07f6550a8256aec9599cd38d92295ce31eefe96378c6d3e59cfa4d2db9dcbb955db683b0fc2eb09b8a80aa71e0ff34f42343b3e80a91522e1d697226d5261a61e538fbed6f1635a197abb41a4bceb46d00cd34663c5ca4c43175c2120cce7a032041cc4ca898c21ab567e1545eeb4791a0f5ca8bad9c4eeb39d7cfec074d216f46210f8a29c7883d94177ca4cee73ab423ebc7880e3ab8dcfac89c2585c029a468e17c5d2c51cede325e37f9f3ea6fff04d3ed786484ed8c9d86453009dde652a2463d385bec2df67e0765a337ebd6cb953c3cecd4f40e1c645f0716c165b74ceeaf73ac42c559d4616b89b3f6bbb20f03dd08eeb971f01e981202514a630cbe36d318170b0f5d96e8241520d99cee87597921501e6c4e10815c9dd958251d54cabf650a6cc6a1d342d58776bcb3498f2eadbaf5d7264cbf3fa6ab95561c7be8293d3ac19f0454a5dc5a53054bdfc74b3387b384eb100e646ad13c255add97017e7018b4b973c8316566c5fc8d9633d5546c76cc5672662a2b111dd71e717c6beb872e3a811a8f7707825e1490cffc827eee91bc33ae94f357a17d59931d8e12ab58c3c887cfdef01d79704f5c0402b27dde8ae622bf2a0afc39c29c495c57687e847fe5076419a13f0e8bc6b38952726fbcccaa0326c88f306915c8088fde123da252899bef118f177e83dd43abeba6ab0c8c6fa58714684ae01c1738b5111a41740c90ec7d8b71d4cccb985e5d88ccdeba17fbcef018b4336fa75c4ddd18193071dd9829afc8d57505fa3b5e83ee133057b05bcc522b06d2af60bc91694eb700115acf527a5bb82cee27e30e19dab3c940e25bf3f080544d952bce4bcfe2c815ca6015bd38da384b6e9cb07b7ede1321de44e2cd35f7d8d6d9e294ae86ed9744709e4d150fe350502d0423904a7739d96b4b24e8e36d44697ccb3e7d4fbf93720c622c7f2973d1ed9e3a5d365c05c0674c6e6e207f016f75a3552e7afa6e8839b89930f54494d3eb1a76b27ac5f14e48f9c86d04b5f2eba7180dd347e1717815aee0f5022459023dd3710fa5931df30ad7e1d2e149f57120deff3c71bb41035556010b73560a30e45ff0f693dbee65ff92bd05a736ff44cb0111a79f4087639b48f4387e326e96433e4097a631e1fed1b4ca7dbe0725a1322817c8208d897416a0a6ec88fb47f242202e51f47c425a2d2b56ec7bdcdcaf82a15760f0910d13085e0dc7468521932df29485f602554ffe52dbfaeca3c65462b6425bd5aed188e49d65e9c99650c33243908045bbbe918ac52afab9edbbeed620c5c75678530e83482d3fcdbd1367445a49ab97d5e011f78c133882143d448466eb3363fae75f475c629d33107d2972061ba00aed10a9a6ce49987f2b4e569f29d81a4ddaec6400f53a2f14ed6cb1fa4fef9b127f46a718dad8ddbd2e7014bf0f5f8fbba91506bd78ba2c6b00c5f7c0c0a851d866c3b05d30fabefede8bb326712b3cde65934d355f1429faaaf822512767068ec65d37ca887f72ff2990e8d51ddf6b3c46dd75d204a551dbae885a6eb3cf70329bb084c3d6ee39e82322b4816feec0b18a63e81e2280b89dfe4b63f6d3902cad7b772987420e23e55b466456f8f4ec6b9ceffd929d10c6758d6b6ab7e819bc5e4836f1160ba6f3d171847b6fa4955bb98fd3602636627d9b68ca585779d06a680bb083a0b86a7dcb0a1d0e800098b6f1e9cc8a5987ac67f36000d47d6a1ec38bf3f17d4c2e43d4193e1b5ceea4d05cc02e0d89cb5e2929774df318b0244aa9a3e81f5856c3e1baac92c9995f494624ee96c1acb0b4a362a1ca144720cfcb8aa2296c1d9229b7e60c298ba6a014ad91a4923a70c8f7ca89c6a4babb958236a2c4268debe981350d4255e7268866e89e4417c369526d0bbbf6a4533877a25560abfa8e7c8e3180ffe5ba8702fe87ae9d0eed45741d0f2861637ebf316f77fe3f9b3da741813b6e1280f80de90076bdfba196f5a2768be7597354ed8b873b113775fda2b4813fc8fbd5830afe370130a4a720cd5a8eb82191161bd3f45577391c6159f8d871a9c87d1e76891ba340731d25f9578a73032083a5e2cb7f34b65e5692d46aa365f85d158d40f36c0df6729f58342d2bcf829776d4f9e59f3a7cab0a2c64efeac709376787f2ff9ba79b32de25394ee59a5ce87b3f56eeeca404c31e5ad986c4313577c7bb87b554844b64834492cf9d33b9cb75c5ffcd63f0db21a3e9749be9b81602b18189e2efaa423c6248508770d30ca3f6e0006e0843155dc7c7fbab8fb6d03778a6aa6d8a59f5dda26e6bf400adc65fb77466e40463c5975a9602670a8a35cdaafa94bcec0c35eb29c1af3bc2a234b778c1659dc6a3bbca0cb4a36662f6fe9d3a3277d746084de018f36991b57e135ffed0b82e364879f4baa763ac82c5040b96a03292288f749a4614e6c2fc809c648c7e2002aa2437b6b96bc7bd431fe03209eff0349878d0d9cefecba666fab23df759c7ed1b5c66004cffa7ee1a47cd0b0aadbe1907c49bbf6b4749c2b55e39169de1fe70401c48693d708af733cf33df0321d954be25580e63022f4c484455391325ce92140d1bf6fe4ef83fdad742a054e0ee8b98b100facd8b9a8a8f2299ad8c26030ee72e2a3f21670e0f1f8544bf62120de041d1c210050a093dc025f0a670ed40b13f22f95d0deabea8b189fc09820f552e28b03e29236e7487aa7df305495d84c0c64dc5461dd3a662b2d1fb1aac0513e6c11fb6e1684c77fa4332af86ae9067086b94516ed622bdfc6c600ae9a87d0ef7c4fae1528181ce94eddbb19998192a065af51506d3abfb1c0f9b627e0090b758801a0b90b537d82c5a56580c39b8ef602cf8eabe1a2d9edbdec986050d3999628c996910743ab71baba2ce8da0c5780888e5f0629fccaf05872dba73987b16ed11242bb0da693a2e44fadc9f5dca9e518952381fb4a0196b61f53dfa976eeb12e46313aaaea8091bbefa948978bc3a97ad9620d48e9f14a101dfd11fb394a1aa71d6a769b9c5a358e6e9912c8056add8ca87c487ae3b1230b25ef7efccb021402b81a0c5cb0eab63e557315cfbca2dadb7466987e3b3375dcc23b5c2309d080ba84ef705cf8213e761726ce5cbc7f481d815e3e6a034cc58b1f152c50bfb16382f68a4e4daa27b7a32f8cb620ccb0a557c453a5882b27da962cb1a65416c0b46f3072ef3e3d8beb8e5f3d1ffa1290f1e0af3dc4ba5e02aef1e8bcb6e01e3f1e7b1839aa7640178c6d879c1ff065553e44c16e75c50c6c9765a6afe8abdfc7ea78c88283d9f9599513daad646ad837043a0d6e755d41e49af05b45a70de5b547edcbf61837c917ffc63c599b98e4297fdf083c1e5363fcfc0fb3e28ec28d495f7c4f35109f69a5f137bc96b036b9681b2eed138a8dbc1941d24f8d4010dfacdd1c351f463a5b18b55254c730e614cd26820c05ade8b7226d6553d8894c3e36c218b7fb256be2e0321df7026b8e1a2ed7c1d42c674461df8e62288e35c636f1d78b96032dc932b98039c23df3573b5aa469fc3d770156291859239ee62ad33500eba84eec0b0ac5c56385d27e84089022da726c5a95cc20c6787f2609f6bf9cbeaddef1e4e9c0ae0479a666968a07ea8c347b3e58299264d53828af3d21ed5500a8f2e282499ae62939a1e49638e48e9291c40cabfe4de09041c0673f3c9e9a7453482d2fd78a90a2c8e5e83569a2f17510d6f94beecf8aee1b8a6efe1f6a9fbcc8a30fb5a7a8f48ae1b219d55305d0ca85afa8412c8865604e38e8724936f2b26c704bb250efbef8b5c35c818d34f0c3c902b69386a172f5a6c1d68299f54c934bfbeb28c48d035d718f7ec5f10a3d476f5458f27d4b7cf54677615f3b48c775aef43d4f66f565230563bf22b020d7a6d374659afab32ae552d1990a69b5ccf41050da1d4f9bc5a2d3ddf68d81e9485c789638bd61e48cb8990b80c04840f6c4ac79964d8a710eca1eabec60ab237b0516d643fdc13482f6d22edabb0835d58602abb402f9030a8542f22c1429f8a68fe401b6098c72d62817c9c4bf9bc00e051b34717b1bdf515aeacfd93683dddb33e661ab06a459cd74e5ac51fbbf89e28b1c61c53fda91bcf691ea7f1ff49f0171ebe66f7e54b9a59a6aafa61b6f29f7fb7a13a316a6d754a503901200aaf9b0182566638f06009e1ee6355ab4e34e7fdda433c16729a8120d909297cdfadd482eeb4b3dec82d55daa2fbf130cccf241dbd4e887fe683fe1e40b3757c99443ac3adf12e1d00828e6495b8443928ccfd83919515cb927c08521402ab3d6e5f8e7a952100c4302286f788554209ef793cd06255faebdb9518672c06a75f154d9bae76f5cce142da6786b7a7886d3f0984452046c926266736c6fc5ad1626b949d74929b34a2adb9aaa79353ea4c328332ed1c05162d7514337f1b01ea81adcf4b09854cff92690f6d446ca5a9f312e570373dac51110ed7e02b9a35c86e7f07f42101928f1cd6369ff27b7045d1fbb17ff67cb6ff942d1f6189fcb55600f4cbcc12d66f0adecc4215aad981864a6583b36f0bd2b5d909a1f052858bce4ec95eff8f0aec9e340f486b77c0d972934152c1aced73aaa5580f3533a9341f152b1a33b18b934c7cc51235594f2cb926f11ddd086ff6a741975132485307c04fffa5d06cf53fd84c12b50728b67aefe6ff09d15d84dc8f600d2e96fa1fdea61744b7959172eb0b944236eab9647138a688a5f16f1e1a80529f0716dd5f96a2c846c27e801b20eb02cc9a0a60c73132081c95604bc20e2542fa719aa478d4c42aa8ec9677560a90c36a656a2ce532bd7d608fbd1f91c5a26229681b75544e8c03c9f55b942a1d09e73a4f1ef3f040ed0ceba7e745f4987ee654163ceaa88e797648ef641843915306bfc2c65600b2f9054a068f689c82284c428ff370439b4fd40b3a06842f678692a14532c0cb387d3ae01cb1f41028feb70c33aca7e51511992d2698d00c16b578b70f30d984f18da26b234acf74aca7d8694ec514c0e3a161916614c22bf65c845161f3a99601a4aed1d4c3d08fcbcf22f1036d455d35f3e8357f28709d134eac941d0ebf65cc4c275fcd877662ac71598a4fc2cba865edccba6f210a8debcc33a0e08084d0093db4c4d0df999202ebf0830b1cda6e9a06c207ab8ed8f56477f1f3b005ec1ff8ff4a526683428fd0d70e9d95ae5ea26e73be8235ec325d4c03ec441b639c169373bfa04c0d2ca02a8f92f598565873312f8bf411b5f735b2b46f28f49d2f0c6112496bc7113326243841e60d8f7e1a9428dcea3876021a2ed4871e4544b0c7ad0afba566a71b7fba66f4b9fc657b46bc9a7b9b05356ebb0ecb1d7c86590914da69ef59a90cfedfc14f978efd83dc08ba4a37c536b088c0425a585466159124dd1a9aa8f19fae182282d777e147d195cc1ab5629baf02826f0eb445dc59eb0314a2c2ea74baa86ea0ecb7e13d6aeec85887dcf56154ba63ebebac373fecdc0801ce3c771058449f446e6254a41d9cdd3f15d72f21d3b0a9aad12bcd0dd28455f93f2158cd5bf91efd363314324f9032a45a87dcbbcc2ab07fb9ef78d6ab36f5098cf527f4d01a55f54ed5c2c193a43b592de815ba298ebb60c12a9e8f3ca5bff02f0fee4e302f8d9e334c2d731194ff1dd69fc2b6d949a2ff73a8bce11d68a2126f373e327fe4c27152c612653151052029d9b45fab74d8010c80ee04c20256ed0aea1ad87638a402ea036d69ea237bbe0bdbea52d7fe273ad61dee4b0e6b144adeda892e975e1cfeec74ba4e13081aa829e274c9f0bbef791b1539d5cb8f9ed9d05f308c7f457e41b7cc3565ed119de0c12660e671f1ac855c19418bbe6719963ba026e0df810c7d0f6ea449e771f40a990c70e93e4f8fec608e36af06bb9a89e76a4607bb7fc6d114ead747dfe6565c288adc354fe902869d673a37d12a125649083d446bdb15577bf47224c8a7fe387bf2d9ccc0a860d830ecb2abf6b2585a8c39ae4b001ccfbe4268160a713876689a6f35f2e36e377391ddf3eb286cf69f78bfaf860f7cc6851c9b6c44ae04e361bc8bd3a906d68fee2e327af2ed44c4304d7ee57184f9c4ef4b3b160af426c552b49530acd83e7fde21f1d4955df7c523f8aa1051c932e6e63a458878cc7f2814f22f0d1485dd44c0bb687986b8a98b8b2345df604d6300cda746bb22f6039fd3314adc9e1bbed87885afbb2a1fd2a0a1dd72bb69a46ec2f7a012c2f8b93728110977088abe53cca67ee9bedf3663c27f1a1a0f2a5e57d0ba4146b61752fbaf0ad2914e5eef97db0339dad11499178adba53eea1823be2bbd7bea803eb44ac917722680b811d334497bd05ed5ffd34f1724aa263520d091c52d8787998a8ef55b9f769d5c6e4b6f8d8edf4fca286b11c1afd2aa2b87bb2f84a12b15788dbe4913510ec564f5a3e99daa5ed97d53df6654e9657a5bc101d2016f743f36a22b98a1173be4fc4b7959242dd9571496bba320cc1f3e9d066019deb9c8c17127fbadd517e2e3c31c34944634cfd8daa2ebb9bb81712c12c40b6d10a1b1b933a1dd170d05e1d09a35d86194d81f5dd09eeac26d38f06be430b9f8886cbe383c0cd00426b47b68e9c9986d041208233f472ac91841d6408faf64421f3d1410277541c8fa49d67a94a7d34300c62a7c6c28741d3e232eb3ff8b8c707e43fa74c07b87733002e3fc7c043f82c995e35497e4395f2bf0b0aa569a9b9b6dc574b479d80bf0c9e97d929b17393a115ed217627ade34ade3f8bfa966e67a8035e4ce2900fd11f95b45234fb80b5f9fc53248d99487fc3be6d7674825598775bf33bd7235650cbea3742a517c89dfa41854d7f874fff2813dde24ed1041413b69500d6b1191a73d8258a1f8349238c13e8d261da9fceb22e08d4952267baae6eec3a29b70fb499d6bd9508971d10fb7b1897e245f9af55d9ae5e9d8fe9f15ccb0cea77a64c7499451040a43698a45d7aa5c683dd75257bcad24361c705a79a67772e95305f67a519429b7014de3d98369df2b71c6f7a5ebc05b4ac57911a0453cd67b5394d50bf4a98a012f16037f3de7206cf0e442d6fb508cad4c68f72120aa7c04fe53261c0b02245768adbec45058032f445271130666eecb5a41aa57b1f9082e2a174d6b084405e37a6cc3be9f9da481d226189e74f98fddca309b6acc8e1c3a77980d9f0b3f58c300308e3fcc74c0af67bde9c011e3cc1419f23c546121fc745c05ce9e2192496519b63373f2ff6abbd97f7345024b6b58482b1c19c2217ea57dd1a284da4c97d67116e2ed41bb4002b5c2decfa4d90d9a25e11731f1d279d8e4bcdd3a35433b990686d7ed47d39950d2ed3c0e9532fcb24da1d85c67393b8a6db8fda000780c77a55df8c3d3eb3921dc83cb3575fc2cfdfcbfd6c00b5c9ba5eb917be0fa63206c5ca9cd9f3d43ed0c544d6becee7dffee1addf28f04cab9f897439873218f76e1a54eea0c913567b132e31dad94682d869d1d0921f45900ce5db1d3ad6a28c4735ea66a4a17c04e6f1577a27a75c8190db8c28c896730ae8ce5930257a8651385c4342bc54bb8e86a9391fed442576926517a71ec2795854b967062701db055f7b0629c7a198820850dcd69ed443bd49c83ddd3c0143c8df8d8813dcff17eb2372440cd4a4db54c7d4ca17296418228410bafff0a1c81e17f70557ae712494c0c25d715207300b9363ca3ad5001e75c19f3279725bb924a855c263d1d47796a4b51b74ebd9a8ca0d77a3bb72755539417b4b0251142fcd015c02e8ff542335be87ea4134638449ee4f5b61f5f35b5cd4bab58a09c1af88e3ca30d485b96bbf19fad5d8bd335ec867f492c7e3f0b6183ce7683ab978782cf3b0393e25954bebd70f53a0fb93860a2987556d3175335b3d351166f0970070eb27ab43109b74bfee8301444e3fe169be740d45dbc756a7d3199975c9215f0ab7cc8c230f9588be5601e3c8f0e81815483ff66bd90501b11919b41689ee6471c0e8069c020b585009c15e1e2cef80405117511fbee5c5f8c07051dcb669aa1e739885d607c52f064be8e0e264c93ea17d99b9dc6060722adab17c7a44c612084be16ef7d604fd460809e2b78a984cf2ab375c71413fe434f09f33acf91706ea641f15eac381800da464aafa4307f358e3f81b564345ed893f883a42b27cba70df430d6ccd62eb1355202868cb740130af3ed59bfa915495adef59b8e789ab90da32622adf7c1b964514ad64ef24531af1c331932cffaa5e0d3c9c0124ded344886c44507e052910cb66b04312b47325c0643ed7c415a8f20f28073fbdd20875b58255726b8aaf7ac08efbabbb2e29442cac288389a0029fbb0c242595ae80105ba3a3577240377c80c09129340f2b10992b5dfa0e71b2492c86adf0df730a10f43e14749a70eaac24779afa01fffca8691c4e831c4b5b9668177a10a5ba98bff40ce393c67d14870b00588cf8839207f43fb7070b9a8a65dd30d959aabb350dc84e829b4dc7863e1c093b80311502f0c3d20510f2cd1aca5c0b395bbd133df626b3b048b872cb5d66a4b9d9f5b9791575f6966a408e625a6b50ca9f684e152e58d40b563cda3f7f33082fead41eb0c052e76dba7e92e13b1cbd57d2695bedabab8098c7f1d82480941c33f5a8776f3761e08c8b23886ed74029d01d5e74bad03ba7979abeb332d9f8c251c8f9b750959f859a3ee1318f57d430c4e1f5d8c57f288d8f4c5509b6b50069e26074f28c3a8e70ed3a467344ba69b8475452c335fe0d0095ef05621a30251fdccda06ac7b81fe54c61eba75db774f2b44e1c6b66e88f913232b58e15a98967f0955ffab8a976a80c7b033b802d02f85b8043905f3b9d2dcc7e9d530a4bce4910a7a8eac05940a02e4fc4d98ca88cbf92a3d91fe96c4fc13d214a882c40ef85d4312516630c4995301f1cac8db7d666352bbc5750b801fbc59c7fc366a9cabbc0b76f395e886afe4ad0c8c12c0bc8e8ab6ac9308d56b364a0930cc93d0e4c721eaec009029fdef7d03af1d1b1c5ce3e9b53c5f6d13308355fe936afc8293388ae19d64fdc1c4793772c26b70195d328b9ed276188591e874ebc4a5c919cfc0465995721505ec6d441c858cf3e4da3e02c75ee45ee44532123cad5b692f42c0999af34c108b5215fa3fd229a1f2822c26d77868b821a9f7c5c2aa644e8a300ca7e2fca0c7002dd08d781d794d37045d1f68e85806802f137342790de196ab4055db6a1446e75bbc86208c505e121461b44416aba0bb3b246335871c33e541b0aa29de346d6264687bed24c75e36a53f06edf29fb70802e569a44abcbce3dec2fec935cd6f2b8ad5732978856d2164a23b4720bbb80075efdd6728befe0e65e36fd598078bcc1193b5c8a96737e85f154bc4872bd8fe13ec23705480040dd8d0916864919653657ce508f2e4e5b72951a935796fe37e0b183be03b7211e9a06e5298d44ba8812ab200521297e243da7d5b17658dbf0e3970161e1bbd6438f761ee434985f1e480dee3c2522d371a909c53d1263232dff19cb40369632a2ecd8d98b844b958821f622ba715ad7814f8d78735a16d0a5b1939f28e9ea47c5364ae4a2e0a84711b63f8e46a38dd38983a42c200bfac40fdc097eebcab00804175c3739bb7f6434f1a9d4f7a075f0fee4f6659bcc1a56607eaad12952b175b2b50410911d0c96a971b03d40945498d20f56693d9390764aacf4140eb556dc01709dbd6597aab5aad8b87c9c40fe6e2eb51b05c8ed2b95cba78dd128875ee8f11abc4cdefd6f2886694854e164d5a0db8583cb0667fcfa5f729b9b1a34972a917f38aedcc883f8279d4e32f269aeb7b808367ebddbad09179fef3302d4d237b743f8a63418e1be8cf2ad29af1fef0a0e0ad5b5fd886e39729b2c62909d4afeb4fbf4416c6cc4a6b5d16b1e8d5a8d671f6b77531fa0b70cdd22b75a90b947ba82d7c9dd4d29a1a888b0cea0f5697474e827a6848a9ccf6dd46c43a831a876e93c16c49b0b5bf37a89af46f88f0d124ae97a53cadf653dae70bf455a83daeaa5e07c5dfdcd960f714f40c46ac7854666e25e49b9a78460d57531a3a00e193cb37bb24a451b7e08e662dd15cbebf6af7a6fa7eafac029ce817a3c4b403a4f1b3f4b813136619f451936d2bc12b94a60e3a52b2e21235b675450684a81bced09ae0475ee06db443f5b1b8e81fa82b00b5052f261d96b5d3157fdc40adf242698fef7cffaaed1d20648a085109585f19656249cc233f1d2396ea5eede898b9f6f70395b6756e82fb36a2f988ad1e6876993edfd51f4dfa927b41f95a827c1df63a412a5c3b798638627be5e2d5b36be58bfe1639f080109d6da7443edcba246d976af4ed88de0a404aaf0a83c5ab37b1086df9a10f604972f18aeec54c139929f79943c6585fb67128a552416c53b8772cfc6035fdad4f74ace06df4bb45f61b2d62f5ec7f52957690618c627f4ac9cb681ed9491e0a5792f7022a14a27953f36dd833e85427366e09e90f771a26486e33fc9e4489ad72a3ee125823f51de3596a2229bd78732c813ab48cf61b13d76b5da87e6a10db718a941a8f474308e34da486785d516c3f368e39087d08c6484a6e234b27545bed6887d302ac8f5fb1ba57c81e9c05f79e892d4d679fb27ab3538bc848e2c16b25229d84cc2c90f58b125e0165e4bd1887878bd7e91907820481dece1dcf58bcae79a2285f104309c07f6507856d9a46b92844226a3606e4ea57cd3746380d9928ccb0348488efd05ce6285c8ca1fa1d0b96da568b18503814b3650b5a943b61f27e601edaa5db1378d7ba1f84f3e25139e29182776968fe6d6e21190e455b9043f99da879d1e28f49de6c1bd6fbbc87aae3994d44bb09843966bed2053680981103f2adaf6d1934592ceb9b2ff365e0e3588696cd47be664b69b85fa23644587508394faeda39c2d35347b78f8e0e7594badb189b5addc0bc9ac8d778cc4093a9b2415e61c8db764bf345aa6e13e826a19447c7eba9a361ec0a61f80a89c27f38874b78e2930eceb9b0b95b2ed6141bce83ad87416bbc47823cb71be497b6b746bef610ac353ae3e19d7af473672b01e6c8d7340a7c50fa1a25d26386acffa9ffabecac1267569a74292160524a0acd80cfb79214ca07d7afb5b474d4a213b674e45fa688c15a86bdc44243037b694fb23c9c659550fd0856d47d3ac29678d5a6f1183e4fb09f976257671b65349611e633aa2340d410dddecf46cfe776adf9db71cae87823dcb9f4b86ba66d53554620b96da4d312cc1f2011272a615949b0a0991aa73babbf3016a553eefdd9c07c954fb40c8e4b8a02f23ab3db67af89c9ac18df5b3df8c3d87f1b6a559fddd149db3451d30c2ad747bf3d6e58afa53dac668e451260c8b32af0e5d7d13b22a81738d1537efc54bfc7a6fe475de844dd1c563dad0f95270576168540f58ee434aac78ad9ab704bc2bb408ab9495abb7f7c4b63373e0c05af2dc8faef61f13fffb134309ff099f6d3259d924340ad58770810130ed3fedb3cd00ef4d3bc98e29bbde6fae1a6ece9581fc0b16253aea1509297027f28c20ed0976b247332d8956d9a8e7c3b3ecb2c547cde7b15193a7df9a882bf97dd623e0a19e3316f5db2340cf6075eade516ef921427792451da904320cf14cb0a250b0cd45954f048b87b6a819ce1eb876b6e00f169ca9fc2f7b2bb45d6054af26dc0a2ea3a7eadc1803f781652b567174ad1eff0c86a6b58f7845caea49b5de97e61337833fa7d028b23e14d757247599d6772f17c7cb56add5a8c30e8ee4cd7bab70fd7933faa95f03aa906e8c6d3d8685971c219f1a6379a5286fb49f5a9b6985a4c2e68555f6c71c652af29480f9e673b5ff7e7481164476699b2bb7b0de48b6665c9fee4f3372de78f74a6863c334db7eb3910a7447ddcd9db2e13d68cf2c34c7faf4f2ad82010f159a3c6029451808fe4d40cd248d258dc71a465d34cbe2c6eff54f9392a3b0a0b5e02cca8b1253ad31cc276fe417e8429b8e75a4a03712f1658c27216712de894843465bdedb43bbc4b68c801a6d66ae3c167d9e93c33b96361a3699f1380f4b10d0841906aaa1c4f069eb2291267ce0b7f3d6196c9fa4bfc6bb6eda0cdbc62f5cc6d4fb9399f73c00d4cdb36a06c07ec5ff3dc476a4693c1bba44bd0a831ebb42dcca2d3fe612b97dc1867b100462439c5d87adb9e09fe124fd356df79ab3ac668887938cff20586e2e131cb309c21908064cbb41b53591c78260995f5c9394c49810c2f557d51ccbd99730068378c99890e7e845616cefa46e541cb7f99b383b5ed242ff359fba97b939949c663656320302ab01d9b532baebf9e18657cfe54e927727a02ee81ca0c3fc64b24d2749f960631f7acd2abd0515f4eecac597dfccb32ed6e03a160202a65f8acbd400fb02cd31ad014c6e989e0b7b3f7db5d8b8f205d15c1d243ad84cbdb994a0937818fa57783621aa8959d8a9d9af44a1accb565182a8ef91fb1787a0bbc9f089eabf95cd7c14a082261bf06ba727889d6b2c1282f69d84f8ce75a0c88f5f109cfc36ae8d86f729ceee4399f44bf3d941100ef815b1f4485f40d2c18f4a5f4671a4fe0cb2e16ed8ca229906f9182e0a9b6abee920ca7d1218045823bee51a511d4b24428589960c3503906feb5658e522f714c646913ace00de989427f817ac2ea713e3d767e970aa861b3a08495ff7f5d371cdc9df676b0e72a09ac59a1377173593b73a69778dd2b08970e3b6cb754a684a46e76915f6e674fe12b26ef693510df6c7398e140efb1a56fc072ae85c3f1383f2caca6c98e4ad4e362cb3a295ca4945e0e1a0589480b985713b07e3cc008fa4a5b8dbde8a1b911c4895f4ba941db3c4936cfffbeb96f7c1e5581d18a69a6ff2c19bfd74a2d81b93fed1f2609313caa5d00fdd80dbb8e824a8975a88176eba020c7eb3a2cb88e660dcd657906c4cc054414ed89d7fea0790b86d44544ea0e1eb846f2a19cfb991392ce01dadfa2df349717c55c3e6caeac04a04a4bcfa3350b2aa41a747ca05d2d0cb19c7359d71ef306e4bb5eb78ec8529c1499fad13673fd66fa333ba19fed23e15575d6fee8dd881f7b5f4eaa31608393ff1a3bb5c54979e186b19bf2748fab5f0901e9445da819c7eff1010ccb4746a411c0003f7ae252a5f1109824258c3dd68245108c3d963935d1dd49d5d293af4cbc78e5c6e17e04032c4747b86699f081125d8c6ce6adb554a932f66c40f086227989340c8f73156a6f6c70ee9de4b5b753c9a86e07aaa1916ac7fbc36acb4f787e87b3239788339ad47b9dfcba0f1237ad99b0436a91db71e67cb3afcb2ac5b84bf4a8cc1dfe5ebc44de01dee2ba18f605e68e9220befbeab2983465fbb0d87c89d9e2c8aef7637ea392e8c7ca9a784a2f2d09b7a09728d5b9cc46b53afe58b08cec907692fd9a8b90e0aac60ede087c00204226c34d4e73aa796ded49a35713aff2c8baa306f860924737f5c9009131b31980ceb09a3466b82d0a3a4c73f90d6d633c1d7630fae380ee5b0d019067c26a638389fbbb802e0a3ba51656927d576609b0ec40abf730b265f16d3d69f2b99cbadb75f5bc6887df0212b43fe4191030b0aaa1b742c1fb6666e32c1a3643d7e9c914ad4c39548f2f6d6ea97f3d5ad97b7c95e8800c59da57a7eb48f2dd45f9464d904f0ccd0a18e46145ca31efff87e6bf548e92baf4f072cd14dd909f2ab2ba1b452c3757c3e04bdc8f9f854f51feefbf7bf1ca22f5abe2fd81b6c24d7f00a4106e5953226e9fa08d4f23fbac55c4bed91efa52076459dd72bfa30b3652556bd3dc0ef22841ffc26742e89cf034acef9d590bcebfa87cb86602037f67a0b3e4dfb12b5af84cf52cfe0e44173adb6645cff6d6a3ff890cbdc99ce332e2f98b8110b23ebab7b265036766fd9919b3c7d0e3cc6a8a8c5f5d5a8b41053f40dd9c2412591bb510e183261175e636a1a87c4002b9f4b2c6d3a270047783a9814b821cfbc58ae90c8b0a33681f4a68257389d9b17202ff666d35c338a11d3bd8823212c882dae4b9fce31f664ef411e71c3cde1a2d0374c33a69c179c0d44b4544cf546fbca6728e90e51048bbfae56bd60bbf1560f65e1f8c39a686e5e90b10bde94d1e2183142df9ef5ecba0f90baafae460786e7bf950c1acaf210cff347198000375433c4a9424388a5571b47507e626459bde258d0e4e0e0adc5317f3df7f538460a28ffbd815a49c9677f37050496cae4f83c15d7b9ab756783c575dc2583d5a773fff75a784036fc5f95f82a56c7f900777ea0d849cd552e3d7962fbb57e8882219576e14350fd2586fe180418e6056280df23bc1e7e29d1bd23bc065a63930b38dd45835106a789fce309d3b6bf837b1eee7bc8d9b9a145ae9d89d38f9d257c1965591cce7635144af6d4c16697b04a1e8ceb6904926f3b2854d38d6105e1752ce2d198f78e347595596a497109c4b8e8944279a6890c8e2c51c3b00e56208a4610503db38d2b7ffafe602ee030d904e78e871a9cbae68a2069b84a087b212ae8f3837730bfdb9640c7fe887094309e2f0102f5a57dbb9814dfabe087b587bac15e4085625178ccbed7efa8d8671c1784e348426e810d5d1a9761eb85ecc1d65775fa1f7ce8cb8ccb87bb77a4cd898aa17ad0c52653cc7c2a64c60d4263117488ff96d9e3198a0e1cce89d04fdecc8e1f4c431efd15eb34378b7b23ff5286c733e42076250c641e668caaa265f59295590dbf0ee29a98a403b10425d1d3ccb73b74cf3574c575ebaf7189b053f01a404bb64e8666ca3bc31460650a2556cfd4799c7e73e5d40b676814c9e4f9e5a8ddb653eb9775853cd786456287c243deacc9cd9807cc0e467bd03b67b3d419426eb16e772881bc2034ee3b2672e50c603b690c11a69191fdd85fc3aea0ce967f480c4c1ab71edd6663c4cc8150a363083718b2d7b670fd87646cc390b50292071bb71ce7180bd1fbdcc1c5d763c822b8baa03f25ea3335feb7786623bb19df07c5aafbdfeda94e91097a934f4f31b057dea6472496f85acaa715f82eefd870ae7bcfca3c1b857c43d48c47c47420a64b9396d2675462ad8436e384c88a2b35e05bb8d0264d93a8c508be3a2c4c4b4586b9766868dd146a2e90a865e24448d8e8ac11b778449935c6d39b23d0936b6906ce92f35f635502ca7b8a62f454afe23dfbf78ef96543f146c1e3059e498f4168e224956629ed5f6c463814544c363f5a220d2ac42a861cacda622208c5913ff0bd6cca62625e2746a059debc89196c45b9acbe9e5ab7e69f3bb5eb23a1d57998c15fdaa5ad530eaa4c377498b36c3bc77bc03d210d58a73a59c367d0af4a42e6523aa760829d17246d6e7638822998ce82af19a388f14c45a5db9f4c9280fc81149c516526f783325c7909398e2ac1381f381660b67dadef95d9d80b80aa5867424856221ca0cf86108bd35f66a34d6fbeef1edd2b85c37361fdf568b2fd83098204fb5e425dca59cee3efbc11fef4b3a5ef699266cb98e0e10e80fbbfe7e17bd8af4f41ebe43e5693348c0b03c6987944e11a4f814cabacbded96546ef87f090f9e981926748c7be1293bd264e1ee5d42947593009b5f79587ae337bfaa9473f88a8fe9f4fcfea339e9375d481e1db631aa66d2a25c3ea2f5b5b60bfb91cabc0cd7ca863a26fcc057f8808b4377c300a10cc095ae3fd38f5085bde103b092c37454b0097a2b82c965227fe1cd2029877006b65f1da85031393fbb7f0f2b48a81488d4a292a1d31bfe01f6490b5b345c57625495ca233fe39f0c0d6a00b1f78eeaf6c33c79af0e9f3a2209ca1748950673a5a3a2b4ec196dab3f7d7cabd218107a93d5e191965add31467766e3202218c1f5584cc034ac141062addc937c9c61f139dadb15fb42a76a32e88a4c33bc4124c8d451f272e18d5f1a2cb3f4f0d5facb8111dadadc1fb9b7cd712c6537337d1e87b8f086d6332b0eb7df500c7af148fc5a03c59fc0c328650028ff29fc6f957036bc211b494e5d5618edda30ea884ec318b1642f50beec0b77e771eb48b319ea5f2494ea77e2464c9a8a68005ed76de46fc7055a60fe02e73e749b2a2254c6b90b6fc2a54942a3607a0990cbbecae95f1b9e198c66a34d2262b0e30794c180ca32f9c9814edc7d3ea5ec1bab69462365e43c6d8d848e604159114a526bf0eba4b86f66cd6b9d8a6b6b261479a28c035533277a3f710f1bfa6bcfaa2c0107ce1c06400598631805dbe17b9c47211b305e89e84a1c7753cf32e6f658db18fff3510f18ca1529cf83feaee8716f84bd418f807344d8368c1b23f2ad9300d55b09ab34c4aae17a85c85c0d68b5fb3b1294af7f47765e72eba2e1f74576ea9905d419b7ceb0d293564a99d83ed362328544697de3e1109af5f6d9e030afcac984e4e6c3008048866eb653b9b2a0ba5dbf3c3f2d01ccf4366c59b09913a5948f82a2bede588deb8511684ca869bf3ac2c8c71a859cc93c85e3b94988bb50c1ab8dd63d1ed6f09677ae3abacd2154caf6e96e56dfcc84e0bfb1e09f2a7e38a20b4766c7c4a37f7a9dfc714a69d8464ae4ebf7688efe6ab3c724fb41244bc77e1eaafaaeb00c2db7031dc66f4ed82effbe7495e75f918538be76a8f6dc2e3e3c433ddcfe26586b1f9b6112786a59a6c315f5d7ce54c0bfdb815216ec44c42b15951a9692e931f29f040c64ff7cc1f196563600cdbceccce2f368da44e1ee617528a62337f728429fca6c6b8c647156db84a5a3b5849ed3d3bcdd455fbd34f795256be58f361e084db2939c06d3cb9b6d58976fe2b1e61a24fe77a5a8049d5ee399b24a85e2249dd9cab8233faffa8f1841c62cf3a6983dc52e7693622f2e57500fa93bbaca46c01b7e06f5ca6519743db3bd8a2a4b675c540aaeb12efb9f5036e0910e2be6c0af681c954b10bd748ad0546","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
