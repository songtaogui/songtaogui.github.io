<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88d3ce7084325e333c5615a244902c9e9cff60938c81d0f3fcac562a79aaa5c6be564109a43b0048803b2c7ec31c0c21a5184111443fbe23dc74332a148f1ed9b11f8fe7ce24b6238677e744fd278ae28740546a461985b5e059ca1704121d41cdaa4eda3ced41a8767507718ce28911bb13d95dc3134edb3a3fc96b91721612f270b456d5cd641f70e39b12664c2d3a93c11586199a8f0a6ad748377d38df565d2bbd77bbfb377255a8b9b2f4ba163f7202e8e507e4f6789439686a4fb055838fdef4ecaba7e2b45c9ee0b83b6cb94024ce618ef0e3a57a334bbce3e5937c68a542800aa511ff728f3cc3cc16443ce66ce0ba2cdffff16b0b138403a5c1d0ef361ead8ff8c4f11f00fac75d311ef94b5809aa2717819cb40d1754d275b1f92dae951c7e3365806fc8e7c83ed750287062443cf2af9d11cc9b2ac9de98ce05dce32783e7631bbe40e905f32a98b73b7aca27c340484222b39e71cb8cf47911900d502c30d40622cbf7773a5c0c1cb7adc882bb0c4feaf91d4502e6c1dbf1088ab165e2b213671c03396e4a57daf1f4db0dd94818cfa960a47a460d3b6a680ce55557728f566a5e77710aabf5e44a6dbe5ca2ce43f588e33c8e01974daa0dc52a3416ff5d1054383caef9250dd1405615854ff9751675f3b35a2fdae107007007f689b5fbb758d79c1679822fd15f4e63c4e7cf1acfb20d80dfeaa28b0127f87f1c5eff568e87f4aa897f75c16a01dddb3effede8e129c88513457af276f38926cee46ce537bb22c471fa1ea4ee28d02948feb9b59abdddb0863882040c2d74f7076ca19fdf20345d86548f083d66cdf3703269603b8b97a5b0d737438412a6d5b0807934c5feb9f8b09f692f4ddbd743c37c104645a44ec6bf59e66d445d8996d1ab3c3455dabee1a314b71da6b999ed78324fc27818b2fe6d6d86727ee976fcca00d1f2a0bfa05b7f2bad2ee9ffc0d218fbe255eebd1096ea3d38f3d9a1fde9b4ebc7aef5e35e66daeb8972a0ae2e8ac01664a3f84a4319a15c177253bf0faa61071268d32c6431a02bf1718f427c58603f2eda7c09eb1f4b698f3f31e18a751ce3602c5e1fd879429dd5e6de21d5b0958680afe31d063b0d2af18d16a7ef10b854c0a844424faacc685783322df3a1182f18714ba31a205226eaf5f03e50b2d14e814c20ab69b7e178f08825196975ab89ed3b64066783e6f287d3127b5d75f317abd535b16cebca7806f1593fbc1d95235d7ef53e336e33b292031c2a24c9dd39bcd791b737bbefd525843c6b8d3ffb7ee6697377d185ffaf06e84fe088bfb05d7008afedda2be2928bcec49c40bd253a146859e955439cd83e7178f82cc30ee20d6ccce46e7ca8a65b6f54690d3fd455a4fb854678841c01212d14c1942437254c741d1caf5c49fb2e1beb879830d8dd0c28dbb30c89e93cf24ffdba9e984248ac8a9257cfc5e8dc012d1e90abba123254bc73b5ee5f18b0a71d169ce4b671616f4c4c6977e0aa60b99f651a331ce0975a607efdc5d9118425da2312744fecefdcc1ba105b93405aa483a44472a994666a6cf1226e1eacc2f97db0a4459395a63419d96d06c6f13c4cd39b6e22e2b2ea5057df97c597d8a36adc592e8fe5a67baf19f4bd142231d36b3a4ad18cb7ab883552ad212a6e966d7bbf0878d477a341376b5ed4014119ece26fdb9d39fd107ddcefeaec34a64cd2f0ef2a30ba6a8c35f020ae5ab6fa16cfbac1667b51775699e8e685cc0b911fe7396cb1b81d18bc92dc6cd04785a6e703e2fccafb88dd5510d846fc95fc98bc25479fa4421725fe9cec9637e8fe8e5895b713beb9cba51144838ca3e842fd69fb098930ee656ead21a8dde0ca310a705ad079f9d46bfb9441523e4b75b90e7f832d5f8b8694af3cf4ac6de8c8a1f24003e1275cbc71639379dd986b0a1d9d61a1c627c562b44c448a8e56d95391b97509c0cb1332ca3ea57e6969761d3d2ee99dbd75114d81be10af291812e8edd62d73fe67f248c6e6819c6a11a34ac0b51f0cb34e1bed5cc70ea1cc3fe305365f147cb8bb34f52bcdd56c10258bc1a738984e69fa7959b5370418c6b1ae7630508e5d75578214292ebae4aa6c0dc469fcaa4e655429a2b1f1a35aed36cad3f627fc04fa52349279fdb005e460debd75bdb186ac115210bda8ca90eb13d3178fb630391f6597a8864e13d808317a6e3b14949ddbf7cffb8b8b2cef9092fd588af71ffcc30a7568a5eeb7d939ee7c696384ac41b1b61132c1b69ff86bccd8c603ef428ccee9ad0dc07228bbbc046053839d2db7ef813c9bef18c09b150ea21e3eb018b204139f3fa6e8dd7741e5409ace985bae165be54c6305d14852d54e07a9ce311a96ae9be4e0028b257ae3c0bb5b1ec234b2deb1924e1ca7f15096103c55395478b4f62747d7ff84778ff931830cd45d79df38863821c66fd1d564d5f2bcc2208ea10650ab85057b5cffe0b5a08cb752b3132be2b15940dcaf9fcf41ddd6a78bec64421425a69bb2f5659ad180afc360757cb1c90519a84d1b446fafad925d7910ed2c8ef519e47c264bc65d4a3f5bd4b0b837151a239b142600cd00d7fd1e64b90bd701cba74a43c3a562929123fd0450df4a72726ae4d3c2e84e25d21285cf0e35c649d2a096b1ae9974a5791eafa977c371a6e48a62a90135790bb1de70ba3f93459b923d0178d8ba185192126d7fb734acc09eb1d0725aa43828342890de9f47458f003bc9e8ac5304bc4ad287aa068a5debeb08002c19d6fe52339b040c7ac1dac1d6ba0d393cc60a0d2351f2f3fef0c34f8efd4b32256f42a9c8a112e696526dfa2f08c2f6518e272dec5c6bfb581d4d36e32bb13be1effdd592f8d6c97b165b3850bf273548ec36f1c6ebd3a8032141622cc18d771533024711f803d7528e068c6c098a57b81f0d05c5c7c993e30bf1db87015f89fdcd7e6871d59bf75b035727d61d3f0d7d5a7cebc3853eec134523c39908c9147f4966ecd12eb45553ee2002da91bf879dcf0a4309271cb8a0c8b132b9a162160360503070efd1099e62f5085bea74f4076cb7bb494b964fe890e35efb35b01dc645d81e3e75031835da37fff809e1cf2c620aaafbd4dafe20bb4a0c8aa3b756c5344272b82e9a28e596e804bb1d99e31d0eab22492ee7a4ebdf3bf89bf628c9c6dde699bcde091107103aacd9ef5f27692e29820ab04c4a37647e46a7a886c6f6c4dc25261ff449a7f54ed6234ff028337de6c5a76ca486e2732ff0ab5a9b420c3e69abc6ac75ae162700fb909c927dfe5214f55a520aa0a2b25ddc39c24745488c8ae8de5b0039afca7bc592b0e2fead5280391b9f95a611c58605a96220e4d44848648693df5fc9ec62a0c5892c8773cc3f256031ec2f4ce9b7c3e8f6d2b34eb882dbe6ecd698102c487fc2cd6b1142c932f1f9f6e17bdd17b3e31d1610bc65b8fe03bf21e812774daf3a272052270ecab5c058d26c643ace4c8e6b6c2de4b035a777b1ff1311cf7c655f67207259bc6c3ab52d5a1aa0fc381c1498e649a87667d4e3400587bb1198fca68e9572ec5c377f89d8cebe20765fb353012dd83434614b0c8f8199a2a26e8ad78a53d0c5b904f05c5978d31acd220492b423c029af7487f2f21fa972ff143bce4849ff6ca057e1e59713769d93454eae9cde6aec7da6c62e0d4791650c8c23db7849df401a109549d7e5358cdb28c95c29f8f08c20eb5c1b434846087d787a512a74b42f92026cd33aaac71a0176c689cb25dd429761e92b6d7bf42a403fa67eac698cc2ee9473d33d66480bad2818d5592992c7af02900a37fdb05775244cef6cc0fbe76c5f9a6a786a6be4a5ca235488366c857756bc064bd225cbfca062ef70e5022be116c76e6dbcfa328c385409f6313924b7cc2feb801132d59fa4a83b2fa86e99c26078fd90e61557f59fdc9c66b15caa7e980c5efc9e749bbe6d9284ff76e435453e3ea83c5fce4cf3de7543ca948a566e84c7704e24ef5dd590df4b764cf63fad2fc081b42e924f78628f11aa95fb35f7262fb3ab5d99ebb422e0a0c69bea18249eae702288e4452292f3292956cf1ddfe41a303accde0c99c7738cb7c2a709e0f5e14026a4c4ff8e55ca8489d4643769f4d96d808801d3480ff1e28b99c7482686197a749343eb421e44660471f722e0b2606d254192c9f563bd3f82403bf4e4aa94e2f75e6dc1b5a158eb0794532efb5b7c7507598fc28ffb5e5e7ab9adc7fdcf3b69bc7d0d834fdf18f908edd89789fe4006c389b580a6c77a3951614da7ff7fea79010a572fd29f005117eb0b37acc80517d2979263a3595e1637c685f93ac76b1b8930484ad45f1cf12110074a79adb5d12567b833f62e14e68ae47bd116d86c2ff98233c31ef2e5eb9b5aa09a634b50fedea0d201c2552a3426ad5be564a416bf33de65f6a42e7bf8e2661ab9732068eb09193bf0ab9398faa0c2cc0517ef724d8ebb018adcc8a34df47251df6d38328dfb4cec38598ed2b54ec4a7e40b52ccddac06bfd03aacccbf9f0191e9ecb6986b559aa1d8ad391554c980a723e5aaa2ac1592578ad1b7e9fd5b5bef276460924ebdd619563a84914ec3423a006ffcac243ca7b46931add63f6de66e67bacf02bfdd005197bdf1f09bf47613afabbd76df6b4ac65e6e5153b7fa59f538a1f2bde2edf0183f1c6ba2a4b8dff424b63ba7d0eb3a388fe68771fd9fe9f882f7b54a76b5711f57643e38b013d7aa6768abdc4a7326e787cab1849ed8ec7f909a4edbecf4feb6db6eb095201981d2ba056446372659b5821d9782be0b1a03fb04e2b98407e006aa109b1ce0814b4cc74f7aa61d97c17d858f1dd138311728ea4f175886a7557c19e7c4b7a8311220c538694ad356ab0abb56cf3646f5f89b8f19ea4bc0cd03f9b46d6f53e6f238e048773a20736e5a696d93be664ddb2e63b78221f2186c7d38c059014fc70cf272d90d8a341faafd2dfe12e258a8aaba03d2bc325ace5db6f17232bbb3711fde7257ca9329623453450773f4eb045ca4655b13e946354f3c13206fe5421a9029807ff43bd9ff1814951aba7581a8213e90de1ed74a71ca79bc4df0fc1166ff22cb9376a25daa370a9ff61d2672b5816ab687e8f980d2ba280ae1b0b8ea77bd40da7807d9206fa165b042825abdc6066f5fb88605e63bb9ba9f90e9985a3ba907af3c397c8f2b649fa578adfdedb085aa23c36448e596dfff0b6d3102baf7a128cfdeb46aee5f69572350432e2c49e9f18c76c10a5e7f9ae306302d5a1e45239e82e93177f425f3fb7e2eaf5242368a80dc6eb2155ff99b21280770ed8a8010b4ce9b6c84878f1d87b8aa6ea959e2aefcbe5d7690b4be97db50673508b5c638326784395c637bbade9977afa10fc0bd934756e34a97af63c17b79b60568e65eebad84b1a7fa49a33f3d70a8c41e935dcf1804558be1414690854ec95877b8ffb40ffe72cc99750f9be7fafe42d20435c0d34d3b898907954af4ad25e40e1f828bfd13e046956c30fef1ad20f07062933f4b27ba0c16f816419f6d958bd56051f76a9996144dbb836ae1219dcb56b1f6c9031c80c0fc568c1e4c5268a9d7058706381a81c4f500b711581a4df31a3ff6445b56c4caf2b6a7b18aad15539aba3a44debcaf30ff7bb4277d35eb209d85bbbaf66632a56e4eaa5d8a505e629df6813256b737a3a4bab808104d97ce206f0ccfafd58add444a8602a5e3a9e24a99372132b6b83cbedfeda6d419c05873b588260268d7ec1dc2b340fb2aa288191c647fa04b15434b536c6236864eaf17e84dfdedfdf7d17b1edb92a205f1385815e09baa0e2ddf44cefe87a018ef75da7f6ed75167c9d47f276e76e70c000229fb420dcca04f709d49964c777d5b42527902fcf24c36e80f83e83e761f91c0f5a7a13eaf854afddd4b38d21e6baeaa9c82548c50b194217f24674f3088c41c88e1abab3ccb39ea81d1535be8ffa9a331906e5a8ece821454035410e6e516b0e52e9f857d73f18f5eb8b71de4e5d264c54ffbf40df175bedd5e20c000d3a8ba40a2a72538ced0a680f05feddac7906d5fa30d0e58722ec8609db5b6dcfc9a34a4168859df38dff25bdfe6942e138dec1b3887676b7a39994a7716449169747200c03d0d2e09005e95ba8f4152926aa5b1c470adf15a6eabff67991cea0a486c8bb3a36d3fb4dbdc11dd60988e1c5fe2a416e60ae10d0518856cee05e0e8050c78d2938c8f33ece436463c65b9c01320be769570f40386037b50280ef4f9348941dd0cc185e3e1924056d6f05f30f50890e3d03f5dbd4e78c8319ecc9e15c627e4937f6456b0f6ce54bc490e7a1a340ee08ebb1b8a7569bdeea1360a4bf30325f21c88ff7511628f0b29baa6379d087145d7a53b7a5aef19bf566f3f1be5f383d3f9d7c4c678aeb058a4f864ffe2c1b5a50de56da7bb7875192385f0454a63daf10d84d1608ff253178f006b42c9765195ccdab58f2d923d68c02ab052349402b1167c2a642caa780a1538c2d323ee972bbafdc510e35f7839c4398589daf7104d466523b738b2282cf80354699ac98988de800ee81f6b02efc6bd455082f04bdd66533581df64b5f8bfeab5f0ad77631b25f42e364e2f54441fb5cdf0cd5c4b9e5bba78d67b42e0825257a26d75edb4f28c4ad9bf466e5e95e27c68a9f4cbbf4a1c389fb033b99cc905d2dd4cfa61d8eb4f24cf86518c693987471b4e0f03174c79910e5390ab613e7bb30d58749be90975e20447287e24e38094cce0e8ab8ca4b1cdad9772e66c33a6f49a3941a2247cae5832b8fb6534c876aba271e1fe63629ad7df07d3afb5e8313e5d76c0e2d51fef2e51b64ddaa2a7bdaa3f944053298cc19826f7fc6019f44b51416f8a6782628cc2ebd1bfe860763bdf22c7fead84c94cac579fe8170de94b14dbf7883c6dfb6fd27f2bb323c62314f4898f821789d03987ac362cb7c668378d2aafcc83529df9f893183c2f34aee1750bcf7c915e9759828c9eb5fef9b7196589a5939b8f8556ba5c608cdd1990ca9af965969891af05f7be751c422b5411f8ebe6a466250332c9a0dfd2ccc7f248c81fef8b1bbe4b28aadaad0b5bb8c8354cd001f4f4b5ffa1939138e0fda5fcfcfa3660b5425582c4568cd554e25c36a42e0f384e64cf08df90da4314ade1e49172667c3da1e424e963dcd8132748a447bf1c750b28c5e13a2918b323370f153c9db2d4de1234c79f3e23d3090536f7dcc99eb02217258186e59c97ce343900c014717ea885bb9d0d52d37e8f3a81bec55afc29358a3fbbbbaef67d4591d53bd7fad133ba64cdaa10a406cd26243c2bfda27029079d811268bdb78c356b02dd9b408fcf2b177d28cdd6e347f30470833307079620ac082bf15528d37d556fed0e98d8ef92f651b71794ad4eb7f9bac2b7097d1553aefd9db2f94387079ad71c73a10612179a45446084a3f895aad2adee742e9406935bd050f520ee92f87b984fb702df1f2dfd038db0a68105fb3088c5b8652e36b6eaef83ba83a39d186a70032c53213baa98980ada6e5162cdd238c12220b3e9c97afa1bcb243919026446f030acd8a5aeb30d14be4d077797712fc6458f245408252407f3eb6e45d5e0bf2f98f7fd76d21ae93c61e81741e41d1bfbe783fb493199af8f46ebfff38e0fa1e7f8939e4adb0ca17add01bef9c3231eec8092bd3ce875c369920adc890efec2a7a12531536063e7dec52adcea05ff17743cfec4a6b674a0f7051ad04cd6c23d33f925c841b5ee0a640dfcf2458e583994ed6c28f6ad6f8b4ea67625840edd39188f1e2696d95a979fda6895639a84244ad339a70ff0f77212bff55ca8a001ae55a727882a6665944b3ac6645065084df7449cb6c66fda9b4db1f3ea3cfe658583d828cc0980d8ed6bec0fc10a63bd3104c21614984be83318f9150e6dbbd7d0f29af710117921483ec80f9bcfed08498903fe376a2227800a46492e833db92651de78c9946b4560c0d2c654dde25f82a5e8f2a5c0a59a33f09f649a84db28d5d14fe624fa617b5ecb9d098d2dd05919a0cc3a55048e79e010e62c27f6227c5eac8bd68a5c7ef752af3242b72eddc01e75896fd3c87c3538fe75ef79a41dde9ec40de6d51d4697abd15ed03aa2e95eb5db305c9a3d51fff27c81245a5b4e9611a265747a7d24ed9242b2b16f24502781e2a7f40fb68cce965c6cc3cf1437d60232fd2a3d63171f1f6b740864d45e7d15faa682a85511d25c6fd35f333c296f7b2d3fa7c011b66a2b12f02902e01e8b3c4ac5c64ccdae03c82f12b3f9ff18097e65133f7d36471368c32c9aa803f954ce1e86536e29f4c1165b9d20dfb0cb7c5d5f274db58a70c41c18182b93410e74b9a2c66872f70105f7af112daf7064a8122efcaa158b374e9907b2b3a487102ec497eaa14f3015835aac54b067b22d3df350de6b1e16ca670c8b656b2db1bfde0a6666b02d0e0762b80116cfaefac30cbe31e22265b4004b1938ccd445462c6794133eb473d4b1f3e40bec0d6b90479125986cc718d748c5b186c413f8e05b73054b469c8791c617fdf542de8bd0bf01a8b229ae3906e815ecc3204cae0712b41d1f85bdc32ac1766371a1369b21ada172f382d4887cedcbf53295ea85c6f41bb6f24d155a59670eab3e916e0a8e6d6c105f915e7407a5f01bdb9c5d79b48efdcd9db84ac4a3a89afd169a5edd5f13f1033622f52e0ef9dbe1cbf5e2ab420a1b6bfb6ae5d631e92bdf7e1918f87836812ab5a71c09768b0104062783c5a7b2bd3ff7b930e94544c0fa12dcc4710425ff9ead26c590acefddd8cfc371ffce101dbf2c7e6bf19fc0e6a8b9a554f1eac90157b66a65a1dfaaa2ae1aff77de256c4ea8a671afd200fd391d922bf24fa76d004724b5bf197f595e5b9762c44f836a6d2cd281cf4b9fb27cc5a14d112a54c7809a58f29d49a70747f8a28ad40c37c4e729bef24e0304b3ed7995800371b2d9b1e95f18555759e796fdea520eb5f08f5e0f1d2dffd7cd0daaa3aeab06ccb71709854cf7f3cecf2cbadf4132aad3f85cb8f70aab7d88d23b59cd6903ea38c78ca243c4d659026b60a64d4fe3a7f8b1429c1a58462dbb6fe06201e6364eeeacbdba08760bf1cff0b34a1722a0de5c894f45f9d7955de997548e05ddca752943181ddbe47233a74473cdd406b9c67e61631e69a6adcc7f8d2d56001b127e938d552cf11cfe462ecda8ef9667b817bc9e2dc1d9233981bb3394d0a8b74942bcc02c91be8b6d470a9c7c6bf91e3f70628357ac732dacae5fac96cb82f0ad3fb0e7dd7eb6edbf6934fdca61f6e190c4a3ee73812e0a9af6d237cecde3b646b92376000d4b8fac45d64c2e54d7f514cf6c4bca8f59ec448df76817ac9dcb2a555c94bb341a297774a5983066efd45c262e664aac0cd41eb824c24195f127e051f4c537335d82e32df612be0c314e0a04e20ab73c2391f1855a461a7350d738edc4b36e5f777725ae7ac8af7abb6a2118c22bd6f119d4b4fd643bb67fe1ef3a9160c04a3aa65f04b0031f0fa7978fe406303c6c34c485ac5775473609d90fe4583b71cf485ebbb05d9e937ddd9e08276f3f8bb210abf85f42c0400d23fdf3459bc01c61b9d4864321de6a312ea8cfb01edfec10e9d19435fbc5c4de926cf7aa34c0073aa1fe9a49381b9496f8161a1bc353336b70b52c85781c583f93356055167109ff28e71eccfa4d36556c9e7d1977deec636b3312f5646d91c5f6eac7a2beb10ee213204ce0b225d090ca358971a4aca72ab948a119bc987a7a30de5c698410be711d5708e1e6bdb2c42214e3181bf8df5dab18d6a293a86f87be4c07a044443ac4de9077a44f1d5fa0038f9fafa055b13fc15212c890e7572c24c10b3941935402467d8f9f99888560562889f5593a212caaeaa84cf5d950bfae99e710656c3a24fe961e63040686a55c1c3767fcef2dccc5e7c5c5ac944fbb980f50e1e9b6599f2bd428297cd8a7bed992a0d6ddf6689e4a7d17d580c9f5389382bfacf30c10ceac38b64b98053da3d4f22c287bcc99c3c7b0e98c4200e065d37726a92051086eeab6a015375e4e33965cfa4f2e115784b841f503ca5b8bd4a27943e0affa8d2bc25b1fdcc782782da1764900ea231f598b261649c1264dc7d6a94c3e8f3bfdc2316989d30ccd0317b26046f8c4eebd1fef7159e17d97f8a17e01d8c41bca2948fc412244ffdcec0c7252b82fc5c907b195cf6b7165f0f08d8e919f3b3191b7d2e4c00170bee8a045bacf559d39b2ea46c4549ada75c32b111ce98f88d5fbc4f97371e32bcc57dedf9bc091862680b6b77911327e74865cd1690a63cfda43a5248bc8beafc7073d1af0457de1ef2b8eb199ea35c07ef16cd5d711d2cddf113ebc6cb225904ba5082e24ab0b11c35a9fb671191141a8c4e34c9fa76c2607f8d03f1f4bb4cd413fcfe9718c44729a4bb47f7d9ac7a25b62c5f48898c0486d34d50d1b9089457ecdb3a3df3b290f8865eef00cc72f57523d11b5604e6981533c8d14b8d1bc5c87b8620455fef969906f7e08b755f806d77ec542cf6e7e802f008d75876616ba7d0d5bf5f88a5cd30360b1067ed21ac363525c3884dbd2632d5d9a9395367465417146daa83ea8d0601dfa1dbc77e3a28b09992853c53021cb3d5f40d2d64af0c770c39f55776e1bfaba6bd9dc7ca7fc8fe36559367651bb23beb5e2f951479b8a05e786a9508ea124d81586ae17b6f5512ac83c449d2034d4ba9db53774425b3fc11c5d1cfc3d93e62641ded03ce6d3a2762596167ee58c1ff85c814778599579e117323724d46762392119f8feee0204c0cc25d41bc81d876d4efb7ebe802acf4625df45c6849cf9fa2c4e9ca34181185ac1a6c8e7f23df3eb449ac53c9926b0975695447e256126c3ac0982768494dc68a0110e5f1f15524195ef029d39ce260c480c14c99c6053fc4d48f5b1e644d3c6e8113324db003126978029925433c4d199482f1c82baaa782c2be537f0b59865879b7610589e49488f930d036f9b8b4fbad0d04be407a789ef9bd20a9f60b162b9f7dd1ac9cf6d6e7183e9604ddb2d251862c32e7f8ee5cab9e9ea17791ff12288be54dba6d2423dd948d8380963d985385d8b87ee4983d99fa3148ce68e74599ffabee03dbd246987c10a57aa44786fcacecc3b82b49100060f0327b15d82fd05226dad4ccd6f57096955f076a5071f202a81d20a10dabcb60f40230c444316bb38f09abb9454ed3c85ebbad7edb4a4a006089fa9fe6ffcc1760c8bf62d9a15b1010abfd8155b679ab158cba49cae992aa531338afe0bbaa13279fee7f943920407f07f8a57b24978a444755c6187c214eac0be64c61be452e3686cd4265150c06b4610b4568b0290a00700a212dd7b8d18ba3858b4695a9e34ba906d709fac209be9a76ad9d540f3e197bdf7a01cd8dad7fb6294959b17c2d6e6a03430a4b73661e0b2fc5ef4d53726697a870ff6d46eb2741b3ffb873791429364b4ed98241bb1e782ac52dff835b2805d0a21b077ee62ef4154d1d2840bf948ec8d4c4660fb837bb40636861333c7edbec8ba2cfec15703ff23b9af174c072ec04b781d90b44f4c6bb7c0afda13a36013a2a4aa5dd6842bbf0983e4b8881c2ef395bb157385ea41188627081d950955ef03b7ef40876424d129d07d2fc23d8f31835d75f5387c74bd2b6a0d8f0babdbf37ed9c7717a77381c3fc15c86116d9b5c5b917e62fd3d1f91bc564ed26fdb87d8daf8b3f9c7db87fcece6b7242f81a8e3d27eec314c708769a955749c087ada1aaf70b81d91427aad2b0efeda777b8f132d1b84297208596d2a742a16c2084eb07f68ccab4806f58c9cbe611706f7d8e069107f70d31691772841db756f3a7ea2a98aa1912351fa6861744abeba0bbc882981c88afbfc3d1f1ea2b13eb41fe6861e3f497c456b0ba36f3c7bc8cc4a8af31c1afb63a6c921f578ee4819178b06ce1392bbf0c81d2c1f96f2b65dc65cf929767110dc898d08414052b9edeb3275371f8c89e25133ebd96c1951cb8facd59a4210db0e1da19a4d7f24ee93feea0f4adaa3b8b353a62263e0eee28ecd71ca9d4c6abed757abc0b324a9d85020acd386ee760667ded2f12f8e5476a6707775597c74484912e3dcda6572b394de5211c0c650cb1920c91c02e624f7d85a6b63a4cf8a3ef350772ec6427094e2b614e1f3595cd6511a330ff88e7ead4604623671dea08e835051f255b24d9861c05dda877642a1489b99837eeb2def3af8b757ad7a59852e8a9743e72a7ad4912847f4d47c179e3de8935809a992f1f11fba70150393d047bdfafa3b949274f144c2ed512df3af9c3e4e443e61aa7dd059e1f39ed864c2e2d76f1f05dd3e09ee658a0ad9cc0a2e929ae2373bf0d338f5b291361695ba230fc367b04e7fa8236432689fbe969d4c2398088e73c53c1ba2f4decf58c6fd89d6f3b7a0610addfaacbcff1ab8cd1849ba576f5d0eb22cb8838992e2ce16e238b9635cd4e8643d16adba028e12965899e6fd7354ef5cc76014dcf4da4dafa911c430d56e1a7a8aa6f791c07b877856f21e47f0758fb45b6796def5fc312560c7cb4eb5c8359eb5e6d744a390b7295d1abe9bf1cd36e0678af992a76aa09f145b0f70c5220184e2c82e8fd2827e6d4808e9625a4ca9f914723385f3c2601c86d0f761bded980228827fe40e8ca386c026764f6c4e92cce2bff272a910c17d52831f4a423346a156f93b882427936b4f0639569449901a98bf356852226e1816a4544a0a050d0a2b6f0bce5990a4740973f6f4316b1f3e8611d2cb91eee94e07a981bfcebcfeaf9d0cd391f4f59d6acbd457bfeae045ed9fe4f60d9964b7e99def20aaa6687f1245139dac331d744b4f908ecc1d9fa93d8f19ac3991fe37c64da0e3ec20d1420cd274bc9e60d305ed6d89d582da8c5db85d41303f69e1b7e5d6e9718c462bdd02ff91c230ae7792d36180df9918b6818ac6553b396aca19118b9c7e9424657d42bb03fbdc80290fdf6af0079aa8efd718e6704d1c2ca00dfc01b48de6369891fdf285d62c054200770b8f08c207840db050a2047b09b25fa0e358ed9a66eb2b2ed9059cf8033ddf4364eae73c5c40408e943f0afc658200bd16cc9b8d2787b181c9323eee58c930fd676dce7cb8e48c5369c30a0da720e9f806981d3c675f2c562e6ee7432f49edbc6663edd380a889e765967ca751e6cee5e8d6f59c5bb60f923a32c49ebe1aa638efca947e0a8e9cdfbaa23432e801ddb1334c75e9d8a3fa698097019caaa78a1d992a43bf7c2d7cf778d2ef856b0a2281bc0609c16a083568f1956ece6a48b35fb0d34be2c9abb3f4d66c9cc8cda3656dee225d028a43f631d9f40899b4ca45f8eb739b73e31081b0cdae198fae37d16270647e4dd097529bb1f04f73cbe9fd02ee8b124377f442472fce35ebc8330891fe4cc0e411fc99968e44189c55c1e42fb4e8c009ce2d8ca388b6d5dc479666ef526a201ef3df785820a2ef8fd80be945b57b8de0ad43166531cf9e75fa31d6f4615e6f0419339a86043d3164e2875984fa05f961032f2cf19103194f03e587bd59775d0f727d9d5aada8bf9eb721c493301d57d51be5b07a719c2a37b0e5b9789e6ef77d2ba780a84049b76b50ee5c0c27c1837baf5a8ec2d1cdec2a03aa5123ce06c5d053276472d268ff1f21e16068f1be9ae6ab75a837e2d66ca225f9849e13f302ec39273c80a6799a5e18b3213f47d5b1a783576925ba52c13e430d17ccd0150973b45cb4e472ee2ea1293bf1fec04a33c272950ebebd38166f730449390f1f2aae69671bacb4e28982246c178b49805e60c3b74378ac276fe15f3c6b41fd3836367b29a485b646e527aa0e4a06038a0dd9973a936eabd65fa58fbc03f8a7e3ae915a0734535f689a60af90a006a8be0ae14876b7add45c31f6b2339e0c904e4d95a176efcc698c8bf6deee55acf8cb7b6f23b38771f8ce1768089e953638a9daf070d476029d93cf501e99110fa67d14ed02d17b83af853079615d976b4ba9919e3fcefcc768b0a4f10fdabb62aca3d5d72d3f3f4735a673802d08d10d0d480657f1125dedcb0ccd84b1742b43179de1ac9125bee036b97b1a5807d229793c5b95edc7323667b5213eb5f69d3b8650f8936795ae1951bf4aeaaab9e52895cc6eaf1971c073f2138bf921c8a1379d83468c0e5d5ec605a17bdbf40a684ccd4d58ada3c33fd74fe1359b0008da948179a07e0dc7a150a77056cfacfbe6ea35cd54d4dd33d9cb2a7b5e14f7cb69e7f94bdabfac2bc0328698aefca31f5a38b19d83f99c355253dc8b05311a033c4462fc54f22588b490481dc25b3e54c60712c2ca6844049ee54169059319d479a03de7e7a1237a52b8f1113bb6e495bcb53419fccad83b5ea56ffdbd1e5c6d51bf090ff4901d3743574e9572f8b7182a1f1fd58609f387e91110f107da857b78ef82debb545e273bfb55299e4fab8b88ce1bd9adbc37cfa9c43ace155f8c51e6bffde23895a8872c916edd8829ce7aeab9e89a75270c07e8502efe3301d837331b508a1eca13b1c9552b72026f4f9affbc3772f77657ba5e837d26e7453a36b1b634f411a35542bc9139923ae1f975efeae15a461871809b2700cdc49b103087adee5f64ce7eb7efbc719cc3fa343e372b25d12cbce5235beb42eb608f27436407a31000e759e97e6bbeddd03c0451e2b3972e76fb1ca3751c4e8d85657d85ebafd7c6e3a0d4b7525ccb74e3e1894cf4f96d86a0e0b3d1607bd9c665db671f7d6762f4c48ebbe0623330df4ef626d3975e54e115b7e6a1072650cbbc9c9daf3595b4c5d1ff8116a07f7bd2c96bf3f61fe61988e686a1912d24f6db8f197faeed04b535de983287cd1e9f955d7e6c9a9128fadee437ccf4fde96b908b68884e3b27d649059a0e6576b8c95f6570672f3f0b1c7a840b3205458dda46195326e78de7dfc79e16fd272a2f745d8b8824e3c2512d9301fb859e47f4f6327f1f2cdde08e986faea3e2fa6d4e2e5a22599138650d9e240bf1a148d97794836c8bd8890e1a61665927ad42e5d7937177c8b31a9a0f2c49eb318c73aaaa1ebfd2e4b222eca206d3ad12393c30f5953d4a31c47eff2f931ee081127df56aa5e81abfbbb339daa35efa08095556da4c4af900c2c176203d164fdcf24f2e31509715be7d9ded546154f93bbe6a1deb00345f3872d51c6f09f4aeaff135f1c84ce0902c7c6ecf5297250f64617157fa4a0f3129bd9b6e53e7e3ddb0990cf04d9010f08208443468a699e8bb1d73c4106a8edfcad323b0991941224de8ac767b8e531b264d2e630dd2f0f949ae8bdd46c5b4c0a3b0553f3354ec0ad46b531ce0b41474d86d4c0be6acd143c11248a1da35910f8756814c2d5a5990cfece63152e816c0e1086cd0481bef3b34daa38a54cfbe266f5350aeabf0e8b922bc33c91c829aed5d01c400b8658c693b8313f54595929fa317ae007010187ee21ba6f09fa3cddde4910528835e26a99c18449b2468fa0f8948b3040c37019fdc2ddf33d797aaf1473919f952f8f34d4ab80a855a8451f7fcf0d084dcec4d784770f6ebd7c7c07a9e6aa9396affd18dbf708044ea1c28f4780197b629a6cfbabb0e0868083c858d2233f637414d96c59d030448b6e6d65cc5d74e1e666b3ee736cfa3e4487df900ebf72bc6d2b7a0911cf39fb9f8f131cd07d23c07f7055c24b56c59a2d535fc3c3308528dc3ee877edb2773f5ce641a31efc45290b81c5732ee5c727482b2d84922e68d3d19df413c6388cda4db4eedbef6b6db38ec5041d4f4d6aef2d142108c41da55707da59a3b124de30bed49e69fc6e0250c9af6cbf06f00045095f8218972d85bbe50e7d87f004749a2155c34a28523122ecc47323ad3ed0696c68835e488184131c9e5276e273c93b16bd7b4332b3710448069c85e2ab86ab1fd5488b1464d71977929a6bcf448d9a3b88969050a555ef4249419a3eb8941585f31fb6d89b904e5382b7d786f17ae513bf7af7728d3334d02f2cce321ec452b662cabbc9b998a5034edc40a76f23049e1d8f5b2a3082e96a10e3fff61d8243b1296359ca29be297e24850733f5b5b4885de0cfc322b270ef8feace80a6c3466bde403d364f44da1469b721a049d5a475bebbf3bc43d5a889dfab804812c7de903c0b9fb67baa8528f1fcf133b6f140af9936a23063d9642bd1a638b352833daa362f1fa264aca781e91028ac534ee97edbd03c1ba44c217cfa402b2bcf80b8c576d4499c736d30634c66bde7ce9a75a3c28ea2e07b6fab082464eb04a5eb84e08cb850539dc3db19b49f52a210ad7ea4a8ade19992efdf50dfcb34a079ad6c9ebecf84f45d23230295e5be8d31ead298a8a6e571f0802a01d0f19fae8f7abbbb93667b8146e860a8f346eafed12558188fb4121b3ae55d97d0146c65d7f030ca6a1aae6efc70fbbe04f25703ae4b40b65b68305706461527e67b2810bca0734e4e03e83a9c5d859fbaa4e4228730c7a14d8ad5bcec579ad06fb4976e73b313da897840f395233e2faef38736025a094ae30fa4d92fa883a9dac3bb7111aa22b5f98bad7888b00992490af47e757c1fb6e1c17f4ef0e90ca8fc9196ccb4a381f0fd434f30c4ba0f62a0625b074b46191bb981c63c12d2462c5c5ccb4d13a117b2c442561989c76ccdc56c56d3bb4f459a11ca4bb0f90b142b1ec4f6f50c91f8573163def7be0790ae31d23264efaed57f60031f1949999092b744c3e7861895662a4306016425248804d54edf0dfccb702f90b0bbc70845b0ca349094b2adcdad57a0ab08bf2bb1d27a23649c6cfc06821700332173a0b6015cd734ef5d0aa437cd074d3c379acdc29c4718d7516a0e88a07214f7aa9e86204ad612c14d7f7258903e631f6a00fb2dfa6fbca4eeca376955aecc470519c1f719f1e987296233b02c126cf694174e25a945c13918678c4836091f4f5da9f170207c5a1b2cd090ab8f866a9c4db531d1057344d17d1654ca7bc0c051918a79e1c04480813cdbaabad40bd58d3ee99acbff2d7ed3c0245bc9a3025268a5c8367deea1913e7b2aece9d69db07eb66313300a050491af94eb83758a92efb2f37df32cece10dd4b11da0e3d56b03411c3e21b51bcbda872c2d6dd11b379085ab793e26a3d49008d51bb0fd4cdc3f2f7aff30b74015f22ff69b8c67b75fd25b1f81eea9f623c91654dac0287c1c5343c91ee44092dc4bee1795cc3d7058914c34b77131b60475aebe98906cb7c3a8352a949b451c791f947cdc8eb149c96eb7929a4d696bf04ef6e2afc1fb6abbed2c26f0830c36dd3e7cd6c1ea09325da480d609726bb47f388eec4789147d2dc5637d560b589c0acdda4843b0df38378d13c27492ea42c313fedf9455e2b6122d0b362a0c7d1ab0818687c099fba60578087fe48cb42f6a549e770d7f35f04a4f51c026ea0a52ef64fbab56ebbc92d10c57c4b9dfed822176c5fd18c71546844abc5cb2865fedb28d389b4136137e985bf1497bd2f3286f78522e02b898a2182c927d6e83c5418ef776c243b49a8af88728c9afd9eff548575d648547f48584c71fc1c6420d9c386a88cc49c1763906aca6fef162b088a8118df171d9bdceb677f7e9c481d95c3a329026f98840704787204d5e1126c5c217f73a603628ae72b854b875526a9cbd9d54c8ce552747be740d6232b399be162853a46981546b553dde96ffb382d958cd7f247f62e76d0cc7d0e53e86b1da756d3d7100010f24193f3dbbe88828ba1fad1d62f3e4baccc53fa3e8a185287280f7f2810976b48709b893e06ebbd2368487be5c709f34acad22a361348d320f3f211b2042b11c999704cb3178a900b67e17c60b820ac144003671907e41636a5a12ad8363b0a2a223772a46a6b24fef07004bb78e3b5b3f8d1b83b8bec40ea5ad49332c75f71cc4992371be82d07d2e3754e84851acc8105e315062374df5651237e7defc6ddd6b1581dfbcf94523b2c232d3f5a3cffd579e9c494c7b7f8bfae39dc8b43cb2d5ed6387fa815c0196395d4b1e82477387feb6180f1774eafbdfb6c61b68ce258f160a048bb0ca16048bc97088b55bd09b47dde4b84e6f7a3f5e0eb893c2e7c9abfaf8cee1d6939dc3df46ee2c4ac176f9f703621c4fe2524a609878716fa50b9fb01665a1344984ba7f2a5b77c5e3bbba2f8830dc984a1de11b2812aa2bac50a1fe956","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
