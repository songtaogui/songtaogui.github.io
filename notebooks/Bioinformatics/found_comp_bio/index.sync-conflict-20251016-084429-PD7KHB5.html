<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1214ef277ba0f517047a56d91eaa92d438aa3f228b428d7003d4ed53734e58dc8fdb9b3c8f64c966d21abb9e790386c1495fb8ffeec95430c2e378c4f3fd1f587e11244cf044b5c697373fe533f72e1694bef18fdb6c7bf764294d3459e4cff52668e9937913e54f7129018134eb1f99f446621fd3462f71b244f42229587d103ab2cbaa8e19fa8baf2aa1ea8360a38450d40c858b4373ae68abead78045ff9808f72b8909a321c4c13fe243f807326508c1c7770ce6fbed22162457a9fc0087122358bb52a505eddd7aa0770d4695a48bfbb9b7fe07eed2dfdfab755d0f534f4851576968a358babfd6b04560fb7b9d32c959c4c7bda419820f4d4f87d897a119dab0ac864528fb8f58ce4aa0c872d9167a9560e9f26adcf4ce4dceb9aef6b8108ef1ab66bf0dc4d4a7e95badff76e2486595e0bf11c4fc93d2f85d63c8e3b5a6e5b7145ae4cb4264fff99c23933bf71a75c4462701a060c3084142fad936ce0178f87e3373f68549c99f2f4abd3a8b60b0f7c8c5f6d2245c3f7a65e1d6dec5ae4ee64d0dc7b0848a827c77517a9ffb9e3cb7c0b74c739ecf4f80b57631b4586744e9dbaba528e024b574c720af8cee3077c22a3152dc68b8405b6e38924e2cff5d5b166a03075e8d73ac335644ad5c297ccfcb947544d6dc850493dc584047669d0d6a8a66e33b4f0649c2572a0c3124dca7e53bc61441d3792d1c4966e621432a7c40c4f06827c4dd582860edfa264b8dba748aa8ede79d83e9b75ab72a114449c44ebd1163b439e4dc156e61b0cd8cf164572608c3d82df0340a2eeb07dfbd07b3589ae309c66dba39d661bb5dcab30a832482685029640f1b12fe909d62a0c357d61e893a18bcbfda8a11eb8d89ad864dea519121a294e3bf8f1b8ab12706046089124cf9ae5b259517c7da8e4600e2fe3119b0e34c9f95f098cd01f355517cd13bda8df48f2e4ed9d7c57ace6e4b912d48e0361edaaa98b10730efe56c73a6b2cd417b826bed5648f0413a6479e15296beb23335df8c60ddba519471c525138de60521b5383b77b822af4a72dea916854411f76af7691c7136c1e0fe55966661e5d2c4fbde2babd31af1e6c031e8342d4b98e7679b0005c6c8b72d74cb62134e6087e75f10421830e5e9a2138ad5eb718872ea9f4f0d5a0176e4a004081758b3ba7ccceb9ee60617bef15cb45badf04521514bf183fa16b3b2c72361638400b3c932c239d42b939c2f40d76dc67a977b759e0307e3dd0526efc8e1f9a3dc597869496cab0f5ef75f43e9be011bb6fd2b820fbe5a9a7e578f7ef5f7b8d337fecd339a9a8f623fdcb0db562cc93ef1ea9267b33fef90d54e68379ae5018cb19a2a69c1290e3868d9e1529bc43c60b07d1d7fe8983a250d4dc6407b056c1f8f65d96845da3c16a1811c98352295ae274b64beaec937ffe54b0c83b97e6d9c8e7a809f8de0caeaa1b89eddcb71d654d66481dc17754c4a928ff46e3ed36ca3ba1e065d4384a74077bf9c4413282934878adddbf8010d95166445ebfbacb1d55809135f103b1ee0044637cec72cfb5c32f3aefa41659fa67418e8858cd927ca1e96f48e334968d352ef15a1573439194a17533969ecb73e4de0f21ad77fde3c26868a00dbb3f3032676ccb9c1be2d3186b3824896eb11cb347ae38256a7853aa4cc83b74d62f769379ef806a9cdef487f594beb42d2377d690ac013357669a7d172769e6da518ff6b81839b91d530c57390a2df85bdb7b34a24f33554b28da4d63660ab800e9daf5004d380560a0c2e7971941cdc1f74d8c63d866780c58cbfc8754e0e700016a8afc0d1203a0d9ff252922d9f2941640990b8da3471b61c30b19739278119435483ed5c0144ee57d0fa6d5f91182d1bd732678482a75295e7573a50d5bbaa022bf96000044b3d9e76743676e3408f3fdc94ee68082ae3a16da5c5d07280b14eaccb9b013d4f7a0d567774cff63466f95c8f3324612488b5f633fb0f8d96c51fef43b058fcd1ca193bb46ce758c88089c49fef5b4d6b6b67123cb9f4cb1cbd8524f89a95e8fe5d2b5753364713c364e372c26bccad15994ab7735efcd71bd6f88d73fa6c692972dfe954e5d2bddb77a61efb30eca5e4490cd32e0547cd2ff3c62232d322125d3d1eb3236518449d7334211e6ec3226fd347b9bb7630b7b515fbd0d9cc910e1111fb88903463f525b7b1fc66faf11a005c4b05c77fb3c6a248f774a0ac2006317bbb6aedfea4f467e20388b50941859e3d9ae216a595a8b2622ff8003403469840c166705dffcf567104e22d071129304be9219f970af62441d47fdcf37a6acb59c6f8ab8bf7b4579a2deb77fc0c75a4683c872e3f2fe35a91b9bcd3fd7b2a125952983037a0f2b98f301022f884268f9e5b312d6263eac91a3df754200965be8ad0eb48a6166af73e7e6ed32c6d6680ddea260416c8e624f944064e31b97b136a87385265e42ceabc0eb2ec63a910f965c0d7d153c0408f69eb00c2aa838e0635cb291e490727c6849f849b081f5396cb6285ab4de0e3089b56b778f12f10d088fa3c2344e33d913d2ef44686362bdfe6084bc0eede05c52d2bfc8ddc9ea6975f4a16e57ba680b4a6f4b15652d7ef04077730962ee3ac17e5139d81307fd645b9d9f8864c08ed04ec4cb189b95e38aad71986910b283610a8ad06f474fa54404f1dd35addf9bfc66cf71c25970d593120f116f3060fb4e5c6b51042694fb52cfd4f10abb59a929f8baca75529b59cd49b3fe726ce3db519a01f9daf2b6a6e46c81864e5ebdef946d0cb1c42db77ae44b092d34dde1e5b377c4e6937ab20d8da3688373042811465f8d5373762befc10fce9000a674cdd8bd0e8315401f644f43959f661cee512a41d17a0f7db50e24cf620dbd0d7e53c8a2e3c10fcc6e4b7829470bad566a87ff2eab6c650f84ee68650fb96c4067239d320bd31bbd5ded318447665066a15c7d74a12af257da44ad75340076cc52e56400f53baf70685278d1243eba492053ea63d169d5732aea057c6fbcf18aefad1a296f99c5a6100234039097988b29053b6d301206f1dd34e53e3018f2be3a49643f4185623ac51a166e6dd054aca911e4ea5293a740ea0d0976f7f002a1c627907cc30028b4710b7801572be045036ab69b774776461071ed9918a59c362fbcde77eaac3fd64cc2608495d353e9b80acec0d7f5b348d525cd3d2b23614bf9116f545fd4bf625bff014916dec054b8e1ab4bbfd2e61c558642e348e10c5994a793b6e0d9c8bf1a3d62284a06ab30010ef2a4f1e68c4a2353ce5876d8c28360efb488bd1969de4f2104d9bd940a35e4f2ce925679df56d5c692a11ee3c58715e309c3e1f3d43669d65c6cdb4003a6fd3120948a23dbddfb2cfc4dd031462944b9891325e9c58051a9ba2246bcc8ffd575944c98fc26a1f46fb6fa49cf335c0382f55390d6086d397f9ea0b6684df6b054f0b28e701b047a9d8b1854bb4287c85f4d12aef9d19023586c5082e6d0898d6515d79158a677e69aff5735b215f468815601fd51a218557a21caa899006452776ee47b9d0f79983890cf0fda41980368db20de71d02cf3b5b11c7b0734f350ab8abd6e915d35b0ea35a398c2bf53f142a8da6f1fc1a55c040287a995252a77e54eb50bb3587c4b93a69f4383a05bae527d88d633cc59882cb40c8ca41178c244afa04653caaa399f78cad3a92abf03e1457062fc1f66f75c2793c818afee737d6c04dfa3d9af62aa42d34249bec64c28980a4dffcb1e353e35ec8805841d197c8073c19a2d34e4cb69972e2959e23ab369233ab7f7cee894b8f311460191466876f2c6892ca1017b898e82a98feb2e8220f7ba794ec79d4240700c2201ea518a899170ad34fc6c920125067959f55c9060755d119dcb02ae4809f220ce592317e0ef087d1e64e4592d7d6d68c3704352da529e8e77aa1f7d24f1967f6e7e0d5917af1a9616df028557e770ee68b9d19803316eba1f41e08ebb56a314fd0c39552fb10438dd41f1e06e85fd261623202319c0b62d876340a32911f919160a1697af18dd37c50fd362783fd7d186a23b6845832e93f02c29fc71c30542deecdb7fcd29edbc6e0a1e246de1129491c2804166e6c8fad35935dc1015b781acf3cb9e814c7f8428bacb337cc54c336adb384649e83122fc08a4e9c926441760a72697f5ed3a70bd437d2026dfc4d7c14a388ddb9734468ecea969c02a92104f0bc264af0a32cef0a237b32030c0972b36628e9eb9a37dced321c196f67650289e45e95242e4dea5807524f1d566442a444b1b0e2bd4399271f65937d325ccda704a49bb209bbfbd6969544d15a7d8e7f739c86e8af07271f1c937f55c4297a715d6c6b30e335e729df1d3125fc009e8c7a9df7fe0ba6ae9d1a6b1d8648a36d61ca27d4d3f17e2360fcb454cb439b58d547771c41be77308c03a3281dd8786dfdb40043b37479455e6cb82896aac4113b3247b9d092b06eef59d64ae2d717329ce0d10e325c3398dc4d1cc3d7334806982cfb5a4420084800e1469ca3c6df03aa66741d9cc355383e048de5f2537328129d9222307e76e6b871d1827fcb82fcd89f1b5c76d5c07dea35ec81036b7dfd4c4f494d54201b9b1f5556de2bb94dd61f89975b2284fd6e6c69100339655f91c8e16c6d585a11eb5c654f0a6bca0a0610b59f812fabb4d4c79441430b7c694820b2fe2fd34a764f3c4d9188c2a8d223f85fc1cbdcf6893b67dea57d91440e3cfa59bcecc7e790bcee2883d3facf9a370eff98abcb4eaa3bb8a166e4e012e2b721fb6343adb204c9f9483420a3de1e522a830ef50022074942d77235dd112da7d70127b877f93e78e5ba956d5f895a7154f1b101729656152d93e0dceefb7dcbe9f07f07829deaf8c9c24ddf1bd3cdde02ba2abc417994517dae72dfa73e859f8ae0590d0024fa3a123d989279a1a2b255dd7becd3d2486880213327d319f21d5ae13ed643d322645fc987baf3b6f6f4e701d188ac806f80aae05ea604aedc0504c822300239b9c09bf88c90e60cf4158b889aad120f02100d3e8229a7347aea3b1069249c59cd6dca9afa95812ece5c776e1a5212231b8644debb8fd8c4f9a8b6f8034b44c6e359b464ba3ad0c44d143f2f920f96e7313c56e505582f8d5c52a674501d6aa39dba9b8da6f170c560e203745af715f1406b45683a1f2f3e5a22694fdacd40e4661de5664f3400c3921e4e2c9b4224b6122da6f44847e50eb50b1ceb891df95d133312f66164848c22e8a2fc644e86737e655f7dec753bbc816767663252e94a785602363a0f94e5b44304f2bbb51b619d463c479bf2c759bb7477975c896646589a19a53a78f8279870f7df7fe858b2e845b5ecd5c83dce2ec93a3e99250d7956e1fb238421542551d9f7b7175da18223e6048d613aee27546e5046bbfd42512e42661413ecab5cceff7a4bdfe93d5fa6b8911f6c101bc93250789b28d013788efc4a9982ae0610150754772ee7af6839ce402a79900ef8dfb13042cc19628a81cd865fa1d7b645303b4139008baa66a17358f0c66a40dd65f7df7b4bf93b0064694dfb22c6bbcc3dbe78bd39ec92ca6f6c332dbecd0f155ffb432410ec504e0d21933b515f9f382c91d189caab8d28fe8fffc725bc3e591484c2d3e1e71f382aaa2cff3609d54f030be24212ae7a424f148253549d98adb242ab79dfac49fa2bd7ba7ac77296367dbc7373c53dce9ddc03632792a7ef1593ca1918c1104a568eadb631ac46583a707199949d3f9284e79e876700cbe7db1ede46f21d3f34c6aa38e0c2f93d5e902bb18a00eb569c38d358a7de69433644bae47d4eb053076ffae2eee91e28f7f00ed31ce8f100f7e8c8e66c1449935e2a39d0284886c79cb3112632d7a0f6d381bd71487409caaf821e4d08468197fd44a1a06c71a09150225ac752d806e37c861fbc5753317bb131657a5a557c1bb57e9cde1ff2bd75c54da893af8d1e4d6e9a8b5b379b99ef9f197df92642c5510c9e154e1d35ac09ab426d5cddccf59011cd9f34a6ac36c49f68618256dd45ce0065e3d65dff61443a19f66826b56ecd8a81dad23a5a635631203fc29c322de032216bc177c35cfcb0db013f99ac0bcbb88e9d2dcdacd0535c3a7f010f3fa0796c411be74f824dfac0edfce899114c66b298f29139dd6642eee93d8e3fcf163eaaa29a4f968c0f59c5fac44eefab4ff514911739f6bab0be7fa9f33c667af4ce87f18a60313b32be0b539164fec40c64b016e84019db5f3ab757f64b1b6977b43821857cbcda7d4e3b363bf5adc2194d2c71cc559c58b26d1a3bd0d94c17733e1ea877691ba576fdce88934668f8ce770385386707f6829832f2e14301afc328a89f21f4172e6f338409f813645a4528cdac0e74776c5e1d2fc1208f880648b7e51e61d6d29a0b5efef3469d3655747208735b1de6618575255f1c24933b0b6533e3e3628eebf22920d1779a67df880dd2b65b2d0cba209b7db9558c4fd1acd01f777b87d2f37562a0fc090bec45e5971876109d124cd420a12d46159db2a9ea6d0834deff63ce9bd0dcfa1d9ebc7a748bfb4588e5ba75f2928b01682eb65da1a9c5817a3642f16ad3712a068212d47ea279d64adbe65b004f428f6fa6e7c0a79466f3bc05c7064144789d0f6939ffd8c5d1217e058e0324e04f457792dabf0e970003442a4c3d5f0a02fc27e20b7cc087964e0566c9ff04ccae049c39ab9bb793c160cef7781d203cedfa1e53a7eeeb93dc0d2cbe461778c9632516fd843e42c9f33924f59f3bd6e207a296665d44da8792e4a296ceba80dc7632b7b2aadc17a5500d34e9d0af3c9d63db72b30cb984fe0768427004cdb3b90778d5ac2276f587b857a542ba357c45517f22c3bac18536d510c5af749116a1ab6d367f14df816d0f2d1f739fa05f6a1d9369c490d15a2501f67cb62dac8e1c1f3cfae3d0db7d27291a05786be610a871975654d1e035d89d00689cd6ca9ccd57e0ce5bb93cbd48cf32f19e6f0afbb9b9d7d18c144b21a7e485fc42c16e5e0136e7bf6d2bac20a530927ac946f830bcd80246b43660b6c98efbc49ebb119f8741a7f2787095faa7a8faa27b5edcb0a1068e2e59e769f39ec1343492f5d8f6b5ecd7c63bf3af4cb400b73e02d73194921f61652415666d30a7d06e46e291d8d570b20966a3628df0f3d93c375e44a3d1dd2aaf0d2db3ee41d2e33390b16bcb7e67aee256505cd72fb7b3766601ee89fa1f19263dd990928af9e96b74724e333fdd38ebb8988eea44500e9b0cc405962e8d0e0ac52b9565b13066b78807092d787befebaaf52fa06c4c3aa94f314ac4b40049571adc7dc1538974fac0f76ca43f30faf2bd1598a675cf2f127a565be2b7eb8cb4c2907412c9f8aedab683d336cbf26e9370bc91e4af4c96c6c9279a247a54005c30f833ae6f22a747f6ec34c226148dbe0421c04c1aadf271338a72089f3c0570e1d48572bb9f7a5eff93fc9b8482a55a187d73d8f23456d046f2181005adfbc48179c242544afc0e46d82f20f860d777b4e8079a91c6304ac994ae9df4d447c3bcd56dd04d14d2389ac5647c7d99b157a6a90b156b427365696d7f81e49c52d0eedd51a39584471ee7006b85fcaee5b59f0eb20e6be175d720ed0de47c5e2aba18df55225538599ecc6389c9a79acf80b3c8ef90312d98457a58c74a49fe97192bb7fff9028cd1a79c078e2c59a581e2403286f74d03b691ad11aadb75ea7d571e2cc9a162732c69c60d6e9fda2008eaefc192904584fb6d8d40671c63d1c421a9bccaccf8097942e3a6a108b92c378bbafa1e29db44f374e7c1483714fc38641a1029f878f02cb559b3b2d588a0e6df7830c9ef8b6b8bc8d3539c36e5026a6f398f723fee1112d9bce59fcedf6f5df984e25bda771023ca6ff7d68861eb6bf4232044570740bfb1509e1b801af6da3455831c158971a8e3b8da51afb5b261d624f21f7e1467f5632194fbcc04ab296b10e65b52600e51dcb97594c527017218515b4cb9f6b12c6eafab68472dd0fbd83e4dd4cc77abfe8e49514ffa1be772a5cfb28c179b3b374630bd4e67f987e536b67602707491419c23acf638e931bc7aba0a1b785b7528490a4e1176956dbfa36fbb990aeb8c183a7e6e5f2d5a23ab2301eee749d919661a1d3bb767f7c411a7982f2bd2c1b033c53b45f4a1b71dd0c9b5732e6fa086d1d48114eb49e8196a0904317900fc74a22eee8a4907ab029a9cc1249b10a641820fc665876a895727de35facee55157d032a16adb15b44e51b057c352f7388154c85906da74b9a576faf0130e9e7943d31c2773ba85a14abb3853ec91b9d60848339d8b7af11408f97aa75f1578ab9f9aa398b3a19ffcec00c0465f322f6685c82fbfc5e00c810e56b09caa93635c4aabb1d6d2cff8ce61183e572c9f07f249a76363ffe454406d445c64e71b458d6f9182b588eba2af36798215bc3a4b164758ecc3150a30348a460f72b9214f2da0a384e695dbfb464019f78be2351de23a0206b82f3261eacc48716fd97e1a259a7c8e3d4f64c8cdbf181967d8215960bedc89876268530cb422691a0e9922944eaa26098635137dc94c7a0d31e3d097b9ad247d511485ac8c0d5356bbb93b1b42571fd270c44bc02a2f3e9bd5f6c7eb3bf035d6fe3ac2b692b3df13c507432cda29da3a85bbf40f026088527645a6a51608331edd880fd013165668aa0ac28929e13c113522e742897f296ba0a0ec1eebddb94e26bd58cd9c63e1b40db41e541031a750c0d92201496af598792e7756745507e5c35fb37318e41a8c47759710d2077a27e7e3d1e63095d8e8ec9db923e740c0911566f7912ef841389f98b6426a79ab7a9ab216b602ece2b3eccdbabd07c00f67379c57466488c321ec7ec625b9a7c2e2786cf93dd8cf16d87395d91ef4863c76ec76dabbdcc89b09e60ba59f1db483c143408b09d42e806078ed0b1ad3b943e0f45835507a6497cb62d4d173462dcc0104e4f943c7776bb89050f5796846d732f4c3f4b1d32be1c673b1385421c73f588b2ca6f5b4ce3d2c19670c1ff0bb70a4afef644dd82415c2a7beec62506fb0bf94a60237d1831bf5d14e198231fc389a48e69a2cd8cf7f20e81d8acc85a0d1dba3ff9ee83b5721857493615408480c3f5369394baceeee311289569a7886ad485dbd24073f6f220ec9f7ea9825d1c6ecd1c8b736ffdea123c9defd7e8d87b394d1842690c8f07597293ad56f5f42fd4149fdff58499811ba8e36550a5ea2450be5077f1c17194914241df3720fe85a8c625aed246434f3942dad627739679ce77d1c7ae007bae18edf388ebc592636ae0578d28516b0090a3e47c667e0858a67841e6bec3d4d6c0888f48e39a2aa97faec2d5a8880ba2e4360356c86907b40a70b55b49fc62b9eb0ffea090e9deca9e316903801fc4fdbb2b6ad7028921530da082386045604058ae13f4666f8a31b2c0e91c1aa3ef562b05d9a27c8354e8ea30afcc9ac52ff859fd457af7ff830dd097aeeec979c6d13ce72576d4ab7c5a1d052446d67e7f9d5007de74a052884e79cc82411d31700e874533a53ee9f9028528905f0c1b2724451a43cf7fd57cfb8059d2d94684014949e707421d78e37389124ccb156c3b64d3814fb9381f74799ca270e1ca359f0d706d393d67d7370d2eb9979d3b852c324f849253484e4d69aaa72c905d9735b747ceb8abf9992d382bf33b19cf1e4e64617de0c8d15eaa65856ead83358e16d1099748226ea27cf510c834004267251c8e0f2385fc39d670e3124c014f014801b8c7bfd97c7db590a80aee0275c3574d843ea499b0b7693d97e727c1a6fd6760cbba1b0d2454867236f3328bfb91fd2ac8053991942774967efc4b22489f91a3ad9df95157ff6c79cfa57ede3fe995422b55e417a0e894ace566df32b14a2373324deab140d4daf6bbb02e9e170acb1cf666422428950a96690ef55021e41db20cad4b63ea99a44fd4df50413b4e512d10f8b8eadf30694ecdca462a25973f135966b2fb46474ce04c616ae3854373ba68147e00b35aee5c144db8dd4c5595767cdc63b5996716388131edbfdc41aebaf894932f98cd73010c721d411d10dddc80d893bd388035ecfd8d63004b182f4d41c524d255cc241fca63508a8f0155d71d0f8dcf35ed856a9ff53e6cdea602640fd417a83c79094b2c8a47016e00d1ebff43b0e489aa1f0fb2783d7390cf607f54a740e65d458718db0069bc11aaabe483e9ed5c1aebf4d9834167bdb292dfa6f9698fcdb3593448b351fb2f0e072421e8b4d412ffaa545dbe31a3cc5783e18085ff766cf4af64be2a97db4d90e258e35f2ff336a40dd0e210ed2f58e5379cd7d8cc9e1a23fcb13fc1bdb0e5bba051d59641189a578ff6e74d0a6a5fea0a8582bc9a12c3eb26ad6a47ba8ade197195b76408a588efe7a83cc25d3a78cfe9af8e653a5b1f1369bc10a22e63921726ed741e1ad3ed76cad786bcaca4f583299a1f2266cbef9a42c99d270c32d5e7424e623d1bb430f2aebcf8a30eded99f28e53749b40ff1c19f4cd0f5d9e79d125b38bbe1b195086e1780616a72bc66296a12eba542d34d7a234d2aa5b8119e337b9795c6a7684a78baddf6b7c3326dfbd3c1a5c13663ace5999f8fd005b7ed083392cff6b721b621ae1e98e9e2005aedabc6f78617033e8e0446411ae20b7e2b99c6215098d93b86b2a32109ccfd8e3dfb2ec27a55df39c274f6e4abeb49a57298385884c2840444b66b450eabf0104f358c770deee52429f373631b9e6b001092db41e1348c828a12149cfdfb8fa2d160e293d1e23ed9affa1923047713ec10ae9eb5789243935e11e47d08a0fd3b1eed6e7fe9c163d09dcc7981567967dd2e1fcbbf1d35f762311abd1dc74a16cb5089a1e393ba0bdc24539110b3e4d9e9d597fa588948625023a067f96521c55472d198622e708f8eed7cb86f6f14e7d5593ef61795cbffd3986be87e68aa7fcf36c12494bdbed2d008849929d07542fad07d130cb3cc0f60851fb369074a21f5edfb14d5e467650d3b3a42ea8be722671fda8cf3b9e381a699a742c871670c81d544e8743fa93e205162a3d7537738e38c8d24a0470f9780e59579b2851cbada5ff665c288c38acbb5d2ac8a0b7ef09fafea64808c8a4c401166984f4e5783722af64bbfadfc87298ee1983e68c1d8bdee4b19be8a4a1dc886e014f5428055dfc894eccb2d01420194a03b183f3cf45b743dc40341f385423937a1fbd3b0d1fe59a4a53e0ba1969175d684159705aac0126e844e99683978195563eee2ea5954ca747e24dc488e305a7be4346e7feb5d6fb9d5d0e5376844b66e0a223a4202f18a9ceba1e87122749f9b44aa8d32b1c8ef27252e261585f56e389323ba2143e6419404bf019295c5ac867a271ce9682984f3549649d67cc546f5d0db9507dd6921e55eb43f747aab466aa197a4c300da3d7d910b5ea99cb978321070e9d5d0bb7114020daf0fd4bad52284ec2f0c0c7636b68f97afda05e033fcdfe81b386c5c7b44969e5d3b374e3ae9679dc9bf33b56381106c938081a11715d9ffa4afdc33389f3151d0877ee5b618fda895b8ae6a6bcf4adeb712f0010eae03ba263f6f5f905925582b087ac1da47cf60894ed3732293fdbbb2bb1a5200792ee36fc72b9487967526be0b26abbc059f40cd415b1d61f8075137308abe8b847afb41ee6d0ba0d7341429d133d0709f4f77c3304aff798db460135d59c7b0417b2d59578f0c672c64f77c83efdaebc0f3ff51a028dccf370c3e44030e9dadbf0214c4e438902143f6450cd4950398c5f7b8e0387f7ec332a1b5be0fc4901a779410a984aacf4928e0498c648bed89e89e2614177626b1811b302bac8c382bfe1487c4b0aa6a7b98965caed6bdc82760139bbe7aa294ce102c42cf29dafcbc2bdedabcbd77a8087018f5f2460f3cea71cce0422c25e2fa047ecf3fa91303041be3ffd2d80df5f4a00fd8858e996400f86dd77961c341e47ddcef99e5bbd0f1c6f23e8e61880fd9f02b89c45cbdd61e33e0ccc5730ce6dea59d2f3b68e6baacf62b0150844bad09a3da09aec5f6f0a4383ccfa6b7ee52ca4964f965e47af7abf5c507bb8babc22faf41e7f739a263d6d2845336ce02b5f9e8b264a93c7a341713b6e9273881f5e5f73165c1459ddbcaaaef843d661a87f691e7e1743b101e168c3781f1bb748129bec06a69b92e905e592691a421d1ccbabc81b1395fe0c027f1666097334c4f994bb9a0d6a8a4a14c4c0b89c288c5f4590028a7a80943c131326c155eea93afacb528ed2dcd2bac87dd294c1195302b4710d92e9eba47c3c290a0a26819e4ace23280d99e18fb9210f72bf3eeb2d30da1d5067afe16f26c0f2e096d9f624d08c1f437c7c8163c173fa8a0cf5d5ea04d9ee0abfa3fee0e9bbd96b9648f1e0870d7617af4ca29ef38452889135b1b990d533b696ac01ad49782f6965891a92e25797c46200adc2cdf441b78f3f7dcb685dcead995ea65d42bdc0ba052d030d513a241d58ef93354476b2eb30cf722f391e1ce10f2140dfb7b6bcf13065f7ac011dec3ff7ca76687b8c0ad3a7540599bbb6edacba1bad9c067e8c3c1b7924e18f05bffe93885a8358759009f5b082f18adaace0483493725af74c9c27afaee436d6aef513d78599e0ec47db390225d1db9f174e1deea82da750312bea637c4c5b5fa6b7efebe3fc5433476514259f12e8da2373d5038aac4cde7c90a63b5364ec678ff284cc1afff5eaf129bdbc81f9634c3726acd7ec057ff5435b63b5dd2e0cab46899fc9f0faa37427c064c4b4dfb56afb6f46361a04fdbb5210564d5a103ed2a0bd1207bc4ceccdae4d1f2311045f5a16f8db44ddae355171363f4c9da555a2ade37fa5727c6b0b289e9bdb14592137a036c8a4b0304375c4e29a6de6337421239fbf74103cd0fccc39fa11adc38f47867baeb3f6964c65df9d65e249c0d59387120e5cc2183eec11f386886ee0e625e005ec91a7471d96da02f37db07c588ddd923c8c1a5c07efcace098378351aa0c99d903141339e1ce34747bee54eac3c6dd11b7c5ccc46b3354e9fa1728fa6f55acf289f74275b32cb026dbd9fd9987a2864376a5bb459df9e85c2745868f4b574ae0cccffd6c17911011c8f89f270e719261c572a139c50f0dee2933cc5bee23f8785c2a8f8d4d7f8af93869d9cc67fbff46285a4bc5450085e36c19b093ecf4288408313bce235b3570bc6fad123e9a4bb086c6e55eece8052d2879c4a064e894ba16ab19017dd65b78488e6e8c793e9a60665a515de1c7e699cee540f4bb9b5daa7bed1eb43d09dbd96d388b28f381171963538bf4eabdaf81445eec198231cc2a05e18648f507a82659912b66d55edb9899b18822eae9429a576f12fb8c1084a956da08973b60364d71b0138a6e2db4306bc4dbf3ad6ecacd57c0e9e1491ed1554cc43ec1fe74025d55fb1f078f394c7d8cdd8945cf40667736042d22064099680edcecdd5efe7740d62b750db1d7cbfdf55191c70938d0cf77ac4af6b5b6fcb248d7103b4a212b511b4fcb65814d33f14fbf0f6394787b66cac663b5420ebc772dd6d2720459b1778fcb9275b82c2e8c401e2b394c742cd7101e7b3c2079ee4c5b74eee40f57de65b9075c324b7f010c3fe9996a974db8dea624422aa75332758c3d0db2c4a5b46fb032ea69a706ce07109ee4bfc074f0c90050fb9b1c21e84cef7c693c2bacca3ce9210a6856fc797249b158be0d6da5445bbc3df329ee1c97dc0fc9c74189d1a82187a6656e74cde17f8a16c29d8088e4f02fba18317ccc1a08a8d2ce7304c1dc44aa30a9db9314d596740b9f2957482b9a6cc88a487b5774c1e162b72c0f34648b57e2f450b7be9e6de419a1c8ff457aa2a25e94418ed27f9d1a07427432e6b89e1db00e9e4a0972714d2bd235ddf175225b4916962c3fd6b16394b62e6a0f0fd5dc376d0e95494c29b58225e47095d844b898c3cfc9ce1b7e8ab5133c688554c8dcf0523079e464266231b568e78d987db005f0afff7940947cd3753e6e4a1f727ae479a5100a1d4b1f1ada329e1c64e78d7767270dcd43aaca5de47cb5a4198a188232aa177da9cb0d6d490dbd0c16de3c9edacf388fd3a74ad45b25639392324d4aeef5b3246448384241f4413406687f4673d520e00976d900e6a5706f93a1b37ae26f290dd2e2e50f24971f312e10f7f0fdffec55ba8d6fdc98d13427c75b7bab1bb75474ace2d01b0da032ca65d79ef8b8a942ee122e59eba8f92f62bcc016bdff0329f47cbc293ddba9a7b4baa8634428fcdd34ae4a2d50abeede86b5341178dfa3454ea742f91115801fbf530e6dce2a0621fa34a8773c67317dd7f814acf6d87a4f6dab97a8b7c95af4cfd6f682381ee7ae495b1a7fe85385762ddc486606ffcf8db3b33eacf3e46344daaf318ad137ce20c57b29fcbe311104edf7db03b15eb7e2f8ef796511b737c11e9419ceda80df8824e6ad8a201fdfa7ada0f033ea5bd012e2892afc033aebc091d98435cee44560a3cb0983f51cc4d6d028745b552bab3463cc7605f0ee82040b01259c800c672077ea0c0fe767170c7825c889233118e1eb0b8b8d16851b9b250167cfb4828538e0cbfa140e7e75618e276f458db280598dd290d6c0a525fbe502ac98a0483a5b8b044a956277452f5d6454e123406c451f80ff92f233a3d6b6099b168f6699bb8f6363d71856b322b106f29f50e20de0515e363a0708828ae30c561f9888372d1d8199eb18a6fa785b7639bf5dd54cdcfd626e3df1c886c3ac092deb188f5080ae5e90894849a89c1af41c5d93275960e2707e03c6fb39deec7753dc67379a428f1667a0c524de72ac0042170f9b31262dc88bf094baa1dbc3003e9865eff1c3463b3ce534522154099112b5ceb7a97fd083f06fead0b7e886f101805b1a8ea0d5a4fd8eb59b8f8b1eb46a7e4b52fee919e1e0ea24f02913d0501762d60eb9c0db1315498dfb9a23893fc936213a5632736b599009dc1b628f3d3448c1694357bc1800e65fd1e13024821383fd6af4242643647108b21c6c1e0f881681edaf44b0f9a2fb8fcfc458aaa255cf08e58524c2f63e1b60085692ff89194e85a99caa3424b1a0830111abae98ca5293b697d4435d8c8f4040348ec019a316a189d5dc2b9d7ea5dd24d603fe1804217b96e1021eb9ea234e9f984f35f236de1e52f19571335f6c605bd9b8eabea990abdcd8461edebceefc3399ed8a27ffd6885a6c37da577fdcfc5bf4d9ec64cb23900a14fa2b26affb82653abee94750b1b1bf8684e9288bfe4bb167dfa992eb90b9750cc74dbf4577614065872d95dc3c4fcf605a9e1e189975fa4346aa32ae696ee654cc2d97110f81de8854a74d9a9bf7aece7bdb343acfa0beb93c0da87e7ac51edb4129b54a2c5fe99d8bebe7bb5ab812ffa1219c1646ed590479ad04e742ec683982cca8313965915f15a1887371f5958820505fd4039b1f4f473b1d4e44faa902f39bad210645f675fe8cb10258ecd10925c1041076c202af350f590428dd23ba182dfeee617ae516ba3202b715b5c7565e91fe702c1501c78f94f38c1fb8b8a21e1e5e716f7bb74d123c26bf29e6e6e5f6a286676bea8fbc698b35925a74495844165dd982e12ceee8d59437498ff41754557789a940606d9e8c273260b0c7f17e20f4e11419e1916d677a723c3469f462921bf3ea8152215f15e93a56ba714d5b801c62fd59920a5a1abec201f441eaa256aa036d7806767822eb42e51b3047c8dbc2b36d1354a3fa2352166b267d4c6ec2e53f5704741ad3a005a88f707b572e89ab50d7ca7a445c5ef2290c9af097bf39e5020dc65153c3485217add14a4b361b680ee064e2061443820042b65f93248ccf808c955dc23b4e0f71f518048c55c983576859fbfb36b918d38bca5e3a6df4145ee3a63802415278d25668e62b0523cb84be5d3f3e0f0d7dcb4f30c4b54a17e8e51c871159f2e0ad7e74363ba897ccd211e49d8754064283921654a8c980f65a87932e851eb07473ee975a2352bb8b95befb6c4042a55a2eb230646d88402f2f41b2c94ffb7b93673a6c856c5c7f25d03ebbe36fce15ca9713bed4ade96f7501189b5de49888a8c4afb0f38f0507d9aa78e207d6e6d32aa48397c5c4b39a6c39481c9b782d084d2f5d6a2c143f51281e2c016e92171b6dd777f7d80b20d433cc3a3e38c205c69538f4b591e59f2605f9a2df0709089c29ed95dbe5c61f687d9bed4c80103c193ca045123020f2eb29c1cfa897ac3bf0f08f7b101e0b9040f80e54a6cdb606101e7df0f7aeddcb0d74e3d9d4aca8840b90c017ac67b32592db27d387de85e4267e7f99967fe4aec406151f7f4a6009be84f5b4679fc1e31d16fa2da71089bd956932fa96d44a9a3ca17177b7331a84c547224d86159d71f14a7d7a9050782c195da582d73c08197b083d6c1d27ad3f1a33033e4abac56770df15f334beefe02439a201c6307e9f1e0c296ae5848a698af0caacd065506fb93978ea5851448ce64d961c9adf1af7ea9812c4a85c55b69df7f4e76662365efe82c74b1e4fc67701e38dea185c385999f46b1c8d316fdbc3386ccd07342200ab400d5ebac5f1eb4a5bb69cd1d7cbda3d38faeac4e6b782c8b005106e66609d639b481051aaca8ec93f8a3d51045e4975e5e5a1f3cb3f7c88ff33cfe8a4d3a77e560d363e366df8fc204648732e26fdcb2aca92792b79017e02965e66df8cc5d38eca41109829f2dfcb722bff61941e1c86b67a1395642594f3ad6693f0804ad5dc5413498a83e2e73c79ad57af61b99d695793f901e5d313f1bcba3d4242062fd1de0e10a33cc97513db5d42b18ec6879570e370192476feb38f6f1f2db55c074cefc62350d4d0f8fffcf83027a46628ce785b32e838247609b32d6022dc9d9120f9c9ba60795b2d574eebd367ae46c7c89c89b24ccd74df77e482c452eebe6b1c41ec997c662ba873bc0f722004941db61fe7084ea74b890ef2835ab3a6f329fee7bb9b30942c3eac81b8fc32087bad9733bc26a583b4fb595a9e5a27335b7d5862c25ed4d9ad64047d0c4634592444b62d6df3c0dbfc2c7d44dfd3070494b7ce957e4082d506d8afb918a7fb0f61cbe30b9fc91996c2bbc9c5941418ab471f6228cbf2071d0d669073a842a27d9ed35370b4fd4f570466305cf8a0b13730f967db89caf1adfcb1d974c7cbcfed003cddb49200c7e0657de860f5fca24d026411fd250639fd3c9b74a43c583d5a52fbcb7d88aa9d7d6f5093635f8c8cecc0d8fb8072c06b0fe125b3b938282847775bb2b83b7df608b2288e735fe16ebda3904ebaeb866ad5ceb91c62a32f65b9d9094717aead0c86e668fa0c15db648bcf7d1a51b84cfe6788bbf9f3a19d0f3fb110676fcb80e789231b6548cd86c77dcb6e2a0439e19331e76ca99c943e8b7c6699ce5219f71aee3f8cb7fe648040230a5cf692cce0cc990f535e8ce4a7c219a519ebb9001b346487fdc5f05e279930f648c33b935eef326c56d22cfc7ad276a7a5af109592fc8a8b154dce3a141c620727d8b5b53faf6315989a3d5387ab2ca19b7b435dab51a7b0f558c90b5fc08cbfc7c1fc7810d134fb89c753d66d6b4cd0538d0ba53484932bb43a924edfb342b71cafaf43eaeb6bfc6f7cd0b40261aa28faf6b9b8b86150fdda89de253452aaba70922e8c77ec0eb1eb5464c0fd56dcec7fe4ca78ff192ab222a6a71fc7902a491a89d906d36b39044e163777e8d53cb83168f66b223752875210abc04a0aace623f0457298d9ca8c1e0306ba35c55b12e99c23ac96b797e5461d5abded4cc0ed6b95bb99a42e7180b01841c544b3108b1b5b079f1342b9d078fbe1cb5913b668b6208ae142d695540188750ddb245c1c402166251b0ad74d7fef2ed73eebc03dcf44f9af6ba0a181df0bb600fd99befdbbeaf71745a129e59384c9b5714d085b9f2d5be42baa0cd61ef3f79d605b239f59078f73d5cd3a4d0e5ffc3de4c050735e66322fc767d4eaa42b45b10085322660b8147bb097ddc3c06170c0c2389b601deab93a6807d76462055e851bf64d8ee0f96e048cd43bc2213edf526831f56ad0495da7fbf8fb5ca10d47145b2cce5549f8a668ee008c52598e36ba08877f47a65485a4f3b65f2d76b091adff216b921296630f4b1e358c5695751bcca668ae2fc9bffde4df869a87d5740020b05b7383a552540b283ac6203a1a98eb0dda3ed7bad68060f0c4d0aa679ba9f047e2ba3c9c9c8db0f429ba11427edab","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
