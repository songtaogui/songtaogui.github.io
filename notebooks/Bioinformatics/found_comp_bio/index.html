<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9a22bbc5d40a17fb8e8d48fe7ccf2544d0f8c59b448451de5b3ed82996e70dfe72311fc16a65f284fd3ea76f2c85acbffb051aa6461449888aa08b90df4772ed5a2706c3b18540ecf4346f8502b6bfd38663103fad9e9c13872847a1c43fa489dfecf93e070bb77d57411ece38a8563ae838d09bb94b86539195e31ecd2cff382af084a48132d24b998288b745b0c61f116a9d5a61f3d7d476f66d9481592d12582494e8d2a43bf2e546d2cee10ad9c2c2b5be5bdfffdeeeb5ae49efc8907f91ef862c6e31774430785c881923b9ea37287184750c4866b41ffe70cd089d84a9e706caa24aa89fa41a4da6c227f77b0671a005c180171ddd5c802363e77a7150f22dbcb9f33d1c2c2dc546fc93ddea80ddc199a49f13b8f6a3c323066db4d53392141f1e757405be7efd0cf049532031a992d9514d4cbc1f04d0313933736e975eb5186017ecfcaaafebb6323459d63a8f9545d8fc97028beff0853024fa81ffa1808cac82221c443f105b35de52a03ebdaf6baf96e0074477f264c93c3d3258ae7322f7ca279f413cd112dd78f2f0cf65ca8c0d8f131c130ac9082982bf9b824018e8f82fcc868bcb3ab671e11a377ea56fe00b6d127fe2efac5499e72b5a18b5dfe62e34cd8f3b6ba9c0adba51028aac154092dccd8281eb14b150b1397e7f6223d18f15df2025a1b3a90d4b875c3710b0164b40de6138e4debc94e5592b2e6d8a687f094d13b950afac60b56aae4879c87f33ced5bc444dcef85f21b1617602ada115ed261dba61e10167f513ab965fb07dd25c3a9c36405065f1ed176886306774b9c3135169d2050d82ae9316c1a58c4f6ec1c7e7d8212fc413f986a81820111de52bc2895605610d3a527ed3cf81a0c4043cf2c6467022005bb3046fac2ff17e1413829f0263403236bdea748c15b261b8776ba5c98b366bcb736258006537b9bfb31f1d805471464831a34c84fe77b4c1af1ac9ddfc436f8a6bc87ffe87104863b9510cb01d76d0769013dd3ab43d4cfe36e96fc4819fed0b7b4fc37832e4de021b93018da417c96a9ef3dde2cd33f2107c25dc2688db7e982a561a2a4a6497d96573b1654df63c8dd786cd251b74dd7e9e6bffdd35799c33645a6bfe0993d5398152c8e73e2f27ebaed49477fb3626246545e32a9cde63030e3bcfea635506af59d1928f27136ba1f604e59c300b103b2e4abe54c8e9f0f8d194b138fd1860b32cb30ef909014b9a9f4e922bd9f8d34350d2c865cffc03716fffb2ec0d2fc516d1b3b678a5e234351aa1e851737e615009af4ecf225eea5a43d2ee469f0ad7185dbcfcce43083276522a9b61cffe9fab1345fc59dd009efeb6a7fde95116925816934e2b3e1c9e99ac45fb948c3d9f0773afb373388afbe98b2368625bef32a745c0a36809ec37d7643aa5e6cca22e16749f9631b9eb5597c584071ae9864cafd485d48b5b5b574b90eba93177591f6cdcac87f25bdfc151e12e3c062dc5f4b9b60ec3a0b3f2db81e7b2192c6e1851f72edf4a902a6ff860397a0bb1e4536e88e651580e358850acb33456920a3517901524a0c157247950af3c650f813cc31a0fa35af83f107b2b25040a24e2b758739b5f6d16da4f049ac44fdc2ba5e73a0025e5b9e17691866589d7331f3572d2bc4f806981f9816162b389189dc460df9d5ad9e38fb76e68dd30a6a566809cbd5a34367b7128c694808f1c1ad3297478b2a6e0e2c0524306604439bca85ac990f7517c87fd74818ad5c574026f2b84c38c4ef20bf5d31c44aad4293311936a7b39095811d266d568948925e55976ed4d563775b3e6465f666164e4251c5b3d40e2f5c11d8a91d6143d69e99949de6d3941ed61288fa9c7d6756451fb240e334a3169b5a7dbdcc186a25935826c3a0f5985d44c443bd46235e4daf105907f1fd31bef304b3cc793807fd9408ed461af4357145b431824f2f25ec71456ecbc16c310e19abfb61567718b1081f6642c9d3725c6f114ab6ceefae75ccc794270719cf4483fcd844a9fbb450499a2a16d2c0c636afc0227a516735170b98ec45823e648be1d623e6ba6f766b04d92fbb4e430641d924202e99e92fab8479fc682fa7d6e01807d1493c3ef38c2067e978e300ff616772467ff8d4dbad61b0edc15fbf8e892a5e8cf697e3276ff18ea9d94e8c2114843cbdddce48b6dd993d4d1b242f3eefaca540373f01df6981d7624ef580594a057c032359bbec49d2ec211f70b0a121e3f17a69e0d935f8a877fa6e3686bee2cb380da293866b790e2dfce8e0a2c50ef531779a42fd2a01916478e573d2c12823283cb93596182faa95f287e577ab7f298cef50c4f900163a20f642d187e9b3bd8f216555778e6f94cb75a92edf0813c64273ccd8d2bf7076d5e7f6c18d0c30756ba3d9cf33ed051f229ca9ec137dbcd77ec5fd4f63248bf8dfc8b4aa278c694d4d269096f76440d6228c4d600d42a819929484917640d82685d4f9495caaf13f9096f8231c73b35660c45292b4d373868b48ebac65bae01ad03754064dd4175b41507f997e2a6c7e37c073d48ba3197e0b343eb528144b3d25c66e53782236375e5288a9e78b0f883378644925424d11b1942fb9bea8b477cf5ad736c86e49260036a37bbde35e841b32efdceaf66723f28a66ec454c42be547630b61ab277cc4a51fae6f5cf8e692d3dc2ec59bf2608eda733534a43f79fa257a9208fd9a3448eede9ef6428dfebc451b85b5bf2c5b1bc81e35efd5699335f9fe8037401370906b27853963b03aff44dd6cecf5f7e4d82a01f2392f509e91c35f444c8ce1af3079051a1a16828011acd3872d5eab7ac096225a45518a4a50cd198df4c61a24746bc77b17ce3d26229b06f389c0f3032d9b25a5403932da85b07e7830e8969e5aac736b01d413b2d4be374c8b38f0de7a58f3a82cd1417f42252914084c0beb2d56d19600278fbf65bd86bb30de96800cba8ef94b2da666b0aef584ea15ada5e3aa70cea3732344a68343da020814a2c5b045a6f73ccc843d8db5f52b1390072733015e293cf8f5796feb9bb5c799ed18135c8751df5650fb95d2c38fb7ef56bb59b0360c096fa2802916005075467a8fd3424f46e9abb85aef559b913bd567348659e36348e30c964aabd6875024833866fb8cce2c70735accec5c0f492f9a1935ef0069cf7f02eeb03b8a9309359224b36bf0d7062719815eaf086e89a4d6de069d9be4b8bb9056250c1561025330910575be0cd321e7e277d85451d0a2b2217930906272fc7c26d96ba70e715383849636580518173bb3a2b86ac3b9d02cad9f2af9296ebbe05647fd253bcf3574ea8a09d6ce35d1b009c19969c65974d24478e6e55d92c7039781273819ef91bb965ac332d4e9638a70386b835ce5e20f4b2451fdbf9a7f9dc399bb874f9c4ef38e6dfd321eea596cb9ec64c9f702c49475718dd8d7993c339bed8d7ed30e3b587b19f4d795c497633952659d30d40720d9ad9e9228a20c78cf6298e6905330e5f63597ad130d05fbcdd1e70732172339fb83a47d3f99e39d971460753a3f4ec860ec64a98439a5f568157bb992fde4d537e134dd4b35dadb657fe4087e81506deb7b637715bf1aa339348f59d5f620a94078550e143a69a52f81dfef03b5dc5e3d004059dd327cea08155c1a20a5cf79ef7f280e19244662186dc2eaf9baf0c67b8c1caaff6a18e2cc75cbef1fb5bae9e55a2feeb99593f19714cf26d8a3ee024c9f303ca9c867dc12fc691ed73dea403cb6164b9ab43af8075b9dc2cbff4257d870ec1c4104623b45d825cd813a7b6ee3564ad282db8cb85904a449e433b2e9b88ffd8ef68a98f802117357d46729372e371fc4f29f5f70e08678fc94fa896a14f56f105f2a2727c86dfd4ee726115df150646b5b37af7449dca71c867913b0a0576e7eb8c74bae781d2ab6fd3c8eb61b56a687215bef81adc1df7b53fbd11c137a468c404128250331e4bdce0a947c8189d54a9b05722ed57e4e1988cb4e1e7fa8a23e93c3ab598dbae490a090e4f6b3e24e002bce4a2bbe428919c7d1291f1f8ace2a7d3598bfd7a02fba1fda434bf490c72b90253ecc8a03653cb7585cb3b9c339d3763128d96b8b5857d4631059653439432d22e30ee574f4dd5158248b3a07fa6aa5278c10f2d559adcbc881785ae494601e1a131a2d0496db68e46360f67ca6ac3df9d698bfe5fbd08b964961168acfa6fc23d507b85d8b2a0294fc155d37d2f10120389550a90adc171e552220fe0642155a5349c34c9fc77eec116083e17ab95d7e057f29a0080bcbe35c70727719d27fcb8b83eef464e61338574b0f9764ad0552fe6380a8aa2ada8e407b87668745cd56e04adee8b7b2fc9337e584dcb8bb90da2abf8b3f4ca0a6cd0a382e18b6b5ad64e2907ad6ac758694eea20e850c99988bc7f2d99b84b5f7f9ac8c17bf6d5ebaa61a2330edf6ae286822a3c18ee54003bdcd000e25127f99e29118a6f5777d139cec825832814680378967e56c713e20a48c35cebd352bbb37b1a7d4d493dc54d308736d0c7674fb6ef33371a2b999fdb49beae1d79bdd2b5d48ce1cf6c3b90c293967a6baa27277f20b25bf991d53aa3e7e254a617afd48fa00ea222812ec059a0dfa691f617d33ff4bfb418ced2112d578b13a8221bd62e9f775fcb2a5587ab08167704f23a288f290b337b0121be1118fe002bf8d57b157ab7e3d2cb3df2e1bffb111d88cc7a3ad55563b61179f6ee06923ea71ce5fc79165421f19381652e3df2cf848c450760d03642b3569b33237a126992871a60ab825656dc9eab567074cf275f145b2169bcc90dce4f3161c60b03edaf4b44ac5a0f1668bd4f0a575ef47a50de19c216925feea0dedfe528839204d32e0965b644d559568bfc702b6f0b30c54b4e0c353d6b6882298ff7dde6bca0ef4ca91e334bccfcd919a18555bf56c554c63b012bca785ee4039bc11ed0b01c854d59cd915bb3afb221e2bdd269034f75d419128be20be09863e687b9d8d64d09afa016de0672c45f2ecdecb82711a752443ed9c887916d6cafac565ce406c844cfcfac3a4976bb6e393302eda1157bb33261cc9c362dbc815c73b8fe1ac798e02ca4737b007585ea178f88e9bdf46e6b033ff6eecabc7691b3aeaed99beaab5d5f1703c0b753e0bb730db1817dde592335a4544c26303229b3da3e08d9e49761313ef7c23a17e17ea2e8a6e4cadc8622d8c8dd5f5ec5c845373da926b322e0c0dbbb057f2e49edd3e04b5c72a39ec25a22283d8395aa96f5756577be784684a0cf29a2825491b75eda4fea43532dfa8f08b14a80649cf1dcaf13b52b9a572b597d6a277b8c9bd474981b21a1ce45f16d8351c66e0b4ff4bb1e4f5bf9ca8bd636a9b73394acc0c9dd9a491108a384ba376be10545d5eaabb866dc1398bc27a1bf05b2c1205a7db1b7793892d21f732ba05908e8242ade935be82a17b2946358bf87bec30a08cd08fe3ef403268a3b761091126e48dbab3f6165fde6ca007b116c064c728b5d58f6dd110e40f1a5950487d8e4b91b3855846a95eb10b8e51798bdd0f2e7a39717c1bca82b3c0f4cdf5d96dcaa17290944f37b27fb5353507061ace5665692386628180075556fd4a5aba0d7320b82d2e3a2a5060a17f639f76bc72900f9b43d7034486468ba4a03dd789321f20c0e17c767a56a2ef7eca2434881c8fc1bc8078fc84964a149e85dc5d10a189992dde30f48c74c803c960275d69edabf34156ef8548c7737038d85d26adcf593c6537f00825797d95c40a211f7794ab66badb0b4ed0163b56523b1cbe182dd8d2a11b660853a080c42d5beedfd3f24c2c6fa0247f8513605e6fc664f0dd43c6a1497e2e2e7153ab2ef3fbca6cf80a80151c6f5507d155fae04fb219bae106db1f15b239958837f39455b6b1f0e3b5b888bfcc385ef20689b6f50ebcad2a668799780bdc65ae06eaf2d2ab68717b1cd6deff9e10574ad189827aa2bf1ed82857363607b1db9e7151ba4c7a9b2d613f1a30cb458dfadba4cff8644bc7f2ec7ba85609c48d95b848f8886c27198667aa839a9e3dfc5726d5f434f6d24c4fcb927a819dfac4527a1f11f42a95dcdbdde5d5af339f957e09285850ef61365c0f65c2c43c063e4bc8477c9bfbd918c6abc7ca4677fefbeb24346976053c2318afa0dff1c27054bdb651bc62dffcabfcb9526116132cc42b076fc7facebaed494f08d9ba782d8b35b6b4f885a30de94f0003f5b5bb0df04a335d64eb19c37f7e00ac0bece35642f6c6b7c4fab8549e55e0913831c76b7b4775c01b467f79cb7899706f71ac0e880e347b11290bab882dee9430dab6d5738c79dd569e42b050988ca93177d80f04a3780176c7aa7dfa7cac58c396c18fc28a521e2ea1a98594f9df5d11bf9e3ef93e3bbbb8e0fec8e4100bece68ab0cad85b41c83f4eb7bec70826c05253bd9ad731f65a30271f0472030017a7cd3ee630d9c5c366ef5c481d6ebafda8ec6ecef1eb95bfa77c5b9c8b836188ce670a24a0ae944e549af6121fc3e8346c17e0b51e6df8807e3c75df16a08d5bb676ab2f6f7a0e9f4f4c5f1fb5e12773f5ca8b3cfe7d531ea94dad6c396dae9fee5c47d0eb7619564096822df46bbcb36b70eaae07a59cdf9c41797e555d8dc07e9a6f8c9b2624fbded12b83938c885319b31c7d96917b6bbf9a4db1dcc60aa153f1f8947d57f205a29671eed480bc1e70dace4b0f959129886d250361476798ef7afa0392ca1d136b57f2740e63841a51ff9cba7def01e1d3a13125f172c16e9ef7e95586d69ea3e6e27e45261d5a43f3e25804fd5b7d70675012ac51482fcf979aa4465ac63d3990bd923fd6f6241e2bddb5dcc22188fe5c2378fda9bbc264c64e05124fe0ae725a7495b9e527d6d223d63d8b47f7452e963ebf5f2d557b9b6d2d3c97b98952eb9341f631f33f3edc00a470194ad2e1bb96e9a609caaf4302c38f46a5edef5508b7e6535bad4451d39c8e3d91b2ff06a1a03ef885753480e948cea1d2eb6766700b9513570bd054e625a8ac0f18a06eb3a0d3dd81cdb36d3140a5ab570436d4c7148d796c534b5756965dda83e02fae70e0c47e0889505c8356acaa70138a68c5de49471d63322c2f4919b8cd802b93aad3170d2ab802c3cad0d06803ff65b7ce0cfa6cea328e969a9d732f226afb3a5a263c501a4bcd8797725b3c631edf9aef6e9f58c525bbc6160694574f94d1f69f3b2875fe48719f2ffedb5466c95c54f27a299e692e747cbd0c1088c68b9c33d64d77a6d1c0275a847ebf20249d05bee539ba81c5a812c1af82baf7489700a7e643e63703df0f39dda9bf3cc11fae1ba21f1f178fa4b28564a6a1471a1f8e416ec3f695e62493310238f2f7ca531cdbfab61728c1ccdeb63609a1dedd9bee2e996e9d088109111d2fabac57c571536c27bd83789c9e7160d5069e93ad743ff697c72b830b25d8abf8d71a5b354ff2d36cf2e297572d911039538318cc88f5178905024cdd97a2301f09db10d256435b9cd33887d9fe9bf2133ee5a030e0b49d55849beeb3533da08c95c08e75fd80f7c5afb2f5e90ce0cb13add7dad751a021ece321bce33bf0d6c114a1416f0794e05ad67a26e01364234af2dc2093417d41c7295cef116fa17df935685e63d465b891bf7c27818e069c8ced3b4d3d8e522bd27585a6c10bfb88e8cabea7280defdd21100eb79bd35901a093f40cc58b2970eae3117aef2ef8e463d0e12deca8957764b9a454d0624e4a56f3a6dac88d62893fa00b68937a9d275aa9dff1163def08435fa20ff995fb7097475639ffedd698c7bf2de0991833ab3a12f1c1c52bd521b4aec8bf87a4d7ad31e3079f0e6ff1e85d0cfc620beb3a2921dd1325644f797e4c6ebe85867c6e238c24fc036a740101556e472d147a6bc80bbdc73394bdc36f284eea20e4ca1188df0ad318f4fb81d4810c97d69e823affb6c141e0cf93af8cfdc566965037557fce9fc53324dad9400b0bb1bc8e4dabc91916011c6a39585b0b56e07f5ccc633cffd005945fe1f2182a5e49c2a1bf852f2a8f35078d534216970fc50dd6b62b86c34f61bda089a8dfc05fb2ec019ad2f1feee590f564ce2ea3d2284535f6c51a06b5494e9ebd4e71415bc05ffc8105e59960ce1c6c764ecbdc50f54c6ae307f95b2e595cffd72b65e0566e8217ed27f972b6e7a69f2767661e5d4ca98e0e9a16ec89fabfb791f06fd48e45e21b58a3a81009f3f876c9abb1b3ac537c6ed0683b507473555bcbcdbf05664e2e813ee326375965456bc5e998d1aaefecf71b495532ebddb86530943a4c6e4f3e4d9bc2164b4ded3c7ce7912c120a7fa10c481277f452726e862b4a611d8d56f6f0cd287cbd8c09668eda5fe043d3f28622a4975994f6a21aa7d39e5a2f08db4ac77847656007ec13db199ecf30632d9cd9a6ce5625cd64f900e71fab37dc6a3c22ff131bf672441bf0df0937046ab423c3f74aab236ad41c8f9ac8f885ef721b0a97ec7ccbedae1ec98d5b8e3d63fa704709333b63531ae1c413bc13b4a6aec2fdb8df3cee645bdfc02968f85b09ff3bcc684745edf243c14e7ba8fc7e5e6f3fc3f21837670fc40219a7715e1d290f057c514998249e99dccc30230ce0d864158c69eab3d4639ba32308233ca7c49ea8c1779a1e7ec6f64440b5a1f8afa5f0d337a520744095d787d15ce7d9f39430e122ffc45964f91972184cea379bca884e506f8b6a1faca43fc6d8a821249180f8f2cec84e7e69e4976f0d92f95bea22c53bc4ae8f8483300a4b5a35ea8d6b35ba0420c063cdad9f21b4e3f4b326e49f922cf860970a3190a670e9a5197b533c87bb4640f3a35ef480e2dded0d8e903202899f5b9a5178b61776acd3acaa338319dfcd47a4d68016b693df30e4cecc9a319e53aa95a058fa293a3d213e77771e0733de7017a8ae8bb184528b17c5b358a49642556a3bb117717b610e735ba3ce130ea12418d6de2115f08199e057c46045961e70bb7ad9a002c4476743412ee0b71902635c1d3adffe7af3759c65751fcf79993e91c661b905dc21d334df70c6045e94ef418dc03be24bae23b57a08c28623bb269cfac41cf95a3242f70170ce0562e58e3d9bda6d05da7db68d7d185dfa88b4b25daec9a12ec88991656d93bf66e87d3370b062ed0a49844ab4ab5704b9673753c73c5bed464e53aa18b6c5edae9638f1289e24afedaebc0371da6b51374334ea5983c481741c3fe41f1f3a85d4ac58d769ae4220359b1d370b92baf4a3d49058f5eb96ca22237315c99a3ccaa6d4ef3ee159f325b5a2cf5e8a065abb25064b20306602f1d47ffaa5e53cfc84382d405b26269668a9a08e10b8c7e7d8e3d69222ad65a17c4548ed2567b5ac2b8dd34066efc7420583a9e6d8f819b9e1afd8dc0babc4cd3fb88bfda3a0c9aaf74c36a300520a4b2cb57b948634d07f864fad893a648ea544dfaa257f7e751bca8b6eca27a3e1ad97c1205ebbb1c9076320e3a04ca9a7899d8d5218f17490375333447d396087c1983508e6dc09a92d79dff8f931ddb6277a34973b270a8e0a9bf883b5148ade6029bcad9dad9d43d1cabb616e042e3bc91254aa3926f4660f7dde6037dc2d6a7702d89843ee5a85631e9aa1c23b6efdb6df06c27c161e720cc37184508be25d841dab3abcbd736b80f839ef3bc3c20216fb8557bf42170f8531dae2959207c531fe5b3efb78e6b5fe189655930e8eb6703f408ad0b7de48406b622c278a17f865b74b63e46a42aee22921eb009eac2acf8fe15d8ec12cf00417ada7f118404e31c5833d52492f939ce45b2661dfedd885f66c802516313d116ac3f46b7ee5bbf5069dabdd6558254250fe3ee944a4644fa70543d8ca453225f04022539e198221cae571b42f3d0306cd6baf3ca1914092c3b979c176e0dacd5c434864765230b951d7cb9508536544c0f5186bd3ac6db05096679c1fbc26a2e9d3301795a8753c1703fd587d521351f12530fedcf59aad9553383ee59ff28e7a8f5579e4fe7461589e156eb5ff490d3adfcd951dde3e4b6e3145e38534663eb51027ccd2ce2608a485b139fae3063efab5c574cfb01c27e83f977b72eb751c46617bf822143c0f272f863d2a9201909ac6ba0dc95e12482c8c9cdda59794ad0528a1958e93ce3cf74907322dd6aaf08503c4ab54bd651c9b5f81b034a8e21e0c71d2fd8750b50dee22a41d49e11419549968bc8c9a5352c70a3304e4881f933ed593f25ecc85f23f072a24bd33c6dea5fee59e93de0359723d340e0769dddce8fe438065e80412c8c23b2736276bdabd553b93a23d2920718321407f6457aba7d8d189d431d22a38b4009cb20ee600dcc3d9dadf35f0f0e6274d176a7e0072bf7a17a71e7aca6107293d978e039b83f443f5224be7458e91bcc77ce22afedb723e28e507f6f7b4ec0c43dd8944d868d8bdc98b2b9dc51f3c038498db74fab10ceaf72b0074f51422404ad97ace3081ebcb96ade61e0b43cee8dd2412066d21057890fcae3eec466f9eb5fb7b5483bfe20e3c09794b613b0dbfd71c6bcfce6d93bc569f0f4fe0f69cecb42b1db7fff9533982d39577df800ca85f31438cabd2fcf8ab050fc22e531545788e2d210338424345d27fe5f6248a4b4118fc7db36259d2f9b0b0e7fece6ac79a186f08a40b1bd574e46194722525029c6063366b97fbaad449d886d6ccbebe8108134c5195c7fda682bf0bc6c45c484d136286e8cbb798bd882630d0c1935207e979138f5565e599655e1ab416b91d378725532bcd0f50de0c5838be17b2530e9f6f5f45f354a639fd2cff27d92d4e765326431012b30b202a85b0c50ca87de20768fc8d3feeace9a5aaf2cba7bdaa40466fd877cb9b35550089546665d7ddf3e89a154de8416d466f1338007473551ec63919ea88ce812fb0dab7a1a480526e0d02d21c07dceaa6e7a2a846e4242cd639adc0d45f34ed9a7fa077ba4cec5608391e31950e6bea70d296b2e9df56936baa8820647b811d7d01b909de16b822627788ca2a4a37a184374f1146c70b6c7f8bda56d06348170fff65a75d39cf103557389ff5a407be4a350b0f2535a4ded76cdb83ee123414462efde5c504bca93e68d222d72de535e9022879ad3df85f71611c764433937fbd38a203c6f1c395f107a55ce6c4840170e584f542fbf30470085dc6c64ff19c46cb263e6c5363859aa45e1ddffaab4d4f7e5dbcfa5a540eb0692bf470443d5f266875824da5d0c85bdb785329caeed210582f14feb94e9d1f30ed142514e6df0f54beb5d4852fdafad950f2a157510d9d5b0567acf38d5c89664962e8fb3da81df42166d72501227bafb73cfe4f7ebe9f3f338673603505effcf4f6374b95e6750de8a89ca2de2617bc04b42dc583a2afaa272d93ad91f54fad7028da357c6278eeb2301113de727beeed93479a4815b6175b482a48d823246c04b67f0720711a090755446a6bc39829c0972fbabca9b2875079e2bb2887a0e32327ba9a979c911231ac6996f621bc86bc343282b74bbdfade554774e9dd998b81648db93bdbba6ed393736bf6c2b3c4e08112204d515bf989f9058f3817d7f1a56d22bd0ea76370336a73d9c26cbc61eb03126b45395c628d470792304b010d385bc447bfbfe51d3fbef581b53a3997bf631525437c91f922923add59dafd1fc8032a2b02d1494342e0e8328d80788c5b50ae9befed3e1dc6a6b2b3eae34f3a2c4e673e75cfceef50d20dcdb62ed4c6e21d6fa568615ba4848dbb5bac917761455b11b449c282e4afe9549e04e33468ea7d262a47236249255277fbbd847badd77c6e3f62d726a264b015b8081b624bc3a28efeefec656eb44c149f06004c49818ebec4d033a7a792116d39d3573fd345bd929a82bd6434c0a72965265b12d485cb3c7ecd738f95e1fc0713af73f6ea6231db3894b4fad062064c2fadb5b80701f8d6ab6e04e0527978afab83d69e5fe9539899f5eccdcb8991076e1307a305fc18a9733430aca4d9a7a6d7c8ced832c6fbabd3ee10b98ab61cfdb22a058fe6d8b5573a4192a07879ae6c69c8a9fc93e185bee3862eecc58887f8c7c465d9c145c9b4c4b2faf3ba0acb5e18ba4f38315717af146df9920d68039ecf7f0442bc456fca3926022d82d1e9cad6ff36bc979089de11fec99dd3a30ab3993584d92333a31bc08b0ff5709000288dfe0c0253504c74c4c61614ef7680b1efd8dc52c653099f0011f01f606a7c51aa1e5a9d5cb96ac02e536895298143e70b1c4c88bce833f9c92e822d2f5a0d3248c84a930b226a955cae526d631412f23309f94f93f70c0858898ed41d8122ad621e9593aecc6ede461de3f2b97a190706d356ddf6c94530968e72c2c4eb09e846123291f2a8a55ab17ed63cb9b36afeff0e032e534430ea99fb5889faca048084ab7962be85ddabc36cf23f810cc09a91bb2a8a39d23501616fe44d0a8d6f6ceb74badb38640a8b00cad33fb1266cf9b7a3c4153994174c1cc915db3b097d3cf5960766ffbdeca2dec46c34c74bb11b90a3fe6fe3452e7c02397a0c875ab9ef58e3e417e89c267339c86c5d1216ebc2ddee50bc91de36f140f6b979d355b276e0e3c11eeb8e46d72ff6eb71a745202594dd3af82c7e2edeb49500c250af5602f78001c15e19a5ed7d431ad3f6bfe4ad2e2bfd0837de8a31aa474271ed6e6537c3660d4630d27ba5c1c0096412ae35ac1596c99291b2d3dccf823d0eda61194c5897eed876ffd695427eadf23b92a03eaf9ba7358ae39fa5b835f5227fb7611e67c75ef87e094e806fe95a27c3477ca40f5d5fb3e8e29c68ae51dd09fe81d642d58eae8d52b35f5f5be443997dcc44bbbd8d6bd989b71962161eba54cabd5c2f9c92510c6c29853b185fe894f7846396cd1164967843a0926d731daf1b65b0d388f399b6f6e3f34aa4290d34fc4107981c960399aaad1d1ee59f91dc8374eb9b7c09bd729b360b22299f9973337c154b5314949fc1b237d82489ae63bb5d48d99137fc811c8504bb6521f5ea32f27fbc8de9ad3723aebf92914e8455a8af5464bf660e43d05871157d7e886498f85444f823d2126ca835d1a419dabe72ce5c0086f7342cbe1c1abdaa48a45ed8b22a7fbe990e0769c8fa0c99192bb24d119f88a89f8fff1b2d049e050cc921ff8b497a7c8096160ffc4255370bf8a7ab5f2d1879aa85c627ea465bdb9b88ea09706a79a2c5d8c8786376f8024089e7a82f254cf89ad2fd420fd48d3258a156c42cc4786337fe1879c5e03f75fb1414b51fbe3d294106b16f1979c6a1e001e14edb9a62fdcfa86ca96997daac5cc057d31de9da3a921c9633d309f6acaf79e3034e1592dbb76bdaa80d4f19d5bb050c2b8756d9d0d858ee340418c695ed3d1514c142c1da94841a9d0dde32a8650fcf25885e3f1c048e63383c95e223303b9c9415a379b962d1d44f72fd46c1c1deeb27bac37b21ef4757988d322ca10767c180fe8181d99cb88321fc4894045dc7fec7c0b0debe469fcb47ec972c4ec36b59d78c3aa96736936c1a3d06a18ec6314f0239c36ca1e28ba58169901a623f51c5831fa131cf5d3a7c5421609db5aa1a37b5a81b5bf95932812b68ee80ed6eb21db5e854b2c2655aee58a5b69ecb617d797db21f1b5dd0506f3c8afbbe1fdbe4bd08c7ee59ca3ad642d8da10e00cf34534383375a43fba1aa5c3ede77bf8cee952c64ad2525255b94d1de5e820deab321dda1c99bece826b0d6b6288d1762b6a6c4d3d0234be618a9a91dd2831b39cffdb01cdf98cf4c1228f3d5c8616dab8447f3b699b97b0f0eaae8889e1bf6d4786d07e85b597d517f22fcf5a3cd9741da3b0553ea62ee20f767fff498427832793ea7170dc9a4aa782706baac12f6e95f4cb4087db9b75443c7ee2f38d388aac4dcc970e976b2fbc5c192606a8c4df8c82c3a6d6d1169295365d8849c4605bc3f06a4721149bf6a915585f4372157c70f4de353d66b4b49426c2ea677afc1712dbd22f515f3e87f3cda000ecbe772ff2ad6d3b418bb051f975656dcc1e1ad96a01675e2c8577fd237b75be70dfd9e4a2cbbe30c3e95ad60da9949406be69947eedcc67e4efbfb4ab645d4fb1388cad5e9b64d6874da0254322f64cf4fa9e85f84383d19c88cc8806f83f18a45d9f244316a8c7e7c39dd0eabf37528ee5483941918998e3c32aecf30a105fa2e5372a1eaca0e394c8cb14f2b6eb1f040f1473ae550b1525b3eaf160b966b070b11e4b6c9d1f3830da3a87d932168eef461d26beef61ec9ce528582aa2f2848522eedbf5ebe4c5b51e52e02cdbcaffddf78d6f4e18b5b5413529e6bcdd40b076318a027f9a473a5419ab476e7edfe1c5da5b6c2c9caa871f613027a046c33e191baa351a87f61d1afcc904bcb32e769f212150fd20be090b4f39627b79a121c5073717ffed1fa995874c4dd35857de286377f1b02977e7349c7fb85f8963717a0df77147ebe9105497678fac042e7c85043cec0b4f5232168714c8cfcf15d46baacbf8c21fca80a8e0dd312695598f68c5b160c06fb63d2c179caf1cc9465ad0efd00455620f588c37333f7a568007402b606b6f357feee06c827969d1435dbafcaee17dcbc6a39b13afd55a11b2074fdec19dd04ddf5af91b05f0cedc716daf5b5234df89ff664ea1214e47641d51ede28d216e1dfa91aa1568ba17eae608695478abe3cad09395c41bb133b90714dc1f3b8de8df2f47dba625a647826adab386f09297f49ee607d3859b1a088a9a8a52e3458745c428dcbf57e2e8f48011358615f2112db6a7558303fe1fac4f2d9f2c297fd0a4185db02329a8922bc82617ece69bc68b9973c7a5eaa068b2ff482d51964cc4181c3e3d0cd0be230f507bfb76f6f4aa4a150cb5b7dc32ead6071fd66e7c2b4b260044b21be3586080f113669238a990ff223e6f3c6c8acadd968a0ff47b2eeb0d0b9250998ab2558a077ca6b07e2e1cb63cd0477b245d540e6a1d023a5570cc6663c0e21dbe0c5ee14ec50e45631b97f89670d6cfc453736929f676930475d97a937550832d982ddf0e36cd13dc9640c9b07d96cddc74cc9c61b90f46cf6a16144322d3fda01c226b02ef72d99cfb58f10b09ab4f38ac7169d40af5342173338c7d7540c580581ae7f1c09ec6ab606be6df1f93eb8c6c57594a0b4b873593dd4db4923465495c861946de140961123bf6b3495d13a74d2aebb1de946b0ea370e394d9104833d35e7142171826f481b9c178fbc21a5856f6185fe48edf117256b44400643945060810c5f74924d4b26074095ca13cd5fb0c5b564e042a96bf7c42b871c70be75d8dc7ad9f1f759e55b2c1cc7df2bd4a3789318ee2376242ae3942722588ef7a5cad48ebd90dca1e349d5c58aad947bc4daacf9675b1943973af39430f50e5ce572c1e49b2ff10010f5bb4e86fc171d5d9495720a4e8cb8638dc1537ce8a8aaaef5dfcb11d347e1bd3b025f2443ba7648918a3d3f00c49de71b837a9a2cd3e4694ea9b9376265864f1d11f9a9f97901b7c118fd5f9c7d23825a8e40558040d9517be0c3cbfa0b9c527846c3601a30621e9da118e8b1803f58e10d6b6fbd0553f8a6a379fe44ff3cf6691a50aa319d98705bd56f268d50c7f1bf38a7a82fc5d452b1a29cc4de504f730bd0dcbc4c1324b41840c4fc823c643b0432f650c308d4ae18ad12fd2137132a1fb3f3009577d7b592273b860540d53a49ec25e24fb7202456dd99e0a07a39ca457bb5adaf6828c525275000a28b4fff7d3d8d0c333bc411d0c7cd67782347de16a22805b8899024a13dec238c937cdeb335ab09943949b1b7d79774e682019fac75cadfb12c5d0fc211935b6d025bf8a4634102e686297444bbd115bbebef0e845a5264a1f3c75a021cddb0c01341b4ec712213a8ca11b84d4b49f4f4b94a2a30735da5383e56712debc8db78c8ce491285afb5583841df55b2b58a75cf6cec0a34155e766cd4aa9faca7780a47097b524ca50f3ed9f6c45a6dd3c2ac44a9db5bf162590e843d925102abd42ce09d72a63233f2b4ef19a954be89bc10184633cb6e3755fb11cfa4b22375591e42064689b03185f15847a32ee430d35590a557a995dad901263552eebd9bec263f66ba1a712fd60d8fbae9184271a1954267010a1cb842d507e0ed353155593ab89c19be1fe3ffb42257eb17e03e39d6da28cb84717fee8499413b4f4ded3ee9d15ec8eca2f91b9f7a3b36dd03661472e0dd4d814b507bb709cd77843d0fd653621cfa7f79a25ce39d6b17aee194162a30c8e0d01b7914ff7795038575897f11c091f03f03471a2a6238a9a4754b8d1d7cad4eb6b764234e99e942e91be73a41a93396f5a445417a235d257606bfa166abeef8647aeef5dc5d7927c85c57121b1aaf3a6fa6ad09dc3e35b39d97d555976695b88db21cb39717377ae282792fc99e11ce3528d81844618b79d8d2dd878126473e63fbe2f473b3bd3981f25c30e4cee73847c1b3d29b7c7e78b7220c4e68009137d8c54b46941a7e44451e77028d4df853e4a8d40814e3642ba8ca7efde8b34fbd12b8b37480c58477ff9f55cca9de54d224d275ff8d1a1ec724ded0daf28268d3f683ff86b9da5e6084fb01af07a94825d00ff7817ad1f722f7c6bcdabf275a16349699fbada6792410359c7077866033eadf57c7f53d3a6e1503c11eb5c20aea64ef0f473c299e6b85160a2e0a191767f888c76b4853db38a104f4481efe6bf7245433102ae5f5925f222f526fc5164d9db04ec4dbbb09cc5b4e1d2cf854ac67ee354d0150608f34b6f5652d7266a1dc927debe0cfa2ede5154869a0e6d1d5ed2a4148445ec88c43eeeabb40fc66ec6939354942457a9baf17bde2187ce4af9f907e688d9a9f92b9348f3147acabf65a802c18ea1215da8ec0d471a604a78f34cb2f6473f3c62d00d9350aa26a7d5904924ec5d76bd36812b3da0fe7c9ab44338e1c3368d8ba3f333afd09417d2c0eb094a8d4c4050be26cb4ae4654d03c500fd14f9a6e2ec776b4a2c5f0396c0d4cfd0f21ec5de6ab47e232f791948f74c6a457407b5df683a4881f3005b9b32965e1ac5e87bca43b57a99cf464f09a61426f0978b4a9a304ec19651eb9b249d54e184cbc9e2b258fc1e7ddefc6dde52b4db0acb8f5dca094847a780fef57f4d8a0a1c53300dddeb8e5423d04d905c5812711af5d514da0ceae5ae92d2b88f75ae3e7a956305d6074c88aafa6cb71c716c5c4ded139feb7c5f0c6062959a02aa5a76a4ed71ad94c2a4e5309ae8095166c26dd5d725480c8013effc29dac5939b23f46750ba160f464b86b7634bbf41fbfb53aacf89815098e010716a5d913dca53ce6650a9db8ee078c9b35dd14b824f6f3107f6731005578baeffde2864d9f96554e4a211bd2fb2734b26d9d59a47f67910289604b54f81642579de80fc829a54b7c8394b84277f3f047c6883e3a3eb473130d804c8130ac26916702d98a6801f1e6ad56c77b2d27f1fd48600ef5ec69022040cdbeab7cfe1b53a98eded1b22ceb01ccfad7f6d135d4bf819d4a44d96fd0600062e20da13bbdf1ab045129001a2a2b4f8966385129a73cc17a0a199faaadbc189320a86317a0e3eb804209076bba98af7d39a47c23a1a77151d6568f6b054e2137183351892cff96dce8fdd3055585e3322fd1d0d7d398e89da1a38bd08492df3ae7570700706eee580bb377cf68b60f585231533b6206a14d5444708416df6434be4d7f69e0edf8e48dd9e2bcf012268e91965eec6917d044772951e01906d7e2205744cb7834fb5c8986e41d06e4626e78ef84b371e5072269767b3983e8c0332007f65a585ea8fedaafa72a9eafd5fd7f206cf59b845609ba3f6523f7877aa4089846dd1bf9fb1c5301e7134019ce8831759bc264bed0d90a5d424705efa5c4ed6e72326e1db816cf8c52672dc2d017c3d16d965d859349b95d349fe2a8fabcac16cba60fb8be6f4793cc55e8e9f121381281e83a234da838b76865fe74034b7f2fd96a2f07f324ef6e2bfca6d53fcdcd6c796b0c70c687df131c96304ee8e799727ac13ef211b12acc1ec73c86a87e68efe691963d7ca2d1552f63fd92b25c9ffbb60ae165178d31e3c73c44def5104cada589106cb52b97a6ff1fb64b6deb38164476413934b03af291dbdb91042637bd0a62e9bc0155c45ca3f9800aabbcd20ff28837f70780369f5e424a89018f589ec797cd2ad710c3fcf2e05e2f2ac4d982d3ed19e6c64752c3e0e225f05e9312653867be514c36a50440ac6321c6f5bed3acc6a7f538030833bdb74f1e0103fd2ba612cbd4351","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
