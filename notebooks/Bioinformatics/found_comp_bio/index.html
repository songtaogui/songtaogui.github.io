<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3917b93c72ade4c47964caa1281c318b146e13d121b196cfc25f517776d50e8bbda9a599ef10aa6447cf3895542a46005d8a2dd2fcb25cad72e14926fa6ce6d89ed6eabe25fc46c7ff99d80e1685f8cb97352c4de5769a6c7a1ccb23b14ed33bf074b1c0302e71900694910590b746b33de6dc26ab803cf0c9e6dc7177e83a8d690dccd815ad1fc96a0293a7ecaf60841637fc9896261e01347edda8fd63a2ae7af8520694e88a855b699ae36d8a607627ce586c1941f029fa5b9916c74e87112b1a0415c127ca4bc8dc8f4ad27421d65951b15fd8861174ff4b73d1ab9a5895370b5460a1e96627e36a87977ca9051d4fc76a6233e704df213df4c4a7c59f19837f8eaf2adbc42da01c89b4d4120107a0526e0dc0173b8ed78330767057eb9d6a61cd48ad05bf4a2c0dcd57994f98e1a6a23169f6a2a114032dd23d50a134bb0a8dd2fef2036d1a00281acdd6cf57739bff0bec1e3714946472e401155b8261ca999d200663af9afcb39d32a60d80728dd4571c6d0c683743c92ea04398f7c7224315ab892492f1c166b19663919d8c5f5447b57aa06d0ae682ef6b6e5950072a55dc56fa64d75ce768e8d4f06c4823ef1f33a397ab038c87def7ec5ae67a060a4ec05e2297052f6cfb866d85a7cf55681626fd641959ec85f7aca09109fe000c2e07ef1780d9a7b7426a58184a49333867d4c84f1c4a5d6eb1038cac941518e6f452f304eb09925e81f92bc4929f58d8a250c4c9a33d7a2bc1a2721447c16d8b88139e0c68fb43afe692eb710434ef8ad301f1d0564ecf5a071a2e855b27e6ca0733abb650f075fd8f88789ed618b35084e5774c42e3a245e1d3ae01f577f0574e46d497da9196088b80b0b804cac5f58478907e228d0555805b8c514623f65036f7106a9c00dfef9fb93be3c514e714cf5a5f8930e360e3eb9c66d24ec5823bf44236179c00a7bf9b238ca9ab188c890b6ffa93ddfc5c7391f4a363d98ca1e84ef20ade47e4a00de1a874a7d30e94675a9f793fbc36ff3e4c64c5cdfdd2a309c5cf30717c1032432445cdf55211f3cc1022651df666ebd1643fc9df2eb79ec015cc59d8fec25073d8a2ea3b28858abcbde54e4f76b3aa7937c3f446895450067b637e727e0b82a3cf948b7175341ee79ae36713c240020609139db2823fafa97de32ee9bfec0093e43998fb833ea56f20512a36a2a1c0ee154caa877353598f7b0cce99a495d512488a90afafbee8bde068dcf930244797d7ee84a3c2187c984e5345d98ae6fe90fa837c2baa6a5dc1cef28d59287b96c1f666e51716a29ffe76bd2c73c55db086686af40b06dd03d7526b44ffefc63508a25181cd83257fa35554f9dff5f6765cf3e542288abd2beac934f8613a197ffa8759dff81532b50317e6ae89a3e9614e66602dd110af54a895771bf4792f95f0e7b1052f6763819729b6909391b76869acff32fd48fe0c40ba53eb8831166997c043ed7bb88cd2b1a35e382cd5b224d3b826f4ace32a962827da71645b672cf288f9f0c6be86b60ec029aaac7f389c2b66f80f30f3b0a466f994ced1518110649f5ecdaf3cd3cb791c8de83c5a33f91207eccc9d1725d39efc90cbc012813ec1d13aecdf0ffd70b6468c72cca6c58a32d50a2f46a96b5e368258b687268ea0b843a3c992a87ac66e02de18ea8aaa6bc295aac70e588890370492bc2c352016d745b3cf6085f9b228462f590a379907d2e9e1b555345a798c9f0ffd81b287c0e612f6a2a839cd844594c8e602ecf5cd290128dd5ad5799710184c62ba01e9bda05cdd980d663413560b0f335b150bfb6555d39537fbbcf09645d38fd481ecd08f1bb237f248ee7d4a17683ea65c39c0731f1c7693d1e598e78293455241f4421edeacd98c0dbf13e7099980c7b289ae160fda649a48c46cb0926c992193ebab1839f4c15a031d837204f674f9bdfa2e9db7d03fd615691a0a0982fed544d31c997cdcd3eb11c54a794351edcedc868ee5cafde9ce4c4f6b76ecfda5f36ca12da1e0e1c43834fec09f54c1343851be3f757e70c91cbde86852e081e7e62e2a48518d7795c4151a7f8cbb62a7ff5a9b7f27b73ded160f0ce7a8f1e7d4d1057530e616d975ca0898e660286957fcec06240d886400d4b6c3123e567014c65a672c8b110e20cefc482e08102ae5e3e7f1d75937805b66925c123fe41747ee774d4bd46e1c1f96d3de737ea10e6077acc269ec7f456e01c52588e66cde8330c0d465b7c4b196d2d54e41366b71374d36b6d3e704948fe7f02f57feac33e9da3401febb1e7892928e35dc4b7d2235aa8c3c828e36c3adaad00feb0509b40ee97d7a92bb6951569c1383c68edda4a708d6885c3e1655b5d037862b6bfec69664fdadc08a560ad6e50ff10dda60920fa4fc88af448908c4fed3168eea537f9cfceff7d6171eddef44bb8a6887e6a3447a8abf4f94f3fba00ee40621490dd60b99ae3d7a2a0edc928f95cb3e2374ed1125330d40715a18b2f3af48866aa676059f69dae573ea291fb63a0f6da631ff67005760b52b9e2c8adbc5ff482fd50a241cf42652a20d09e5264282ffd894a03f2488d2d897798ffb046a62e04a0248c93cfdb82560719f55d982dca40788252dca4bda26899d31a63ed956b01693be06bfc4018575c78f7bc8eb0ab6802db6798553e1e709417d9f82c20acc4fc5e4fd98ea18588e64dfa8d3440435041d5e262374c85defc69f7c39701f21384728b2be94333c11de89ed45558b1e64c1fc14665d4b1baec709c8b3d0b55c5e5961cba69fa9af4ebb8b6e3868381405172a7f193b245fd51faf6a6008199c918ca75e0e368dc0d438be2f10666b793080b04c1ceffcebcb68dda6e9c0f451fd03cec85b1e4bfa3b17fd57b6da3a3fe9558d5d800ea5e1b41a305882ff0a56ed7c131a72e0a5f20ee9be5e23df9271294509055a622d2b9fe21b82ac629d480b7d01e5479175b916dd331821eeb4ab4a259cae1a477fb56f703f3213424587113a5dcc40d6f05868102dcb5d7f9999d3a6865ed24f33ad31565e6adc77506a3a4473e61c59138e93d845e0138800d4990b2a6f0a288fa0b7c24a9241849876950343c1cbd510a8a71fc7be062ce9dd60f1bc9adfd5657403b344013e1d7327c096c59fe5790a4a98443034373cc7a3920ae1a79c37abebd63863e3de5f17bd94bd01d4a927ba34266156a6bff2eb3cd527d765d6c31adced31ef7963c043746a5607f3ee7bc356dff25be731c03c6b93748322e9122002e466d656bb54693aad23fddd28589da8eae2837aa3cddef6b440e88f6130b6d573b93b21494f2b1f7778eb50852bfc08c06a4940651442f80483043a6edd77ee71a915fc3dd8130e5bbfda356cbf580006fbe3410fde48b507574760de0a619c548cd90a350faf26e0ba1bdb704c0bdd5ae9d6285f6ae8a0eb5f9de4cbb6dc183146539a2d2a6c6b5b78ecaf4864613d74e59538675ef6e75bdd5e2d5da549431873cb0991b9ea3b674aea87f9c28c904c2ef87979bacfd1dcd204b5d9c20839ab0ec8a61e42dcad719c5b7494cf66e71d38d86cefc2eec3a6db85afdbcf174055e6eb6b1304af65c0c0cd6660105db4a61fe8f4c84914c23f969d4c60314c8fbbc9d7c2d5124bf9cffb41f8cac59113ed97f2a597cc01039296b67fb51689df47f4346807c9c87b0c6ab35bd2c90acf2e5b07b7fea8d7c2a2c143daec58564c448b1e71bcee927b6c5b0a621db039cfad67af210b94c4f4623f68f869b0444427f6500f468f842a117b6e68b7f011056fd9de7d6f74fd9f211fe102cf2022a2b2a5cc08b0384554f1b68d42ba188f6eb2aa98430bd96853d02a75a7aa20674056b58ffad8fa233057159d437fde4a101edf4af1634e795418c9287875cf390be5989df5e5d4a9814e8b0fa02297321b539585885b78e558c2658cb0af85992bd3138210025a9d33813660d4cf7db35b5364cb37d45e8f1daf33dc32aaa417e22bf0a3573d9b89d686f941d82165ba6339f411cbd9fecaecdd34ab3664276c4aa4538fa27d806dcb03324e790316ff169c349108976090d9bbd80a52b86b1ebe11f340dad9b8959ab3229d02b0631d1a70bdb9e701b26aae426889963c72af1e2e4b816db52088d86c59069be8c26c2aada35af4243bf46d11d3f96344a94101d506b2f1a4601a1c3f1724817e68173e77259fdcfbe4314d1152dec303fb949f8c76700be93889544bde06708edbac41faa1e0004c083edbd419663c3b4a1b2eaf2993a92bee51bcf0a2f9c9020bd19b0a9f384aba12933c37b5a640652a4dbf16331dd8fc91f3f1d9c332142d2620f46c42d8bf209877ccfab12404f0ceba866733e1ffcb9ee025c107d242bed6a3b3d2feeece87b5e16ab7b7384774d61bf3b65967e0746011a438a5175531a29d37b0b7ed7b0fc8f601ecdac061926f45e206198bc6c6f4e464e783f38f230cdf34c54f37f49e3cdd617c9ca55c587945a85980a6f2d8f7a2ea7613c06f6e9d2f25d4085a7786e417c7d56b52160ed1f8de4c52f8fd2b7509f0988ba201cc074ded2e5da4cbe7976a8c50abaef96660a09be40385b1612c834d52d0b27418ed4ea7a879ce1d1e229e9340649c4fbfaca93b8750a6e3ae813e56ea7e5f74b583535093f918a18114c1b31502d4b266be39c5a8505826347ed44202598d6f6479a2c0f23e56c1dbf9c1191c5b5934ef5e0cd5c29ff64d9019881a5dd6a46d5ffb3c5c3df369ec890321ddacdac63ec7237943fa49f0a48e179f9f9dc68ddaf73d3c64cc5d32ab023a1d4923b8876ae48ec60fdb9e579fd1a17281649ed1144b91ca6ab1b6a7f050e457f45d09331df619c25a43c1f030dda08657b9b95bfe4454d11654b80f21ad2209aa1df5a7d0154123720bb34c07a7996eefacebc5ffdbac813c9d9868766c47ef54649822a4f9dd7c6e109f32c027c28029d2afb64056fbe0ffa342bdacfa1c32a447e4d2fb38c0beaefe9843556b6e2ff66fb2c41166821a4bc7d86692d2fed2634bd5cf0344c2e57e54875cfc5740a28e67950670041c48406fa7f76ee3f00b3a911f7db168aa7d32c0fb9c4749895aa0cce88bab83da8976651a5629d1b3e6afe7acc92241ef616fe0f7e6f3b91171f42b84cc7f2d5957db745c349945bbf2b7f2274a0bb8ac323eced1cacf969c209810abf46b7042a0bf7b7436d78a5b1f2b7b9b0da00ef729aa0948c7904c0a23783ff4399c031fb72a1473a94f1db3d55d0b2060df82f9291eb3791b2a31d826ea2be103e93315bbd2e149869388d3c22b22d31f7b68b322a717b7b6302ded5c2cb47b45a25844288aefb4f7a4360a03cc08b332e7ff3a6859313e0ce99eafd69dcc8871928744b924f81a7abad95e56e356ec88cf3f25ac49855e7c7901367e96fd4aca6ca4b5df7aea08a962e7bdd059ade33306360be4db579bd106e38369d521b5aa4cfb63f8fdda0de22ddefd098b5c45f3e8ebacfc8f9147eb7c0f03581b9e4613ead585e14932120144205f9d78301c13367596f3d84c996ff104679cc8640ff56a51a3a382326b5ddc9843b2e19e1bb6fe50c79e8d32aac4b7eefa26b8cbdcb46359821e75747bed4a0f96144fe48e6e781d86161d8b709d458426ce83f45b1149f3f96d34ee02cc6294c4b574d5724670a0db27917c816a08eb1480bc0d8bb22cffd561e0297f3643b6e7183db52642171f20a8c7fa2fbf90ce4d854b836bf3cac7dacef590a7c9f1cbc658eea8d11acaa69e057bd42685c382377989d3db84f273be1eaee375d8d54b0daeaaabb1a5da415fd18c9c956d239537cfb9311fa5bb268ca4e2298163cb9bfc43680b4b8cc066e21e1a177d764b5124c701da9cd3d3906a4f7630853d400ca0284bb29ba2914fea43e99d186ff539935cbf6b5ab31855c229cd0b9a1faf3c2492c10a627400a321a37ae08fb655ddd3795850c84c3341f9f04666d4d3a71d814483fcde1ffe0d615997000a56dd91657726b1d9d33ac89b2a1fb2b6aae7db746a42cf2bfb27f33c11c68d88c70456cd73a244c99cac96b3310755c0f3141c9418972affb4194a9a063ca5a1b6f5e64cef29faa6e37bc356712ad11e76b7e402628966cb7636e7d1d0d97a984ee33ac7bcd01e5144d0c7ee7db140aabd26c9de11d2f3674e2e46f1fedf07ea37947bf37cbd454d8e979ee9c23ad046a74011555ce252f1f77e12ea382e33ae9f75255ebaec036130d2eaeda64290a8b456a0383f70ffac62fb6aaaa7df9e43c32bdf0e625de3c88291188c8655ffaee2bf4be650d97cc7faf8e2cb06d441091a7afcaa03676ff4d651546131d71658af558091a2caf3ec4ee62baff0c236364581738243c9c59b94d49e0e333023b7df7a70175b6bf751cae7d9ed2f5a65435611944f55c2972293ec035b853094b991282bf8aed00f1008c5e7a5012bddf2468a79f1c52a85d44962db4d2fdc0a5fbd632ddde968021f03f9cf4c03a44d0eca24f6592a212a38292e1b17239089c734bb2eb443e8dad5a876471d6137967ea8ae1518019bc94c5ba0fa90970bca2c61c1c725c25ec64147bd8b01c909ca716595d2a21dab4f6da4d49c64c08a2942b610bb9d35866943f6a80fc1f6d73324645131831a2a79551c45ef59aca9492ab90598f930dd1c29c6f23475452bac553700bad1f88a30889e44a7b46d9c197a2fc92e94e02ad7ef11f956580538c39490f62fb4c2dc8fb9f77e7f3a42c73aab5e66f8c7b900d559b518ca496ef3973c595877d8e558e51a4ace6ed28c4a19e86300a02a02f8e0f672fef7ceb570c158e3ceeba3bd15411f909ff2620a7d80abe2d6298b7cece2b699a945cf4670c649d72a4a312a126ec0250e9542982dadddc97bf9fa5edc3668ae408a035c325d258268aa8ebafe6f0b92d7a079764c690c2a33b16e37618a4336a980d6d6d78c6d023d849b14e6cc9924068903dff936f561a78f999de6d2e12b47cff7e7ae0808f35613a24ac46a01f7dfb687fe0d3affcc7fac410c8419f3fa48895f5869ce59ce85417e0cf57ed295fbe63972acf1033cfbb21e89823d81c24ac17ff33b570968ac0cffd897cdd258ae91b3cade492ed33560d7d7216a11173a8dbb969cb6566c5e767544d13d1af30b0ae0863a61ca0541dd7a118b95f7ac1e3ab438f167cd108fa22bb86a63751296869f49686d72f6bb14b6330a45b090940046e2bd2982d76e61a7a292ec7370e07b35acaaff8af772ce4bb63b4a4a8e3ce0892b600f777131b61b6bfc9c19f45ef75c6c16c88728640015b6de6746bc9e801ce3c292332451f96d18119c998676abaa3568c0c6ef867d47a2e4a905d7a2bcb7d31ea1b51e60b1c7cbed8ae6bec3a1a6032ffde09c24cd059507e48e336e47db57933def61eec5e1db5d390d0633cba074b72bbc2d176710b9ece683451f09e7079965554e591ce29357f54c634f3e7087ede6a3990dbecf193ea7e3a59ed7e074c353af655206c186b61ecdc4d036449f409c1844d11050c6d460dd4bfa739946fecfeec3e025dbb71226a9b6b86b19568bf16dcba9a5624a5bcc0384345374a2aa0969514c9c50ba12e056b907797525a6470229a2a23aa150150ac92f84835aae10dc03f28774dfe46eec609077cc773f78b7585f7ecf05479b70209dbded631c3b524937ba40cea3c006b6753faaf45f892768b0dcd2c76318ba971a65317e3f283cb448c7fe4dac4db071fc196664eefc7d874d327b9a3ebaa9b7f4c4126b21e726dcd6665bdca718c4e5ca0a84e36bf659767a0d5bb29798d6c181645039a1c070a3f0b0feb7351e5edf9b867822e119487aeeea81e8ae93b43350d38d516a2b3de04b0d7ad6100bfcf09f0c581cd61da0d0961a24b4542778dc6665052f93dc73a49f04a0043bd8220500b9978ac2f267b872cb8c832a6a562a1973bd29c6f999e1a856581da75b3c623833f2b813e6e3a231403117534c3b0d658af651694bc8572df1e97fcf36b580412a37dccaa863622d05dd952f44c8b82b0a785565a75042c9d4ce3c3040dd768395bd3710ed6c9ee2067cf0b64e3485ac170f9b2c1cbe74be9716de96dec31649ecf8f58d2d72f4017f930a2605864fc65426bd4f1ea92f8ad9347f24e9ae9f9e07fb16925b1a6feac95c45051764a07d1b3501ba08a8f7d17652377e9e870d1e3b4976083c5a0c81327b16f180d289c4a2c284f0217edd766246ba9817539b00c9b7daf8f2f80b73819aa8a6f3a996264fe28d9352f6d8b8b30c414388213a391b66c4907068b2566a35af4ff3a97e33dd18331afaade0cf479eb9c9d058a2876b68c1c447e776841cddd26b89b989ccb5f813e0bee05223c7a0f74832c183acc7c4823a0daeac1b46249553ac8f6b471b36c5e1b3fd1395cac6086de83248e127155b4ee850f32a132e7be2aa54056f0cb5813183c0124d35a4d0ce73a5fb66dcf25b6afaaf8a0514ce6e76325e9fbed0fe95132b8fd45b8335de1ee788a78e3578437c48893562bbc0f1b53b2a643aaa222347170def455d8bc79d41e485d8794ae1c66a7cfb0f7194069420aca92fd7e64cf2cd5aa451a4b24f9f7b92dfe27120768d41e5aa35270f26fc11e9f81a7f79a6b6972ba2f69d45df76035bcd1e220a52af6e0aec9bb89525f588d6c2b47e242952856d57b655bd4727f18c3aa732e715820014f5d982c3e5ccd6b7d88eb6e93157b591840a3aefb58fe60038897c8e9f768f8b3971a19a7788a51866608b701a8028b53e1b230dd1db991dfc40150f91207941a23c81df9343b6113a6152f75176472b4f91332f577f4f0b3ea40616ac224eea2f77218c09d179b7c1f32bb32f8740b20cd28b343e7badc389702896c464b58b6d1e25e2c32777fd6066f8296fafc05e80d47ddd8eda1930cc22e5b464ea534aa9b2337bd43dbb7334e40ad3df611cb0c29d5dbb9bc2d0015afa03983614e0980ac97ba2043192938296010d2c097ea601cbb1e0c012dfad6527fd523c7f9f87311fceaa29a7b6aa8104e88c10f99ff3576511ff177dba81b84e0d6b62a15e1bac6c5be3cf01968dc8df4d69c45a94dbad888cbcead54552ac2fe2090134e2c02bd07a95e613cf24259eb091c9ca7f60b2c471cf3c4bc6c66a89a82577f0bb9354f68fb9eadd534c120671274b1182873136fea6dd7568cb597d24c62815716265e98906877266629b509bdc745aed9c91b2bf43e1ec4332aa890c33611edeec56de700308c26ae713125912a075593d56e8ce42e99c1d40901ffcbbed9e5eb09400b869b53ccfd1588dd8a5078ff49c5c5d116621267588916af4941fd271f69288e4302e05377ea9e2c6747906c3e063a888de8123ff91798e5ee29cae7c2568d645aa6241717067c1002339761264ec470c53bea1bf4406c7317ce96581caa1ee0c57fe5c772173dafcde4d301bffa22d12d815d11b584b45aa87bebf847438c62477c8ef00c592344ff4aeed55998e573613b2926a3caa940639e975deef02ca8650d81a2a444db6e759eccc3de5eb29539973701eac4e2629b51eaebc00e1355aa2f57a76593aadc7b7ed5635f6aa75eda2f2df84a08a61233abaa743cfbace3aebb373fb6e23fc894fc0216c509da2d0d3de7287240fab28af34afb2276f00489284abf6f3c6dd68f760e718e0224e97de2605dc275874472493dd12ddb501d361aa2a56380a59560bd1dd8eb540c944d6374a64a6f7abeda9c37d13a5acca6ebd4efc4527be2e59079d58b99b05ce44de1c4b9210960848c36b27686d6904c861509d52614e2ef26112396850e19242e386cd01a06908634db7acd6f20c129d8f8ed08be3603921e91ef12665bdc35c2d630e72a80500ff26e057d81d7200238495ffef407060af82ca66177f1d744b7a2d850dc08d5a82e57fcc60b6ea3065ff63013da9a9dd98d9df59fbce96e267ef1879d1654320a8e2183a478101b493cd31d3a12f1037e4c2b6b736b027b477c36a6d0cfac87d7fde628f063c5c463e4476c64aec00ff5921a0a28c0bdcf65ef2a1661685dad007d5b31fb7bacfe85033ea4eaa56b7bd4f90dfef169243c5e070b9279543f3cce04a14ea79fc46055627a6cc3431c7f31149a9fe38666e022f777a5186efcb7199a8a9fe54b4667caecfa51e3ed58280937161ed53ccb13f9ab8e5c29633f4261719a5bf3576619c47cece427a67bc1fac43bf7cab57c738e9f689ce38aabc0d8444662b623be546b9f132fc897f5de8aab5871430d40a5bd96b8f3ffe64a7ede910ba31202817815bb66ca5c4c0b1d2ca7f23deef7d25fd9d7dad71691c379b2fb9f619a85c289830a81dc52317f356ea4523fc95f2fffadab13799411bd0ed5f1e0b788a0fad2fed35e557b9b1fbb5dd136ae674640fc8529b4a6a7253f54c35404c95392f6628b17104b6f238d8dbb322cbb1d934771ded8a809c5666ac5ddc916b2f23275f81d4ab8f4c343ea491c52471f8eea91c315f06a65515b1260f348e87c3f583e2fa6007a4c0ca828088c4bdf7ee79a11d445e4af8c2b301ee3262dd52328db562b8c66c5d41546e817dcb38661c58d304f9a21702e6152688dc44e2388e77a0b87780ea6edd6301bad446c40ca74cc3dc394bb397ba4007acc0772edab279b748e60f7078754c59bd06f68dcaa4d3e6397fe5453c6754f8c6f7dc45b38824205b32c7afd84f48493b9e616b26f87885bedc50d3873f340fa919861772d405d415981c84eac9c5559eec8677aaff8fe8b6806f3e7104bd742cf0a3ea1be67a95f9d8854cbe8446b83a1fbeb55388a2cca4e322aadf1f4232a83c16563d4bce30554e8ca59544eb5e1ac52088c07bad5743627ebdf7db09ff47a3109d93786862c40b5d6fed1f8f238ca64f66166bd76f302b814b60cc0c7cedc5d28286ad078d6b540145a8c7090db86da7e5c81ff6aba47153b971aa40cfc5f973e8a287d9a0b436cc2eef315f4246f3df6839d40df376aeba39a009f7661d1d2aead38b3e5c3220329f46c8f43a7fd7886f53ba630853ac648a8c5414266446dd94da09bdf8c47d3c3ce0af2ca9bef0d05024a1fab7b6a4d012706cd2fddde56b08e348c071082756d9438876455d2a5da3de5d7f74b1fb31578b4236e5a22f846a14481158d4dcce108e588c5c054ece05346342646e0e55d1186f6930282263f951bfab44872e77c3529f2f069bc807d8c7bb9290e4a2fd31278b03a0271010ca4ad9fe3491230bdb1cebd38fdbeedd1d0e4dfaeed700314620770b7cac970f5fe988e8161855e113bcc4c1e8e5669fc36a742c6a335f8c24397c4791d4f93e8c1f366adc8b715dd0e503e9bd3374748e71907abd59eac496731790c4035070fce826806277e620504a5bbce6b38fbd0ee7221956374a09da43f4707cc6da609b2fd0d337dc3fac261348c2638f620a1ede304d3308c113cf398b8d1669b5d4a0ac618db1a86effd77d073d77aa075f9a0301b4e35efc9958f3a5ccd5941d987c3678381fc1de71877b09debe82d2bfbb9d08dc60878d69dd2dc71b4fe6c22be1b50c4ea82026150492763990603d5e1c90979d364a400e461af9e96e5f63efa2b590e419cb83bef979e226d0b12f39f78065acd597166e9415ca28e13cf71dc4bc1d68586f9c7f6ab7e8c7705d8615dc556110f674745182c04842463be92364e67367eef8e601799b428839acbd3b50f91e0bbf5bf72b6442d9d02cee55b92a3465dbbe724be9dd08166c454d75a61429c21df66265128c7dfaece08bff2a06b9bf527491d295f097ba77c6d868ef4231a58c85e1fc14e1d9f2e9fd890b5727667dbd822c70ed1adc5a628274b77814c0d853edfdcb5133f825e790da932113dd7908041f8a485c8af95d9a7ef341074f07d3964594eb5edf656469c13f4fec204e7b110e5a140b269f893d6d888a8e3c5aadb543380b2933d8d62c82b645b8548019d17a38bd29bdaca35698981f262ad76274298f8d5cb2d33e3d6051f62926e95e2f292cbcb19e9e5249daae0fa0ffa5319315ac0d04569925221aa59ea410ccb977e22aa3496e0c48c604b5ff4c8754db7bc6a5ad5cbe232536b26c7e6b8eee025029eb89f96fa154153ad1bfe53a3fdf68956c0a631ec634dad43c7d63f425c5e6e832a8ead3bd9e02d98c8be30183a72a3d1081fe222200bd2bd2a2f2f47143ca47a8e9e7f81c7b981674e46f4e488fd0d459b224888536832abef11ac01633b89cd1c7b1eba24ef2d452fb29101dd344b8075dfc2368bdcda5d185d6c1c2bfd7c02bb144c4d1e09d60c9f24108ed5d216481b4445754974f9736f74d6da41b3646160a7bdb9343fc7211ac0b91309d3307fb5e2324326b830cdb0fcfc579c959b6a14b4c04fa0251f76cd3230ce90259cec258197742b755ff7908447fd8560007ed38977173298de8b172f0938231e82f6e5b3e6223b133de79cd065d3de80997fb57afece8d019081ba1594928d6ccbc68d0c4410f0ae258836e6e1dc6b2fc359caf22dfee115926b2e196fd8f0cbd936028e011ed50832c4d01fe47aa47b63531872b48a5c3573da03c20a5dd0b0d75113e6d89ca8e74f91db4cd8415f7d248e5daca922c8991f07b45d0ffc1c8559e963aefe724adb248961a2c1b78e38e5593b92fb5c3dc3cdd4569a2c9f9d9912cae2144903251afcef44122841ee7f19a219eec966d8262abd24ce49024b7028e185992c9a4bdfa727ab1935408841922dba4d2c437b096028523dde69c240f37f16af44b5335da4330f4b4ac7bd2d2be6909556e36898db96eaadc449cf75f57094db6da0786de63ca24d178c1ef87e9232a2155cb5a509cb597361f875a23b230898fcd8ea84d9bdb6d1a4848a266547bf218e0ad66f38000c9444a24e00b5e01ab6a76eb815a6f073559306f5612f15948f31202228b2f1dc486708f091f220fea288dc818c6bc5b6f019fc586a17bbc90c2787919e4770f2b7e168f3ede3d24324ab2e4402ca1e9f0ea104ce026623ff86ba63b1a20e3a3983bda7248f48ee9f75a06916f85fea96c0224311c57183455c3a043af2eb1e19a6cc421f5358df09e9cc70c79fa878fb72f89d6c01ff420ace5b6a0e251732944e7e617792a2a473bfbad825e45e42be73a00b2ae1c14bc86f5e1e6c2a44defb1f0abbf27fb36e9d4b50758ef6ec739ea0ca2b1bd58c1abf53a4c21d9d9dc6d8ee48a0d338322cb38320cd19571b91c74cc6541800fdc8f2baa1d75d61dbb07daa6863714f517a7f068e1021ce29fa61ae3a4318bd0a275febc9b2e05475ee264d706c2b3b4267166ea9799b4130254606960ac0af9c4599c6ffc3e7473d9a90cae575709fc91955dae5e82e4cd079cde2564f62eff04b1a80e8be2d4c57f8a01cb3adc71e7a8f88baa50381d62cb0ff77661f95671a578b2e835b91bb72236996355302ff66e989cf0d87dfbc36ffd1b4fdf6fd98b1de34cceb32bfdc26c65c3646188d54e0bf7c2111b840a4f72ed22f7cfdd2f843a8bb2320255dd2a5e9471763d9ec6f3d8848e2a545a0feffc528f7dea737177c57919e51d94bf7a7ca6fbfc112e9d819620a3d0d2bc913b05174d2f90872bb637ba7397d371f89d39e7801be71e0e1128229694082e586eeba3be43d2545a2c6c4d45043b858b6e18732e3320c52ffeeabd62965053bd4a3c5b9163ca7be2e5687a6b6b10b343c8b080ec4898318e1e06608bafd9aa9ef5963670f41f6d55273f83767275d38e1dc83374483fb5c5942131197793e181d5be49226d665f38320e001191d76f9fb5eeebf2b843aff01066f5bccc5da82b0475c35cd8ee65b94f78e9de4a083ad26c2bb6237758753ceb5e013c0718801889017fbc83ddfa58c16d07a5a1d5c07df87697b1e06b10a16f83e8f57a6b370f24bb5003aab89b490d50b4ee3ba3b9169f349d081f0840f0d6805b65602b144a2de99abccc87b76979901cf4e8cabe2f8fae5fa9d34d0f9552056235d87980b804d2940f8741fd03e3798b1e6bda4a9a47529f4f6b218f698f2282aeeacbd15e219ec461bb49477c046193ffeb2134c3aec77552df3aef08e56b6bda8ddf370914239b7965e3bbf07a5612b5344b235a894e9fcdea1c36a3e925bf47cf2f35d40ff5add357a170291a193b0e9f385f4ce2e54648d17597055b59baa3fdd640e771cdc181283cccd2902357045c15bbb7abdece15e6f114f8bac27a1fdd6e85c3078144116bfb60ff489045811b1ff976a0756a84743d62c6fdcfeadb9498c6b8a44fbe3d479e047ce07dedebee581235ebc56c40e3190dbf5e94b966e0e62f0ee973b0d82ed69725a3522ea107b4f5f6d666dc5f72de8078df9bfbd9acbc8002cfc4971ad6214215ca97690cc0c4d4c83339e5c22d07817dc8f1c110942a80d28554ba4d5a820d43ebaf5fb1f772218139c305fcfe3fa6c2ff6ef184294b473fb98c31aa33e88f1ec3aa2a5c8bbbb9226c95a87e5311545cd8460070f3a943c90b47f259fea586546a4e34e65085e031c01177a90a2cae74f0bc03d5b4a3af98fb376b11cebb4223710a5d1142dd701a6125094b74acf5cdeb9fdc21658ea82095cbbb7c07eda2409dcbbce40e4069d43989631096003bd46fb05901f211452e0a7eec9da1b3969ddd70a723cb119bb808fe68e96a76cb5920cdab5daee7a2b8cbd5f8153329b54cdd3f4e814f5956762b6780bca7779d1f2749caa98f61e015de15d97139a8c91f7d06fdb972516c6698a0e1481666864586f8f9bfee11a37323d4050fa26f584c0957cf7d371c4337bc40818f73b53690782358950d08b4b058f96831d6a68224d7bb573631fd7fd8fae0078f5cc12f658e1f561a55496fc6a86a7b56a47489203b5afe8fc1918ddcb3c855e0297ea51ceecfa5b3c489e81fad29a21bf1a100e1be47c666587dbbccad371664370fa2c5bc0fd6957178d98338ed94325f9446dfc860744288e0835a587a69c6cee3e9622cfc071fb8c56ef64a4e7c3c1d6eece79f2a828b51533c06261beb6aaae964d478b043158936dda64d434e7890594ed8f5c6890c1eff270946f3fb2f84f30ebc5a57485ee53df09b43baedde802a3ed1995f7d7b1a4ccd14f2f7453f9f8580609a28ac8fe097b9ebe3bd28e3c27fb4ae9079441aee2d821bfe4d7a43b89bdae7546afb39f219463f407f9a4354f6ce65f176093eb6718c0a5f6c0c3cd8662b0b5dace9f6b8d98b831b9da47646755e2b8333d948a44ee41650f71c066c7468db4b4d872bf6cd6000d0be5fcd2c6367a8ea6d66801ef2a1ec4b6681cbe8470b852609f81420ea1fd9ac1519962a6e0afd7b33397199f1f1c43019c9b2edda520855867c3bd7555bad6955f675f37bc96fe25acadd1fede9a922e4fd18728bf569d29d70eb9cd407e64b85f430ce2ce5c0b7b41ac5017d0165a47d98cb97cabb21e082153700c62aed86251e16fb4d76aaf4325477f7742b8d373ef4e91162e426af31c8eeb57cf60ee2eb85a8c9ed3ff8745021336ea364a1bc08db7e095843fc250b790c2a86df1581a4eba043a5ee2a53a0522957a69e1ab742416844c883c54351e70e83b7b6fb0ec4781330e3d51be030caa9495c1d34a46b4591064cf0b969e6e360f063e75ffc4b9236e7d499607729a9af0bf091610f178af5f9345e600268b3ddc2f155b4cb3dd421adc3d6735b97a99893980d0a46180a91ed93bf674d9e8629697b2f43aa60eb0e72e426bd6028a24981cec6062cbd2d7968493dcf6f36486ecbe4b213a64e43e7f8396395e899f5b5ebbd913589982b27f55e3150097bccc7f3491d8b898b568f71eb6b2d91cf681224ce456424107336b9a0a4fb0aa3e3ba45cf608e81f05330b9d8ad2ab3d3aa13b84cd8bcfbc6e1ccfd3ee0f1242c3f200f34b01e2df2e935fe0d6c0af682e515631195313fafab4b1fe0e81f6d3f75cc3f3d43fa0d5a4d1385a031bbd7b006fcffd536915e2b93c3e6c4663e583e4d54b8cc9a31f600100b43750d41014a26ddc3b2ec4fd83fd0270aad440e308288c2ae7b05cd5929c6eb7a29941669425ac65ccb66421dff285aee75d20117c0fb38861b43e8bce913a78f726023e6b526545451f31c443f8c6de45efc3b40b1423e1404a2153c7a47fd3ef437f344947e4cfb8a17b0c5745c77b2afd327e90680e465e40edbda0d99ebb6b03e3603efcd0560982c32b9559927f95dea3b8ccfde28dcbe3bbe06072cd5fe9490d902b18231911353d317f3f9c10f4def110a771af7ae8111f6b9075813d3a82669a645780e8a7b5f70b319fce181c4b1bb247dbd71c01f87fcde3d98921f9e23cda7a10df79370ae37593201aca4b0f4fe0af3791ee574c88dc51bdd93fda31159147055269a2d3c79c4c86f560306ec483ab74ddb86f150655f374fe94d74ac64238fa8a214a11121140730b5b5d5a007a9b0cda511957e5fcfb6374395c05bd77903b6f3d5e269bc9ea6be7f2e5d0fc82e08fa35a87aea75a21f100d5c216dc93719bea393869d592cef1d2a1f35237939bf2df36069c8fc0d33b4d0ac5f04494ef6a6945ae0e1e79c0e7376048b8fc8569d35654790308e5c7106e0c4e5921a69c8678a3a4526e6f1fc3be7f3551326f7ab1291ac6168bf427b5cdfa2bd8f823236f1ce460512817a0cda36dcb0184f71b4da5ba30e0eb18d38044d5edb5dd79b274d4a61d112a976350bb341146f8123d97192d29527a9545affbed6377009bc13a978697846a1030b1ae40f1e363915ab6704017162e6382f2f81b8afb4105093d0b1f7919e08e2856785e9322e8e9bdb2cb6e8840022ab7f483c9cb4d11d5b5a3f92de986b7f8bf69222890663b234d68767a4fa0431f388d77ac2f211a05495e34cfcdd439c9c0e3dd7f6730a3497946bc5ea072a1bb6df4d756c1e987ee246412bee0d32a7a920b6e9c8a8921e50962435bd51a40fc200b3f47271ffb22d32c892d46cbb1981f8b2c13614ac982e8a68709da35438064de450605669235b64b89a66d2131e628d3dbe6c0d09a799e5de4f1a92bfc7981b9c971bb3bce63213cc90d42eb8b289b3ca9f3319041e8a0b376ea999b5153e49b0d796518b4098b92c908b527a00f375a01b6bfbbc3e601045c06ce4744e10dd3a57461584af4f9a50cb5b6a9e41239b8e453403e0ba7d48a792c65fd71f18f2c4acdfa109c997e3797376af3170dafe5d596f0a3d516de9c32fcb6941e9c2d90be50471a2fd0fc9003c86a6cb3cbd26fd8479dc3391a14e01c9427423cde845b0a009c6349309d5fb64653b6005a70b014a5e2805f226326f92081c4bcf2435c457afb9cbdf5e6f0e0586a1b8477e63573dea0927772053366d44831fadea07625d66dba51710882b26ccbfd314e704da7870e1f858d6cf8f69103da0392c96c9a445bf7f62a547b06a9e37bf22cc39faa8912bd1aa2fafcbeb9395accd9c84f882dd82dac5ac01f4adba46a2bafe0f294a8f54bd1d6b81d1757f588424f1897efb4e72d0c045fb043523c68d67d45916f32c336c1a03dc9c6d878bddadb895817a4c2b430e21f3d43e7aee4becc285f725da5efab04b81ea59bdd2c0d5adbe4344b302719a0bc08594d1dcdd89408483534d543f5582aa1ed8d98a248957eea09b58be1a15bedc63bb0c3f8e34ca8bf969e0475a2ff2b604e5dd7533b978487f0253d1433d69f1bae3b1134d46fc13f19199712410e632c38364dd3c7c5ae30e128c66b830c455a649c24906753c7b6b92bacd4a7bd645ca70d61d8b9dcab18299a973df74f90539e8c9346b0c3e528a83ab3ee75b9785daaac370ca67a3d6564960acaf5794439c5ecacb8d311a28e9f4a0b8e06821b03b41ec5db4e454d76c159c346ce986ff59cdeb0c733d8fd55bd3c00c588b5c340777819f4a2599818fcb58c349559d954e03832c92e547a01974fd9d43e3cb3529245e9d766efbfed3300918fbb7aef2d5e501ca3cc38a846a6130c4d60a218b91de24d666c01e32d270bfb369d86995e3e9ae2376f9cadab537fb57562eabbfa045bd25b67e8dd4fe3f7ec7bd0e9cb25e83940716cc6e8ea77dc048fea994ac29469062e8b7242ac656be885e289231c43fdcab588a8d5ab70a6baa26d28c8fe4e8473a3a96cc8591f42fc43888c8db3275e0896ef5935390a1515ea7020bad0730187a73daa9a712a9a6e467d9570b83dc599be63873f198deea8afda8de7f192bc9c3bd1c022cd1d2b0bb5ad848e326bd058c2ad4c059a46490e65927f42e076a676a428b7fb8f9f09153634c7996465d79a89faa1e17179288cb117ef6399f850f188c66ca9ded7b85943d180d6c508034a3b893b646c179d5b625c09a13b716ec8343","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
