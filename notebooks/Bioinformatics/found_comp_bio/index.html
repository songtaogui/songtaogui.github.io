<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a5f77b34152965a0fd8878d1b8d5d540bb7f6702eaa8640b4e944d81f2b7abc74faa3e6f768268f19b1c3a97961b0bf765eed80791f3a31553073c487d659c006379b80de7b0564fa46107d6b06f24ba41b9bbc9028b60e5b9a7843c61b3fef2703c6c297b8c8ccc3b0e79ebe6d71c16f53d587872eca0702f3cbd4689296f869a356e2668c0a93480e00b7728bf0a54653e6cbbda3b4f03eaf2422fe7c8a58f4f7ff1b00ba10e0c1f2593612a6c82eb4684b06bb354327a349468c824933ca95be62eb050a13ae75c334c3b8bb2f96f2857bf1a80e8d6501fc85d9d6f4be6c277c37305fa559d731fcf8d7549faab5aed91ed9eed96282ca5689c220a4db8880a8e88c0013272d29422fe6eac285b73e0a9c96d7c37dad34e0a3f197e5d139430454e44cf7d7e2c8550c441fcc684e0cec7d7143125a5d9ba00d81fc3d0abb2442a133c7fe2d8ee47a12e2952c2b2f8a026a62c677acd11680aec65e00ce96f2700837c702172bd836ff49a53cb3e348de972691445e863e6febf06d373e08c7d2d3ad0435f21015c5bea96d7079674702a61fabf0c946d475603f57cb2f701645cdcd0c2c236b496db2ce3ab94dcea3781dbf5ffe60d284cd9efe1c0603e391e365d509cc2418b9d9838dfe529a29e53edea686df414a3c7b59d0a71a9e2a4c8fde67bc562ccf0f7213791451609aeda8213929382b3943816e20a53232dc15ac68af73b3755fb7c8933fc14f8938199acff66ef7c140367eb33af4b4bb59d014ba2074710bd892decdea990b9c218f69a8af397ee87b4d4b01a66e7d93db94db4b21546d4329d6f77793669576a4a9b8729be193a4649c230935619b3a5fc66afe533ab88c3096de923e8f0ed99148ee60e2dc9d6fae2a0863991441f36ae22a46c0d18436cc74884601931ec4bf6aaf207d02b6bcdcc5161b858a9d34e730fa3930824e000358f87c87115b6b5687c1beacd148be88ce5c42dea10c1af59662f6b32d6b9344a504c2e203217564a4bf804c3f1b4e8dc33006417125a13f063ca7f33ec72a4873b650db2528414c5fedec53c1d71f771893fd20db1c54686728421ab9b2314233fbe100451992695b33d40fcab7012c175b58a2f743132ee3717582eaa269cd5247aa9505223720e4f2500f9eb1fcd3e35ab27a29dc7ecff35ae5add5bcc91106cb64a538554f37a360fe007ceb59ecbdda15f6c31d343b0735c03207c410cc73bdbfc63f9e8d7f84ab71c8e27c50220063aa24a3ef180edada38739bf12b9f6bc56aa82577004aaa0ddca016ee2fae212de7839afd8bef40b31137df456248f8f341148878f5a5071da101c0467e5880067797211ee0bc12f4a87a186196eb9edf61e2f5817a3798b8601ead5c913d3a119d16443f0041519b3c2c9cc3ea76ddc25800cd8c4b3b8ca0dc4816cd699b45f5313daa1af7edf0d2396f6b107f026c6c8c4120bf8848a090f29a989e6cf9e68e69247599542fb5a04c81348cdc864cb95a3d3b9750539bde90b2878dfa006fd4a8c5b039b304f0ff26ca0794776cf27555b8f56a1b405557a418372264cee0ff53862472708ca447a0729fdf59401445aea13a99b6491ed6291f4c170a893c350b5491721a675ad9ec1751068a2df87206b4b0398f28893dc8dd629abfd6ff4ceb4c0bbfac6b1a3fde026aaaf81b9a4bfa8a82b4989defa22edc2a081ec32993f6887e7bc5deaba77a717205a16dfa737e406cc146ceb033c87d6ab8bacb3b0e6ea155d06a6c09dbff33218d0ff6628f07a33a3f8f368a8825058043a214e6a49bfc4e83cdc58df7ad3a17f23fca99b622231bb8822a72baac275389a716326e5430537c8ff5929c6b7bbb17b081db1e9c1b8fb1773ec61d408a8a640821830014faa3ea08eb6061a32e73528cc0b9fd7c1b8f6e04fca2740d91851e3437a9fec182cc46aefaa1e4be507d13e42b96f9faa3f12a98e1bab8390f73427d56efe577a488782bc61050fd0a3686acc8fd1fe52d2f8469ef1bd3fceaa1e8e48dc4123a2dd5aa81c9198d0da8bc2b4785d838969ba3398644f9d630dd89592a6a12e615fa748acd3f55672acbf89d7d18ca286c47fa54b9c077bb639005f4465e2db6383724d092413a5567e49542eab7e7bda276d0b7990925205fb48ad895298331c925f14a98ffb11a810fc1b128243c6319818e429e715c81e2c29cffe473578ec9b7a02e08ee1eb41fd64c678bfdf62abb0596b71456fef20dd179a5248c43582073d28f4f2ab6a51c9bbd2725bca9e847fc65aaf452ec0633627ed3224d01939aebe5b8ec62476457f0a78f23798b362fc29cea4720ce874691dae4deba80c2848fa4e8f06f94305b0d61529812b3835e771d4699e127f34e4602d10ae1ecf7ea8d0331579dbc22a560b52842225e8a91f9bf6be0f852b9c40d8828384d2e302ce7601224c0dc30e1a39aacd95fb53409f33d3fb3197709ac3c984a67099d89f6e136cc4fea68848b503b26c6baaa0faa03d488b14e0ab4d142dac84aa33e23e5a291eb5c28ccbf1e72eece0739f58927a213c5fd7049312341fc82cb839746dbb4450cbfd0cdee1fade91f2c68ca23f5df34d77a1053a390a02664515d326e10d8d3d64b39634a562c0b9eabd5e57ab39f4867f930c4af64f99afc001b58b7e608cbb1e5f377c82cc81e10d1bbab1c66c30b7eb1006d51ab30a154d16fa0e261ed7af4650653b091dddb0bca12995e19b786d9bd73f29a770068b33c3664fa21ec597508086028fcb097179900fac1430b62bc61d1c6f14d64a261c08af6c1b5b77facd141f967023909900e4018519b58c56bf6280a630cecd2aa5243d5834835ff3878471031b50910ead8d39c36c771973646168973fd0b15c510a1b500c823074c7236047802ce964d37e321c3362c2594d80a885d5f6cf9b267915da3348092bf91d169bb8777612566b5bd046e15e5a22a51ae3cd38bc560fd9fff7ef73e9bcbc02dbeada2c39698d96c2173dfd7649fc104df7bef2666ccf43283ab139d068fdd4ff987ceee787aa8693b5c90fca62c3c4d8410e8a666a76bc53b5f696ab08361a1ea66fc363b45afb74d49697757de9b861453ff42d006bcb3946812f6a79a867a31d35db47c37a14df5d7ae78503d24b32d7030d00edbcef4fc2799772d8b144517c3b5cb3d0adf5d8233cc4fe88e520d06485f0ea97914d92ab3bb59f5445bdc705ed962ae738b1692d173e61f866c1f7d22886a4a367d2a0cb791beef698ee56289f6c00d0952de21f2837f01b8e49a2af8aa24ada7b02de743a280d4fcb5b0a7c952cfa48778007ec9776a54f82032f85f0c832b88232b538b48aa24eb5e4b6bc9d7f3de218c309de96351be869b86228496eb0c49d915038e5271f534074d71e38fa8df67428ac2c455d7f0d275ec029e4dda7b06e9fafe901d12da2169239bca80376a220e9b11d344423451781f57f19e75f4d784459cc0c1c7c38a8ddf7f596687427f7969cc24410a0509db1503aa957b1d9568d074743358de448e9be4ad0498004a34812f67c868fe66dea04f0a2417ac49ec89b511c38c4deed3deb719664c42a0dc962b3e0ea3fc2bccdf2a24166e50b925735d929eeea15a79df5b1754fbfa40bf6480de8870fbe1738265475eca5cf0e4b8fd5c945871ed966564d4594934fc5a5f0ccd650ce9c0e5bd603b96eb8e3a222f23afa00e843248c464e504465208ab1ac7edd77709db5fce85a8dc09cc50e6a1b49fd2458f597c39063933bada826fe8f8cab3eb64ae2b27cafc717092e3dc352cec5487cd8be966c3efa9e46faa35992576d0eb03800b18d726d58e4d4951c4c54083cafda473bb4989c2bfd8d7ecc209fedf45790daa9d29ed099d9f506f0420a1e44b97769f5b38f94cd47998d9ea55a9d51a8ae08774289a6b386650dfe125a20f5c15d10ef07e747c87f092713a791e582113b8c2089447eb3bad491a45a35894f1289720f1f9b433f58da7a5eebc99ae781bdead6f03a8e5feeb58a28be1221c503bd11f0b02fbc92fdacf792de6a2b6d356b08a3ff57c53255088e5d2088a44520b24f7ade00381bf10126bcb2a3f01bb9807347acc9a5e278b8891471c8e5bdb9cb722aa077849ef5c6191f790ca94a87428a32b4fa1262ac28838d0360d70927c6d745e3189458d0a24bdc73323c43ad8c37e86a7ad5bc243aaeefe3db7b6d10c7fef9d4f4906ec5e3f4685eceba4dcf497d60596060220fa9c0b6defcacea72b22bc5f2ae2e4dc106e30e8cbf4921f6948604df29284194079a77dfadacd6388124f31ab62c9cd720a3fd91cd13133de751a6693cfa836d92cf6b1a339b78079a60ee6883f52e5f7a7176c37479c4b4c4fffd7a5a7ae45cabee2a8e941632b8ec541a480207ea9dffa4fff891e3de997f455a72c357985a37faa23d77b2c8ad13e061bd137b7dbf01a38e07d4ec52889c874bb975996894d292fe1952ff3c0bf5a1622a2116a9a5172922d3de4d6e2974830766a17ed2a5c916b2ed2f4535a836f141df27adcc45524b1a104cd72aaec0c6c6eadcec33dabd58f52ec5575b0aef6385b5a5478de3b7e0082efb4336bd38ea34a5fcdaeca0c677ca7aa72d494ebb99f10bd07eb030fd180d06f30d498c62f8da1ca9f003a7223b992a592e1ce6f45c977479e0cc77e25e2e836a41187a174d71e4e714b4ef6282138822806a7e6af6d7677c37536d45c5e3cd1784f301c29d7583566b0be18a30d03d173aa4d81d1b56253a0665444af65d5e566486004b621f9593e6c09919be6a39512ef25ee04be124252693b56883de88e9e6abc0da02b254ae0102b28a05ef82c832f051dc7b9c8b460a7b0bf7b6bfd9d30b9d09b85a26b356e77e401c104816440df3f31de631c9d98e175537d968f88a4713cef5bf08e350ac6afd75ad0171b052183d31b26b4102473b1af25af8f86ddb5286184502c612419b6bd6bd3d07485fe56a482e4239d37ecf5a93680a21873fb79cb824a02f92514594980a2d091ae6e303681e474a6042d0abe41bd87da37511bca6091f12f13e5677b063bea7ae35f510aee8f2b74222bb2a9a9eadef8d36570a3317dd07a597a5ceb4bf95a9f13948a089e4baa5f8c2712d7e6e1ca07822c34d98553aa5ae5ee4de00065038711ffde3552a1f048630eca7e72c047f380672acc1b829ca070f94e078c2326809eb181910738407d319551f2c7fc560e8f00411f1d9fd1ad38ca5c8befb1929090704a811756c74876dd9ab9744295972f404ee61f8d9fff3230b4a8618f54a72c5458d80b29524e81bc95185e5c814919b97d1a14f72663759ace287a4c25fc760cf707f025ff61b45ad0c894d1f3e99ed89d53612b3c25f6544385564cc77de2bf9b6ce9ac2b3ca4134f526e40e9220a35802c7e1def90ebe84b9f05fe651aa067e26075b1a487531d35a64e8e819f094f703337e6ad35a45899711a4485cb83a78fa68c714fa5984617517fc3f083d38555dbb17ca9d821169d527935919ee2b832a1b1e53b6a39527080dbfb28c83f194a3307b0c8892d9edfb65bd2274dea5a3275f6787c58bae8eb17be43fcbeb9a7b2d5be7ce13faa673eb3ad1d9364ba1fe01b719238b6982e82fbfc440e4b9a90ed8640ed5dff11c6b040f03b867c58ddab3b10d764bb5dc664e3ac33724013917e4adb45015b92b03ef9c3a8be02ac6d202e13e249db2491ddcb2cfe8fd61911792840c6493306f06c2e84d9369649561df68fd42a0ce3ad195d3f79a098e6f601b487e2c96e0bf1116b0d77a957211eb016184a91b6ed913c598bdf28fd6b4f01fbf4510333d3ef28d17307a4f8bfd576252b29868548c445a9d46624555dd35a99989ae6fa008e6aa411829e9b61ae3a0d4a4671b3cd7edb128cbbb262bf70d7ae5c8a4154424fb974880e8a4d698655a79f6ffb27e9ce1c29911be8a1b93f7011acb5ad516a997aaccaf8ab1c38305006701404e83827d48558f6a098528314ffa5b3278edb7776f96014e32d2d7f70c1a1b0fe36c0804240a0fb96b57b9591c642b1c785165f3d139ba30dbf537de82e03f652ee5b18606631bd853d38428639b48ccb78edfdb711d2739051c0f11cd9935e0575a34fd230be21769a91d73f16da38aab1fcf2e5c2045e54241cb33a4cd2211a7eff378ff5d422a08f224092196fff56ef273417c35b8022d9a1fec3704f53b19d41b133c1972a6002d59ddeb169344a6b2a575ea8ffa505f5df260be75dee7bd3312d6d3e5e2f3a58a1b4c77bb6015fa7597282ef4cee28312e40267e540ddb08cbcf3f638ed7a43763a89d6574b64ace9a0880fb21b5e3cd4d95cf183ad3629d726f1b6f7784cd2768e056290ecf144d7871ab8ecd6cda532db878a85437155374d01350c50a063d68073b01d26e77ce24e00e22ef84e9a7fef5f2abacf7d90f2174aadd276f3848f5d0cd800f6d310efed0fe54964cf13f390b68162b96fbb9a6364375135e29ea69c90d363325012a4b6e87393b6e1dacb6ff087c8d8c49e1e1caa7164d8fbffc09303983affcc424b6cb6608c68e1005baa49aebb14c884df64494d853f9dcce7fb7d9dc271b6f6cdd81d9110bf5656b4c14b15065a6eee4cbc7c6ce00d204a6ecbe19e821d1a05fc97fe89b7c71a7612284eca1dc6168790d13fe7aea564614dc9638d9d703dd9ef137d73173650686f5384bfc5927a21412bc00c4cfc107d58eea4722f6a4aee6fc2a16390cd937341dfb7cd55aa2c7d5fe482e96b499865d58515b03100c6cc5286fde7e59bb8592cf18ef32089acbdcde43dc332982570546d17c1aa7a8c673f4138904ec4695450e02f976c12368ecfc8245e20eb5ef5526dd7c43f44fe4b3a297c78d4844a59dfd7755309c2bfa14729f19b60ac2f9658b20179cc249a068bd8dcc8e0260d2270bd160871c028c0d2e3157024105d5f9dc6d8c3a090cea11cc76f85e92f9e1b7e98c8887b172b2138e8fec8b8825d1980efd6b22a5dfefb91aab339d74778e1b0ce614d984af0e763d5e54a80f16f9373e7f2d807057d3e4caa9ad7d7d5f762178773b9a31862add9009a442fb4c7c613561711925ff523548a5790593252ef4f3d5812a860f3e6a15c40a81146e8c651d52db71e09f918f227c33a214966ade052c9dc54a270541da32f255fcc392c19b8f285ef23ffe9539c9b49abaa290cd66e4ddd09736e5fa43b33331586bfad1742c7bdc705c3b3acfb39bb9b68ddd9443a003249cca289c251e76e71ba72b40764c589f550bda21be589df8ce2942789c82f1c31400d4d79dee4ee302727eaf1c2067f838bb880257339e6ef054255746f5e5f6de601a7f9514cbd17b7f05296c64fdbd80805c3e9524f3ee1182900b3dea11837cc1cba95be3860d1e313ca7527faa8574d04a7f81e212b02dd829ba5d9389cb402e4fcbdaf066dbd28710c7a6ca6ddcc9437051ddd355ea2b606a69d2f17c9e28eb778369ff491e2007b903c278b82de9034d96db678b8003c5b51e51bf42f8e8c5a387d2ce44a40f86ab4e3ff0205e95a48d883b6315c4101fd0f74d1936a4d420a3e8313dcbf5366a1ecd280a45eb1f4d282387089df8d9b31d551da49910e3edb2ac4a872672dca43dd837bd7242f7b7343ff9a02df23a10e3d811553b5ae76143cd31aa537c0f6d43927d3d736062046ddd6d366a51085c6dba905d6a44a1135ba01461dd801e58389a7d887a50be49d0a4ca13e2018c0e6acacb70cc2fb171499256c4a53b811ba8baed41b9f77ad5d46e4b7722c6afae0088e43c86a172fc74be97984d07a3085dfc9c534fa1855cfdc1f3c879aa7a76eea8a2486bc20576ab22e93e2a32103b41489aa26245dbf00c3146f13681b5931fc17dc8ce99307c5048944d8d25cb4bbaaef682b6e2febc64ee91c1c81063a8fd264d647925fe6ee5c33936a216e002d82346d1f497bd04f30bff7a6b195cdb93cde5073c439035d08a4ceee48d1daf761d4c6c657b24655b25a442ddae56e9f4a7bb8b92437b62c8ddd04a46d413d36133c474894606a094cd88b440c117d9c34921a9f86c9082e5bedaa1e5ca72682488ca9478e39aa8d135f65eccb3baeaa2253143ed6bd609ab95b6c2c2b6e9396995c8e939333984b0415b52d93f5e1b505ea6d8cafac71183d20f4f7bb7a18b786474ce40a1768b3601917b0e0af06ca43f82e841d75fc734ca03d6e4949762cdfb48e7f9a65a2bf06c5e4b11bb47757d7160536e741b013bd58f2bad2819ff43a3cc27185ca9f7cc0082af3ff1438cc3d416633d84419bb5d15904d49a5775a493783bacb27f7b02ca68aeb7a9e6b2102879cacce20c6705dbf03caff1eb9bb016c970f215c4425693eadfbe03364f2293477ba2392e9b37bf82de7c93f6174534327822f729049a11ae19594b0bf074f13663b09f3a087ad3897cca6ecea743721a34e543a4138adf499584c1eba97c5f818ccc130238a0728b517344972a1f0eb32b110188755165d3905f82ff149cdcc6b452efbf15d7f521d39e21495abc2fc57f2839ab8866cded60a45fa9aca800224e6d534193f96ec6221ded9ef2d42e2033c266eaf2b8c034167a21471859a42650c28bf7525c11b4426b39ff437b92bddd7258304b60992ee268849ecfba2a7a72e3989b30a67f13ae70b654a73425cb882f1c3d44f4bc7684ba34a8b09709ff2cf49417ddd713377de5bbf7526941e8751a6e3ea2bec60abe00ff9bb04df653864c7537b7c1e8d9345158923cc143c61dd0e256502163446d7d8f6bb13bdeefc6e0f4def2abf971addb9b44a4827999a4680be051e385fd3cc146072c1f08ea312358d55c6333325a1f1e33490e79fa83e5b59c5673b9c5f34d8239dcb15ee7480b623b04964a5bd1b4eea6ffdde16297d973581ee39c4dd729c4cb380cb3dbb9d087cf1474f553bb5d9cc9caca0f56118138678949b0f37b4407800cabde5dca5f2962ce9df526eadfea9c2e4faf796bb9b4bc7392262735366da12b171204a019d366fda0487da1f654819ddecd819ab2115d249ea81a9e92bf00edabb1c7a49fd1f7fbb3e6f9cb761a3edc99dfe9c4da0c67c40f2951ed2360d12f31f70f978425ceabeb26921312ae0706e2d119c9ac43ac3ce12f0134ce95c5b30e680897b2f826837692d1bc51096d9fff9b3dbafd9a03b6788be538063e28892fe7b3cf6d613469d88505d04aa5a26c4ad379824f1b603349e5bc2d7ef378f0f7e5215441e65b1fd3973bf96999301d71430ec1e2303ec40301d37464a4c7d383110418e8b2157398846d39a243fec806c9880e0b0aa0910297f1cc20d4be05f0f5446b8ff393c546ba5630ce565e5782c987683e0c09a23e81d317530ffe10e8e5eb5e00bd90941a640ec07247d6a960c4130ea3b48d444f2235d07edd9ba605409fe1da034c1fd0305836fcd6361084330778a526ae820ac256463b2293699aca4c604cc67fe76bd0267645c3088a1a16e3c6a07b99394d4616ab9a14692d29fae0459928ca9cf6d9dea3018a40b160ea40691e6c643b99fa680be554b519851c77be401f1c734621a12ee1d8fbab52a8f76194037a19ea0b85863bccc404a6870069b678c478e8db8bc4a48764d832420e177caf7503cc8284389f2ea96e3bab7e41bbbc477df248a40bea45937d93d3f17375f6c26e384fb6a2c292ae979422ed6d8cda500748a73ce8a5b3bbff3110fe222d4f7ba7f12f84001ec0bc135815ee855f94e57539d69cf32a4f1dbc01d3c4eb66019a68968a6a77fd47f357bcdc1eb37de4be50b696d8fbb79697cafd243f18c7ba8eef282c893f1524b7f4ab725745e16f1b96b842f04cd05529874068e1a6629d3e60ee462722c9e187cc92a55dac1634becfc564467cae14bf52671931bc0314044c38b1028bc3c024add63e7a67fcc52fdccc1717f71348abc0f10657430cfe8156b71268d50477c3457a7a25cfbb54897a8da4ffeab5a6722a345fe2b28b134c0e1c918955b3b81d1faa85ba40fce85d3d8b331699e52f030a2dd9495977538eecd9eb6d1d675ae33ceb7efb53c5e45309e3c7c79a93d6c0170f75be1b9e3f62b407d9c35af9663acce20592e72553e4404b5857af90b34525588c21f1b9690d8b6233c6307fc5845ade455a8a82f9350714cbc0bdb4a3fc18d71b711b468c0acadcd55eb6379c60da11461f75ef40897d030aaeeb58863de9d7668a038370f980669d130a309aeca005483a03f9ccf9be50ea7007f346787aca2f5fa9d94de3890c2c7e2d1d6a1d31c2fc56367d7f4ba47c618adbba3b01ce0c8aafd79c9bf0d5420137eaf059752d8a384961359ccea1a2da339f46082a62c350a4b688383e9406018b02fa929e5e7e47db37a8463d21d745ecaf0ff1b47d20eef8c805809e293792f1c395e432a49291b283c37f0d967cf8430b6e7b557a5aac704717c77c5e7548161840ebaa3b5f59cfb0384487e8dc9f3421e949caf5bcf7746afc2fc3c9d45ec333bea722a86f41ac750886ab1cd168ab39a27935de73eb1ab9251d7300bf559f0f5a33bf2422888bf4180b74ed1535dbb0cdff62223046ee8932e41485d81799172b37adadaf5b140a1261feab97a0dc6772a58ce652b5ac407be500db5a18f2886a691c29c8787852397c0fde8ebfac81fcee41238a960a3adbe9195b4cf5ef524cb4b4dad4dc2328c731ec25808b9feebd9a03a54b93bef548bd7970b6c7ee7101b3a6bb11ee355adaf0e658e7ba98b4db4428618f5dacccb760f521500d33957fbb7ce4b417f81c50297e079cecae8a21411f6935356d133108d804bc4218c701128959d434605436fe88845df48aea6173efc08490819d0d820004440368642f4e83037e1016a8e47b54513a713f6c134311896e47eecfaa54111d8b95fe93dddc711c1d78dd1dea6b462c91ee87245a9e052be7d97ccf768a8d25f26f3b6ed55efa855a792667212432ee1ab3e0c4bd5f445e9639c19fd3e856bd6854127649dca3f8026aa4f0ee4215843d96155cf3da80fe78646e9d071867154060a84137370ada5461c7d836003cf5c34d612a16d9158ab3933b5f326ada0ddce590dadad7a523eaedcf34f25cc00a41136190731e1214540023dcedaf82ccf9f9fee83d794b9686ffed307ad09b31829f83be16d658d0b85ad8726fc25a4bc9740ea378c9a03ca66197beb0386c51d90637c04138e0160bcf9dc15adcb19795f676fadc105acd426221af832251701bbb545fe5c03b48e962d216f5f7c2c1129dd7acf0b007ab849287c9fe6ad11f8cece3cf30cbfc44b7a08c16dbb9ce5a22324351dacde7e32743fd8b83d5f0224c7b55200ff368eece3f2eb77f6d41053c3166d48f631fc89e29a8b4619e88db4da716fb28331240c7ee9e048c31e0f889cda7864a4a86b1020056a96bf6f9f6477d308bf7260b7e94a295130dd54093297474eb0de80e5587ba3a8d7a37fc7baf6f13a041bddea9440703807ff767cbd1a7ec6c89bebaf6e134ca8d2c678d38a99412b9d70cb3e46a86cf237a691a6778f17808719883b585165f9a697ca22ac4db81bbc06b02050dc4b3ec9787834d360e1ce94a716ef4b7a6e5acaa2d09ef04a657155dcd4f622e92955f999aea07c80c61ba090bd5fd21859112279f5540d0c5536eee6ff22aa02df9eef13024d8979bd57020ee4870c97af93897d26e256a3bbcfdd70c2392e615efeae75a6229d4601dbf4c3101dfddd7e39ee934c64f49d71ef211661ece1768dc162af2d9bb70358de1e37007228926019fc339d6164b54c157572b4b13334c61cd75c9362732d6bcf08e12c1d815cdafbf1b546bf1924e5e1c30a62dbb4dd1636acce2681a218e9f8b2214db44a171be7e695b47b644ea9c42642ca5c38506d229f764a5aed87c93eaed0d2fe9de14355de9e07f2b9a86612e2a253fbdb39243a14fddb904b9960ed938f812ebca43f761d3de499b764ee3d5410d10e08d9c443841389b17446c498304831135bb80684a4f2851108c5ec819bebfb909f3f4b4da11bbcb4656f1bbede477d8dfe625d8f5bef7a084228b0b42efc4f0c2b65f8423ef31d7f7973427e03bfbab7d583ebbacebf2142b0491b6222f80a7dc4a53eac2edf185367ba4694b4e6a90bfc258defd87e447786b67c7ade7cea98eefb23330979781fafbf7045f1fe363e79f071dd45e39f1f2ba8b810ff42477558462b8d1c15d60cd197a9fa11d8ef09e5ac72bf1cc4a713c401eff4ff8abd6873067215528f2c02d4b3d70c8b3a2ddb8525cab1a89d8a52bc5b4e35f5cb3b6cd671da87e11aa1d358cebbeef57a7d5d621860da2ae60c28cd085371ce14ca88f002cf3ae3370bbbb5dc7b0dc1d81fd43bb192f6cf97d1465e24e48530aa066a4afc0a5b0a6454104554ea2ba81ccf783d1e402fcba18be3e679145525ed0dc09b110525b98b1f58369eed30d20ced4e05fdab89f4370dda65c423ba3926092c7c98f2797058d66403567017208a512dc2e87964eb803b171e3217b3572feaf36adfb33c42f9cf220e66ba6873c649e4226c1b4666ced955e215304539827182c2f2d34f8da82e85121593ca65ec1968d1f017f4e141e1f3005c4c382e6c7eb2299045941c515616b96f15fecfa69342c0fd4b5f8ab7f0d81293a5d0268c279cabc55ec24754f6c47a06684c70e47e11b0f9ee0ac49903a71f6dc00be8ecb3084e9a14212e4f80fd2fe6436ee98df4ef334de0ac6c734a8493a7acfdba29f7a787336b14981800ab1a13a6821fefc485832826856df9d10203be3cfe7dc506f7b3a9e1d36fb997869268c27371403e3f2527fa44cf7fcc445c7ab077ff6d0f3c86ac38a51e868a58a1be2e95d3c56b6e97e599a1ce5272081de35dc62e693ddb20d4085908fab981130ed5d4c3be50d7645ec2ab8f01cc011ee5cd83f754f5b6a92c8f13b771a6768c96356c1c0ab1dd83f53b4689785def66ebbda6cdca21dc95e1768d6aba0735b175c6dd4331e1ece894dfc29e70f69e9c57fc7c3a777b45f30e4042b49703e3c13a95ed8eb12a579bf0ec98ebff77aae60695cd8977e55ea41e35c75aa5d0d1a5b4e09f0af94fdeb48941fd924c13fe33b569752e946929135c8cc16622c5b9ecddd3cdf451ee4126b3e485d60564ccfa1574bd5aea35ad383bec9cb305527352b1497158f4f1eaf237ec51e788b347d21a547ac8b1b8a71ed2b20fffe06731f0e2e4c9075120b03d75f365a759e9b4c11377eea309912f06c802e23061c56016892b25f0a872dca23aa94b85128aea687395d7040e6da5d30b9dc623f6327f29568139c58ccb5e54256579a0e2eef41c8a70c9e2d01b44356f3c779d1c36bb27b944ec89b884290e3d7438fd56f3f6fd3d82994c0577eabe7c6064aea386848f0cde72fc91df3fff8e13a891cbe0917fe5b4608a32623aa14dde442f996edab550bbf319deb5beca5670d03ea182d7247627c0f4eb0d7f47c53bd189d3de3fd1ec6ab0671ec5b449f3c1650f7dc331cbe613d3a411893e8d2e05ecfca93a339452d046e95be2949d174ec0ec4bd2c72c7b2dc5f5191b789f78584746d601607b00f253e0746b86bd536b485348b018c83409c40df38f277111ea373935f2447fab0578c0aa0a02b94c4cce454d0026c5a9a5ec4eacf253377059c1aca9e58ae182a73e3f3c899acbc0fa7a6a08885fb05b945871b4489481fb42e5a4f50dc67362b5bc37912b09005d9485c02fa3f1bce6bb0dbe32903d301a6f6992893ac3d0061ce53f030962145db551df2664390aaeacfce81a524ed094ac142b120fe5e2321d55eebb5da4dba5b315210e2a9b1d34cbca6684ca9b776ce2194063f05c8807a3fe8f81c6ec6545f3058d3ee90ae0f1aa0d547fca9048aee8079e2a97fe598fc86a6d8854fcfbca3e9ed40b84499bb869c4dc7b2756ae310d4fa421ee41d44205c92972cda092cbd4e8fa80674b5136fe116001554f694de73500057efa95aefee6fcf2c7c6010c2c13e395cfc542baca08fff46bd5cd515fefc6f32195b7d045b829bfa643bc502776e339ef32a8b4d19a383dbd258daeebe8353b6323074e1a140e4fa8120b62755e9823b3cb3a3be154b0cfa404935cc33c7d0a70696f86c17af6cc0249472150833f4c52e2c610876d4f20e831235c8b66505617be71c801c9a77d37b05d6613e0b8f749025914a8ffe7b86beee5c12e95ce0a8076b3d11997db637d52638ce98b1c785c805c5aca6102c8c2479d4fb743f47eff38cffb927e409753e1811623e6a7ee54c93015f3557ee1d53bfe911abfad610391eceeabdfcd593bf163a6a654ea831e8e0451e7fce8a29c6c1b84c24d8b3283911df434a441dc0cef875d704c0e983598e707169f962e104f69ec94ec265a0cdaf17acf3e5da434d4afd3a32950cfcbef2063199d7e402858d0178ebaeafc56647324db81eefb22447ba217e7905fe71438add1a2ccbaebc4e86a163fbd9363852fbe3535703b195a9f640c2c8aa07288a1cea542798cb720783049529b2fa908e32b2ff62415fc406bcdd3d5c54c668b1e6f20ab6743102342df3b2be0c4b0f9460f80f2cc0d1b9a8e3e209646d5c989ce4ca2200c48c7f49786270c9b11540e441544db1aab904e62e4a937404f4bb52055b3027460484b7e415b1ba6275189f64dbdeb3512a92dd6617ec20857c9e712af1c6c4e64f9c0e8ab0fa38f5119e37d53aaed002c0f4e54010ff88f089b8c4140689299aaa3556c5751e7cd5c368134a9a86881acbe1736cdb0dc0a1130fcba8b3c7dac702c2fcb2c158cd6dde95cf827a09c61050aaa9a9069afe7a660ca5d14bfffb8b488fa8ec59dbea9619ca21b034a84dd9ef303cd6cdcea0f64e6210ad54565f29a54126145d0c73e8b744d3a86d6bd2dc9f230a99cc0fb0e51b07be5369550d2e60a148295e8ae9158cdb53ef4e702910011ec56b2eebe1753c53c2f5ad2de62f81949bb43d7fbf28c0c336e3a92234d80f91baf536cf10da84a33302ca70495533680ebdfbb41d1308133dd514249041e28a456dff0692e18a4b47021fe8a68cf1eafeafa56d952186ef3399924b7649216508be9156e9671f3d2b99313eedd1e665609769ac403682f5f02aa98473208073d806826c568dda42e96c6578c068c5738493f54d0491562d6f4b1a26f6ecc7ec646ef01ece877be5fd327b844ddf7b53f3eabb19ba83f7eefc8fef498711f0a9610f3148b9e8b092bfa08e25d777dd108e59376d109f94bcd68231f78af48a8787049942a3df68348a5f052d38019be690650461e0a13e094cfa79d6a471effea6be8b37cf79bcaaee7e25467e02be619625405050dd5dfe55924cc1d5a27073de04866f28e1175211f0bf1a7f451aa9da89fb2d1938bd64f58e87c0c41d7b9b093af767c8f467959df77392538b219ca79d77b66a58020daede8fbc2bce74f7cd17da15497ce53010fae3c7e2b66df60e1f0d6164e0684890f5b410715453d5d6a44056f643225559ffdab4678e27d74ccc1739abd62dec6d3e7f8d691d9042dc6aa4d2cd21462c2fccb3ba92e866908b96593289c0c8d2511eebaa6825b3010a8efe3e617e267846f5262afa050fbc0ad1382738579b5cea31ad4d055200de66e09d266c1aa49c40cb14e17129ab8ffdb4eee00c0d0f4e0f15438dea3f417711bf058b5b167b96739cd0506c5b57117aaf8ed3fbe14b8103d87ee1208a9df0318385e4b26c1e9fce814273aed43cee98cf817e9db1af75eccb0edddb88512438a5241c77a5fa5747eb16c587be1f85f726b7ea5ef209dda1664c07b9708e7fd056224d92c1b12b78b1434833ca253e3eab41eda562605b1b78cff0ffb811102ff2ae9a82cef46e70624a9eb3d095ad42e1ea999d05ad88754143e82e2e71019a01ea6a15aac4d5b84cb7da27294d2d18907c25aa6a215fe2e2f75f00d25f1bb109564136fc3c92678f87241864c75ec061a6937d60d838b1c43cb339a4419e0aaae8baea41a50af0aa07dbefdf0d4f65a9c8697f30e45d18218f9ae6f70f27589cd59011bf6bd237431e26b9f9cfde4920d2cf5e756473723ebc7cc698c44196c8c731a2b46cfe0c89a0366943f1ab15dc1c4a6cc23769f833aea060427b47db5e523cc947bbfb44ec31fb55bcb518e54df3677ac779a8a20817311bccd731ac86a7aa3d1c04878b5e5a597adb3410e106b3ca8f0a0d7e5f6ca132afc1cac19a3ba9ba98b69649094cd9f263a28f531bda795a4c3640fd3cc295d15dbee3f564ae5fa9e18d853f28182ec03c888fee46535a2cce388ae7df77a10f20ebd902b87cb250f014f383a0201e3256a951efaa2f2da5f279a3bbe320f38b29e092d3a0e163172e0d7d20820a9cb45ea536651171f55aa3530b9b8e73745d5f2e7edf41c8efa591768a3f6921fa31dac36cb85ea5431700e36a3b7e09389dd1fa7989916776f13ddac63817e0ef00c62675473f8e057f4e17ae0ee01d636a0e558ec23cdfb103531167c164c4f136de67f3990aab0e2ff0444af4f7379e670e3e90bb67418ddf1db37430264a95de630a6cf04fa031bcad8da775dd58c88d895a2eb61015cb86735b27ba27dae5a9126514082b6183ea5d9ab1bdf78c3681c2f87dd3e0c0ba3f8508b7d959e9815723362549741296d919caf763f606ea2262c956f59f390043a6f40bb86c907abf2515de6d10c5c912714a69b44b76b637b5b22e4b506a5c8972e6b31bfc3edc3c8f8f84ec5c00e7c5007c0f0957fefc4563e7e842a6c67c48055f94cb865a141e5c43c64bb6b6470abf7cb11beb9d0a3ac64e9a752c88a047e9e6637ac870b9738c38d748bf6ec9a1ad255cc08df00c24fdbf1bebf20e3619c766c3e2da81a217f72feaa0c04d50ded8d20f1aced4f6a97d6d836e3140da5ce0b4647c30d0105392bebaf38d20755830d0369fd7a116969b6887cb136a7e725a50932e42a4064cbf916bf606e6e056f72e885176ee68d282f88fdfcfefcf36beca93b3bbfe2b608335e21a86c5fe174efd7d520e53b4336c6c761e18bb58601a89f60952b54cd8bdf13b2d0ea2d3629d9f3f19f9c493506025a106160c2e899ee6030fda9f316ae68df7d13e4ae10eea8d71770a4d3e392fd370ca87290f59b77f64f2be85ddd7e5dd5d2fc9283573e86bd441aa218c59a701e5b41f326c18b1f700af99ec6208f2f18c95a149e0682388aae249e5deaeb0576da9634a0658976d571cbc4c0fdf074950c26b88c4367d517f43c1298f037c415355d9711f06dc329890f3cb64cf947e0c361bd6e6a5547293cc78dc9c89a8931bd38073d275d7ac1952a51865924339daceeae552769d4986927805dc4881b80ae4447bbbca939d1e6f12b65e96cdbc64818007eb938100e2452eaadbc5745a7dadf38873df1ade40686dd1794dcf039334ee422fff6ae81792f78670a705dd89287cc93858ee8fd7729b3d3de6e922df1ce91888e02e73eea4eaa77fb4453af78263d59533b1fa782cf87c17e6ee2de1090466f6fc62a379874ad654d5badcb41e0e721db48eba075531540a7d0f838213542e954e0cb08f0bcc8feeac9dce9428d9a5e91e297b783cb48cfab6f91cb721196f9601ed22d199842a6270ec8eb84c485ed00dcc9884ece093b171fe483e94f30b9dfd890f90c2fb0eafbb5da8e1cd5432abfe6bda85eb7d0abcb5b9b73db8cd894858bd51ec43abd918f03c8a90f5a2014ce17bbcd3858140e60cf8bd7ee75e0d24383e7d68bf3890bab204102dece4fa3010573166ae0d59b2a4c6f2769a86f50b6ec40994d2ee99a3ec10abe6ed07a0c07dc6a41da0d9715786f699a8946718768daf3bd817a4030fcda952d3ff537220728a7c7feb246d97b8b51b23478c882636a45d3a5e097be55793876cc9a7c16fd3c9aaff48ee5a276a41e971950bd9c468ddd8db3a5e5c36c049ad91a3b4bb88cf97a15e50f7ec1338f46adcdceed22c4c7198ecef2d4da48925809af53fa855641d9a12b8f4660bf63251a8f0b739902fe83cd56076a91b2438a3a4909ba1ae95289e750cbd44481689a071d99ab7a8756dc319b77c1f0fceebdc78c223022f5b9ddfc7182fab4ac56ba43e9eb932a40f529f93b58ed31b0479a63cbebbcf61839ad559593c7dee1beec42c3084f68dee2d6fc896520aaa8617b8dd698e958c3805f497032aaae0d3c736edbdd929a05b73fdb6aff22e2a2e7f8846fcd3204c537d3ec59060bd87292abd5cf4475399567f14159a4f1a2c4db5fa7fe09b16124f19ce7da1d04fef837776a3e72bb68604015cd82eb3fcb4efc9fdd0a35ff9d99cd756b994bc3c86fbb642dc5510268e78c2bc21c2fd2a488e3ec32ef770616d96e6cab580f73fedacff7e7d95eda38672b7b5991392bd14468012fe4adb5a7d5d5fe40239b4f4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
