<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"415d6f02530fa86f324df733a69c56e44904eb990f62a99451fb04df2dc0833dac31fe7038c2f26442d9851e785b51d3d593043d59d096cd198145101aba4494237a816712e75fa6f652cbe30bb5d34e8f75db8d5a38480e46ede756b0d0d48de0d69e1c7d0f028afe70e77cb9a432f9a51dd6be97ad6b260234f7cfa6ebaec0d55596565b6949e646222ac849af26a20266f9940e0f91eecfe1df848b2b447b2d51d57af1b63c99ee5852bc678c5f172e1fd0a233e192f2b1e7db09f16990b5e80697cd9158e32256bf96fe197046c4e040e5adb6be3bd83413a0484f40a1e137069033a5227b37eab42b99787000cc22b70c70fa805916c5ca378a6ca89f29f436d0fe6078db29dbbd5bd7a9cc5861ee6aae41a85469edf4eb028db098419fe060eabd367ff2b39a0e197bd336d4db894a98b1b9a5db862cdc887581a3d5013bf0c31d7332c109d8e335fc7af0a2747e8e72310733ed721961a0d1b8277c97cec95baa01a6b513805f507e9978297d0a3b3b08ae42c24979cf813eb62d6e724a23c986135f75c40fc50b0edb35bdfcba0a354a18e12b9aea9036f257178daba3ff2adb44ed5bad90f7ad7eb698fbfc948a25c0c30ac41f8bc845e3f4e46c3899d12a012a0752d7785f8a2a7d0026e2d5954ad4ad458af93d1c14d954225439ec6945b936f06be73912591021397d5ff12388b8aec165cbb5bbd4d3254f3a72e5cd38758801a31caf819d1f1d216de23d1ec889446b6c98a48ca98fe247f4993b0e773fb3b2c25a7122d2ab034d14eee7b5a60dbb35a64ebb7347befdb726afb4ff1c08b40223e92982ccc1133868a1ccde4bbdbea0d584075904b614ab7bfc97998e83a3f111de68d511411d9b3815b694d3f80a212fc162ac323c21dd8f5fb6b7b243a183cc369cddce29bad4b3ea90e7bed82477897ab4ef77df6d72ea45c0eaa36aea079ac37226ccafd4568b19b9ad1e7cb87a39396213de1ff15ab90ed703e19f33cc1da04dd813a707d9c039f104bec3e325f85f3f25692d7197f1286fcde6065aca49f97325180af8200ca10e7e12138f9c39941a8c6c085f5e0dbe0f0d01b1602f34c7ae807058b63fcf97388cbe55087dbf06cc658912691ce7b5773f5d520d7bfc71fbd65ff188d3043b31b1ca5067e5aad3016b34bde374dfa6923c0273e26457c534a3f5d8725d318c29a72ba65d27410b41ba84edaff5423a2062aa830414e8bca73f937f7ff6443af69b46cb31abe826cc48b1435983651aff6955f14d6fd95eb54b99d89e97e5ef3872111af0609130b5e4972bc738a4bf1bc7a1c2b1e3b4e65e22728d09ceec08657d6677aa363ea05d0490b759225425d66c769d7f1f475c54c790cbf143ed86454a722de11c2835c08b049229964976e0aee9e36e8d8c8047e010b9bf2abd196e0a86bd45018e92fa466a29d34ca71d82e1b0064bc7e32e148fdd77d77debccb08a66ed2939cba965d62add3d863554057594d8bffd4a893f32ff4ffae128e6725492ce333bc846b8db2f78e0e8ff96ca13c0cad1a98c5bdb33c80d236d7289168632e7e0c6cd5cc03c79825e68952c735e86c7f16ae03074e6daeced969309a1609cf141b44e9e467f980e6a783db71fb0a8465288ba0f626f96f6e02961f3996ca50133cb67c9208742c61b71e66523e4a1ebec47cdfbb88edc134c6809983ce5b3d8f1b04a128d357c2dbea4b007a48517a7b93d1f6fbebec954b13b8b81d0a08d04f04cd762b57e51697d1117c2a73cc7f12560ca7d9744a4c5c83f4d2347f8d896da402f1d05438a08e45ca6f69dbf5ed43d065003b0d7faf629f019b34268cd7465ec217acec85d5026e7f15f33c27122161aa7a9ed026633d37a5c15e3c536927f608936f4567365a4df37be61e6ffe17165525e9a7ff35ab59aa72f58d19a152351fe763787f0aa51f85ad3c01b7c49eb8cc5612c3d589e28298727dda86f43bc9999253c76a5eeb6dc2eba59ff7d78f6a76f7545c2c9928b87dacc6273a5c650e5f50562ff184fb6fcb08bcb59b749d3135f389b2a1fe3be3269bc2f63489e80ec9067d31bdbac2338b1af8c7a5fbf40eeab8d61014719e194f95ccbe942f7dc643d8dd46759332e3aa2a3ffcec411b13f665a0bbc64fd2fa58c0e048b49a75f91d188eb721d6a2c812cbacfdd82ccaef6a63ec9bf18f861e11e10a4e02c4c1352b6081b7fdae7effcdf9a5f8f97e4c42a8b3b4a1c2ae3ce7a7ea7b81b51e54c86cafca0694326444ffce4b8d1a77ad4ccc5ee0e5491631fc918111280de26eda71ef047706f2e89a24673bb3742850d89c777fadf5b7559a3d8cc7826506dcab964feccc5c9d5958c65c2b49206ef59d51483c0813fde049882c245fa828e2ac151beda0465d109ecf3c4f37c1cd5c6fb0b512fc2f265a65a24e16ca4df55356fe53a53c82ad1471df2abfac09358298b5a2f73ce5da90491ee679151c8c0c08678aad0ac26719b21dc4f99539f846f474afc17e591b75ea6a47452459f40faf7dbc404ec4c477280afdd083301a1bf8ed520b443ef9ceff60ba3f1ede8ede933f01c09ce57eeba0ed06eeba3a4680fe194c91bbcc7b8d6de1ba4dc5cf5970e9728517e632868901c82837af9582717b056b8424815bafd2e2130c6adf4073115bd6f5d5dffa19a59f1e64e31ba28d45bc198158fb87f40e343d3415aa3a8ab4e5104dab25630c4301bd3a0da6b1ad7cfe2881a4145d4adc0b446a258076e4a98d6c586433219111159baa5d90436dc3bf6ade41adbd316e8c23f39c707a8a9d464a43e5721b21ac0477a011f5a912eaee71e11072602d602305292c91899d95c7cf04fc3cf7c497a16cf099835eb1fd51e252cd8ce7e20c14baed63c768ccedadd72c200b2595245f94d076f903414d58d7359391669337ef9df92fcbadd94677352fa5f250c2a680ea7bb815f33ee973cd0b855eb00bc42cbc801ee87946655307cffdeaad2be561c1c99c4613517998adf2918951b57b6e2530c37068c29219d354b503b2ab818b0294b8a4cdd31c703bd7007a30e254dad3497a1a67d81d5449b89bf13c499a7ba7ba361e60d1ea36ee22f92314cc5d981508e6c9816455a872390b62d5fa759dde7f5dc50333d4521c4c055a70c765822d78d128d184f279b91066a211e05f3fcb0f442d63c54ce67fb553e5962e338c1e37784aee1170aeed35c788c91aa640c8ba2006d5d7c5564ccc74b7423cf6763c3461615a7af99ab264cc984b797ac79a5ff9c2b509711ff77eee47b14a5317733b30cafc11ee428db2b7d649aadf34a2be3b7d58e8b2f57e783514e9424f45d323a6504c4af0b11bb419ab380ab8b59557ce1d390d88ac332d26ae297769da7201d335dbe25a74da9c7b52d2840ca8db90953ac0b5af3f8c3ea9e14abdc95d4dd68eeb5abdfddadfc8ae5911f9c4dfc46e0a1edd56239f82ab96b0701af8526a3b61d25e67a77026e4ca14ee0c05b6a18bf3ff73aa42d9caf862688adf07573c4225e67e4a988c1dd9ead7c3239ffa2c6e96c1ba9616ca6224af0bf2f4211f257314e75da0100627e34204509546a60c494189634d97226584074a0765db250fb7058535c6be27d06b65521fc460a3b1046d02d1bc905526fe367419db3af363d97b4729f4454bb80e8f37002b755626fd83a8d72c03a4e5fbf86a54f361e2bd2f23eb20c46a9276074d6da86f20e0e545f49db05f26d74c65cab0e5a277f64098209a011067a859120dab456e93cfe38a077f76ab1c232dab7b6d0a20379d3651d6d729f1882d6c963a8635ff777feae6908d7b52ea5afacf65c0993e2742810b5de936b7ed8537be6805f5372421f18b76adc2cc343540f600a0d56edd970de5f4d37cbed3a149ea4047a2f452cff797612304a4b0f292433ccc28a2c5f6cc1017d25fae9a857d03d3f8e4b639d30e16792392aaef565ff4b447e12af7a8bc927c9d6c8150644240d4e8704997eeff2d353f66f3e893fdb5b75efdfed4c0df1df50c54b911645ddf15cc2b0dc07be1daa2498963f92c11c39c3582696be3ad0adf5b5491cc18dbdf6f79b9d8c49ed042dd1f864be6ac0c9b1c9c18d74cd8428308391e34ca5dd668df668417b24add617970f18327715250569606aa0a8b0fd1f2b165ae9c21d852c1a97cacc14dfea012b790c276262a849b8a2fa3c3d180c8a3bbe8ce92b7cbae533de1375cb5b5e3252166b47b589192099eed5399ab8975eaf4d892f50d44c48332d6c4422acbe03ee850d31997bf72c5f5e10b44a29bc8f702b987a5ff65d4d77a01a57a0ee8a7ad3857af87bfc2ef1651da7ec5adcf844c480faf004a4eacbc1755ed63603d428888da059adeb2cae619a19e6a779302866c6f73464adce1d6e19062b0ed988d23333f90160b99b49aa1bb0d9327d37c93435a8aa646cc0e12a13f9e8799fc82430904859f0c31bed8dfa306a13eeee4c9d1c9d8bf331b84f0e984b8e6d0d601694f2ed210497ea3f95f1119c58c46925dd9d66e540ff8e75305e97ed4f8e37dfab1ab75e5772b207b213c758f8161c2786179e012f8bdee503f990ce5dc4af7d51004c365fc658e376da3c9c5f97bc794526ac5c873e73d547d1937fcf35ddbefe42e3f9e97e41633b008a8cec750d2f40142c91eda9a1266b4513f61c696e5d174ae3a3d032cb4fb653c2449cddb11d8a668ab628be55bb8f1345c6eab116180075785e07f4f358a08143e6d4d9c7561ff05e8515bc6a5fafb90119386b0d215635991c8f6bfd50cd4c23dd08acfb3cc78663cfd0deaa240b522847641ce83b27b897d93513baf163230849050b7c230d200b56749bd2d3fd6307cd0527e518da90b2803399839c53237b85c67fce545f3a8c060d980a34f3945785e1617bc88e1694970394d465229c8c5aedfc5c2a8f16fac6d4b535940c5811196726ca35501f31225ce40129b261b115b905961a0cd683ef59abb67f41d97d8b2a9ea42de36425cadb6daa258b0726ec0407b4e0389f7aa0aa6c4414c85ed65efdb0c0c80cdf5a48ce265f56643202deb5b8dd7aea33d718c4a5749444d7f346e410466c5cdc2a3da539d450c535ad51078c0900e4b5865b211710381a69a943cab8f7cd9135675e45c517d1d740693c912f6dcff4be6b23d0a76f92a55da6dc4b493b433a574073f1349312fc9ac0103a435854208793318e5ff6591feddafa8a19ef7fd166f1a617e05a5f7db39286192bb1455dcd01e534c5041cf5367a89f47ccce77531b8717f44ad1aa40cb180b9bc41ce41fdbe0e1dfcd51b6fde4351e4ed3aa02c2a97f9920cacdad82b0aa187fc4f8869443adf3260246ae7d7b57b2d41f27bf77154b89f90053d497139506f8ce310b31f7d3cd33f8e9e6d64545b63e2ceddc3178bead23dfe6b7bc3afe53a3e550abf1acbab4d055a922552b196e1031f0130974ba77d1f0cde2e9ee7f3e4dfe60b0f6bce33c87849173d19c575da9376a81714649172936235b4fbcaaa2cd7acbf888c8708a1a689820c373cc9eb26d641680d5ae2a978e5f598a722b404506e65ae01e901e43d9f00bd57aadb572d777bb57c428934f542eaefd19efeb77b7b1f9cacf194b2d9d97789a1088f157fcda6689dcf0cc8f802161123057d665c6af165d57247863c711276d5b907d359fb11dcf6ace940eb3d05a601c9691deda536639a8a6dd1edddeab0b662de3dea0c17d8c79e7d21aeccae0ef537513a5616db757a551861c1446955246e55f6f3c675832375a0985cec99a166aa8dc7358ae2749d9b8ab40f1d31ac3061da2d0f716c2c44e8df82a78c36c34482b20176eb62d777af3d40179c056e3f131e4ee732b6d042abe8171bd5210218babe94c71c20bf245ab4b36003ca3c1541e739eda6ab79e7d8926513c4fd8b71aa932133179e388c099b589491fcb15debfb380900d6d1cb78e1e461c5c14d89dcec7aeeaef47fc87688831f383446ea4e50d18cad685b14225d1f974de32c1701ec5aa0845b068774e8ad0b1e23c5b2cac1c873c032638dff176d5f2d87bce57ad1dae0908561a20ba2d4b98de26eebef70b5947d09ddfbfb79c743996fc576f6642d0b9b2ea8250158683c90d401b94a448591faed44b41e51159f744642505e5e0e1f088cd379d09b0a68e40c5cb646eb963d93946a1a614499ecf7ad3bc6a90dd036c12f628bfba2601172b7ee20dc94edcf1062252b0ac397bee574acd6409ff22a5d2259cdfdf7c212096c83ed2fff4a6958c37590ef09b3cce28cc92612d6f8a72c947c62969adc1b0e8410829d3b1a77bb4ab9fa75542ea59d08efff6fc7f1ee90b5f2206a1a2aa97e8ead4d538da39bd973e0509104b5cdd2de619cabe6c7056d6b73595491cd11c1893d20c0912441e6c2ecdf96209e17b218e5df6714fa67f2da027e7af1fad302ceaa5f0e3ac74a4ea11c5f971e02a2eca62cee0713391bb86b67459b90bb77a086b77e5c42f2a68bcb2f1bbdff8edd8e78ca41ad69555646282c5da747f30b9b9e2a6a021b8d2d586deda1906565d16e3e5845452c1ec03b0e461700e86b0fdbf3d45cb0d99071b5f9bfce3ee9a3caf6294c15d78b7fcdc5ac058b8aa8821343293eb3df305b52c0b5fc8d9549dc1a7a94d774800aa605b35e906082a6a9f868f42ee19f5b10c4b8858670bbc8b87ad6d4495e703ad44960d38535937b9c194f9341053632248de4cb9561bb40335ccb5245f6c0c063f1ea13715bfbdc9162408f05c1ed779e42af1ec07e8b4f1d1a3b187b3a39bc46816faa6f7264367b1cdfc44c7b5dccd8ad5ee777ddd3707f061e23b98bfc0e248ad9428eb23c3abf9bc0625b82de9f61a23a20b6e182ed02456877774ec3b1f8d3e964f8d1ee863dec4ce7b057ded12d6c6681c1fa03fcadeabc36b5e0ccfb827bb6443843a65e1196735ced14e90168162b492e85a5708344cee5579c31dca6568a5d20aac2bb8acfa87001c3655bc0aaa3f1a511aef338c442db900f0c6c6c2a498046d02c9f295fab593db0d37443f41de3f9d2377754882c2fff15108362ae8c76f9bc368f6d3c939e64c10da02991ef6940e4bfcb09486ed21236d052abe8b110e2dac07fb6f0345254dd1c7dcda39c4f1bfc777a8b308b5892c4196d4b78da0d55d694384c3df439c7ac00a1ba153877a564227354538eaba2a9ee4d4c53b6937ecf1cb67cce00659299c5b58cbc6211469651f7328f9dc80e9a8b8cdabe65998671a44ed757fc04923d528fbb86f2b2bab82dfaf97a2425afe1dcdb0af6244aaa064af83fd2e728d20651a78d6fd93abc36130a788f9d2a042071f93bd0cb619edf129a1fed13b60dcccb1c19d8a2eda06bce38a0a5cd92bd397b07763585d8b5bc106d6328a5f8426e3f40df0c615a93c1087637d8a089f47392259e34b7c83b354ca45b9a200475ebc9746a4818c63d0f03ac553a3f41324997db1de7442f78409ea1ea481bfa81721c3314c661acf0947a0ef4a245fea475b894f28cfe00b8171d17481062d6fafbe53e8d06547fb560df6c3131ba5d304e2fd7c39eb6aaedfb10efa5d9178043e0aabe1b71f76e0a519dad96eaa12a229c6db17182c01ef8f9b6549d023c6489312a034eb3422584d0c90717ee0a995d345f40c800135bb801d94844b10045b46e7e2aa72eb7a4b0a4518278667ce2ff8abc62b4b3f4592008ba3801fc384a204aef013ff13883c31e573e3ce4f8d54c966c49afa729a60f45ad86293dbd3403c1f115f39be1234049b37f3a0af312bd30d63d06cf93a4a172ae2be6c981d8e727a3c5b39085f6253c7192c7105f95237eeb59442aba33a819fb88fd752ee23d993da4837647dcc758898f60f7201eb2a4356e5598cbf41cfda2ab938696af3d1cb1f8b66920d511d9e39c995386de5dd6f57d23ee1ae7f52d9952319669c3929c70fca7a19076add041a1d3c74e018be89ee68ad4a4d4712ccb43b7eb754db0ca3ee64fdf569c11ed719f8226341014f65b28074610c7bcc51b03bf0aa2120b88541ae76d5b5594370596fac0778d55653e7e95fceb95e2573d7427a556a8ee7613645903502c95c54c6e1160c042d1a6f493accd9a8a1469a05c9440d15366de6f25310fa48d729c787ed301738735b49bea70af724114a614bd7341de2dd15fa2e9aa42666898591fb84cbb6f363a6b3c5aac86dbf7bc81b7532bbc7077861cf5d45aca843f92b2c3d8d4d37eda1d77d54e0609b982a583de7dc4a3df84060151c6a4a897379b188ce831806f71208e0a2737c7192155040323a6fe2371cd662f0164d006017056c96acf9cbaa95f484c7b98b830d93bb41396442f02eb67b8ce642f8050f3d04c486d40433832fa5590ba1381e6aa4ee6fefeec520808746f3e1e3ee202f4986be151b85dabd354e2fab7f2972a95f88cc10e6e948177f469df1bef0dad37039587dd1ec2638e956ad2fa9e2811bea4d60bf76b8d569c0f73b65ac418e6b987ca675a36d8475e704067e89826befbbe29dfe7102494ba57115426534cfa68b4542a98fbee3c0155a79f2f433273b946ee197aa5254a9c8ec6f3461e7ed7b9164c3488623db3500ea629f23b19c26fadbe21af37d1d67285f48213bb53f7ba26fecb1b875b76789c1bdf65b28937c71fb0cc9dca32cfb0108ce98d65b9eb4c3077794910b1548106ac4adfdebbfb12e1ef42074e6be81183a7f5a835715066d59332213548b5a9113e6da69e761f1c1955273bf46b44d1c0f097d34e9057a232ae2f3949532167f6fa86c24934e58e81b431f13ef7e589acb75fcc7e11915f069d6b3385e5235e7a28fb34e7b443745b1199175d190a8c9b629e24ce34da5df9c127dea80d5f6ea801f0b3edcfa2cf6f135acec6e9ca9cc6ef1b3568c22c9715237200783efa6392e1a19b240a9dc8f2065deae65b518d77f891f52f7a44de8bd44555e6bcb9a5c647773ce7625e2151e3d2313e4d40200114f77676e62ba93960c3274083c24bbe7fdeed5e90ef08ada254290ec87fc336867c423ce5acd1e62ab06731f0c3a5c6e5ab1049dbcf680ed1b0022409a30fe705ee7ae7781c27fa3478309864594465107916acd1cc32dae4319325d08fd4f536bc8c89f193431d21aacd366d3b861fa096e31b14a08e0eb289c4f5639b8f45ba9e53ecfcda676484177f5f604f48a82ea1659cfdfc7b51009bf649017f9d2e614e7b6afe58b901c029829eced4c932b28f27ee772c05e7d14516624a885f6ee9d870f195814702bef6571772bec7382519bd5aa606033fbb9da7ff617419ef377c4bb2b56e22b4abb2b665074655aaec262a2d0fbfcc1e9646cb54fae8eaa3e1c529902ee770eb2458afe64e7ce7e0a361a377d35fdadc4b4d1b6436b672d70977c839564914db71ec3a5ac5c831ddfed19b36ba84e9af304950bc1dda7f11d425c1fb58b436e1a251cbda0759f64599433f9817d17179c1d47db59dcdb2d0f2437dee56d9d750a6f9df1f94a68a936fdab394991c77c20fb96428b3f532b2228630555744943717840787cb78e0019ceee2499c7b0038ff5abc3f6679802e5b3624ba649a943b14f2de873198823aa0d3deaad2ea62b5b55c7611064b3083a3c9f94f3edd335caca5900fc2b5f97c4d33e66eb23e8abebfa7f37650b4997e61370b9def45b22e48fc53bfb6ebfd271c510fb2fdd93f1ff065a546657417446e13cb889647f438f2a06d049433d3c41f0b5b5d639ac5200620d5aa4beb9a08c875b02940f6382d2a6e1a610ac0688abe3009aa46c60b491a3ecf9558a6c0a83f5e08ffad39f96041066193bf2a00042a9b257c20eedf24eedcb4db5d90e25c94712486ee3015eb0d01e99a3d4f691b152fee117cd5315e6d8375ac876f3713e213c22e64b59588e36bf468499a63b1136d09d40179efd23e1c48a684cc4356259eb1dd492d5ca0ab99948b820209e1c75c099f712fd040c6ce2c315e12d05f515d8af59cb6b62ce4e4efd5cfb84c7e619970f10a55a51391ed1c793476d61c5cb3b1eb26a20169b7bef6c5cc98c51ee78a2bbbc7c2b24110ca838baa52175a6c8ae0f4246797e65f45430ad77df84608c9b305ef99ba621f309712e57ae36c47d6abeb37db5c0a2efa79f81a02d23f459c04fef229847a0f7e68ab9625fcf20cddd5c37e5d8a2721695843eeb82a70bb37f4cdbc9df86075d4acdce62ac3479d2583517fa946283683f7b0fa334bcc8d8c58118c834271aa984ab5bc9649f8958c10eb555faf044aa3777217db6e4b5553ac4c23fd8b44c99d355be85504eba5769e55830bdab417e73497a9e6762e619f5f78542f6cf9874d1ee5e9a153c7302be3e23640c69e741fab78d4aff1f6f09f2e8c3fac13a9a8d9fe0d7f4cefd6ec6ab642142764cf96e0b60fb35fc5554160248e6f05bdca125ba0e34d2019442b8f290fd340b242df61d7e5fad7f9eca894d6e7c934f9b88bb78d97338e8afb072ba2d293018ed88feba1fa0e05eabafe371fd9fff0bc373177e2fb34ed7ac1436b690b8c5f7d37a64951df49edac7b9471c4ea4e5ab085183c4e294eb47f3ec174bd3b1295e0213b5bfb04e1cedf5b7b0a11fd4df125eeb146e355f066fa8e95df6944f00ba966ea6387b521563fee3318d882b5e4c8dfeec168e9e2b39248382cf97a9f8c6d24fe5dbc1ed9bb6b664d139b2c95786b1e61c3e7cc1732495bea6d637571d8a1d6338786ee07e5049d141df45c130113d5a902ff71acce1ec63def3ed891f6d3ca460c64d6e917b18a296bfa478b6f7e4940e06011e4542d7f67c266370315f950c648218b2aed358ce264e6c0bb4e9cffb515237bb9ea820475e1966439d4e0711cd6a31c99545462b923ec1591e31561bdfac87f22085e60e63005c4617034d63d78417414a403468a620103badf913603756fe61dbe1821f6431fde04a1335b70c3ea1c165e95a6c01b140ab05bffff3fe604983dd68b9e61c1ba3a34d3c07797cbc699194a3a6c0a1a0a8abfd9023880625aba0bc0c30bddf568e05ab4474fd74e21c0efe3aecc0b1941564fdbe5f6a7a1c6b6f88f363bda5bd41b47daeb7bf0a0d343bb43d368f1615212da3f5d9a572ac6490c313a40ac0d5e4830d44edb5a1b9270a3ca0f4cab3bb0fd13a49eb9741328649c6e891fb8b5ed640ebcafc650ac84a65349dd1014f8bb3d421a3265ed010a20936f40495d58e16b1a662d0f6f5b528b363c6ae0598d8bf0c79c59db81fbb5cfa5c408ac9089c801d1dfc083ab03b357e2b77d67e22a43a87700be6a22b441d885de2d780bb284d380f7fee19fa49b18f43968696f69f57e79be4ae755a030bb8a46fd2696e60b91222679e736585bde4a0a59ad1baa6cb1867bb23ba88485aa8a2175aaf568dc4d7b06e1a4f888b7201b05b33c2e4bbadf6e3ce2e658607da15a4142224f68f28d8b188b9a185277288d0f185506548a8ad034b42bac5d1e2596d889b08c3a2897b0c6441f8e581a9f5673cbb5cbbd03e836c7e5b7433d7b6af6641af78337eb6cbddc9bdda0f5975b499ed2b0f8471323694e1a7ed782704d36f57c0706815a4bf06abdc83d7683a5047e7f1cbb33ec13f6b0e053974e816b6f9188a1db10fb9be63da16c728208036418a2b0c477a991fad0d3e0c680600ac83963f114a05c0a8200ba0e70a95e824ebba80786e596b0b65183148e5cf37d9b4ace0f0106eddf7729d4a45b6ce75cf0b3c2b2fb8dbcf12558dfd86cbdd874c5e95aaa75cf75b6ad330bb51b5f86cdfccb36fcdf98a8714d8aefefa95d81f3a5dc5af2e0711497637c344420d5d473acae15efb7e94ab0c5a1a0fe8e374b21c2c7766b884e81ada6a79eb922e901005d94e15e87711edb466bb220c1c1aae44b5045400dbc6974c0da7498663a2fc170be5ecdd69f5661c55a5d6eebf88ce9c2a7a55294aa93fc5158277c3150be707e967e4628eafe8b62b96aafb4bbaf93c263d6ef01f0116fdb96257d07f5348b53f529cbf7fc1f71068bd757a994a12ee5a8d05de681da9d185abae2e453981409c74da1ad8f6c8265dfa4882dad59db86a0fa443b1f301998a7fdfc73bc3955812b2e8eb27d5e66444ab4b8397768c74c8f07287828deaf5f2bb92bda5dbfa5645e31d462d5e6830176da16db93f7e418455fcf755a94314b8a31c90f13368aca79636640c3bb213f54167d0b07de68f923ed31e8eaa323ad74273378d4a40c936f8c830850925febae083fb5651de7f9598092ed7166dca5570578fb9d093830da9bb6a09bc7a9b1d1bf9f8cb16c8313fafebd66f462b921bdfdc7275bdeb9e44fbc0d3c1101e49be42c1c53dbea99f54b6d1ccc1e73a22a531ac8b13e0a82b74233d9ac006e4a22727292266be7386a768430a27560024d7aaf2d244c689b9c56f2459e153b3153b59ee0d1846108bab310c9c1d38c59df8ede6c03dbd05be07c1f2cb0bafbaf67e0d4350ec7e6ac65b900f90b917f83c0c04eed7acc237d6cfab6c1df5a53c3887cb59d93cb7358157f5021968d22c3ff0f9cade6bd682df9634460bf9198bda83278a00cd4d88cf218a3a0bcbe49fae8e0925084aaf28a59293d2e030877d8674e5425354061cc9a1482892f459917e5a5f6e7e28bd6bd55c82984e594615b8a910f51c449af0acab6145a87b6273fa708b29186c38ec7ac432f433812b5e259ce6c2ec340d77697a4e02a5f5167c63d1a5913068d296d5e793700ee517c5aa0ec34f315189889ab91e5ba872a1c015fbbd546d6075534e5b2a763742a47d52e9e08c927641fcc7c9fc25b4cc9691f9f587b1b1b9d21ba6c897b7f151861655e76970fa7a13b38384c37ce58426d0e5040c3dad693120cb1b6e5f602b5bf65cdb62245e5011ff8ab4f35fe79c75ab544d0d154e1d3315409ee6af0b307e1afcb466c475e8392dd6ee252022cd9dd331a4193de5999b089762dde56e44258e3dca164630feaea6e29dedbcd8e1f3f46abd8fd2421848afd9fe1898793f28da419ff16f99e5f377d39899a648f8cad2ddc8290af5ef56005165527ef33877a13901f89527bf8c5f3894aa6c1e825d6ad753eac1a9ca44103746a7f00abc6b7a45d8fc31d6b2ac923ce4fecdd162237983eac1f7fb50a7f7b6eb0f70417a2cab78544041f12ae0aaebf13c9cbdb86de65b15d297d742fa3e438f003c339acbcbd9b213c6341e7574c112b1da61ecd229a5986e46afe3f14a83bf61344a89367821642a88bdd92791fcf3552eb4635f7f66aa896df02dd02db4f7d7ac72982e93c8d2d4678294c3936d57e505a253a003ed507af55b3da867d2dd4056e1cf8652b5dc9266a9f7efd94406c78d40b1db155868022056c5324de20c55f362d0c4e79104208d644e824b4c8c143ec82cfc53e306fbb012e62e3765de7f683f3988bb2433c788eb7f008c59bba91e916f4ea153406b5c3db3ff01710393b4e0ff5f64be2cdaf5e098678e15ed5895a27d34edff2183f9cfc84e73f53d88fca4020237be906cf55eb3a545c97cb9f1f2eceb63772bc0e11442ed01650d3018156e82c231aaa9e08dca73b7fb107579a61442749137275667abb6c1354aab8d086ee2663afb0441683f722f799fba1b9b5893c826570d8ab584a9138e9b2c8d29a9be4d5b987bb4c59674729151dae284cb20dcd185c7ce61986f24b8a430615db92f45e466bf362463ea0d83b5864ddada3eb3030e1ebac55ea3cdeeadd1c0d766bf2c82a2e2d0414039cce6c54979c18fb1b90c86fc8cb5fc6ca49342f181eb10f73e8665bf32b8810fd1c2a71675890d55aade5d4a9ebe8dec3439c2318b11c4a1e88010ee4c6cc93e094711405d371f656b356523b660e648f398afac49aac56efa8990343062776c42018e92442692b1199d7b4351bba39964225f18545bbeb78ba197ec95ec5633d3f5b1e76b819a80273d1c2a5a1cbc5af51c6378361d5891e118048b09bc3c597236695e1166e00abb66df7e8f5c59c197071ba083bbb465ce8281287e1670d2cbeb1db010cff129f9c715a4e68f4805d0a3401b4da99ce865b58cdf1613bffd4b874859c6365ee2091317718addc13bf4baf9f1a65f961b4ae73df8a7b5471d57c673a94c105fbc0fc3070136e053bbe92afae800835ece8851d73276a08f67dc821ea22b85f2c2d4a74438edef5347702e55e110858a396e2dfc9f958be1f1895433b469fe87f801476a0bc63708b0f8b71e30595d288cc374ff27f013f56df378c2a7b59bee02bc9762396fd4defec0e28f76a6a1f7ac57ab10735d8501f2b653680bd2a481f75c6509d1feece1a33a69d38414ee5b83387704c31d2a4caff3398813be2435413432ac3d644e68643f801a7a32e80c712b7b2394e7ac01f5ad1e796417b53e2545813a45f21141930152e88dafe840373dcdab3e2c6e557c0fbaf934d2579b27613bb29b9a61cbe059df0c85715884378d9e548d425101a06d21af55cc16bf5490a5a14242f973b47816e80efb47eda60c349e9cf6e6711cb063db4d123b51f403979eb3f4ead7a1dfb2b138d0122a0d90007919f38a334d3a861f17d53fc5d21f6b8d01e773d3742560fbaab095fd6a2ce422b32b254f70d8f530c18247068ba91bbe1f4a325164b0b14f4439863c39d9c97bcdc6bc43a4fb7211cc9bfa4c09a2fbb8b6d41c8d886f6fd26bacd158109ebc6c8003b43231a3b471e4f193dece46a0b9989bfbe87a80b73f455a6035de3dbdaf3ab307b53e4a6d3de9c8e56962e4d22a79d1d2ccb88c6d6528a9da46704222cff6c7f841268e04523a3ca1699fd365c224a44bafe14166a8ffb73eb2ce7f27bffecf41c286f7a02c00fa0532937902d2aceee4a50bdc398a704300615bdb056886fbb21ea994ac3b77b6bdeb66f31ab2db241e1f6511a88b3f0436026d104a8419a238fd6ed43503e51ae9e02777cbf6f3f187cb8f3df41f2fabf76172b10f7e0060ef5be394a2f2c1148605bdf857e606c3d4d43fb2a74a095b91327761311c95689d245f83078a1cb05320258b5c3d3fb14731e71be37d2aee04174b03e1cdc602fe1d190997cfd9ebcec4be152847db624be10d55cbd720760b83ebb17f4e324e4a2cfa651459eef24063e46e2bf5aec1d8e91589511efde5dec45dcac812cb302a459dbf2757b4ef6119ca661988de7bea35c46058937a8936aa7637959a06ca5968d78e2f4963e88914fdd334e0076e9bbbba5721d166851e59e9222ad01a68f4c2c10c168e5f6da8d03fead96d2ef617824954f9051a9fe1c683c3dd42e288528a7a0a60d2ec4d903bbbd5ca403d5b1506ece2647c7117fd0ce6c7382c25f5af9408ff209b9601dbccf957437e5135fc2ccc394cfac47d19cb8c003b79f92445efa8400ab6a805e4f852662daffc80172bfee273ad87e41a2ab8068498e6af7b041d5fd228c1e8794c4cbe0583316b449e4342c4de3d4ef00c73069ab5accfb2a1b4e8a5856fd696cf6dc24c3213863427c7625c371cfb5462a7d2c6e2dc32794f94c71cccc0fb0e469458bb7eb703fedee70ba13b9a7c9ff2189babf729f33d5155d3a9d8018ac317946669f1a322f921fdde6357a11cfc4efe6adb793799fb0190db371ef92a79935ac04a2eee62ee95ed91ff56413dace43d4edcdb5b4b079d622187183054699de2b8c1aac55c864fd92a6902481f528733d5290e6dc037c862d78b72bd32669a95e77a2c4a4549066bc1cd5753f70639d364f4b08045679b64165f5c89d67d13dfdc7be0ad31773a0897e3550de69f49af93fa4af376f1c9d4132a5ed1652c6a9a6cd26075830b9b8dd82d2433fa80a2646d0e5967f3b539b9b1daf57bc192047f40c7d9ec61a9205da408e7aca06acd7bbd2fd36061029fffaaee951bf756e86f6c1e86d84c326ad57f506707c88e9c24767c7eace9b2fdca2676421e0d742cb3ac0c24fab608338e2e50d7efd0ff8cbceb2ed13f0f399bbec4f48db431944452bee0a48ee960f068377cdda4108f39bab6b7b49e2ac61df8925f180c3803172c92d54042625bb0014bb4548bfbfa615b83ad86d49abe130af6660deb24ec1d489271ff6b908620c1e477923900804ed6bd3ee6a147458b635b63c82d82102225da5a5fcae87b119ff4ef21c45bd549df8094dfb3e3f34f4619ae179b818989b756c4ce135db2b09679c5f14855af34030e9da739d88a58e1bc6c60dd9b43e577ae128a35c3a7d8d279b0054e19440c1d42cfac5702994ea6bae75298327f54348436d566eac9478158856eee8e0bb830f5d7eef71e9829d365e66d296fef0d7f79310f3400a08b6872863e895cba49227c8604b3da6fa4b2ddb6a7266db4a486f6f20685ca6c3a7a37bc45408315836e661b75f9916eccc892936d28669a6a538049c11bf7ce6ebe8b801b9b35fac361bc3b99a23186e1433c2791c456f3729c818cb60de912823408d1502e1bc0560668fcdb37a8edf8a3d22dc4f71d6e796675600af3f4935a4fa3370b3943a1af54d8147ba8ed44180d3e09a67d58cca5c0eaec86f32a2049ea691b56692bc5a689d720cd0371ccab6dc2d672a34af348e182352c742fa7fe0293d615c6b22aa2e757d4c035382f4685b6df001a3ae3a23e16eb3b097d058ca478b648282c2cf645cdae87b09675812cb66b10b17d85b169c5dfa15cb7e6115272010307dd7c31cb9f16a884668a409bd79507d40f4fc4a1e17a28a2eef881a1b1f0f0d2b77e54c34526e87093d6baa13652a6e6934e076cee07d89c4a0681f81864f039a28c418673f6a734e4b73fb45f0ed76581bc83c701807024b1568ee9947ab532c03157eb56cfb06bcc69bd002a3ed96943e58f69a3d27e39c8e292485b7440da8b80fae6af29abe35e8b5e79514d366cad73e07e8ce2cba0151c972085aae946a4bb0cb51b7acc6be88f65803022e46e410e9fb88dee98316c9938a0956817b0330fdab91cd0c7a268189848110c6c4f769b1c868b8b3fbbf884302e7deeddefcb7b5df5d18073c770c1477f40569f2debadb8f1b5963a1f0f9ed47e4b8b37f490c23eaaf2bda09d99274ad0a9d1eb4b108537340de12e6e04e5fde2078434ba8faf66cd7c186c3eeb176a12a089fe4264b646fa0ade0cd0973ee57dc6818b858e3322e4100a0425ed37f4c1dcdb265b1e042a084efc1e6ddbdb48aa4bc1f88387fa77008f78dff50b1eb7858764c691e200dd778d207da0f3eb878b1386b8229da7254cebf8aa197db12e1742b1a84744f4f3261cb6afbe6e8ac61a8b88a66cdee2b93a53aa1f55c809ab2bb34632adfe19c9b6ec8f60c607f1c6d73ddcfec60c5fbc259a4f9e40c5ca2e1bfd9352212a6b43beffa4c66708e435bb5299ec97f643555d038157149e43a5455fc462988206db69fc3f421345cea0652a0b1ba47f60fc9960b3f33eed67b79792ae3e4f5fe20b3fb98ce45e01e88547f292bd195b2f7fa298bdab4d2b58a0793c970ca5529769205efdb347429ad0fa1e09ed813292b19a88d0c0914d42a9e2ee16928fb1997ed8743fae6fb8a4f21f347538cc08777e079a2a9297952cad4beec0a3dc15ff83b3a2263f6398f62fb3466d29ede85a66bd4473f35064a46317815c952792ba2a8e0beed842fcd011398e6d0e637df5489653f5088213cd039c547996d997a0f4efa10270c009ff7f665a8ab77841f4d292bbdc87aeeac9f08a09a7e86e96ce2538789807ab02502beb7e37774efb2e695e21cbdb0d0e1e880900a9726e4855aba5c6a10e8249e1e942c54614aae44c3f0ed134dd63f49b290574fd5927d8bdf8a727b53ee39d3c589aa8a1c7487886fea12aeb452392bdc009b5da368174b873e215272390361315a7befe4308c9e1f111f1d43c13e17419936428c88916bb416bef756787f15e22b436048c17541be1140a66e6f9ed8b38aca2340c906a7f7b49fbc3d6740c78a8ff6fa7d869c6578519f57226e20ac7292aa2fe1e7925beec5786a1a13faa64a84e6b003e1e453376d0c58925ec94587740c509642cf23ab0902220960fa19fec937cae20711630062185a93f95d767bebd26470ef5aa41818689ad2207f5800fe00cccafb7686ff9a03a0bbf8e25a09647b7e48bbb1610e8ea2ae83f0789d39908bf0c470e481de2e90eec1a8d1dcea937a8346308d45eca56cc9a333464f7140293ec5ef712c5f8fc893117bcd2491d0ec783ea40c0c1fc2dc3418145252702030cec73312f9c2584f7b6c14617b5e686fa8becb62476c48475936c71f9940dd14c2e702cc60002df0cae75d5b61a225e26c7bb1e08aa69f16724fc5a6cbb9a21c25935e4cbff403af033b83cc773221e5a4c9bc58519dcb1aa7a7b8cc2eb9aaa82c9553ef2828f71147d06e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
