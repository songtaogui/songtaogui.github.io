<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"953860b848a0576474c2f93e3de78dbfa72bb3be4134684a728e4fab155302437d013f0502a9bb41768b00e934b48de5dc757c72654d42c3f438a0908ddf29da19fe79aa7940481fab630e5a05249d4664455d06bcbf48eac410a54533a7f21506dbbbc59bae8336853031f0b7fc32e8bcd1c28532a0151cf40b975573f643a3f56a12d00d4622acd84b3d93a911a75994364d56a3cf61e6960056ceb80501e17463f27217de12cbc076f3c3a24a83fc44d3c7f7636d194cadd3580cdd9085cbc6d506c2fa802a9609f9c2480ac6a82e36309c8b26ab20212bfd1157b1e9a466af455bf4a015abaac8ab78efc03e5ed3a58b24fbe3c72ff84f9703545ce972109c9a9977815004e5b45b16066874e2002221a640e93a23c0726769c518039ffc0f8347c9ff581bb67414c815383f05df283100302a4c3a6c15ee3fa34700e03d3d81ccd3689adf1324754a9458cca398daf43b5739180214068ee77a86d2a5618b0aa79186f9e6c017f3bae0ec6acf130226dadac66c190376d67d77e3cc410c8afef08ffc548c35ea952ce7188fff56d235cfadf72b18fb253e3324a55d96ffb26b67b1b652b2b8340212e5c11dcf45ec6dc8eea3f5afd8f71f432c55b35458eb37edac9eea1cb44f077b7dc1a00277880dfe283f1cd64daa916fa95bbba5ddde81fc6cefc46fcf00b11c5ba91a88e904e20bbcfcafc41cc85bf25b0c5ecc17cc0ca9ded917f65a5d18a46b20adc77fa34def3889559bbd8c4ea7689e0ef1d7c74c17684f901ce1eaa7fff7d76a59e23e36e0ecc77aabda826133795814e46211fc386d589cf37e76bb03c870a2b92a1d549cf334b21ee4d2f7f48964e5d236cf2b90074a72d1a6d4ae9b467d595742b2e60b820d0f10a0c547c5224b171dd1dfce84308ef70608ceabf0a7be4c7bcb2d35df7992df433ffb8e13c973f7bc4a780c69946cbc69bc6d92c9e43701cfb9ab3ba8ab26c33b3825d131a6f7547aa76ae3bcede6c98acf010b08b7e7c1b346ea37e869173481e60484cb9bcb5fc3b90c9232a43c1e93f1f7d618bb098e24d799ce66e0f003c7ec2b36e0937f24df6caa6037d3ba52eb34def9bed9b0b487f4595635ba17e0470b9655d92b8b7c1d04d5f08392e18394ed36f59e23de4432d33d3b77d45c6b4d68fc81cb101e36b5152715636b4b222cb9ffca2e73f9dccef7d262ba11974c73a9c2cf585f637b55529ab62f3d0c7b66e353a9d3e6b3e4ceac96487f27292602acf03cd5951f7da1b0f8373f54f2697c94600779bfd8ba49092eedcf9a69f553abbbb0fe7362777075810ff43c65e839fd0e51d7eb4b324ccaefa595b08dde881ff414d140da0c8cb536c14718dec4fb355e6a07c453708f87e18330c583020d4f9ce870ee28ad66fe1dcd247b8b38aa16420fa4030dd0f0003729dd5dec5f97b1904e0507d9b9fd764ac9726f4201e1109711ebfc278cdf597690da57fb5bf0dc9e626397521645fa8b1e8b61d266c8fd684d65bbb5e35df6462c1d87aafd73ad66fec8536d946aa730c529b001e58a0dfca1e7e2f5075363fe575fc4e5590f6b49c705dbbda500becc03ca0a355ff70e41b10e1a0877fefaad548f5cd3447f920a83291a4266d590905eee41ec48dc7956bbafe186a41a85fb5ccd5761882443fa267c44ae21c2a35a8f005837b183f9698e73a055bb9f2799074a8fe253abe68e993ff920df7d643d3deebb6becc8a3ec514a6e4e7fd119fabf14675e6e77282c55e6b6ecbb7b0cf2a51c167e7c3145df38ba29a4a0b5b4b9a1d72e4d21e4adba1cca8bd7a9895dcc780d58cdc522833bfae5b99fb79920d23904f274bfc503659449e09ce7bf2ed4dd4ed7a83b2218e3f25116ce951d9007f482be4ba97d5966e53e0c8227fc28c32b6ea01ba9258fb3d3fdf9214b641a6c47629516551924e029e80a2b1ef312d38ad3a6dd0d7f7a308d77bd6ecdd0cf93449df596f234cff283a0525873a4c8c674af18567d11ebaf840e1fd795f760068163ca5c06bdd115e8767b769fe46600897c2bc82e42948699eacb58f52f0f20d9d03c220b671c1f24af6db6ea13af72cf8f9ba6aa1b8f5c3341345d958f6be809e4e9d4768e6322a53860ad4f93b333d8cb1808720ae1fb17c3a853eb626e54038405ea6a426975582c6b646de578cd1bee2ac6bbf0a2cca2f287a444d52f663c73604efefb9d1d238d6da9b966acb961bb58019b4c8e3d05e73ff3e38457c0e038cd5b6522d768a51a213e85e38c40120a7e22a3213caec101102ce2a1d0fa1d08e5d7af6aa3b799ac10c3a0170deb922892238a335be0fa61cfd84e68fd89268be60f6d653d11d6d4f403cbd39500bd40f59673d1220c8ea526f7da73f3d05fce38eca6b92212f1e3b559c32d7b4ef22257bac6db3b60d0f8a75c49d6371fa4b2990b16032096d6e4f37e7df4b32fd32eceb51ab3b8d07c1ed5c40ef2b53382123b03664f35659f25a096765f1149f5c4f07ac594c468e60a32df0d35418e1f9798e66566aecfe9efac9cf69f2a2f5717e142bf7053b4df2d53895aa9040a449da2c3740dc05f6e6cebda25f6c8544ea7c8625d772076be47af8a53650e2ee54bcb0778be3be54951591fc45cc1b800b89bd2ba6a5e7070ba7fdb558fca8f82c1e375644bf4cd7e477f4118f9e4998010cc5b23642e0045d4bcaaa03629a643c7ab7130f734031580b2a5205b7912f609e1d1a4d7450726a000a9c4323d616d8276763c2437f6d80c82188c0c3f71776a8a4ef5a531060c453d8565c92201ba2b3654741f853cc6af4560a2a0627da54592c7a7806761441ad7fdd92fe5cd7a573a14d9ef954dc5fb8090fb86fbcba0208fd6029824eba821071b33fba90fae74933e4be4e4f2c4472dfd17e9702d4dbde731e39d0d6b5835a512a2ecde7b618316c3c76de31935bf551e4008a47164dc7314589403ae0c012c990f1e9c003da53242155039a5df24244261e180d100809a737ace86d226f6631dd43443285627ebd63d531b76ed5e406f83ce7c3007c63e6963f169c0f8e133b83a1051c92fef799f3b161623e77eee38d3260801a549ce726f5a9dc125137c407bdaaefa16652ec682fdde5ac6769f53454775b009a3afbb963ed6f8d16fd7a4dd4654fcad0c334d8f461ab87b51c1b54fe3c74782ba7a94adb4c1ebc5757938e811c310ec0636ac4235247d99d2a849510df480d291b41b39c4b69d86fdc30ddb15ddeff42e759a20a79d35c177958a03ac2171555dbbb66a73d9d2d605f030eb373ad2de657ea29e535ac82ecef548e5cb20f70d5d884a98f53dc0f6afb64176f7ae674c5f89b09cd4c2b6a8ced340521283c9b4bf61feac54bb55841b6b28c27563f2f563b0437618c5e6af705b2db23ee795b0fe7750d02c83d460731de12682b1a03b41845708f82b6b9d9edcbd209c26b3b562b4594daca7083e255f816a1c2feaf88eba08b2e494ff98dd5a185bee44f83bbf9db708695107ee0d002692adc8fec0ae5224663e78820cb8acf178a176ffcae22718111fc70c87555d14d1f8fe08bb67e78a266ddec9f5b0c93a10c71670dc8327404ba88d93c421fd2a40887329f6c044fa7a760b85d3cbbce923b5315c703892b54a970930519eb658742ff73f1146c06fac649b9852d02dc17bccdd4487ef261591c29d3ccc35e09963f9ae1b9e40dbd0284446317875416520d8d02a41668e8ee2f7ac4be89114e80bd57eaae1485a32ca460b17cf791cc59ba4eae35daaff945f2a9407eedc1fb37b033e1bb52570ad63eeea7fc7e130b387862c679c907a7830f9de98c20ddc252910c5f95c07079585dfd7f902875ecf0253e3ef3a225c068a6d7894c0fec0d1394f3f42fbafa8777429510a163e4492099e7521e40102b96b4b0f5fe766a33ab21807e1b1abbc5476605aef7a2ee8a4afe0190551e1f926507afbe0de2794648561aacd2138b01f1a7fd8288dc464693ffe8a271a56fc03795072c6c69786bae1c10f514fd3a883a0db784fc38c5d9f146f4748da089104a5f585c29637a134d19179f75e44bb8be40d303ce6d772a527c4c77a25ed6173569b69ca295e87c29c454a5c40aa88a548c3b88cecc5e80e785dcfa6eec9a5f95b53e1f75436170eeeccb13c525504caaa957f5c5286a55de80bfd35a8aa0295b71f08d3c90819e8394eed9ebefd4d18363cd895663a667bd4236d13e0d721acd84cfd415707c62e19e0a15889286defd2ca51c3ba1ac5263c87483820f6ed066691bd39f966b5452432b28e802db11f628a848d9876dd1581aa184c1db68a231bb02e995f345745d877a397688590997cc322d5070e7698b221ffe214b94b561a93790189adc8b75abd936728220eb83b3c0d52799600535767987dd0a9d9443d38d054644145d40fb33bf2490ac86566026a43c008bb7fe7f250aaad4d61cbdb4ebedc4d44a53d6e7e3637285194f87c6440be19a546987c07b29c7aaa8551615ba1b40971bf194ce8fcf5c9c6ffe505907a68e8416467d295c616eec4194805ca63ffdc6035448c821a4b099b978510c45c533693454ebfb36e8053284225bc5fd45d15830292ac282cbc41a31e534d8cd325742422038e0a6e18d98d338f064c9c5e97cb6e5621d2e2f89e1ed51150f5b124a65173148957968f6314c1ff850a94bc49d130257947f0728d48812916970f054e01688189153a62ca9ba77238002844bbafc7679fbf650bf8ab05ca5e12d11617205a24bc339de03df27f42c3eba980de9d6719f26b79c37abfba1bb90c1acc8222629a5aaf4b6fda4c38de4f1179b262c09c1a4d7ee4653129ac05d76c072cc27e51fc5c6eface6bfdbcf9b83b6a25ce0768035848a144a5f1eb0d410469521334a5a522e6540328b8f37b10c04d3d2054d47df6a8468ceb181915ed48f89fc05107c5523f4df728f5e4d00eec639018760dac0fff0d179a3f0127e6d5018f7dad4dba6d836701d2ea48efd8b40621481047ce17da020e258216a2f70d9dcffb50daed53ca1214e6cba1f3a89287b1e58ef6b6dd7e09e19a51f2121f81a2380c64414e515951ffc3f4690666299af15ced1812a7db59dda1c4eb0fd761207d5d6b18bd8b688afe5bb0ec2317d2116ef8c24d0e122f11cfafb55bbb3c69fd35790a094b14f1ec21a5dd721309dcb0599877873ca56b21328bd13b34276c11d223da4d013c2b02f59175aa07f5bf4e6cba6ee727b1e129b7820bed753fc6f6938ebfb22c4d7d92890f48d976c3e34d8e6b0021fb4e25d946f5714907388ebac9f33a178eab6072ac9374eda6dfad35e0e20384881467967e1faa4da04588eeb43fe37fe3faa35e77ff0c41fc55eb83e2551b23235f4f0b3d6d0f67bc10805e7ab22d09984159925aa97d26ef059118b4b308dd4d785bbb99f49b99d939ff782a4ea0b7056d51a869822a0f3acce4f6264eb01e761e27722219097bda9428118a83431874f774beb8b010d55fa9e40f030087eadc3ec7003801b73edf647832177cfd229fab074daa3c09bf6cbe7dc2e5a6df1bb2c8d9766d8a358c9f6468259a8e41732a1735e8ca79f575934a727fd96826a18640d8d9dc796abcbef4f1502ccbf7016851fa92ffc648dfb75ca8976a916b138f3a157b5501602f877e3b1c103053b0da997d0c854f2ccf64c31527dd32e42ba218174799570ccd0709ecbd4c12c409546da467742860cdf33abeee85ac437ef626dab857bcc792139776491b38fa93c4da71bb4c5196f81ca3bcdba5f8b451cc7bfe76224ebba32d3d5ca585a207439ba1541e275570f2740a169ef5530bec5922a8e0d148a50ef0ad2ab6a182eb54357fe1b36ff6732c5a3ce3ac46b067afb5106ecd974f41a6c7687dd05dd5a06da9344cf34a2fce7306dd4c99b64b95e8d5f4b26887e9bcc87208092b67adf32ba69655a15900bfd920e78b64919f8806c3a8d6c79db4553ffb48dd058572c9d5941de1be837efc9b0a8811a773e30e3f804e073d583b18ad8187a76708f0fedab6f97d6472751da0068134bf69ae220261c3ce09e97ae17a1a176a935b83d1ce24a4bcfbe6dc88a45cc640a20476813f4982e54fa706b3dc6f433b21d336e8ef90d0a40233570abb876a418ca631c7dfd26dc67d14b95b45eb988f0a66b3615c18a8564bb376529e4c567019192c0b566eaf580653144c854367b5f48be8f9609d27d814544725bf4d646dda0b3f5a6c90254fb219d98800e0daf2e37e8b4d424bcd44fe57e1c98c46d4a30aa8d7a7698cf3dd2e86b8515ff8dcb7c0eb950353c66e51e47ba2092963307fe7c3288afaba29d07b7c0e52f16e7f3d3241c85119e52eaf799651726950c5f2a86bbe3ab3220d4f66f0ecdbbb58a8407ce01ae6c76bde49a29fcd800874b827bb053b632941c276580094e936a19e215f4478a84906f1116db01a17a0d22a9217e5b4dd10fca7e1903b02bb75be203df55fe2bf825da9ba361854bfbe91500c9409515c87cbebf54ee16327ad6e3817a6e4826966b0355d7a100601728a3d150e09199b95a2010fb00be4ce6dff6a7c2ac4b3d4d1ee23218b8a940377bbe8599c8aae04355cf272fb83df20e5e4ef909f0e527c198b81f2b5c17e5259cdb574ca153daedda63cb12774b37506c2b2dfb68b22a39780da59f32fba1a545e9841c2b8c72873a87f5822b61434fc885e7eef5aa83108f72cdcc67cd1ddc2d737c8996e7a065398e09ac86d03c61a86af443a0c2ce5398dbac17865453112721a217d45651aa9e92f91e2e253fa35639dc56e05d90a1ed33b6872ddf10340fda7932227788014b2e99ba255d1f80881acaa806ebcb6dddee4f41e829dadb526085523961f9b2bdd9374f02d120b09009c8a61051905e5a93dedc9d3b450d3b8a8c9e782fea056e3cee738ac099fbeddd9e199d11ba97dd3e7a3ddd1e7b86dc20c50fcd0da0ab2cc39f4ab0773cbd8aa483636e2782ca0361f3ee78fcb31bbad0d702e17f732435b7d240c15830ccd584ce00a7067ca44170e5512ab9f6b7ce95202c1099a86722f509da1996eea88e7a0a95b3117675a7e7cf2188911cddd5fa9a0cf8bdc9127cebc94d95d8d30d40864c08f1872138ddb0fb4e8a869a3db11df78ea76057aa7b2666bf4f804dbe68b12d114fff9fce4f74ac6379bf3dae5f827a29e459d169576c01ec0e30a937b98219b0db8eb0a0973edc3bd1925c38360fb45b64f106fd3464838c0b2c4d96f6fe1d3426fcc8b680e56977e42fda281da675a355eec304240f56b9921cdd05bca57146a1101cea67e04d1de1fda3fefcaa957c35c7190c00d6afdd83f144a10a7175b4f0056da2c9dd3385f40c5cda4dbdbfab8c22228a350ce47083d0f72d9352253a9df7b9f7f9ca0afd39d3ab6b5c8fd7de20c28e807627b2b4f5c0006e9dff58ef0ef4e11fc391ddf523afc916ab93763156b92350b76d0c643836c94ca034b420fefcb979c7e79838e558e3557db5bf0176d4c4df77fd7afb1b9f36b5bad517efcfdce7b71cecdb9181ec4f8807945105444f32c62e4c657392828ae22a8a0f354ba0d16c13fb2e8ec980517a11523be933cfeb67102ad86a627dca7eb8eec975dec58438620d4d8d05c187b6f9b0e3bd65bc8fc4ca437acc9d2620c19b06f47b5ee9ad692699e6eb398da00805306735b1425942a8821ce81f8a0e7dae47be7d9bf53695b7e6c6d794ecb96a7883e8bbbfa0f62ce9396d1c0d269f83728aa6eafdd4420f7706e77abe9d96514c10b5a04e4da7065a6ce343bdeb310b13b58a99c28429015ec563db9980cf4cce866409e1498c62d10de6bca83b2c9330f0e6f2769586e46a9412cadeafc9f340ac9af3e95a8104010ae883c208e74000e515da87050ba14f7c5211b7dfb2f90c11fb3f40b99ab203cd8886e680f754127b3716e1a7675bebc90475f9bc03863d834d9de63783fecb96bd7f9348bf10a446f2383296af870ba363b8993c51325e7bd2e22d92002c267de42dc79ec7ddfe4e09658012fa3f2eac629a9809fb87a70d514b469fd55c0da4641be086ac8659abb39245f8d95c86cc3264604c523ec9e6c101a45a4186327567d5eba64d3785f453abf7cd5bcbcd3bbed874d2b559f765425c02e7dc13ec70866b12e994c864a2c1b2055e1623813b8654b2a5f67069d9bb5c20821dc11621267d776568560d3539e6ed8c84ddc4dda02961c7a86f56bf2aac3f52e0852effd00e467d4500e132b879e8948e59d94794d7295657d6aea5619da331f9e350a06b20ceae0df7f67b7c197e971eb6fe97e64aaeed01ba72b649a9c272360175fe102914cdb83366d1958868b8934a8d471445062b26bcf00375145b65c61e381e1900a9df81509b2a686bdb9e8a2cb40cdc642af1588f4704da5fec5669e6281a15f457bed0d9bfe71bf9a1cc882ea410ffa8bc6ced636b4c0cb963e5c14baaef3b6e9e0e5374243d0fed495808d77ebfa45565dfe268f4d75eccd3e6ce2adcaead750f769f7abeba6fcabfd1066f7a7028068fce0915926730716f5526d2c16df3f96766b5b6b4146b3859731a5907028504e035b498258e57db9d3f1f55c124472a72dd95460f2c8c24a4c991aa139d7c2dc808a13fa7612be3d60c6b0a23d1fbd21d95a14afe826ca6f6416c2f739e44a9bfb3ce6d8a7fdc575eb8fb74cba5d2cd79e0556fffd2c589fb1776b9e978cb15df6c3bcf09af4a8b7b98006d2c7eab6ab1a397b9de54a00c9190b93b6dbf1c6173dc3c11a3303222a766c411af1fafcd4bb445a3c51292e30ef60357d78bad76a6288bd702605f14a08368ec52c5677c480e38cfe2a30771047da85b88c9b2446a4dcc97f622d604f1c5093109d57c5d09c39acd9952eb275bb0a7ebdcf5fc59439334e5e081ec782818f1421c27362a2a684b52d03d8868b480c5c18db0fe993d035284e301abe4b1b429f37ff194819e6af5013effbdfef3f8f1a323ad8ecbb8074e42c5dd8cdb2bc154f2485fc11816653bf5a7a85f5782e07bd6b9f2fb343a1eb76eafb45ff86e5ef3ca2f52ce3ce65c32ce2b02b3ab60c83f49035420b1e7b04ae36369ea11acb66c3710da43d6a11eb832b9084301e4926f2af70269f521717ea99f9f0f61658d004da7840723b8e1fae58c67fb7b7e0ea881f0b9922a26c2e05f660d6624e56f26c825e5493caf89296e39a4a08843e907e3786d493ef6e1480d0b155a2c743d4f0bed2c366ae448274eef8ee2518688f78fbffdecf21495919a3d20197fabb97b9beedad03fbcf3c9c0f9741c1b286e429fe78b599ea54d479b2d408793ffc33ad7eae248f65c1a6023fdf9c0a6f5de7d7daf6285f10c3e83590c30745ff97c827f74aaaa56bfdf917ad3c1c7b36e5240b64d7d53b9eb8aa15b3a1c044695e6b0cc761b194cb68d1745edad1c31ac22e4f349656b956f355bdaca4cfbf6436ce47c8f87d4e9face5993d351c141640225a8f73dd2f67f24fb4957ea6935c5b7f3482a8ef9baf4e14de69210042663b82d0b9f0f3537476c276604c2f1dac03ef75e85a2c2529122c247307ed29d0120e7fe7467d1a36421666d2f39f5692d62d258d1061dc4a7e8c1c83877e5a275be0492bad989b23d5188d41912c128b57d314eba633943865d375c0f81d6e831647abf49fad5cc792bd1ee1f0e8f12a54a10e03e07a1ed20e621d9b002637bb71f47f65eed82de3504dc55a63957706f82fc595467ab42c2c8f9e4d77733e96bf82762bd81bddec67025fd02a935ca920c09af7f18cc92af4af9a2386c1d106c0b2bd191b2ed0bff29748c688cbbebfdaf25cfd38b16c41f02a6c928fa7e3d95cd8610212e0486b6d090337dec8f564d2b8195101da8ee6f91b8c747f93279c7a28c55dcaf60f318f68e9cafc3b3081fd34ab468e4478b0c31d9d3d17c37e3d0de4e8b7a99d74d7782160b8e4550cf0512016ddf5437bd4dd3e75e82d6695f74033f9b57a6ebc15deedbe1f27c56e2c2d18219e6c0e1b4045e278809e6f557f4251f0620c8ab94d86f546ae44b75ecee66bd6760cac33e425d9c223040326ab367822c85b4e2a5b4fea9978463e7e454ae3887c4fd3c5441c42d243548daa9de5420e3879d06668b4e99c677b32cf5773b93514270cc0a3bbf84835c2be60edf5f90e01244c1b66b56099e36ce075e958b9210910fa2dd9a8a0d68ae8298f2675a3d456fa8fc9ff590b3f5b92f347f6d0ec641773211a37995726a3866b0ea6cdaeae448c22c1e01e6e3b38a6a94baa2bddfe25cbddf09dd97f74ec847a801378f9112222d63f276b8b69bb17b2af73677a8d8e2ebd67cd56e5b5ca1361665e336c8d6c74b1c8f166dfd63ad413573265e7a982d165879226977280addccdcf4aa3c50942bf754d73e3ca03c250a5adb749492dd56b0f1a74b1cb4cf2399474de10f804d87d84dd9fdc6fa8b739de81e1fcc39f3426455fc0e2e6f11eee18921433dd8ae0921624a55fa901337e091d455c7f9b70adca33e6bdcb4bae1c873bd3c92c4d1750a2ba24709e9fc938ba8027205445e46e166f0bcf612dc9a71b660896119fdbc7500ffc608a47d3a225e7684ad1b65b614e93254d496ce0c8a63eacb01001cecdf41902019c4a79203f67d5ab4cc48854a41095c57289dddaebaef95bc10184f04a1c46a2b736e017a731539eb11e14ed730abc9297eeded4071f910fd73ddfc12da2d4c5e2a97cbb17e41070c92ff2ec8e86a67c96a85707d87f3e955640e3fc4d123c2389f8260fc03a1e2f8b88352f9acbb288ce047cbd4eee432d4521ce7aa2cdda16561872db91aa3b0b383dd2a4625325fab46cde6b8c76dfb640bed3262d5976bf02c063019492a3e02558321d02560176bd7948f2d901f5438012ebb42b9aacad2e9518bcbd0e4613e68b0f763738889cce03f66707c0357fed66310fadb0a31c91a36fa920c42cf5cd315a2aa7faaf0c86bc453a75b20e8b63945edd75db62e5110d075917bfeb844a5346ee80f691a748fd2d8147c6d7a40a05462991a0c4e6dedcb65e45e15fcc8542e2848b0463930db6225e59cb403fc3f761dd66a314caf8a2980357415753663dda2cfd2ded58cf2f20ef37ced9f4689a7f61aef0c7dbef1e53cc844a1336a2002b46a0ddf4bb0e1ac8d893df1509b94a9b0e676c144d80bf9feb787cdb71b8b7b3e5788bff74003932ac51b38f8127b44fa37c880c31c368a69734d1871c83ddb48120ca59371b0c2f7142746b2c50b0045f8da14ca6d60822f55c392e3c0a9b0336528824476118d6f913903140b66671240fcc110219947dfbdc6966fc12be9527fddec775b493e86645b2bfdeff4bdd433e019ad67bdf1df19abaf3bd6d8ac7c7ff33611055076c595cbb77d66c80bbe90579855547c5c6e201e3510efbdea06a2b2117b68778f4eb8b81db6677d5a7624664885b13b827a6719162109b536f31d3bf67f7900aa14e63fa640397b9601cc7aa1ee34827dfb48f9d6077d1e03b8d4aa055cb94b1b0ca9080d74d987c0284387528921548607f1894a2296c0fe58af5bc03d7810bff560aec6052d59efc25dc144127969cf81fb5260e2fa7152c8230c8338dd18f87fbcc345b887fe24e67284725a6b1607c672ada9a9ef7c634ecd5058ab9425bfdb20fd21e6aed3a2fa0e386ea33a38ee73e2e121e5ee34677dcd52cfe99e6ba8ba832e62b8db23b3d74feab2e3ff7e67d61cea86c43d0798e8c49b3793311166765ae3d72a95c6ffef954b33f1760ab0cc1c341742f1c8110c6b9cd898b39ec1a16da894f96c2e67c7ed644cfad9429b647ca82d47751a4ddfc84ef3efe1524b58d850b4fb28c5bc819fc8ff9bab89776888638260a87c6738f1a6569122de8e5553e2c2394dad32b3305f453482edcf0713e1be57ba04fdbaa01aedd9e460e0f7f3b5a8dd1287427a0d3d242c7a184c331f6db2cd6e096ed7915688cb5d4c9265ef5423eed2c92477355a01a55b2e153626e0332187aec34ad719acb1f1709a8ea2beb4f5375a349c685b779f9f582fc028892db8628f9e15177cebee07bc81521b92f70dde478b3bd860048b383df465144e1bcded565c0a1c5328657e03824036c7746507b34c2c67c17d5356b47a1242249b068a60f79e1ffb289004dc7a43d3dbfc357573623e3a23f347e70dcb95d01f9f88daa70f60b5eafcfafa3a0bc088fb4a3c4757bb3bfd3e03d8f684ea2c37779afda31f18308ef641b24d75aba9b6272493c07bb6e34d086155a9d963b83c595bc632a9539f6599c1f999be85aad8e43fc3306df993d1b7d98be9f2153610e7f56d7756d9b150793d90923515eec638b90b782b42f6fa773992452093ab2c972b079e41ce9e944314ebcd2a01119765de4bec5b84a6e039ebb5a5b371fda3f0bb75fec69f6c454f1363c0c76a7f605ba69367cfe4f7571e4ff6be4480b112274e40afdb998c5d3a8fbe8c9bfaf52d785ce348cbbb95dfd3f83b2fd0228c41f0355fd6be179adac8d72e381a544aa1deeb3716b77687af26a5877f8e3cd87a1e7ec9b7f6ffe52eed9147f14ff1463df35d97e7862e14a9b71b4d8ea7bb2a7d991a288e3f752d8b9d739bb389ec7a14f07e3c5f875ec6b06e73fd6446aa69463ce8efe9354d6e70cd55ac6a8fc013e367eed2d59acdffacb44f09e74d139f51fb78fdad4fec4a2f9696ba3bb24e6482d4d2ed6854919a1d7b9b5c9db42a280da18e538a16e6f299395eb7550979a7df9ae36d27c49e494e9db960acb9223d5275df9541fa90696089af55a1e7c07b87320cf257d2ee1deffa8accc3f835f79db94691c01940266f47263d8f0b39d7b5f78c1676d3218663e7fc783a5d907ea9d1cb7ce7048920471b933189b15f75cebbb3023a30bfa02dbd814d615c279a89eebce5abd3262e65543db4d88369e82b5bdf295d75f3f6cbe2216fe63ac07d68e525cecd5cb2c2adaa82c893fa5d0bffbd3743042df27f24327eb97ec2389422efe7d0341194d730cf0a35bffa7e31b54d89704a3a8f02dbdd7cf925dbc3103c08f7a22b31653a71c3639380660971eb64adbcafaadc57d96068a8288b86b7655eac58dd66d13058e78945f9e06134887798e9c39402e06c51a7beef65c941461ffba21088a94e8a8e312342de7e43b86f5a4722964310846d98304114fb440fc9d0caff8e218c77f5129e770248aef766f8ee86bb2dca63dd82c86a9f007c87f7b701ca2c8d1de946930ace2ddfa95b78c52088c943c89faf47e60b7a22b4722e18cb059525500adf0218d2ac63030a9653ec61fcd88cf73dcf550570d7f5575780f218280e22e929ea4fe3237a80c7921f225bcabc0cab394a1489c209211335cd75905d3cb99e30dde477f83a467a7199c1f9d9fd6e87525d8acee75717f4735a0b3e4662268f3699e7eba49237d316681c315c56797c4f9045271f93ec2e76dee1422ca1e23ffa1bb2449d441b90ca7b5195c9ce2e9650e6019b620e72859df4b6ca605abf7edc5a65f0291407803e13afa109a9b67bb4609bad284c3d02d0a639798f1850e9217bcc6664dd2afa681b367fcb3ab4923d21381c6dce314024322455e9bfcaf6d4bfc8765551f746d62d1978434876b8201bebd3b71ff83502bb41806e30d70d28d4d91f3faa1214c8552e1e81aaf1a9902b5e510b095f01b90f38c5b146d6eef183695c49f44c34dd811311ca1548d7187ba81600abfd0d0083e9199992fe869473453f905072d17545ecfb3d18baac4829fd3785900f983f9add82fda9004c6a918e3b44d1e3fe849b97a1211c2057325be276a814ac50818b7e9d372b0979923449bfa37ea5d0c458f77394b320110c9759432b2636228b93d095ac89d0190a39887891098bd609bf91b9c922cdfc042fdff82cb1b4f3857605a634546077bcbd8b2f2034eff8c8cc27f11f338febd1d9be00434b372aee16a58a317de3553f51aeca32b69481c59d3bd9e6bb340f5359d19c6f232886276753717ca97ba853a0218cca750ddeb2268120bdd601f22b12fc40ec0adf2d80d768beb97f43b94f3bf115ddbbe172210dca2e9610680cf0e02659ca3474c0c5532aa9d1d09317c05d6b2d140c460057a73e2bf306c2ce4e2a60380f4cd109a74edabaed9ca301f27c8cea02586add1bbf8440ff9156ea398e85a28b485a81bf839fc8d719276935602a97e4c39c668b0898a478239557e7ba647463f903488cba215d8f0af085b7da088b15d9ce71bcb491ddcfb53bd3388245aa7e0dbb216d03a4d3a65b34a883efcfcefb886a21f9c1fe22d754384dfd8bbdd89ab3105bf2ba8b807857f6b9e55bc2090553d7a5af4f6eb96659de57039bcb7e80ab834e22924c5319fdd7f35587f992ebd48d3dee51b29c2861fd927451d49ed5edb26cc66ef6b4bff9a69f25660d093e782d3b54bdc78bd70913952f0a183324b0f53075dda3e98d94f2ba77ca94a6d2e2c3bdb867180244b49f5ec4d2766facf1069e48e53062ff8487ee69ab609b8055e8d47fd29da1738e84b7b949769892246249bb863c2ac5c1e9e8cdd401eebfa29c17077decafc60b9e80b3074a76c157feccb9c2a549e1f5d3e436189d77068e74ddb1fb86122f1083e4d1e8fd7de1c8eccdf4195c5213640e414d5008273a6de85aff2ad9a0e4ac6e802d8bcb59656e8847e36d7cc1909dd2472f5e0aac58261277c9422a065daa3cde5bcd689a8b8aae30eb9658d201b2a156401586e6f87ae1189ce3fa53d067288d151bbaa6db3639a49badcdf26827267b005ddcb0a24c9e7a755eeb82d8039a7a79427397f3b98241c86508d034be754b197f90c9ebc3ff50910e037c0c1c5fc45f7f9ab9ab605ddc76200f0e2a93cfe2c2be74cbfe0415867f21e8ac7db7f3be9990d7a8f6248e7d053ec0bbefb98e3ea6c34837b49b75e98853f52ffb590f68ea46d10337e1d1ff08ce7877fe8e4d95daff473dee66106297598f25b8b121aa4a74462b4f616cee5a301ca1517174309f52ecd428f8e4b3f1b7bd49726cb1596300db695d15c31acd09247fddda8f59652cfaf69bb48e2598a7a965370668216d7b453b80fee6301302bde5a5203a5616a5746245e57abcd074180e9bcd759bfff82afcf5499b1ae59188a94848f0486a5bf70cf128eb838286a3f3833fcd11b3f90e229afe0369bcb235e102788a223feb48ab0f687ad0518b84f7fe3e97cfbfa6b3df32c4cfbfa20e730d3d3c44b65fa3881814627d386909cc65bbce19262f2a47807c4fc15cf1c5a99ff986a570e6f0a4b7ee1a3519cbfd679a6176b9df92b878e0bc66de5ef762e1d0cad9a14f9728656960d8badd7c6ad3d0e1aa9ee08077955649fb92d75b3b9edb6abf4c3957c62694c11bcc26e5ec218c688dd0bfccda99247ef2f8be7e5fd3b6b3e137fbf05b6ddfa6511177148d83881f6d4e21d7ef1d1ab3231b0a3d29ad571f9585d1c63da925b5d246e8735d1f681b48bb23bc12c2f093dfde31cb3e20e81f2e7b7d7521b6f8fc3efb0cc1b3f5a6459b5bedd4931a4d98a96e1965bf991734c9983bd0b88ad46588f77f326bdf2f8e57c39eee9b2248c62715ea769112b4659c478f0e690f4eaab8d56bf0d27f87dd8d5cb9dd196ece5b0a192bd24cbf5272d12ba18a7b9b3be26fb391cf27b42bcf4db35439dc211e7f89a80f226ecc34f9d210cac98f4b82578bbea1ec69de0ba1eb49e8ef18dd408ae51555b6e56f2c2e3b8b55bc983ea88ab18bc865837d8cccdc423c4f25b0d5a413e19f0a32bacaaeaa2e7f085ebc0efd3af3b6d7abc15715362d278059e48bd80fb0687f2e4a6c0ad51d357ecc7efb2f8803a865f29ec105e01e15659042195c384fac368921d731f4830ed0200bd4a94f6cf6289a6229f6fa8691746a64f763f86d5e4cb1090706d2ae8dec17732cc241aeddd21a21e53fcb72f99f693640f682dc52b6b69a2b7f3e13a5bac10a26f52ec4067e60c03c19e766b1b27acc36644ef3479208a77dc4a4c6440a92ee9656313cbd42a7af33ace54f09fa2cae27d42d58e09e058ae33d1f0652a842d217ff5132cb0bdc3be98600523c41f0f3aa91ee7ec23f3a36f3f83c6082c866616d781f5a241fb93f709aff65a459a7b8e8e3c8c3660f8fa44fd84bca8fd0f3ca320acc22d6b2da90136197888589b78a1e9fdbf2fc8b8766c43518f4c9d452d59391673f1457450cd879316beb983d75b7179f2cc674d647da36e0ee09e5ac5bc565d04861013965c1473dd2aaf666255bce7fa5c2eb5b333598810072ebb2763472c01b1d4032a27bc1691b05a1ad97a2de58da075f4ae60d55559f5dc2f5543623553d81a3d0ab42f2983eb81574ef2502b7c37dbd32b6c286d4eb21f8fad98a206e1d4bf3220ddabcce0d87d844014be9751835a5ae71792a0b92dfec9c5acffaa03a84c72a8e79512dfdb8f87a7a094189668ffd5eb4f93b801ec469c21cc9618e8fc72c1d4aee45939184884a559fcc17914dd1f0e33914aa7678f88b6eebeac5eee29f1eb937aaf690add89fed6ae05e103d21aac52565fa3c0cc1fae8a2346e1c7c18bca9408756c2392678a152c541d8a35a0c44b84533e47d63eda8c6b6b4596c1ff8562884cbb3da7c35609342e51f8b8e70724b44a58959b5d00d2580fbe01084e3b6e94b38a32303c5c9e310e2137ca6d619f6db8f1934e763c778343704533b38f935cc220c5277ab9a06da0b96eaefb10db67b0088ffbd5d09455bf9e999871a4042ac52a0101aa0d8c18bb164a0a20ba25b288e6f56dccbc3e88e608a112b5ae1d8e87409761eca343b7eae6aee3bfbbcbad3a6e617a3dff7cfa59f79acc939d21ee47cc5009d70de8337e4c43ecd3faa3481f35833d4824fc86a274262cbf42291317dc073b51b44246772b0aa485d1b511dc85029f5da29b560d33e9f21c3421ebeb1a51aae8267d45998ba2f8af662bee4af3a85419bbdbfe3b8170f6b6140486b33a27aa11e1d71a468513b581a05c2b93cdf9008e2c5caf5057a3a14e43be7992e937c5c4d511b20a74661f9a30585329b7bd8179a20e90baf93e4f9f3ca48103938a2ccb68880a5f702aedde0592aa292e29f6151a9e5836d790b5c604afcd62c33735dc61b1213c85f2bb082884c928091181863254cad66fa533d3598a5e2b6ba116bb8c5545ac56b43ca7ac91a78b0cfe4c6840bf7bcc8848a504f259f031761da97f75dbcca9a9a8206618f5a10c1606dd245e9c8376edadd7a01fd8e08f44389c141601286de6fca3bea35937e6c7488542bc3075967ec3261d7860658fb3334672af7ebbad575fde453e2deb3c0e0ab244cb636d528683c0bbad02114709c960c46703eafed9e52b4973b0060d7500811f1eda17aa25b5f3626837d23176e05407c5449ef2c2626f5575c98540b115aaebd0f321fe8b3868169c58127d585b829bf9568a67508b7df9e2eab9b74fc071d927c8dfb7454ba9b40ba7651b9d8652c784d798b4baa7ad5d628c4b62492abdb65c5da1f8d4bb195a923fe15532c415898a7fd16450a3a4dc9bb68ce17f8c86854c88f2ba43f4be7527500ac515076d1c0f6337186befa35080b6d9053224e70d709916217f0b772dbe7ef58541cd6ccc2fa6cc4f7a40b775ea4bb14a03b34ce8ba639b0b0bb69a9fd64beafe7d69c9723b4586bad0180178db52d9b5125c1e6c8f8e413e8c502336d335124152e8d2fdb2945058cecb2720246ccde036b6dac6aaa9b6cf5256ed304a6e61d35c5d6ededd53060664bd82a0bc4b9cf4a0106828ec048e4e55a0eff34f9e0a7200199cf12a3cbbfe43600326c758f3769770636b6632eadd4b004a7e1247b97d622be89ee9fed4c33235acd02d3ad1cf77f425eb2b3c71e2164eca9c62bb254bcf4586d921f4a467755836db15537456937fe04c2cbc8e83c4fece23683cdcf172d0a77ef0af5caa45b82bd90a02bd680e99fbc0097c143e67276e0dd0bc8352ca1cb2e8ca0749c303c654075263535005e72b3c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
