<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66a10a805b68e212f54c97d224be40a082972e2cca3ee66fd7e04a6bdbb806466cc8a2b97c0f8a540eadae15cccc6873bb1903dca190adc1053056df76fa8a11deebe40a99e1d14cbc465a5e16ad0f188b30893fb369562b3e83a7921b8ac5af132eff2efc6d15ecfddec5aa790931b9b36b9d0dd918dbcbe0fb853f2d58e36f34afbe8fe2f0d21697161edf638653d016b93e1905bb85e400e391918901095cc23bb6a1a95b93c9c2757081a97cd48037e864d256af4bf537d69466446930a25b23bc8249399d22e108f437d9fc00d0f499776fbf71ef2291d944c21f1d90186293209d97200941d16fe892af93211134dfb4354eefbd7ef55db95a38ea448a97177592bf7e71806c8e4932b7775aaccbc349bac7581f3b7562e7d68aa757501f58b1f9258037c8f6ea2df006aeeb9a0eee786c104fa0c82338841072d9fec90b0cfc0ed2328e53becf7f58b8b70d4f1b7fed2e740151ae58cbdd9063c885ae20a37c3bccb291186b6f5c17e1bb3939a61f8880f1bc39234155c73bd99426a8343a1dd7f6287b249c2a467ad6c13cabbdfc3147ca2ee146c0c2838fee7f00244adb6ea79267f0b5a47d843d0c3b3caa66b25ae7f4cfb0d0495f8e5d9feaba54838385c4ff3d177b6a2f59196ef3fd77ed08796f0121c42781e20d7cf4e73e52b6bf1631f7953f6f09510e70b8d189243d0a891835c62f128f7235ea97f6c75a4039e9f9b2f957655afed1b4f75cdc3876f796db8a8bc6dc48bcf6065c8ff4061dccd653b43112781660c96060456296d41209f4862c1b6c77f7704af43aeb81c0de5fac009efabec395d9586d4a5e604439f9b969bdb8c031d480810f1c4dc16d3a3942865c1d8a9b604c741297b263d5ece859cc508816f6dd030fcfead2b728c901ff27ac6fef56807a5199c532d3ba7ca56a7624a4ba67ff1a4174289b665d2bf10599b046b866a41731c33961eca76cea8e87514ca87f2705ce0d6be0d80a257cd09c8b10e0346a7d04789409b554311e83a5716990cfaa350d76f968017eef854d6853b1d6b7eaabb78169a674d435e1f9182a661c10b221dfae4e790a8c148c465cc112df1b408bc337209a2670ea9fcf0a00b306d7e3081fcb6cd4dce4896f5294e4a7300f3132e7a78b39df996e877fcec03f21598c1b747f6572d4edd594d4ac2d40101e5c0f3fd726f9385ef77ebbc47824826831e17e0ae64117f1b2dcc2a74ecd3f0ec939ffcc3dc243ba9b07df05ffd2ae8514ccc5e922750dfde4cb2da2b314b386d28d4519f5d47508db3dccce4eb20085eb992daf6e51290e8ecd87dc0cdf12b6a95dbe76326ab08e48cf657f3d2b3adc4bf428fbae1351a630e5a9d6e65fcc641a88334b6f1f24f67b08dd474624923d7612dc5ac33955adaffb668d8a3c4c8d08e337e04fef18bf44dfd03a77cbd29f8fe5c7f4335824562e07709f3a7cb457142cc6b0abf32893bf1a0680cb158f4c9df61fa7a4991eb8f51bdb0d1ebbf65c4c2910970040da403c0d85c8c5184fbb896254ae96b388d0d609912aee2a95911d50842a51cad0f392477d30090bc47a67b763a40e8e984d56dd1148b2066b1d223b7f9d0b4e6d65cfd207b1a09322569f249c13662a80fb704ca13536abc14915a7b2ba89354fafec48be747b108c9fa573af63e80c1b4416f335926f041a7ae30326ef1627eb99f05cb965e399ed78dae5836e3dfcf6fcd18c3f4c015825f39a5a17beccd5a667d3a433a29c027e160ddc816177907af899ddd2b48da85b533de17042c818aafcb7f3b7915c0365fc13effdae5a44a373b5e22e1e23d4e3ae4cd188eebe832ed299558448f6f6744a4994b9b4329f81484375f63f2379b336b82689d57f02d80436a40a375f4e6258ca11ae4d1176d7f30912a8bf47c67c2dbe7a24e0bef82fa6a9f542212f916b33ac7623ed12bb22bc23898809e54f5d48654422e8b0114defe6b9af1895167c6bde32a2e969a8fc4f5648039a310561eee0d8e20deb801430cdc402d7e215cd9f545e854024420c78c6ab471bda9ab792c41312d7eb3a0a51ddc72f434961a4f55f8a30aedd1ade21ed3683a13b73786aec7ceb522b516cda633c5400e2330159af976ec977b889547627b1bc36f55b04035468d89429e0c1536bb8054a646648a545ed224ca57bed834b919684f0e7dd4d10cdbb7f3c295361c3f49bfd3f863d6a86df7e0d7fbf9573034e50e03293c2758e5909c581417fe1f0cfae6a0518c55367954f5812b691603d5e32694c338e06da28252052e5abd2d0e1199156da39a7d775205efb2409748eb56e950e10e8309fc6f03881a0d6afcab748f6263fd136e8d83dd46eb241a8e20da2fa80f2908365cf65c8d7c61b30f86e783273f4b596acf741617c1ddb83ee55a48414f7a6e5a9282c4d5432a227ff7df795a6aa23944181cc31e296057928b491bcd944fb902dfe2b2055f8ea1089da0dc0397a32fe121e70d786addcc921c2031b2a502a897ea3f2e97c1e958bc25f2c37fe73974a6263726acec2c1acbbcb431ef3f054ce76a306cc84cb6c0aa13cedc55f44ffaef7aa61fd8c451c71f17289014afeb2c695eaaca5c87e8837ea18c7ea3828946aec100856074534cf86ed76bb2762f563add013e951f8ff72ecf1ce1e5b28bc88a5c38713d8e70ae40271912cbfc110288dcdd6a3d792712db2b9f9e7867e5696f5f9c9846b1300c65b86d4208356aa23f45f77e5df2093f955f513b1049c98405ca8fdfad323f6e9b01c652ad6816b0bc7e271d35a64c5f935b8df314908d49b92b32965b1f7be50e4ec46a0aafa14f1be47dcc2e733a675eb80b7ca84c48f937b6b6fa7848c98fa715a54fffe67a702dbc4efcc7b2f6f1bd6b5470088bc3a2ba4c50061b16a43459faafcf7df62cc64b889c56d2a5c3a7d5cfc65e61c10109877df0668c1967361e3026161387f454bd061e9c625b94630ab35a36546ea3084cf8322f7edb431caa11b132d763450932a6c42c6c9382a58ab05c4ef99c39b7047dc58616d83af2ca6db327e6d6426a05e7deb032c148423563a4b9e8a1325f770f1ac809d156a023a542dbb762f495d05a11bc6cdabecf4f985dece31e739b413c73f5b9bdf6b3964e90e120cfe1344e4c1e873f8906d1408944427c8cb5c76a52d98b78fbc0873cf5acd9b92e8c2e360b5694fb08d14d6801a2fcf52207f5c6ec36dc945cc3fbf164521da214c706ef1e95f31674a1a90067d89ac795aa604c1abc4f7f087a955baf32b447440f727ca1dc68247743ce1bbbe494b8e67553f7dbe99c3a283839b010b3360da017c54f08af5f09879ecbd2a9c55fbb0d0168d256448494b312e19482ab2bcf075660484f45214230192ceffb7bb10db49fa55a7b96814d000704d7bd6a5c63271ddb8b52ade05d352c76d40420ebe2441fdd86843a52a72b399f91ba92c83b3bd3ae8c935c547794cff0118cd138df936a5bfdce738e38b8aefc8d7abf2c919d7599b61c6710053aa0adc775db26979f5164ddb897d6d7612598ba2e96cc6ef9f1e85c068afe823c89f401e94c41ca804d677430f75d8b1c1959c322ad4707a0c968aef5be691f4b097a52d8a19329b5349f8a4c15450d0809ba0e4dfd53145fa622f080d8609693c52fcdba5531c6750983835bda7a526df9faaa9a603b372504d952dad23e9ce3cfbd3fa9b9db4013d41c8a421e0a41f98a1cb33014955be8811f2a8ee47761a82f5e25597d25e20f2a81b1cd78af66c0dd1d0a642b1b4b62efa0108d7c98452e664c8ed5c89db4b6ca77bc20fe1634a3e4db3c5fc37ceff970a770b1dd5bfe37a517202a27ac75dd6a568638e0af7ff2c696ad7f2cb075589ce5a0220e9ff9192a8679c603f84c4657d679f980407eea91139ccc8b8f8c2b47fdf7fbd9e61ded87a3c0d6a0141520f41b4973403bc690c2e619fa21b0f097abf1f23363b8d54c6a7da8e239ba85180ae9fdff0cb5957d0d45c36127a0e1f20347e86ff8c3e979426384cda1d7086e453678e15499be22013613f2383f7e1e2f702f1bf4f920f615a72d31a80eb149c412a1eeb783eeee51fffab1dd51d089b6bed8b3989068b18c1a89487b546ce26724fe5584c1a50950e56e50d8455f18909cddf148eed2465f1143be573129f7419756da5e4a359a8f9606c97a63f0f3fa342e11d4640baedb09a226d7586e11cf4b759339b20c5f6a725293e1a813794bfafcad3f409a1f5afc9be1a3062f6af387c30087e3f064cafd23174ff05a7d85f0354a86f045900b20f9fc2c29e19815e4b9d744973ac7c0010963130d9bb672ea0e4b0b99c8e0e36647ca11862cf6e2c761fe1ae62048dbaaccb92e3cda3450274d3244cca329eae204c8a4d44a653a2f01e1509b8bfb7677c3be4ab98dfb0cfd561120f0c8f59ebca915c47fbbd73c4750852890b86f7636deaf184a48a97f77fade59215059e8a83c8f3cf334d73031f940b8ed4a3a0c2e7b5de3838dadc2f9adc47eb7ce4c7c5761a0d6ac7898a610052eae1bfcfb8498e9c12ba0a52e2ae7d932a9459e86954464ebe95e156ba3d68002a3adcfba9a768aa48b6bdfd2c90ad4c808889629f08c4aa20c51af60c14ebbe0ccf910e877cbcc3c8220abcc35bc808d6e272f68177c219ccfc08485c4c47f6d69a2eadff961622776847293004d4650b6b14f0022911066cf418303ff47a5416af00741f452d8adbad7e4d1ea07a6d6783e08e5857a26a1084cad53ea50ddd49c85c1f418c1df91d245689d111d03b91cc5b399a24c1694b34c02f86f48eca070429a3cf14b8ddaa81b40e774b972968eeb7bea6ec147b2cde9da4068317d1960087d4ae1fe3dfe93a3e877c2c147f2de5d882e50454b34f41840ec8ec866d7ae0c48cd65a3d1f680c8f978d30efec8fcc1c0fc141f7e69db09ad05f7cdf8c3806efc5cd60832fdc1932a84adae6c26534d75cd68b3d386bc9b3416153561eb2be537cc6a5f56f9bb4bad5dab647f0ec3452e96f91833b8d245069a36bc400548cd54beb8fbad68712672b531884adce0145990363191695c1988e9e69c112401d00c0ae0fc116621a483a6f7625b164237a599633379ef3c8d01e2d3f139bb05fe91cca8b82166b75e3acca9cbbeac38b5a18cfba26015ca4fdc1302400588dc04e3320ea65fec8346d9b36caca7b4aa1140475cbdda675450ec5e54e0300978a0978d0ac39f23e2b3a31a3a1f6b4340af2053de03a214137a87abee6f13455c88993cbb33eee62ad7944fd65472f05de883f6c6ed1fb575cc90123a81b1f3a9c9fb6fd1e58ed47c802895eb25fb715d264621a48bfc0b70caaec7678a08b24813f5847987cff3c640c267d32de66a2a707a740e000baa6e36a4f8cc51eaec14cdc4a76bbce2a0c1dac2d75dd5337e4da2ca7593977e32bebc668ba688033a952b8d60614b69df763c1b1b2276c4e4a92de5db4d3324b4e805f12da381d8775cc9642a547ce373071199bff9c03bbc37d08d165d340a7d5bde786ae5e9b096f631a2f8e07614585180a5f2b8a767eac7e1bb588a94ed538bc87dfa7884c781b42892697095859213bab8186e3b400969fc6ca67226121a7ada3720feb0846a9ad2129674782c71c2e824d0e90343aaaab6113e90e0ab526771637439ca7e42796edbfe83c64ad16cffbd0cbef1ccfaa93c1d2ae15ecaf349a48ed5da117cc1ce6d6b8c7f89886d9984f862a1fa9b13464e4ee26cd4503f2179b0374fe707d686cb0af7387a2ff5ad051642e580ef655ec481256eb62ff2b3d8304acb2d7642e3ede7acf42e00706e48da894692922fe7b41466f6910b773636e7430808cd65f894e4a4af91369a80472f0f24560c39cd7581ca37ca2e5c7be02ddfad0b930172aa83627925add81450e80874647c1549737f5d9ceb086b4d2693ed8adddf241b88bb06a333ed2869e949d2fff916ee7cb5abf6b51271b6f699db4e33c94a96a5812d781a5f99e6656c49a34a071fab1ebf46d52cfc6564f65deb28bd7e57af4cdab7fd8ffadb30f67b2394f4e2bc01c17c1a9ebf313648d3b3d160c1a235208eea9ef8c89011e82ee141e135d6060e42d154198305a496938c3998f1d22a4c60efeeb230d5732f04ce54f2062bcfa551248f373324cf752d99e7013a16cf389d1fac14d2465bac2e5790b83efc91c8acb59b1c2f951c85c109d840a88aecace2c8fec73d8fb8324140c7166a14d601182bd0ceda1bd3c089a21f4c863ca8795d2395b263fb0223d499e6af3096fea7fddf8cf3b6e8f6570a06ce3c2c261681e622899f690ac707d6f96a70a492be8f1792eea9b03b04b5e19cfddc1e3c7b968cbebd2d14062f02e7e8de50bea6f2c197805c535e49cbd3f5656ec99dc489a2e17e78dd0ad8f4da1b62d95c92c768022dd0d310921deb1f993f4bf150618993ee3367149a83c7594a3ae0d113281819645dee747a7caf8cf06090bf74a6988cc3623e9a8de2a93da7f75d61186604a9f5b0789780d5a5036a9e5da48b13db63adbe09725d2f3da20d99bd5043dfdc6382ad952a6bea17241f74dc84bcb69d396c2e2005c47ede52a1eba2070a7476f7da3e0efc57d1ca0507a3f36f240486327bafff48a74eefbb4b6e6928a2a7c5ef51fe57e44601996e5ecca5f8e1895db66f2910e0c5cac1ab900faf5b7d7851bf14bf324a3b56fd97e9a86665c6dd6193856746689651cd017cb05d5db3685497d0f9ddc5fd426e7911a2ed07b5e02680c9a6a9a0d9bbfccad22dacf6716ecb7ef84a1ad5fd9b7924fbf64d898502ddc809161d97f52455d5ea237a801970457435fc7d24cec16e3d3ffcfb1e3c1bb79259ecd7809dc119f5417dc17277eff820d7191ca93bbf58eea6bde1a00a401b42f8f740e10531569a27f4f1e505b87d3a448467134503746e79503e504f1b192de2ce28756043d532f217f4cac0a3bf93e1a8e517335ba10f24c52108934adaf675570fbf7ed8a4ab5aa889c1405638f6217302219ee733dde02e0ea746243b9a569da401a62a4b477cce11b43a6a4bb02eba36c8cb5151492e4453458a0b08acf96684fc5a26b3d48371768789728162880cbc33a7bc846a9a23e50e509048db53c591ad22bf059314506fbeeff4eedd0b59812a0e1666a710e300c66081feaa61b0b6a7397b03ae502c9edff51494c2af5e00d10e6611551781c7423c6b773521da82362a1729f76f378ed07ea47982434bf7f2597363a74c5b7107aa4b8bcaa67bd7969f38efce0ae9fac14d04b0dcef1b3175fb35dcddad914e874af6a1c017510c30b8c628583a6ede26dc9b45449241fa2eb1bae34deabc35d15832f3e3e3b30ead8f84a68f290bd3a2be5100749ff8fd7491e16b1f6b28e91a180e88c37dc809b3603e9f6cbd83d2404ef5e6e9d455d163ae6350680b844e7752b5f4f7a47003c7925d47b583f7b7b40bac5bd73b2d1c1ffe948ca80a3574fc16e6dc1e49c7f002f76f677c42b464e1d5dce7afd0260a54ebd7e7152943bd6035341cd0de3097383fb6b0d828f41518db10066ae1ec76a9b504b6c75b947bf0196d31f340d7e12f1a30fb7365c31fcb119c4332e9ad42c7106d929d5b3c1279a47a9a0e2883637f89e43e6e4dd73d6b99f03a0afaa1c383420e0df8a7c7649139fec3e22fdb6d59d78044dcb0425bc9a7a5197599930a690bb447723042aa47ae2171741130184b6aeb3d0081dd62d02d9c10063a9909dd296f5787be4c5a5399ee98d53bb16707651611903bc2474136c0871c1c557e1d44d692cd40430cb52abf016d09ba5d7999acc5daac803155792c75b45a1ac28568d3560363ec6dd3b2328b882a04d98eaee857696006507b668fab1df71d00b39cc971f3ccf77cf65d20dc16b4a21dfd45f0a90e90a07fa4d6f266aeed5c9701e72c9a2778eb6f4a16305107163169edf5aa464eaa76e1c8f68b24b9dd4f7d0422e030e40048e49fe7ffd8bc10bdc808cb08f99d5569b6cfadb77330534427f3343bfc8df76a0fcff7d55c5b2cd6b422fae18e280909b112374f2cc3e27c1ec24f3a96c6604ba64c0281973d9034a6e2ee3badf8875c9ac95d886ff3ab6be5029f807780cc2564432596de40c1745a99c4142137c3af657d9546005d90b3abe76bdb9eaed3579df50825b332822e65a156327f700f310f2021b59721ce6c770584f517a4910f2e7bc9a02d368dfdd3dfec372bacf04a803648bf1d3a51c7c1c5d66a37a2e4e1215e308935558e258947f3eeefb15becfbb35eef95cc73d092d175744225098f3da4a64c9827b3f2488069a73a0294e7262ecf19dbcc4de524e11eb1220f9e32982b1553f0f410ea66eca7eb561d1b8c0ab5b360c61968def174e45238f2ade7e2af37a9e62f8c30fb35c17322426f491ae2e13a138d558381bdf1a217e310de5b86695e83f51c1b929f7c17e0384759a02b7eb9ec9af725b5129fbb1ca241c59e0821fbe2bb62bd504d828433c3a3f347224e7ac5e3c94c9bc492677fd405c4af25feb259ace3fffe2572867dd509fc074df6ae98d590f32ff60fc1b1f509aa99ca0a878e7f237e3c9b4658ecae6fdb4347ab049e55008d552d32c7982f8c3a03b0afdb1d614f8f3b7f468855d65ccce3ba9cc02d94327467847e58f7d7b3136a436db0c1ed916cf4680d383d959e22562e197e540c55e726cc97b40453cb318fb5828ccb2b41344abd05342d1ce3e8da0567db77b53ffa83c7403c200cd2b0ff758796d266f0f1bea1bf8cdf22df04b62a1e37166ef1e50159031dfe0e2cfa4b733be46ad91293916e0cc12ff0fc49a0d0907227015a3673565319a704973d150012f215d6ed989b2f3d4faa4ee5a850c1e084335ab05fd7ffe6f63d634a46f4033db6f0bc2fe5f712711d75bda5c5585d9de32a1d3f91de1acba3fa9b280d6d121e924d644a3bf21556294c6ad7e77995c0e8950639d87664911b2a434546dbb34773f8d82919d176cd462f6df5fdf9196b74ee7ec4377d4d5d1687335f20d35239da5b415108e83c355722bd13b1a4a2b7e7c5465adc40cc11f8ddff61d0e221e1b229fdb9e49e69e6f3be434e7dec3b6eb2f373399a13dd44e1f27c69eef66bd8cc78270f55d09cc21578fd24798769950ce0ec629216214a618b2ecdd08aba77619c4cc0bf9683696fc665297b40db76e1f779c11c41428f3ec7dd5a586619dc14ce2506602a1945251e058b88a737272746d651eb4be7082c3a7f57a2dba4a0381c006ddaf712020907c1945cddc93f304910c5a854169e364357f5c204565e16f2f26663b5e8e2b626d5bc16d800495b604e79c355ea365ea4fef75046bd8318f8b7a84488b0148b8066057f1ca101f0d2181bfe9189532b1d345d717965af5403f2342ef2fada410b5fd231bd48519891a7866fd75b1b3e503143b2fb34fd3cbf425e6f1b37f461464fc7fa0fe5ab3d7428419e99eab8fa53a30a9d51a27f435369b14e74d4a2587646c2a51801df7859d85c1a2dad28c481c3423621b63400db7707ddd8324fbf15591b520996dcdcc89a653745cb90021ba3ab120f930bc71997b898ec49090c5459a3aa67d35a08aef4a2602bba6e6dbb15ee63547ff6640fc5e7fcc7ca01bfe0516ac8537a9e871a9a51aae8e0c3b59f94c054e74f12a8b106506a3a47fb1845c5db29f189582beaa13cc36fe5cb1dd83ab08d2b071f6c7dd7ed942461045a3caabbb83476d9bd5c8d1c9bc18e25016ce8bf3a3c3d80d476ac8a94d2bd4f479cd945b995f35b6695b974a8122b476be998ec713def9a2fbf1e3dee630f4411c9adeb9b44ab5f8fab14949ae0082eeb25104508dc8cb175c9d82250bf8204324e1110cb5a384d4b080309999bbb1c061912b1a67d6a454e43fe87b8e843a0f66fc001df59d853386d7080d4fb2071e45fae42c848f710df167bfedb539aa135b1db0d5543c728afa32a761e069c351e98c9511f80d1554368f0367fd20005f6efab824d7735e61fdd3a481df65f9d2f77a6ff0a050bded057294f67ab84170ca0776d77b110f56412e9488ed1a4a6ed6620b27f9947438fc70e1db3731b115a59ba079fce83864f42c4e64908820837411d771ca4a54939501b2f9883f9978f7d7bc9c9595000d3748d4b93b7ca5cca006da1b64ea596c477eebfd4a1621062c6191cb9e8dbf8bbd89b946bdcd0cac33d9991b8a2c68eda29a03ea59cfd3ccb570987f8349db2efb5e659c211507640c31301651386bdef8e558ea4cf13c6718c4d0552f7199e53d188c7bcda9fd2094bf3d76c2d825573ca7bb2f4b02a223856bb0902aa67fdad33fcf4c96db7092a5f78a3b8e0c6f505e8e608b77a5e09bc7afcb4789901e2395e39a349850f3f24bb54fcdd9fd0cdbb99c8b29e32238bea1949ff5f4a130ab0d61507353bbb16adc3ae2e2991166e720049497cfdcabcd06158edf0f626325ac3c39fc287a9cf6b4cd5ae0045d414527e72ff43a8ff3cf58b92d4b67cc2700c9cafc6faec29379b671d840c0015f4bb622322d3235b9e8621ca82b066508327bcacd02f081694e48fa08847a94c821b65e8ec39f11d65dea8794ab6e08e41ce58a1fcaacb550ef16890748c8be0d7b777a16e4583a81dd156b23dfdd08cfd412ecf238e518c996c9ac4055182736cebfbc92136a97cd244777be906620aab2ddd829a0fbcf1a16adf923fe4adf763f8c7270ce2ce8e887e2560694122b9165d8c82ecec913a23f4ffd3c329eb0b970b90b78371245e923b9773be2664664b0ff50738ef0e944d94f2b76c1f2b7a91cc8b058d71a05e08216ba191b2b620ae8f29aeda4249922a956106627fb3a68145ffe0cf5df33f0c54dc17a6aef04d34ea0c53ee8fa7888de391adbb571cc58ac0522eb8a5b01a5b93fd380d2ffda160570edb6e72aa53d4690a2864f2650fbc294730ab993a205466ceae90a0e021202ae9ab8d1ee87472f695334fbfe1afc25185b15b51dfdaa173fc346182b254e304bf7a00158dc18bfdd3d4becdc1e52bf5aefc0987964de4dda7614e4e7e2de6e5fcb4c7c2bcd3c3b559c963df79b59c13f3f1e9901e862771fc0c223e2c5c3c9ad0bd300ed9bba06ce5c371cc147b3bbc940d195225b04b86129e86de6a84afc0ddcd49a0b278914c3cf7a969fc66e6b80c5790d189ae70d06c1055a32f15a5f843096d4f6afb4b10df6f3b308bdf6fa99d38cbdd46865e7be190951d68438aeaa85413ab865ced5921e85e1185bc734cc07d3a76779cccf9afaad478afa2d83bd3b1658314b8f37b61cebe6f55622e82e4f7c5039bb3469bbd714dc19866f930bf300b6b1893974e61c4a5844397a49b9978c59dd8325dfa30c530027df877184491d11fe71dc8c1fcca05aca62c755257c2184ccf6883f797083c6bfec7d3725ba8ebfe8caa875fa66aeb892d36dd0d92f9d0c1f7743c3299f88bb28b269e9e1524cc71fbc24f7bf3900cfdfb822f2a8d01162e60390384ab310679a857ded533a68d470187dde4ad751e216b1cee9ac7d77082899959b1b7901009855ee4632c60d94b56e8b1ccbb0f7af3284469094e00a7deb5e084f6823fa7f48e5aa44ddc56d815cbe821c4317826ddf1b02b20ea3bc71682b3d00f918b26d65b8a2dc8d9af6cc1f7a1aa53f3329d8dd27bcb4f9f84b3acc2a636638d48713c39440486af27a154ca8cbe4e7100a4253ee649556fbdd677ea38d60fd830f48820a574fd9ceb1237fdef6ac47f7be519fd846639c4f55ee71e97fc2b98ba1797e6ec68178a92268a09cc3a0a64d1846cf74adfc8de9b5765f5a20af0db71c8da843c4134fddd5231fb763a22f6e34dd7f20c2fbd399ab37655004cf03a6a888890fe4e62b386a675cc2a7b6e0de053541122f6469405d5ec6df6b041bb52f9976c3a1dfe56576ddd42593a73d8fe10201e1f1d9525076fa1a29d318d2cba8f4d0c4048d9786312c7350b6a2f5baf7a8d44804123049666c8720ea7bdcec149f4c22dd4a34eced6288a1286af9dad3ae103f421749c4bfcab7e36db39a732b1f7dee73f2e429d066a07fd8bd1c73ac6d7d69dd8fee1e981c5bcb2b73f97485ca083f3d4bac6ee40b5963be5ad7b46a15679597256d0d0f2cbbec5b2328839fd02eca440165a68308d29343a51c6d96881667b0531471b1bb7e824d9b69bf8c4c5ec5325d3f741585f20662f69753dbfd7b02f5c87781397cc934b98439054f550c25c0c71320d55b4af6ad62d09abce48624ef35fc2d72b5fd89b50144efd631c45e1e12b69110ab07a2e36a0d916e81b936d2800ecaf501e5d132efce6788af7f48cc977bb0b1c90d0ebb9484bd72651cd99f8d58c2657352d4a9b4af25c1598609ed3dcdad4dcc42a5d2e33ea962ff662c68401c6ba5d0f4bd1ee3284c8b1cdc61d16e6a0bfbf3888293900190d81e52de2df9792e118c65802f1a9e685a7a1677536ba747fe28d831f959dfebb2fcc262d466915731e561b436d7999fa796c32a223dc2c137dc3215ee8228e090931a7f7cbc0f3d3ab290b5a1802a8f12c99f68b270f6a78226a44ac55b8d42deff20edb7965522bb9b6538701f754231008b0f7dcc20eabb20df0b669b8be8684274159bee1de1613d073146428db3f6273436dded05b37c4e8e173558d397db2423452b425d1145956987f6ee78091afec190b5d462626d5c44c34f9157b3b223c01e7ef25b074850b562a8de79ab534ee79446ddb1b87e3975d619c9201e27284c94fa738fa211ec7e18e076b8f63f6b6a3a5cd3e19ceb4c8668718d6d690622f442c5bc15a846ea9edf9fbae035fb35e1b15d6090e94d18dd02a59a856cfa9648f1206af63d2b746949a37b9ddd65ec28a2aac223c719108c3e0aebb1cf7b22227a9198ffc30372b565f83f7628237e18ccc6cda08332a6701ec9c9e29bb02776845687246ab954d337240e4e17690c703e5dc2df1a154d131574db95de07149239a91e53e85ebc28b22e958debe40352c0f77faef7e752d4cf05e9449a59ad282a25acd39274096d768eecf42531069d98e29eb02999a0205762c3a13bbb01e76bc2121ddbb7fc2668e156d4581e73bc8be73b5a61edbf2cdd11a8b567c8827dd85d8b68dab6baa48bd374a4cab744dc3bf8aab0eaf5cb1febd0e604c14e79a54a410236481d365ee6f96d837d78e707073385f7a1855f5eb16e09ac8c140901c3ce4c9abd40ea33f13463c6e88036f1fbf22d07d14b322ebca60feda7bcdd46e84b3c12655a7f8b5676c6955bae1ce45e152fee9d2d3b369fdc7659e2dfbc0ed434bddbe06ce446b541685b45d0e85274d1ca2dcfcf344930ec60ba2c1c7fc365c9c6fcf5db65121ebc2f759000ff78325accda43d0673a3102b577c523b6f3bae94b64896e29d6818a3375caffd2484c44601cae4af2d686801bdc908248203047ccbd3a6441bc65c93ef5eeacb815c4a2cfa6a5bedf28c15f7c6cb736a6b7d1aed9d8b1fe38d7231f89e9bf01061aadf3a5d64eba2834c8df2c1ea3ac410a3cc93364b353b1c62b438ce1168a49ac947293484571b5608d097f9a9129bb5b3d0681ad38e23cbf0ce6374b39108fbb9c619172f31c4534635fc01b07778295b48907e3abae5f4a9b027e6408bee4400408b30e34b0aabe0b9c620694af1c88baeac7a166ee555a7fbffd85f08535c66cf4ac857b0842591c3a65db75fb37deb48e612e1d034cb060fa6b7f6ff0e018803589eed29a0724becbc442f28d79d09c045c0878979eefdfaa3e9d77dded67572dc44ef54ad7de5c181a4ae107671a8d722d76aa42922313e5e49b7dc12b0485442b44acdd1fc27182cfded7dbad718cd046af7ddf82656ab677e423527f184160c0d474428e450357847024a12eaa5ed40c83caf6f2be4851b61ea45a282763ab4d9a895dff76ed31c5b855fbbd3c8d2192ab279401c37d818a629a818a2f2ecafedda020ebb6ae6c22d352bdaf1338296cd5960dabe6556e840d26850cd416b59fccef188f98d078195fbb3e7b35a928c91206f6d535a3b9b700e09a8b1784ef0c01c1dd1f05f674038d435b4a2a97bb6a9d8b19c9605c04f6c7f1b26b04789d6be397634e9b8c15c2942396ffedf6234e7fd4e86563ad7f208dd12a28eacd21178f217b9392b64ad231c025c94a568ec978b4719f0d3e32ec7a6453b1a1dc1482619a7fa4e622da5015a302c7e0abf1830810af06753fc8f193e54f547d9ae26a01042dd10e84f4c10fd80540ed22fb379afa5b197d68f4bf1471410d9e5c1152c7c08a4885cb504197597a85ba8eab16c5cefd68ded6b98101fdea9f7dff82e45d7f7b498b41f06ff329f3ef6e9bed38c2598b211c6a6aedb0973e719de5d686890a45143d25e37969b932b307c54b9819bffccfc26ea1d263a7276b71161f31b6f8e8d3dc17e62e94391c426b0fc4b68b63e1c2ca3218e3097396f730fc29503a9aa51953de7f59f5708eaa073e6c2bc4c6d8dc64d08bb51800541c467b534d287dee264a001a400407f17e5d42173402f7bb606f238ef448af21e804cb8d8b6154e272f03a27e72216fb54364509265b2704c148b75c42499b766fc1ba0d6e59dd04fa147c0172d622a67d200abe3bb496305a4636d6c752959a1989cb3726ad9d47ac6fab0a88211cbcb27ebb2354ebcc8ddbbfbdfd95a89acc935ef2b6c99ac6aa966fed4a1413d6d8a7097b482e1fd7c0d8fe703b3b347c9fd04e983176f3827bdb009e50f464af2d1662624bf0778919236078639837ab00b5667cbe54f2a65736766a5d1a32e2f4224a27ccbabfadc3e9d610d6733fd4b4721ad8babd3142c63aa5fd8685047fc470b0693550edf78aef0df157ba87c412d69ff3145dc6d61f34d3f34710340deb204474a2446ed805cc0ff10d94d0551fffd3e011b33418302727a7a1ef27598fff560020e1b39a546ba52cb62ff8c8c6369771defc3bf0cdb079798ea4bdf12775fa8f28f28c614bff70d6e86e236695794449699624c5133f75a0cb06c2fa1db9187d565ae6b03479c561beebff583b03ba7e54a4accb5caed0e25e963bb03643fe32f6ea41e6a3a2c519fc45c925bfee85ac0189eff2d6ebf479560b97c83f075f2221f92222709e838a04f158e2249cc13e0a9a9fc3debb746e0464a1fd924666b97ca88b10a923e0575c0162ef1831979d8f75df994d29f2a112a9a1d5fe27f0866b829d43b94388209edb6848713db06aed3a34755e4c45c7cf278d12043c2d356332cb69aaad96fad419356fe54f217a94c2fe43bbbb6d69f5afc709607a0ac53bf1f0ba731f98fc8ceb753060886edb0fcd6c0a3f7803c11dd4bbd276ebb7405fffea24a76a3539a7b3b771066f04371af9eead885186f4ec202f0121e049ceda33c4c3fafa7eb6345df70400aedbaadeb7cc469bf5dac5ef153b01338dbc0e2d642d3792ddd34585936483864bbb57b188a72b8c1559249731db05fef44500edd1ef1027c00f0909e40909b80c82c59ddf5d199f7b08af0e6d2ce2d4a81127690cd1052e82c6a8b4fd841e9b6ccf5018388ce1abffe202275cc18aa55ccd37428e94fb89cbf59e392df6e0210c4529ae9586276a9649d5e202eae9730678dec104e4b94c7207c15363b8587ccf550623eadddcbaa55627c0527a5f147d3cbae80bcc73718a6c67bceb556fd6910cad59b963ec10998bed3d7fd88bbe042151a961ffab8d3386feaa149a00b4bc3fc9f79d5a4fcb68d957884a8215787abd97634399e749f0ec684f006d3e9cb34240d5d4b5ca79ca494cdaacbd8b22c56a130e10c2ba125826324eded1a12e52bf2e36863977edce182fac2d1c246b5ab889eda943ec4d9c1417b2b6ca43e40b6fb074e1e9d2cabc3fc5861b81fc6f638f32f7484548502efa2b9a8e8ed85f98cab4caaea3edc097e07d07ff306b28013167a71b56d09bb1a2c98a2995e7702f7fdf465ce8530f2603bd4fb5d64d110225d9e1cfe4b3617cdba5ff459af6d61a8bd6efe44c7e444fe8db09451d97a69daae0dda9266f0b00a76315499d67d6fadc1526d2de060e5be265dd3512bd2507468d04240b2ebdf820f707918b2b39c40fcfd94a0dfe02031c526a580e6c3d89ea4ee48c8c6e1aca3ef446131dd06b77b9b796a6160d3fadae8cd00cd6f25733014b5fd7425d2b31d41c70df12b7ae2012ff7c7241d551faa5b72cd8bfbf8bc073c80bd73420ee470552805a062a05007da71a70c16307b47fbddd45fd1caf7112d43705d02e1bbde1f413dea3a303cfa28ebcd9c8c1f9d380acd8e1c1003bf492585ae5204ffd680f1937a17ce6759d7e398e14828ea0a53c7f8e836784bf451b24f1394a6e2db02f7ee492664c5b639f7b331cb9f19f09de1c8f0486218d0350e914054436a8feeea52ebce7f823faf02c6cf3fd529baac269ee30d3be6e066adbf207dfedd6940d2ee282361f236ca7ce74012b87acd5e8acf5e67d16ccb36f737ddea9708eab709992dff3e33a0b4008bd561f6ab7dec2122c9ebd3a06181c57c53232e8f428b9e169def613a474f59b2433482f98a72228a6c97dd05d898467f95edf91406bb420f230808558303f5756c48b85b6383d370de5da00651766cf4cb9ab83f0710f3cd0d7e930125ff39d453bd2c3d46acda9209382a74b999c4571c621b361cd2dc02243899ff081043af1e3191a7a34c611b8c2eaf9bd61fa64aace76b2ed8c1a7ca7f236ba47243c7b7ab0998c1ff691cfd802faf61d89dc09d66d904e6834a9492e2c93c6d330ed750e070e51777d1b1796bb15e683dafc401d3496fdd77c04b4b3d192a3051380235b7ee16d8dbeedb34c4bd81a541f63ee3222b1fe1b4abf2b4744fb21fd54c415b27195f1b302c334dcf3181d0c49f71a1b768d20bd0364365b7351b7d4a1916b0bfe3e859626327ad286b9856fd43254eef93e6a7e1e336be07609bfec9279cab1a0abd4c28a1413960af4f71608a1b3389ca7ff44689c9fd1dcb51b28df8802fbd2e99286020b36317c9a1378feb2f7a67354ac020d8cb67a732d3005598744ef44ac53a86f22b68aa284f2f507525cca6dafe67bd791fb2c0d4b4bf2d6d33670174252ef053e8eae572adc05a6cf66d9f941ab86594d221319640ef02075f00dc1fdba3d79bb57c4464824e391fa1295b0569f36e97c574071494940cd19d21d1261f9002307cd77f3c1de5a9b92669051b6db5ebce9fa10ca969dc1741ba1d60f8363e8090fffa5748b124d0cae0977c3f2629cc507055e901b7362e4ff12954ce64b17ce4c031bbc863744a87c0216ab3545ac49d7cd988df496ad766bc74c918b4936c767db2b8e62d3001e9b26d4d61a4d1938ce362475ae5d4b91848629d609f804ca436bc3875a3131cc3377623eb33f420ccd5899466bd74666dcbbaf9e7c64c256cfbac1c71461e8d76c9de93ccec8d55fdcf19f009de4073dc9f8fc8e676bae8de85d0c3ac7389158abf6359f8ccf68a5450d93f4b250b9ebc3a4fb4f1e667ff56b70790e0077017c6e6215010d69b9aca7f354fc02772fc580d01e2cf14a55abe453353525b33dfa724a9d7a4975f92f24cb78317dcd0318f4655312412470088a9461090fad271abb22b6a064c395e4539066553e898268a2b0cdc0966e7a58b3c8dfbceecff027e8cfd447bc5d051baa167cee4207dcb580a9c23f4e8c9883fbd91d839316814ba183145a7492bd5b1d3e027746af56507d6e87c917efd5ea6993f5cf5613c459e818133c44247f549ff31c0951794210d255b76597b66e50f99366cacc607a861297995e5189dab77c6d0f1df0d2ee999c414ad75c7994af1d2ee840a182b8d6ce511049ccb0b950532b3c34ba12d302f54430692f320794665766bb5e59cae781dd5f22e52f2215e03bb4eda90efc7cafc121536e7f91ac8b719680362bc13ec508ad424e1d26e25967d097b41acc8003dc4f0f76b527bc9e5bccb73b5346fbc34ac9617cee30581906ae29d9b8015d5904a2c03ad25ce06f3c7fbddc2dbc181d4d4b9d2dfd08b2e6999539c422612218f2c619016c3cc967aeef894973504008ee576df997526ec5d57415607c03d4ddb7af40b83c09461f142670874e1082c3d9a4b4642113224900860a73e153a8bc0d301656a7082ccf9bf5392e506de83a6c4137a2d98db4e14da52f77602e5012ac9ace137f0a9c0ed10c3d362c2f443544c7a845b635fd4a5974444d1b5169c43a87ecdb2d43370e02309feea7e66be13784e931efb6ab43c51156dd92cae9824fdb90587ae194614d53b2212630a52b63921808e97b1a6a047ff36f2a8ae937baf381ac1c899a434de504983904d9e1aee2724c6913ce97a891609cc40de05623e6d9e28af3ca7818361c403bb2bfab6be5e7e91344061e32833d9ec84465d1ca4d89cd6694bdf2ac68058fd6428d3b7c068e52408d9f3fa46a95c1d0af6d3b56c3e2f1e01cba64aae8","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
