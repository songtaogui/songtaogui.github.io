<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"987ceb562b4c7e15ee96d6dfe65cf8edeef73931f45f531b66b20c48c3621d84141566f8a6b08b7ed8724ec09ec6e7e5709263130a9a47d3a8757edc4d5a0de526852d8623e0e3cbed5e7a240314a37c9addf47288961b6e326cb0014dc19b43f244c22cafc0a9f88d66f445f64bd5620ae0d3636f3860be2cfd1d06bb55909c591c41d2dea35ecf5bfa8ee10116b6a571873433277849fb0760025c2c64b9d74d21bf0c373508ae710d7eeef197151ba5d38e30bf4cb47fc07dfab447b5d4af4489cb10acded2165fe3a7da42d68c1d98b8b8e7411c906499a1012e1272d0d03b4a5fe0397bbd97f824b7e2413346eeb57933f219b2ba57cf49dec2376756a21faf13477626d75b078139040496e66b1770df9e5b61e8a8b91b372f10fdc38bd2ebcb833a930c63df3b0d6431e9bd40d60166348987a346dd3d35066f90cfda0b0e966488e946311ee1edde4ca6439f4c8f875037d8d303b19b09ee5e98fec88b619a228205e3e237af7b97bbcfba4f06b875d563cfc9fea3b2c59c25e95d65f317ce3ee58c1a74b9a776d01ad23d2ee005e4b3746c755ff36b50cede2daa319b9f7c1b88388d36d57c05025ca55304b44c3bcfa6a65579745e966af036b107fb252075ff203bcb6169029319c30dba20d57e426334c2e6af42ffe9260c859c338ebea5395b4111be3cdb08c565b4c91062e625a2f16ea89b39da083fc4f4633d192ec99560b9e0ce1eda9b16344b5ee2097d386924fd5f501881bf502d17b043997b0eb4449a1473960ac9d0478ad87c249c588ec20221d10a697f1458255236fed3defc28c94b1987a0776335d201ae3e18f335deb862f07a16391ad57e4d3dc05b1878f5b9f069bf8149e8fe4a0f778d0a0d1121f6a3b087155103706215cd77af526b529471df51dc6f68544f63d56bdda0682d8cd1653d14f1485ada94406ccc5ee34acb554529d29854420d1b531a989a00f0fcc95439b746bc345f9668846b456ae4948e3a4cf17abf0eb2f602f0dee827cd865717de53c9bc346ea2feba859b2487db8b899a3acb59f2bcf75184c7e2f9426ae631b5de2ffbeda42255be9a5d1a8e846fd1be1f6d8dbcfda9623a96df8b246a1c1ffae3d52d23787caadbe1da852d66785ee0d36ad1c8ca60fde93845590af76ea6878e78404363ebbf909a819b2aa55957045f0c5b546e5d35277be9454803bcc4f505b712c7b05e3ed6d84b9b89450dedd7add7c1c4ac55faa6fcfa4b28f664b6ab3bd07cbe1f9f1a855fcf6574bce46eecc71d695633f8af9f2e72828bdf3745b6516e27a40823d73f5295cdf90e79132bfd78562c787e53e99683557492f9894ffa73ce4c530835521aba57bcf3e1179a1565b9e9e50886c94674527d708739d16b068b99467d97cc97e9d44fa5e32d690529fa82c9634dde0655dbacd52802dbf50014d53b8d0c20b9481ece5b59cb7a59bc96a58b7f3a3971ab2f9de2ae73d71dab88762de62643ec9e88cd5cf6b1b974091829bbaf68f23225774579b87ed9248bebe541eb7995a1b3628372b6c1d90e54d573d39221c4ac048a9372ab8e921ccb7751509c0e24962341a5c0760ef5039001710b9820b6db810361455f0c2a27c6cb28d530e4a6e9c478bccf083b30b81bb621d8094102fd936cae347434e8fe6fa606bb753fb103bf17aa2aa3666fc631c8dd58af747f4491bf965d4e92f0063022069d0b5ca8f9e89016114e0091bc591af0259fbc15f4dd77dcbd0e1f2618cf9109159795b8bfea24e8d7ceaaa757a330e8189147a0c053d75d669070eb48753f20642501be4c431cd68536243bcd19d29c20498e791c426ee7bc747e850df345194c4a516ba394e2248cb23f4a5e4c1b168294162b5f86491db9ad7d627cbf0add291306c73ad9c8d23860003cab149d8c1bbe4e801fa2caab23df9b834fa424c183664c4b4dd8180d91205dc0899337da1f8567c5b1f8fc372b9885653165afc19a4e0fcd5519f5543f81b3f8d5e8f269ae7591eef5631c0eae357749fd3415fafb30ec394405ca95dc5c114b98844c0681e67d4def89ccc2a13891d9a7e5c5a7ce96d2a2ed22c4e12e889df915f3f9fa1512b4a10b721e49bdd56ff802a8aba66551d4ba75d5859db5358e4b3b17e0c0a4ab34238f8bcbaa2f0e8db8f7d48320eb2e5af2c0c323cac896a7c19ec3c3517e1f976bbae780b75c48d565c2ee58b4016b58f595537e71a6ef15c081d14f57598426055adf3515efd60af0fb215a90ca4993c218fed7da42256f8a7da56a9402714bc66826249512c15436a649282b54e51acfd1840a683825fcf5cf78a367c6f2df09f2d712eace929c04fd1f72614957168df9f1f6fe2bee13acb8140877c516b85b575d5a99636b2e8d03921a7d7c5d910376765c9eb18c659d670416741fc8cf5a4541dd81e9a25c5e34194d8df6f82da4b2e2a8c5ae406047109807a2ef24ff85112f0062adf8fa4c1c9f99b91c0339e16cdad5a2db9bb93f5064954c5906543a432c9a8d26914f562e99e5f268a105ffdd88fd2cc76bb1e0779683787a4a7ca24d80bc17ace5526f028bab5c78081d9fe92ce1511332780a928d5f3cc1776b667c9e09db49ecafeea8c711266f35fb5eebb3e4385a729b0740bc001643e4dc978ea2e8d7d9fd955e9bf8dc12de675ddd10c8d04c80b2c5e534fd40733f10f0b99bce39833538183bcad75e8f457b86bfd1e5687a784c8b024293dda056d176db3b9d1ab1db2b089ace62129793261eae08f2acc75074e62dea17e3d16951f615fff0c266f4967cfea346bf27e33794d81b4f810adad558be69444c6178ed0f42431a18a9d80e6112a134bc901a6128bef526bd783b5aacbc18471bc1696c934106936db08dc5d46928f72c0f2b2ee7a5a58e486c3136f0dc93d6489605461096fc0e2883fe2750f725b114b77467e3f17f10d58663f1615c54f0b3808d07973da9724be28ffe2dc07cff965d0a85dc5ea76b4adfe786533e16a5fd09154c029de5dd732cc74cfb375b4164daefbff33fc827ab4fe1e38302e2a7dfb1057ab2e4d9ff35fe9c7277b257a714488f6967cf59c98476003955378d4ff5cabf3757f2c829fb68bf50d54393e34d2937d847e9e27385f02d0f8a65754f3636742ea734f941390f7eb9a157de76b8e43f36d5f830d2059671054b5ea81d3264f98913806bd458e5215f40bedcf22fbade0d0f9f8f0c7fc1ee76d9ee7b0488152fa07bc4d5e80b0a4c341f631fc2da2bea7ce7ada697ce702939fc3bb737613c683970329a61308b63513eadc73600ae8bd0d18b1c87a97f94deb1e22c2870b2d6e502546c669a0f4529a5e4f8d1c4db4619eeb017d5e0f1a230d713c24e6fe24f8a0e08ae4421c0b494994c63da5623a5cc6538be69cf9b367e30421ce1e68923ac7bfe0e95834c3dcc89be9330f157b5e39224d485f8b052402f849446e89096a87515534f250aad34067eb92b891a0048a664c6710338ee1125ad0103dade6b22c38aa86573b22a1542e69e98a86212485d4493271c50dd5bec90c8ecceee3879642cd77a08ff938a0293aed0106221804f85e326d1c9ad62d418fc0f39ec6e546eb115bbc1dd44bf878dc1460077e288a1f48f76a3d25332db14dc11caeebfc539de021114bc06e4f662c52ad9aebbe177322f58ffb139978012061f179a3cfc82435b63d0756d22a5749909919a97b0cd6db815c238bcd587333f0db68202aaa8007a797b78caf46c2cf92522c13bd14f3910ee02eed53c03731466a5e88cc92e89117e21272b0d1429799969ff88e89683895437eccb7f1a77e68ea510121d1e69ec90cd8ac8f713e74e57bd73d751023d97bcff0b9459b7e17301a20bef39ceb8c2014e29503803925a61d2c019d96de1314bc01daff43ec01bddf55c42178b2f3d6aeac01607cb1dfeb8cf551e397ed7a42cd70c4aad868495649f6cbafaf893a2bd1305bec2fd2997516c3a58302e40f43711b15c8ab9a5b4f7c0e3743e57061b279c894cad653ca12cf73f8d8c28785ad474f4d4bf0d1bc96d3494444a02868d700e9610d187839ef5fb9a9f21e47b7d38d21296c466e89935880ef97030faeff89cd0981ccb28938ada92bae8d26f09653d1fddfac4406d9b04e3feba4bd7be8f5282096fb412c01192b206f208eebffec9f85521ab8c6b64fc43e8fdd48f64682910a70f975f12e92127b930795564c7c2de4b9f2e46deea8936352f3d528393dd787bffe1c3db4020755b07e85bb8bc0b992a5f7e1c7e7b5825412236eda26b7ae0db13443e966848a0ab547858c3f7a62fbd940cf5c81a5616c219d4eb847ace19d51793365dfb92b0a23b60149812cd78985469dc1e07e8f8e8b48a1b748dd2d4852798569428126773e8394161a0e2f08bda79f4db6f93054cc10b8953febc7f19e5cc14c382330b9142442c1dcb589bc2d4fcdb513a275ea1381ca929486d4f7e0b6aef426d164f72a5c2045315ca0bf00b03405eba40ad00ac4ad90e88d3b7d39cec0ae1d34ec4d3047326cadd52f35bb9fd82dfd46603980c21991bbf932b6205b49011500c642f8ae25a426d38177034b67a5ea26111eaada6eb9c7f6fbc29be36fcb7fd170af404e07616eaa36dd48cfc7134b99d84d651235f86c444420ec5dcdc8faa37b0b72d517c3a871c5180501627d84d52cb8bab686ddb1dba9c586b696f1159e2b62bd434a3c53b24f136bcf754911458cf97cf336beb0be78da80a29c9839e4d3b29cb540c3057b011ce6f18928d5154748ef1c6d0da9794b7673f09c381fd009ca09b3137969f0133f13291c3dacf202251503a109c59c64a0e9ccaf667f667565580d108d16d835f4c675b85cda5e2c7708c90e444d454dbdcd61b5543d218fa9d820249f7c14312bf2a8b808dab3514e474637b6afbdd5b9347be62fc621f1cdaef4d1924e7623544e01c840e0447d1d17793ad327698ba1d1b5264e8057dec9eec98ee040b93f169683fd6d21a5aad131be33da7d952a13a816273467e2a636b92c86ab643a85379c855a227c4dcfa1bdf31494be734458cb6b6361d4fb8c138875ba76b6931979fb3f02e8ff53dce3101fdac104813dceb2a725250b6286b922c5ab7e0569e835c007380ada62eaeafd54bf7cc001260d153fc55c00c8095971b24e17057035755745f4614a36f9408294f2111c88d980f1b374484ac36bde8bf81950ee7185e307005cb837bd2b73840f81f5c47eddc847b839f72f6e5c460a3c8032b825340f6d1eb11cff6510d8b1e1619656d70a5d676fa1ef75dd8792de9a69a93b68f4c5fdce57a135308e7789f72078cf5fa4552ff16be283c3217762dc3b0a73761b44fcac852ca95cbc5efea368699b2a97d1a45a424ea1cc4b3bf3590d21fa331173f00913d6b82a50913c6f41e3a08efc3f90635f2bfd437b745da963a74ea387fde28a598d6ca2d1dff0c79b9f29e94548e2be7b7dca1ddf7971441e6a72a2806de0ceb74c124d0d1ceafe1c7accf65a46ad6128b7ab8caea072a46910f5d92b82a01afa53c836897f115930b63176647d35f15907ac19fb3696af805066946afe43120edd680648d90570b39bd60a175b2771327f89967fb303a159c29a7b312a443b5639448a8442702072557464ca372dbf77f7f9cb7ed43f06375fd8f4a22378af3a4e7c2d4ba7e5663b8d894c89f5050e62a47ec5d3f8e0d9019cafff6a17b7ab709abdee9036c629b8dda909ecd115bc5964bd6af4093ebe164db844649c146b34929922e1fa9e63069871f17816c8ab9a66e1d9c2700bfc1ea4576b52d7999d3230d6fdbaf72ce6f4ee7081e7551fe2106c48505c728ede0d7a8566f3e5a7eb4c21444da91ac602d1d1863d3806fab6434d06da091a055a27c4c6f8bf9ea16c64666cfde9d57411269f2b21ba12db92d39702c0f19fa1bf71a4ce2df5aa33ce8d3907f45320ece8b18b19f09fa842871af44b09111c0112c1b0618109345d0d94c07221cc6491b31f4ee27359d2c930656cd3b66eef3d4b54537e2c58b1b9cdd912e228eaf2ca53bf86fa721711b056101c40c810744d9807496e3f84e21dc269c9462dec357c306bbbf98a5f140d27c13581b8231434501e3b4dc02df42fe0e6b2a369ef7d703decb2690edaec3b32be2c9303ef3ba9958404f0fa0dc7a1f82f14666f4935274160d7d343465fcebf903ec45d02d38111e7063f69d5d3406445dfe538ec0703361320490f9e2d6d2d9e43df6c8021a9f8a9111ec0301f1f6fa91c4281622102e52b054f80fd5e4c4779acb61a1fea906cc2f59c05eff80402351290befca08e9bfb61ebd267813c6f622ee1fcfd52a7ed4d77062e0adf44e682b26b6940947dfc0be619725bf1418096e700d2c200c0ddcdb2d21be06f5460f38f72a265ecf2aeb8fcfa915ba66c7b52003a20c54d06a6091413369cc29b2e26ab100a08c6b004345588b7c73f1dbe3a6844353d9992eb8acd23ff292860924f4b44b7d9cfd716c638e0bde4f28fe7366b7b796dddc4ccaf40ee9a731fdece7fad57c619a12466984b6908450c128983c9a87bd14d279942d2254a5064424b1e0725dd269ab02771b7e7e4c434e209fcbc5349ff0bff6d953be61f51e6ecbeb4b0bc74c0e31a110367082a4d394a375a2dc3b37ab094361a91f423e0c887c9ba83ad1670c2545bfc13f790271aa9f964eaaa33b628ef8ea6f18a656a3d46ff9b61c904e417e7ddc32b1c3e025773a92a26d388757c371ce6eb8c24d1a1945831540a82bcc837394f6cbb57f9a4fa3e6544c693335decad3fac6037fd865f578ae7bfcb52e71866d98c25dc9a456efaf99ab5397635a90e231c7b1f747b9c0560f8860bb51273630a9b8cf68f88704f7a215bc269b6f45aaf424b45e58a86ff1f3bb35c9d0c5cb97e50af11b2bcf2e3abb96e536c3ca61b9799a9798776ed0666caac3dbcffb1669e95c51cbe5d07fbca5ca71cb87c10304476487f9d74f6b0b7bfd80ddbd77f2262877686ff7750f0730e6d1ee03a06072eee533e1878a43b6fea99531c76d95abe0272c28b5eb1cf561e306d429fa11c3f6c0fab87164c70d69790a4b3135e028beaf80a61fd57311b28d9c45ed693f85ef8b17dc394866daf2c916de7501e423a6a6efbd745f1005d05c33647071362bd2131ddb17d8ece19be103d98d495fe58ad10aae70cbf1545c1ac9b1fec000bc1130501d2da789e46dd22d810cddb0b11c9b1bf75019b5f35b5cf845862fb607b85ef25ff4cb7e4d450ec94f27d862e06988003179f09ee18ef8e31b2cac547395a152e334e0e3e2aeedcc3a60c306dcefa8e398e0d7b8e89aee5fbc256f55eec900b602d02c97a6098f4c5786f9db2d5169dad74d2c48e046a5fd79f7518fee8bb66f0a53e09ad7933b246866508f6ad9e1aaa7578c39b59fa05c60c4c1442f259248997ed6ceb57590b9f6c4904da69b89963c10942b495f4636c454ffd0c400fa2e54f24d24181ffa342963ff6713628289f02d3719f0b3562e470c6e35ee2e48c1f64a745e1402a0c0e42aa3c50eeb8a18ff55704b1550807d2ec60c4f75dbe172b210960ab26a200655baf3115986408b2a57fa6653d894d2a080f7ac516cfe582d5ac59a78a866e14468499e6c048d8fb238a2c782bb969a8e3ca2897200d103a971921779da1d20c452558450e18cf06ea331da3c02b7fbf749c13d37d554cd0f4175a6e095aea330fe07e4e51b8c8762f6d464cde601dd1f4ef3a16929a39b2977e019133b3cc3812add7f9c07bac665102f947efaa56383ce19e02cdbe65673f7c5fd152c6b496e77810c595bf12b307efe6b8a993330802e76f6f98fa583383d57282f6b8940f1b6614756e7f1cfc4852ad4b347f11c338b197bc6381f6d3e59d86f4598a042c804bb23b927eb15349ab3f09b4a3661849eb6a6480e1b39cb4230b98634123a0be3e6855644430b3349ff1ce8f887a5b916df5538b1e4595f8fa74a7232244e37325d38030a57233c90158b5a5ba517791c1db8d1567e01ba77a6b2df89a0e92b115a07379727a8f5470ec83b5667a0e1775dc254240f43f8c5e7513bc560c2fadbbeb99f3cdf1f611fc9584245dd4f1817711d1bcbaff3081fe6b4c1f4cbe62c1244d1c184c20447d1f6da9ef87a071bbd2cdf217ba3f5e827e6da3821cfabef5aab73db7793babeedfe23b53413390eb292f3da249f8a66a4548f5dfddfa4b54825137186480ef7902c5478612fb170af1e35a21cd07bce24bc4d4fed7c131f739a5fbed4e641d3b796e140246ba9e613ea901942607fc72cada586b6c3ddcec96066e15fc32e66d0843b5c8ba79e91e9c2d159283124f38aa610ee693a510c247f02123528fd4207685e693f5ccfceb0a7ce50c46a6c69f1884cb3dc8bddd3793adb0f3690b27ea7d4ba60d28e7e67f140dc458358dea42b513fac1ff50515495652855c7f16728782862ea0ad8932fc98872978d34836fd28113616a31b36b262a6b16ab88070ef82c53061c116eb92e95a6a2dd39bbd67290ebbc0aae5a06e6050ba757c0e77248fcfcaa34da517a45f25fd1c2db450f6ed5ee01b0d9ff5ff1569c79c29514b2fbeb5fdb468513df44542c37f6f43ff410ee7384a9aa89f2b4a9bb86d870d60031e97bdcea139b360862dca687eefe1cb7d64fa38c7669169cf7a1b2f61d9eaf80a1af9a2d64288199d32aabb3fe2624a318b1db37fa622d25de6a8c9e31ae527a43fe345f7582ac61804e155d095881426285a83409790a02fab0001f72a4e6446e1601861341c8c746debcbe98b16b8c8d253416a3ee114a6cc9a9b6a8e91d6e218effd6ef0ba77e0f516c488b607daf50d7d59850bb6204b1c5e146212c25a0f8d2c7762d448970c3e34c36f7db0a6728bd490d8417d774fb976188ca14a987a4e597acf7fdd7c832e8088b92d632d6711acb1064f10bdeeb41e24f046e1c355baa8a6edeb94506c2d6b55d2a3247f3404a5b502138666a67c80f65d41d39581bc20386c1d897342ce4e66c468286d9c47c926f9c7c288d6e0e7ba7dfb9e33f44ad5cf5ec7895d912650ea09e9b6bf9927220c0eb0fe7ac0cc3f3584de9ec4a488efdff1a7b29bae2c0b0037a97cb657de8a726311c8d78d8061601c623ced3b041582be62ff3ad59be8996762092228f4f8a3ddc31a3ccb0e44e92f59dd7f5da7937e7fbed85668c74300aa7031e5dc9c07fd35abc38dfb2d1252267321f55bbf6bed3d7ba42686b04204b244e633fc288c2f96263c11b4fc0fb7b37e463b22e8acb5ce776c4fa8544ebbe1e6f624643ab55378e62869add6689a22b1b1ddca9fea94674c7a63eaa945310d98343925b51a87ac71cbf22897a9be7d20b8215ed5fdaa782ddce327bacaf1976dc194587292abaf4a2b96b0b3d84778b22c0aaf80ce8b766b86123d9bce9d657b0afcc11b1f38a0b2f55d5fdd0d0307718ec4544ce75fae5b0e26948a613c09e654cffa2d49b8b4347068b00312b187cfb80133e3b174e00b75937d76ce1737e0b68fef4a473ee4ab7a44a50cdbb519b58c01f6829c3765c27de9c6d88dba20e36fc2a61a6dcc294eaecc9e427f17107ef9702c682b71c26c42805a2eaa166aea9335efe295752b3d08a3c64dd03d2e52f5af01e6153eda4dd22414f16a2ed0546f40413e2dc7b6bccf133a2be04ed349f065bfeb5d1067ce5c7de44fb6f14022ff2a2297702462ad1ba009c7d22009376dded7642b33abf3e1a364502beeb38d2bfc7f3b8ca8cc0e5bae021331b75167ad47afd4026b73e86a530e32f7fe17798eed325a31f89ea61797da56f99ea62c3235217414ba39227c177325669508350c968144ed80c834bf9477fb360feffa4f9182c727e962e44040243777202b8712143ee474496053c6d2138e6c2eb673a9dbe3e1f06fa0d9ea7acce41b2b48c8e332b789500af1127fcd362c08593bbc423ebe80dae458b82b25e2cb9767658dce6e52439abc9ae41234e57b48bbae8e51b68dc6da3bbf5b1afbc3c56d7e0b200b56b0725b258f0a04c90af27a268cf844b080ded82d04e1fac21e26cf8d8a32898336dd44a67e9802995fc2b363581bfc979371ae459deaaaa87aab41a7001db1edf63b516d12fd82bbd033ef41cffd76651d502644d15cc38e98de027e804c069ab541717804f331310a35dac50c6d8ab149400e9f1177a3e41985e0e5395fc0623684914a1cdf20a9917d85429b71abf799e0615fd2d014d8fb800ec5f3238484c1c4e2f26f32b1abe4994993d973740df7da411b141a9d7c7d9e17c84e6e4a57767b2ee1c7a8a7929125497a46ceb75a33c3a64ac912300708284cc30bf7d67f589edc0f22416425c0c498baa1aef569f07030690eac6d08577856ddad7810f6d90d24f7580030dd671551d4e34628907437c0f3a54b326af7f6f581c389b1f382fb005d5ad8f5c85bcd95a848cf8bb075c19375c7579def53e7f5563217f7c155745cdb64732f17fd5a08d583b80d3549d448f38ff760fd4ad9c3f30df2363e5846bee25115b55e8a1f16a2dfff6a08c774d9852b3d7ca38f226c2a3ac5ba001936251722322fde266f949eec701ed9f1879072d73a5aa5ed8fbba822081d49c1bc96d94178767daa88069fa081112d402ceab35eae518e3931620c82adc98ef198b55bd3b9373e5afe0e5adc5049a5db9b439b82a9c4d973a70995ebece2870b158550a82faa32691062d353e99713e34a7fef390ce684d38c33a790c59a9247da8de007f7a1d8fbe45a0ab8170c9d6e2470c8f9192dc96dd12582fdd90b39e08270d008bf76eff9677364084d4576d3ffcd9e5760d2982f90287eb2929bf09d7a5f16b471045799848dfc0ebdaaf1bec986dd86984c86e0d17256f7c9b18933f0b545fee86b80ad56f5e69ee71e42072edec58e04445c42c58de36adf29f5b577fef3bbd6c9a84f55cdb66c4274d7ab403a5171e59d8daaf75b433b44df8605e005f3b03d9653712d5f7bbf047b835476867d90f8bd172c27375294ff138a7c794c2f73779e97b5dac52bac58f149aaa554401adb2ca38b18eb22fe4ed775c1b9650f8381acf4fbf407fc3a7fdd05ddbcc1073596009d1d3866443e3e207338e9378bcbf39d4eea2dd98a835c8bbe34f758d7d70203c981a1f439655721d073ea1ce49d819256a84f127bd96da3353245181768c725ec8da9958f4d99ae64518d13e25c94b88abba392358522a3e0c42c80aa3330ed3d04151d5329fbcef4e1b640c41c07b8d6a74db6afda207e3597b52cc8676577ea20154d765efbe79a45ef88e28173890476f8dfe8d10063bed93fe4c646adad40d3e1e50a85b7526aa4e3d2171240a8130034b31948d375d63ac4d86725cdc065d5f5344bf64503820b55815b674c7fd31a70a3c3eb29d4bedd7230738879d65381c44f9a16077bbf254661199d343126b1f84e5c5f8a8ff5425db1ff15f869a8b4fe15ddd70e87b9def369cd951be4175652796a019b61dc606689a2bffbaff1b652875c4943395eec7905094124b7d8d60b29149d8290a9ab70d837b884374251e62392e2931fd3ebe2aba0b9fbb8bb09a9df8eb1ec16523b40f45c7f47a77d39cbd0a8537befd156e42bf191c2f61819318117e2d2bbeca2c2e9e714542fffe00814ac30ae70304fbab81e7f09cbbdc256b4134d529f57619b22e692af1f8e616949e997b4bf026cd6f1eeab98ea724ec3f40898670803bafdf2a7416f1fd6f60b68794f2c8713c2108cb21291468fe3397aa0c3e008a544724d73120904d5a5ffc5427ba454221a60f3eb1009f16294999c863c7b1cfe64e4d99c05163ef97657c04d9f2828d811217d9f72b2db9c13f425479489dbee92d299f4c5196e6d9673e77dc5e43a5d6aa57bedc52d77f4fca62481e99a96112b26db7897087a26dc271df88a88a8515259e9f955d7656524797546ae330bf89e8dcee4e98291953c3ca2f3362be50777df0711a00f1143811b486c794afe25c4c88b66a72b9e3d3ec0a2d36070c9ace89bf30c07e00c415c814556c13973ffc028adec215f1cfca031377934109021756c03ee67251793e2f2eb6129ab3f132a113446217b9a453215705e0ee99603b671f5c215ee87562a3b6b65d1291024372b31749d85271702e2f7f4d5d524bacba60e47ce06713d4578a94500968e5a032f15a73469b9558b82757829d52bb8ee6397cc999deac2504a61d6a09c0820c03652dd369e384de2d43156f01f454fb02577fbaf8381c79f6db843120e9f58fa999bdcc4aec63f07a9e4a0f94a0821109305b1cbaba5d397ecbaa2c3e57ae80bec5b4db28ee974ee9146e8407e1d2ee9d1d8c60f22de30771d50ae849a15dea77d439279b2266696af8dc32e502ff87cfc766cb5306e5e648ab7a9242da60c34e3f90df431c7916e84d1f584e8c51652936d06fb90c6d46ad66cef99c2a5d044f2a6128521a554bd525dcefa3a9b79d9405a8439a65a2966d4b2eec5b6e1e35eae170c9c57b79775ebc4e79ae721aad6acd8035eace52162c2afb8947013faea4a8901001d370f7cde9c7623047cb0758d0599571ca9d945c4991fde97ac1bcdc4e888d87b4cb802d70e6dcc114b4f31c4ffb5dc2bcf314dc84d3a0054966d86018ee5a09d2bd8076a15abdea56bcc8b42327e9a02f04f611601b01dbfedba57234735a20929e073d9c588a6e9b101ba989ed6e373d3e4aab21d8d83b93e91a1388f839b8e0c065d153b66d9eeca1567d2a471b04beb658b6adc7e2618c3be717b31b548b1d1b5f6151856efd580ddcdcc69523060e1cf6aa71928449f33c94d5bca19664cd83855a5cc59ecb9f220eaae0a3749d5123225fb81f9ce0cca348541ca4949ef33cbd0cdd65ebd2fd7b5fa5b7d8dfba2c1f3970e01cc9cff8dea2b37c5ee8813af5cd8c42feb3f22e01f226a231aa5b1dbda7e0d0b4d4f002fe418425bc62b8ee0927c9f2198aa094c9d2f57d4317fcad10377d28b4f9a9f4916888a9be58e23299627a92d3e64cafe89bd3297c9e1e5e148771551e48ef3bdb2745084dfb6ae6ce03dce3d4aec1827e26fef2f564e9e720d160669ef2b04e6aab2869254ca20c788143937a8e99203e595b10caf89ed8670a746ce4184a7aff5b2bea424f67d5055ce6336a59ad1c1c513c6bda9fd3235e209c25c2c56f750545465d2b0dd1422bbe6543fed4d10daf565c231a04ae5c379593ed73550a75341d27c2ab74d626d6d4f241184cf8397ecf289580bfde5b430a7cb914853974101910f0e3147fa6ddee24a6e8241239fbf26d2eb6a68fc512469740029db39ceb2af4414cc9ca68fcd7d1959a138256a1ea1cc5cac3fcb2525ced80b2440845a809359d212cf30ae7e5a6fdce5ff1cd68a88b7d592afb81b1c6b711dd79baba20da14fdbabbc48187494aec06af573c0b8ffd008eeaca8eceee8f8a00a17f061cb42838531877a339c5eff577d464f490f020ee61ff1c5f00c69c9684fefd951cb10594b9fef645399b4f850059881479fe9d175da2ee32480569b73554c5e5e9aaa1deb3a950c31afa33b619bdb626add53d605897617f48a65267eaae98f85ba0c63ef0bf19646f3ece7bd5d2a6b6b5115410b16007b9099da7239d14862af8a64c7596f4331472f01d5d64ddefe253e8f8382b25a3e841106b632b6a939661f3691d5f5d6e680c5946c6df4106965e3c63b6e86b5d436f36dbd8dbb5d92974d7f9b8d5e96ed9e9238c1bf57fc2e931cee1f5d8e741b2614f3a5f9ba31ab89a7370a321fe610aad4de30eec2aecb771f27a040102c9564d66f6b1c5b83b7a0bad1468e5165b84690c56e6b056bc7275252c6f048201ebaf2edc0fa08c145694060132178044b9898c5ce55004c6f00d27be4efab0e0b1cb53e8c52a5c103517e99dc9ccf29945029e7cca929f83b0bc1ff281f0eadd0ef668409c7a2ac5463d8e12c8ef4d05655a6523b9f03df10fda5b8de649d8ab6c7851400e2d3478b14250402b70ee5315dc26d0d05f82794309afdb969753837d976cd5c4b9cd7d6b63035c8bd5109612c31acd20b73c60cd93208f3292160da6b9a5d802fc85bb962c749e29f5a55fe5874b08b4d02dae0ddf4c1eb4013eab9618047d2fe628f4af9aa1e991cd6379766935c2b88c0185ae1383c21e2e3c4f7843db13b6ea380be33b64f7c1b412966c7e2c8fa445bfc809d078d58c9a2a80763956cd7b2da2ad67a10f1edd867e42d598b3c39aaee1ffb824c0caa17ced264f34ff30c5b2e4f0d9875ea288aa05178292682c010a552f53cfa3b906e227077d3823fccad9f490166057eae4ced3996b58598d5e66c6719b0adada25104777ef8dcd79a92fdffe12898f9ecb00088693eac9d3994a7d18b30d4ab229cb622833744af5f20f3d99543100968a1e297b5f261d0239cdd0625d835fb1a9664ee722b454e9db98f0862631496d3777a919ddbb553520b9e4981b6ce4547faeaaa48bdab5260f375b45c5c94383805e2e5baf6710504ec1ed8875bf5f1c127624401f0b5a1b39f33421eaaea160e975d7c7106d650785c1e4c48fa28f180a2a4f721bdccf1136cabb1fda76b47561af5e762cc56002bf6ad69849561e151f628be1cb91570e5f4608d15f29c858717d5438179cde592883d83fb09c6e2ef30966de6b65ae4a73197ed5bcdd0b1d0df06500e93f90719781a8205bdb2f8b6d5fa263b1c61b9900658c5fcbb6cbca3c72a327e03346470743f6724e6ac5ce6cba04bb2946068d1b37892e008aab6cd7ba06b59f4c846ef45a25a3a57fde04741256969d1974b7012b7660a18f58a2df92025f10fb845d37d220c2114557672ab36048d4cfe013f20f9d524ad3f54fcb0a4715a58b1d26ae1de01b6c7215cee2d6cad54570aafdbd3bf13d545b1fdf381ceecba4035c80a68a7b4d6fbc1428cf4fedd9397d29efe28e09ea4276c7a7e2325412115384678418dea6dbed51d6aef15ee6ea0469f1e41802e4878402de8528ec8db477bb4e23ce36e47d4b05693e160be224dcfd14bb15e522147f11fdcf35f88fcb9b5bc11baf530323cef678de7ea30ec322f8fe238d5a27783456002c108e99f59e5dab692680951771c5430a211a5a4110b079c75ab5da4e8750b54c59f33e9cf9efb9647fa67442b408f44071d04ee19e269ea82d6bcaed3fe7ded257580e0a1a8c86ffc590267ae4e0cfa07e4f823dd23eb326dfc85605ca487cfe08b4eec0f5ea732e4757a6db8dadab87809234642ed3f39d9fcdbb2abf257bda65f226b27a5539eeabd5afd6192088ed76d1f041b3e2d6e8cb4c1211046dbcb59b6b1f1a0e364b7a8a69b9fdaf60dc919d38b08d8a798e1281ab2a8d23d816d759e8a70f92e878e17ae330041fb2a70f90b9175db5347253fa27b41dd322e406d42e23203ea73d4fccb619c04d9a011c7b264c07277ab47f053fa5906731f4cebab93dbf5a7a6a22abed5eda4578eec5b71a946f060c7e4278651e6bd3a97b4cb801e8f97a20d7b5d91c16a1dd07955218899e2c3dbc25756279cf539f67063b125b6a137296d0fe09be984c41a5edf39ecbeb7ce8edcd1d609ae241a159aa6220dc51436c305acc39adbb4a85024f5130f1a372b813528160a6a10ba8583c1ca4775ba1b43358967747f6b363a86d802beb64d86ebf5a7f16faa2555773b970585d974d5774544e65aa0d5d9119451b42cefcebefc3b2f259b78fb41d1e8fdf58043bee8c8c98ba4230e2aaf5b83ca8eb47a04c3e7af34415829a8bb00313f4b94a1d6be398a51623a1286a7617a036d8cce59669395078522c0ae80d9f8ffb908f3f6690c9bb86c5ccc573a238d074219d5024ad19aa7ab8593d894027efa5866a7ec472c34e87f01508789d4e77289cd57c30617706f8d3fc1c223202f5e3c497e01bba4ac58c323482f43a9a6c5b330820974bb6220a92d32126b100807fddb538d689804d5757175d38eb4fbd6e3ab110b7ec86bc8e3ea00b7ef35fba92ccfce9a2f370e0a9e164da19f6e99659ac7bddd1bbce2ecaebe1cc0aeb1ae53d117182bbbeb67de67f4c50f3db8d4850d3ad80dda479889af4bdacd098058bf5ed654a856903dab25048c8494af96f3810990b5b4f2dee4232c01e21caa106d396d5c2c7a8a25712dc7860e61f34ba36744b884488f854c910861026225f0642e7d280fa1718cd560b7d7dff6e9620c689cdaf15ce181fb96733e549089d3f9730d435eab45b67012634fe077a77ef989f0470b55c3f2163101777b613eaf12c550f857adbd10400e8bee129ea1016e07c434169fde70d22fd66da13471feabc102f8acf3d96b6baf9c4e03a9f642dea79da156bef9693e97810794310b6d2ff4b86cc9eca6eac198ff4d89a6704cff4bac448e245eaba77362bb0b1c01e7c240cb37b670546270989868d3daef7f753b9dfca2333fd3467bf60f6e35a435c6e388c2e91468b17c5307c0de6436218b406caad57e156649aab8a9933bc6a7772e4b2e819b845d04062d7f09c267284ef2c2e982a370d3b95670c5241d338a5e81351dacfb83634dba8e189e5744001322516ea3b5abaeaf8fa6baaa613efbd9e88a17423c730f5cbeceb87c8bab655b5239685533bfd0272207dd5cd0dbbd791394b6eca60d5909266ac02e1b027519efa7d2cdf8925d830ea18074bd6fd1349da5bc7d12df4d31ac79af442b42aa253784cc0c6add397cf0a1c30f1601488e95a62f56cb8c3fcf2c9d62cfb8c9a8653b4ac8947f8337bd6204b674ebe8e4dbf33ce67253154131c50146c3f38a5e315d06d300b5c13057a9f5b8cee2c40fb90b73d4c63a137129bf80e3d1ef5682ff2cde75b9de8ce1c46a8f097222ca272afeaf9dcdad2b5f24ec67a9a7b3ad1dd3a85d142512aadfbde5a1371fd6504a2778e3a714a6dd89243f1730cec6023ae50861287558e7f81fa5e7a5238db52c852f7fb7289b77fc88cb60e61984b5231007725236b0e63df7855cd9f8a2241d74106f402e83a64227d323ee80f444e50161bb8828a0ba30edada5d9a1d6f1a725f1230bf96be274863a6b108d3137924d2e097ffd7662ef698b70eb6c5f5881d9128a780b0dfee7a8bce9ac5b9f78b247e0c048e278b2388db6a03dee514193f68c6ee45b55c77b454b6e12da28b2c71412a90e74e6cde7d475e0c9a20121129555a7fc376b4201045d2433ecb2521df6202dda4302685632cc9a5dc3122f5be108bf5c4b6ab56070354adea487cbc37cdff7b9977ea8f1a6e2a66a721f73797ae5f2a4303ef0cb71e195234342e13083b00ffc424b17a90843db257023df458748936beee6654650b5ca115235a8d217664f94017a79843b757ef0ef997078e9330001720145be1b0240ff2ee441cba55634a242d56b2f74bb33537f1080236502ce95b6f98563f7e7f6c41c026ff0b3070e0b5aa862617fa234b90f60acb808b29f8d252350a52037bc95dd0a706a73fbfa243e29a96e727e34d1b4fbdbc6ad48f1685d2422a2a940148ef6f573ebba2bd2ec360cea3de3098183c09f1b32a8ac8a3bc7f7abb6ce25bcda22b7d00c031c0089e1608341bbb062966976928961aaf8f54f5155e6a092f047b1ebe99ba00ed1042d485153bb132b560b5e23dea930764fd7aebee84ed7d5cda09eed4848f3877b2312c86d11d93f851b5bb72b1c4c9225cb4c84d2abf461bf40789bd2f4fe20ac1d7586a3d1196ac0625e4a642644329dba60fb4fe7faddf0fff3e0f6960da474d5983d51c6e70c8055ae1c861feb8891390cb16d96911194975b02c8ac61dce954525b951a18bb2ee5d9f614b4ac29f73cfa64d35475fb2f8806313038c38c1901bca4acc42ad7d856ace6b857ac83af17d60163398255764e96f5aa067ddba4f014ec8a39d03a8f03f542d5d041fed822f0670a711604cda9f7b5a4e05f7779901e1743340455fae4ebc588de5f3b1625d14ee8733f055a9af74d218b3234e1e6dc66b4f4f37c9809f56184ae43ff72a8746309e9038ed9a23a830aacdd61ac6c46b25585f13d49f7b56acb63f6ffb4c80db446934227142962056a30bdb40adbc51d19fef537d8dfc971a947619c7ce3311c7b3a85ab6cbc030b4508ffc1d3a9ce911741c9fd43e99bd69c29e2f2ea7b06278da387982ed17f2e0be0836051da9dac22848a520ee768cbae9301b8c623c1434ab0454a45f625085f636767dfa2d4a1d3cebb5ba7cf0c1c5899cd417b6e8525c598249c96c249afc8805343683bc88828e2d6b594520f25bb49bdda458a5188306515316e5d48289ed94f93b16e6a6c062cda5658962bd35aa92bb94bc17085b67b5cabb43dc0e0c549c57cf9c28eeda2fd49f97f88bc70e019fbc6561df7970013bc6896d84045c69405dee1fef6eea2cc687bf6bf88d7db9a88bb33c5ca71d1397ab31894d4fced11082d74c360be5ff611142cecd619831c3f72b7f9743e2b21190733fb050bcb1d9f7f180eeff0a2609b132cdc98a0243dd94f6e46655a03ec078e5c5aec107535cb61d721147a23d22b040e8ccb42e2fbb4a0ec4ab8fa1daa5d1054a826c25dadfb7fb9bd27d2bf3eaf9a00c7422b700ca77e1d33ce364400e616db18414018a506929b957108e8c8ffaf219b77c57907132d81e6764b18930c9a8016b090b905387388366e413042","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
