<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba972b0d86bbf31236023433278052b0c08a8ebd1363c25550d49b4147e335d4d3abc3651db73c1033d283a2306ee856158102bac066e521b9d5100e2478e8f05e65fd5f8bc4b1ecdafc86671ba2f8e08d9669e675dfad09ba2bafff26526c6764d5ef035a8b5aa6b0b53dad78d6622798e92afd4082e588b494f41cf5b7af01b5c3949fe478d278dc31dd8538643e8ceb3fcba67973a4296ac2d53792c3444c07865a7c2301161199cc67b85bf8fc7f444eb856115cb480f316ba4f246cc52116265acb3e4b7a02edb271313771297eb0a493d70d695733466c531765ea4b26accb8b277571e8351432f85ade6d8318dcb2404be3fd7f1f0fab03c5669fcd72177af8f991adda1c8ac5abe8c27feb96e94cccaa7adf06f84d30bc05a39012f46c52588812401fa34062c48c2c28d1cd9a80c7fb40bfdbe40169a41884cff492f23d3515f59f5c00f3660d6831f720496658f6972c4b3ae7a707e0cde28e652ad3415ee26b5f98ebb2c220e2b202470bee2bcdf689f19c8bb763b8121007c4135981caf3105b050414c499e4d24622918246c5b50cfca2d467a0f4f64d1a414ec38e6f06e30f9fdfdc502cee3ceef52870549d43f064b7ec51d5659ccc7c9bfb3b18dfba438c4b60bc51626bdcae9593925eb6c9e1c79cec63eee966183838084314ba15f7ac5be170f53f2c324f0c7d3cc223d0f0bd222e66a301e47a7f6c986ff1ce06da36a0428812d2b3822a4990ee0332134e49a02ff750ff81bbb88ae09a722d9299c10e17dc6c32101e89c3fdb5eac26dc391d6908206936d551752c77a52c35eaa06396dbb506eef7db2af25f478219b685f4fbf4b224d06c13b592e8467e16cfb20b572fc6660716d51cfc778c6b9269f488dc837ad0675d910f045f285c249af1baed4d64f19734b9b2019737a9b13f64a6a4626876d9958fadef0813d368dcdf3575a96ca2b676d1adcb0c5e4b521051fce36035fc270f74d1ae625a0f0dc3a9e31d3b4773a80631d699adfd563309400c41dd98e3d229440cdb1d0998f6c5241d002613f4c0257cd6a01deee1db670f595bda5ec4ab851c0745bdea8d6dfc46d6825f1b597f931c191a1363d67f6b9f5b8672e10346e6868fadeeda7ea8de1cc98d13fe42406cfdac90c0dadb1c62eede07ae7f1fb91c5d4f44e72a9d53ac5b52e259b595cf2d9005241560b4ab93d530483c93d93fb986dce94248655d985c95f6eb87673b4a34df0b874744ce8a34db726c1e9cfe05508ea0376556f7fe6ebb6e0e5201f08959bc9db15642e2982aee31d6ac8aa042659faf94b22a058f96f3a5a0de517bb2f6f0a353fafe95a7de473c7ec11b0ac1d14d87134666f341a2b66202cc938f57ea458fe981008f53c1157df0cc824aecbb8213ac9f5ba804de5f38821d4294192023b19a02a1fdb1e29639f3a49daf37893c460a0e36d1f0680e8fb0b4d1e14c08906e87d316e727241142cd6283ee4d72635f3212dc6f0822b235f00bfef7f696213e0f19cd2218e77314b8b459cd153225341418536965e93799c2892092ee6a9d653332640b62e4ddf7359f64308b3c1e0fb2e3a262db5b6d6b4bef79a34e049137a39019a57d0c0552bbd228cf6bdf4ed5b34220b078c77e6d668f9e611d35cf3ca071353a54ef31bca9269d6f2c6fdc4f715e122cf651bbee446d8068035be08aded62364e2ac641070e5ab42c3006f7d7b5708ec26720fac075ff3683d789493b7dbfcbee20d898b2cd654f614fb5b0c5987294b8d069e000af04b3520f70864cc8687da7cf2b3fb089fe53092ae813fd851d3760b1d5fce077e999a1654171d74692643362fbcda0dd9932bbde98e4124d332db364f1334fb6e746f89481354689023901c4b56d89c16845b63e8141110b5012596e6265808ac6d7e7c8b9531a724e4a25d216b8ae78d29c72f885e9aeb47abcb4c694ff9a73d0d0f1eb5d15eb51c31dd6342418c2d1b017dbe1276a4b65a8d009596610c3da653651d07011dc821a8492784d768c46f9560cc28c1e3e6e77a78b7b636cd8d9dfd0b5608df29b021a87b1bd164f08768f4e1d7a5c32748a5b8c7fee3129b0389e54a7af719d54014aceb4693a565bf2630e1daeec0e25c37c31e6c4d77ec1d275c256f29fc15a375f083e45e8dc66720a31d1b0305ebccd01f6747932163b104422b5a4aeb0dab71fd22f92ae43425fbdd3aef51f94b3d06641fdd2d65d0f11feaaf917bcfe5f735f8b2060230dd27945df86f8d3895c11e80c0806915c3000d72e5cb40161286d13ee36f1ec56101a3d65ff30f50513f21da22cb691683192980c9e75b5d6d4e0cce263c4f5c3bb95402829f8e783cc2f5220f4e82b2d0083df25286266873be3a956dc459ab0613469fcef77fb72371e365f9873040b199ca9d6df57ee2f3701578bf6996153a21b674e40cb2903151f07901f70f0cd35a8a296bc72ae42c5bac1df7f111f87461af21febb3c313e8ec3d4a26b01fbbc1d98b976145e71505565341a6747a5d919c4db1c43a740ac966f112a7750be013a68dd23e20d336b7e59289b4be89ddf1cde73c1569906b8ab52b8a633d25e70252d69d88e3cf824ea55d154a77b7d77b85475403bae4a67114fd75cbfdd4acd420280db9f29aeb7687378ce242a290f713349bc43a44f62b679748d2732092e22191fa5064b56fe83a6c7bb5159aedb30a9c56f954f60e0f98199c7cc8d339acba876a310a84c6ecee5f72f7001380f5c35c4b843b1baaec8d7860a42bdc90774e1463a2cf319a86ecbecf9b85384d96e4735f761cb7ae9819e90d5909977ac9845f0df3059cd10edec271272ad83b44d3837b70f4ce152bf2b849707d2102cf7c850108d68f620c7405578217377f5be302fa02a533eb2ddd0e6b3cdca5d27a2756c71e5a677ceec61779ee593869b93582632e2e60eee78454d56e0bbfd6e2053663ea947de123f5e3b244fb9f7d4888d099cf4cbcb123b7c8f4f760916e5f5ce5b76be54292132a779d773b21a5a9351d2e6cdb5b02212d63311c4ae2be312b6371cca4b8906bf6c0d6438412dd6db159ecd1974400df3c50c0a965f1f3027c9ae53e780ce64b54427f54e3d6f4edf8e2a8d810a6db1a4650641aa488df2d3772c6a2a6331cd7c46d1943b925c585ce925a2786dbd4d05b7167a1286d14f5c34c2ef7fa3a2c13c417b4467ab2dcbbfe49a3c094ff7ac3b07dd3b30a1fe30a850a64772d0e52d99c1838d4fbf2ae0f3bf70132caf8f68aa3c4f3fb6f4a760c9dcdbdfd7500302fee9d7f426a28115c99edce30f203287728ad5684c70e94dde2450154c565a79a0b2e8fb3f4d4d6069045fc23bca7dbc43f9512b555c3b97d73c520360b905b674df6835ee4e108dc34e77418f2d4f9f8efe7e6ffbcf0ac9122e77f1751afcd677ebbe866432112dcc9f9dfddf7addd5a8f201041075006472419caed5727a4a9681a4546e22b513e3785f7eee0e46e1a6ed03327fd1de3ba58afccccfb481853892a054d90cd3c03e965eacdc6d6748836711b1c18a47292ab176d97839f6a4b052233e1fbd8a2d03eb859c31b0fb95aedf5f41779e791a60056f7425e6797b74ebcbb8583ca68cdb54c1bfc23272664a8e38ca721e613a6882d6cd21d6e37ac283c350809289e15230f289e68207667c8c7592cd2d2226ad96083c5e6b6e0f4e19887d2e342491df107d3e2ac68bd74398e8195dc830b63cadc4e9527bbe5aefaef23bc4464afb3cd3484270f69d5e50ecf53ae0835aa7ba6b85e11850575132c7ec408f0e4c008636f9562038edb7c0807fe58e5af51e22f8c8348004c8d436fe85fc55439bd44067481845e62dd3ec92b725f789be8d92564ccecbfb27fd9667d6567d1a1f0e73fce0c7b32d16ac4655a7aff35a10e20e2844eb3ff544a746eb1af10d36164ba057263f16db59cde00f91607bf7d06f7edf14bf8fd6aecaede97cb04b8935e0b41bbcb81a89070b47480786c75194289595cfe1c2579e247bad33ac8d940aad99a013f7ee880d2e18e343d1db0026549e07fc6e0e9787eb28d429467231902792241f05abe7a6125f0d5adb1fc4211095326bded4507225290a03b4a2f0dc32bc35089274ab0c5595d21ecf8304e5f18c24c48f0e3f8a8211bd696492724170cefbc5161af6d5d66a7657bfbe133677ffcf5ce40c679a15cda6ac357ef2ce9df48a722b42119abd8ae6fda02f2d9100057340faa15a8bba1544ca5a5e4c90cf3bc94e8331181337e3e24f2d599e15f5ff7ec000daf796aacbd6e8741e17a6af9f73e9c9398d2860108893dbe6af82b9b160dbf67a9771453c7e48f3eb83f37261cbdce46899626a7d1f7e311a4097ae20a4e35054e855f914254fa6c3e6515a44a49d66c1ba87381d13b628560e11da1491b6c61ac3ae8cc4a4ac7aafc141f8c6de49ddd8e0b5c6dc139391e2e0db3ff5bdb49c613b0e65418c0409b0c352ae252d41bb4dd76f983e725b65361b8bc192616bc306c440b851a379bd7e11cb58d053df2675f349d3c844fb47cf6cc7be9f45c399616966c189a086cce7e2e1450a22b117d94e0889bb3a2ccfbd0aec781bc0feb517aee9d624e563b9831b72c98408f8f94f2dcdb08b8c2ca3179351acf3cf7e5c13c39bc0ac7acfc839bf5b441d508a8e759c38ac940732aa9b74d2374ed08b384068dcfbc4191efccd5779552d7f241f5072377784c607d62be24075a00a2818431eea188d92d39250fcb305e5ee7382bee761648c28d511754efdc5854c3284beb67fd85cfed6076dc46781a7f8be30094b7fd2aa2a919c360d2a33c6ca7288d6ffb126d74c3b4d3ef1fd7342be04befac73aee8c637e0ae3e9374b9a694a06fc800ceb5afb28b8dba5bd3efab6eb11e9c0f4577e55474d4cdca70eb40fdbbebc12b123fa6e7e2bdb75871c1008b136bea0f496fd8ede69240ea187e87f068b452fa43f43c5e2f2f8e70fc802ec480a1afb45ae8220f0a2c6c682a8d8741c3fbdecba66f0c24cba1fef08fb0c4137aa3b9f21d2adbbeb9b4dd20892d03c8f182d20f5a6e53a5652441959c71ac2b65d06a00a4bc9f655797f026b7f5f23bf3aaf5bbae8ad66f1ba92bba4e7fe74ccc320086490b66bf635d5a3221e5284fd2722fac7aca77c1b76c40278fc0d1282c706f8cc1e5cb6de613c75c35eaec2d9da4772cd323ea1c8e67619b3cbca541f74ac858791486ea2645ecd8a6f4a19bbe43d5aaa42afe71da04c32d9ab65be47725127acd3ff0159442d94dc5e4c815b3022da7d62268a70d65e5697902965259af3ef8cd860fdbb3101a86727eb1208d184cc0c58a3916c93696acdb11b3b75ee6ded203ce4c47ed9042dcda332b35a4b3240c6760b761baa0f0af9b4a3806a21a8da9760d21e28cc1e84be33c149bebb59f1e0a19475fdc2a44286d5ddd30c5c30bb731ebc2b2ceb919e97aec44919a1632f5016e7c0c74a555e11044756f154008961bdbaf3a947139721030ae1f64b70013e3232f94cda0fc264369698d20c4ef7e01036991af4279d6bbb56cb4ccf3789951184154bad69d69c645640214f43a1e10d5d8a85e71b473970b3a43b59460d8ac2c9f806ee066e0bf53d0e9102f47de0f2cccd92d1586dcc1e279ae30f6e16251d9c1ae209296ec1d92efa997ab0ab6e23d2ce630212f318ff5aa1c43935689a6124d0bcf5d3771698c0326f60d655b45573bdab2ab8783913a11e64027dd80cd93bef63956119dca5381fcdfb4d76269045de54f6422c838c1504e7e49441840be2327e658337077e77cd40c4bbc5c994eda8d5780418ed26a7be35e72b900d78d452707192458b7161849d2a30118e16b5bff9cb370725a1ab03faf9bc2db11d77dff3a71d3a7a3a5087185a7ed8616fabea987bd070726fd6b3efb35036fa7910af140ebd3728cc669019506967cd2861e9fcd2c00a917c029e1bc9bb5053689b7a9db552dbd66207a3687aead697add5c3bdbe477e6e54348fd2544b227c9ac264ae99dd988043f5fdac71fe0cb4c05d4a47b0c982f026823f0a6893939e97998d51dfc091f1abf9ec80e118064bc0457eecb568e8cf0270aba148cec37717b28d5c689b2517e8ce77963e5383c36ca85cc373f64e7e4e92cb2793bdd7fd87d026f339b1c15cef30212e4b522bbe4bf49c3d8a8e0494c00288d03410076e47567c58fe484af982cbbe8a5a0620a327b778ed3bfb4e2766977bc3a74f9bddd91b0d4ed8d0927aec5ccf339c6ebec8dc88c49e380d170f9edba2b57f6c86c9a4d7c55dd1b8a51b6f3c3408801ab579f9a367e8b7fa65f9c0aeedfa675bb2a2f8524590cea531ba2a8e0ac0d13b43c5f111969588d93fcd4e31a1aaf88dea0c9f19ae134c7ca65ed1bca73ced4124cf9f60cb10eaf51f0a413b4302a5326b86403ebace60b1c273ac69eaa4bfc626d78359d558b2b2ff6e5c92a23bd2041d65404bc70c4399db08bec51f59b9880a97e664a990dc8a33fc54fc38421df748b8d75364c45e6dc656a25958dc73e11fc1416428c37545b09861881623883be094e4695917a1903f08f833513386738ef6f2745f546e4c27ad9b099fe2a144d370faa9bb61d627ad071037c77de5f53a080204576c5cc7989482a927cab9a981a5e721a39128b1e8cc4b0378b8a2b3ff30e777b0a589eb78d300046f714d753779546842ff95e0fda78029112e84d6b63d13d6a13cb764a3907732c0c4284b65f3f6fb1faee4db4438a7020381719ba85e34b4a44546cd45b164ca1353fd17983bfe63a737f472c55fc57d2fe6eb0b68d76d416fbbaac464b7f537b3b227e0b443ebfc799a84f32a4a67868d12053f45b50c9594729364fb812559f3816de0939c392f82520f321ca5255264f37cd96fdc04eb7e7514816bc9b2fd4df092f8aefafc725fca0de62d82a35d4bf26ece2b7bd93ccc89f01c4e616a2b44740a8a6b1f8205fea1da2b3bdfb0b91ab362fed9b6a707013b45ef8cc67d9e205c96e2bf6af5ca4bfa169b37b645bcb845f5c647f0d4bd22bc4026da14241dfb6d0c959ad25f5fc174251bae37a61352289554200dbf07af97120654876fba07fdf23017263be40ad535094bf00b4a812fa6aeefda74c81ee37d332baa2b8a494446966ce2a9bdd30ba608abe2ee5428b4fe704ce443bba89d6554d0e888c85784c595d0bfd66fd5f882ce80ce27e41e9d62d6414524788b69f2c1c69815cd20f78c118a151d6528818581c144c560609a47811c3616f9b694eb7eba11b9c671106e4a636bf686e83f3f0b3bb057b41b09cfcf76d9d88dee5c53e999f5908e2209fe943749b0f070d62af41d06713bb88fefff99179f18a9a561e903ba66397eb0c25fde89e45a663726e69a97da7f7bca523b2b23180442a29f3daa409c8c04b4a8e9ee146e1414806212bc58268f97a51f5e9253e8e2afdb0747e8a4a9b5db86241876d5ad95bf1c6a25aa8df92c221ca7d2c8f37131bdadd972b1bd92179d05db4fa2767d218efc88878f7106f3c7588ce391955fb5c54241aa6d03954a27dde912111e47715c982adcb5aef866ec4e4bca69b7aac995a1e8bc34c22b2574d6d9c3dca3acd7b4edb6196f52e17fe582a151341b85eac39eb16daca92c029b62f61e7ca7369d175a6467c214c58ca48f6820ef22cde2631d486d54c46d2b8b056e89e24d1471c952235a59c85dfa5a1e42c2125f2a03fec604e289ff69eb12aa9aba6329104720ac1923f1faa8af8c1dd06786b31ade44df87fa44b0a5d866bfaced97365e30428aea25c1d5e054195c47f9003a5ef851079d899905adbd1e06d37c8ccc74663e5aa635797d026d99d4d3d1f85c7e1c437e625721c13cf536cd520e2d8db029ddf71f565bf86a0a22373103a70f278da95d6d911aeae5e9be4ab31016bc91823bbae89d3195fa1206170a65de4dd9d80cc2d377945532cb07b07b1c9dd9388c7bc4d6f5545423b7a39a3c820575c1e3c99f25a951024164074c9b77b093f22b3353dffb6d7ee3e7a052ad8c0b02b086213f1b3ba9563d7a8b655786db5dd7b1c53ca57b5a4ac4e397abef431d6fdc9134f5551e59b5ebc92b914972a40af6fc0073631c9370f272dc10e6391d64fb268624764ef24726e6281745d0b08166c5fae66792853f82dc355faf60d3162190ab895c80f7f3d3c0f854017498f4c2dcebc38137b659088d6772edfceb77db4979003f7edcde2c0be5421f62f7269db4bbdc2fffababedd7a27df42201e9d3b76aaea3908349bfb1b40c001ac3e94a746377e2d3cd054bb5c8872bc8657b9dedef6c4a087f9867729277d79fe3d85a0ce49e972f9cd84cbf48c4680440868c9bbf6e6a6b5e9b88ff18c2db93af9bbfd435d52f0702fcba3bd327d48c86bf8055c1b6a45233adf270a2013ff5626701dd251dcff13cf2c47dedb0e04ad47169b007a7b1bac706378b029feb2bec44e334965e66d16130112984e9b9541ea91dc24e92bdfc12701ebe62ea22a85fab32fcf8de9c7cc8d2f68781c1c8ed1c3bff318f6ef532d6459ea2b5125c86757d3e7365a4e453fa6c3ebe7301dd6c951b0b5824ecda76113a4e4c106111ad2d0ee6d95ca7d87ec7de364d425e83793ab0893af1aae6d593652311ffb9846fabe71fae37d87903870152f913c8d63c46ee9c88421bfc81ca20c9f9264610e7d6f5890aa55c9a425df1ba52fcdc85922b967e0f08a9ad4a9a1ae1a7843b42319f0e5f3ef22c6476bd89deb7b614c76bdd25aaa21749c23b84507fc5994a63934cc1b42adc4fffe2504856c256ecd9c0043378924b6ba60cf7a0269c6c402dbf4dd09d927f3ac001eb49c5850a054d5c5aff15356f0b563808c2dc0fb24294447f76c9fa75e6e5cdbce4c6c3b80cc2828928ab6987a91877db4000865eb991877c80f19df02d11f14d575c5b4a9880c4456eae06a0a4225eea2370d7fb13dfa90d88e1bce160ba58f988e2fc7307a47567a6e20cd090b1a1e7a3bfdefd63be737cbde64fecd579ae38364cd228e0227d116f5c7096bb3d7670b0c0482e8a911c26614859fa6849f7c509adfb78cb35065d08cad9a15edddc5fc8dcda36470ee47856d9ad77204b25144aca2ab45b1649fb2483943afeaa781141ef4fd9a3a4cb71e43d424f6b8687f478fff8692e32725a282be406bf046cd4ced04dc003faee83e7f8f04314e298e0c5d9f018c22d33d14228bedefac5d5a20c670e7467dc5221c160752b5c98856ba20225fd332931f7d7e2178938afc28bda09896f1c03ea9e4fb29cd01b8da032131cebdf090ad98ab0dd6858009dfd336fee1241ed82f5e0b6995cd5416b6c052c705ea434d1d8e4c7c907fa229568e515d9ff27caec24096e364b5adfa914b9025e979d64c2b0d924bd1df0bc540dadccf3cb53cd4d973d8b124626d97c0ea938d36b8b2542aa2af54b43f9542447868b3b865708a2f18bbc4b78c319fee0af882c9d8c40be106cd1caf9aa69d4d5b3af95b6241f247b1b88e89cf194258329eaac54f1b50e3abd970dd7cebaaf88f786182e054e94796f13e6378501f48b3fcfa5a5e05240ab0249fc8a6aeb29200bdfb23559ac2a43c9ac74ab548a396e266f8b5e89d2bb71ebbeb2aca41faa6ccd7da23d1c6e04273d5a5f542aeb46bfa5cb0013c879ae843c492d34631e7a9449ea4055969b45a0a2f2fabf00ddb1442e6f315035e7c52a99d51040b87771c8f3ac312e657dae12b84f49a6b7aecc2ae3e612e1438e66ca9947de3c65d6786a1178a9b7047bd7c29755d2aa813718a5368dab8f3335e42b370f68ae33f3fbfc6971571d5653d97628e60757a4cda563fbd09fe0d3ea43f1571577a243cf0a9656425105c5c0ec0d560b399cbafc5eb86def9b5be240ad7cf32aa3dbc018e2d91c89387fd303d7622f3435d76c7b9e0eb386a3f44163905fb5ed3cd5b5b28e96ec93bd026d7e04cc6b48a8169760671852f6f68649b4b39def983456da22ee07ba02aa276bd080f4131e5531477e717932fb475c97b1a637a6097d4ee25c89d91509f036a6a4a6a1be9648df7ef7e01eb618f168cdcfad7ebe2f596b1e12893f62d00ef915cb11135620457a7c09021f3f03cd417e2a102a27dd41693ae9a962ca3f06f01a7b62bb290dc6786f785c2e9b539cea106c77754a19d22c27ced3e204d1447c22239eedf23c6ad2864e3f80aeb8eda63d790559e1263132dc44571e069666d5c89dd9a2a4f155a90dffc2edf3edd7e026bca02a6ae6208ae7274230fbee9ca7316b35b13013fc8fe12d6d4cd2ead66fdb12733c8c9841b7e5f060cb15baa3fd9a416256328fa2c2c1bd10a6ee87f895a684a476e49b0736f51b1e51e3bac0bdec892ad253e22f70c7eaa2cbc02a961132f1bd968d248e35955348f9b0b0b4ebbfc0eabe4ba2094b59b744a88ac4cccfa9469af2a3a1f99c90d52b809b1c0789bab05514a9212eead05336a383fc7efb508390b2eb3120c5ee141eb8d3a676ca5b137b0fa780dbac4af03f13b435cc996c50eb296a3ff4e5059862adfc3ddb47c75edf5bcfaaa8e0ae12b1eac8718c152d2432e496707e366f11bf5520d2ebdb4e297f7df82497d37a38ef8664eee66b2bb99d36660b5b445a856e5b8f25912d0e6530c4944a5f6439b9c0453d8f1f137a6ff9a11e932f7aa3312015fd8eda754f71e463fb03c4fb9c332577ebd900631a0c7a0ed1d45f2b92b45b5958476fde902060c7a19263c2bd4152f18bfdffd1091bebd1b0de98a8938317f9e504c684446972f71928cf440709f21e9d2cefaeac588e98ed0b4f00efb2f25f6a1811f2bd21efd81b0ebde109d1bf544d74d8409e564af553a31763ea5b197b80d097a90c2b40cd91570391e626e118437feb03b40df2d27d9457d082c4630b54f4d05c1c76d8f186ebbbec23524496e4f84fcaa8a55879809bd779a2d77999c4d7c009fd475c3eab11c1c9492450acf560869c73bbbdc3c49c42f61fe51b92f3964cd0728404da9a98a4283de1cc7ab505e9c9ed4aa2e2f824d56424d5bb8e995282b08b3c9c87643c119e9243c6b8760adca196dc9b8f81ef465b9a9751e1a1fa4b2b2d5f16b27d9a442988e090dd343f5c4cf51abcbd059448f6318f070f8cf6d3e00b8f02f0b3e8f747e3b3c191a69d01b56147084f788c070cf8a6d57474f98a742dcaa0b2bb071faaac41dec4a1d64926ec4b538e7d52a650ea14423e5eb3489b03b16a84a9e00eb9a1936e827c2d3ca5ef943694eb393076c38fc368dde2664e893d3093660d710d612a161266809c6c2a524f6c223e98577b468e0435d6336b60e25c1ccdd15e094bef73083d29887813cb67f6c9bde8059b024dae2925ae7ebc031dc971673701ba5883f6ec87d405bf247fb868685b62d4b9ec8fb0d7e4c9b9956cebcd9577e193b8367454b528e658430068a0cc1149f07c9ce2e40641b375a1ff853f4b0a8531832950392d89e11729a9dc1d95c9718e68d16f5deb884bc3d37f6a0bc89e475a56449b2094ba2b386ed0839e2fe273cbd50b239351fabc9046734bbb297a0dfe163d2f0d233d3580ee55fed9770470bdd99f1b2455357900e6e39d15343046d7d33c41048778f66809f43860c3fc66006761b6c1c232bc827da4e9df0a6d09e7a6ecd164999a774cc15a97465052544b66e65e375083c47708f6af5676c2416d350fff6782ab7aea04c535f06cdc79dee0f08a97fb014d63838e0128dd32ba07e8e6a0127963c30f79ffa23b9125a1bb3cc601edaca26536994685c08a4f8a65a99ec130602383ff4d91fa090d6f666efc651bb6eebea5b81ac4377e8b1da5c7aab97c8dc220f3e9899a9376104ca74b5e2296eba29f78e450d95f67d6ca736787ee5ebc3103138aab5a93487767ce707a7274bffb23191a1900dd78f845018fd9a810b6597ad0970b3b0cdb593a1f00d55e95823470029935085912efd8df244712732f79746be8d40dc070a4ee016091d58a4f6dea10ee1f241cea356270b1f3e86009b34c428de22996bb6a67060c2df43a6b9c16e4d8d7bba09244166f587f689b995396f018e916b5947345aa9880e88359271d34e200310720b7e0bf3ebadfa0af5b865b8fd7ae8f1874d55c39a7cd1e4f98d6f55bcffa985430226f906deab668f732f75c3284118f260a68389b983808054955e4144b3e23b82a60f859ab66088185f1bf6b2b0f04683dff258b7ad7e04d6eeadfe22483f7b9c2be1a24d785ef0d0c4f39d1922ed99501163216ff8c8a7e695931d857e1677a700cf7352909926d4a0f15f861dd8ace760f04fa5a8136fd2c1a75d1e50fc8263b28fed50b42e800040fbc23421b9cd7d5ee65c8356fe77aaaa6f1baa7cc5b317b438c96d27353ec6177f44dda174168df4fbc32f24ef712c327ff9c2239b2f0ae00efb322fcb8dc0ad6a7b37dabea7ecf87d337d3ecec276885e70980999f7ecf83d0d38bb73c4dfe44d7a23cd7007f9ba2cd23cff3dd1488089b4045c35d307784fe400d617377608ff56ee1e94cd7ade749fb68c73ce0464ea27471e122a643b61cda3faf619787de4d165ce8d91d98bd3df1bd5b61ba1f01636a8c0a033f289eab9998ab6368c8f1c5bfaa813fa185e64a815006feeac5f38f04497aaa1aefb370f9a777faee6385b34ae7d42244247ba29335c51380e6041506e9d38763b72d306b1996c35a67b577277672edb0236d4c1657cdd47089945042c377e4e6f54fd66e0424d296def205ec2fbceb1a56242cd4b7525cfffe9576d0409dde8012437e59e48375f0a37fa066cbb4e05cf750e0ea432fb93297813c2b123649ff488781872478d8af50d3ae03c2b258a0954b5e0c0e70db7b31199ae4788f235f9a199689ac14c1e39df8711ac169ce37ec93f80aba1a2c6d59fa4637fcb2d4644151228e0022743eca73dd50a1dfbbe500411baf192e3c0294ccf26773f22be9f564897140edf6d3f8caa48afa299d5a195c28990fc53b4087a2e326d482cb272c27960f75832b2f11c021f4e8d164c48035a002f85efbc7a78fcd82123e6aa970b24ee1dcc535da54cd6a664c181972944be3060e03b6a6c9f787f6f7322cf7e49cad279f41d58d2a62fafac4536eb4f8122c1ca948fe09026b5a0fa6c56303e163b483f81c35a8551f58cf3e3ecf4eb27ddb595ae9f3e6b25a06497c0c9e142c02cfc65cb1d58700bdbc0f3918587c65fa2149453b844cb9851e95803a65c6a9955320b703676e11a6cf320e2c18439cbc4541d9b7b9f0f3dd0f9dcd0131faece989686bce5e0163c498f384ec99bd32e9fc51b9f35a61f06f54efd3b3d2a6389bce9cf907a209608c3507bb7264ddd50e0a2be8fdaa54f0c445b140db7ba02ac0330899c42d9b1fcb5e8d7d896a0f829592194772102b2d9dc5be8d9a1e426aad40d347da8797b2120ffa7de03edaecf9114df15159cfd2c2571b510d67503379a5ff3f398becaab14fbd0acc1e9e6e8d3bdc82ae86d216a01bbbf5e6e903f1293acc4960fdc6284c0ecd5cca46e7a15fba82772b1d2db1efbabceee080fe1566e1c94ae8547444f85e81a77114f9cabac96074c80ac1cc19b3e28b090ccf554c2548f362be2162e992cb6ea9438759816ffb1f516147b25ddf8a2841f3f364e3927a48deba403f4633ebc60ab472cc554b8566c4f77d80a7b8b825a803ae901120f57c06f3af46db0bc05575c4354b7198fc1b7924937a9ee98e1496f8dd025b729bd7b3a66c47f5ff79acef292eeb200b3b5e8215d952c6ca7c3f9fbfb68086ae2b597b6084acc50691ac9bbe58f6ff94c586ad5a17481f245c1e61799d685e0fa83ad003e98c8a7bf04fd0172787f3f850008f815076372a215daebbafdfe7c9cbbca50b3477c2f30aa6612c643f01d2b923982fd0760be1015278c9f6cee6360fc1faab43e0b869c441b05a31ab0d53d334d93b545a5c16989e9f556e7922fd115e85f7aa2443db80590200064cdba4386bf32f540959e8de293a8fa2d13eebab23d24b9704a4d0ef924abc1e54ac862af2ea57bd09460e68b57617fef5088e19ec21c56c2af9fe7aa43f862a464f9380a699162b4ab7a7456dfc93ddd2cc45e6ccb920d361b9d10f0c7055355dd2cc953ef1fd4c5afba5bcf00210c17344861705edb966e28e5141e9be9d47b36ff9d2e95c1cece79c466f3e9d67973df75b3d4629602d2201004cddd321112d5be08137babf705e707a5ba55c28afbac6751299a84c46a861756b1584659599c3f00480d669de0a9579683e783951507d0296c423f1a049880f8c14e8640b4c5fec3486135d130adda63f2249721fad065eb3562d81f3df78ef819a0ae00e0354dab3c9f45ea78a179401339ed73120aec3a782dfadd6bf9e783753ff741f71b3e450a0f23944c678ffa480bbcb5be908d32f373769c687737aed2f84455f63d8098fcd0f010d428210c5c09c1bdbee6b27c0fed0d5a1e28975bbd15d71524df59497246fa61ca36e3ff471cb7312ef378822f494410b6d397e18be66104db5a1ecad6d04bd39f7d0727434c7088f9f8a45879a92c9592a0ff60d182321fa7ae5b7779ee9cc19e8e3dc83ddfc74e35d16e1a97260cccba8fccd83971f7591a439f24290eb6e69f26aea242f5b5afdfed4fac4963288f8d4ca8d9425d5e1073182810e2607a8189cda9043b3302b6e6119b77e21fb975d52f77aa170d511167c779568a74969abf6dbb1fdcdb25d15186b909167d5f05e722ec37af857b2db3c4455e2d63ec09574fdeed30016d772e317ee6a1ebcb606048a8e8f593bb35ff11c698ecd86611087473ebbe058e5b802925fbed85bd9f4238e78c9ff567cc4101ec46e9ac6b04692c2395ba12f19af86c738e12ad09a19016d4d3c8e618ce36c70550ccc4d8c05882de5bf1971078edde6ca2e052f7d5229c88a74fe855a3b6f54b1fe322150b9104e7df94c117690327dfdc6eceb85141bb487e72bc56f6f1f7bd09aa4ba3ec8253a17329f010b45743eab9a694fff9936fae58812c1f667901564e557d0796c78d95ba5e13289da0144166ef80e7b597b83e780043f3e5048d915ae3a71f0a34f62fb0d359fb7c414b871b199ea6aad55c65c6fb4969b127429626cf8bfebb53de574e884518cb70f3cf67fd4aa159c1cb30dbf70f11752088af5437dccf72c5536e09a9efce16720a79967f7917b12b2753d994570d083bf41d3ddfde42bf7a2a39060f0444acbd78032c08d8d8b723125161084bb4331b51d93b870c50a074ec22b00d529f087552a9e1fe338adc43e71418700dc127359647fc812070f31706d9a24925ec0159c00ece0bd5843b78edf36c59a0124a5df9b0f6360fe4e26a0d6c1aa14438ef63037cf240333a2c0d4d53eac1d75a3f97b463f64a0a0b03fc9f61a764224a6e57493d7185ce78dfe7114477026faa69ba59c69db0459ec83ed0123239df6bb7317b6ecf9f7627b713815451af5771b29b59bd40d14dd602bc40ab05de93196627a38929cc8f14df40f1165dbfc51c0b5cda9161fd9eab28290e47df2cfb73b56cff164f82865ea7819112e0c6263abce19f3e547123daf6e6146d76d649f19573bcfaa21c85c560afcb97d397ba5e64f6144fbd1612f246d45081039e364532b6af083065213fd18abd2fb1c6d28e798169b677ae640d30484ba4cbf3593ee228687871d87f0b7abf59293a85c2995acbe5a65d07f934e44707e6c8cc09af583bbc5f105467a912e0380d251436b45abac78c22fd0db9e5f69df8799d1927a1fe19e357eaf1d1e2c80dfc66c96c3764e3f82122f98b7ab665ef5ece76ab7fe2ab28a3282b9b77ad4d20a9eb100f57e9f323405956ef0d3147f01b6948f73daa637b209c1733ad018350ba14dc50640cfbd49257a84de008216a1ac6a3ddab75e27bd850f40962d3486adad28887845412876d809223d75f2cb0acfa253c34753f8ae85f801023ec94f8a6b4eb38859b9710346755a54ddf02ca0fc83a9c66f537ec89036a7f51661cd551b4cef3f9cb18cdf8171e347be35502f3d3828d4555220bdcd5da15c1845a5f95dc7d0c176b133cdbe0c30b0f5ec37c04d1212dd6b283b9f653e45e861e2f094f12861d61c9b6ef7401a13fc001c7bb0e217768b67a0c784b7ed2b2b67bb59f6f9eb55ff6cbcb62103efa41fd8f61856ac0ebeb87111cbfc9c1e95033f3d3681dd3aa165aa9d8d4eb72f010df4430898bdc96ff0e7f46ef48dbe80b643bf1ea729e3c4094a3087a91760a901214c76b11f4371fa9728bbef062f7d29b3c457027100a93ebf42060f34f6ed3dae7067bb0880adf5f5b1689e8d2dbac360cb10f250ae0bcf40c1111001f8b00af6019ae388a47b415e01a0770807bd9e1b5bb84b7628ec1004ffb4c076e4ab2ac6ca462d5ef5c63ce01c5c6aece8f76c16268e2ac560082744e211c6082d7a6a2764c4989feb89aca74214e16919c79662ee28a1e97c7019e568a87ce8616bbcd60101aa70b59c1fa064c6092304ab9c724bc5df44beaa5317927743a168fb23bdec28c3c3312f75c14631167da5e023ac52d819e0a865d4ed1519a3212630e5b5363133f873ca3b11d45941649a4a5ae62c5c298ae4180a764609a1afccbb8bb676242d883176c414e2690444c97f0e8928952bb888cd54ac1d6cc2e584070c6b39fafb5f2cbea412af1f6da34ceba2b698982458c83d982daa0e143dcd74271d69fe6bbddc6a4193094e023e27a4dc440f113e11c8c61accc922fc23ff249b6782ebbf152519682aa70d12caa5a21eaa3797c1c1ea107939bbdbf271f51c7204cdb5966944d8ab3a12d4bdbc93a851d03ca80e1bbb60b8a8fc7992784899bb8fb51335004978a75916119f6fbe3d68211b15d3a799850e2e08d14a1f5e2e6311262c684c9e281b562a00c5abad3871bff7e27dd5c43cafb2126a0b171077cf2b19225622e1d4aa1fe7b50c131852016e91fbfcd42b17f867fb61199028e25d9d57b4a58229402329018dd6e942b18a40663f51fefa086c6213809621cc3f549395f1f5550d00ceda8e586033af28973970a0dd37059720cfc6befa1b17507ac386705814df5fe538c21661b254b4d30f98600968a9850e2a735429126f4d5eb4d71f1b1f423da5cf7317c7a95c0af878c0e5ac6d47647b3a320da689bf3b77b497b5178c34385a244169d658ac4969a5ff02ce18477f24109f8d167b856e169a6f74267702283ce63f373092c99eef1c6b389bacc6b01e0192c48805dd8469e3f9ff2216ebfc5bdcc26bda477150f749e78c0c12c9def204c8a321e55b84302b4ec062382d3d19358f4d6df194ba43cf1538fde8a47f39224b93b13ab91be1976be413762023f0c4b9ed527b3c1bb8dffb534d008754c2884d3160298fc19e4ac6478b594520c3b6aa20d700781036f40113be8e5efe0003f41024f3e5f33bdf6e6b4acbd4af0984d2dc95b9c70e8be4fdde89bb9cda73547cc4a1e41643e24d471ea83f2bc9f3e9c38244035fb09d0ef8c0dbf27a80c7bdcdced1117d2adbc47b8a0351c23bc0cd5a7ecb5b84e08e6aea59e6f1a29efb25b4a510a9fa18af250db85024fced2301241d5fb4e609a571f820eadf1654459f684e96d0ca0b755e690557d04c8a47b3492590458fe6c8499f2035bd573b9eb8af33b554de419a7a43030a0fe62699ef5191293ee6c7739c7f0d751330b0657ecb2a6c4529d70d36c30fdf2a151619e2f0baec6db4700dcaaf82f908603d1f3488939139db2d6d1a4ec6ff365bfcbb476d4a278ca23f2e91a3258b910f48a410a6c77d57a3ff6d9be2d36715b67c108343c8724836392c9bc553c7bb21e3be3a15c6907c2dfeb79de5835301ec078204ed50e9efa7d0c011e6d24739ec5e2a710e88aae97308ba58c9c88ebf3ed062835400e3d604397f6f4b7da3478c2fc818fd8451ddda3c0d7307c6a6ab9be7948fff95a1753fa8e4c15988acc9d72ae6c71fbac9533fe554a0ae9bbea2b4a1e6ab3ea0bbe0a9d48bd305d99ea421c6316f5fbd775164c4fd9cc8d5f85e7aa1a80561ea4fe20d56eda8c6ca2a7fcc2d7f03dd5fceb82aef2ab1223b7218c0e76bca8d2fde3b837a6cd8f51a9488661fe60288d846493d6a4a8a4da91f9b9b38c88a163b7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
