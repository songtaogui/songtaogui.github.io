<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e939087c5f37bab048108ae4a1117beac167a3b1f4dbb386046ad79195d575c106785a9e89b8620a8a9d26712e3552fc1c58c920333102ea972e854f1ef303a6131a253cdf892ca9aea20e96a880ca23423fed037d89103966e13d97330c7ea3f1f825c3b2b8aa5a04877f384143aef0c012e9ecea3f3e8d15c1a3b90a325d3f459af3200a0457d3af56ca9501839ec3a4911896fc688bcc943a671f67751a722737d380af52f2d552691e09fefeb8fa76ba60e590ef71a18485be1b6512f55d39632ce4f087fee9d14db7579ac27184c23f86baec0c716b3f2570b00b4aabb5f6c626802c889b7a4e28b1b9c13d91c1980f48b49676f8d9bb6eec2fc83c3d363e48079f3e8ed844ad9348e56199592eb6f331174675e25721285f060934b755891d45947388781a6415aed60c8b75a220f7ceab30aa335330c2dea4f13d3a2dc5c56ee51ad5d8abd50cee3cf971ee7b00cc51bebd8e20a5274a6b9e343872e1f14228c0b16de389f11f6ed20109e242b894d0a55ab518f14df742d06fef1471b24ccc2813f019d9eb99a7c2484238fe0647f709bc9b4bc94ff8ef557d707d7c5e30863ab1b5a78e0bf967e4ff2a473a9658adf804de5f2f0361f02656ce7175fc67a2560cb2ba31f3ae95318b81ac44fe8efabbe3bc52df1bf9ad16a7d18a4ce0df339cfe3f079dcc035e97a0f2e6bdfad6171f408e318135607a29cce3b8bb26ac737f63cc20e6ffe19972962cc472f54dbd980ef8b08415af8916e4fecaf1f7bd5ae7882bd0441954271b985a40f85a132f3e3f608f0961857c8751785dae7f6ed5fe1d5a42d08081f0c58986fde18a025dcfeb40de05d7dae51e80ce98cfab5ae58b42f4c8ff3374b799fdafcf2ddec9ae3c98dc7aeeaf9def96993afed160e1beeb395b273b7bb9190bf460ba57b0a380a9b83eac9963ad2ab2493e7b6cbbeafb6749d25a9d66a069b4b348a9d8c46cf2cbadd3d0e8c0a541b47188f691c806c685815f388169058a07df10ee74a7c4b80bd700e2c28fd6c80097c2da501866f86a6c2cb0ca02590d32e727cb0f747ea45b18471cd65c90f0ddfad783043659306e9018dc7978de4f9f3d73f15a93d0c19012687640435a88b7d97c1e97edaccdbff829fe5c40c5e1acb79101607846b854b067401021d166ee6b5a21337b496b0ec6ab4a597d6b2e4c89b0f3645c2cf6e77b11a5e7303ace14bb9f9130f12cc739c9073946d6fa0c0b19ccf74b0747cf23e3e8c52b89cb0958f50ed50b0a774eb9f0f615743664f99a4ea5b7809a072e3bffd82c9f3c04c37791a47e27dafd2d0ec96418c2b180d221229606f2a35148c44333b9415d5f073cf666c72211b21d867eca6e34b22f537194803b14d3a5e10a92629cf2fe07bc4b5ee856861b4eab4fd8e96ac357dc3a85b550680670a13ce359cfb741f0daf5d00ec69ec3137c32ac041590a4e2239ae6f71f786e8f5d2c90de131ecdf691509e9b6a829d629d732cceed01d70919515575ab549628947fc62af51a9418e77df2f7ef63cda6608e0b74a1f1fe371a12cf3e84c2ab9e44288c3832710d08606d0154cc6335396a61e3c701ddf34a56baf22e719102d1853be4bc2cf0acf8bcf21289f80a5527e00a860b8727c47007b5cf64707e3705ee47ce7f0a5c4dbc2842be0fda48e0507b1f229f486271333d97ca221961349462a7fa9fe7d82e1eb778c610918f1cb0372664412b578504a8205f1400f1b9d82a8c5887e3e52790d8546c29da652b330e6b1f0f394ada0d88d76fc9a067584bd3522f513cf5ea806ff3f285534fbf7fb05199155c096d39e3abd7688bc73bf8b13c0dc4b156c86489997d270056d97f6ec54d688da410a996908cf4927d2c7e4d84a2757cac5cb876720e549cda0420c32b535c3e046d5c92d05921d963c3c5f093792c3706413b75f1fe8bd0727869758f373c95f89b5a7eb579bb31a7e8e297922792a4a90b3eae77f4e9b7b24f52060ae760457a3bd9438c53cd77db2416a14009ea3ac89c5bb9f15125064b38b0ebd8982caf52ddd20f445ad44aa7e6ad338765c190bd2db1fb078ca4c62934994e60ee1a13985b1bdd35b837aa6cc96110372a820a585fc97d9af3d4e0ad3f99d0c191900332a6ad4b29ed4ec9a95c0fef9c1e3426c8ef5c466f9b11c920f5a67959dfa09a96bb85e4401981b971f5cdf3abb1ad94ded5be7cc0b130b5170e1ec479e1099c4b34ae52ecad7566b02f96e673b4a4cad306c292e10315cb964404820c24d170e9ec112dd3aa527297933bcb5d188851a42634abc4be3df2bf6dc9199b3682f76b8377d67d5408a93ddd9b1c9cf335df8420a1f75286cd876c7e5e686df162c39fcdc43efb7318786b03f53581a07cfb706557f97f802e231b2cabb400538e33aa486532de7dd66c99b9168b83c16c6e58413402099da5904497b516c5ca00bf42e3b77018d943817ef5abd79d56e3c15bee523f27123a601d500554d6c97876ca60167ebe6b2119cb82d07e14ef91878a1dd082f35950c97667f21cd6f3d752d9fa011d1e8a825c1e3eec66ffd43ed62c400bd8c98e7ed745c41cb3a554e215e1224677568cbe3780abf2e137379771af1e5ef8109d5bc6834dc129becf00403e0a7ea9ebd0db739b319618d159c079561295b90481b17d1296f7e9c42f1724b7c7bb59bb5f4f1b7a2fb1b8e26e5e22e9b5a19e4cd5365052b8608c9026dc8fe5109eb5b48f19ad5d8e76894bba42cbbc4ceb29f6daa15d58d7915722034682ddd6aaf31651c5fd17bcd46aaac3f048ae78747bee70d46c85516ca9b7860ea38b1c2ce4656d84ded0eaa147626be697d3a882546ee9b23703654cb91e3f3fe466609f9f4f0f26fcc0babac10940107b03c347964b203957ffabaaa2fe191ce78a94cb05f6dcb19a18687866f6b372a667abcd2cd84d1401e2e09fbb7fbe60a8f873c66c2a670ac7668a6fc8899453d8fd70b1068d309eff5a48ee12ccbbb6b86b6ce5dfcabf37e42ac8aa9038e368d583903fccbb09321917c4401b99ae9c0ab54d2e344c7c588f58c88a69eaf0ded10b263ff73f7299098f178e83cbee8295bbbde0328c00747d772485204b738fad6e2fc9eb6efba36bb4cff947962417c9470881c5d6407eb90a88e7fcd1297780c9441853dd6bdb804cd5960016863dd65cc7182872b6ebe46a275e8db719b5989244a19106bc032503d14cb2dbae560b2a41e83d0830fd8a2fc2eaa9bc37af2d70bf914bb2dad37fef621d8555ad66588b93627776efb2a8e5be115c21c5640a5b5d46b95a08b7d1cbfdab613213da9ab4a6726a82d780923a2743bd7597afdb91ae751a8de45df500f8f7b9399a205d5b526b132870691f605896bb8d2dee556ec21711f021062a23f9060b6a9e162e5cc6308d52b17614d9369d24317fb1b8da35635ba85fceccd803de50528405d69845fdfce8d6058db084af4092f10d01fca44eda0e389f259efc31f59d4c40fc9840318ece571180ce1954736a51b75193a9be1fa6c396a5fee1d5ffbc90370e20aa766609a5f6ec85d4472b8793cdd5afa5a199b937b5464ab5ecf319cc07912dd52f64a89bf28d61c2050e3744de28468f3e8a16eef58dfe536ba8ee0dcec70d8868ab336b2dd581b5f877c0416b265d0d50ecaa26c3201f5438fda88e2a804db437358d75ae7e203b5564793e98d28056e638dee2f835042501e3bf1617fe72fb5afde914c1e4d717bfa4ce067cec2e83ab9503a811f65bdbd68c34c8e54b6a757e65a6621ea5d2deefadaff25ba7952211620af97f3df28a8aeba4e07050331ea3b2da274dc9d89b7336536e697a279b0cca4be9bcb8ce5a61d22927755c4b1b654b73e479dceffd8c51cbfbd1b2fe8e3532645e6250b24afbbe4a1d3449d85ae06e48c3151f7e3fff699b5a15e0ac845c0e1bd386e008178490fe4cf7e37c822554de685d168c916b46fb6a8e3e64f719a04434108577e14e276f8dc017771d0fd8074753ce846af4afac633f59529523db53cba7a1da4f0b7236bea0790d239ab527beb882a3e768e14be66b48b144d665cf0309c2896ab42204da4d0a3aa47b604341ffb5f674ccbfa645598309ff2e46a3317429422b42290299475d9cc8f6728ff882c045f743b0055e668af1115d976fd9dbe47c90fbc64190d9a802507c5102b2aab482cd01f6fb687d7549a53e573d4ec27c685845456ff09436ca1a56629e2c88d6ba0b53ed4088d9c36e064cf6a411cadf10eabe4791b00912512e92a4f8f13a5256bbbd8e59a392059c9e2799f6df62f0cf6a8021df14729e288daa3f75e3e32cdd096adab76213f1217a2ac0674236616a3955bbd96924ea51566cbb3bb1d3f86604e17370df86a5ceda016c14e3d7cf539cc0473623dfa3b89892790d6ea575f0ebc5a10b12cba0fef522a4640090f28a0958c0f96dd70d3743bcf34405c74983f51431ac8b320e057b4c5999d13bfeeaff784646e704ac9c9961cdd6555d770a52c629d0ea17b958154091ca4342c2b4fa2a3de1d541f74e08c4ab89af4a84036b2717b7de42f6d96f48711ac648c541fdb4bfaec36931cf249112ed9abd2f10fb982690576fc070bcd9bf1bdfe2c58c7f8b5a3420d247fb3c82cfa7699e3bc3aed516960d4bf4ef8e3f34c4789a7c546f4573b9c5950aa24580c348abccf3694defd5f169cd2035ac3217e08e07c0b1b6c81e84d46df6d1aa2b2d97cbdcee4159323567a7e4752ee1e2af5a28a536bbbc407406e564bb64aacbae3019408d601b1a6303ac4194ea389bce2d91ca1ebc3c7dfaa538aec1380c23a6dbe44740e83ee554aa6749212139974b0d29536dfe83a589566b73680100038ea79a0eeccc380a531fe63da2dcbcc5869f5de051d1f3728ae28c7b6d9edbdd38056b63a864f20702270fa2c2725e5f1b74e8e3df82aa41460ca7a7ec6a80e3adbd071f1e18d3339bbd8f7796e3d778b052a83a5cc56afa64cabb1e317602e9f390cd1b7aa252406b8c398d5c7c00c5150b72cec50c124a80e95e0e5dd7c98e149313d7601081cccc5a650e97365e8e40b66b3ee093d31e52d6c9fde88eccf1c07700444a8baa1e146d927f8c80285632072b0892daab3648a06bca31d1a4de7c6bcfaf8c6fb6cd042a0e233661a0ad36e0a4f07def9daf6cf0f00ceee20b9ea2f1944fc4b1ffba6f8be7968764aa430cf5a0c34dbf1418cf28a2b615bb6db07b8d2ae46d27e372052c055a24dfb2860b7b55dc608f3f1e2b3bed5135b5c7c95f822d7ddfe1eb20c909196ba84ab619974aabb11373994a8663e6e2eb81a93d4886b6a2d40f1e5282a6927f7b7040dadcf4e9dec7a9f6632cd3735cca7915ded9a6952ccfab89b1165b3e05421f079287eeca990e239e835577821239a809de44424b096dff5d588af1e400071b30468dea7c405e108b7fe9b1559f90a74f00dbee79fcc33f85abaee0339f482fa08c024171b19a50caa4997a8ecad5ab5f9e83deb457605f8a03ae216bce784768de9397da7aa4885071fbdceffce2f5c553b9b110216e2224144f2294a1a4fb44341e17e4e412baf12901f8955df8d0ea01da8387f97b2fb4983733089e94e268918f8c5329cea3779355ad671f3e9fef688a7e513ce82462f9d21ad25249b3dc6c2bff9c423a598d2ba88fee67e7f40a6c46424491104e9ee584e9da5e85e0ca660e7153c23caeb884dcd239c0fda8b0966e8dbcb2add1dffc8f9d658cb14f423d83109ccd4ad7a96f1d763bffca4a7a209658cf59d7a4cd0846437ca9d37e598a3b290dff63d2b0488bd1b23dbf8d0e4468e254b284752ec2273b70a1641d1c6533730c8f2243e8d780efc4616aef301c202a7b879f34be87f21b4a7b1f335ec05cb80e163edb2553eeef0fdd5d217678c2c5de43b913a796de5a773c4b48fe5dd0b5f0cf6aad38d5646b4797faa2f40d2bf7b481aabc5009ccb90d3929010890eb627599a706e95d068d93bc4256f7767e06775aaac6b1f0543ac876e760f812abe717d9b2a49315f06faf80f159bd26a3b6ec3cd6e9f6165ff1ef92402ed6bcd91bb398ccef4a5ed1ba3fd74fc6daf7ec137fa88a24920ff0f3bf3684962363c02cfe1b0346e646b2786cb9287ec7236fb810b8850fe0e4a83864265037844f668d623b2fbc2eaa2e9553680d4acd5e513333330d2fe34d1b7b8ba5c9b9a5a924d69319c79e7c703b6619454a674d345199c7763409bfcbcab3abdfe084b4fd8d8cab2f02ef9a5b899c83e697ef0904f74ab16c03cf2353b2d82f017dc4568d5a8e31d8b720d4996bea6279f764ef52d42da1da1a7f2e49208f32a908659e207b712818f89c6b0a0155dc28cf8e7c9e5e2658505a80b1dacb228bd6fdfd7d58edcc4864f8e5b231e69af371a0d50655e41a8db794c0c64441c3b7d834cd380518366c86009e3074708c70e01d07bb591a297fa148bdc83dc194f15597651d791cbe259e9a5a2376ac2957575c58fc89edec12b9523c729552919dbeebfdc129747fac5e3eb897c658083b36195bcb9de6b9c0413cb948e1ce3b40fec7e83f2a7e5774c9a4b85d20144509b04bff306102025a5c65443bcecacf26b64f028f880d1080050c87a1d97107f3ccfa6b82f2bfea3c824849891591ab08338a407c2eb8ad35a97b088dfefd0dad5c42ef6f20691fc1892887761b903a61d55991c57309cd0a4a46ea983b0e3b4fb25ccd3a1da8d380e6f56cf13495d81265c6b925687527eec5ea6d6617fdc3976cf105fe9704df61043c75fddc74653ae90926e0ccdb21c336b3b36f1faacb015650f75e7a35025388fdea4184f611a121f52680fc5f1b9427be69a2f4ca93b80cdfcd6d914f8e35128d9cde5b767a1efb6f8c5ea3c752021d0fe38a84cb1a577940771a6fd1cec7d9ae46949439324f21234b69c195b52970cdb6291c5f8f294676c61818e2435cbf3f2b523095583b16473c20deffb583d1ef9e06f3ca866a92bee4b7c69333bb05ece9a2c61a9b6fabfa272370cf9e81958ed0aef326665256bf980629027ab962cc1449d6c553ff444f9adb45b2e9f4160bb4e1ff00fac141123f489358e9fd6e0db0a816a64393ec408c915824010882b75e187bbfdd946711abc7cba1647015181621399c40a2a94407ca95c98f945a8675dd148d0efea3022d85c160ab2644717c944948d91da71ea33176abeaf5df8594256d1d8c0d848f0b42a3ad8523b3a80791c2123f7891ec0cc70501d9923bd3ea7aac370fa7d59e77bc3bd64d264c192fda06da733631a0302da0350de31de4cb754d38493194ba718831225f9cae6163dbb946f509589d9a53c0f7ae7c4a903c74f6dbdf1b8a14d4885f75cc75e12baaa58ae089889eafb1c02bf1cc98ac5df32167eb60244c3f49069154e1748851a0704dc2125e37ef0af71a64eff5b198ce0b1c6c5655824b0bb756d3bda1973b54a87640c404e5c0ee8e9dfbe7cca99a0ea5640e4251977cf1f795b68410f9c794512671bf83762f869197da22428b5821a320289c84c291fb622dc06a4b31e9e29ae0a33cc8ad3aa1ce98cf69b629b2c19c5f12bed5b3ff5c956edd7dfc0a0ae715b1a0f0204aca4335beb4ca43b5477bcfc70d9f78c5b20266ec8a955dc35fddf4513a6e910d54b7f8c5a8598aa6ff8895501d48f7bac10a525bf2662e2842b698a9f02afd08266b8cd403bae4b727fe21cc59354c30eafe22200ea5c488df6dbfad20b4eb88317fd56af823aaaeff12f98f4f58008bc17475a3c7dcfdeba96895123b2d008d2c68876ce713210c7c978e5c332d7e5be7aad1aa5065305f99779d0e08a15d782c9533f6ef60e5dc6258b33cd197c6ef415eeddef6dc25d473028359964635286fa06e6ad00720e1eddfa6bdc96561f7413b94dab93d79f482677697ad5cbbbccbc54670c81663daeb180ea93eeb7690894b56de3a2e8df66e32341069e0f94ab19d8b0ed3bed051d030dd9f726a992dbe43eee0a82876d63dc7d2e53265a8dec76407b89319dd187a0d1ee23702ea20a9f993707d04a80717a5dc4451e28430ce1a5e4213b41f89579f84445e41831237999e5b6a4c3aed128822f7f9b137a911bdb0c1fd97cc66effeff73c0ba4c2d158e7ea852befe699ccafe721ac0156fc2d02be2dffe18152d9f582cfdcfe31dfe76b3fdf2ff578e9e5bdfe69c67c12fc8339adc50705ee1c1dc0ad9af2a03a2b9f269cc45ea9b69062fcb3844663d734b76eeec76f1bc827f76f63fc390c60a174304b17f9ce5d8ba39ced3ed8d73c45518ca2909eea0d9c85cc923eb828aef83a1ba7d7f98d533edce0d284ca984a48706c8bf1c3a8c7da6ccd8e6bbba4b8e215112f5cfeb3e33e746b1640a4f4c66e11fafb429651306116bc50dff902a979dbedd5fd7bfe6ab5b71bd84ed497e1f6714ea8d636e2a476eca7bee28efe5ab92fee5bd70aa72185767bd78cea46a65d8fe6bafeb36e799978e4c7a90a1bc9a95f1c0f2c22ab8140b4a6a3a0de501deced9725df8f8611bf7cd966dc04772fadede3a2c726b9034b0085ba97d2fb35e7425eaa414eadd2b2e20ac0496058f2cca020abf303668a8e4db5eb62bb6e108f85db0f52442180244eaa4f0df24cfc1438455f5840469a98175ac91a49b293dee1bd3481dcbc0311e41711d6b812cbd39a62132fc6982360187ad9559b323ebb4c66bd58281380b41f4a88561bddbd998b299f5c1fbeaf0af4452efbf5806ea97bf2e3bdbce3da2568afe59e87858f7a1df7df7be7aee7bddc75152a2c91bd4fc55f237b559ab278b89964aa6995c74941a8a06456c73a3414d96179973172510934affdbb3806f062eab58987bb24a75aa25ee6596c6d5a23bbd4441fe4661e243e6cf440be8796c1307640e8acc44efe0bd64cda31983ce0096b684d6ce145d4e0be260dcca043f9fbabd1e14ce00a5f55523fbaca85899cfa28e0c7c47faff13afddbc9d741d3c2fe5d7b9b6138ddc4d143a14c531ab5f1a64efde3c48baee571edde2ca6d7a27a1803762eae4c71e075353427e40bebcc531857d50a112b20b1c87c2127dd5deb8dca4ebcdfd32666e9d1379aab817e380e743f804278e3eeda0f9b14eefdf6e3e9a3e4b98b81de67944c32d23db1fb29b6a9b53cf0fa69df1fd1382330931ae85fd44f21a610b24870af1b3c732d63691f62c2a24da5233ab53266770766fb26adf746f7c902f3c5eb8bf6606432a045cbc8af6452f9bee66e7ae37045432d6ebee3883dc5900dafed058ed63fdc975b1b0303539637c10ffbc3327a6afeec1b17d4f619e732e4b40a8b7132f5225e53965204ee69b587eaef66e8b688dffa3c042583843215dd2d77b9b9d6557d452e2d744570bc9764f3e66d9cedb60e5f161954c5257b25e5cfd473e3382041d893db70ac7df8e159a7b851d4a4f39663f310b921568e549170d0be02a7716de1b49baed9294a2129dc3ce539ecb7fb286766a3a3775b2ee0d265249d8f7c5bc51dbf99e05ed8eb65a5a8a909baf8cfcf3c19a13ab903a3840060d76809a37fa8f2648e4d021f86d20342029989e6366e79fd760f9e4abeccfd745217498396a7a8f525923e9a22476d16c7e15e9121c10ae5252075fd3fe87615588dc9363fefd8175e03d4ff1f731fb70c47ae2b7ebfa81bd25592e35fc00eb5ed8399ca18d8d2a09b9f0e31fa1d34be8ae53d24f3871b4772f56b14ba73eb388c90d7a114d9297eef44cd29b351fb7e532fd77ee1f8262109e91fd953ee9a8e1d29f0fe267781cb8f160844d281d92d7ae902c854abff7d0699099fa11082968464b944c60e1393f9161a57e42c6d3d137056e05e5a3b5cb91575771a6095bf6ee8b3cca11b062cbb9c63074c48b503eeb76b2e94336fb8ef7675346ed8142681626f5f64a5cdc49da4065a19364045b24ce1d5faa5b2ff9b8fc64e0d0923ebbb40a66a98e66cdbfd581819d862ae15520934c6e9d88fdb1d0ba73b9558a8ba759b0671a4da72e5167b9e878d2d278da2a6b08c95d9937539b8e934ae079fc8948b7f21ba27491f2c19f3068ab82f5c1c78e6d7ed28979f873657d27f64d91608f3b7faa0dc624aca4118d99085e9dbd0d551047cf264d4e4bad07009a89747036bce16615ba394b950d943f845b50b48b65b712e11f9e881720a3925c1d75e4159abfa3106b92beb0525d61b682c3822b329ef3548d287dbaef4c0b9b065b399cbf4d2dcd934bfde1e44f229b31b57cedb53a17fce9500c1c1044802b93809001f9741698620f71dc34e6af5d8e51fcbf45adc9fa32e22532fb3d70b11a48ae75e5d4890298fbbf6b10fe283ba4a68611e39367685138067d999c2f8a54cf42059f6e84ba49802dd10d28577de2610f7f1a983dbc9a140e5c292f0c7f88190f8523109776f4b4ea7749a45f92193d71ccaa7bfd2c21fd273c97078e676281255e58f4f169da2fb495f6c336d32de112c5ef4284bbc53e32c49bdd9b56a23d1b27b19d5e0f4246dd50808fcfd78f12512e7848cf53a494fba2aee77d2044ceee698336e2548302114f3f0433d139bdb2fe07e2559cead7cbbf51d050e7a99d013c7c4bc82cecf50a823c0990a8e12239a47f656451d155b6ae4488cbbc9ab66be09072baf5510efc38f54922250998419b59d5b0a72f87d14f6623ac2098ad514dbf8257c4926db2f841409c1346060e0e0e81d8f3bff9a39e754423fdd34d67b0216e9d776e53b9ed5fd1a7d0edea414736be3df7fc3374785f5a0c22ac366c0ff6d3ca48bc177afe4a7ef21c758d3fa9f113108a0eb65bfee56b73c6654d028df4a5e590e7d2e18e82674051154a5c21e30ccd1ca417795955dd62c0b4b0c96380474e5bae8e16e71e8d5d7ed292101657639c12d455b6758eb9d87b0d353eb4becba22f3525217cff6680b1da39ea144ce62244ee85669fe6612bef45e601f0ac06d2f9042d15155aae0b3450ca9ca2a9c05c8825f1eb719622754a1bb59bea815fe2286ae99d47961f90c471b81b41884e328b0f7bdcd185e40429fd5726ee50735266139868cc2494ed5682671f2c18ad4eef2721fafbcb0ed39dc5d629d70c32666265c06e0e866a226173b5f5698755f3ed908897c0fcf5783c97703fbcf23f0263273408182467fbd51a59bce4d628ef61013e3f1fecdbf0421ee278d34abc520adcddc6ab1ba7befa2fdb28e38d40eced837d8bddc01b06ee429d7962d7de22509c14cef26c2888c951fc6b51e7b6c52d69b13d2a972d0b6e45f7148cf032e84b2be1bba2db93d50a622654fc9a726881aaca2aa7455b3c805169d06e0f24e4b77d6f45b075d7ca7c3cc6ddf714848ac34651c86bad1b4ce7ade44d1bf410a9229ce604855d23a0e2ce86af0cf2f23797e9146130db2fff554ddb80b8e45c3e450af88cbaf0d2adafa367e9908667ce443830c7aa13051015a54a09d94a8768a0d956b85638c1d3c8d0f9655c8688fb5ecfd410d756c1a9da971c3a7d6fe604ae995a20840d89486d0fa20f73df799b6b1c3bc93751152875e363030f71db64801739fb14915aef179461aaf375b490943a4bbd1ef509a68d905dbb5e88235e5530c4887d60300bfaffcf61237884b81bfb59efd8eb8ed5ee57630410edce8744e1d8ec970129348d925dd17f5a936065aa9351ea7280ff5eb33a7fd27bedc39896748493de40d2f45f7fea162d247acfbf1a1d852bbe3732201df3e78b2e7539fc5f13636e696361b5733fe9913bf24f6653dbab4d383b43b12f898ac66d4a905c474171858af5301b3f67822f44fde19dceff10027845d369c8d420a8488ba3f7c1915e59e53feab56a12b38ee1e81468ecb09ac39bd748b0e79a34944171a3055aa40b7cd80072b0b603719894163fcbf532e439f16bcc97efcf392af06893186a0d5892444a5a4fe509e04b32c82bfe2e027297384af055a9271ead6097909a79ab62a6ec5d45cf9fc7ba27b540c5e602f098d6d888d61bcdd7b3fcb21080c6a3f95c41c8a213a5bfd670cbcf14a3a9726f933e9890d4977a2f8f86e387c32c0feb9537df92b0fc5ec341f3acfb54285acffca76b253911b84fabb63166d6dfadf37e25f9b65820f30a736e3452cea73b70a0bf0d2560fdbc0764767065cefae4dccd48ef644ae21f67987a5d8975e1836ebf2fc984e2bb62754818bce3ec6595ddeab0f3aef9e658360503d31c28e2cc9e975b48dd9a0e44369b5773072451324db8994eebbb28db4aa29bc013596947f9830743eddfd78417e15c852b06020e8c88da99ea97b6b301438d67433414644eeeedd646e03732cc674ae7e69a61cc21e9a194fefda60e58ece4b375f81fdfc7a59d8db2889c986d40dff7dca60d103fa41bfec97f2fe5638316e884be1d6169b2f372d886b9c0081195cf35244adeb1ca538a72ac3b33abf7c1571ee3e435cad5fc20cc3dd06bd00996ffc0c2f901e162c8e0ce6a0afefce7dd5819bf695c779420177652453942718de119f882b5889cc7d0d62052b3475a84d1014c1c61113b1a8cf2d34bb5d2a49122bf1c74fcf50a830587252010ac4bb4cb4e8b036897cb7bb34c897249a24e574a18e00c6ca6663ee3252a8285284b80562db7c5b07a694d430d9d04cfdbe5ffc92a736f33db6aed60f39b285415376b01b651f4814e1e6716ea644f69d015782b25539e9dec4272d4ca563eaa43b2cc22eecc8fa65fd0fa65327856e8ce57123b26cfd8ac63b41b6e0880c1ff54ff38ea15fa0d1913b7ee9bee9481c917744cac5410b223dad0cd5f65b5777cf5e2e74bde9f03245dd5339dd556c9732f4a33ead2a6af3e05596306c5de198d1480e36c25bf0151e9929d6b3e2fca96cdb80dda9c3e46f5301b7d67bb5024d5f471a109c44e6c72136b2ac9a8937b8111a69d24ac29dddf94434b1c8af8345bf47611d0f4eaa1dba6d4d41d5b9a798a155dc414aa2ccbf9e1aa898ad8b990f6f93181af093c4c53796d3c5cd9425ddaf7178584093beb1ad9b568f46596587b282fc292ae54b058d2ed7c3e98128526ea6fbe06999972feb4b10be8c4976472470c08ceb7514ad10f79cf48ba0096823c6cf7432e3ea1635dd12fac7585df12b1472503bd4c58c3a904d72266132c87771a7eb78794815ce9ef152e5796fff485ebf25c91956e7836406faa1ff3dd2900ee7f06a9e2e1e9d56c6b91367d712cdc917acd7e2151eb44da3b50bb165a0951c4944101d268615a7736b8a67f2f050089709826e1a15d9732117dea7be175dd9ea12881476d73b621e5d8944c1b9c63fde66827ae7cc0940e243bb589e8b4851e4f4e20df2e868635bee4487909898bdda731980bd4601951960b1f2ec5fa97f095283a90b5d19fd35ba9b15ed1468598c22c6b1b17eb7355afdf60f2206cd2a5567ddebee96c754edbe360669d068d6273fce0d171f96a34904bffc2f35d050195df5ee13af48c0fff8ffad555e2ebedf44cb19071c28f26891248688b25a50a56755fed429b710553ce979fd85625ca31b6efc71571696e6708836cab593581624f9c236b37b635b7f04963ad63e5efcb5209995205b42094127c43fa4f33fa4512cda79e400a4b4ada632e3ca72f123355332612bae31a1ce50fc98b3702fedb0d15a056e1e67223aba91e45a1d136e742c00f18b235df8e426a476cc3e6ddb63d5d3b312b9b05f6d38b44decc27731bc598b6b386a1b9d5e8bd3d1898e945df2953ba0621615a4f31e8c072e7e4af7fef0726cba80e75de93b12f08de359295b12ea005b9d19eeaacb7784e63ae9719d5a5b7938f7a45fd82f19e1b62f7fde53ac8e96f5f1bc5594bb5745c1fece63cff02c3165ff0eb3c95aa2edc442b37295c094694ed361625d09e1b878571d81ed44ecd3be45a981222030461a3f667d15a71d9a0733cf4485d8b6479872b42af068f1269b8d6ecca3ffdc4b112b89416392b51b07b6e67537f86bdf50711b55a740c5e802731fa23f11d3b32c8946bbb2465b8a5b6370598bd3a151ede1842d9b36c0ebe22ab1a39cc2792c9bf36e884efcd3ab42c59f3ac6de3736807ea04760eca2b793d41cd304adc6e658d945b3c0656d0c26c162eca3a54c18e5ee141651a8471ffff4ce5e00577b1ce3974f0fb36e2ac80f64868e268266b42109cbcf552ea442c670babcdbc9416130fa97602cd267dc2019d75e97dd699333a6dbf13dc4c9b59e1ccc495caec0c23a682bae289a1f9749ca52e5c286924b1553bb4973c06d2203909e51ef630247b0d0ed8919960cfde6cc701661eabfe7b3cf6d5d5bd6759b284c4e95e7f0a6ee335d49aabf8bb2a168bcf9816c40a751bb4b6a7d69987e733b04e13b1349911519cf029bdd70971471be1bac4befbfd151f7bab66c09493d7600706a964c558b1d0febcf252ecc9cdfa20375f8b594c1be4cb834819da327f67e2d8b65a86e7b720f998db314e64b13eaa23905ab4c3440ae5a9b072502df8c4608b617698c9ccc7b3803c298530d9d1c8d66d1acdd2f5b2802268ae6e8ede76ea765e6ac3b39affdcf4cf89bf6a968cccd710a91af351ff25a8a8a05b2b890d107b160d5509be7b9cf1cabe24d9ff0b6ceb1b7af7a1bb4db2829d1e01b098d7d35a7badce6b606ed1d6891b653c84c4a0262f3233d4aad2fc6988813e3220729761f412824059a384a90bab4550388d19ec0cda9ae9f8c656f12fa8563abdba9743d9f2a3377afaae370c0b65e3e53db4b29a4c3ae9bee1eb219119b9bdeccdb09607f523da44cf4b213b7abed5c54b9749515176ad9359a054f7511de2c8cc6a6c5225733c2372195e71f9779492f3a596e10267516107f33206f93c6fed8465f2e503e54255eb4ea61c4a7725dd16df2062edaebe5f08287349f2bd90003ac609478f3cda44093f880b8cf98d52a03bb6ff0c9fb0584a0a01eb24e97e699de152c961acb323ce940eaeca23b8c85d411d6e3162a085e9f2d254f3ccb3477921ff1db95544b19c37676bea62105b29ae7ee02104485af7529d7356305d81182550d63aa882c20e29652b1f0180f8ddba65c874a88cbe4c3bc1aaa754e9c9143232b6de169e95e0d39c45fa379f448e2417c02909fa766a31e968ba8de67163cdc64895410c146c7fef371eb34e24db184db293ecc7313d9347972a7308d92f6c4847f59fb53493df83d41378019d00f338df2a41555649e730cf1325400c845488ba307481c76d385afe92d3b63a16d71cd203ff556fcc0c315a845752c4b4efe04594176907e378c7958d6af0b26101f6c346aaaccfb28dd5282df074ccef237365969dfb59b7551a8d6593d3ed3b5d2465757b5ca981c86333a6e04eb7e328ac9f4e82d19228fdd07f13b014971b92726a20900a8baa941b62fd13242b981c1c1ae46fba0e1598cd9723c1d20a261d33715ea3321edf28ab534b7b96a51881a72a334c89184ffc6d4d8d8c3dc78b5a9168307d1239a170015943c277224240637724de6754be9ecf3f41ea7caa0c350b4bf54430165a624c0f265f1d29cec977185ed435f4dd5420f3a68ec4de74aab1134aa4b657082ad43456507c74abfb1b691f560d746d5e7c0edf442f98fccff50d9dd13312b884677fb44c8aeae232569b635b62b6bfbc1c5f82ee3dc445a25bb38f09b400b2a05854886a01c981c0b21a26dc6a2e41fb2cf6a2765dfe0a4e6b0ec6b7a9696eeebeb6ce1bf6084e3b96bf27ae3171711f8b7c629418936ad9ed12cd74662eb671a7742f3f9042e5c71d06c22ffa62b31796ab22ccaad9df2a2e1b5f845d7df9d648c8e0c0a2a2099b5cc1449986ad8fed1d922694d9a003adab538274e373a844266312e3a48601db41891c2275cf80eef3accbcefa3cf6b7abaf73f0544a8e0390ccd89a64075b72f0852a074cbc392425b9eb095d1e1bd5b552051f06e2bf466f67a8450eb7b954cd194d2f25793b79336a767407ec619fa2937cbea234ebdad87b9c65c86b660d6eff87055ff031c330662d4fb0e5d15a35d67f9c5c3e4fa1fa65c4b2f56f55130b50f57128e61d5418c7da51e8950a3d98f10dda8670ea1af2f5e265bfb0433aaf3562e2f49509e990ac88f0b4a50e3f44a3d60770be81c144a1586452f97d1ff1110e8842f15c1e768ed0e5929da4827bdd432f8904ba5b1d891afdd908ab2551a5bf2e5609e004b07acd1438c155086420e16b96b474ba202ca1bd21fb4cc92f12c620f161c9fcbee726b04ad1811b39f56afebf6e3b91fe8e7b9ee8a33572de1ce9e4aacbe3dcb72a746caf56ff291cb52569239e2ff5cdd51b8efe730fc12d51b712af1b663ef81db1b40298d5b67da9a0b59a7a27e9eb0b71b895d68bccfeaaa694be899856a7f3c9c4e2690c9c898c4ade0df263b76d8f4ab6bc2133545e29cf830a42d75cb730c55848ca27c5c69c3635b6faeafe746f6e9522f4816f9beced1930ccacb56e55146b6b95a92a228dc48ea434ccb352eea4cd1f68c5ed5049d853570c1280b5032f4faa31759ac5374ddbf8df13ac3054dcf382a0ccf20051ed04bd0225ed7655bf8a720c587f54dce48bb55b85037e16f2595cbba53461b1fc7c705ddee10e110b4df3dd98cad15acc69fabe0ae10f5e77f2b1c599d2cb7610dd111b1a0fe3aa9b514832619d1ae3501194730261d5f4785fb56ce535c95524d02bee274d663a88db64a7c7a77e2e87ecb3ca01ecb060df9e3e736f9a89f652c8f67891cc3ece6cb62f81fd0a5c8bcdf0b48c57467f0ce201fa84d5c4f4414a6cac0e6484dc5f8f5f345325376cf4e77067462986b1cdfea225fc04efb093cc708d70c3e484d2c1e3e363263f3d39a2636c0dbb5b784d1a93569c00dc11a6142c1897079095e80f1ebb6f19d7d7e52e46fdb678cf0fdaebfd433446c993e36a9540fdefe3558ebe61618cbd6d2250ff8e785c44d2dbdaa41e5ee40995cf5e9aa0927cff77313c9a8e9de5d9c2c38eda3ee58b310229c4fccbe8391350d768e1bdef8d995515a3d146a1a662ad3d2d02be8003c10edbcb1626ab0039a61dc2c22b4a5c3d72259904fefbfe450e13996e9f7dee6169a19c5c7ddbfe874bc1d07abcc0c0395b8b74b16844ba65c767d230487fabb564511ec05ec1840e83ec35f46a262c61eff801aae098bbd5feabbb6080a56fb3403196448d1298e994b144b39cb7cd41a876c4aa7020e38c530cec216610fb3e19a7057ca71eb55d9c906f13db8ec7ce32d6bd5505b0c290fdc356495f84384ca5ae3ddbce98c89e7912b69de4ee22eec234b4f77b1da59c110f1473e69964c27c9aa24af103613f7d49df1e8ca45432ea9d8e1a4135a3dda1d9b757b171367d91d2436d707e579352beeee7c3696e11a68080018043689736627a3c3289f27d77e4b9d5f12183e3ec3515941e2ac09d163458eca9ec4a0dc282a9d3c19924dd8d767af66af894ee191ae8435741eebfd310305fde35329e2cfba52830605c7924a87dc32200df1570ac62148d5460eae4393b31a8e20322501126c6cc34867ecbb7ca4bdd9fec7905c6f8a3442c695585cc26d67dd2cfde93dd2ddeeefd4b71a87e3d0e05d5811d9c48fd44b56bd97f456948e9fdfa0ba5afa94bcd191aa7aafbcef52d209c7d112a279c175b5b0114038dff0a42bf4d46537415b0929ccff699efc82f421e6859bf42396da3ce9e167a2fcb947c5742f0bb9fe86636d94367932780b0038c1c3d143335d2ae09476ccb7547cfab3d438cf757f3fef1c7e5aef5d7ad2d2c9fc58d4035a4dcb014ba5a98883415df47c964cfc00c6a55c381181e82fe58bb24901b923e71e18cb6dd44b82fa2f05828fa52bf989b82f813ad7b4b9acb2726234cf54937b88f30dde40eaa492814dbf8de3fa222a16c885e674a26107edb5aa035c2b56da4b6426b151888eb0e66bfd56353371d65f6f065d7c6c919b7c8078348f62c2e921f74cb0f58171474348f159b5724f30f03141eda921e86b37e2f70373296767b60329f7a4e18e43eac44ec9c15103f6f13a9fd952f7e65e52628b49c87f2ccc1e2f2bd0a1c7b6f62a07ccae702fd03e78408e46a730d99bbe8f374e8c333672b9695d7241ce05a995bac6ef147cfbff4ca0add77fbcdb7905ecf07adde0a822a5fdab808b5bae73294103d318992d8756aabf8898f36b7970b993f31cb08d71538ad046f69ef92fc866fd83845596f5cac660518e694f5ddf17d8498ace43a68c6396a8460b9b98d45a6555989d5aa87a3084eaa1b4371de95d068281a2c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
