<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37197fae05f09c43549081b818d3abc98a12fdaa86e8e2a2143cc73a47a9eb834b8dbeb97c222dd2c93f0abbbd5bc5df7b99a6475fc2850bd2db93e16f7b1423626aca3b22a4844b717d1ebe89a36af43f7a05ea08477423e871e7db859a44214475a8548f74fbc91278723fee081f4d66db3d35ba8d3622f74f9212e447e2f579d99c715a8d1390e41258f4bcc440b1bb641926ec5b1b4c516474766aeeb3ff32cc0e77885cd1c7a9ec7a9ac6ae68de0b016b45a6e29eb8e68f96ede08650d71b3183dbad0d1e220f3d5a6de5251c61ca47cd2c4700c64ccb65fbccdd24a289e3a0dc2406ea1d9ea63f409ff6f09843248574dd2917c589639f63dfb80a74f7e7dccfa02e5b0ad6c459502c719e319c2c2a3d0adcc165026803520005cb8b099258f7f9bb92f08626b9c9b0decc1ca3cc93c115489c4fe0a5a4ed99100f4b8cdf95a8229222d964fcd343de1974ea8a6380708615cefacf92dec65d8d80d414879f7ca4d326b7621ff58132c0814907a92fd15403da5d8920f99195980b9b45874a9da9b6da4da41486266c6e6133f03295e2a358e8818f5a2fc324939d6b7d4c6eef4de992c6e1e86fb8cb3885865d788f33bbbdb6003e984b34f29cb91d002006aadeb59c5ca90ad7d760fa2c4771f2cf168ccd5efd1f0254d370c2dbe23211561f5a59a18ba1ed76deabe9befa6d7a1163ad75e561ad26b6f3ec1b5a3b3718cad4115436868b8840b7681fe5aa3313a64ff9e72c33e4139a656077126753ca5c2f91134cb393fea403d8dd98fc1660f537894f88ff28f28ca219d303efc3dd24dd58c0366e66014bf56e5a7672f7e027f7e2649429e7edefaaf3518196f1f76a2a0a72a8f72872653f8752fef8db75f94128ad5f9113c0457b29519de2e8963962ed3a31953cbd646d793ed858ddd37cd93d514f2f0a16eb5d7120dd371f7dbf6b5dc25eb110231d1829a8624dd75f1ee84e28771db759e716e643174e66fb1c79b7999acf9a001d0a95b7dc5eb79da8e98cdb49dcd3c04c65d4b93b978f96b167b29d11e50157aee8008d514af543759dc7c05cc090e40f5d94f521e79a2ef512c83e10e7a08d17fee0d5017f3898cabfb23d71edfba427fa6df82fab2897789b25814e96e8702965222110f2e709130060e27361a1bd5b3eadd61e91bc9c3bd30c2797e0613a3f53bef4025a86908ff3aa1906998c60e161cf79ed937c6247f1c4682b40b9b311872e87d2321c6972dc8f0c449476f8ecfc874cda2e1af725a48f4bbc996472bb45c9ec27021952294cfcbe5902bbf1ea2b82e465afe91c3fa7cb63deb8ac37b67c0ac9d279ac2ca7c5d76f900649702cc609b95afc98f62e00804e27c9aef014799828c72d45753e0c3065c581e15503244075c116bf1cafe50fd2b151f76a9725dcc7ae91b7bfd0dcfa97559829875392b0c92d18b25bc703dcfb9acd9ccb037bd71c83f5d3dcdb8b6a99fbbff6fb1aab870ceb446daed891b5b6b518605697ef6165fcb3367eb255276cef94ff95b014887c78473b1d59e69fca81d0037b3abbd823dc60790fe6b2c4ee70e5238580b164428bcbbb07a94550b1f3693016262bff9e389e60934beedfef9a35d43b57f4f540bfc0c0e739a823bdafa4fff98ea43881ead4484efd570720d078640bc5d3f22603f244d91c779df5661a1707b230240e5175d22fb77b8e76ae70acf2368b7bf28072dace81783998f64fa4503a22df1c7942e95aee93702027da8f5076ba5f2b032caecfcd3e2d9b0d4775b2ef0431f7f040b2d7954d9ad3da27cc0fa783b8fcceb934b63274cb0508baf09c80e27d420df514a99b85dbfdf3608aadee0bece296ae1d11eb4f2b53d830b135e1e72bc64e929d909f7cb2c80ce6e742f34060c69bc8bb5d6a443198b75a73feaddabcc573464fb6f133e99f5972789a32f86cb7c81765cc035bb73a6de5d07ea332d56ebe20f091a5e865c983440f56fad57981bba5763ee5f09daa64c273ff05787b7262cc0ed1a115f26fd0f62699308acf58ea7cf568c2b95c69f036b437a5ae84ec94d4a962a53cde9734945ff88d1591c199bcc471a211fc4879bd2e9255fad459bf848594d46895865ac69e99abbd178a6b35a22792c221329051893dd25a898195e2c5180ab69d3f43e2679cbc358d380b3e7063fd10c6331c8c6c59d4869a80b23a7e17cf74dee5b3f50c7c5c0d75897be6f999308e7461ae7d0bb8df7ca7d60b0bc1d943dd157717523e5e91ab5ea225d20727daede655f5e0ea48c1ea8e8ff88529fdda8b6d8bb7cd1db9aa5d1d2c85c7b20b1dd995284136654c590ab0d72d4633a1db570b884a84373f29210822e72de979483f8bb4b4242e90996ca6bde7f20dd6a8801a3152818a73034fb6792079974f14f343e76d445bae89a895383d97ac42da79813f8485f386f99c18722b85682037aa709c01a592631db14c74c20fd77726263a1e494efa018749e7f66563255a21d007fba82dd30760dd925c66df17f38308e1d67db7a5d3929775f2af96159055c2f0f6cea60f6578335bcaba44302e02f5f2442e5cb9ca358fb7c859947c394212ee23a9cd6ce9aac8c1931b2e1a5bda65fe6dbf244ac42c461e6f9c621594ca188679e23d5cc335e7f5a0927dc6244d0aab0cef720281aa6cf1b2b2d00a47a283e86500ea0ed540611b4e6456527f46d339a3e344b7f24ddc016cf6f47832cb9d34c9d79363b8641b004c43a91725b0b730f849fdbb751f96b8fcbee2537b3ef72944af6693b69db1a395aad3318377648802f7e37234482c32e16e682647d72211d19dc674d8efe56aed0944a5b37e12c54bf9d8fdf1948c36a7ed599e010bfb90d53a8cdf90da679448669db757f62f271bbf5c6b0e0238ceb8c27eb47396ece20a2aaf8d9681da1565d36a494111728a90c17decb711d491072cab946e95f53197ed93ef70f10bfe50a81cfc6f7aa904d4480300d7b95de4cf1af4d5b7006cba7410d4f89430104bfb83413b0871f0510543879e777c5b2ea9921d8f22e7f624635a23ccac4a51f9e264ad0be985f37b516c0e6bbb15f5254e0285ad0c40fdb7aa1a492f971e9795a6a03add463539f28f35fa098efc12a0a9dd5fc503dced7c45f086ca4a95bcf1b750ea5e7b0e6f33ffa8ca6de65e73b5e9487ba51bb81dc86be8d3788d8379e870167c53f2a9ed5773926aed1a3d7a1da69c5c6a6d0e6a6d0caf9e88e2ad2ed70db81f211f3783197f668a128d941fa86661880d9dd1938303f86f9caefb6abc76b81447f24bd879ecab426643b9b2a3f132f54295ca5dc3d9aa53cb9df2e62e4f444d23718f43ed49e5f9d364a4f7160ecc8ab4bc1a44546554aee362d2ca62335c8a2507564fa36eb34a1625b10a8e27c40d7bf03ef6336be551bbde4c7a99c38a962e0866603c5fda9912df8525bbf2eb77707c06d50c92a02f3bac9d916749f2244cb1b4a6b69de452354aba156d7b0376b8dd516241cad60b76f914af5d9152529bc762117bb940bbbcbe6607148bd2c9ff3e4644f5dde4f0abaf7e1f2bf223a1a20b1d52e9b5dad83d4dcd87290c56f608312743bda376fce59860f67e03ee0f30017e16e4e63af4958797452557888fb6c7f9aa1cf5a0eb9309fc052e456cc005842ae33ba3f04ef8ac9e85514108941a501d4c79efb08aceda6aa76c34582247a33d7bb994c329f4c8e8f7ee062361b7020c9ffc827bc5954b5541a6b120098d3c37773b807b1e46085eb2768b62218268cde8a79cbd2eeaa90f2cbec08b93c2fc5b94b2fc6e3fd4d5257ce829a01168a2bb6165358777c2633269079064d2f6818b6b2fb0acd80b620c251bcc2e28735945386acff826822fa81876a17188ef95da7e34a002e059aa1ac501abef7c95244f56a3494c924ee473f5783d871e1342ff373655e10f8712a15ee809f3b6b0f79995899e98c63064252e6e98a0c3fb8951cb6fa0598cd5525ba6fae7f2601c16bb7e7b4723cfd37727b5bc073267476bcfdfbdd7086bbd602bfe4bc1c611b050b09c2dafba8b38cc44f99ab96d641b98e74e66e7c576bd0119c9cf19a55d326e95481c86d979abecefe90c22af599904966bf37ea4ea6507bfe7d2a90863fdc01f4516c45f26af01e93e60d64a2e43a30bee955bcaa8031d3a953d98ac5148160333f10d0f05c5f508031ef89792654067b71748d24259d3091c43cca877609ae50c957134e80fb9e5da39221c9dcf0b1a53ecb786759b19bd779353b335bf0f68b37221e4caec1855269d0768d96a64958d6643796ab906991904844890f4e3a68e39d99a072a453f8b942a93d3b32d6bbf9e8d86ad91dbd24cb68353ab2c9a1ff680eb5c6f2a4af1e9184074224ff4363a2539de61fe618ebea97d5bb0d7cbfa9e8af0a640c1cfd72d2f5ddb179420663acde985536a702384934c536e5d6300c8aa68ea1442260584332a82ce0cfc0e319229a813558c8a31952da7550f9b88338ea9f1d32b5e41e6ff050364404609c7d5ab9b7926bff58e4cc95a895834035ea0eed5723475a24814aafc0c3e7968983c5ae42edb610a3eb31ec1ba0407761b55fc33e1814e9edff6de58814b9c0f3d870144cc6eb775150b200d2acadcb253525cfd1e43f9de5e7cc06b1a79bcf9a977136eb9f0047354c2d99ed4fc8672b58301d899536eb51d3dd5a1a450647edce3d682cad8ed9bfcd5e976a4de4c019e40c3e857fa3f5eee69a369efddfafba2fe766140c55f05bbe7b9a6b846372722f585f9136c529583a6fbcfd2648d04e573fc1ad65a0fadc095ea71f8cd4658880746a1a03364da84ac0ab4f52bd36317b7ad7c84521327934b25620a11aeb31d67810e3ee391ef6383e042113bb9bb3d83d3ef12682dd0afdf3bbb0334595cbbf6aae974c6e91c11a50fc973723ddcd62ab2c3512e704c79199e5bd5e8212830ca5af50577bfb46859d4584fa64af01e6717003bed1fce29da3d12c4098d4831d0d7c5677c036c5698d72b9e21d7b2709f5be0fbb4b7f35f07bff827a00f7f245f7ad86894de0b5a0c4c9437bbb5838d9d2013ffff5cfcc2eb9bb32c8f2850910b2beb5ace51292bd80ceda75d32ec7b6e5d37cff909220d40a7bb52b66e92e9ce942528e797f9473b8e25d9753e70b2699f8f9d823ce7a67122b897b841d3f4084dae0879c0a7366511adefcecbc179f0d153f5b334dc4fc0a144eb7e0faaa85b5b1570b49b83159de408ef939ecb28db1737dcfdd9556926162bb277625eec3b0a5ce1da1b1f646423ea6b885c95040222aa7c60a388daca9645a73f712c0dfdff0cbd93aaf664e432954cbdaa73c6234fe6cf8cef41e5393d512695e58c01dff0710df2cd0a4aa203c13c8020ac524eea63088a27f9ae327212efab7f453ed8757f6bac71c671821417cd7e1237cf450fa75413ff831dc72d4cdb9712f2996472a9dca9775419ca85aba4c6a1b6ad54d05a15dc413877496e621a44b840368b772774d3a0c81c3480f7a88b432d02797cba2f3af78c1f884b80f0730d862c9050b1d6b2f0ddda92adeb62e56f2a3990a118f3cf0c2ea315e50ab27177eed54c30cee370196dd62875bdb6d04e3aff3ca56a6d227fe2e88f96799b4401aa4342601f23084cdc03f8cac9ebad914f5447145a91d59bc22575675d2376ac5a8a942de5537eb00de499ea823cf0a27e2f29a23972981d8dad7ba22fd25894a9fec78d4c78d109b03b8f1fd17fc1b61b6fa6f30571e190bd42e69c091aebccc6b2e2ee87d6654eddb7fc6cc8ec29cd0add027bb667605eca8662b61e537a4132b53dbdd739468c1a21d50cd19f342ef6797c2e455b66dc542a7c3c93cd2097c752682701ccdc95834691235e25c7f0412adffca12bf417216cff5de663d9da57eea0f64ed3e262cc120d9b6183401298c213322e56bde9276d466a28cb25a518e3fca36ad0f11c120aea767f235c142d644b03185da7bd163b2817c0fc27c9a7f32b8a9283fc0cea6bf0bb6f075482793c4be055c39608bab489a816116e3abc7199236d9fd8ba907bdcd99d98ff3493a444a1fd4adb21143c124a1fe70b4fa1516bcb3ed8bff5e1a130103837dd3f0c2e93f44b532aa2e2cc579fc262a657ea698a82728cf40e879fc264c9ed34dd07d85893bc1c0acbfd61b30629953ead932119d3d61ec758026891e2038c91794647f26687f19e98db34bf93234be70b350e5891236235fe17d790916c69c57ece4cacd4faba444f31db335a9f29aa9907105bdf5adb7224cbef5181050adfb53bc024b9e5459d8cb3f807687ea07dc30c69591a4933d467aae141a77cd2f5a1ecd2f19eaae82853f8145f22c7ee5ee57647260bc29525d17e005b88b5fc5027e08e81508113315872d9f30576e84b1c9abeec472350fa31704564ad05147be1bbbf5bc15566bba10856178ae960b57e3cbac6d71a8a878acf3b295791d23192a23515e75c23c1bfcb103538f203d988443c226f66d3da92708b0993702472e2b40ade2836173b1efba46e6576534ae44a981ac58214bd27529b350736e091927885e87c7dd66b9be8803ecd8d26f46394e58c0b59852a14fe5883585bedf46219e4bb5c78d18c6c4e94b9de7308b8c95f7b8d1bc6d9aa93c81a146c373208897ef3efdaf8b9956317a1ba982cc8a1964ad00346a51bda7dd9925f6e28e8dde14e185b1effc0dfeac5f55e64140fc8fa98413266320118c5e029709bd26e4c0b72c4340b3f64dc3dce8fd27da3376b19bcf59ec6ac4ce81fc72323baeb2036066bf3e40692beee9efcf6ee85ede2b8d34307ae74d021ff12e765abbe6f3647a165aa79b5756b8804be9600ec04fdaed71bc945f28e3c466814f33991d8e39e4415c47af8681d243b7a67a51e34697d69a2275828303a267c34e131d2e135e6f99498e95a91984678ab29d3a5391a2eb4de8a9592ac2d6be766c68cbdde086490515d204da9a119cf72358c40030751c0a0960ec2da6654eece583539137499e66c2cd2b948c2d0a29c403b1347e66129f6fb35f1607d3164c867f1ab92b7c85d2bd306211b99dae574800f3c4f3875c55215d5185f8e362bae8ad0eb977925cc93c8644ffdba965ee6e5741ab5e7eeb5b7f8cd35b7024414180822f11f3735bf5117bee9a239466c104e4b0a3c8879f713f0a159057402680c696d3c35f4f8ec3c0ba073aa709ca20fbb693607a53ab4b0fad3b7f09abbef3a1478ea5afdddedbb0bef852482b4c401556b77e8648703e56de81f6576fda68e4d5467d21883534199ce3ab91b69ac4683b423e77a5921cd99474e43bfb47475dd6adce1406c799ec98c1b7cf88ad9a1ead66eae54a1f4dbc791f904f6b3e9d8f56bc4debe0091504276cb8b13616f2f1eafbf56d3ebd55fd3d5026c009c010e74082bb217a22bfa2f508739611b75ae5ffbbe44ac7f80fd7b389c9bc445db2f6c4b16ec01991402d572252151ccdceb9407df959b4368650f1e06726334a242622856ebcc233f93ad871a12b090c9b784fac46ead51857b4d302ed2193ab67aedfbba85e051e495a9131a12e484f08c3d6b298696f955300c824d00a7fa71ab6bf0bd5634fae4249131e9de90823c552bcbe29504357dd7a44558242e9c50cbfdfdbb06f622b9491f5465c00dca67acd254c8cd91c9938add2d6abf3811c24844b1d5962825efb3f9865f128b5497b6b7b28d8ab94bc0271a4f285ab0c1500e5f74acedaddf7bd688e609173d7f4efcdade35ae79fdd4aa549e50587db209fdf5528ebf59616a295a0137db290d5f9b3106c2574f3bdcb94f4367792bb22394c72de8ee1f3adbfd022ec96210e204af4dfaa2c3e05c5f6ff69add15c5ee62ec865219b54890df29926fdbf8f7a2680cb0a0889a090d87409e23ecc4c0c1e0af5409c4dcf839f50a3c8481f2e814eba21648f5e36aab38091adb9871c873d068162c486238131759f964d957f7a8d7f1b1be334f5612d1980f11e3ec64f93d5a1754d53f370fc673200ea3f8be9cb5eeab84ccdadde930ba0d1c6725399f1f0ac78aeada0d47f52eb0d3867b2cffab807e6129f12044f78566d7a3a87ba4108fde680f0ab80968d76b6c2f1b291da2a63a79395d1a50184dbc80fa7293e21c5ed7830056cb1aa39b6ebddeda40559c7fc16e0572a7aec983de5c7ae6854d637caa3b31d327289f4d5a35acc9f097c9a7877bca2732cb2be76d780335d0a2d9d3c28c534f52773378b68d6c39b3935fefe0790d7fb32e9adb10d5b020a92b0c48fe2a1888c242761e6428757ea46807703dbe5cd7cf183c3e289e9db670b42d82d0c2b12be5960249396390fca99d3c051837b21579b53f6ce7c427a57241e1571d5a0d03e0fe98b1dc475f62c5d13d5c0eb92c3384bdd31a3e47e9f51a833e6693fcb402af0df168f974dd5513b464d0eca757dd688c3f31193e82b766ee3073e8a9f1a821135f9b3e2c0b863b44af6dcf7255f7997936984402b719564fe5741dc6a907349558c5d36ab91b81eea77792693249c67bc3cdc70d4b789588f0ee92b7bb33cc8afb3a69f4b948fe8d59a6645eae6f2c736b0e6158fde70fe051cba43c257affc8128d1bdaf70e979138a4d848145889cf836ff5616a2bb07a4603ac8c547192a129bcb23e67a3668faa244f71d5d4588bf338a6212608edd0f7ffe34202c42070ecab39fec191958334f8ff2762e9322976a7805c4e8789ce5da2c4c6ae00b894ee021aa73d5ecc1b2c2e9af9e4ad2a77cfdff510baae96141206a95bb6b0751956394d03d617744dff06d0d00670ce9beb5edb702472bfd72428016e6584a5ca8b29d8bbf92872fe982a395c3434cb175124c0019fcb4239c063e836b64cd8a35d1153cc1931e80bffebd1030ca38e2646339f13c994f120948e23541a24edfad3f2101593fe9439344e51a524864a9a48002c9efc5c2631f28e29ddb700e041e37f52180c275190951f033dc18c9024ed04a96894ea2eba3deaeb33aaafae1d21fb48b4b1f9169e70dc96b77ab55492fc0d865d59ea291c7c415d6f49d7366fbf81b53dd9be6e135ed223c37b87f9d59091b4d5dc2911cb83918e2a8281b58ffe4361642782752cf90444fe16b93b2e6e85dc9ceee02a6c8342ee7a818fc8c64f355f020603666a92b5119077804b4db3db9886fa159d571215e863ea2101c6298d2e933998ae5c7e97b8211d947d5341a264bc36e68321c463d1611779fa95c80bba83cae5ac89af44bb8e26a5d0a780501c4d6f95d9cb93f8027ed6d087606771ed77110e2aaeae5992ab51339a4536b21fc4681de143a5448f0e25592950a72447df38754a37682a620e6869e2cb520b819c99bdec171d403795dad31b6bd626f8bf62373805a09fa830505fdff0473bdd94a0a57cc4f0f8815c09b5d4f83ba7127a409d88af6f944bf3ad2447c1f64113fcaf7fbb893a9f35419fc8f4ebe07ba5b2d38f280ade92487fb7d24f40796c7bbfe504e6df2b0ecff1e3683e2e08c571b9d73092c88714f24bc9343f0ef81c103e82f5c10838554d797456f352062ceecbeae946abb3806f53f85d1d120a79fefabd18d78bebf1884146a15c54871a3057dc2a39716fdc264f6c86d3b21a4cdbb829318a6149cfab99f03b18080a10be8649b027587a2a54347ccf45281992f6dff650880eae6d44961405b92c50b41b781a022192e2bdbd1d379a4eecbb62b09341a6a416377fade98734d0b0e9cbd9e96cfb6e051962442b180c8ae22b0e73ee3a3f37a7cc58db776ada2224fb2ff8e46c3633bdb2defd38e9f017d119656a8f3c03eaffff63109d6d3b46a04d10ee9d61a0ef84e2ecb25d0c7c9eeee335c1be074f94f979dfd75b6bcdd306ab86d3e587604d53ad7b8b0533e91f1d0a581b6aeaea9c8f8d336262ba2d14f8f3aff3473227ad8c992336c3c44def20f3118fcf7cc25b6752eefcf7a4ae34f9090a67243d91df20d4ea194411afe82413999beea9ae280cb0bcff035ab3bd86c9d0b5f14e5ca76e858028ac1a5ca4de52eee5b65965f78972efd2aa2f97f20aaa73d43e435c238e2261dbf148796f8863d68035f284d6eae72a60cc8a249dbf13d3709c0fdf94165916776051c3038d16f86d8ee8328d29ba065a2ed788f2a66385203667c43d8a1ff8a0061f189b26ecc1928de850c6535a1654c59501a87ef4ee72edd64485ce84ee78f1852921f5c21e8573b3bec53b535c2ec69b30d573278eb7462d4b6d0ea12fa0eeebef457894f3044e099841ed5ccac0f77561c5e02ab90e902a6056780696798f22eaad8bf12d2ca784d62315cab166519dc62820e91ae6d70eadb90828e1bdb9b847dd597c92c092dffd7c9b75458bb627d154088d099cf0d18b10d917deadc8b43e0cac2fbf211677756c3d9e0379cd7e293c2799d6bd3288255791e93f198899ae10aedef43aa43efa90c5a1af2ea2edd332707f7e56b5d08b06381a7f8e584d79c97b5cd5aefd9c17965b84ef0fb70b8a046eabb9675cb0bdcfbada5c68295214f9db9e56c6026ab38014b77e276c8744961213c4129e2746342cc6b404c44d177ae3a1c8177903b0d67ffd9db4655198d7fa89993d08525ea2aac0672936796936da107b9623e3e884137ef5f2f4eef8f31f29871a85fa9957beb156b3ca64c6badce777b77dcf91acd6a0d7f52958ee2aad6fa8e333ccda341a7286b69e6853ac4cc799818216f6c9dfc2e82450928dc9c779f2666aabe803b152fe7ab8ea2eadf4583f614238465a179779958cf13382c701c861872711980db2838a8361018686f9082be29f8da0a8789ae8202adcaabe3cb5b4981c4dc665d61aac6e18d842d640701eb4a7fcbe4bd023b3fd8022b3fcd15d82f4c0334af0cae0395f49595d092381a4ea9eb445ced253784a561abbcd4e1deb99aa7ef932dede7de3806f40f298576d761d88e4d4c75a317f363989c461c99490714e27de46d8fff7f16bfe156a14576c633da2125238b87d6aa0145251af6656cb781f89fb87f9613e13b371ad64882a42b99a8a7e5dbb1e1640ae2970d0f24989828b411a4f9481e4fbcb1ec21b5c7a6c8a13fd8a36aec93222c7f9b36283bd254436b942d4466ae0ac639ee3aaa43f7abb66b6343541bf5026b9a886897c37944282023f08b92dfe22ed2795867625215313a3b45c74912cd51f2fc7a5e31eaaee87d46db7abfd4b8596197ec89085654eda950820687abc810f717971dba1f64499a6d1b9ac8f38347da96265c7c821f8225a48896381e105415acf99f5c3ab5b48462eb22a171f64c50ca36482cfa2619b1a2c46601f8b1b26aee440d4cd05873c165a2b31c00afd1e40c8b7a0931c6cfb6e8a14ff08bc0994233b0d80d76d42131babcca29ffd17a370871101b4d3df0f8ad1a75cea934ef04c541fc5237111d42d2cadb51236d9a8315be2c3eb8f0c92b1e50fb262e6af813af3b3cce5387e6c57aa69d8d3f680e48adb9a5239220773724bc861b89b0dfdae81c717c42208a03f7f936299c5a6ab1c843c932b9b242333fba3253e5d4e0034dd28b428714e3a4afd4b3d3580d8c11347eb023c87d3d0735659e553f18b9514596b745989f55a05b2f440ae925d7f244b48f1b9b365f44be0eca1a7d2512d7f1c7ef5d4d61aa0fa32fcefc4bd8b2f93a2ebd0f7e0f4ecb876a8e67d896f94220e14d162eb299d64fe984d2c1afc4a22e874bf728c0df682da04ab88274290c3cb8aec921985a8f55b6ddba2765c65a1a484a4d121fc5ceda30e984ecc950c749d83329ec23576e24137cf8555f38c4d09d07d419ad73e706ee21f1e555d10ce835e05587fdbec24229d42cdff5e19bc353cb9e418f8b32bf2e58593312d2065876317e22a0aba8a9d2f89e930d0b55ee492b18210121c17999974994d76078fd9702e2ecd90eaa24a9ba71c2b826209535314bcab02034e2eab1e9b7a6df2426c270e142699fe927dc75913ec889658958d91fc42d66d90a6eebb16c14cfb25b0bf3116ada635bf4c5619f2fb286a387e8aefd3fa059ebe2af374d8ade5e4722fc7bc8a4b3a0897218b93d325d5229f9baa4cec37f5d456d4607a1b078dd6c1f68024d17b0760286c1345c6c181c4dd4dd6dcbe9509aefcf802c7225bc1335c7625f804268a8f0e14bc1a3b66119423425063c9fe14933a13297be276a012c74d941a894a99d8c2a797079ab8761b4698f5e8146f31119935bcc010052eb3becd3cbe37cf207a903b6b1f81e3c98213b64c6cbf72272ab570f3f6abb8bbe2c6fa0935053dadbff16c6ca0f395f43f33b7a65a7e31651bdcd4c5f1c4fb9467efaaaf672b33bfa68580454fab2d9be8c8cd0a21faed04b556a7cca5e29d79d9a8c5c4a0c2bf5101ab361329daeab244aa98d038156def91a58d9a4cddcc39a75571f14596816b86054e0321edcd89cf19d1ee00323bb8617c63c17f7bc563dd3c985e81453949caff558b1023e758e09c9ffdb7f56b396a1b9cadc2ef6505e9f6c4f5624e03ebc9c2f422ae8c5af2dcc4225f51ae435b5ed3493a6fbb8eff7b5772908abf4442c611b75f7ad6ef280e8c34ed5e58df6699c17f8d0d3bd59e9fdcbf9ccab15d8b9e6c02fb9ae042508e4b5fe8b839db218ede0592a87fcba6fe45aa88226cf34c9ef7e0ff4bcb8a5ffa524c097f48c6533e509ae78e16d155983e58558c22db8637980d5cfacc073f386432abdaaf5332c924695b1a42cabd499fd0fc21f5414150c4101827b51bef8f2e9bf92706db4ea18dd5371bea3ce08b7c796ed654876973b030098d48395173511204a22c8ebb65651a38ea54ab112224c3599426d0970cba92cda6ad8e1180bff78cdb3b5066d1bb7d0ef622c53106c11849dcb3951d7550e6f116e9dfe26248a20b0d8133b49b1266e9f87a5eea54764775eadf83c390e1f21733238918ed1b618d9f856c8db29f504a70ff5e6161b88a6314c3f67c04bcb24da794e130baf0ba90fdd121e983156bf3c9cab3d0b9e95da84b6f37fd2e914d908fb0a214d9d541641d6a64d772a27e2c455cc87be725dabaa94fcf62fccbc0ee72f4eef00e309aee9b9453503fc322be1f9fe2bd0dd0ed9920cdc41f39b078527af728e17cc18c0708a3d20b52dad4d64c214d39b7b089b5ba19426c626b4ff3942846c9a6c17b773fd35e668a94ff0643393feb16a90dfcc9f9d75c293dec2772b23631d794ee3eb1afa3ad9ded15917e3509b35f2349caa0c767785ab78b6d879ca9baa76dd8e4e74eac6104f238afa16cb58d7fa2cc6e1456bffa73cd1f8de111ca9acb32f1c357c9cd85d203a7deec8775310691c66cb21a7d8adee5809cf3fb498d9f5199f39cf3cae3f2e06282120ca627a4243e1739c0c5bb4d4693744b093140c0a58d868a6d87a4ba86dd34164cde83f48a042d13e57315bb6241a44d8b138e1dc10dea0d6c565ec3eb221d2a6d7cd42c524dae2f541bceca126c1b181f1691e18e3273056b102a69a8e710cb90cf5d329a631adaecab7fbe6c136d21daa5772eb34f38dbd57463dc46472f873b2c968a549745c8fd3f9588215223deb1a7375fad806d0a13fd8536496c5eb09188a645dac6d159132833d1840de75c1259ac02b29b8b37f04daca40fdd80e4a034b10006b66312fedc9fe7191640f08f79e4d540c6fb458153eb84358710122a354d1f8b26a12618ecb01af171414f586ae0df3438ce897921c47dd3088782adde302f478908a004553a41d58e85c7b737ca9ed1b36816d846c52857fd494f097d235d39bc717857aec592f8e37335c9d493c26f929ededdc09ee1ae40e9096bd5b1a735b240587597ad71b05ff58ba53983f161add51e7494a709ac0303ce8058dfc4b19cf5b3d04f20447759e402c8acd97d78767bbcafbb07b18c4c99927bb53cc930c02cbcd812cfc26e2a876e43f807da2a61f96dc736d020f93e5768bbc7fb325e5ac52f27bd316542a372891490050c73a2d0c58f3f78414cc7edfecaf91a410e61e5bd397156281fd0ddedcbf2b8d763e88be52753b346bccbeefcc858efc696057518d0fdc4d113cc7cccd93367c7b908a809d22ac04bb2dd662df0142f35c25d08683608f466e2a04e92b45be2c177c10a915ba2f830be15fb8870d7e49dd881ceb6180ae02bb2a464b90a4fe94e7108a00853333f87aebd7ead34c1bc762dcd1f4ac901a4189374783e0dea979911e3d42316deab2fd96ebb90e2aecd8f4ebbf00e9943f652beb3daa5b19e81fe2bf5a936443c28bde3e999751de3ce7b0da60b0e4a8d289703e340ff9b709b558e30f234d077c0ac9979d3f37a98730c01ba72e8ac40360f9fad4c3331f59453720a61fe167e65dbc34d13136746e2b6c790d34a7508e10faec27ab977faf994f7fa64ddeb2558060577fba0b79167739c6a5054407cd30c96b9185385b5d87d91de9b7df799db22e62bc103cfecbe6297afd9b625c684beb7c7a0331b8834df972306e192cb4971566c189f0a5cc787808a614ebcbac988442e644a57a37cfd083a38f8b4192d407f1d2775aba30317b899c88ce506d2848f08516fd3d6514fda06cd7e529a915010edc0c4023c6d2436e71b2fe77c0e9d167bd2193ee1043ae310753002741572fce7549318de147695920392afc8132a07afdab6247a874674632b89ff77869d42e4b0f06b33b26ef7d394909f0546a5b806ee1b5ef85a191bf10d55ddc8b02c58c9836493daeab3629c76bf53df5454700e9e77fb079704d972fa5c563b653b9dd116d2069e4415be47faec63bd8d680dbff94c6b4d2912cb814f496957983f1935b87243213a44d931ece5b117cf3dec4f8dbd587ee00317e2bdf59932e17dfa7aa893601d8716d714724a3fe4effbcdfc5d0463697c1eeb819c7f76924c383412336f69ee926e73489988fc4737e05f81152cb5af1bf7a673af05b4e1eccf18434a5e0775e7a032e0e57de327e85d0407faceff5b2a9b1cad136fcbdc23cf41e7d2912bb51f98c1487bdeb6bf979f1e694e67fb4c6f6c80698c65dade9bfb78cc8a7cc8bf36300d9152c531a4503ab35085d6a464e96182f945f561c384215eb696b47b1247f9b403a7a4d8e9a76fea9a2a795ccaf553bafa0d4dc91cda4093f97a35eafd9a80a9beff84785336017862352413c277edd124def509ca9e53e73342d13ae825db278aefd920b7fbade264a0ba621fba7d27c4dc6b09a534f6b89971b1f3b53eba00c39342552fb4040f669fc4337e25b331658471b0093968a7054091817136c67bd99c91f14dd5f6015f16efd8cf2a78896580b4f63a8cab3555c94ceaeb7c570a1c17cf3bf2d9358179ea2c2210cc69235e75b00cf04eba79eeddd856fc54f04c96ff5562cbdc9f3aa196e852a6a45294164a74d5b68501ba00aedfe44bb4c406ce0f99ee0791835406bdf6dd1a0893c1494a5e8d2b4203b37cb5733dedb0e597da93c5760ca040c6027b8b5820efc98936b0771d14d9fe8eb42994c312c4ee91b02731f92e07a77de72232f8dcdc29a64e4c018ed7cc900ae2552c8623177ebb5f235becc73f690d28320b46c2e8b97bc9ad2c15e68ef68e8c8e5a1a11cd19b56204e0eeeaa030be775c6ecc12dfa484ad0c5c854ef287d699315f3605c9c43f871fe78b58e1e67680f3f2cbf12ef4477ab4735615e7138fa2df6bda9b5d919733778312ca70208e595325f6156d93f1f0fbafd134b9df61e0cc6c1be55426d2ed1d0e986e6c77051e0a0d0c8833baac2d0341df2feaa856a8c0fb2b8532fa6ba1be2f30ed6917dfed9c1bb6d244cc8c163464629eefdd18148d69734b87cc849e530b6b26d65d9260c6fa2a70dbb1ceda198d85eef293e97b5a7afefe98d9c5bb08ecc2388306c4d8a8ebb7e4ec87e35d7149538b84c0c98509805670d6cf6f1a798b9351398dca11b64955cc1b9d366358c69f38ff6b7ea4cc94cbda783848d0b1cf6b12f813387bf7f689984e681c340dc015787fba3485df35527437a224e21ed4d2b5a134082661fa38704ce440708b2da6bb024bbe3fc2d8e0119268b6d6cb75135139b6ce2ce7ee29ac721f1642892e7a9eb9f0272b7f63974f14417ff25494928e2399f0687658daee770e3a5664c3a9961c269b214e99e539bb92e08d9dafda10f5c3c5b35c4c9aa1da9bda74754b069c14b89c3e6e5e690699ad4ba25cf8652e987400b20834d93a105f936fdba75e07932317f404dd21f55772c1133ce489fba9ca02f7e392868efb2da2c7bb87dd5f09746c34570446860a3134d2a0e5b5a98e92d020f3104f68b10d89f7b8a257c37d0d126808203ac81d85631f3a5c6a52685ac65fb2be8df39fac992d943cb07b4e7b5c42b949e71ecd399b4a153d1951ea04f8148a5d2626f4dfaf17ad031139e0d924eea854eb276f561a42473596f57efd14bf28acf53c6606622edca2004e721693f0116861dc5dd95d65202756cc2d4b7adf608af43a0884aff08d0ed3a306653208cb91383a34fa08b2ee61a0917a179be07250b6b61a2eea562071bc2f60b452900ed86b63fec77ff00096d587458cf5a3c76eb5240ef4c286057ffb479efcbb5949e88e233f0c98434636b185278673103157aa522d10dbaaa4622f4ad73cf9083bc15ee3801043fe2ef2d03196f36d2e555026e55fc0b5d13176f7571ed8c51153e798cb21a2d035919902c0e1cf351c8ab498adbda971ee6511f66826b03568c8e75239c7bed874e56ef5a4fff59ddeac781667603e8ad7dbf27be3c3d2bf8b9a0e384336d562385bf2e435674b4e6ac8db7e65a254e6347f3e66cfd04bb49e88be587614e6e90e5fbc7e7a01a78c4da8404b735cef4ae657f552ddd68bc84ae8e4b08577909aec82f3cc94000b13145ea9c202cf7e283c9dc40ca2219c7deb90efb024b2dc36adf0f5d3a88691a12196ebff85ab0a4645073812a4b95f4b3e0efff9fdc3cf0f1c4745bcb634322773be8ac364cdb9dfea24355a770ef53aa6a18ca576fad5ef544e4dacc0deaf5517ae7e95d8cb654b27725a1f8c623233fe4642513b397a04c81efa77a316af43c6006a0d7fd8d824e6582c812c8ff3e422272f108bb2fa59b8128debacfa421a91a355728771b111efe36a8a4764ce7f10e36dc12545edd0561bdb02fd5e9d3ad7f921ec819d5cac8a49c849b4c367734e0abbb78207d8db24aec9b3cdc49a17681084909dfedbde790ed1a972f99e606868d8a52a79b966f78282d4cc37a3e130b7da61cf10a70aadb7c6e92e8f2c5fe10aec6e998df6e0bda11b8117e83724c20268ebced3913bb752d9d63fa9e4ba165367edf115952d8f559fed31bbbc0ed709f1429d99d96a935fdf4aaaecf273d20b0719e31f75a632ccd94150de1e5b4f782720a573a7ce7673c8c3032d15261523b8cec7086d93c6ce20f0823d0a6e888c124c2f5dfac45c02f46015eb17ba138941e8b3ffd63b2ff77b46074d4a3cf16d2df459a00f7b0ac0de12d28c352733dc0370dd605535df747604c1c91b8d0bb2a9f4b2b923980e238a4a16092a7197225e9ca457c588637ea33a285b5037000fd80655bf2c8a68981e89426d60dbefd6707503a7046665a7d2a893bd014654f6a2d519a63df75afa8969eb1c4b72e9788328460e042a51bb76841f31cc3f9cbc8267ae7ecdd8f053c82b85f55221036e0fd82a7c0d2fc47b033f2f935c4eb3df870ba224d22163a543bbdf2e7ff96c6e409935342521350ac10b2a6241deff222eba645133019920cde33137940fe31121d3b9903fb3125cc72ab610d6a16578a9afec12de89690f9d6760f9d8127ab438ba1247a84fa2206dd1cb828229aa276834038edc25480a5390775ed08b03f9ea209fb9c0e759654fd58ce0411d681895279a39fb4d2b34c84a089d9ca8523a2e4eb6b47c0748fff9f8791d3099266fc7e62f5175b656c016ed1c18499f0c8f01f184b167dcb3d21306fe97a344fcfea99da2137b57fb95d027d809472fc3884de8ef4ee0f97dc424397efbeb81965cf20879f1141e31266255f2686d89a996908f009921f686072bc412dec7449ca6652c03ca2b5c715e4a53355d14eb6609a5710c311e396a62eb6eea3a97d39596ba1e1565040c617f26a4e2057c6078646ea47a0450bf53c3aa5634dce5dd74335843c0b0c803cb2f69a07b76554f4f49231be54d5a83c21020a97cecb2cbb77f7aead5fda46e9b1fbd7992d582bf6b2941dbdfe720ac05b40e92de084b69bd55177e72de9cdf","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
