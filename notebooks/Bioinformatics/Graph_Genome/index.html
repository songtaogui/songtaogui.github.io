<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b934069684bc7268a78716e79b10b6e2ad942a5353ee31576048d282976c13a465fea43afc7b961a4f8664c5887fa42f03f87de8e70cc4180395918e8b24c64ea94a9cfd9d8224d4ada0047234391d747f18ba41e2aad014454d6afbd70f092aeaa5f30cafa613cc7be81a4f4303cd42d9419ace33deab638e9ee2d745aeb145069586edfa30384139207f85b353a51f5ec52a1671cc47d4152a1689bb071bf86c5212911622d02ace08e213ce6ab9dbf4ca9cb1a4f71781e78ae4dce78844815f1aabd5bd6b73fb53334515c530f8cead0be3ebc3ca609698dcfc0ebe28d69a837a6b02e2d2a3d31a6feaf26d68238d463b65ebbc27e326ae4152c2eaa3c20d86fcd3285d774aaadd1a0d3b78bc0a0fe8a0e4655976b961d1dddb64ba3084fb0f24c1a3a6ca59908d04012acb3d58f0bb0ce3ef5dddcc0682c3172220e3c4a50599845db47493937b603ee063f40f58db548746d3917377e61e8389e45a74781c3367850d5b5b7a9e63bb73f742c0b8b5dfcb8b6a3fa8031a8fb536ad8a0bd4da7d7972578839aeb5d14eb628898578d39b9b0b942287cfe8881610d20915ed3ed66d900a624624203ad1ba0f1d383eee7086e0fc153e07d612ec404247efff054e58e5fa77fda27331d0d2ab5d5b4922006b3643625fb4219ee0618d7d8642d9cd96f234e1a3c7435898208d02c8241a33d4b71779840b6d3a707e313f6398e78d7ea229c3a10201667bb7164749c5a1ae9105453b25b2eec1a86dc0aa898e96200d77f334d0fb0fec94f5cf1dd383b86f1186e57be0d8e378d0e0b4249d726af44afef294663ab78b4319061a5ac0544d28ede14cc7486a54999f2a2edb3252074ce0234b567074cda64b02fc68f8817709eb4d24f86af290bbc18425cd0fe7d6bcc421fac9a4dce6034784d1f01e5da7aca9002c9a2a29416909510840099e64b3b8c5c976a23b22d5cab15a099dba235c9bdb393b9bb7abe3bd5bf19720bd10b6a56fa7a46da365bf3a991639d377ab7660632ce3bd45c1d4727e1a8be715bbe01f4de9a74c3a4fe16483b5663bb3cae9c58e5142fff3b088aef5c2578f291a2fd1deead052bd8678a3dbb8bc47eab64476f099c609ad62078ab10729b278bf545ed8066ab58fa1d71c91acbbeec13acc57cf330c83a45a2b2257ebb42f36d37437983bae76a2ffd994a6deb022b2dafa32c4854646e66d5eed52bf2fd7e164f68f48cc06db56ec3549b667c90e6dc7fa0e0f88d974d570b84be243bb63bdf0753438691ef8ab56bebd227a9d6cc8391132bb3f100d9c54882573bb437c4e58ed598fa6d30fecd158b7f64038ce71be0980460aa3e603f0eddf09610876072f6d44b361f6a403bde8735bb884473f3a95a8851b94742e16b71ba698cff5066c8f103f84c6435550c8bbb4f6eff4177ad8f3afe042ee7f705b2906ec5e7a235be8464a2b4cecbfc7c1203e9744e67a5df312aa6b53427edda682ba2b8776acbf0651407d5583269a1d4e518f7ec8623815d3dd3c52f6e9c1de05e172baebb691400d9d2367fe4be1f9e4df1a617bc23665983ec1eae2cc78a7ce38141ed2c3f855a9846bc7c741a91f461b03d571bf0b1e5ff2908ce6556235888d027524384853272d070ff36296d54cdc3a4f7ae993711faf73f5a9927f3c5965d85a7da59590a1f9a2377b18b2fe769a35e67076b1a615abc4169941812c54ea58ed37e5bcaf70247a59de078e6925926ef115d4906f3761e749f5d19f1dcf3a626d0ab16607f468ab73402a49125a57afd46f9de25532367401c0f02c052fec33dd38865051f9f8f521e453a5c1a6dfe72d4635c332b6be36c01223672c6d8330c5cfaea2c61dc69c13e08d40ebebb387260edee7162c71c6fa5db5b85d3153ed8a0073ea5c0ffcdf19f4d01c3487a6a51efede2f66cc1d89d2e9990a4fe0110f1b041ab770a2eb14c2728adaf5e126c3f6e24aa9983c333e77ab5abd2aec1f8d4b50717323b42be5c6ab07695938a68905d0a559a68149471b896a4cc9399aed13262eeb2d5ddee0feda210b41babe37538d123d36303755d6ab8f3d916a2beb011fee33644bcbf303b8caac75248d9da80af9d11f1443ad45deb9c0964e422be288462fdeeb29114691aa7ea7b7eec4e67ec4085b807fd9a4739d0bddfacf61b82e310d159e7d45478312445a90a2a1a1588850ed199c7db460b0f4bdcc931ee0232219bfada4a197e7697e186af5177b17351143816c4a86e155df1940b26d2f2d5621e1145b6200e62aca1ebccb89c593fa3a257746af0ffd70d345c39c20af569db8c6682858cce2e0969d74fe0ab472c292a1e1649ad73f3e4c320f8e6a4db5487ac89455245165b3290b629eba5b50dc1a0fe8bda4dff13370bbebefaa6dc65f1526dcf4addd68ff145da81ce8c682bd14635277a3a6d29a97ed0450325aa065a7536311b6d1fc63287d6046c0ee0f7825ed5623fb40a3ecc9a67e30f3b8b9ace3c3c1ac6a2ae852c727216823d1ec93094bc329017483e8c0303fb1583d7509d4484dc6d9648673b4f7993242cd32609f8cde752ac118b76e1c8b62cb0f63a8574cbf9ad5fcf20adc75c968014c18740b757a95f45f82ba2428b817b25598dc0c80a96a52c17b4d71b6a78445ec1de1e07f81eb033e91de84719e867f9c42d2f0ea4e883708d3225fb54391164e1c1db3ee37a7e664228d963e0c0540daadc1c4bb9a3286094bb9da0ed30f41cc01da705202bef16909ee28c9e7852235be8cd587c0de50a51367d17e4bdce4223eeeac0bfaa57ff77f5585db541202c0df18c3ace3eb2b84b299345abd55371078bcbf32a4f76b53b4041006a4068d3f05cdf3a493d077ff570e8f93e687b912d3c58c7d7af3b4edc2bcd47992f9a9755c40245234503b38199520f5f7313c9b6f43ada2e260b90d81d846b67c4d4f28406a0df8323fb394782215c021cd22fd54f9ebea175a8863b3f0084576933883a63ab7fd043321dc70f497c5344facf8e64f94ae0347892949bbfb3e3bde703bc69edc7d35237422d551b606c5f05f547316b65fd99d419af72f55c99d959689e3eb0ae95ec9292caed8378f7d5ffc1b30359fd23c72876c408d1f5be838ec72b17a3a4c0a52af1925493b10e462f1572cc6649682710b2eb08fc34947925406b8ad140016eab9b14be3c6563fc8bdfef1f44d5bb8a5fefd1b00d0ef8ce9a4708cc0d2105a5cbce08550d0a6d45f3676b8545ac9b3cdb8fd55a6e2bba1c999e16c8d7b66bafbe1a1a20227ccc71109c4758bf99e9275cb436a173c66a473ce7fab76e3f20dd0689dda71366dc9b147afeb35d62598efa9d389a4936c226c01c217bdb8616029c93e04d14f1bde2242fd02420fa0c5724069cfc55dcf25c5f9b64a059fe401cc02e2bbc723798fcee65de7a0543cea40ed75006404a2e91879416978df3fe0566b6ea7da55bc072b5857cb95d2fa804286c0e1bd1d711201fc280b13ca7eca344c436e7c1c657615e44172a766d146b2e741609f24d5c1a801b9420926f88d2afd28ddec7f421d61465ba4d59cd439a31ea69eba3f3a5b07ecc1711e452611def13daf6364bf5cca06fc463777056a5c9aa0ac2c5a583ae68455cb201f032ae1f6402726f3088631ba573d7fa127b073c2f2b810dc17bbfc383fc1895d5b9b6ecb693e86a58ed6c677cc50c018a2300a799fe53f4c00968563745021fb83cb494271685671584594ee60226adfffd0d6cd902aab477b8e81bba894ab7e6ee0c0be4502766e7df384a9aa5db0e495da9bcd4fea5b053e619d17d4435ebd029ade8544c770ffe772f49504e4c268a2790b3baaf633596c1bd8fce6a656f748ef4912985b7c7195a8d820b21dc4d6bb7efa33212d62ccfce589320e8d6ccd67d791a080d50fba96a29b182002ed012dd1bb4782ef88241147c6261e749503167864e170d9263a22a96974477dc27a8ee550bd9f95696255e83d7f430476c389818321bfcbcd58766c6a401662c202b0c141d0ec49e85eaf067eab028aafa6425ece5b8a4af7d0f938a6f1ed5f25e1e06c59501d870b37e82a336d623832cc365eeff28d9826df624ef4914fd171df40c10c508e12608466778418aae6d9d2363f51ef796d63d11c883778ce3cf41fddaba51a1c48929a389e7f9e54b57bef63bb461fcae165763cce8ed8bda60723c5ae95b8dbd2c553176e7f0087d1d0328438716aebae45e6ee70949028e260dd3895bc57dd8f80f79eb998473007de6d8ee146792984251d1aea6d5d500e2f54ace58a8702e49d560fe0ec3bfe9723acba4bde97fdf32a05660fa8426745409c1642091c2f2f85da11a53419b82b4612d5479394622c9bfec7e301b29cc3fc17aa44e1202346b6962dbb31beb45618ec1b91d9094c56330347e2ee786ff9fbf2f196ae54d46a05bb3bbd6d73a4de2ae386b8d6575efcf663d62142d3db0ed7ed66b32c0ddf09bb522ad98aa7e15b42c6b41de5d99a0d9cb32646307df7d802110802058e636e4de798f3910eb466496f1cd41d85dafaf246e49fbfa816f773a2352271370f5f98a192b60b85cbe8663bc5ef019b64104addc1305dcef6c9be6abcdf7eee624637cab05a8aed30adbe3433b88b3d007ef1acfb1883e587dbff47cc5cf5103c52e38a576fff7c25ccb2eff7e6c6dc15faa513d9625379cf171905d466d4985bc9484edb64e272505facb9ab08336d78eb770cea61ecddc8e1601d7a72dc388ca06e200129045caad65ca7aa5beaf55f1a7c673173b5c0f3db05c2ef3229d10a8f8319ba90462a131ae8a7dc12db3c10cdf9f232cceecf3a41fd753d58c3712b474e9b79ed375e3a5717a679373bb7f8d48b803a90e9a136c09043010226b4c75080af8890565eed2335f6f8a7cb9778655a6be9475c955ff1e006ae6eac6a5c545ad54632faf080b8149f2bb219e9cb759b381ce46779b9607028306a0ee23bd7acfbdfd80cd811045b9f78f9055c981477d38065576111d4c7c0800f9b546d63bffc1cc85a531ed2f33b556bb6a39c6732628a81efcdc8077958efc36a3b95729fea54fea9d8c1c0b9ad88f0735f05ce460848003213d03fe4fa4dbc7d2320c5fbdd8e308f89b93e4e60f065c42862718a8f3a1a2b52059ee31619be3f627d2a3148d6998220ab5aca6f137b587cc56c1d7ddcdee9a89ee36d2e31d3547f1873ea66bd9096ae46ee2ba26cfef66dbac2b188690cefc87080795d16f8f8418be0219a28576baf93af95a2eda241162b365855c68587438f24d1e9dffabc0919cdc04ab29fb4efded70e36428ec6c9f0dcafcee2b7f1603126e0b5e16ca4def92c85bda688dee143b616a0dbf09dbc36ba6aa4fbce3907ac1eef87591491246897a51a2eea026cc4a19032dfec9fed18c5be4e72b5b2f3921f860bbfbd770a58da113a5c0d493855f5968ddffd8cf314f2cbe4aba499c2ecf73824cc66e2f1eab6170781081e410ff913e793af59307d6214f6a7265fa849c3d43b7c0d88f8a6ed3955d1610cd5531398b8c09f2d3ceb083c84600257fc7f8a453eb0294b40273343225dfaee6f525e0bc7dcc9c2dc68fbb181b8da53309c86c30823ea6929c58f9cc1589ce8c5bbf73c32b5d41aa519670fb06d609b76f8f40849157b0a948402dee7986f06c7e82730584ce7208de9fe3283dc9f60707ca79e0684cb8ff71f758c3f3850e79adc1b6b8542f8acf129cd87000193db1237ccda30b7c67999009eef74320e8fedf224b7fb2a72c63ae6bb0a56b248e511a892ba4c4f8d8af5fcf8e4e098f77387ffb95be29a2dd430968fa73aa3542e0e79c1a29fc6f03ac1625070e5625af28fe45fdc89d96663c5ebe10e76ce3cfe6e8ebe474fb45f598e6919a711f3c5fae3f244a51e0373ce61c1f19144ea7afa26ada5aec3f8d6af123eed181d66fd8a75c90792ef48c964ec17407228e7b908f8adf6ccfaa763dc907bf9f30c0d4facce4beccd80f20128cc08f45cad7c74e7e7ae8a3716868ad5542022519d7b29f1f1f5f5176f2c55352be08e7039c31e851e76b398f9fe6b46e94a878177119b2aab673e9eed9a4b18f9a84f661ca4f00b8822d8aa26a11934ec165296c804f4f9321767d7c3c1d64bf0b07a1cff9b81c3ccd752159b37b184e2aba1b3957e847c31abe0af0611babce756d789e7d028620462a8391feb1f48631b9a21cac91b7cbf25560eb1f389c5d721a5ccb9696abf9f256c5300474c0a96e6eab365308516b096909c1e380a66e33f6cafc9313dfdefb6c6d130a865092fc0a6b4ec6a7650ddf69715d6582c27101a2a6eeb0bc0e1b2c72ace4bdf89bdf794ecb248f29d3ab4e0c7ed7d1f4e61d59bf9346a31a08b3887933849777541b359c74b0b01fe292a40f04165be9a0a9cca7d38405e72fd758a7e0055fd4067595128783ae26ff212d1143ea92921e214f57bd0452d1e96ac8e5ca1f687b7e2b9eb60ae4fe03c8aea33116a9ee18bb48f845b5c2675ff811661b53c50a0885ac43964d5e5f6595d0103cceec1b9c4173aa0cde1ac2bb9d3b78c3645077458a514a86104b4b644e078b1c4b670eb7697d41bdff46dd76ac241a23831e67e3a57e4fc1a6fdb8083e23bac32b00d15c7341610e6950b089cbc65d229e594a52465a2c02ecb136059f8934107ad44dd6e4acf1a9195c4e5d0cdb85d88bc7fa882b3cf14e05281c9a6d898859164a54532147d811fc4ca9ac74ed24840b6ac36d6cdce0fe53e156620c57d9d05a582032ddf9e2b94f73eb0d53a1551ab707ce97b34e41b8af17a91a72b968e2152bcbf0aef9a05c6ed4cc710c4c4cb61f3b315f65eff3042d69fb5dd8ab9dd8d5721da51bfa506adbfcc397a926e0868b2a0e4dbc43bdc91ed418f506ed0e73a82edc1e4dff6293b6ddb3d82fca31d358d96a6bef110bec6fb3073d5f1668dafe7e214f490ec287c116ffed38b75cb0688020d329c47945a8114ae4d87d9c694d57702f9a433090531862782d66c25da55900ca7c35f846dff73c5f289dd56fe278918849daea5447fd4d4e295f8b0e9e48ebb8ab4a3a9d73bd2ea8915a2807cdb7dfa74c6f1d5937770de334d82524d87f3cdb629e6dcc0ef3679606d35173a3c57bbcf1f07f79c240adf0f047a96a75658e7200db812a937d4d145ddf773eac00bbf9c3f4e97a18b4a131117528dedbf6b71d57326c384db95ed0caa426156d9d31b7a952d49dae8016022c4e871ab44a192f5c2b7c4ca90e44c2d1eb38e90838fa8b52dbdc134d6bd5eff78478c75bf578e344b4468dca7a97db6a2a6c981dbc80d4f9e2ebe72841d0641f748a3406b08ae36a9d212df24553b850ae0d0650ff8b3f485e03e80b2c71a8ba00936cac100fe033421c393f25e499700e6418a85db6018ae64e0253932f102c89ffe5ddc4a86237b1af14de472fb43af73861119027c1efd199633e0a9349efd0bcc21dcfc755f6e64f35f98e4e0e368ad9d51c16617f3b27f4431d856ceb240fd47bcd82ca25d0b4a7fbbe034dcfec0c045a9538f7fe167ac5b0fe9ecd34f3df4c25bf7895181e233f3f2f88d5e58d40fbb9f2233cf80f68a49c9dd61c652a85fc287fdd460384315a5023a26dac18edf38922cd31e0f9d62f3471bd6dc80bc8b8ee77de94671400b010c17c584013dd547332bf8cd76e7ed89d994e3f2e5eb592679811008e8d2d7f7f358c756de2ae7150e6b5235ab891b34791781028f4b7f0c59416ed9dd47eb8d51892b615ba81610599aaed4c5540583d5b11cf262c39d3b0990477a7105f65d9fc4040d5c2bf1077f56f2899f2d806b6df63ffa5d2e7c929138320ef85b928aa00312cc150b5bf52fa280b9bcb6efe3ee7c02bbd9311dbac2c302d9503ebdbbb5e11d8b45638496070dd4cd4c665e943a57454f78863579e3e511a4e1261274f52a152149ba9ef274825428d7448f1e2ad950b99c26a00bc7a93a597847593814dbd497240cba5f0ace0f9cf8d8016d2fa96ebfa444c4e425b59c810b862674bf801482b5d07fb617a40f8a21c520556b73676a35455ff7eafeea2ee2877f11a9f156d4d94aac00309f189ec65c34faa6e0d61ba4b28411a2fc22d85cee98a86701a853b9c70d503455fb891eba3a253906712e8fcfafe6b030dbb1bed4b01c12bc3b278f354a45bdf2f60d38c7e83df4018410edd887be8bbe31df79711d5e011687ccc465a745773f19c421fd1fac04329b325fea9d69f0a66e950ed56932c5438e687178769d4c901c2eda78dfbc0f27ee571470b8cb90763cb0d5d2b61aee72f82e55903588d6b63c1f112a6aa0bf1eab5be0b55461778e36fdd0d349852e7e181148a9a2968a62628be40ddd5dc2b2fad8ffbaa3e5cd2ccb227f3abe72ca71e3954b8360bbe38c6030959afa55d0c1d09527f2b613cdbc903a93dec3c27a0a4b8b90df39fd4f0ab866b636288917864fb27ff9ec4c099d4a99e0749fc6432ba92e5a05720d25a19cb510c048454463db3404ead794028515e988a2a964ff7a703eb0c259bb757cf129d368a36f9f7d0b5570476a58d71dea678651fd4ae4a0571aabf972e187e38683be8bb5aff653179d03ef1b545acd66a70d6db44289299182663b940ef9d04e110979f056a50432b39bc7210da272f2710e64fda11e2e526775c2cc8c84c3d6ce380264879e52c5c1f0c63b11e161b2ac1edc15804118ffa252b20721fc8643a5e8a2c085c14339c5b499c950a5c6754897b637ef952011502e0bcd0e471459a7319d691370b7a56e00082b0b7d2805164656c56e74472e477474a22a9951d74bff1686da93a9f873c2bc7af4eea1db950b79dacb375c4e734b5bec68faaff9dd96eafc4deed9fadaba35e6a6e21399b3450acbd60d390cc30b98eaa89d1c9770302fe570ea5765d26e36bd07c2f53b392da6d6041c18ffc7e35f1eb81cfca72239026feea696ab5bd27c882dca2dcea4d681a11eaf6c1fda710627026968d29e3260b3b2d9e27db4cfd46741a9ab4d2f71747436ffa5efada685fbdf6381f1a1035fc1b7a5e5a7acf36a0085664ad57464d8157a791db398a272d974c9428953d6e724fa35bf88a245f80a116b915ef5840675f99a975c00f5c589e9348db0a26df06b8d74706373d6bba817d2031f8c551c9de4a72522693f2028bd1d274a6314e4ac36a9b68c763207b45a53fc7f16a56090c3dfe4ad35e1ba1c78b8148bed23bffa8d3497eb31972dd370a4cb32b1c147450ef513e812ba0e9ff6e339ea0b7b9d91c46171a4993a0be5e1c827675ad0c53743294222d4d7f6e50206e53d87eabe9e9dc63703501b7578f23b1f408d3d23ad6023af6dcd8c83a322dea80cf143076e966825fa2c8be81d0635b3b6b85e7517622a691d1b2b2c808eeb9fee188c569fa1d6caf35231fe0024723098403ead2fa95cff4b5814fe0b7307ab3617e689e16056126f4623222dc538423a49f3f87e9a1d3c3e7a6104fbc9630264759ebdc513ee2bb8b900cb5740708fac45bed1e8a7539cb95f4e5d781661198c89a6977a4b84abfbca1ab81a52a6e438004d3ca70c076b37cd18b695cfeeb45ce8c4a79a92b2f01f3bcf5924d6c8e774f7969ccc4f72b557f09edee5e004a5006500acec828d80ccc1d36c234fe6ccd8b665a87d5f1fbc9e0c6f948b9e714ae67ef5de810d59a02c40858c079ab043396b1ccd2b2687e126d0015318641fea1f6b93885cc7a7bc0e944b5810742ed42ce401f932b5680a7274db11d3571e685b108187462e8b06532ed58b1fea9a470c61469f8aa899f4426e82105def2eca95448e523b8259655af4335e0bbe802bdb8c240d76b9a2d14b20d9a275fc3b4d1df740cd2ab4c47746ee5f267db24229c2874cec941630949be4d8a4497b3152f2692761fb22984d125a7787537eb45d99acf2b615786c7d5b79e2ad9830536b663f6b6ebf15a7d2208f0f6f77bdbee551ca0b066e8047d62fa0f01df9305ce55feb8e08d6cb66a69f5c3d8cd567042795daecde442febda956901f9c60be7ea1163b103a84e48566041e13b3f8bf27aa7a8709dbad9624fd4ea94282c82206229b2115346b1ce9ae27624590fca5781e908e64c0e2092f468f6af48a56fa6c01fd70a2548224092119a96aa0e442237199ba0a744b1002323f6c552b4ba124f5d963cb9f7bf979f948925e28edbcf1c4a98b44f08349e41c2eb4ff8dac5210b80e90fdbb4ec1ca5e854e3f3d890804d7290b7a9afc4e8498c9695e67079d0cd9100bdf02efd3719b69772c41a92459ff21c7d4f5c44d797872e4a46681af8bdab7538dd070b8078c5b30ebb92dbeb3ef0d9d62664c312c1f9ba89dd552c17f0c1cb2333f41f782bb1ea28a10404e7dfc110b2addfe445140c06a49c4f3ac94544412d1f5f8a4ae1a3748a41a37c35f9916230669730af6f4ed9ecdb8de0045b161f490cc74bf845bae9d8d2b02a7c3bc1f5a899adf17b47750fedcaaaa71305f05430e5a1364cc7b52b4e91b5563af9a7f5f1fe88b548d921165abb556f144fd841c747c2a56a6834fd0fc6fcc9e633717381df022dea4729dba2102680ea4e100a3ea44bba61009876a947f58c74cdc6615b436ad360b853d8476e73c2c4010c7f69bfaa69e32e4175fb08eba540a7caf330b02a1336036edf1207aa03961aa47085d77dcd1f7e06deaa96f7f89accc032cb610c3541288a039c2455e46bbf69eb2ab13fe36f949cd020acfba543ebaf0b4d724be8079e5380a0e8c3dac11beb57dcc0ea62da259737a0c48c9257aeb6cea81f6797b2776725e9649cf22c3f944d9f5d12e1d585c25b23d43e22c9c433f23251caab9781a599440775ef6af8fe26f61251e0087d558da2f9d2ec7abc456f1881670a58ddb0d901bb707bf9081596ead6f05e72d0fbce69c385267b05db1ad12896c845a8ffb858a0ea03ba75c28c6a6e2adc96d5352786b167519a20a93e9afca88c0c3ae048a9b50eec0fde43284c9795b0b128f70dda6d3a3fd899fee1a28d80f47c8963cfcd9345348e39f3af71450dca6cd0fb27e183967a48fe063fe4f5b29fa727edf0c74165c11efb43f9fd57e89f470d6e088cfd1b7da90f310a84e43acb86e86cb2b2d32e1a86593806eb6c8ad4dd4060c7a655e6197320294b10c1f97025c071564492f9a29a3324cd4f714443853da38ea8a4a0a634501dd47921c64f5b1019d67282352807aa59ff7b9943336295dc2d8664db0ceb9392957b5d4c02f60fbf6140277dc75e495128194348d85bc49df5c672ac826e0b7c0bc001fd71bd76019453941854422a0495722c77be2c507a2e9b63ae10ad39abc4bd874a85f93480d931f515b6ac89804b3142f4d82514a6762bd87d8264ca0fa0aeb87aa05aee0adfd692ffb42cc9e79fa66be14e2b1562c81e98d93a6bb52c01b29a56ce389b6d5617ca63cc14beaab9543b75664af228c14f7a538299d21a4daf42134a0cfd758bed9fc013c5bf6e856766aa61f8bf43567e7c8fda5564cb51cb1874afbc6b20a2bc533eb6a9bac3def35c3a41cbf4ba436eb9610bab60fa597f548dc16ed58b7f79330d1e64f318fe233dd3a98e0748aa6b23df2b8cef756eddb77442184e9e57f5cbbc688432f235c248a9fd0f68e55e24f6bd42c6c2630775ce999626cc4be4cacb75a9464d52b8d938d3d4826f2c3ad7e6ac587360923ca1401208d3194d564f7432c36c00d086e288d2bce4481a808eb92f2f718c83d8c2395a3f9adfa4f95161be359b35d8513e0657639602aa0e802be1ad968524c5e517ffb7009f007282deda01ae7c944a06cc3e6fd128cc932504421ebe84362e91ffc1e2387c8f61eaabe96c0333aa3a33fb442a728319c22eac78c214bd36ff3a495d5317c1c2361a2ab5db249f2ee68be6b1480c2cd1ec7b3d75cb53822610a643bff7d395c4b1d50a5d9b508ae89fca3237ee14084c0227d1f609d1c8d20ef386801f7f66422e108f36441a6ec8b304655309c7ea19592c44dbd614d5c14a95abc43d3b11132607dae3ff2eddf28027984dbfa31b6b8a9498d0fd82f000db1ad9cb5d55cbf3e44adb756a90525a5ea19a1e475e0180c2bc9cc535903929fbe573da3c1ea7913f236aebaabcc7707f14001a06989106aa8b33308212a4c81bc9d69099484b19ed8ed556b3499a16bfe9d96ab0f6ab70b1464e1a155dc2d4740e4bc3200b52385bd62a54564c3cd28d3ff307a9e3f70b88a17edde32150c41b25d1b61f1390dd5b6dadf0c7288a802f3a40968a8ea573e5bfeb2c6672f1d041430dc55ca0ac5c0b879a4a5d856fa0d1ee4d1141955a77aef31811983c91a67d9a3f75b8c1316f6bda6193313ebe474de3051d117b67705b5a1a2542edb2e4639e1eff25ec5662138535aa9eb0cdb2a5ffae711f91cd04e7a45aa8a028f749d1f6e75f0a945b312846d8fdc0927881b84a40d5357ff8682580c15de4b97022716ee313f260f2656ae16ac8fceddf05fb916188a558cf65f251b1d91541dce583825da09bfa5fe0c234b07fc836f07781f754252bd63f3072b475f462aff2cc83cad2e56831c06e0c0ce4cc37ecb94ea8cdfd4ec81971d9b140621b46b51d5e54e8d25d0bc80c796928d88e37a13055269872c708d0269db8eb129d5be0999dce883dbd420eaf07047799ac014972afda271e2ab04cb4057c80cbee69c95bbaf1b40732f66e313e118464754c69a8b86fa2140a193ec0f24796efe1025d15dd823158352f304518825e62d6cdbe6250d8cb5bbe54f27ab8bf52ee91560404d6ec24b07383b6e92b37dd1049c683f5ffda2be6100788a5a6b461b11f4028f0d2c58eec42687ced1f84e8a17f19d44c35e55def24dc85c3be4a6dc33f79b839c1c5044d830c7833fdcd42b7f2664cdf00a5ea15fb719b42c05e0bf0c6c518b264d41b97b9edfd2f734ef252ac693753d05c50af4214f9249ad6eb5d2de38b96e4ef7d5eef9cf99ff86b4abba819f28cee0ad3377da209eaf4360df0d990eda9788e061827791ac19dbf7fd4be7ff31476003c5e440c22ba9310043a94be1212f14f3788a3eb65bb500677e063f778b1b400878c37d68e4bf0a436131fe79985c327ce385918d798a4fdaaec87b1448da48996e82267bec09881d146604341dfcf70cb59a51cfabb98aba26858ba4a20155f62c2a2d4e318f8dc4ce047d393e32f37f7aa0ae9de9e2a072eceb8be49a47d795e7024134a30ab773ac2ea1023095c7fbbbf0b5f2e8646c141f76397584b1a88ae5ae6458b6997e7b6aaa2eeae27e12248254cb253e17db4dce4bef189ed585a7867d61f951b380f0ab283a11bab1b37b8ed715cb6ae8ea2981f0306b541a7e51733ac75c3402df8bd27d7628152b7198c891985d3643c2f49e0dec157ca02ba96dcb20c4441e87bc86eb508ad2f18f450fe0540cc9f8b02fd34707ff255f1526caaaa8a1284b43f2d4638558c0752f98484bd418ce57b915450fca7ec30dd21970fb1202e9805335215894ab0d4b4fe13bfeab56e1d962d1e7bcd888c0f05f029ccc74ef91e3b680a150d10cda6dd3bc909350656e4d2fccf62e4e9bd8e62f2415c19758b0d388f4269a6513fddd301da128356862482ccd2be0ee40c26a447e08a0f8adb4e86198fc1840b482b511ce53ecebfb46bf3773e325b991c5fb04897df50a13014ed11b264e5514ec7f7a701d82f83161d4f51e040144fdc0b091bdd70774a9a851aa47db935acc69f0d121de44b43d491c2db6d301a50240a7ec83e8fb84e0633ec31720a41c168a73809f1ef7b13afbeda62b8b84cbfb1dedafef6e2ae7d1e88c7fee4d51d5949152f2e91abd5c241522088dc3d7e160413d22a245125377065492b99c8d26554b4d174ed1cc095fe30408a606eabd64c5efea3462eb6068c12fc59abf4655b0234c44afd14590e9f4ccd3f54582990762ec2c13632058ba05d12a30b37902899348bd3adadb7af6a60c9a94a413392c6dae00292cf30c206b329be65c598c4110cef7a253fce296b91c48c529235b694b4e4ef7cd78755d194cbd151fa3bfb578843b950517f487339b385fe601431a0e9c4ccade623e1165721c98b7219d5086a5083b7cce708a1abe372d0b8762613cbbe14f679cdcb616ad938ffbabcc64f869b584c80f8db9b84eaa8b6b052b296c865a3d541fe926b21e53b5240b36388ebb355401093d3f680c2b4df4c0561d628de06ef7e5a62ceb832b9a5b955c4ee98dd466d961090cda380043609578941c054d504149fa91be205731165ac2c37a8f49d83df9f82db7284312105ffaf660ab89275947f3bf2db1004a45e5f840373873b866f0f2e5624a741c5bc2d54ed4d1c41ed8fe397bdf59c194ffab5419a6f726222881b95b19cbd1d2a4a66d734a58717f88306a65721e6f9bed7a01783872493d9bb0debd3daa1e1ed1dce0994b87a168ad7b66714214c66bc12840df6ad6aa2c98d055a26425f1d3f2f63bdb23158c98d12ce9b710c5bcb0706877b36155dccda8df8fec83c2ada0f0ff3e9bb1b24e0b6552fe7e3bba635e972711f96d930c97fd73885e57a6800a3b6cc72fa9b8a1ca0a373d36f5a06377c9a5d9e0c70e566b9ab3774e4d78442d46fa136c79a9840b7720ef6f004257b7edbd71662ef38d47572b126c05215381db700c03f0431a685962f44b778d38e618749db26b30c44fc7d969b5c35283110b1483ffb850a6e870949b137fc3016c43934126fce1df46d9472e69f762aa04a34b4043bcc98ffd9da58dbc5b36f5d6d27b9d29d869cdde28dfa1b1e3c4b28bd3e2ef78a05c561224e54e76ee650353a130cd1ccfe392d515e41486a4299654eca7e95c5f7e298f317bdc88aade57b74a3c0ccc530050dacef7d300d70a613553e1b316d672daf52ce36c6e47b696c9de2d5257ce32ce3f5c4b61ced5ea29c25df885366ca29eb5f4d945c4d0821399e1c6b66b3ad560ae8a2cf8f5acc4b62005e1a3427c823e2d75833bb180f2244ee7f9db291062862fff4f0a8f4494668608702c3e99e8ac8a913e420d43defde2c2c2a466070700d62347d20f9f758d9f90e697e989e7025805eb9e1f52fcce34b8e485804448dd26861b638444f7cb7480da90951de5d672b03e693ae45f9120eb9019812845736af5ceef7e3b7267718e196f7e7af5ca094be3896cd0a3655a55229500a574e1d085b3fdee38956343eed906b828086990e3baec4bc4b6af180e03fb3ad4c78268724ad5b9e5da36145b8bff32a32f084725e71b19693fed4ba8ba9a4d532411af0aa908a08b49ec9cb453e21f8b090574d78223eea4f6c16750c10eb75208d6683c67c577ca2b37cc11887a3fd4a4af5a3038aba0de634cea0ae38172066fdffa2612c641af1e8b4a11b9dadb57ce11223fbeaaa9344afed2d9157939b22935d455006a224bef13f7e815445a9286e061248f32c4cddcb50c7f22c21fde694cf3be69634e07dd2252eed6a51862beb6c2929fb981f0ac55822bf6969ebf46e089116d8c047251b4d0b6e12309ebcef0fbd58f7da904602abfa2f2e16159b934e69356b564b6794e4b1adf0688f8acac9904958b09f99957be58037bbecdfc02532d84188a40d8f09550fcf01adb8f71678c7f8e0deccaf60729c5755acbdea0f4ef5e948e79a94ad6a9dea24ae8da48ee37ef81ad74f97ab80eb0299bea043115028c5d94f064c6277ee5b5b1071a5bdf83d2ce5f13dc32ae80a582cf136b510239613212e480c8383b2ddb2147bbaa6be4dec636348c0c5b3b846355c75e1bfc9eef3e8b3c09995d17f8fd08b8775c87016b60e408580eceee65618865167af6a5b8774fdc7cacc53485efbd261739b8ad327a31c54ac956ac2e842dee005bd0140476c9dc4e82c2ce53d6e5a5edcfeced471fea3c5ba0ac9baa8ae9212e93a0917ea637b6599859ba0776ea0de92b1085825f054f75713659043c32e18493ec38225531b32c6623075d5271203126ee9f6048b8df12bc1c8858fd3e03e2920f375a1445d3f691e0e42fe7c83b62d40e6667e339c437d4afa83d286c9ab4e9db91efc1c2282e4350d5e92b9f91596c6726bc9f11eca97ae782096efcd52956caff1a1e68b88f290900db3f0496067d128c19f71ef0c3fa71905792eb67a88c2aabd98707adcde386014801b82d307497073fbdc6a9a6446278c71d482dd38c1de7f82e2cf1802b40b34981429436986a410f4e41b63e729e57a541aa547f13f93e9ba3bef1f1d6f4203faad39a0163ddd6384737b22d930897c6492b83b07e05b6f0045ba273edd0ed26a1914f637c54c0112deb50439e83a7001096f7453b25bdd6503ad3832cb6308cf7e8f5be0d509987c8f222be70e62a6035ca22e96a5af7510fe083126c89f84c878c2e9d6f8dfd7a67e538427e523f359f02a05e0618a021939de5672c2d6d1703fa0e89ee6d8b53ce12d1f36a9de0f7c12c5a0d7629808b20fda329a956ed225e32f63ab35f2ab592ea905f9bd67c9082b76ad36330d409c9cf7614d97d7b3e16e7765258d6f52020924a1fb5e8b2891332c67076bb3b1e5318ead886d8a3a57851bf61c474e3ac29769a03610fc91e8a1273da957c9931ce677326e68e43132138d7b5f1bcc0f46e4dc226b5fb1a4d8a18a1ee40125acad7554c8048c6efdcbe66d58f3a90e2fce0d1261b6b8a5d708357afdae42817280a01b0d667919a48e41918e36c0e741cdac6da11fec910625ba7d6ed050e5369df91748ff517746961073fd4dd24552165a083aebd8314acb2d2481ab733ae2db36a345dcb51dbd8954cda2ab5a69e38b4fe730425357e3ba3149eb144ef6ee466597a07acde9b80252e172bfb3592c42c77efaf3d9e85c640ebd4bb184ee801f5844ed0a8aa65a995f75b9bd31bc86bfad36d59d9476a22bf1ae488d9a12461dbd9f99017e64bcba3b7e6e6bf9b7218ec5cb510fe39e3ed1abecf160aeb9a54bfede67fb396da53dda25685d9433714831aefc03fa4c7b383bb67d162df8837b117b6fcdd5c7c1b59cba313b7fb324d5564364f5f89fa0246e460e6032b50ef6e78af93aa40c54a80c6603afb0401d8e2e925021ad10e481d5adce9c35bb43062c5168f7e790c6de11452c8781bcc087c704b5b6a64ea0e25a2d38e8c6aadd6fcd00aeac8a20a6601e3226c6b5a3c849d0168d95b1f9de56ed7566394c6aa2ef0b1e07f40337e8881adda3c6cc5d2d3fb6382bdfe542996433a246a80029f92089be4b34d74932a7bd5c4047515b4c763c6b3a09cecde6e8e13692dd5c9e1d297756753e37fc104ce0ee0e7effdb1486b664448c2a9827e04dd9c7e945efb7f989e0301d2f9de95225d33e5755e8aaf10e5eb79cf5a6be23fbb7850b6cfd9e55ed0b82844c00347846ea2cf9ea5609b41cf2f57d1f907452e384edd5e468972e15a2410cfd628d65e063ce78fc4b6a11e3051679b79eb2e34571ed01415f5b1b3c8eb85862182a66e2f9682989ea4c8d93392bc43e1cc680639a9211b021c96ecd41b91694d2fd35a841e1f47fb309f0487bc5b4d5d65d5498550dba6dd4a2f5a9cfcdd887ab0a8c08f0b2d900c6205be0695df49a97419af2244fb75fc97e54eef445990fdc58ab62176a40bcf17a33f4df434883091f316df39e2d956b7ee06e5b7ca0e6349c0b5a9065156e0fe926fc3ee5fc54bcfaae4b9a629ac334da6337fdec44ed0cb14771fb3c3887ef0698be8ff882e2417edca74a6d7d3df4e443fc23212835918678c4f6dce5fe5ac3aad98b3e0551158f2f5b90c297fe3a6b7cef2f94122511c34a9222dabb9b712bbe93e7e54c885581b0ee68b5a1dc2fe575399843ab7a3462650460bc096933134eecd64d50c1861f41ae091eeb439eb398233b8f9245d52b09b10b671f4f6e888cc6840997e8759df853c7b2ab9b44e548734056a34c7c0aad09e0f50a6fe3c06ea2e521e38fa409c1a73cb60a05911671b7445ce6f118f44cb5e374c73b11c1eb204bdbe5d1e75114ad39972d69670a1d7249afc06473b61851c48e22d030fec46669f7fbbe3a4b945ad8342a755d972fcd01751f30363330e5b421b5c81d7f9c4ef71c325a70e67da9f2ee1c134e4c7693bef33c3746ee1ff70db4ff6f72e60accc702d50ebbebeb2a4302a74033229903248f58ead69132e5be5a0f9c0eea037c3305bcdd7d3b9474a7017016f12b8edf25085e5c0ab060a9b863168a876068e65d631e5332ea7715990b427cde224d53f7c947a1a11af20f8ee3b1103dbdf6b4de12e902ccb47ccf6d2f14f06433367d9f31cb7019a52aaf16ffe7cfe61afd9673d4d5e924fcc28e3ed4688664b1b6a94a99d56f4be825a0e3948a500342a45216f8012faee92663b8b27540f662964d06a702997bea42225f3f9d037501406b298083f4c05b578f49d880586e1eefe827b3521cf4e038962966bde900bdf9ee71ba60d2b159917c6ee2b713071e647a5a16b6a7df237b60cee924b4dfd604b18fd64a1afed66a6df92a20fd213b663ab4dd88e6e9c8285e1a44e33105ecc9db2b3ea275ddd7ad5a86cdb9f7f7f05d004730531b6ff82095ece05cd16eb1d7e4c77c997ef8089ee6886048f6fb1c3961227f4730cef47f10b6e13e2da76bac52e0ff3244be44172cb8c2aefd3b7dc217a0d5956bc4d6cccbc4011c3308c854e51ad46da11519d8b6b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
