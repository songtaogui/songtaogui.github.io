<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28027f5d2c7ebe9d40476b3fa78eab866bdc591e9b016a61137460f9cd284518d45f6094caf061b80105e66b43779b10547cf2357014d995a3865186fd8843c1907e5d4f358d75f8e9f55619d649f87ed7e575df0a3976ea3415db9c0ee21720451e8e367e6be141030c5932aa5911fad4242a80a2f5a243d5d87e153399d967d24cde0a812c9d9d53e84cb61f2e585e4687d6184227c28709adbce3fdad40cad05ab64f9eb0c835eeb327937f127fd8410a183686b60ee0cac72a864ce48b4121cb7a88ec672006cc8b2f3c43726123130b0ffa75eabd1c50f2e72f2b6739f9cb2acf3b466852780edb477caa351852a7a0beead735014b2a933423ed8914654fb8b3b459430eec96190cccd63226aa8162d08b7c01b07ba24447ff2e11d27cf27979ba982145ce8365531fe4e9808a82065cfb53f28c462bb506d51d488587938c708dbff8ed3f5027c39f4848d544a664a32cbc53cdc806c1e68d2bd4bdb804bf33532f5b8ae6854b1858ccddabfd36a3577546e769aa2e1fd3c1607b525aa82aa80f860c65ce159d938a5c826f06d4ec07d4a996aadeea5743ad1b21cb136a5cc43bc7bf06b225576f3b0cf08f95d5602d6a07aeb26be703595a80ea9c5a68477ade463fd4fbd280622cc6fd6fecf0eaca2c6430c35ee4154aba7c07196d3e8e4d6fcc3f29908066ccc9592ea4243c14db4a09b7743791cf394d773b4585e2cc6611cd4b3e2c29e59c1b080264603778442b13867e3d379246aeb28a7df1b9a43396f48e47760f88ca6ac80569311c43eb31dd9566d61b04ae156ec859a781443b7eaad2a3ee2ea54e54a283c9a495f8fe438ea4e322990856dabfc824f5a7cd828acb49709d8269afb988a334c3c5bd9f6e34c8ca0f0a13c160c67cd0d8bac75d6178c1405c547fffd9dd6e43ea2bb5c50fc1a330e6566495579aadd1b120a85a1c8914e692c12a0b6a9af91ecb677eac173d6dfa0ab3ff63c8537739735a09ceffc928a316ea66ece0941922f0dc6d322b4549a6ccaacccbc8f5ec6348c905007fef52844de8a2f709cac4ae22116afbe60f7465cadd1ee6bac02b3bb4b06805d5df540d7239a64e0655dfd8de380814231731fcbbf73c4d7eae5390fea08fc2bc4513281f5056c41c64f9550146a9d43cf19d366c849cb9dd1de5384c2c4fa0024bbd16405b4194fe4fcde7cbe02a3b4731f4a33910a5d5df067536a211a11c8cc212e1853f219ee106e7821200f50268c4861a292459af93621aac6fa294d346764e43265ba1aa49717ac3642a7eb7c128741eb397b08b5a919717e8daf21b157a3b244b92383ec53b3ef615b3a71a8c84547c16a2353ee8fa3fda8722a283510eaacb6b277aab831847474fef2b8b75220674bc0320298b14fb1c28e30518f23dfa985582ccc3ef83329bc5964420fe7550a21fc67c1dd3deb06d8a35fc495fa28471f63470315eece42400e4dc695395ac2d82e0f5a17ae1b2f0c6982fdf44b8e997ecc4e92a5513ba24d174e71a4500f528306d8fbbe1eb7c1edd9be687e51ed46e5062510934d5a852282316ccc0f7c84cb982ecabc7db4b5293c08e63d76274bc9f4d6220075556f7509fb60a9dba01e0cb7c71b73e765bd734cbf8d3085240a38ec2eadfee85f99dae96704dbbbe33aff6c0bc4c3be5a8393885145d282c6cb1f0a2bb7bcc3d8d4ce4a3d3d980f2d0d3825f1e75eb893706076bff988bd6af6e4cf00c01904ee8f5a4265d77c4ef36f9e0cb3b6240dff318ece744eed92740b2f541e553a8e3c0ba90a931c7ea116f765cc0de0267b172989bc2300fa711085dac5fb94066cad44ab040bbeda6a07a324b944f6918f8e84f5ccf2afba9e609041c73e8502182800b5a5e3f2bab282cff333c50d4d2a5e2fa78a4fa7b78508d60a8c2845258a8e1b0fdf9e2cc0099d6c2a85151df303ac5c6df5bcd43997c8a87cf4c765b138d86073543883c35e8c2818504d229f2ed989597551b95b08f019c1148f79d041b5dc25b9955fe3f68d89e0b87de2f167fef014d346c0ac795509ed5042bfb39fd9c452f900592c0ed21d3b4fde7d3a0d9dd59d802c803819efa532a0f2edfb6604ec532854c152fcc5b6cac6c9a4e175ceb95c34a619b8649e12894b7e10610b735a8f8f779ff5be3ae1eaa673bcc3bb5cc09303573f6730687a27b45af4317f2c364a2e73caaa097a3d177d6dd5c655f633785d3d0107cb7bb08f558e0a32c259ec012f26d0bfec25c0593cbd3a2651813488b65a52004486c30339a49121e36c4d6b54b0367edc471f995b77af252dd1c9229376581d3f35cd50d5084daaab9313700936e494d841def7590fcb8ab6dc674f66a7cd30b60a5c3529a85225efa0b8362ed27bd104175cd4de3985b7843298d362997c2d61dd638732c4e02c2c725d5c6cba30128648bbbd7a30b3b499140c8364f7d4ae79a0f818901660a3debc8077b63e0dcdda3f43b0280ea718e598a7b35b54db796652a177696fa21446eec789e9bb321f004776bf5e90902a1064004fc1fda9fb6a9940ac1c5865469e0b5325ff74a92d505a7f614b6a839a799759e6adfb15eff532710b288716204d5d116074eacdf24ad00b1be5c36e5207f9b0a2ba39c063893c01f1f2706f327bd2b5f34014970d8ea0c8d9427cc86982078c2d87d621dbb1f72ef6b0a742dc91f4218c89d3b71d58f6a07bb6ac0b72dade228a70d6b5b772aa5b22ef68ab3912b2832fe03266a7a2a9b0a9d39bac414419fbdf3f52bac29ffc0dc5294711455166c8b2e62e771148c328a2b29faea3f7ec6d93685d47a782061f78fcb53e26f50325cdbda5b075c433f81c71d6fbf6b564fb805c88f06d097afebfd680baa92d48c7580f2a8b7020af918d02b9f12728696d871408b965998bfe94d1eefeb8d5201be3aa686ec38530c7ededd39b3e530125df00c24cea665425279f9a3e9c3255335b0d95ba22d118a4e951274c762ab60f9bc2c5e3f5612cc9734de6d24f48a447f89dcb085336ac119c2b3733f1bd84c64f1b46c89ab1980011fa65d009c8cc40390d7679f47a9635aad15a0ee5f625f2941fde0bfad62f792df80826d14cb2ba6be7fe4cbe51f16f161d19fbcd09ade2da56832e70899e9e8fb072275479d5e9f83e10a64b3715e802a8ebc73a0a5d0ff94aa6e424cbfded9bf879e200d72252c00ac0d38fabbf60744453e72bee92671c0f59cfd59de92caff58ebc856074c87a9b734585f3f275b781517304288819ff9de4e88bf917e217114a56d69cb1195e810b15c48a3d48a2b864b28abfdbcee82988776fa4b4d4d7b837ae88b85f8d14f47f67893fd28e2f86f8e7e2d30b4078725dbc6b8473eb5b25b6cd295017a20dea6dcd092c64f76e8cee259bcf188346eb0a93393fe465b8d7607c2069547ce4866fa43b070e4e06c069ecfb77475738d60c658fbd4f413e0f2764f7a4eebbb2d02ef9d11fc2a2989a64251d051dd340580f38e57636b8ab49d506e126500824b67222370887ebc504d8a9f7f392d5dafca015021bf52a03721945c85d6ba7a820be21651829e7fd24040d68b27e10ddc4f3bb20cf35e5a74c64cab2d9baa0fd3216c2c5dde665fbdb0561d02e72a710147e2b8cb562748de230bad94ae6a1cdce23c8b13330f8ba5c09d370abaf50b63764f03f7f4d55127c7380aa0c61278ab1eb491654b2531bbb50dcf7ef9e257d8f5bf8ddaba00b94f63bc3458d265ffabd8cbdf7d778678bc8c8749d854e0b206e3ad6828cb1b467655657b4befb1fc5f02c91f25154de333360287507072e38abf3afdb3ceb0587d81f017f094e4760ba3f6fa4b2c701c5bc293ff6d1820e2d8294982c467fc17389e342cdeb878ecdb7c3e342cfd2044ffc4ec80b7893d2263a2d3a8ac77cdd7d51959b65457b602acc4499434b59f150004ee9208e1be3310a0902526e4f346b24ef566593f8ca5052cce0bc6c6d438408fac6446942b0a67ed5b99819d74a278e2da668f384ea6407b8c774778cde61dc2d197bfc6b59de5390a70693769c59f94094a3afba17be82edc08c0739cd4961c9a34607be965c272b8ea9a1b7877f7d6f9252695f448e31403330947a851c2c4194885d0bba55687cce0e197dec7eec310d04232eba5dde7bec73085a48aea3845e9c7200559f575a48e6b74153fc810fef6de0354669842ecf1d181602631a3aa69252954af0dc3c9fa99cb9e0e2671ce1e91a5b0f60f261c2a103dfda7b5e510e62513f1246b3352998f2397b1dc63dcfebb510ec4f6174f106f25fbdb8b4a8f16f18f756dede913e0c860ff2128b5e7ba9445a0c42fdfa1464b83ed997f7cc2c14eca40d425f6867bf91d264f97f14d1f901cec84974a0b3295132d1a79f6c910c5b9d3d6ef587b83e6893e952393e417a9fd9c0c499520a3a7fe7e70cd23e402219a78d90779cac3d1208f4434e6e1bb287d64df0e71f949c3b4d4a669b19b29281d868b67cb5dc556a89c0fd3176c919e299436a34db81a687a1fde09fe4f53f02fc4ffdaf42b285b290a99cef26577a9ac6c83f670174c085c09584c914242987cc5c1e306d6b58155c974069ce6956c6fda41b8e941672bff5b9439573162dd3608aaf8d0bd17d6135de5ee4c823b8aeeaf8981e555d2b0820324a3b75e9997166eecc41e60b4262d78f9c27d54175a739ff0f401c3a10070ce2d6df5c0523793dc54d9a46d8b8e4bf6ac8d0b83ac9766475d80e3a349ab0e43ad73aba14ca5d716540aed09f044fdb04d0dcac4ced7d6b1dbe6ab4f3e9a755f01fae9e63c48beda61347ddfc1944de9e94373b905bcdc13f50ec9fb06846dcc596dcd76e43824c331b632674558af824cdcff2e14f456f8cdf9e1dc2a2662ed5d61fcf8e2cc9fcadab2e91d995c0ce9c94d979ddaa0d87442b2c156e690e489724e45d5a97006e9d8ca32e1181926dc1fc4b3fb28c4b9d4e31ca7b7c20ed8d726f970e2cc79af902b077978e76e533c84aa248851bdca16bc28d5cbcc6fbc95bd69b5f87a216fab2c7265f323df93b7137993570b328240782563ba881f0ac6855fb08abd2c309f9cf4839b9282f9d7a20e882ad3d1474e56b6ba0dae3e47364ec6794ad55ed6993d185d0acef89ceabf76f536c91b1fb30ea7f9c82bc2bb00c7dd445d4a04f6bb34fe4c34b8655767524af42e97f56707bce5b37867027299a7003ef846a211fbf5ceb0fd02ac9ef1349c1a1e6d9620791b214dc2dd933e8929ef72d06462b4efec17ff00a227b372b7d7e32ad87d7f7fd56bd45c9e7c1f8a3e731af8d612e1bf1719d3b2ab5933b633588a85404619429b1143a03713b24c31aa3d7bf628f8a873aea8d0a22b49e3ab76fdf12946998c4803e971306c9f919d5cff1ee13801c7727f7945b4b1027ca02ec91571363a62c040c5282204f4c81d5ee8324c93762886002fbe02f08ad22a756ce8fd3e874d685999cf19f2d355aa49fd4520f559f7d5cd163ce7b0cb889066fad892270cb11ce58ee43a0786f47a035b43aa66e15ef1733b28008eaa2023e4b55dcca564f3d7a95e431b0d72642f972b19d51124d2421d87eda1bbaceb52c7053b4d4753d3d9eb821a9766819b6068457956e5aa8723315c1df971f078a3e9faf25a91eb96784cd4ea344173c358b8b01fe6df3b538aaa67c18eb1360e30a251c1d76a7b02efa6b7043ecc51dfc0ebc0b05953a568ce46ab46559193896929aa23b80c558a9c4dab70232a1a0f53b48e75ac944a2c0231b87137583547e5a44767cc66793929be073b37c345fbb432de660d651a45434ac7d07bf1121c86bdcc9e89a170945f3b007dc57afbb0453f7670c2bb30b084814d76363e301d633e331df26dce8d623887bf3918a6909b89486416d22aa5d61f1854ce668929c1972088089c88692674b90a07c73e404872efebc5393f4e3a72fb65a05ffc2729474ca21f63f918a0561343d9d2831c74e6fd3e497ed3b5e0a4f82d3f8b5ee95e8005c28b9ca29e0f39750de91a9a9512c41dfa419f5fbf95bfc8a1ed0be2d96756a3021ac3254aae00a28de7d4e65be95768489f59ad7f882289b83d887fd848399ab44a8c3fbbd4b0a9987d0cf410d67776177ea51ad5a26ef84031d76ffd89a73ba6249a619453f9e004600f081ddaf677ff5ad713dfa800a080542db014012308bde70dcecfb0bdf2a06ac98d1f9a52d4944791b13568d3de75f0776b787b409f62eb60d866071b78fde308b136d8f4273a57fb5452a2da240ebe628a33211954d4d2aa5ef06cf06a708a183ec68ac7fbd580e4e8b422055ec70f766ab989d35b5ba8e5321b1ebecd509a8e9610ea5bbe97d91f421136a23561bc5810274e249e5e7878c6d5b0a32867e0a9b7860fa707f0f2075da8bead9598dbd85ec4683f530ffbeedf5eddd1d9deffe05ae8e9c9321af2b67a883a901257d9f83a57f3cffcd4a4da5df765827951cd9794720b20c8ac8aa5878b9d8f68e1a564c82362b189d4d64cacfe628fb24497694c91cc5a6cb7d69e952bea41bb4feba6659c13a37ece4b6c0cbaa1880529d7879cbc0275691351a083666d5795a6ba80b1c716115fc788e4d597a6516c870d9a031b06b4184c7811b614f06c4fe472bec37c29e5ee8f84a2c02c9d9a334c6587684ff21e58d43052ef79bbe7488d4fd23836f63bed9ea1ffd86632d90cbefb3de71f1376a791d37acfaf674145fac2debac79784be94efc3fe4df5142bccc0ed5f770b24a5e1a834ec5e745b25031c2d637ea012fe88eb2a512f15c960fe6825ba51ef476559b75d984b7590936732f761cbd88105618e9663696bada22c305d1216d796de41470cdaef89e2d72d9a951d1376bd52cc3047b4027294dc17018d48d92279383dd1c6b753d618373522767bd9269f851672c2cedded055d1005b340f68cd05ad4d93b715e5bb78f492045068050ed3341eef7cbf3a135bce6800cf46252f5953001682d69b59addc54bd48685de0cbc94b99d646d6f162a1ecd117a2f2602edac27bd429974931bb9684af85aac00283fa291e6c178467eae60ea814bd53463c577e657b3c976f9f71d04144acf3ca344ada13a6b0e6d83d0a18a0b3a7e13a4975389b9c496cd9e23f193d983198d6aef6c5706fc3bbfe39d640cf98586d757ac4deafad1d8aefc7e07146ffc4abc20ebfc631c96541ed0fd4173ba6ddfebdbf7564a857712f2adbdf0efff49358eef10e6fb8a56fcce772ae78463a5a848eb4d65cb7ac527e6bd0471b27001d8fd8d621842da82e7c1029928cace1b78f280b696c11dffd3bae0ed759355e2f612981f0491d621ca5e7eca3416123223d3a045b8d2cceda9da6a703d696c98431037937a45b68b102a7f4ab79d659ac9d34c2b98407cff9b379a12a195078ec983671db3f23a72b819c74f8276545597d748954d35414f3e0f8e5ad155e3b2caff6d1dadbb57bfef00f354d503709cd10611d08a3bea386fc3d52ea2b3acf6392dcbc4e36ba788b0f3c4284cb704756cc1197be93b611531133c9d33a55059aea8b3eb03452d1e0028540370563fd7b7e6db7ee3d35e5b3dcf486518d90de08a1f57f17e2ebe757e63a94098d2eee945acf6cb4e183959f3d0b39640d6df97829425b90f4e2729cb3a8e742cd174ce6b7e12d6021953319bc618a130db9b49c8d7b03b7c45f86a97f7b2e709f1ccc0ad292501bf4155b9b2a89375fa3621c04b03486d084f345fe8947731f3cbecc26ed3fbbf35147b162df3d4d56a6556e78d12aedbed433d0c4214944207a87a96e9857b7c8dfc51e286a31182cc8a3195c1f22e063782c06daeefb61017cc0bb3c7486327150eb777f221658c8f0c3c351f96615717ad951fe23f189656fbfcceb32c9ee391630f5417402f06c5f1a65b1d3fc9e6490286d87b1791c47cc74f9f2c1520292591a0366f8d7273fe1c712a3ab359569e70d3f8ab6665896f244ec69903133f184329d099d9bf3a8d508fee4bcf039dd6eab3169627950e26aeea6face629be4a3b76c606f89393966c1663a870b9385f25855ca76425bce33acbf5c34ab09694fec892b581e4093965e0a46e22a7745b41d59e53c1ba358dbb8e4f73e469333af927f0f74dbfa3a34bd1d8bef2b0800ddc5133a56be040cf3894deed40a7c235269ab332afc57ef1e2829a23a243599205c3ffaa3ab828c31679dc4e5a012cd8e15657b059bdfad57d9a79e4d67f6d0bb5158ca8a23de1eea4ae88b24a4dfed6a0e2cca1e9908478afd36b9f7258b1a21e2aea21951c2ce27c04eb8f92b5e4a9f6a3c5ef2b45055526517b3253bd4818453aff4350b2909fbd4be33501ac38e31e995c9d1c895d15c6350b2c8bdb9f96d2c173ffe47257238d87769d71a2856a67910a3af6b892212181c1a5538bdc3621742ccb43f2cbe2c0c1790eda71c3cec5c99101391a596480e675955faaec82240fd570f01a12331377eade77d26f5926dae0c608a9c190a488cb12697b256b407b8039c5f1ed4a39c34b306ec9171b949ca415add9e80bde9da7a9523b740aa1ee836e78ae653ae73b04c9d34b5b7e50c988deeaab70ee4d9a0e5a94b619cfb1ccc14727db2e5b88b65fdcfb2b10ad4ab593fe3c034457df0a7b9995c39cf01abb5cab447af455754a765199011b0b8b49873d93aff7a5e972ce17913346be8724fb509bee12a52ab17e86b3cfc24bfae9da25aa745cae21d30890a152653316d87378e09efd2ad0fc413328a29d85e7d489c3a17ab73eeeabd46e07167a091c595ecf4445f67b430b0269f0d8fe11b28b2314558da43fb52d7289738c8317ec3f7e8307d25116795141d05c9ee1e3f7507e5cbdb4719cdfccf5157b474ea108e3c3ff3ca63a21200e522ca1a2855506ce46e6b4e1249cbbc18b7c5a37c350b9b8c71d9a0a745d46ca5866b82d844ce1af23abf6b8c5513a36afc12e15b801364673054ab6a1326ef7086274b4c319bd59f65935b8aeeea85b38d5c86074e48cdf7a738fccf4665fdb87e320bd655b7dc345f26c51f1b0f08873df5ec6f992a743333d532fa283290f9b64d23b4fea64aa99f9b200c5a78c791d107eb4b72ddb17795c9972a564de9dd42f9182816d524844d4f041198dedd5c46b39fb1fb6f183e53e4e9f409876a5257a3faa6f49538d6914777b9ff1e6e12b5396e3b0a9ad33a7d30ae3a785d03a9a3a89e6b589e74abb803696a4550576a705e180b2f035123ebc68f3498287ea9b2eda8daa8e2a5797f6ce3774f923d1e976f4a9b13fd913b48c2ad49155973b944f80232278a10a73c508e0e1671f2c300d4b2966e1a1a330d2e746508964b057a7702c07e92391f158a7517796ebf8ab9853bdd7ac65f06cc8e2c8a6b5a2d3a94bda65481c38922274405f8c6b2fae3ef2a1b12883b4a158173724c57b5df64d67716524cd2b8ed8a834762127bce2e174c69d3173fc7b9bca2aad002721c3bdabb35626dfaa078d272c210ae0a7261f30aa690b273a0b6021a8b7da2ca553951d14727a7db336ed8d092b76067fc0ab588f8efa704b8186a142209ea518a563e91457b96c4feae2b0666878b90c7c340d2b4b4bac5801d99a57b579c802565f2ba442d5da41b47a866e1d52920a7901e010d2d02a4290308f5448032b6da30304c297a4a6262f557cfd07e6d0bc7d8c45ade44806a19b1c58b2cc2bd32c6eb4bd38dd901e9433289a3d87264fa18e0973738035066cded04b79a0bf436da028c1332365cd45ad4be83db8762a54c916ce60d88e88afef03272303d86753fddb1aaf8e841bc8f05999e187dad3aec45b1c80d1607d5aadd1c2c8654e6773cf2368822ae0de6832fe2de35b401f3d0a6ff11b479693b94b38f132498594cde42fc58415c4bf77e6ec827db269942c327082d70c92ca99159404ce4d4bdd118e2e361f54e68883708400a428314c52dde261eaa87d55ef63e427ed5912d36745f0dacf026569bc7c77517413c5539d82279056713fab1fdebc1c516f56b3a754303da228f6c5cb8f6b4c1b7f38856392d14d7f47194313402a83c8f2a0b8477dd37a55f3091c0d3cacc9d7ec20d34a509ec8a260d9ecbef76472c038964dcdcac1af304a2426672c7b255db4207d7aff963bbf0f821777cb8a76855cc69353e1da4b20319e141c9858bc1e82249588c7cd04b81069ab2bdb4df9450372e50bae067f4270ddc015745c71c18e4e4cfb6ea5104824a33b462aea8da7035fb462abda4b55b80f67ecc25d55693cc6dcd9c08eee1063d8055a56f267e86cd49c1d8b9800325e4aa2759e7d1374b3008f05f10df170cc21509c030e295344ad5890cb71c6d1a63206dd6957afe088fa2c89b43d7f0a28ce8b7c62d1f3af5f6571b7ed4af9667c4e56efeb5e7cbd3ee47caf3f46c1ca4bf506d17f5c6c425ded92853da56db58f764c3f069744cf144deadc83fd63e3c677017b89e009244e09d2c971bb1eacc736cc3563bed35ca2a3bbeda162b04d7a17cf1ffc69c24f077a7e00525efd70d5eb37d76b5f64bcc0b2f28d3da5394b17d3d18ae47cd58a944390ebf9fe18b2077588aafc184fcbb5d7cedaaad87d7aa73d7439c7d84406c1ec5fbafcef3dfea3e7b69be1f96cf5e658d1f4771531a5f390ae260c69768d74790ea94d6d59a21211771fa725d7c3d9c0b2457399684c0ef685e46b66c780801f54ce298eb7628a7f98a69458696a73f002a4247e6fc52aa48c60f32e2ede0b0d91dc2b7a6385328395a55739b86b215523dcabad0fa714dd091402aef2245ba709190febbc12b1dd1e36810e88ed43e06dea504a63e0e67e7e501aa454d55d427d55a585fb561900f25b6e5a403941bc901f97efd63ba70edd8fe1db8d7e54e0ed335c489c5c218a17b28e0f61b683ee76738fe2572e2b3ca440451bba7b1ce3fd8ce5976d708bd312cc3383d22413c2a4eac4cb431f4f3d0cafd4bc18aee7b823f875aca08cf19db2e7ef35b6cd0f0dd20895fcb06f6d98c4a0df55ddc50cb03ac6ae0f8e7ad61b2c271993f43a41925de0dd1874ec66b8157052f08c8baab48670deae317216d0024beae2450477c908b751db18c5d8b5eba6be689040d0f94dc4187eb656e3a83f721395fe356b9ce38133034e776952d2895aca7c421e607cbd6ce26b6495eab8d912c6b7933cac3b2f0680cc1357a8ef5e3e50cbda03286d02a14622ffd9bdee2756ea1bba1a0845e28589b28bda86ac9fff9615444f71648511a12ed6760d66a686770d3d5b36eae1d74156850af73e3b03c3b7578b27b0e6382b387ebcbb48587ebfa1c7e19853956b889fdc3a3fb33cf2867fec0559a78e07b7a5457c985e96d31cef4b425f3e2b28aa6fc264d62e0e25083fc1f2e2053265dfc001f2ec500bdb1d9de9a0070d57baa1197e138d9c1a37d88a817b57395aeffca5b1540e9a17bd349b463a4034aa014c8d7a70892da2172f52c655340b6c96677addf0c5a0a6ea44183c43f0040b99e9b92fe3092bae49c82b696c159a5682711d34901645e1d2e738b07269ab09a4c00501e63bf4087d52dba1cf1683c6f545224c226fa35d8fc369f971543be8424ff0e2e159db5ac844da5e566b0923e400d56ede3b3ba73bbda71821219b68cda14e0495eb75212293a20cd3cf2b505df44186cc54217dca8c47ba75cbf1130990bd2652218ca62fad98f18ca995298bbeb725d9dfda9d00bcbf6d514a24803fed5ca64e96a3a319657708a962f438f1959c4af034ba77b13d605105aae45cfa8bed914ef7141925335acf54bbff3e36f9930dab93d3a0f1591459ded11b791414bd5f96f2fe7b71ffed078174c0bb2107a4ea19c16966e70ae19788e7e9cee96ab2d8f0e152161ef0ebbe9b1b2f176891ad1ccbbe90eef2bdffc1571a10c1ae0477f3cb341175ae09f6f5eeaaf8ff0c5de4a05b47e4bfb4694735f142eeebceb96efdc69e4c9f20cd8fa02dc872990af37343f1c4e0e3523a11f10078dc0dc8434b4173f0aa3172a306013331750f2b61beb71c1f14a43ec3791bbb203a07955b17fbc23e4af9106a877652375105af1e81fb1d1763e862576eef59de4d48902847dcd3366dbf61f7b615c2d1f35150c940ee38411b8b758a917f020bf44cc751804f6d06ac657f07faaddac350d30bf4c09e7e537c129fd163f3c8b628be47b1becf650027f18958751b7ddc8006e149609a85c8a00f1269ce5265c58a18a248bd26eea470b13f002d8d1822b1aa4b19eed15e6a208349cd0abc90c3f87b329021c87bcbb379f9c03817b5670ec97c17cdbd5bd36a57450cc738003b89da34e45d05cbcad076eccd8be654358c47e12749fe3eeab86fc4903e7a2f6fa8dc91d5ab76a79cb9b3e901141fe4121c03e60970150166ffe9ae6f468b89736fe390e45b1d57a8f923a400da3fb7a04e4e315faf8d74013c0c4140909c6873a3ebc5b0a1729dad4387672244fdefcd2a62d7ef814ffc044f16af77134f8040a199ac962c18f3b1e7f584be81bc6a55a005da3ef0dba856799dc9b8f392181dbbed4debdcb23b8207c26cb622d4e3df1aa4e51ef689dad2a351aa9f369a2dc15601ac2f4e541a0c4a47f17a65c20f643712730214ffd32303d09ca6f5f6a90ee7a875cbe97912f3c2ee0f03711f24e5270dcbc4e7e3a8a2ee498f6e070c7300160f23e3a6bbe0c6287646a23c8a34b0d28bf12f14cf4afbe4b806c63ab24156470cc10beedc183e238b63de4ddc704ac51b28dc62b02ecef4d11d719fcf0bfc8509379a5215cd2036a860cd795f976247179ac8db0a46e03f5b3e153a9a2b1585ebf16a3d42e1b7a3b5774cdb3883450fa408a2bb88f3fad61fa7d3961a22a6c0ea7d8060ff53ac8c81e6de14d43f56f1b5b6fc5297b30e3fe0bda4703c2c7239e5d2095902f241d8c7bcb64a1c87ac99169b1d194252ad89c5073781854b1e85a1d2322cedd07cb402f65b4ffda7e12c7ed64161fe9d28f7ff38a42a3f1ff7f0b12c2bb16eed009770895abab8b1b8b2eeb2865200ae675d3c5961bd5900114ababbb9149da211e1689729e63d4e272741c9ac14121bab7dcf8493b9ac5de586a2077cacd5cc86841dec30be652cf7c0e05b45c95b29be08f3b5c5f1488026ab1af54a1fc29544053803feddd5520cee05c6f52230ec16ea0b906559f87e12dd8c476345079ac2bdd9af7592df0942c039897e65a3364dcccedb38307e10d3c515d9e1d76cadafed7db350ec09b52cae8e41cc4cf7d0df8fcfdc4b0469697fa488e8822a135c6af2a4a5e0f1450d8cd07d80cecb5dea48bb8d6fb3c59ce48fc4a6d7eac0f57550a40c6ce6cc5ce95d8f260ba23c4c8ef7bfd9216282fae604d5bdbb5c08c3f00c6a9a37911061afdcd6f476ce7d06384db3aa3bc7b22afc37fc8695027545cc8154afe70fe0a863faea5fac38182f0d81ad5a999d9b59d4d50c3bc02a3faa615b349725e8f99ad2df379a1c8457ab53752a64bda27f006ca6e7aac152e67972ca862a28ecb59c9804d4f3d64c18cebb3004d0eb5b1873dd648ec6a1e273c0ff594c2ddb5875a4d203f3d420c86cdf8e4bc4a6cc3ee5252d339055ccafafe348206925ae90be761791224b744e4b54ef5bb08a4e8f4eaae2e9680a0e976090955a50092718758fea42b063576b495243c6ec099b73cdb06750db3d2b34eac25b8f5c298de4cb54965fd1750777620cebb681e0a04d3a48e1cc61d9cc0d6472c6e2e0550c8904f0ce6be20d62663cca5b9e8c2f665f80ec41272a18ba105f88bbf2e5ef8c59fb1ce8c5899d1f786311010c21a33427a6cd8632bc86e00a5d7111bdef76bf0fc389cc5d8e5c11055087a21ee9a79a162567c267047ecdaa4f6904471e14a49e6699bb72e266bc4e57b0083669bad01626683e8cf41155a15ae7899b86ba6746d4b2e1f79f67386eba569dc8e2da819c4e0cfb04983de2ec4ade85c3a22620f3a0abff319af2362c25032f20901df6f73fad042302bb5b4455331e48c9229831f51d6d1381a91468fbf99db05d5f7c8aa52ebfcc1a00ebf3e3f4543088106490604aa9c64df6d9e56a013ea8b1dd652db3eb92a07bdaabe5da77ca154e8891c28eef3c7c56f5bbdf6f1c85330205d8cd617a0ef8b726ecedc4e15001de67ea4a5bf223063750175c9aa58296d37613f1162b12a796c80a980f0b148349f7a006be21e5e93ba2b3545567451e92df4199d49c1dbde1eda2b092205cf0b7911c52b88e4c6e8872fb9036080e902096fc75c18e96c62dd14cce7a8e79711f6568661e619f6baebe85052597c6a7659c0194e618e5cd35266fa3cac2f0a7d671b342efabcb14ae414e14131d8f7735d13f847e9a5912c41b4456e1b9f8e39e74e60ed92c0009a8dc37c51a91cb40d61c77c1a47b13c0261e43561ba5ac5ae7bb5a6453b3c8c3a14f6799e8d426e2a6effcd136e627ccef3bd3a2fad09d2014c9423e007b6753929eda7a4732e1292350b432877a2e049b64de1616af39f75e01f2a3e71a39f452475041ab861e7ee4e2f7882fa7d2f209113cb3914430fc54566a29a80f4760b5bdff0a69a325843af514e2a4b5ae02b5341c6ce35bcb8b7460508be634176e8986b0d08bba3cc9d17c05a24f79e220d5878a8cd626ba8c94b0fdb0fb37f0b278969c344f1d75b69fc052df8295e1eda3c4457e241e6f3f15bae628f857af06e04258876ca9a1f177600ddd73db2c99f48e708d7a15128a5c1afa3cdf1f1e8989858c48620b458c5ed7473086481507f089474fde585c714f6418e1c8bae8a22a79f75fe66f82f43502ea8ae47b451a9e18139e5e109b600a22e9ddee0f5d8e9fe07e672f7af8e5600ddeded6a4c59f74912fed8f5e46040adf2ec3603eccba2cc45b5394a69938efa12e4b9ce959d32f1a24d0a1921649fe33e752764663807ffddfc4f947a30f6ae3199ad7c5a10c5a9582d7b3e0c1f0cccbbe458d29cd19588114ce36f7cdb22b1b24c4305d5fc6e90569a4bcd70d1ebf71a0c1f2eba8539442c2c965a8a681571d68ff14057bf3e6f08922f1aa47698033b50f46301b269f4ae098c695fabc190475ecb1474648dd855415e02b2052393b4381df8f9cf9b6776fd3eaae73b886f33735068777954caa9489bc410d3accfc0c995c74cdc9234a0949c6714773af482464f1eb15331147ebc4f30ca5caec72b1d981b5ce811e8e15a2647855d4f3bd56efbd974fa2d5ebb2a343f3bafb77ca4eaafa8c4242753b51d954db3437e5e9e3c490ffd503bd5a09b23d7027b26b23343e70c461895b2dcd69e41db2de109e58363e394345e7a592b082cda9a66f2000d54ffae7512280be843fbd5adaa9ff0431a7097edd99e948c9e35de04ba58951ab9dafe323eb4a56fe18c51c35dc141cdcc04ece4d8eb6e86934d88c8586c29e299981170b1bf8f7deda40ca250b0061dcb7e4661b960dab876aea4ea99fc69701c1b8eb331a98d9619b913a0419c32ba19091df3e0724f564aa78289a2d044768b3bdbf7c9366c9d23b65cab468697af9083b4bfc0ef1c45b8eca577e1582317c0a30c9fb6c8675b8d71cbc9093c792fb513d53f5319aa6db549efe9bda285a3d68bcc8f275f6ece5ba3ad119404118a5c62afbe91a47f25ca346bcc6e89af6b2fdae441dd8ffd29a496bb76721c71a46b7a65f8a2d55d363ba2a5b45e0bd113662005f76fa8616118c3ba45537826392f324895b5f97e4f9d29baa3788267834851d6b3a4fa60e7d1877af0f23f0ecf55677b11e6eb2730cabe39b53cf337c2b346384de8d99cb10dcff4dd059fd302bd01b672ba2ad7283e80b0cee266a369d1e6774061a7fbec7cd6969a90a2e1f3df59e859d0835fa82a422630e4d51313fbdc77458dfe52057568a007defa9cc34f1fa7c86531576be206da0bfb767d02ae352fe1100fedb2426ccf7735a14fff7a25826747def5e80edbd6459f540845eb961ab7756f9fb00ad39fd92a60ea21d38af35fe27954cac530a4cb36a50d902cca06bb6eae6e8c4957bef12ab4aa5fa9a9916cc8c550e75fb42868f6302fc4e0cc45c65ff59d3ef010aa80eddcdb08de930eddde739ff5cd5fcd8b2d0b3a5286c352debd4b8f26df9ac02c1f1baf899be5bec826277def89fa72371317ac2f9c81adc80018df9c142d683ce9524108caa697de3c1f217d875fa450de3cc4a0032b385fabea23098a80c3979abe71a276c2551c0e57cde5d9474b1af7e5e93c3c996b154ade619147889392778f253071953ec055fec4348d930ea68e2bd1ce51a5413386572780d30eac1056aac1341067fc9bf184d00f1f415b4adfc87c05c3c5347564ad134a42ed0910265354af78b226867ef5cc50070049c6f0071632c5665a320dcc3a03fec5e87fb308bade5e49a14757bb3408dff69b3ef2b3786478714ae4eb7ae7a374d4cc6e952386a40e7658c2847d5a5993619f4e8ec1d8001003adffee047c60aa42ec1d494ed69751c3ef817158b66af0685af94a5a71f839f5efb83b800a760380379b02f8cf63262e860769eb668c8ccc0c034e70a0c26c9d86fa5c9ec7ed8c8c87ae7b0b3ad71b89d85a316f5cdefc1eb8bf06d44afed108f0f3d2127c0c6b8a84e8b5e71c323b573af6194ccbd4dbf79f17fdeb6081ee68bd27615faa7f9ff8477facea8fcb45045ed57ccd2c20d99aa623489083eb91ca9bd48784aaf1f22e20d55fa5207e998e3cc845de6305109679c5f1ba305d752658c07410b47018b160bd3b54b0eca3a970e29565f0fcffefe26e5064230a1f0ac2a127d9398e0d03f97fd9263dd1fa5ac338107fe0aee4694a6c2a365a4e6f45a6e1b4f0fcde03862f10ba99634f345667b433213f2fb49410f877ba4f270ebec62401e42f8d8730b79d4c2f599e96de25819c958ce6b4c5aa5099cb5180336c5a1da50aa2f97cc1f811ebcfcc4a2e5f458ed52370c28a50156e2f310e587386c33486174cdfb41355361274a15094ee09f5a71b8fa57a1275230819d8620cb4455ef520aeb30226c737eae90010605a1979d9725412d6cd49c86d3addaf950f7feadce047b4347dfdcef656243bd588f51fa45a13e44fcf1b5e1dacc227b28028598fe85e9a2ee6b2ffcc9869929f5b95297666ec3e74a62a970d441b16a2668f7209558f4352ee094290c960ce5a738309d825490f2845e9f998add0ec7670f3c542945e3a55f994ba2cdf91bf602fd19de4d481b375de145d236616d5e588c8c518734f19508842a1e8aa97af11a5a224d0e7266efad289b37e752c1de4ee5178ae5485b9915270d62636f0dd17568eda88357fa63761d5e0537cf0b52ff221aaf6f81a895e4f458e4c3d190c822587effff2f88b0009cbb2fb88c011d00e3ada89f4d242cb19c698d5345bbbdc7b9aa4409a6f762fce898d4ecc70621606233245597df2e394b10c561a47d0615b269a2844889b1d889fbcd8344e759c8cecaa79ff37aefffaeaf1a740f5640ce2a4adad72b030557539b3ddedb8e977f9dcbc10e4990169cd6cc79ebac79271390169be6a69ddf58c822cfa45bea016ff520a66498423741a46d40c83fe57f572be8fa16b3d069a22c7fb180ca7d201831e5fa9bd8a3555961adb97db85f5f5f08519c0ccfdda48a157b6333eb3ec5377462d93b25225878f72ef76e10a21151ffe17f5d5e7d0a839c25b21b8655537ae5e2f595dcd922c8e9c981aeda73693a62ae46a480625571f8495d4a0caee3d8366b19f422fcd84a7b61b41d93901fe3264111c0c1e70a912ad73ed8e41b8a2ecae39719ec1b21a1eae25f0dd3d41a8766aadba59d71fcc95c58dd1e0e14f4dc44e0677b018f858d0bfe13e54702a3e6d4f023382509fef38a5f8455e6655f5bf210f7c86570dc8c06f82e0f93de51acabdd1c6e42e2bee5aabddb3b0bfa90c290820b76fe4943073b1327d8e1467f9ff01c8be70aedf4f4c876a4418046fd2c9c8e68cf1e7116e3c93f14b180465c1b3332a11b4398cc92d7d884c0a61097fab21b96dac5d4e839f78af07465d1914fd5cb2907f092b5d7155552546178111e35e276d2a35b50781130069fed1242712f50c78df6ca8c811c8a8d77d5f6afb40bb4d54d2c799530ba333e1ff78daa9729dd0fba6b596b48710ef560165e3d91e2e76e745de60067a9fd0e3642c7f867389686cf052979d65c486538b2911999ab0fb1139fd82709300f02a11b28bbb2bde350144bef4aba5ec40b8b86ee894f6b0b335e731bba86f96f1a871b8a5a0fd534c0eb34b9adfd4c8de87de257dc2a15d5c68da9a876115d7df97d321b1d7501f2b3d9eb7a75cd2d624a5b204b7b63fd8dfc27efa283211729437d1b9c02cecf4d3695727388105217b0c1287c42b279bc43aa0724c5ac49eb9ad8881b54d77d1ec4e4cbbb39a63d95b58286e95fa18e71b09326b9fe27324863980931354fe05a7cdff32ce1ce29556bc12e5b36019a0586998d4b20b0a8919666b4b5af427db33ef64ff3cd4bd5ac16567983c99969cc4a2057a4d53c0890a010168abf6667ee13efecf505d183e355a7e61411e0dfb0b721bc8da34d08cc4010034a9ff6280dd8fe6992577b5d723612621970eb5601bcdb82087c758c7a0285c5cc1c506d28ce11d0af16db23510406f8b6dfe679e3b93d426e33ff8814ff03a5a68f9e9eef8203e49345837dbf86f1d7fa020468eb22c0ef5e60d48bc88c83ac1b3edc7f914f1a6f173d482da18f7e426703d7b99a3e377e7ce64e1e353a0daec037b55f394d5b289d342a8cd2bcbc4f95ae6e3f0142fcfc217c460fdd86a399ed8584391909c8da1980d8abd9c542ed97c976300e60150cb8e3df989fc6de988dbb39c53892967a742a62bd02a49e0a1efffc7b27509f61eecae7dfb75b21b2db551f2d04db876ea54da2900254abe4dd6dc3f986c3d0bdba00719bc132e521ef0f4689385dfc9308a2f6db4b04d3b1ebb9b306ff46cda88b12ef7be5e7c86b2bd65c888dc8675b2ed50a52f6246f7e743bc3b673e91b91f3518cfd5fdc6248d2580f955ce7b1d471a1d21f8c332b7d75ddbb5cb5debf15babb7b8b556db56a6f93ff5bf659110cb93ab7a12709ab1df797717a2f4b086abe738ca71bdaf46344ad942b4b8b6a966e876eac8ab840d0434bcd68842d9f8a94774c1d52458b5eac5f3da251df08451707b974f99d02a276005e6d7f993ddfac47fe5925a7eb59c7f49f42c77aaa74d6c577643eb7f73358b36485e5631c0bf903726519ed44b3f433454ed129b708b837c4001e73353e9d780d6581271a355fd6a6500a379d74c9e0097dbea12836d84ae1ff228ae1a1071efc01ff03f11a92c5fa57168a7185d622e1ad643ade31355295b52089abc34c52bc18b13f8f1ba929da38745bab89b6e0c193ba14660a8f1fc6b836eff4e12dc83cd2b3fcdd8da4b95e23c97e4838f7e9c4ab58ac5041f95d6c8570fff5f7e58c4bb208ad5e356d12882e381c5be816e88a4891b6d30698fdfc1631a019bd7b9d44452b73b49c5fa5910f11b1cd011ee106b3ea7182ef2902596f2eb03bb57852d9413a9b294d71a70c6f7ce9940206db7aac8c6520de939d2e2ef88748d4f51e0323cdfd4197a4aed47b4d657327045576150d477c28ccccb8cd7507d8934b182d03717122a3e4b08d55ed869a488f3d357a9a1d304a3def0ee15bcfb1727e64d697a9756e97d6a99992f7946c56096284a4cb17cb6b0e3e03cbbcb8059e612a0a7c417d9de96ea6617f1fd56080247d4bbe8545bd27b927c079c5e93876605e9e453137427f725b08536462f15ecb04ea7310a85e1c6d9208b42f46f4206404f4237fafe1e64cba6daeb29f7f5ee9cc9faacc2f1421608f0b90194e2dabd5645a41869cd899791cab1cb06cf43e3d1f6c78ec149ce03aade5b6952bc603431ca0207e002a35b6ea66c3886385f66f9e9cbee16d71664836108d71b88dac1e313f4c3ff84ef8d1c6b1c1982e197fb9783c11c7c0ff4761a37b172f8aa8c41c55c7fe92b67f6b9f29a431b001f80cdcae45c650077f71d5272e6b06742339e688f23e266c632e92cf335f4a622a3356cfea5fa16f62b1423aa9ba81b8149855f76011f5b4fa928533b997085bc8b886822b02ca5ff8be0517067087db130ade3de4dfe39aa7d6db2286d0c32ca60655d3f7ff6c6ec90bfcae363e1fa983bc9db70f7638a8f9395a927be1bdabcf8edb5b3a6c6a2fdc5e13c8408252bbcca57a2e2b9613878a1ec4490d42596fd4d326247e269f97895862be39122e22d193a8fe8928a9cb59ba8e2c67a680ede46c8e56a91477923d38c1180a5bebde1bac93997d8adb59664625a42e26b00730269b1bf511ba1945bb54a2bb5033693fc1c2de35f3d56d51a3d5f63190b3a200ff1f6d156f25a945aea26f03ddc30820f5ce931144adc2745b23bdb83e8b6adda4affa948f623464915fd08a9cca8da0bc3c53e52d92857acb0401e6d81b6638fbd3201a581efeea1e2c7033ee03d676225e47574bb686665b3ac5a91ef90fee93edaf757d68f1a949fb569283f291c9fa3978607a810bd368a8a4a913da7491abe19e00fbe29bce5f4089fb614a43d23680aae5368f12285e2cacf88e3b11bbb7c52f07eb7cd77c6032e88fbba31d64d509f8caca6cb488be099cd3453d929a766447a619da828ec30f65e9114c769c72f108af61fca7ff105be675a5089946c93802ccea18ac4a1d4e029916a6b6044388f840cca0bdf6fbb30f5ba1e2d0d0b57d6a0044007503c2bf3a5bccd523fe5dc32a80192c716220562b9b8f0b6862c1b2e38d62e359d01daa55d9ba8687424316d53923b22a3e7f37845dfffc460eabb6e8db5c3a5f45dd95138f4a6340765b71322b115bd1d119ef4ce6b87c2abd7fbc6a067c142ff92bdf1b025bc9ad07a3bc08c5c3495c588f74b92e22289e938447ae09ee23679d71a7e74aaf9b4871221da6615f70975e315e17006c79a7c0910ee7f91157d936e2aff44d304e757c774cd3452ea5550b21bd8db8e90e67efd47fa1d554da8ee200f8f1b1f208d9c899eded9cec4d6b1970f8c1e98c026014fabf908fae840317c80cfcfc0d39e0a12d2960744d7fb73462cfe4ad559b7030bdcffdd1fbef12eb265ff39e683df48e79e93214536059c2db68374da5363e6e346f865ae63ad7f6518d7022687ae33cfedb433c76315865bddbbed8f619d4bad2f358037faae905210ac36f75d4f9c685e01e83723cdad6f888f999f2cbf282f42edf107adeb66a63ed43fef971303414a79cad4d7f3a8c89164ab44dcb0caeac1f61d3576fb14b1b969efcd9b8aeef01515b4962c37f410630607601b68fc5c9cdb0ca4c36f51d83dffc3a00dffb3c8d0f8f26d3d9171cbe7b1c7a39b555ae154d836613226ca9218a2cb9a593a2e2a92c5a0cacf9c94e49b72edbc7dc96bc85622509d1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
