<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f3aad47d059e29556a7cdee1f0c54f34cc2794769eac1f61366fe0e7f80847fae5ca13dbd38aef6ec25573616291d3717361e8369d3f036032395cb9a20c65c68980e177863995bbc4916a5675db0e80b52ae9974e294262a8b12933574cba3265ad3bf500dcb229a9ae9ea40749aa930d2f793c97849b8ef67e6fafa5c69cc324b7b4701496d41fb9a03768296cd077b7bc24a0b16bb88e25d4cb08a5cf8aba21ca62ced5aa0e49836546eab30f5f4fb52aed6059e5f0f12b8e39a5ea1bc6962bef4e13b9f1573a9a723e1d2032139813a4e5e644c7d1c665baa28302602419da2977ff6592071b58077aab872e270179344a1efe62725466b31044f928a6e483abaf029a1651cabba45f8a39030ff4dbb89b4e4540a1e9e0b35b3655fdbe093ddda25f7bfede1bbe896a99947514b633ed575719e51e9f5d94539e9febe0cb6db81ec603c88b9248acd8c8676fc9f567cf3ee6f4f6153df0f5f0c83bbfdabca1271d72e0ebd4aa62d572b735f46e85dcd8c0aa9e5b4c4c24bd7edba9a3edb036ce32e55732f9358eced2cf6e894e752724fbc1d9bdff7679f3dd0117448e3482c0ea749ff7b5fbef9cafb36d260c2edf95cc820c2c05759ee46e66be3fa9a4ddc8d86f2aa1c6edfa54db25f87fc59724b4fb29174e755db9c40ae636d9ea32e3c4f6f46159997dab12d6c2a42291f9b70fe6110249d8f9a068d0d2ad435ecc4794b7e7abf22a8a906cf7049bac7326a14f35aeb5e2fe74920696b1955b541d1a6c389967ca3fd7d86d401f508cc9503bf924c2385d02fc32067a8142b39b3ce2cdbaa37890d83f1206085af29a96c0bb356582cc05b880456017fd4fa35c75c0814ae88e4725f5c4c7159385333e4c69b8a9da499a8b8a93e4436a2c021d65786337f0d17d30bdd47648bd711e1541ed1a48f527f58a525d946cb2925949defc1ed725512c01b822cb3d6906b2c7e629ceb722b586de10d41f507865ce4926ce232ade1dc943126a56c850ff3370d0239333bb38e830c423d26ed4b172b175804463d04a3c156b2083ea251ad5463e2308bbf168916c9e6f85bb92e62adec2ac7eb60c31e30261dad93fb859d5aa6fa61eefc1e61d8edd12e6003b7ffe39a5b9bfd61ec85050d011994f5ad01ddbb9adcc2f2babcfa501a1906ecd6d5a2b45a04de6a96f3f77a3d493a0c95e97ba84215fb851eb16b28084ef74aaf07be6c18bdccc1ed776580333957e28f179c72a3279eac597b9b3f1ad8418bdcbe845b7251aa3335fa01827943fe03089b5a3943dacb18bd4837aa80c23b2c48e52727a70e7e9c92a10b82373aeb1dd7f423048f79c84de3b1f0e49d5c7166ddb5e66eab214665789d15c355d7ad199475e3ea9ad2b29816f7a89af86af891d89b425c51d34752b9b94c8e4913721e289704d59c9ee8b8a2d88d20daba0e3b530a5f5c6237832b6287989faeaca546803ae8f8d43e72a1fb7a4de14777a170b11cb780d938dddd6c9baf1c6a095288212fa0610d2974ed41229f00edd5e1cbbd37056181d47cc448c0798a5b1cabeb32f758d521f1fa1d1888b17d56fd793cb12b5791371d95c60816364bbdc4ba8697cce3f14e5c8b11e91042587a3a178914a33fd06e68e76c263296455a1f326dadcbfa20988c2c9123e09fcd11b06919ffba7d1fff2b1966c5c93c9ab8acb5b1d0417e345acc375acd1282451423e0b3a771596feb83f1d56e9e28493331ef5d8bb99b9965731abeecf18d6c586fbd810d5a7984cc31a3d6a5b68af5e2259562e56a259fc64a5d111b55a12a09b7cc4de248206ba54b2d0e98240860346419d51946ec150447c0a4d14c2884d8dfcee3d47200da2fab85f3a837646535e3a726141ad7edcb6c5b87c62ec6cfa298494b265f4a4cac16f129d49ab63e3a038ad84f6f89b0a71323258350f4ff5119bc18fe3638ba43af177d0d95804b44538f9409ae3092177e68475b714d262054fad8ec68bb9c725726e3590f27ab66eb76546e5675f51117e1ce6c02add5e01595aa94c475cdf7fb1f98188c6e90132de46e10d7073af44f0ad359e282833c7b7a62dba148570d8417eb6f9997a1d02705533bdb92ce48853365b5d27ceae597dc473b05752b799add1de44a77192c32bebc1b87580719f33b117b7d71c0e648791f27580a100db213894bc469842473f8fdd6842da93782f475086940bb8c5174e6bbb687cc53300140788c111e6a09de398801e34bf7563b7094176a17d188035f26100a328254f1cbd0e3972815d46a3d6cc2d8ad0f1d75ce920c239b36443f586cd73701eac570414a9f0fdfdf0c42eac140342ad8ffa8837a149217e007b5fcf20eaf7a5bcf2ff6974a2c4a6920ef96f4ca4874064053fa1e54ff69dd24874fc505c5164ef3e734143f7c7d1ddee063c11acef612d0f3b556206671499f08597217be71974cfb64742252fa5d7f0083c8ec35ed1b205c128192cbab6f8bea92a9b97ef564e7320192ff978d0543a832a885951ad8528a675cd8ca0553060e166f0e12aadf042d3b03c190fc2ee863fd8f9a8116e09fd7081b1320e53fb6d97f9f4d2a5d6ead9008ed79d7ff51fd94a07e9c215c4976fb0e8e2c1f82983217ae660af66a4be15b521c085b12319bdd84ec2bb8ccc1fb4782f5a07af176a5cc5227bdbb4f32f4b896141cee84ea69e804eb6c5623c749344b84586d11032d6d2351e4846f85a960b641720e4f6e4def79a4ad5214dcc4fec95a3d8baf41144d2e1dc6bc58547ce52cf6a4fb70710984d3d7c29fd593cda91893830dafccab3b392a657e022a2526670bbfa8fcb4fa6e80c2e6de3abe0946e01f4570827de3a54bc600386b42174fd77c273493d9d28058fd9f02187c24652fc73900c59eae64ac04fdf06d6128f5e6baf413f148d935e6e7585dd782686ccdb3282aabf2ad43a1dad4883d67562d3d7e148e46668c16a77b69b57869204b7964610d41e4ec8043d9286b26c1e87bb97528b2de395ff6cda866df9df799285ee8c2785be306be84fd0e197e0060c7555de1abcedc362e9bf61d1ae3c87f7d3d0e2889c0a4a8182cb34051e754a7914e5083576fede915d7d00bedf19235e8cce5e698a66a2466bcd19fe13c0d0dd32b89b975bcd78cf6eb4a6d61ad524f84cd5012aae448d3793b877936dd07efb50cdb5166ac17547b2c85b00521df254982bf410631172e3069cabb441c6cbdd659362a26bb06f1a97928ec2f7869695ebdd87ae1426cf639dc7b0497131794ccc74e3aeab3d906ab9d4ef0dfbd800f99164939cd3827228d2d1b29c0b085ce191f3027f3c6474eb73195127885dfa7b1d7b9d68aacd0440a65daf78a144e8a0df32ab8bbc1389265fad7ef932e2f92a78dad8c4e2c8bc255aa6dd88213e3f9e01aada82e41830e59a302ae153e58eea14836c4e09327072004bb72ff608726b73ed736b0b28eef4fa647abc1158ae5f88ba5d39d5b82a3bd4c94a4ed7339a1e7430e58c23df6a876cdc9ce512dba24c1e4b91c1e2713b0b5b2993678ed9131b6dd4818ac42fcdf05c8aabafcc625230a47bed83f1ee39bf3744945932574f3126e802a71059d5b9407d0ce685d3c64fdf68163a275fb7dc48a990eb4672a7523a2227ebc64273642209d9fa0135b6dfcc99711d6a7efa5f9df8e01e514d340d4a918f2bae64207cd5193608f7ac6ad682a9707551e3d3e920865f62fe6f27a4e257ac4789eeec401c24467acb086ec9f371121599ddbd66a83ca1826455d8db2381594320bbbc10cb5a95d23b0fe9d505e311c5d12955a4337859bbd0ba93b07c18f81c7797ecc0543aaeb7098e2e36dd741f4958c9816c3e95b8d72ecd133834721d18d56dd56b80ff1769c263adc43c93796cef3914cd397b1589f91be25371e67467b20cc61a8d0f24cb001996b9e6a47ee25febaba015e05ddbbcd5c2c8ea22f3289d6d8e8c07352ab96d945db855949be6b6a09a47fffa5d259c3aa2841b6f8aa7aa8b80605470cba8c741d78c3e75e98c7d40fb53d279e43a80b163a84f82d9755dc26910a6182479441e0b9793938182f5889919272d8303ba7715fed65e07fa80c71c85acaa95d0078d84cdd368fbf374ddb715134405101c0b085af86c704bc4582a6ad3d90a6ced520fa7164252859db6c96ef74bf4104a8dec9e8d73f0ab26a57ac6c72b4f003c67fad02879fcb0f2c20f1f08ef78796fb5b0656456849c2e72f5110370d6c83d91a3920a3fdc23358769e3fbeba1e9afcd0c027e12475eade7459240099515857bd667d21e071e47c947ce75b1770efc313e52b9aa4d68ddbd05d143def00c4d445dd825e933346f9033785cc78684636e02d529fed5c9046f2ec63fc9a421c977df74ae3fa0d1a10c81048df9a45a0f0d60c63740119d4ecb67e04bb9a0a22d7903664a6a8a5e2eee60f021a4de4df59360ff7c071f17952a5991f395273954a4f8413b349f8bdf99258e4f00d75535879f565ded66aa3960949bae18dbfdbf744c295ed2beee34fc7a79954b68ef3ecc78aad9c04331be26617fbf1c92929fe47d6ba6a1b7075fde9e1dffd6cba43411da83fd253439670833881b3f492e95a5a511a090105fbba0a23292de1ffe388180fcda14e8c38f8eb5819f67b9ce58a05ea8c48eb41e76b4ad10d2130eec8e9a49306daf9bd2b7cd366fe015ad696bff6d393b2089aa3abd9df938fc08f5aad64c08a30b6ec8612b6c6459de49f2c8386423cd56f6ef2efb5dc719e768f2451b29eed75927dfbb6c85aaf2c837686768eb77326dbcd57e00c042bfda70d457f3a0ef4658d21e894faeb4bd2f22ead8f2ed3a7dffa02ad55b3f4e92e6e9c6eae441a461f3ab4dbeb6f8a5f20286d18a3008fe7e40d2bccc4b71ca574b623e2bbba71451d80482c07194a44deab1f6807747a3754cc3d38226db249fcb9e2c8e9a21997c968da0ff51234022a432b3c973fa8346212170e00e3a43c7eea1a6661a1f8b46a67e925f8ed0127141d3559e8c89589933d284c555856b04c8c18ab5029dd6a9599281d12119db0fa6898b36d8294a88b4a69f390cf183acdf7bcb5c87e0b4b3a1021b018cf40cc35289a71db6300bbf2f9d7c5aac2ebaded21f263f7d451c0ae12dd46d681ad3619690a13809b6a17fcc5a62d0a38ee95ec70bae0253774aab1a9e8af6d1cfe1f41911c4682ff8c3be2fe3a8a86768f120c29518067ca94d6b2dc2724f7987ab36a7ce67f914516a3992aafc8a6dc4c71342d51436917c74918dc6c0aeb1ed1c5b2fedaf7b75b8bc71adcc7341a485498355d7cbe9146834bc75a8a4d94e338df95064ffe0961e032eaee5362c2c66b3134d29f229c9d5e942084131f98a43de21da43191ac7a3b4cec397d3008b95c635696c2a79e53a720968c3e43ad23fc2e4ce5e152bf1f18b3e4172e54bd256fab51fd08b5342adf7d6ee6c7a9f1c80f1e9c379daf0c651946bfe3fe3bb789b80351d07f7b3c145c62898b817d3e41873ba55df3f43c92295c8d5c0881561332974a361938352ba6b4abe0468a8944cd665ae4eed32c577501ca2b8cb1855cd0b8080971e4dcfd88fb5b97d7ecf3efdcad9a51a544ce39a225d5890140b357133a2d5489192df39e4e596111b465fbff968bc3af0267c670ffd8f56e9fa4637e4fa3bec315e707cf816ad874f19032f3fa0fe5a5c3ce3163803193ea0d50fee17c0d51cdde67f20f9a276f06274b3f0f9a567ba8b0f0d32a6fd9338b7ee43454711c4a2798c73005443f3a1b5320612b2d50477b26b827d404a2674f364072c6a349a104c662c36477e1913ee890da0862ddd8feb8cd19b9422ee1236ca32e87475319dd5c75eaab147f620bed36706d2905614649c48c43ec7086806b432ef78db3ff166e67e208e863e8119c02fa8f00ff5d3dc521fd1353a0c02bb31ca6766a25a8d16788e7cfa856dbb453214d84d2220a2fd0b0906bcc89e986ed227063da813a3664003711742114678498d1ba018131d4a0df330857edcf84575b333d9ec5611b7a3d812423fb98e15987cc3f0c193eaaa8d728ac7ee5c3a817ff8684403a57b9d8c63115bd64d9ac31acb408edd1f795eeda6ed24b0aac54db7366009b927cac681e3dc86b3dfcd99be834333cf1611bb40c40f08bb9b2d3f4b31cee0b58f4de1cdedaf91c61a494f332883ac51ef75b86782e538a3bdd6d43ea7d70eb07d2eb9eba92d473c49747fbaf5934c9a872475111192c4f13bf622bc8325a96306a886474d6c1ee6f1998115a35ddbfe5f5388fbfc1af93aa04d715be2bf3e62c84e564d732442d8add8922e05c2e9a2508d937fd59a86a29098a45f19741c97cbe9bb75adad8f285f172001773a9e7ec749e166011d5b2a296a04721a81fe07821f103e30e5767a6b20cebec5b633c88b1316e95bc5e006e4f402eaef7340dfa7b1574380355b5ede6cbfb5c2a7d8ec55fc8e36e4ab61255dfd6f2e46db395fbe058121a126d8b3ebe008da1b3b73648df3beecc0cb405ea1eac0550ab38ebca8028586f13269b2ffd832b0f77da0e5e5ef721c5d9a0f00356ccc1284f432a8352b534bd938330914498ea4c91dac4e427c1fc60bf1956e6c03973b6ab8411420f8195a3f7367628a909842a83471c7231e3b6e0b6c28cf48fa416c1cd76ce0c45d6ad9f5ab320bed460727a49cdb44a020298d666d59daceb6f56a8e918c0bf03cc2fb1d0b4ee411ecb492d67da07c35e175276b73fe88cc27598bd2848e813c69c51914783dc6d4983b1bdb1f6478dc03df4a844714c25c3cf9572e75cf9d8c5e129db55556bced81da75287d9c459fc26bc9d15735d62b554794b45d7208b4100b2e7bfc15d3fa9b913557ceb8399f3632892bf1b30ad03febfddc37cf6f39759febcef77e25806a6be0b2dfa243c647479970e5b6c961857d49210f12bc1715183222467d1fefca17c6f25379f33caebfc7c0ef7008cc5898d9ca137495bd26880b88a24137eacfa0d5b8b8e3b5e5e9a25acdf706aa51d60059c508679cadbc5b222a31e540700b63d063cd3991f4b7cdee1aa7572a5abc6f5794ad4837dc2f5517fab0c18aa1a53f4498f33298e8f6d4993419e93be5f6b889a6ffa359298723d4305efd1d6f04b9ac66a5930b3ed213f58661e521060a8dd6fab565bf66b43bc11c750c8c50bb2393e45d3e9788f9d1734f7c20fed4ddfd9b88ba55f3cd886f24690080dce9b654bf598080193521b16e7096c477c14266671894acf08917f7269379d6baf1889781caf1e3b4b3c105081c4b336cbecac3e6824418d3666cb8e63feca929e558320b4afdded0ee628db9af15fe40044937b829b01af55c40285739e79e67d251fb34a17f0183f47000e4e0827e2bd7ad2103cf985effb85324902256d063b7a23056048fde6ba59f8228aced98ca025ac1b3a381326104f93d416515560605d35019e01f9155b5c0581ffafb04dc93c32fee101f14f2e1ea9d6ef4d7bb5f9f8f93bb1646df5f6aa30f25c428168eb9fec7f69af1d2f23df23f0ba1bee92ce612faa7a2dbf15ed9282a90e2aa11e8e81677a8234a0dc73e36058c5daeccfd42070e8cde903d9501179be6e9dc7e5bbc71d58212e17f90c4300f4d50a690dd2267fb685e120143f85341900e934d87b683f745661731e3be0df968b91e713614f5487375794c2ec7f97cc52ec107e4edf00af9054d9dff0f028173c00f36dc59d1aa6b695ebd22a925786e14832edc13be41704af13619fa86dba6ccf715c3e61e38025104683ddce249df75a056e28de304df7d42edbdabfa1330c7b89b90b27d6993d0364ab99b57652a644baf6b7c1cd8f158942e47ff07deafdf644ccfc395b53178b80848d026d74389e25888d1f98dff3f47afa8039ac20056dffb494a0afd15f0550f2d289de4e7cc59b0ec8bba0debf65bc3b5a6d8c188c1d189739ce325139266fad8844e96b57d5302081c34eac06e34281a4445450321cd20b4830a6895c457f321fe2be013caab763f2c724640caad1e04a208c3c763564a5c3c4d9b201b447674d27bfd017bcfbecfa2d42e46515585fa04b1b0dd9fb2399bf7934dc0acbdc235fa4b920a6aa263e066dc797c11863048699732bcdc8c32f55882e7ed1be476711372750a9c1f210462f198c56db5f4f65de599b45fe0386d01bea3414c0473fd16f160a8dcc4a27621e267e5550a8cf1e2d4b418ec8ca1bccdcd0828fa0c0073e477af90a09c84ae1359706a68c077416e6f66f23a335ffd479fef09961c9870ed8d63b76361e24d77a9df13143013913f0720bf2e8c058959a2ee9b1bd6c481f0db3892dbac9eb4a5d3a5fcdc7220936f4695e5877ac571131bf1632c19fb31c11f40683fee5b7d3249696b7afb48f525016165e000e3da9c4392b71b4a097a4b245a9c5cb6c036bbe5a1f21994965b62f9ab399163e8368d4453c0b0af9aa9f6c90c3aa861110bf83300e0251e80e248f80adcef230ac3246e1bc6ade81c3c6ff1c8b3d6c969e49c858fca937209c6b53d12ef7f45f1130c6342743070d31364e9dbf30d9f02d356532079ba54e62cf4ce18af5d4c8005668739865fff42a3db395c011819cb992abc7c8321581d37a465434219ba795313de63d8fd06e7e5a9a21592b9a1d676009e4657e00aa7e8294c0f1f329f90eb6cf9fd28b433811bd6e64f8a3a3da2236a1ad00925c83218932e2c79893e6e4180c907eef52f118f3d9f19da8e4e6b58c8739059c40ee55ad814adee8e7b76e5e175bc2d11439883b0eef79c4ae5e93f84ba818d8a99eeb5ad93be4d5c91c8510cf91cb36fd328a525d42522e0b164fc75c676c34ca96c0ca1ad2cf3a21b967bac1557a15ffca0fc5a8a221a94c844c50d2302b5a018b780b633df18b8e6b8d85025272e502a1b2bc40f0248d3c4090884f3ee12bfd285717c499de63344e7d9740a0137ee8aa3415012a78f48d04e269ec5ce95c2366ddebad6b76e6b16e66d40e02b3bdf10c3b0c9f00023ec9719675b036f2021e79d6fafd74aa1243b05f9ced6d2043b3b8092ed2d311f4a2b187a68f4a125c5e566cb099770eea8eb0a7bfd7b37363634ab6b9194d2cfc6eadde51d60aea6de6a32dcef18a8fea74dc3c89d3ac374c137a14fa92cc95c615a7ffa75b98d97b12bbd9cd446524038cfd71a0d8b8d799416025c57dc2144d95a9b0ba57f71730d441470bbb76a06038551d58418521027657ec59ca02681291d3f0a181d0f005ae45bde36a0677f9cd820d595ec66c3f852d80c928377dba813e3795ce4940d90e15a09360f82bfbfb49190a7b3ac091b43e6d647298aa491a8552e86c9e10323e443dd5f39ec22f08a5438409c8cb8887d9c12def24e63a752f78c3de5fb3cb819c2c5d6780db3bf6791125e1ac11bb286df983b0457da05d24766a9185f8ae156f9e0fa0c7e237e02b15587d4c6aba3ffb1cf1d06205126987464cc62a5963a6757ff9a37953e06cfa4a29b69b87acf56e396e7448b5feaa613042365e18c7be6e04fec609864f4337c5f450e162c2f3c132ab913e25c9aec70d02ca31355d812ba9aec2c3cfb519fcb2a9495e5eea94ca0393feb9d4b61466d8514c3a5c95614103ea0921bbd05bb5043c9ec628e03739871b29793d122e423ef68d8fba55e9df4fb2c418478a9692e2b90fe57275c63889445d9d30eb40225f4d0b2061619f1cffd6030a0f7f99161da342f2eefffccc06d77d1862dcd60eb62ad83f32f766b436cc21b49098fb1bff4eb02268feb6ddeab32ac4961363bf3b1a04688b08667fe387fc048e25bbe7335b7c32704e504f4babd9ebabe8ab0cbb83acc0bbbaec242cbe6925d52e266de6a0dd13c5fc9f861da32edc5d63bd0ca5967a8273f64548b410d0322f3426fe80075d2a35e5adea71d671eaa6747f13dc0832b042c6e7c89447d9cb6f22fa640705bcfb4a97407eded8ea4428438f3b23acdae90ca2b3cbd651ba873d878f40025db6bd4226da570fd84620d0d11197edcb95136bad39f5554c132144187f4812f31d0021fe3603ada34d6d6f9a9e4e7c05a1e8163c380d8901cbb7e16a7f24ec9d28ce821f2ac2ab4af511ce72bd0240928af5512c57b08e7390cd5399678ce3c495783c350fb316b89a99275127bbd7b56e38b5edc702126c96b55d1faf7b5e3a6146276fb3b280e58e0aab2b0f67663c87b3b09ad819867835562c41914c019db977623848d7ca812e5ddff895373d04fc96d4fbcf5fe5c31fbb0887dfbff006f1d4149547c9b1459f2949f1624cb03e1b340eb0ac1b91e34ad33e173b746705a3cf7f39bb5df1458bc082c1046988ae5c9b781218e0f7d7b5f82a6a629a3db89e67aa8f32b06e2ad47682fadb9c6eb97b0ad62591274cb43c7e5f96f20b7af0d88798956fbaeaac9b212c2cbd9c29ec43192eb0a0305740ec36438383dcf189e5039a85fbeedabe6a44397d620705a5afe15ecd505d2366d1f19c2ac7c4f8a77410193816b2f19028ebf442a0776f15235fd178dff3fd823e989c372c93e97c6f3cce8203cdc809646b35d48d5f53c4857b42a067fe0a781a8400fdbac1a0eeacb531d27745f251e14cd87bf6cd7b2b8ea8eaa86a2e657a96c14d07f4f93bb7aab172328af222a9cbce93c9618cbbdec3945f8a1f19f1c2e688b77005fdbcc630a882a6773b23da9c4058e2923f8e628590e2449c70e0af2ff963e433f6109d9839f81c5c92015e2fc9cd34ba774b17f6a2c531e8dc1844161801a3e85f6434cd7109a16acdf493bdfeb401da2949aac8d63c385aafe4ff3c8e0c8951bfd34b4a97be573de5b467890ec5598386547f2cc0ec9040ba12dce9c46de312bb3516e946ea612c57f91b58c62bd6580aef076ffde15025a624090063de131510b1538fc560a31a1fd02180a9785f1a8ef1ed2b4ec245aeb3c4f12fbe3aef51f2145a4d0c2e3b369e58684094e9b37fb558f828bf34b475925e9edf7867c5e6e16430c5d204ce50e26cc7caa2e56eca9a5b7fcdcbfa0e210dd7a5fb6a0870a0db76707d434a6af26b53125088c06b81c11254cf5bb61c6c1f7590768ad57c6f72fd8f3eb9f274684a86c40d7ed4d607697532601736d2fc02c07ab09c1631de36d18c8e283f8b93d05b88b7fe655222e7a10048670db3a6a4630f6f857699e9824fe81cc166390f0755034c21bca5aa7f2ab32506447ceb408f0f37ec45f6e7771f44bdf4c64659afe19e1b09cf8d9845ad864c815b1fe1c324c3a46afcb9ce197b17f16114554f9b18424ce493d2c49517447761a099006753ba433be16f9812a0d31290160088b5072133bb0c7cc1054111783c00007802ad246d2157f8db67b7e054cccc9f4b53d7da88f1204501e049545cc0900bc242528ec90adeaa0896544e916a6eb16aa06877386b38f1399d0eda0f1cc4d3aaa9229208ab081ad9f5a0b0165ae829662dedf97e03174138409cfaef51aa3aa11f284638b63da11389c8ed80e58fb8536405d1d73785f60e65f9cffdb9e926447a4e87cfdb1223dec26ec17d036087fb38654823ecac226586f456aee5cdc5c6dfe0fc0ee4a28d7ce71c8e0fbc8343fc0f8d676db4accab1bd3a2ba88d01ac35cb5f7ddd3f8b7431d31d35bafbe31e7f7362ad8f578386bd23e33f74cfb9d267262bf21982906adcf6fa1f9e108986540289a6e0d8994ab2c59adfaac5cfae31a5c7f324e2361d0db08ea0f8535f6f3fe282f0909155c5455a1dce763bc8a3209816566243c3f76ea8aa6d14ec1e57fb7f73c63d04e531b71110ec78e5af5009a69ac0a8d21540aa5b1677d6fe37d61cc28147d6a05cafb6db6ad775a2ea7dd7d8101787284750c3e7a09abc752d535f0427bbd7905b162c1ce5634b6f6d3b095747475a745bfc377c767aec84706f940156c07ed740a2243d2af6348caecf3dc8c8f2d987a6b6b3421974899f672b700e7a1949427a5d06f2be10434d9af8d7db851e7263b09027b7dcc92ce64d3ae2f334b51104e70ad8e2d78c8c78b201823ce1adceec544762a5ed9062b7ee6bcb2cffcbc07e6e69d19e15ff1ff9b14b1b76cdd20a18c0609c2148ada6d2b584d238dbaa259d594279c3635002d2e764811771e2dc242b63f870e370926bd30bcddd078dd145608965a8ef92d4dd603d2d6b6161453066789822872dd934c8c3ef38bf4eb70ba5c6d80ed9a008a4aff2d1956e6fc920b37b8b5df742e92cec470662b6925e5a5388585aaa64a6c9282d65565284221b2e29016a087e80d9207000de0e4c31d621f0c32236c9a3d9d9536f77e670d4c574ad117849a91296e53e1e711ce4570e7fd07c900a637c7f03d9e03e73cdb7c07b1992e32bcbc7a5bb77a92c50ecb8d4bb38a1fa14439d0bef097fb8bee378f24af57c0ec628d0ee4e58727a1378dccd16a688ddb132274c4e51cbd07e34bb3991d0e162eb853b13dc956c242295d43163edc7f9ff0dc82b2ee9562acb79891c6602df6df5ed40aa13254fd6eed21f6ff4b5d904df9be372cdcb4e883b45581c0b06b7f1e4fb32f39da1399bb7bb21310fa2c495325860a9b2d41373b7e586f914d70ad2a137bd52d38d924e095ea118b896ddec41eb9168e27c08b9ebafc9d095e971a326f4e7af2246c74d44314e65cd0750d63f07863ac2b1a848bb0bc107095d09545566f633a0e601f26b7b94f02eb115c0b93d2d47383105de268c38ebd7f600c45a6b6e9ab9de2c3cc781c9a53bd42270aca920612680af0a7bcc9455a3c7f9aed47b5afa47d5e5758e3dcc441e5b3bef65c76f86a012fbc7bdbf5d225d9d217ca7f12f3bdc1511804ad5f11e337167efab195cf6aecf2f4a769f714e3d961bd15ac92229008e84f0d88c2c1e8349cfa38f30c8bf0c494afd3467c603039c55149b44a93be81e08de77bbe1ff5abbad197030bfbf6095a5687d287199a1815f4ac1c3dddc7fb6d5d70a4f94a9263b6e2f4b4ceedcd692ada301bde397162dd9af81c582213a344392df18c30fd16967d5a4d183a803d4f4135c67939029bbaf9523e8b65e0f8c765e894eaddfa90f4e1330d775f8f642ee079731ebbffbb652d3ab279d002090640698c43d5bf9b02316bd9cb6c809d7148bca966cb30ae5689b3e593aaeec82d56c428df1ee30153289605a99feb96ba23a88533a9ba29dae75bcef01e087d60457784bd322aeed123f6c39d05b87f3925891762dc9a5ecc9d888def22a9aa50265c0aaf3aa9820ccd248f4420a1dd4ad26e5c17b5e1920d15b28b97f6ebe67fe2e95f8ce9fa1dce393e9dd018a92d57a88156d215d5f545ccb14cc3be08967c77e24511902c83e0efc26990ce74dafb5a12c03fefce1a383a57a2ee4b7f203583b959bc228bf29c88052c9033f7d5dab435d42db6127a1cc03b888a0b0b6741f6a8a0c40011f7222454c2090cceb2fc83c2782cb3119731fbeb487669d94fee45e16b6350e7eb431844f049fc6fd93f1a1c183a586cfe0c9ef42143e8816b7da7539a47b1e8bbbb6939263600129c36c9be386831775b1a6467bb6c0c55c7659357fd707a2ffdb47076601f3aab346a575e548e4f6d2c741e3be307dcb6f14fa7e3e521e02b63cbb4e8837a9f0a2d5ac96ebfed55cd22a1972eb5d9b7b828db33f013740291d9033675a66c92c7872abc1a3c4b832575557c49771bbe6045845f81a9209c9145c9d6c9018856cf2cfa0addc50a7dbe8ea44a31b11aafc0e9c6cecd9c023c2c6d984257aa2b6c5243af46f964dae5b9f220545208e4fc2a64e4aa343ffe1b83afa16135cf71743646814f3d16c39dac3cf3c4a6e4fcdd6807522ec2a068d9abdacab3dbb9131ef39234a1c658f3099a8838c2450069c75782bb1cc69f17cb779307b8a1e50cbdc27c0a30361efae27596494bd83c11946454f0027e5fb866c850a570da362ec384a715d8e33d446f0c2e5bdd6b536924f088cc1844ea25d63a683804825c05f5add70027ccbbc4d449be50dcd42f935d818d262e0e40e48ef83a20b656a325fd71790d4bbeb63cc9f0b5da4c16a1089bfb86b366f5f7b0390028f8b81bcbd6781dd4151abd9773d77586f89d2d00cf8ec32cd4ed63315d7f5ff418a206ac96254370b1b6691f4d7ac4c22a74f00dc627386a915f57ac761ced3dbf9bb2114fd18d516fb6bc14a196fa6c0fbb3d814b5292409ade293d2560aee8c43473fe72922e4eb25c233b0f5d92e01ef7066cd2caa73c47c6cb64060d88272895d340e0ffe3bc2580d91c33a03fad675f3f3fdde24144b458777a2425ceb45b4fd60c642b536389ad1f0ecddff79a18240e3e7e4ba2a825a55d9582ba519022d1e891f9c078056f004a3763a926ca149c123890dc096821f27a8be772c935b76a8ac1c02ee7bed2d19e343f663dc3ac6a72e5ebb5cb4c6de1d36dc7594e9e1828122f1c69e1573f18bfb2fa4d30bf414aeae019fa37f332f02987e47883721709ac2fab496f0d35ab980277d7a7534dc76584b6f49b5d5d6d0efca2024eb4efee0b8be214a6e1c887dc64bfd171896a543564442a55df3aaffcf613023fa79bc12043540e719faeba6549f8bf56893fedd5c0b250f39f4b5f102e2a6db9a252f8a2ad81112991646f9f2ffd377cb159bcc594f1577da71a78acd81905cbeb6d0cf77d2caffc6041cf7d46ef7b3604ab358ea43a34e30044c45e41ee2f20b4af5855fd84fe61adbca85ca6396b07ef421013d1a3ed6ef3f593d45a9e545747a5ba74cc0814001567a65864118ef527b78272286f8faa24215bf463265d135d760e602b259a53d250204c8fc83f23431a956d761843fcf238754a2349f5a8088f40a9580bd0147ecc9e3dcbf82e010d106788675f4ea1d7ca2bb5396dd56812eb74fbf758503396ec547a75c8d70d364c964ed4aad7651f4f8935bd81461349046c6f181c474e2342c104f01898671eee8cd47fe5bf08dc9626c196eb26c00e793ce543cd03590e22084abe79d9d42ac851909366c1f77caa580c1988a6304124b55f7e40acbf1e996e826ad3284201b01ef70a1a5a1021280585983b03424970c9f3ea1f3f541de014c62592d6c3f9a61d06acf93bcd9d67b630b3ca3d30076796a28efaa35e22c9fdcec6b2ca765c0e96f8f8d71f1590a73dc5b671ee4cc72cde8019587fe7b36ad720034a609b7a77c64ae1289322fd2e50f05a489244edd7f122f93cff8bd138a5d055dfe71b606d98b3d1f594ab5d5e55069aa2f716d7b2be499db8e60b1b002ecf5b251c220938322edbc0f62b987e6eaabcf3f9c186ac592e49d7c6163cceaeb01e769adacdf720cad2a0dad264fe3a080373973b2391a0e5728401a598f44c2a42cd7e367d0593e378dcdcdc67de581e84625491e1a20cd78de64739400706b8c13c3da3f781b1edd459409a673b9f5d474e8b359cda2d3b3aa0a8ede1a1b598c87c4d64e4f2169db93be91154d6cffb1b5e650a92ff24bb593d140f8d6b5e2dc590b3446e6fca0640c61b6be0e46bdb9ee9e3e09a0b729f14b2f622db9db44d83fc5b23a1ecbfa1a85b07cb70a47a78a609fa06ed2030d6d0f3dde933f3fa1794bc20bc708561e670a41b66d343dfd84838e8bbd1600141c718afaf7085535852ce1eb3a33ef06079626ba3f19085858ac65d4211f677a1a29d0f3e152df4eafa24d28b3dbc4678a80c7ea804c3713b8543f050d227ea06b2ef13a86d42d31b885eeb752853024d323457876c05d9cdf8986ba3ffb115c35755e7660683581056efa060e0185d54c9038035d16a7ab9ba16fb44e12d2b03a48c8359ea98880c7826b142584608e7b6f0e7cfb911622f20e22d44324a23f5f15d613e3637e7206408193b3af3f049ba9cc3e8769f446fda29707fc3483c68ce179d54e250b3aefacb24b57830dc429937067578147a70baf2d187dc20ea317c4cbdd8a21f25cdf27478d9d7256ba2137f46735c68927ec61660bd8414460c441901c16a9bb2bc5e5b1dcdb38ad64458e1a8103af5813856a78eb69914b2c1589f58d3828e35d76f89c328296d1da0e94f50b3cfbbfbadcc499ee24115fb79d640a0d7dfbf266b62cb69a9be2209db8a05c14895af89bcda80822d597d4a2c56a55979af88a9762dd4150bed403bd2776914feecae28965a0494c66021d21a2b23f8c8af18e19f64b7c5a6788764488acba175a99903ec4d8dd35faa0388cba34369939b81ea0076600ab22f53357f71b405ba5f3a5049963e66a6eb73602b53d790d2f4cc3705ccdbf8fe22083f9a0022c4010ffe7056c21f0fa847e37945c78c4dac999c7bff329d77644a3cbab11956da82a83274bd7920776fddf2d6b6d9dda33a03910215fd8b2dae2cdeaccecaded89f8a413af676d08021987c248f0844428d4e2dd0c6e3821d8766f52b8227330b36575dce134b61b4aab9e4f4f5d1ae25ff73573e1cf7789e6140db5786405df8bf3cec3ee7d30ba3d3e0ae5b81827af4cea1a5652db1d083a21adf063f640c2f5be62b0ce2ff8cda7e281d205bbbc75974d7916c8af1b0eda5d1945a42c684a64e734e4192029bfe4809f6cdb3ed88dca914f2f511eb8149f57dfe840f1d99d263a69216c41b612426857c1f33f1fea82bbe92583cfca82c1e25148fbfbf571c04f9d47871f0aba5797e5c8e6bc27b29758221ffd2257f9bdcbc96e1aad67b3c3e98c2d37a7f3f50b9875ca403e465647046fa7b34f3ffff4ff7d5f03157a1560f9939cee893bfbcf7a01c3d2a185432eac17b8959be4927b7be136a47a8a0675ac322eae5acb95b7d35a52ecd8806b3d2ae3a8491916fe95dba4c38e8c698ad405bba1ff96d48cc841aaaead4d66e071f1e0caa746a60e7ce28ddd265c812bacafac68b5eae88adf7a85e9b6296be38cbabc489d0144a6fcdc6fcf95be451b8f07a09df01653b088ae78a9715ea1fdf6a0475e109b511d874225b24beeee7e4b91f1d610a8fe024af1478a62a84eba07b5592365b573163514c63a5dbb687196d9110f5302df2944a52137b302eeddda428d894c3b3c5a79cfc23e45a5a23630af5d805dabb4b808c152d713239c63e1e1068933847b1b264e68f4e715e51ddbe4dff93c0daedc6a1e44483f63f9801db1c8ceeebe8e1edd2b39c6e50a6c6dff3493ecfce444070f74287e934865cdcf47fa7cb5e4eaf66447483de84c5ea6eb9f5cf4fd7067ae139829ed763f4064f90bb55833466c3fe442627a73c682ef386a2f51f515cf62db3477b93a31f5652cb6f2801f94e37dd5bbabc0637eeffb935fe7b6e5a64146b140b4bcb9f32d61f5a140a970b8d0a3f1928874e3be46df33ea20e8dc4eca3b4a72f5ddd46b8323c2a1d6cc6a35b79f53424df67fa4a1368144e01b1d002a2ddc637c71887784f0a0c000ea7b80adb91c4b0fbfb9f9dbccb9ad520b095ac80f4554b41d19bf8dbf89cea006db43685b786c1e3eb43310b1ecab8542b585ced3a49e6e59dde1b1c250cc0a0dd3abdc5e0385a9197a6a5e2539e664ee834e0f380df0d1a02a33209b9d2f8de436feb5ae531eeb772d6d323f74f9a0d48aa061a8a6f02ab1f430b8e45046c162db5102faf60dfa308527d82b5e73fb03d1e58f7335aa9deb55cef3eb1ebfec28621b575d24890a9ccdbc757f3e4583f4ddebf889976ce74398f5387a701ae88b2bccdb61ae9452f51cf8d709dbdceb80dd3c1c465823aeab8de482099cae665fd9126575e5f3f6d31954361ae347b2b7f7a5171d5518fd45988d3cbf683b2c8ccf00faf7dd1aac619fa5281f313afa2c17b27165ce15698b33c24149824997e04c64d6662e156f9a3b4693ad333cf318a8525e089c6a783a5f0d82637403ea2a6c2954bd6ec5cf96ea004bafcfadea5cfdce46e2dbc612da1b9da243aa4e4b3f3b265014f8982ac248464d141902009fd6a002c06233b3be3b2dc725dc3b5e7600345eba8c5b7d8163344e7ab241b68dd99b1af2ff9892df7a6712731fe464d4a102c180b163645029c19499a3dbd969b92b1082eb5f90f66d9ed5fa0398f69f24e7eeed07d42c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
