<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3633f29ff4ab873df87a8df5385dab940605cb1aa8536b46eebe3be7241dd2d38aabfa9d497a5adf7a0e288499df63eef4ef2632e70565098922a7a9b9b2621d6128097139fb9297a2eb7aa9ca38c069fc2513a61980dd7c2c0c39528f3add1ab7afe89edda23484d7e30be356a204010a35fdaa1b8ccebc9386bf4805709609205eccf92d28bd7d4b5ddc9b6917f3e55c9edcb707394510e70c0cdb1062a31446485169063e08de87d65dc6019aa07cf1bed9f26022c108434584a1abf31f5b2357f64e1c2467159ad9a94890da6d4f2e7e4798e3473789d1013d4bf3189773034d0e927aae6e2e8e85cd671bba50a6c342d23ac240939d9fdef5f40169005b66e208d44a2d6927450906f2029ab3780c48c0de0eb75fdb232588e53c49696863a897281fc84c935ca91cffc256de533d8c4eb3ecaecbd35b43f38b21945933ad3d627cdd42709817329d4af5a578897be9ff236594e1edf6db849f5c123d6c41102685094d9b5a3cbe4a4fed044e68bb990ee53a90b154b6f4162434abc7411679d324f60a8ecebca232d84ee6f619eed2c745f03f571b28f0ae3980df3c558e42a3036340090089b7b008fda3dde8cbbfdd0391331adf731f329f02d69dff66b5009df05635a83c8990eaa77a2d2bcc25adee2e7b10150bab54e5e911abd9ebd6a54492eeedf5e84bdbc928af4e08e5ddc41577fe0cae8a1eb4c081c4b9e20d3af51711d87a87aed41d22cc2d4c4bcf4ff9e8da7673ee534b126a85493f7c22a730f38aee46dcb408b154db96abc0f1d6e2a062062fa079544e617d39da2205a10a742c78caa7a50a42e4611462b60292c9db9c27b91134d2d204c5652bc2d7405d19486da7824d5406a8ad848c1ddaeab11efbfd369f63f323e352ec79773db890f951fd4d73e9ab9e1d85beca085519c65850dec0c1ef6374abd5863d565a049ee10a1399c0d58aa585245f0a36f75c2089a24ba14860e776f8958792070c9aa9dbee0fad296b34f013fbc282b43766650ff771fe6729f0689e5fb5fbc02cb0a03a8ae0d4963447be576ed12af5c16d343220f011976f2ec4261eab0b24a9fd99327fb913ec07d37626248c673f03fdff791ab8bba8bbc4b9217554c786d872178a3229af32d0fd27e20631792830ebcc3674d1fafca3a3d2cd38b10cf266cd4d77d34db2aeb1ddeb5d3851492cd8b7d514af18feaf7f0619ce815941ecff399e4bf4ff90239405110244a79f1c28a13e8d4a8bbb22efcf037f53d21af1d0142ae31d32ed3147aa86971aad3db07ad7fbaf8ac17d5e0eb996db53280e00d84d53711863eda028b8dfe2b7882b2c182fcc81fdbf7889ba2e785ae0e215b221181519822a983e16552f02362bbf4300320872104b288dce8976c7c86969e3b8a74f5d5864425b4c101ecf7cb6d4f281089b17438f4eb731198a75e238028c551d52651aeec65ae7964d8f9eb0c1877d82e97400cb87b4cdc157b29033bfc0e7954a537b9fbac7aa4e6f1457f06ef181a209bdb6ac45103a4ad1ed639d2b7c40614b3856362820729a370aafe5c99afdea8b36754831e494f9998686525d5e31f33a123f32c9c3093438207751db6269f698e4b5f20eb711d9e13a989df8bc85bf02952239b6552f7acf0a0ab6969de62350a970ced79058587e37e68daf9f064ce397ca7282b49f9e36c4de115cb662ec3698978604cb1100c96b875427640917d12accf572f873b3a89d42ebd9583c5c1075e3e653fad6d532f8023a63720b47888fc6d38e6b7d94650e6c473d824216a05f9cfd02e1c826fc6de38e9f524164cb489777dc7916d423e53499bb7f713b9c7df03f121a27c8de7c91b35c51c74324f6d229bca8c2870a9f65b9cd56275608a754f556d1c9432cbfe8568eefca3902ac4c1872b26bfe31f074b17dd80a49ae4ed044ebb061c03863aac3260d8674eb11e1299ef2bd224dec85dd2565c012c6aa1677d11e1dee521cd3d6c91e090503e543a6ab7ea0c279b9713a2ed4a779ea89fa5655518fc64fbf36971b1e64fe6b83a34a7d7bf31cc1c0e5f82cfd1bfa568ce54efb4f622bc4376dc64d52605c1fee8b157f1950da737a55b9a077c0986941f94f49885d736b34d43854c512f701928eaeecdfd5790d47ca46fff2b8161fd324ba239945ca1cba16e8a8d2507fbd3718dbfdfe941ea5cbb9384978a90b4956c2a208b94f5c277894da8594444a08dec94d99adba4d08f78892f0766feb146188c4b43753382b6bc3440746f9d6b57adf107de8eae3a5c62a57d22d50ab71ea7ed251b960f5754925a7d9c0fc333030e88e3336b24f20750597d0a581cff90171698d8748f8344053794f63baeffe6c03617357979adfd3e0e57793f31d1e8a528bdb9ab366cd632212ab86fac9bd805fc1a6ec2789b4f04f403c32e53a9c196731309d8af4577d51524b090b25019522a611c8ecc653c7adfef016510f7f10d849644528234546edf5a95ae1855a7aa5098184a20bcb1bd7e7fae65d976991fe75b92a37a5a90a983ee1a93126af4279119b871dbcfeee52f986b0c05dc31bc9de4f9fe45872c6e0504a0d1cf0b467eb98d7a830504836cee2fba242a4268de66e4920d66c16b9a854bbf06cf1c388bbeb4b572286087380ba9dc905245eb5aeab8c815b75244b0e31a26b674d27813ad4193673eb7e172d8ff560a7f57844f8aaf5375a916a82905233437dc3f93033881b8532abb31d814d7feb4760da65bcec662b92e6b8715eba70813925a62653109c7a32c6e1a876827b9ea1fec0b4d329e165da7d3f453d62753b8dbbf4843c83ad859c3f155b14bca74799daaa0b764268ec15ffa253fade2c6692a1fee804cb99f67929be7e8944f693f7202f9b3aad9ba5f462c2a0cf709374b54dd9f9e22d32e847cec868070fc06c9809cb7e7fabbe5cdea2a7d78718b96fc1e6ee0c5e28a8c4fb846036eb84c4b17dca7f854df65824607ee3513810f978784f86865822e09595bb89fefd5b2db80b2800679a86452c9c67880c233492a3f40c98c3c64b7370fb633b97d1e3c72ea502452f8a733d48f11b7f5266a70d6100548067e18cb9fefaffa00715784ab5105cc0dece83096e4d06fe64b975c2bdd83cfb0c49b380be035e7ccdba689b5b54316ccb589a70655b81bd5ccd79a4a8f99d05516821c8578975d120bdcfda30093f82734deaa8f8c84f9faf04123dfdf2bbd30b9b48a136f3b9d420ceeed46cafa00835cec17711f15bc93d2dfd7fa98206a52bb71ccbec4aaecb64f4e7b93caa8a83e65990f123c07e27ce0a3e90a7aea285bf9bf9627899ad65a12de55c21327c47249efdf10e3945b0856f171582635520432560b2a49c1961d692bc789af487ba1fd2e44cc48d826cefdd82085816fd3484cd3604c901de2993409d225327fe0c707664c359d6731aa2623b9e71184daed7d89ab51baa6a026cfe37283ba388b072e05e44632dfb60379678e01ad95b9bad37f486ece176a6cd9eeee99f25c8913bc6c200d63b1683256a1b85d435c574c39de9513fa1606156e8ac26d8cc82e3fb30f7d140d614f41f8f4ba8a80419a7e6b192f89921b3a6ec4dacb19057081a1761f924810d40762723e7cb73368e5831d29c074b8056106cf9cffb2b8941159cee0c80912fcd1c35bcb56fe5b726e2872466eec5385947c44c9b4f16bd2a1beb0751fded4231b0f479a538c27e3dcda72285a8d5f6730e01139dbb4953adcfe4f5cf1323c9495708c03cd2b0acff3085c275f610b8323cb33b62ed4f241f429196aced01bf42c7baf332a4300a0614f8986f3d6b308fac9d719d6c8fb8ee6728aa1fe027346f278497b9ef9929328263d4216be53e83d81118d30bd7404b4fa117c0ecf308f14c5ab50921f414db27f5eb3b4a28670ae6b54e65d13526f3629c19d0d40fe02723ed22c8721b04baaf8225064c9e8ccaff59f18b73473acc17da792e82174bfeac770e65b315faef6e4b2d13ebf2bf99a67ed5b0770454ef16d1f748128e9fc7e3b0cd24d54a5bc7e1f0af53e258ce162e70fae28579b9e05c25fabd97be30674eebf1e3a757fbeee7fb228f5ec3f04df259176bf7e7b385fc5be29b387520a30ec8d9e3229ef343627d107e903a6b41447000f2d32c41d89289b8b2308ee021744c3fb0ef58ad9f59ce8ea7bd4f4e6e0c00a92129efafe138d5de794595bc56cbce4c1a85a457a937757102e4a65a243007e1bd62795527846e33f0d416d5828a438476dddd06aa007e1ad3a3054efa880c382a043457e07b529dd5966225ebd50934d30eb18cbee8432731f73b99ca9350f6d0fe5edf3b564c3f85b9ab710f768413da1b28ce888227adbc5f59f8c58f84021c175c311b4b13d2bb0ad908ab64ec9b1f8b5edc82e799d5e03098ba442128cd9c9c613ce4eaa903b0a77f58736406a398986555dedbe905fdae426ddd585764fe970434ea447ed2dc4014ec0bb56802326daaf996de2546fd2fb9ac1a68730b2c7cc6928429776d69acb6e98c0716b9bb254b33420ef4a3a2ac5d2f62167084e85d06c292417f099a46d1c5d4f9e60d9becba8171b140bc71cd9c1c71944868f0b68c33e96a08029f5a5f2f937161c0519616856368a892c9b7423ac28cf8e9d6fb36709c99ee71e2e83d01eace933a00555a4f77aaf0266996e74a61ba0a11a55d14467d60cba2c21b641424377a7959d10c92e451b3b02586fae7a1fc234cdb3a2c6212a8c02828a29f95d32860209a1566aad650a9c3cc5e18a6387951765ccbf32ce2c85a90293ac879804ef5c1bb65cd6e52bc823cfbebaedebd02aa52e330cd3d1b93139227a823dfb60726d743b9c8561fbe297cfbe1410ed01096f64f4c35b40f04ce4c0331c7581f66cf55fa902d0c17b62e05b8d300973f5d58ad8cf9462515e2329a71938c000725615cd640cf66e065d7a17d1de68fa4221b0825f7134e50a7dde2d28f6f2a52b4e8ff086e473f2376e225e440b89409f174d0cc4b5f3c8de7464de85a502c88a9345e8cbd4570ddc623e0035777022388774e21fc9718f876801395f9ff5d12bc2f2981a842b06504bb47a24b0411471a33d7bde3a1797ab1a83feba9e70a09595a48cbfc27e633b8d475ecc5cb767364432505c8a1785d98f956621fd8a2724fff303ea75cd73435ea393b7150d09f6639519f0f69251e8fec017689d6bc49c615b24e3836fc313ee24db8b5b8eb99c011a7f38e3f6ba7a07aa3b2623d5c82471e76135a933936542a80bb1921f12e838a660f061511028ef389e55c69cedc729ef0e244a8179680b1cd3252462745caca4148301bb7a39099803fbcda1e863de26d875344d54337bfd2c21083dc641cdcc200f8f3443157063cc77e45d33539fc0f1d50e1e66d5c40866f67eb4b4d420d02892555b850c70f222f9ef566d5ea7ef8338ed41d8065447e6fcd89bc985442c734d6943d6245bbdf6e033f6e6f8c8bf3779628b577f725e845f7d79abac122f826fbdb1548091a4ea42e9226dfae2f789165b902374c8a80fc3a7ba1c6e02dd4e2c70f34fdfde1eb1abd2de812e2645864b35274af2c360abf94c141643985e021a7035c1a7e3e9d887cacff94419174e45f2737f8306520a65f8f64cc12c32a7e666c82bc786f1cdfe002f99cec22448e0c2db65769f92fcd28dbda576f1b29ba61d80eebedd8701ef11d1bf9d3786f487594d17f3484d4fa3bd76d8b6d686c6c5f74979c259c9157172b12e9fa1d81e9ea97fd6d2c766cbb82cf2985506b7d74929816a5d2e48780bfd8f01981e8d56674d4fdb8d5f5cb43d43f6337b7c47ae8383339b54624ac9af24e16c006d72032c552be6317e2c79663a16b75a63f1ea59b865e4803af2e595b3c8375de98ca1f2c49f1e98990adab57d975d3a3f9df6d9322a96370b270baae775477f86428002b5cacf95f6823a2db018fb8253aa0244fe5d121c4120b51aa33c43777096263d1d3b25a0627933b1cd4a6315d3ee1ca4ebec2a56dcd85945c6801f9d947d829ac0cf738a26bfd3c9730bb40cdddd5e59100c4dc69f9843f712bbd0ea0ce8286c07226b2ab4cf2f68d006f643f31db90a84ef8d82e218c9c0b4e962aa9f02a214ed043a9ea449b48392a692890de1658424b39f864a1a0588accc18ac9b3cf998a1b4612ff0f858801329c5f7b809db3726792e5f3f08b4852db2b5800118a05becc8b13004e77fe47fbd4cd7c7e51f9412abe20347c157c1a14170da9fec4d4236a87644f422acb75d3cd10a6dc15a5c19003ed59a5c47637fbe0ca8577662690df8cfc3af70eb1583929429625409db2f3531b3f601d2d5fe1a2890083b65788efff09a2a7329ecdaa4f091758095fe9660e1ee72e6f4b7c316688e5b45c11e4003c6371fef053d08413c7c7d7a7d054fa034a518f6695fb21423cb0f3b8733f0486aac7276de3d0922949ae528aab4073d8a1324a103e1d63e47e843d026faeedfadf981dbe4b3641964041b65382db6a1af1ec06b8da034c820942ee931db7223d040e576a117efc24f0b53edb8d246a3d2c147e3c3ec0ecaec67f155c271f1777a52bd399c98a3cdb395568ad188fbe84c1af295dfcd435902c93c27f66b755befb5305fcaac3e90bda9e6f8882373c52ebc64dd4a7f2017043eb9c391b758d6f40189ed5dde20dec9e938a9b536c079e3ad2bd34ce6395f90d417811256291a6c044c2b878827d9b262605f00581ed57b40b11ec235e898b5f34bff8a4a814cb071865a0bf469c79cd3868873635449e2707ee1cdc28ff7124a0fff2a6fe4584a377e29d22604d32884063229be7ae76ee2c74e544da9c50d97c870c0d331764feb362be16ca94ab3865d61e84e30a580e20c3d473d0910633a3841700401fc12fcb06807137a9d83c75880f3d22dd66eb58ec7695196d2652e11bf2bedbcfa6f8e8373fd7d4d2da1331ee6c7db42c8698869c7cf197a835ff3da8d19c29d34dedc2d572c7406575f636fa1b40c39e07d85b92161560c6b8e4d5f82a6b4f37f7b7f757b790398cb38b392f14808bbfb576c01ed65bff8c92b2cdf54ce0e4ff01291adf7e2c89f484792ed7ed61687d573f9460c96f78b268e07623f7a9358cbe5626c5f702f4da5ec332b713c74ccef1089f98dfb3667b2282186158cbde22fd29ed5a479c3e64befa8843abd5d2e6da50317390fc795064b6d3bf91c3ed3b3b84d65ee18e5a30490484ae279eaf4911c91569700c633aaf8efdcfd0e6bc671fd9593d9f2c20b516a68322953d85f3e3be557ce6e1acdd6ddeacfd5562201e81968080ea6b348fa50333624b6207030cfabb37f05e7de1fc70c74c08dd323ea7dee19c4c7715cf51c356ca56bda5f41991e14aabe69368cb8a6d11340f398ae9de628a0e0bfd708f2aaed81590debd517f815e43bd257e430684d10916255cbbd53174c91e9b061e909bd69022db958d4b58d6080f8adc9851da3ebc54fc0e9b477877e75dedbc26fe57cfc866b8c3b95e2e818dbd46d186e53802628145506fcfca252bf1aa20aa54b84ce76ec4bbdcabc6ef6173d01d05724a10426d96a588caf0fb4ac3cef01a96d2eb237f020388722a9a284313b4ee9cd4d68d2eb2d3b5f1fb3dbc678e56b22a21a34dfea9ee28a17bf8500b3b45fdcbb4809b0ecc4ed6b578b4e3ac0b75350891c76ac9c988fb5236a5b1c4b599adc9752ef2fc89ecd2276d587fbb11f561a58b0e0e081a5914808a287e3bf5e23e0841761bd4c393b9b746fbc4fb683ac3cf0689f8059a2ea18c4e63252736a24fdab54429e78858b6f171ba8e60192e99728615e11c1474c796db856b58f6a93a82af61547131fac5d84fada0e03839359fa35d767d069aa39b9523454bfc63ff59c318806702b7a38221acad2fe13c87a046ad7adbc3e73f852796752236af71bd4f38df6a0bb8be4b7f17568a2712effd433abbae47c0735d93fff09384725784b2e852c17496d07e9862bb5a7c2f662f388993b4fbd5d7414958ecfe84f7b9394338a8ce79673c2877663742b60e9042d9f30ecfc6523d42c87cc7d29e0f128b5b1ba889e66ffd2adcdce06131eaefc1b64e16fae2b7810d39e46984d837df7e87bca5e30ab59452763cdabe8e0b882902c6fa8e90d1f07a38a0ef1b10471b83bbe036a38803c3bde4934cf09068d7040aea511c34bf7026d3e232b5e42136b66e4661b9dc77c2abb8013c4f1aab8b40ec738f773e89c5c8d139f7fb81d2f2311d97a442488d4babdb0634ee878d569fd13f493a599307ed8c67275e697d80b5468aac9f73b73e2670b3a3d7aa8e142f84c9f8842a3bbeda68a13a3467711f8a39a0de1348592a9affd4588fe6b866a01278f4de70e9c2d0d32c27781ca4153245a963188d3564da92802e488066b415b3152df61ddd3ac97737db985f9c0f3efd9dc83bd6a50dda5aba1cdafb1d9831e9dea5712b445abc0a50cd5cd002533a8894d757983d3cd42e1ef02cda9d922e6483c693e6441d802eaf74aa643e08d5e78ac824b8754fcbdf6e7f1fd60531ea33d277087730d4c2aaa687123c75a9e08e56ebcab26993aeea2d65b85589b5b92c9f1617d2ab8cac10e487fd97a85966e0046ce68c8c568730edf62602ccfb4933b78495866b33aa6e01c7959c6b26a6776b3a952587a21260f060aa2584b8fff2250167fb7441f81ca7acee416cfcb43c3be2f9890af9224d5b15a80c39ede960b17375511c2201a6285cc792b71a0553170ee0ffef9dce41a5e1afb8bdf135f7b24a0cda69f6ecf7e2e636a2e2f67be29cf0c8d651bafcf77f7ecaadcf48ea8e3cb1be9a23b5f3e9b575ef774cb807783d21bc285b6ae97d16f7c7e374a9d8e9f1bc547a877985fb7bea8091ae4a889c71194c2a963b6baa8285aeca33da2bcfd5e4acbd6a9214533da8b4a99666c69c9b41fbc1a59aa9b2bdc8c5fb260ecd1daea781ca488cd98ce1c2e9e5975eb4cdc2463e19d41514a63bcaa68e3e86be3afbdc3ac9699a54f1b9c068db4783f6a872b29b4ea3108b7c3edf3324206d338c846efd914723f4f593cf7e81748a6dcf004cd7abf60eb9ef7e288c59a0f745c416a4c9744650328032448db7b4bbedc8f8cf35ac43edca34767436f683942c8faa7f01892630589d5a64729c3f29fc5a30a147e6691e0984840779de5204ce056e9c034742830bcc1afb04abf2fda22a6b295b6936253251f3a47b2297584b3cbe86158aa6965a0c894c22cc608c394c6373e71769120d7bc8017a05b6a4868c447cfb3940b8d37a35b1b9c497a348171cd9b8c84488960456ec3b380712c6be86c705daefbf563d081cd1e613f2f250703c0477e39f079a437c3df6fb2a3a0d750cf3e84287e62d4588691d715b659c79c876f7ab7d78c7b5da3abbcdfbbbcfbcd68d7072c515fdd7ad16a075b0496213b55f06ed47b690b41ec56f6a398722202ccd5236e6c4fdc7e31a0d1a6a9c38b05b42233d2483bfb92d7aedb0e0a30ca32889877fe64f3c8c120ee949ce778b51c7eda68942328bd3c98a3cd5cf9475bafe1575eb6b5bc55ab743e36ccd1f43da6b81fd4e133425a58d2c887fead674a07fe0844a6f767caa23d85863605ea077d89735788cbd6a7ab6cf25ba9092d34b917e67fb876b0b3a129b502397dfb5f5b9999904c940244c21561d39f51f1dda71fa9bfb6011d2296eb6f097e6c65ec1162384a90a33d2b2ed3c462ab0776333b31efc3fd6e38ff9fe50839ad046b3946a39bcbbc93bb61e6a77bf35ff1d04d5c26e2b45597d60887ee7468a2ed0042443a6f741e68ea505aed2d07e5ae78c13464b12364f08a8940eaf4a75eb8642e2da5737b45233546a9361c1f33f8415102ce036a9fba03ec399958fce7074dca314504a609b35d9cf916c7c603cc890c53e20ac5c9323c4bc134388eb5aac3b56ab6808f58b72cf4024b724541ea398b5e2ceb2b5c6b4cf4d61b2c647c5da34c037239e648d810aa49d045bbf0f7b57d5399b95cd8620ec4a4cb6f17a456947b3e1bf146faf3573468dd2f3bc89d3cd4c5f8eddbe97d39a70f3390065a589564b63caea8ef6374d0d8514aaa6be0296107eca196e306c4709d13a7f7565ec0150bcb9f734cc75d9bbf9fd16a96bbef00fa764721992d354439117ae3f3a39291685b37ec37be32d6fb4f1bbe5dfef0a6c7b8bc18614be8f4d6a4b0373f055794bd9e6f3a294e708a7ab49b31671a50ae871b6e17a527ea7360ca8e4d6a4b51beea0c01d6bedeede35a529308730da925c5057b303d4386802624ee71d66c0f5e0dc030f857c86a10321f7ff3504427c090a96dfc63ba326b9f7f51a316944f63ce1ee2d813656ff72bb8c86e022b03e4b6f66a0815d329bdcf9ddbbad682da788f636d1cb0d65d6ef1677d47fe2159815249e3aadce31513279736cac36f58b5983c34b75a5a35164e2a86eaf73236d2ea09d60d0608d384e448362a1cb44ba631f6870144fa65c4b63ac6c426b0b7234f0f65a164263e0c81c95792c9fb9d62058f15d898767e55bbd47fd0892515ff71b8479f8c2ef572914560d8d9ea5e7957ad24336b3bc417658a8dd99426be5968f003a92dd3bd0f7df47034bba7ae25a4900e4a60df2c443744acf77954b7eb5d62fede4334a1cfdba336c5c85d417c5b62cc975c5dc34707be83badb588ac19761365a9e30740bac9383c0a7a0d713bd4815cc609792bea3961510c54ecbc3848b751668f4d171b424d26f56c04d144303de5ea9f4a055239ad52d0733564745f25211baa81f1cea3820101a59f1784223c211e238978ba03a69b7b48d3b2108ea621f95edba5458bbabd0f4445ad34ed1e06786b6fc34f30d69115c08af6da7a783dccbe46dabd26ff2771e7b35bf333883b326e3dc8632e517c08b56526e6c8d58b5f853aa8a58940d253e21a7034cdb37243e7525ea1b326b705522ad109ece05586ad337f60c767d1509c588d83d07a3de944d9010c2978e626837dfcfe0312a4339e9d64837bb302679f81c96103454f9ee249b41df127604ca360b71efca859366ccf0d037f216876db7353cba989a98252ec861b202b4cd5a8d3824113e03155e0fc3a0cb570fd8bb6dc2828a3548db10de36b7886246bd3f02aa97c85983f4bfad7b4f5bcfb960afd1001d677a3a467d8e076b01446c9de0204eee7e935de5448bb3f6898eeab546c13dfc86db88263640d3b10f0f46d243ab599470fef0813deb44c9b05436d1b88ecb5810a0cc6574ba59893e46074dc915df8b64914fadadcaa2450fa74bfc91a28d87b863d6118e43ecacb673548060b7a9da44443b6867ee1264b191bc87200622dda318b9c0e6093cbb37e7dbf49bf119f25d6970d177d26bf24012bf09098b4f5a1552af9d7a08fa6edf2efa683d988ba3a0f83f159172fa31c8596b6ca2bc0d2a1bdcc1a8d0209f6055711b51e98a6aef6cd7960093981e587423096f64de263b3ed5e94a92ff24c5297c71e4b6210295fd688af6402fd98f4507b0e11d4d2adef03aa4d09c2bb7e941e3af550a3bee0dae8b0534d43355b45020da7f7b048f24c42653487c720d38150087acc819b061e6016fc7edf025c2d4632a5d2cebb78e3e4876c3c58d4941145e035e3d4e0fcb03781167866b96a2a4e9351c9f77a0852d57830986ff4d96c398b662c29c0122356550cf7214d3bdb2a3919b2aee3a9ecb2e64bee976a04548d3aff6a53d49f1e4663adb09c755c98c95f8615913b466434bd39e928ad396f1f2085923ef705d8300c6d7e829690144f9d55166529575db8260d4c117df3e3aca82e65b8eab89c22505a91d6862f3629bae6d13740c7e1bdbba1243397eeff51de58dc906dd2cc4d04e384d3208113eab4edaf3fdba2386dc606e7f85c96eeebb925b97675e9ec55c0bf3c48dcf9672d2a5bc2e0d7df2a19522495411225aeae269f75ac022164f1491d8c413c3d15a49cf3a82ccd5a92a213e602b8894f44136659e6358531de98b414e5215a6c26628de028b486b233edc7dce61f0ec7d1ad92d697ff555a5b3b4d844930eb8abb31bc77abe1e00a5a57a79f143e4c9e655c0ac24b37bc7ef80216bd64ee3ef24b16920cff0af1a4b24842f7cc70fc934f0747a0973a4fa06962d5de50bb06a4b419eca00862da17e1dd351769957c9d197853be1482f3a1ca4705de2c7ab1a36116db6eeb2108ace595e0b9e68db75f7bd459ee7c172343654e4b0b206b5a56ba8427030265583afacfe58474a12590fa7667350fb50c92a6a45ce1a01c6a6c387d4411b8b28a10222cbbf604a02e9ac18edc4fbf881a2c9325b640f6894f487dc591663ce6bcd4e406205399e96ed5076a1abf3b4922c5e50c6761012be7d9cdbbf1177ce32c725b83009adbd8d535e5a478f6da6427259ec68f9e887c1157ef408f28c9827ab2b40d3fcf7e4903bea436885d5aa200f5ca64b428a90d04e6e29dc9273958b64f5888e92dda1b854ee9be67790de838b97e4ff59ead77db139583dbf1384ff4756ae777f5fcfae0c384b805e74ed8c6d8f122371a485b37ec64c344d99eed2ce8782d921113641c020b22541f16d8af3d85a6936cc7476529333944512c26086a9e9f926030f7bd999f6d258e4a7ec54df34fb0ff11634dd56af404d02936bbd0299209e18a2998a4ee899039dcb13b6f845a341ef4cb080c940c7f4ee5e001cccfd9082a89341318eff9855a349999fea3a2289c7fcee3d6d0eb02f7d57497ec1d0a9268e7ea5c271545e9758666cbace5a85a811b1f11e809e17a5aa6799d7d54c273e0f114b2c9a264c0123be88548aefa8cc0743fac39e2e36cc0e12bb1da33869713b5d72a36b66f2fd3df4b002cb1efe230dc7698fefaa0445f8ba7439d4b73a57ba4b24ffbf5faf63aca4fa020da17615805258299bcaad550feb330fc0fec1ae54ed15dec3810239dfda20fd367265a4fcfb04655aa6053dcb3221101e758608d8f216a99ef116259577a26fc66eb7fb658a1c5111c526e2e265d6b9932a271edeaac888ac474e8b3941ffe8c438f7b172c0121c1e39cb94614aa38b5fb417d8c43271acc51168740c14dd9e811db856282e7e2c9fcdd35d39589a4a0a83277b609723bcd7ae65fc9fe65fac26d31ef2fbf13635ecb85e45a3c2c74c63e047d4a1d2d22a05a227ca2768c8e90cf5f279e9f8098f637fcb23569933f434f1de9844143043c39979408b2e9c922e7a51b70088d3f109141527c7d8ede65f0c35db11fe992cf5cb96f3303a2ec3e70adeba3f3eaa6ed78c28aa68727c6e4e42ffb22c4d8efa98acd210f0f5913e2e973434b546997a6969455d48bcd4007ab63ab96c0e212e5569893cee5452d5e4106a374aa1afb9786a0cfcaa895ce52b066961e00bd3f533c03097bdc7ec2c497aeaad6043e01dad2b97e3b2ddf0b5b77767a37b9032f69ce5da2322682a5d7c9d284d47984b96427c710d62676c91c9cac8adc429bb9c5aee1164d889847d597747f1ba07e3b2f94cf8b0210cdd4ef6e4074cba051e340de4f82807ec89c14cfe0de5e3d2004c884f706248b5280d0bbfae940e56a06433eca878130d0dd50e62c5302932b009466fe347da85e4a139581d7b71a6cf9c36c4ad5435df767d4317449c77f2235a17ddd2dd18ae71604a4af26c467ac9ddc0f8caba4c0d63ba41bb34cf25ff846ee33758500bf8d11071fe27b2d7501112e79ec23c63c302a1ae7a11075d24fca9b326b97dbabffb0bfa062790afdcd83ce46d768201d2dc2d382c70ebb2db41c1e3dd617b2c925f76ab333f3b9a30e67acf9be099557a9e9e89f664e33b75262bcf5904dfd603f6751f37459a50886312b5a8c361bea7035c0b625dc6c0c4059257ca69f2860fbc5c5c6e855a2a7226237ae655fbc3dea55a8ff294c8a564a741c43e1124abc46d890d7821ade0a3b6433e349bcee469842f8dda887a6847b613fcdcad20c6a0e212423700d7d023e1d95ca7fcefe730893285a4501a43d6ea7cf7b497f912021681b8d3ed43770c27b99b1f8301b4300773e313d5c3d38f8a207e18e03774a35a7d602206e39a2e873f31476d05773b299c77e617d2a598f840b29d2bb0c3dc41e7c31b12f447ae59f1836868673f677df1f502b5883b11d4c62f8d284f9874fc68a3895058f75aee08e2800dc21afdaa867d40e4516d28321dae9bf6acbaf1bd808f79975a741cb1de480c2c802ef666b784f3522ae233f33d308497f82e178752ca5c9dfb161f8b97c05d39841d481ee7da750dbdafbf2bebc5edafb263097ecdcaad36f2eed188cf0455d90410bdc83254ef5770e2d77546cd7b9390b2faf8ea22d329bd198f4833c06ac8d1736ca15dd742b155c71cd53b36a49f7299f70c48c988d5dfdd17ad65a650f5e5cd0d2dc71a96fbc7add2f3c4a8a08cbe81b9c1a02c27dfbc23153da2ae69d22290c57f4f835c0e30b89799c6ab4e97a55fb4c7468eef21ec5f2864d505e30a2089bf5ab88351086f76c2d3184921af25ec3ccdb94b3e76fafab47f4ba51c783beeac97852813743d134a814da57a8c55150145f298ac4f1f3eab6c152f9774065fbd5ba3626cf09392f11c3bb6ce16ea28eab961ec8896cae81593ff93ed2e8938dde1741e9e31bdb08ce0e9116abae2541de8834fffb78b423c9bc2324df16c77eddedbd3c66565f13b912aedf633e4513de390fca8764fa5f296a8a1d284a9937d22ea202cd80f477568bb6f1555de715389c0a89bdc8b7d38fe76c9af5e045ea13ca65a43f5445226285912ae3156aa86d28da4f16d91c38cac46fa8cdc8fb79087cdf4a9369cbe075ecb119bbb053bb9149827364835d808994909097e43c21f7e297c4e22726e38cc4f82c965d016c00457601bbc59c64ee7066e388818e0f896128a111dfb89bef7a0ed3157467cf5b6a3a49fabb5ea86b432385bd7e811ab005d3df4525b93770c6372c44647fae2ee7cb82ec2fd894e0210b6ebeb44cc6f74f3520594c1925ec6db40557808f446097167ca126c8bf36324f921403c5d1d76328caeb8763241fd04b7277ccc38034d0b66320a52b6b750865b50d07dfe0f0c0c94f2dfd34812fecb65cd50a793f73437d31f3062c938bb994e3bb3dec4b007784618670a7ab3a9d564b75275c6afa1ce2aab62fcf23e95f8784aa540f93b9de7692e182d89097530203f454ed7e7e2c82f08d7fb8c0d3962432266a024fd31e2d6ba892293282cccce8777447c2d062cbea3ea641da931a461ab2e7f63c4f1aba7bacbfd9599dd406ac4588d1c9d7c3b62826eae69cadef1e27d29a4344f51ab16dd32e797815080cffed5784496cb4b6825aa44ba161829e55e145153183c4495f61680dddd70ed8020bb0f2ccf8f0568926f27eaf7d5c3f68393f88e2d7a9184e69892ed3bbc2cd5e054869a9a7024b0dc12499fa80aac7e575b291459c2c7d77ac55e0441d913476452c462b77dc707350be1aabb0187739c54d33586a15d8652f57bc3909fd87acba21e8477a7bd7489e92812803e6c57b52e83eeec7340dba1b0530a8859db71307a76c098fbe15323074750d2c5f397e70e69bb866358a71d8fa4959acd26774818ff7feb6b5970e6b7fad16d8c21b4894c92a4e68928591619a715046dd85f597eaf6cbc7ff9c31f6ffb75496a3ea738d88894c3ce7b6dbf120f16e21a654dd06d9847358f77ba4558c34a00a4842281c63dcfdd2c967ef187c26ff638367692b9884d314373cb56aed0ef56ab68d568e5c5af5b678decfdd45c517da104f1e172d335b598594bf6b6c7aa58780f3d0015b8325f10f5534f4b691b39845250486c0dcabcfb816da52514d2427d04851a5ec9259a62aa3d03cae9b5662255361b386424fc77bf8eb9a8f3a14dc518f8b0c4917bff32d01765e9c872730eba356171af302136bf9226c96949a362a55c4858b51ecf472de1da241e5cd8c642250c50633048fd0b72160e53c4bec10801c9fd54e1e85c70e77ac40cd391e8995f6dddd483064ef55874f1cffb0597893da6ca9bf600cd028f768ebab893b0aca37c414e24830476ea2942ba9f957a207c6ebeabde95b55c99658fdc90bf8943a82b0b97462a3c437e41959cdbd0f949b300ea7349623aab75a8786c9a8a1003c5e97b5f635b9d08b7a627ef04d7895d37a738f98e9b09fd319e22aad0127b825fd73d69c9e6fab9fed66043e76a769b06eb9f05fe84bffa365a400a98deb50473792d364ec2f0403df8890e176efed066b61c1b5b674e457790cb7aea139df0e44c21d2f90d6489bda94172a46d51901c14dd52935214f8ba74bfc58a55ecfffe4ada55ed38c10487fb77c7b37a6ff8e5f2b26be560a41cab77cf928806c50b27fd70b11fe4153e0eab86066e9f16d801abff2dc257bf5765b53b5d06b829ea5bd7042d1ca6984d23ff569bff0ef1933de4e2ffcbf88dbf99707d2bd464b2ef5ef69649af9729c0ef1518f9bf5164f067c4c4eb3d9a310733a30a9e4d84a04abf906417f032dc29a0525110287891310ac613d990465594ded40ae0b6dceed07e20472ff4ba900363852c6e16404407f2439706f1fd952dae9eefa088d22e67d444f301dd859a7ba3b6424df6d7c32812c307eb70611c374a4633d6f351e6fe35e9d1d718c32435909c010a138c4fc0d368b2b8a838c588769acca12063945093f28825770381ef70b433915b9dec90d4fd75c791003d8744efa2cc25a87565aca6c18c9172dac5f08b2e80c70117bc7d91517e0ba343409a1b6677d5b277c807ca23ef7ac27f36960cdc0421a3cc31312322434d4d2b54570d785fde6c774edd10d8ddf16d196fb412d984623440c3311790ae220116158261712341ec15fbbc3ce1530949add13aeb5556a74f4943b489dcbb271773e9ffd033b1720f07ba548b63f0c1a76b789acaed1deeb304bd185a1ab7246ce3f05da5f1d5328f523a9a1416fb34bc9dcacfd71eb419f94f75529c836f7f4f97a7e3f68293f7f87fe72bec968ea27b895dfeb3ceb765bf272fd311848d382547711691cfb2d01dc01dc22f786286868f93a81d2213042a4a803e99687c1c4cc8fdaccdabdd1dce82fc2bd26ab7ab0cc33df5c71089049c0407531cb3c74b70916d968728284c2e3f1b1dcc223e648a8ded8ebd9c2c0c2a92c0253e3b979abe59fd27899a2a2204845c9110f90c777233227b8e9db248f2308283989c59daf9e836758142b80288521c8ffe211e4804c60e78a50bc46657ff403ceda24118a980da5d3eb9d6d372ecc85d98c5ea5604f6e23065edc87a4e11aeebb2e958cbd3cf8decdf892b562b77821ad6f6064e5a629bb4621be7c91d7b76e4f187b965976dad2c8893b5b85e1f2e8692720ea140c95d79582b4708f59f67f9e0cafd75723e9b90af06d17b11760ab68ab8989b87c8487cb75664d5607486794f380af6f8205c2bcf0e7ea001a7d5dff55704cc441a4a399f2edf11f99159d25d3fbad9d09409454b0d7823ec04292477b11011b23e2212705640bdf46c223247285f7709b834ecc393fcca92cfb10e69c2433750e9789401b81611e9b586c4e0c6d6998ee950f3d75830813d5d86943da59d121ced7675ef9e3a0ba357c157540858725543ac725d2a2b84dfb3e99a27a7ecdfea0df789597fd2c02155d445cb20227f84cad8b6a2710ea384dc8b4490cb2e327e5eaeadfed48d02576a6cf03e0696e2cb41e47348af53104097f9fc8a637d9c69870b18079c4b834d17570198c98cef2437b85d5288bd20e29bb26782c94249ab23f7008d5162967f57cb75da8be4cc0f099d73f707bb675bd39137233318b549dd00955d6dcd2933e5c7ed97ecfe88f5bb68338d1a72a4f370be6ff8ebd43e33cab2a9a5dcd9ec08c18bec88b51baba9f24c383c07654589326f6201d50a7f08bc10a8e34e9bd534562bdc4c512e07c4cd65bbd398b32e33ed695576d0b00c7a48829be4579fa5c4c8257c04093f87efd8699a12c0282d78fc11717b7cd87f1ca568e4b9cc383c514f72228525617f063bf810d927b8c678167c58da8e58d0208ad853f52f91ca7b79ccb79c10217cc1d6456eba08c463be6471eefa28a6f03e20016ba1b48f619d74d4b142924fa93220ff7dc24016c1d7a08f3375f97155937101e22ba90a1065c690cd74696c396714245d8ea2c904ccaf8f205e71d129f042befe210290db88e5576ea44c6e39ef84ad9bc164718624715180f060f84480a0a995540657307c96fb2c064f8a11484aec323cb41805e8b75cbe1479478ce133344fe5235bf21f78a1fb47ebf86df7dd57a2cdafa45dc9d36aa0bf8af4f6d8a4129cd70d9f24fa4ed73061ecec11a1e03bd58330c749fecd185036291dae6804aa4afffe8c87cb53072e031643a08541f84023ccb50e7e1af9ac674f1d7e8488ea8deeb748f81a32aba63944376f5762666f61d324d2dcf216305f81a80e11cb1b9fd88369c1401d5d0ca48295d9a50ab8c0775345f526d0831628c5597deef9949c3e1fa5fd577f71c84261d1b19776f9bcec669cc06ed987029795511f91039428572cd45739355e40ecde5e012842faa19b136bba30bc37737aac66f29616e6310476c1883230f635b42202ebeca55978c389bf9a00b94e152f6a8a766cf522c6c912294f3d6e4ed9d4a3ecd675862025d278e4bfe","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
