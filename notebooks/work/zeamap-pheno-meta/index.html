<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"499244bd33fc2e82fd0c249698cab8da9dfb6365db0269507b4b48a4d4ca11cfaf7f2067e1e5b707073642d23a3ee75cbfae424ac396e4067ba9df470afec2fe212e7011bcd3aa38bc5292a9b599ce68ebf3536a49eee86ff9234a1d9fd85dfd10bc9c5f0bba6565ab5bbe860ca917fe790d7e59c384ddbc60f93e0df4e27a525c987490ea2724cb96026f4525fa49897a0f9f380318442a7f05cdc05058b3d3d76cb11bb054dd7d9374aa31c2bad3c2cd941fb6159607114747a516cef2bad18c70da211fd7fe8195cc1c8448dff1298b288fe926929a9a985e072620419bab491392c25c99db62dd2162e7285693a164b5b577d791c268ec40c725955bd30a25b3b9d592fa4547b09d877f90a0154a23351e55cbf448cd24347f423043070ed9bc2c974217b8719db14694c3114e72d601baddd5cebbc8680a461f9e8e15e003371d3603d8190b0224ce977c64115dccde5f90acc136b497f85dc265c8a5f4f3582391479eec240971b52a5bcbc0acd1639cf5245f17cb7d42176556e34f5cb8a8e5945bc9073b5489291ff73e775d1225e88482e5f7bc3937e2f0c434b4d4c8411797ad163caa86242e3282f7c37b7d26ed8c2d6844a98eff3a4b83eb9e712d3c6dbea6841a38d0fe4ff66184e577a403ddc550a1412c379da166e2b746545633e1093f287c1bcb81bd34cca398896e58a5719146cec6ad8de42a4356b8568c30bf94608f0bed2b89136ff3e0f7fc224296626d00b568d1ae045b9a3707359dcf953cd88e7ed9441575899108229e388e5a4200594ff4925b699656b24483da26ff518d7e383bad1b54efb03e618684c10e480a127135e99e64643c7afa31ff604437ec0d8447059857dadaef99d16a6bfbc52a49a65881756c63979a855edc331c49b6d5620bed1c0060ded22dc79c0d9911fa39246a6a7ce5d214fabcb46f410016a73c3d8734c702afe4b9a74376987772158a49bfca6fb0beee330a6ff68de7353fd996ef67e6f950a2ffab508a0f44020da1cfcb662d052eda648142eda361da137f1758d6479bac1a4adc68e8e9cc2e31fdb3f659c7d6cd88fa1354ae2fb72e7d52015a3b13c276de6b88d5f23076bebc4c89bedb35bc6ae195efc30c344c4970d70f8ddd8622fd010f705b444290d7ce85df9b7c4dd266e5766232283252a06c9ebce836f1fe39aa311319c87c7d0dd36abc5458560601f0fa5dbfd99600c796b04835eb966d28c12c8b4c2032dd6b6729164ac8dfae12428a049727d14d0aa65afe27487db9497ebb4ed77ecb63d45feb0b17dd6f65b6e0756fdcda12acaf61a642e23246b9f712f0ffe18ca542693b595e1a12f765460ad79494ce9bd1c4a6192f26b5b2fdc00509d238ddcdee80ad4b6da00a6596adc74f53325a287e6207199b1a10e02d256454606fcb0e300e7e7085f4c5384cb15326ea7fa10301cf2e237470408182d925cbb21b6e7e01428ae4ad06c1a97065f4149e74c57ca456ea63ba87187b0e98a1db311aa0d387e2b5b5ac45fdf0280119a7d3774d29db29910f7853ca7394f8bec0042fc4f37e17a77a6e5748a4c9dd0bac04d4d838e26dd8f7eb850ea4c4d9c342cc0b9eaf1295e7829e1ea4da6c8ce8d8cbbc723583df0b433ac0a62b9ac3c056b7b7d71a646d01146677c0bffee5137b61dde66a2554094446959a985903a09b3a3e8109a7cf3cb32c07b9c5f126a876601de92fc0272276cc26c29486f3090a893301350683f2f6692ec32c13a6a441f039c32b9148b57ab231ba77c6cc8d88db5d6c01e1c3461dc51523c5d2abf06ac19979cb18544fcf74781939cad4972655c6835eff10a1cc7627c08221c95b663966094a3e62d41ed33e4ecace0078faed167fab868c49d65986ac18524db7d019fa7be0b3d67660895069d746d51098a3a57c6f94728e5d4ca9b14c20a9ef8f026f8ca43b4762ef3802daafdb591aef25f411eb0a789b7c676019b720098d1f9143b6774d81cd1f9cb672dae5ac1878487c4e0085c81cb6242d7fdd81afb74497d3288c1a05c7a20cd6b1d1a026445d9ef220f824638d01d0cb58c61a227d33a87b5094547045efc728af9fedeba5e289be8fc56f01e661f0c29068f0da3bc975c64ee255fc1ea80094b0e5b8921fd84d4450227ba852a8ab2afe5f5b2498f699cb5c268f02696350c064a5525aff2e560767781f8c642ef6dbf593adf4166b7a826dd4e91161c44b1bfe397659b08ddfdb4bb19f962a6d91dc617a56abbcfa87ed1791150f59176bf6dc30ada62daf7152a5714b20383c6242d26ab80ac22300c763043e891a1eb2ac926a5c8c34a860593ac79cfff317033cee45a5d24495389fe49279c9645a0a53007f40638560c187e59651b9e983a79d13aa04cd276ec14f8156d01dee6c9cdb750e073d4501644eacbf125c487edab0a768ab41e1f128175bf0f0b9186f1de06ea0296612e673fec5a441f945c7bbbe725ce8d113ab4edc256728964cb2fe2c3a7edb8e41b2ca6eef4248d9c13ceb5a11e71c8d4673d22a62b31d63518f576e847a22d8d34d2dd9f78ab5934eefa237147a2c140ec20437f3e59d513ea42e24db0db05d7def96ec82fedfd9ee5a9c4f2cbddb8ba4e809e96d951cc1698ac02f82b31e346e34b8071aa325a62d74e3738e31c983ba6d3cb33267a326edfd9e39bd22b208afb8c932c045b1d133c7283e703b21bd6c2137e1e003e2ea58d9d38b6acf88ec14d180e903e24db6c97ba5ecffc08460dcb40afdc69d01417803184d56b91cd1c3eb971f0180e323dc2c27e3489447e72ec71a550ca56475e581f516e7c111a20b9a20c91a2f899e867c736edd9d664bc6f9b380c176e22c18e6345dd56186a5ccdb230cabe11899b0248a764cd0c62d2a6478a5d6d6ee4212d9d7c380b7a94e1fadb18443ad90d9bb6830841039b900880da81169185ee78afc50d552f811a29cbd477b03fd6c5f4d035b212b1d163ccfbfe3f69490dbdb78015958be819e2764d1170f733b8fd712caa0a8c1cfe1272b24dd9163f891b7582dea58eb0a7c43249a5e06ab4f96f9b397fae8689b8ed52755ee0f34b76dcc25ad384c0e9941fc6567d28171bd0ddb20a81cb47eca8dfc07bbc81186d4b7c95e5bcbeba7fe33737a53ffefd426890606b843a31488d60834d85b6918e56d8e29f2f43d96911fccf09f57d36c218a769c1d1ed727e524a5a000f59c0cc8a94c623ecdffbe73751d67b33285fc155ee558b745022238177c8799d1168c02ebda473a15fdb9a1c98a44fed68b3d569c3af6f448acc231020a18682b80fa0fc4a63e27edb039b5b28549cc957ee73e0dfb39e2684b7637a5c12a6021b0f43e9371054f787930de0cf22e7f92bbc1514f1fa71781c8c2d27cc2209f0740eb26aff91d6da756c6636ecc47aa13ce2c32b1d1790337c314e8ae553b99ef084247f83d544781e09e5aee5c39a4ceeeed359d308fb8088cbe314ca6d9f589b4a03a91be410c9b280a620dad03cf3339025cadc1e3d8e267165fce1ea29e68ee0eb41da98fd8e0ca5b14dd1bc3827ad8a496bab528a00e9ecea21df92d7988c7f6a9940c6a828e9c0cbbf0b8e70f87dd6928f3009ce408dc7d71d96fdc131314342f2516e210ccc65cb5d57760ceff880d9752f8017568ab37ddd827001af5dcacf1eca0c797583322b175d0669b9031bff2f8eff4dd15aeb06c2ed370c622b2b5eda065dce5c492034f0e2bd629592d2d15febf73c8bae2104b326479b81052a942ba04857a7ed0b506f99424cb6615bac4462c59fa1eed5025d7e6093d7f97d1f7bbfbd74acfaecccc3ea7e61e0d6e737c185e049f6c0aa457958a34024f212ab230b7ee09e5fd3c1d6c03ddb72c4169aa7fedee88a482369149a20f3b09ccf24aaa282b8531c0e311ab0be5053f98ac2efce9de5a8fecc6e7d5e90cea283d7782f46b26454a4660151621890f7820f7081f6981c3d2e55a673ff764db7b7236c39e1c5e344a67fa346f14baa8fbb5d3661719e6b4f0cf30bd428df56dc35ade69260e0831f429c8372e2a6efedbe3956bd263961c27a589b972d49a52665cd248a44d26919ec3f299a192b22362bc52ac1572184d6c35b1960525b907bd7f7231de6148c127c1c6c162c36c1d0eb6d6dfc45c50955f9c4cde8b86d4f62159a7bd96429d18e3c6e8f9d29e94edac6e628a29dc192a798e06d3050fcaad7696b155d6d72557e5bf6c2b2e772d02e78f705938cbd97b1d756d45284afce1249e5e82537db1ecc8f76fd9cd2ffa6531d839c7eac01d497d7366ac70a5dbdf4169ab928c148929bc501ec51ef37db2978e25f86e814c6d09940543cb4b365e7d99b2c7cfd078a8e1e307b5f41dfc6e1c31ae7bbfa8a2676f893bbf9f85eca71de8d286e48e8b0d961cd730e159e764aee82e9d7aa021a45cc68f090155aef5e6d6de3731e4574db7b12549ae971747d52636cae5b17d6c874cf015dd08e3b89e6c793e2cc1893f3f4ee2ebe9109482b705f3e5cb3aa256df7e282439b9cc7e62ea2b8ae34791967d0aa06f349ce8b2af329a2a1232eba91ce8e10d5b9ce1806dadc029c48d7fd92c7115787fb66993b8c9a60883e8dedc075170462b56a58a86b962c3e93578f5c99328747cc92b8a19b166f7b352ec12cadd3984a6f56bf88a7d414da2f71d3e95b2762e5b76ee19c1f6c7bd09121e80a9c063aba4ea0ffcc02793ca7dd7096d1aa925ef494e952723d2ee62bc44d8e0aa5ccf74be851ae6af3ebcd324db542d6473e8cf92fb6494e98ae21b7a150ecdae51b9614f964c746218903ee9c1f45f0d06333cd794364825bc4d3a38253ede4025c3d88fe4059bb7525cf8f8b80ee1d1fe21bc42f673ff5973ccc1702ebbc6fb67787c051e0bf21a56f882efdbe6c9f6f4498fee00716a887f357a617be6a7c5b5fd4e15b67067df83cc6e94d6159c1b74ade3ffbeb8262439d18052799ca86422f6f2c47862fe72defa6606eac5d993b20f3a317b87fb26ea31bafe115a8ac772b42f0676ea6257d4abe545d0b147a985343705f0c750ac4f1bd99dff73694d2680a1c14f999abd601f60591789826d2c221501e2d1ab2cb0fa04c3b95a59cb4397262046eb0bc8d93d35af8a5c9c9ef149ce4ff06b1e583bc2ce39d583ad49de2a5be7cbe6a4cc3a5a5ee880567fc48a30839aeca0e256e8e74d1276286fef1409ff0f5b6e5c08454d7cd963c48c49d8a807c90291e8794f978d5e4986f82bc4bdc7ec5029abf04eb8accac783c475c50b97e2767e64f4876d60258eb9d55c947b5b40e11663b78d28863d4be6cf1d0a0891a2adac2df299aa69fb9bb3d6b94572a3d6152c33fd14a4ef523770f15875165f2cf17518e5d374c51a0294371dd40282c51415d78cb6d01118d5fefce32771799bc9fb0af318d76cb80a0a9c74ddcf860cc663cb443ddc53324c96a61ac55c4f82146a19d64dedc22055cd9cfe098f93b7713c9bf2a95083b5bb5cbb374717367bcb52c017931281b5178b1b4be060484ff59160717e79f18584cd3211f51ae96c48a929693c659c4a5fd2d38a661d890b709247441782374b7854dea08310a94bfa7f2954b00fc744d5bf2c3aa60b0eea654d05c820065c73d13d35cd5334a92a362efe2962b1046598609c2054500da86e158344971533422865286ef84eed25c1df8074a7c5b61c85c30b9cec5ddd1f7a6430e7edbc2e1e890430882f5465caa084d127cae976d7cc9cc3d3dc7f6cf31b6218d9c406ce79bcc6989eaa352cb19b50782c69aebbb251158d39d03835042ec1ff3206473e35eff741f11c0c18db5d0492ed335c33d17e06843257c863639bf820f1e33960bc6d424fc61628f7beb15332a496364d9c074be8a07ec4293f0b3d482a8451f7d1c189fb79981f2c4013f8b42ad93bd4672633835de91d30c6dacd2441410034c4e1babd3f342bd2dd96f30328742941ea7d80b0e4724247947f66186bb1ad28de0f6a35de773be2b3ac5e45c4aed79eed5062ce08f46946efedb67a2d841b6a240b25b4342898ab87ef995b8f04aca99b8e525c920231143f270788a0db5810f98632dad254724347609f32c79bbb55bf756d8308661cf4f433dac4e68dac3c338c9c049c1c1a5efd49c2fafe49d496d0768ffa39dd6708f92c0fd18c6c7a3a6a15bc0bbdce678e413ab6fdb6254ff930f29d54d5f65920869a5a1e1ecf8fef49c1a592eee1c920a5b38078eb7ecc1df037e91e56a736f551303e5339c05697aee05eac4b793da4c545524b57474cdb3549b8c68b2795aa7a52862be6e46799e4c7cac288a3ab0d22d2874e5d90ca41a2fe70ceb966009212b02807eda0723a0c033589b24a5b1e21b687e645db8a6a91ce68e753bb12543ea4f11e2426d3bb821c783779de93c22f4df019479c634243d58f73c9ecdadf1d859e3f9aa47ef68cbbc9ddea2f9835597be7b0ff86d99a2e3a80a8abacd3b2612d839f5cead14704f1c9c73af727b50a31b52bf35ce29053f1b686050163a9e251e99e266902533991e2b9d5a65fdd1f9ec66c07ca7747322eae6514704c3852dd00121de3fece41f533d505172dff914d0cc14a61d9678e85c7882b5d365d1fd73ccfc223fd6e8ca1834e70279f851bd2f55930311ab864e3bd7afcd661b060c6cc8f85e4083d9bb57c848715cbafbc2ab1ed010a6937af37935d0574eea25b7302ef92828cd4590ef810f4fc17be6e69f1a83c8dbf4c43fcf406fbb845e125d8d562897a7add9b5ed5b1db25e25e17f8023b5f746fbcde2c81ea825d886ed22c6eb2c1ed9af8787a611634514f92fe45ae8b3d922da518426621b4b214f9860f095c28d68c3b6e7e9809f68e65bf3aa24dd5ebbf870d604dad9b47683bdb16c3d7a4d8e9f66b9481f5b5597e6b4df947df7e2ef7086ee0cac69111ab5af76ae98edb34b1660ef04461d6e1c568784d70c74ed498f10f7e04dfa9a8f74823a56fdb0d41205f4f0da9faf749924df4916995b42d45774410e0bd092e29f4235d89f900492b94618cc1dc536189f94ca07e89f022ed07dde0c0a2a067f45e48acd96889fd1e863de3b0293ed93b8fb1ec4e52a740b1246c7c4dc71872a9bb155bef14766f6786b00a2e0e002a38e1e43299ba6a9031d7cea9e6fd40f1861f3b84278208e9a422d118636ccec803ddb229bdd464de3130ed37aec26ab065871050e717076b4f23aecc3fc813df92eb0b46e50cf1fb82c974164a1ed9a9e1bb3d3e401f6218572afd6609e95c2a7d8691803eedcfc2e76fd08868adde63c953d0899a105187731a2ab8186e82e934f489bdbf7ef6e6a34d6b0700df8a13a2e078c8a22bd5fa4f262d5952d5304cfd616dfdfdc953d4699c670e590b4059c3e8d91a55ee8879668ea17f81de5c0a9de9458789b40d56d0f07823d4942be2b51b7e9ed9f8f1547506514352c11512a4b222fe2c9eae8ba6418fd23bcc5394c6917bcf3fed6c4b363141f6de821f199eab6973e925910fe8cdb5fc028f26ba1513a038820da90ced0bd5da2fe445467563342b6d4e1fd5c0d5072fd90c4fa7c021f28813d85ce05f92022e044aa134db4bf133caa2380bf0939f5452ba28914fc24f163b27b4f581989321fefcc87c1ad2d6c3fd16a206a62572e1218bc5feb5b921465b0411a2297288d7ae69b8de771a74e2abc18fa95c2f6f8c1c63333644de8c53312906f887d53f3787c557cdb4ae6bfc7517aa2484f1f8fcfd936795a34683c261e2468780ac268a17511d3b7e87fe21c39a2e71ff4898e1751ac9066736baabb7a9ca25caf64ed55ac914304f84fa8bb805cdd540eb99946922b7a7890566fb08d395d93482aac6fc7fd4973a480cf1aa05a0693a05617e9bcb122e82a0e6a919828fbac1a2b1d15ecca48a5ba6ade94aabc429563f8f189f4ee709e16e66d4fd7a513c5dad9365c027db4433a532600d262f20a6332c4bfc60f24f9cc989ce4677bc4d866ed87fb9b218523ab07f77e50da62ce1f6a4b74f3128af365971edc9563dec65e49216d294efdee16c0d43f6ed5c1a1905d180f83e3bd3f7e5e1f52668c34d1b055e3afa3c32959806f15229896aa0d0dbc76e14d735f37249a05b106f56f0982a4ccb690d84077ce55963a2869b2fe5962ab2c7f7a2ac6dbe02cdf9faaa80c4cd2299ec65114560d1a12a41586cdd2120db4f9256bff6e1c6ad0bb3570d72ee9b855c4406992f096e42c84ebea5eec027e058c97707121e021b7b7c0ae70aba3ed84a9bf409b2b01bbf5e5bd25c007f0912e83fd15db57080bb5c2e94702b333403492b07f6ffb4f57397248dd2fdc80e2e98feba19b84afb909acd590b93d94f0f51c35893bff992ed2f25b7d57e3131277d93af5067f9d7546f589db2c0e4333c1794253c6f97ce68e6110246e9ea2fe8d69c976e074d66e57b2b1b398ce472fb614f6a8acdce3e72331b28d19dc34eaf1e8d53e2f09f9de768a102ad0563bf107138a0db79ccb7cbc2f0cbf1e0abb10b06578a07b02552a50f519435c7216018847c07fc80518a33011afba10dba94fd35936ea645458796b8a4b169f04dc2392fec899aa572089cf3b1f52bd197910a589307f9a31236075d86d4704b058e4ecb7e84aae1bcfdd5f96760d1baaf16df58250f81e8ec0d0730514aeac1588da9fb8a227cfbf49507c66e662acf22e7060c9ec6a31f966e2eef020086b772f9157fa63fcd2fcaeb527f614d96ccbe4b63fd988c0d8055d9f78e73aa6efc5f4376cd45741258c8c17c622070e1573f504bf871282d2a341f6538c0ec6f96904dbd4a0938347f99d70a03b0ae7d8b9430e7de3bf671b488dae1c2126ba0593e2df3e5f271d851fff01452f76e2035b02b3c55e41c267df5d30cd114c7e20066bf0c08e308a0073be6a61130a624c35c3051c375ae3efcdc5699fb0ac08f34f2a012b09a23999dc7efa850071dad9b0e7c761e0e75de45a91e63f7f8c66c4e8115cdbd2e534177e53f0cfcdf81b9394eaecba4aac7e91d631d32d919fd094aaf605c94c54d39644a478ff2525b0c123bc378038b8423d2f874614c0f6b601c6229464653f9d5ec51b2f3f060304f478025a82f98db1c389614d9fdfbd548afdff8dfde00218bf5428c25a0802729e07b25cca678d2ac49ad77b77aa1dd3119210c292e7a52b7ab25b89178be161464bb7f718ebd6fd326f91d74c48d132174735e355ebb11de50437a8de2076586d48c8691a39b5a38b3d4e1987944a941fb18a9bab15726af51c1961b3e6e5c245a6d18c4b73b3e6cce957a989049728634ceb44a7e743b07b370f08e430c02ada98f1a9d4dccab081ca3bbb06a6f2d8edba88af2b015dd4fbc0693caeae3145c5dd9419000221fd5a5280b05f3a032ce13cd834dd5b63ebcfa8c134f6579b432fde06141d1517910bc4643a857482a39fc14032449aedb0c639b5fab76d6282223774e3e14593f54d09322c1ae064f1ec5922aecfea595a08637c70e64f30ed2b8dc9bea9d7aa0e5cff297d09a1158a91b13abe9492112e4cc0a31aebf2ed9fde027a274c4c0a6cfa2337248db9a2d6ecae87de9492f23e8c1bc3b55a7dc067e587de1b88f17b9c3d09c9bfb2d6feaf9966e8287734ee2eb2e65e8d94932c029a0e01c1010599a57380693b93f50e73c3786fa428705bc52a36321d665a4f0704b8cb760602aa786f5867fc10620a117a64d1d81b9dabeddde89b2d12e8a70e80b5728df08909cb29f09c4a35caa5bea2b4181568150103be7a685c202e9b645750cbe0f6296c9df7e5d86f0059605055432b7fdb0f8477e5079023287437e6354273652692e4f1cff97d19250fa733e0c2c78738542920de5d46806ebfd6858031c517d38b04420bbae7b0d833da7f8b7c496785913736953a971c08659b1ecfe1a416004cce026971453f9c1f73e5b7566f0ccefeee85a8aea9ebfa6e4829f1f6791f399c84841d9cdfa9327e347c3e0bef901fecf9812d28c21b1909509226e732f1ed68f06ffebd0eacf03809c1020037eb43f9906cf57f240ffa39d9ce9635665f8bf1b4be6f3e40dc1b8d660bb2093a7083d45e8511839417e82fbf3158412499744cdd7aec3e52f1459cda13eb377cfa2fb0737b89f409fd812f241df33f423bdec42660e339901eba6fc4badcaab64641189d2032c226b16d2fa9b8dc21c7d213a27b3186f153fa3c8d0ec0fc774e78898f6149c30e3aa5314b0771524ff791475433b7323654de7ec6d757716a26c2583f35b25f26a00d42dbeb5e3385b9aef950a2f7c3781df5b8ff7e2b0c1a0a28039f88dc2db407db38da60a93b516c0019a1349d7bec4dba1438f0a01851c3a9c7aa6aee84fb2f7a143339b67dc202f400297f39d3f2f9d0cdf63ed806e4afffe965ecf4973166e71ab08593568fb33d727b02e949d51f541ffc78f49600f172bde52412a82c2a60f143cadfd6610e9f12c363663bc2f7b347f9beb63eeb3baa02368b4fd3750acfaeb8006b6667384c131aa46310f6017c8684257b292e47cad2940aced482e8012b7b59d58393f3dc3399a5a1edeaf9217e334de7608a3d3a17588623aae5c4391f76fb2ef86c480c83d69eefcf04b8bcd1923d42a8c8d4d761e61f39c7cb8a0eeabd28667256ac42969641c74b0215021e497fe6242151c93436eba4eb406bb963af624f46049f8355c53a0475fd2fefcf3675e390c471113bc22b922d2d8b7bf0207641b3fb87e3f7258871c8960e03d69a87f7f6b712aa40567d4e1a8fd945aeee02ad6e449b7275f9d7d22008eeaf07a9d6b15df6f7235366140cda5dcb33f215ec90f0c53fae2fd989d48ee1785d718716f79cfd0f172706e904bf941947c824214f0386cbc502c9b6197e06b01dad8e91d02648a10b892b6a6bc811491ae607d044fd1db5adb60a294954ac56d14478f3bce70d414f85a72c017c7c8e03c1974a0ed5325340745fac54795fce5795f10c483e422852ebd5e171b05a1cead5cb3a8d77446e8ee4b3951acdf8ae96c27d6ce5cb086ec3ac2c473bb4d288c9eaab8f29df5d1dfeeb1b5ad47e1ca4cfb044af90b30b1a0f85eae48fb10cc7ea2635d377ae02dc65756c8ef157eb713bd33aebbe3e0dd219dd4363d4887df2f3d15d5bf6d9e408fc62d5af05800258081dee7700b8d14ee4971ab968ea0f3c50f031325524c6a90f0a41fc895a74c166d62c064c9f7678c899e9509238c44584d7794bf30b0efdaf85a164beb344f56966cff17eef3469ca24645252794726b677e4af109aad3af41b46554182c2f1d4eac370c9dd7ee4fd7f11397e363f56481b9b9e92098788db84b9515ad6efc69e7655310d4e05b23519daab0f63cb8e79ee71f4d345d5b79add25fe117dd2534d1d286d9965b02cf99e83aa4a6912af4264abd5798070f911e4a5634739e1ea101a56cfdb5771202c2a98d3fdb22471ee37599fc5feb8b5f2be1aa3468c78f19182a180516cdf2f8872decf499c215f802608fc22a1978277c60be553b16cb22df302357ae8e83721a2e66ca156c28edcf5feedb6924cc131665a2a7f5411fab6eaa0b1ca51bfedc0de80f6e7d05c9dd83feb7f66f7b6a878170a982db7b6f7b23867c2b93780d82b180538433340c2a4671b44bd2b886e7fa3821ca879ff7928c56b944071881708f1b15f4e17d10a2e7c410216d6647312fdddbd5f51eb7c73c0c3a4df766cebeb396ceee1ab3bac093e3b44067ae15aeaf703fd9da824b15a8c55b29681f6aae8dcca4f6f1d9af058d1045be2d79abb915176bd6c36e414e56cf613cd634c2daa1c27bc1a9d2ae59a5193a78ee0dc1bf232197823b4e1e9ed6c9fccb542096db18c8b1c302598eb7c5b900de34990af5ecc564b0012db5d233cd2592b059d4d94b1e964d69bd70ce719985ec1e7926970373a915fb85e4dde4da5cc095410b6d043c591e898b6dd2f5ee48a4cb423e0829484c96a3d6e16dfeeb6d710ba9ede6941823d50d133c3132437fc24a3482673f0b7edfa3839f4769ab457918f2b0e6aea98340736a709c04edb6a0acddd5dccc88ca8731bc45332936ee484c63f2801f7917870263288204bf9a5e0a6d7e59974957fbbb84f0fd8aa725f9f5bf4f8ba8d4302c7e8fef9ba60c09612bd2d05b76cf7bb5b004cf3312b9c18383e5c8a25e9fdfaefb18f2408e009c6473ff0d95fd3184fee5131d5605157e759e5c578c19110a1b96abf78881bd02be59b9983c312b09459773a30a14667726c29c832729ecda7608adf6e838c2c234407ff22b26c7cc87aac1cbe597821bcf4a2b99c3ec8c9f66dfd797d93d6b3504d0ecbfba4f13af5de2000b844b644da214149023e6382a8bef920def775c2329ea593bc24975783d7a3b7a09274cba4ca2db7cd4181440c04183c47de79e1d64d07a4a8f8996b43a755e0d2b4aad93fd87de6ca8c33007c8cae4601473fb1b6de6f55e66b1fb67881ed0b69ecf82395d5f59ae83e40c0dc5290d5bd3c43ea7341c5ce1852b1e9fd693444ca5c48019224bec29d9524c88553910d667b2a16d9148f1a311220d34be32617f95f87aa1daecfea70efd278aacf31eac22adbea2e7673a8f4b11dd8bf7d5b6c247ed7e61c968777d025a0b95415a2383e5ce172a6b2f770a3b45e8029f2f3474c515a7b4ef9c9e03f986a9b0f4c4928e6ec4a1dd4a497b09819093c491e1cb7eb856a959780ce84fe2c3114dca6072b191aa9d545271006200f21aa6a7df70033a05f44e9d89c82c7697d7093f2a9eec62cd1d6b325fff9b56497a27649ec8100631987ccbd83b656c501b61057cc12b4bee3b5990031e03674c4bdf2fc30da732a8c9ce490440de7090e67bee5d1eeddfda4fd7ac615e2a24ebac00043b75eae712610a8e0c8586a74328c33f1bfc4f12e47f5dad7cb83e3d5d212122a8d685d68f96f9fe8437ab008e928a78a6d21330415e274c9acc11e7e31b0e705e3567cecc84cb72c43864f0c8a9f67e395f98f85006ce67f2145ecc7ec5ccc3c25c23a9441a7fd7dbc777fb2237ad9ff534299c8970383f2a9ccd8f4437505a656ce5c761324d295df18caf4e58b730c9ba4c04f72467dfd421f3d106e41104f22f5facd9b3c851360d3b4d775acba942ff85751c3db1de436215aaeca7573bf7da41dfdb72624f5834e60f7be0e4360c3313b73d3d0373e268fd0c0651d7bac25df766e0c3fa66e844028d239b57c4eab145068de729e6afdb861693a746f12036caecc3c3e185a399bd7882a0caa3519c876175f580b574c0cda5b897ed9a695fa56f7aae27f03b70137eda7ac79cf4cc997c006b3ec197ae4fc24be88092ab223e9824f4f9c3acb482bacafd1fd3590b39eb95abbe6561434a73b6e38affb7b4f8f671eb1f852c2c2e85967ff4cfb80168a12c4da47db17bc4758afbc38bb0c5f99283ef1d656dbdc8392d7d70ff782fec0c9285e20cdbb6ec692ba67feaffb1c8f9ea1f099742faece911443d9b73826727a0c58fd649f489ac9dc0c345d3c515e85642f1dfaae3c42c9280bfe378d5e356894b443cc25e4bcf53f6f998bf222bb26c9c7d027a6f67cca49d1e104a31a2d2411c71f8e943462f8425fe7c9a924e4743a8a9364acbc5cc4a74ae19223236f6aacff19fb4dd767673d3495bf52c1afdcdbf30a8c8a86d9248826bf74d8628912cedc4a6f9996683e20261113c39f70d8ec29f81d70f407c4aeb200ef628e3d7668c41804c72ffc301c4abd6d3431a35904a747b9e9d7c0d3457d051d496442668da5c20655ad9898822bd823ee93acf7a3b846618a5ae10b4f4b53789a2bbc250534ec92e7b763d70c241717fcf438abb7172a731e744f61dcf62814354046894b1805941e9305cdb82c70e0276eb26f64027be54aa6dc776997f77f571702c3a563d0f370fd381db3513ba491d793e3c5a021d883d8397bd82dcce3234974ff8ddf2ae7a8f7117bb5d32a7d75e4cffdf5103d474870e27da1fb880f68d10fc5666ccce89ff3b34cb98c32202395420f8ef291e0bc414bfdc79c0535588b122fcbee17989246505c3a2564781f445cb6f873976aea38caddf51d765e25a359279dc5f7dd436f9979dec077e94370058c175a2cf079e89ddabb3c62f55888a24fadd89dba129b1710784f57cd47a52c98a16919c02d447f208fc6b90eb67df791887c2da40b4b00e3e1078bb024f53c5ce6e7c1cc900c505ff4a2f417127f3d7b4de8982566d1c097863a0861c71932ce763df7d15a076e6dc4096cf8b73f2ee1ea3439e423a326b3d515293df5ce5b16d01804abf53bb20e66a11843989c528285c946a6e7394207767051b83233334f3fa587dedefa572259543bc4399d45d9533a5a9d29172b6512ac606df7155497f733c5706dd56022ae6ad49a3306c96ee8de964ca626237043e8f8929ba5ee5d88aab6660efd6632eb127d2b09c2733c2cb82a362a1c5013b6b3f6fe4046336cc17ef1a9c9b6394194feda1589370bfaf6e97af4ea958cb5584cc4d66950dfb48436a160ecdd1707a7437c8939da6ca7c8cfd6706aed6a9cd99129471e9bff6d5a51954d45fafc53ac90c8922ccd1183bbc3bbcab99c8a323732255921094c328c8e87374bdcfa45f1ec80d6078f7dd2b172385ef24ec54efb24eded40cb9b58a749f2edb591512e2f4964097c9f201894ce0b2e78eb81e9f3f02aeadb1eb42103878c35e7000b00d850e3fc4ae69152cc5dd96f73cb77f2cfd77080a0b93636eea2bcd40a385cb58bf9cc02782c1ef45dc2b35006e64ee0f503e46c2011ea333f5c235a65d9fb1bb8966e622e0a90cd87752eb5bf93fc5026486225779b217a28a89d9a53ccc1626398dbd8dd39a0f2f23019260a1ba5b0653d2b6a7bb1bbd7dc82af82fbbdf5e189272817ac6d76becd38622f86caa6694dca1c11ebe1c955ff7cf316d8b61cd1f6c1002ce9841207f6d9edb40230e4f25b318ec601b51e3d727468035c6a9ec29087f1497bc422b9fa41d7d8299b936965c2a7cef16e92b857a8b6c3b76b3da97ad663b5fd4d4fd7a857b343cc46d6ac385fced2a07a9ff7aa19b76694b74b5f2b08f21e2397223d0cb3edc57acc4819cd4ae133dd0a3043b3dbdda3bf67cf85844f585398aea8055a5c70cc2298a26538f94ad7b20019555d86394d562c68b0ac0afc33957d59525980cad09c1e2aa00be31d78857e9ae317ccaf0bae2e5ce08928a492877b2366959812964f02fc20a6200085a516ac6e83c912e390591c08a7f6a42c0afe6bac5c654a799f7a5620e5a45a00915a020296446ab98aab8e382d4482fc85f4793237b189a3bcd5802e5a6dbea6781aedd4e8d38d9fe467edaa070888930be3a2f4bb1eb07b364ea98e998b00bba8d357e68ab347fbb1c78e619e529432f5e56cf196a4c5be794967f3850494b2341283474945d4ec54f3ced4d5ee7889f3dbd6e8a5f279f796dbf78655c49245bc613ef922ebfbf9b1b8f5ada84cf0b0b3494932ca7d4b061bbec2c72ecca30f27a83b924853aa01b1521bd4257cfb94afebb47525aff95e4007996b273052e23b34c2da3b4528a603adbace0320853708b7bc36b68cb914411b44a75aa80345a792f3fe7cfb6fa52bc41869b1a4d27e30292c175deff9289ea09a9e49a42880a722f94838fc9091450d0dc6b0286d50a4fd56be0b45572062ae0eb150f784d648234de26b18e70f7429cf7786e7fd1122928031d03534c59170849ae51f458bed50126750d7c6647c07f1ecddbc0c31eba9e7a81c9f788cae1da6743c290e08d440bac85fa07fb041cd8a5b2d5b311a27495a310d1bfe28e21faae9c9d679cbd3f2dbbd0f4795cd6a362d1fec1a1ba89c8f95144e4caf41da42395c2e1ae52a34e7bcb49d64b5789929b31649ca3fd1ff018079fb4d4abbecef3a2c67bc85c558729f3efcedd017986bdc5a4b2747ef2e75805982727895ad28a185b6e20bb8cefcada3706618e8ba7b860fd8b27320f2124f96b896befce1f2589259d2689ccea053adf0f21f961f22cc84b6724ceb99a1ac65041c97c87fc06e236c8ed24d126258dc0380429e70b67db67b18771d577ce8a557f7bde26997b399393e672e79c77f82134a9a17a8eacd67b98b8619d030e5b0e03929197e429d57c765d4184c18494a10c12c1709f23bffd7290c18641b2a5f751688b0c96bf22e3421f50c313e4b74d9b6e7c3759e3a5cd60c9cb0f49a0b9316733d75b25ea4f03b3a793557993b818d0b7ab5aa3bb696171d5e63fa47dae6d2343f895d5b7df59a65b700640a58a97fa5df56138d4f0c64cb655a4de6c287f522504d8b84bc4362b663af383b4bc15d14ea60702c177df2c9fa7c18b9c500ab05a5c83207c24c59f39d2b29ebf5a24564dda4ffabcd85b4fb30b37c0116f41b31363ea599f34563c2554bf3a3196fc201bd4ffa8de7e37bf1b05e2aaa43ff62acc221ab6778d66f2bdff774fd2bd7e0ab29536dc2f0762a15eb8b96d516fe74d07fef20e2e6403c23098571b790180654a5df3a800ca9f94b021a923e4a5b9863dd0b44e353ac1538135c09ed3b69d8952c0d45646ee18f86b82db42129e8a2bad0fd7e7215b807a5603050010f4350a8feb09049353aabc847a03920fdf9eeef0e39ff013272e019e7d049e7ca955b802e3d7eb2eb5985934278c3db75eac033a066ac594f5a05ddd6b66293c46efc88ea2b28b3d2d96b9fb5c81de1bc9e3c74cef44be524b56f81e316cac505b4a5d56ad55ac8dcf22906f8b9c8fa457e905286b615406e1c333df36be8529802512bc9a558bedb0bcb5e48d371979002de37677dce55d29ac632fdd66e6163a1d20bc8c059a5f5a2a16ea3aec41d6bcf4f069aafa36d85d609a81f83316313353085fe2c8b27455b0c554dfd2675b85544c7d27ff361aa7fb5d9a2d1eeac34ae9d9261684c485cf1b125b67ae0768f95c9a98fcc4b5c32e8bc1d5402fa9af1eea36c7fb00c92561343148d649d3740b42a29eb92860033a9ba340c18aa5eaa372c11905a953726638c1a4fbe843241a72d7ed845df5e6605951307c53b51f68ed89ff6d70556b96e6fc150b991dd022926efa7d0c8189fec5f75f5a1cbf3c1d28d0834a2cca120dd3c47237f994d12fb39c8021b3affd658f2212296ded3191f95e2129eb2d6dc910ed076e95afaaf6b9ef086ded4f188c19995428c771a88c8778143f7fbf58245ad98613e11e186396ab98d660fd1a4171a7621a08ca5061289e1c4f4b4ab75da342ab41ef5f2980034a1780c11c15313ecf84bcb28a729f9386e7b6c7c63cb6d683dcf789b68dde5823afad51107a2e8e5740cfc97ba0adac53ada3f0c508f5379fbf702857aa524216a7caed760619e69a72a86b965bbfe6b75d52d8efa3656fbfd86b2979386d10d8b124503cc594d233f9a7bcc1bb03f3b806e6fe2a627177235afaef90ad6f0aed5a865d32ee12f400d78be617b991b53a55a074da0635266b2c51a7f52052d8d3b9980a120d18460a59ce59e8abcdaf2771ac7662485165f822f6519a05f775d1771f6b9ae1b351126ab117e55391e21933b006bcf4efc02b1cbec93b176e0d9f3e0818f5d809ff6aa9a5585e21b37d78a6e05626b81934c7517c1a3e971ea87ec638ce693c6d6bdb46c01559e33b89777872cb69e787e93bcd48a93748f917c6bdc51a6a8c149dfd5eda01079e09308fe60aabe1f008bd9ac3e0c3636899fff45fede2ab8a0d9688c18c2f9b569bd9e9c68c8bcf46324667677532e149dda60940a264e35119f7d4de69733a2dce4b91137930400de299a8de0ab226c35d0cd492cdfcfff93d77b5573db108f99d64979a0c3a62b516df55bd1cdbec0fbd1ef381550dd001a732b32de23c46014ed773f2318c33de4d36f266d6f9102d2c1a71c0b10b5f92a9676c3c4ad7d5cc380e6a3e62a99c76be51b0d66cb5f9b398d1a1a5f20779a8a658d652b32a92eda4cc532affe617f70d8073052c59d9da2a2cce470e65250d431bc5c12f00169fcb91254b279a6b63f87bcf5ead49301e3681981fefa632806cd4f8338300fc2d8cfbb5a22ed3184b26bdcd452b7dd36c36c7b2181572c907d1b712d85422765a6f7a71f6f63b3fc9a86a9628f0b7e561b411233bd097cb5c9c9fad1145c5ce2daa95cb7aba5fd3e3d977741be223f8dd0435060d55cea5dd65198b31542c8b9684c1691f2dbc88d08f59f4e5d437266cf57e11f24326c46accfa314715ce1cbbdbbd6249e596c0b232f731acf6ca313f0de18299f8c8927d602f8426197fb9784ec4f04ddeb5aebad9c068e95ded72bb3d7d58d9a9063799","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
