<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd2667a65b71663dc30d5791bae23421ab10fcdf7fe20facbda893a9d9a9e63b697125022a0e9ba6a257fe6d30585ad58c3df5f928a59bf62f263a96af13c1df939aea6e19aea9218d22f7c06f2f2e92e8d3b9f0aa3b13fe743c1aadd346812c1f9f15b2ca8e6524089abd8096396c167d9168c2f0db6bbdc29a0c6443ec53137d6dc46c1a3753f85b4e87172ca5823064ae30ff6848bfc41efcfd04650b1740f247644bba44baaf5f74af71a9985080686a884dd8180df16c2f1d23822b24615f6d124b7e6bd44a0acbb274525d4a4a191820f233a88c730cd327419b94b994dd00124d280bb2adc0e0e31fc16e1a6840eff356795610b7b287f487ccbd994a5612f89ff61f7623e3e0a5dccd041f8616a4618810235a01d0683315f1086b8635339cdc022f520c2278b7deacda12a0e7c093d69409e342487672964229c9ce261a06c817dd4180a37f4d9b85542239e5d265076b56375ade48db08d055fcff5fa332a66284db308477ea4a157d886865eb56f6cfab935b581a282a1bebe79b489dba3796f79dbb38feea20b7d4b10259003ae3040ea614d7a48de6fe6b72a975a1d783aeb034ef30bfe1bf2a56bcee37c6ffc8c68e02545fd793c42a953ae1d1f85a7362c5c934a741e5acb32966c59002d7d776e0502f8e4a19f3804c4b7199718fdd4eacd4c5dbccb4a8b6cc424e0eca4ab2ac1a04af08c239604d0af3de8beaf0d944d806c530d8f5c46d69d7f418cc67923eacbea72e6ce242a4bce2078fd737485e3beb9be0719673b41e7aadfb982768f0d0ff53eb62f9c09134dec9c9aa55973899a1d3e4d3094fa0c95ba17f74ec615b040e3ecf2b366368eaceb5a4098895d9897e980ad9d2e6085d1d4f2e0bd3d456f4fcfa79dd12a3a17440eebb256c4f7814d39b0e6eae51211824d553d8981d5601b2acb4397cb915bab377018b1cde7c9e02ac70038bb22ee6895680888a17aee6c306f55a1e55852ec9734cca6254524ae8094ee20dee3ba40c2c136fa72c112c0f034477e4f7ad1d1da51f4c2ccdd4fbd26a52577c6a6c10838815438a34bf3ae6943932f7ec6ea609b505f8339f28c15cb61faf4f2e7874abfaee053eecf60b4af8bcaf1d1b324dfe9d0b225bc02b3dbb68cb3702e9f7b62f4838f6a67dff5ace73c59d6e54c6a19901d50af2a16cca147d9d1ea3bb7cf2e5e72dc98bd5a674d918045a685dc2fe853d7661969e41a50bdeb984a7e0f4ec84787a0da59149a15b01810ad7b9e5bee623977916971d053eac3d633b0ed459fd31bf30600dbaf7f7fedb46873427c9c9e8e41ffa1e149effa4a84be59e01467d37092ac4969d3da8660ddcfff0d0eed93ce69646f9e1c69ecc52fb5f8d66e6bccd6169751963eb8959ac3b04884f0fc8cb9eeac453d3c002d060e841a2726c39c57a9300515548f32713998144806719960da451e20f31db604c642f5282bf119cd10ec7cbec7fc41b215195317c7fb7519c3f755397822fa2f7e5fa7b0cf5e8378a33d7b0029fef6e34796dc606042da412131e0d61eee961637ae8185450acdce13f99cb633680ebb1fd1cac9bd0608d7f17659a05102f135d1243c2a107195323e4ae217b8ffc15b6182a2651fb3e4e71d6ca409df2fa49a84e7e9a05a8fd3f9b5575a42dc86f047b3368f654ecc315d46ce138839c71d4314bff12491acd88234e252a5741ad0c9fbb999dd5d1eda391a94ae8ea16982e83207c39aa405173a51b3b77435e36420b516d765c0941d0e6bcb8db921381cc245fdc7e2c1212912c8328154111cbcf3063dee38dbc5a99053f6ead122aff1092f203f8666b79f5cf16df683b13595904a5864192a937187124c3ac70fc0e4c00075dfbd7a6bd321827cf93594ef66b5585147abca1757b969e9e2a3687e4562cf82ed768cb39e79119233cbb5af8542fbc3526f555de7cc75fb7938e790426f3b98954407d0d2e14c737cf25c19a6292e466ab6c3112a3afe1b4c0d543b23db546715fea7fefd7b1113ec4034e622383af34e69ab52d4b091a493a946828cbaddc03e08b3b6d20ac09ca64f5f8a11080a555a21ba638b0368c805f124c7be564f03e24ad33f2a3349b53c3b6835eb3f0e944ff607279b570d66a7bddb9a06cbf3818d9b783c47e9f0e6c00e62635fe63965e966f5a6ccd31eba3246716ea020e6a101027fc835e1883a555d82202826f6a250a74620a5028199b6e600f72c1f2ef8cbe79ee725fd005ca0116156f7bb28e0b70420fe93a50cb5bd6af4842c81de2d0d641376bb17aa4037ef34e5a4330f4b8e89c3b712547abf584de6a33fa47238a87062672fec8e270e1ca9b69e188e2c459aa16d98f5dc1b1241efa5dc3838b8d3cb5ed2bf7be7455bb7d1ca16f9a1c3bdc4940b122a0d94e31d5f42bac6cba40a2fb842ecfeafd5c9fd0c8e90da143621c5ff6f9eeb31d58a4593e70c3a75c8a74a33a6166650866b4961442e94b66bde5e72b0f2e667101a6f2d99e7543979cd45f554a459c55ca85c3b03bb4bb50d30a0a0c76692ceaa8232e72d871b20e4b345623c776bed374883976d2d5a4e8bdbfa5005c9f3ad2c227edf3c76a41aaf5830c241d5b7c4281e160f89c72547401045b3369a1ab20f602d451471c5995d5d9f632ff179ab46c80747912117842565c13633636c8207f57fb258b652c8090fa6ab6dd3f3236cb5face0a332f4498d695e9995198da4dad13ebd2aba5bb2b1b7d2e41d702f6940dc91596f1222d5ed9b027efdc08699f52eea8f3b436112119a8f11be0431b164b6a7f4b44ccb3abd542a1bf3b466e08d95ea5beec3abc6d9bfe0f895263d12dc5b7834bdddb5d435d55cfa3ee0e3e75c51ae4458f5830fdecd5687ba38e5246455b010f1eea15d10dda396423c09ba1deb64c9fca46cd346f1906310cb36d83687642c717d84d20eef469a6fdf976cacbdbee00acaf8816b913b3d9c8dd9bcaadda4cf8c7d134b6eae43683f1acf52393177a1ee7cab97923d02ffb5c88f25e4bd96249c6483a5ccd891e362213550bacacc5658378d22aa35daec8e38ce0dec91417e8cb79cb2c20d08a39502bad078287568cdfaea6a347f0fce5c3428cced4d5bc4e292a6f7ecbe6acc7176440e2b3dcc2863a0e2a14f04e138e2490cdc9fc829e27471568ca7e3f662c49db4e8017a89ddb748ce8ca84aba974b9e8225566780b1a8d1423dff99132e7d4ddfe2ee8ca714e34fb5362ed64ebb56a151b34654879304fc873318d2326cc274c7d6e428c1c1a21bdf6aed393102639f3907f85cf9ed2fd0e6fcd7f8d2e71c20ffac092d20768d93258ef6b2e80b4bea693d4a021f27200dcd2ebcb2912ad55f32cc8fc3fb9cb8818aa395ed255c11751df39879608735d06d52f22bb7f4111ac7c8459ade9352f49e44510a506488912426a3efffeed4483e7b0627b8a507b6d1531ed4deee02ff4b36df5014c417ff7455f10dca735e916931784069d95786ed42d6cef8adce1a679ea206c724fe557ee7b42dbd8c2a7e30716df9d7dd3fc9bb742726af50a4160dddca8ed70ca2f47a431185a24505b7a66340c9040478aa57599652228537daedf9241227523f3582a8e32ea4eef39141f67854d2520cb51f168e8513b7c8017077388799db088734da6422409eaf9ce2b03bb9c9ac250c72eab1c37e7f6ca4810af1c63f80fca173b464f2395c5a90701d27c6f8fed5d1118a9e2d7d7e2d1bab6374c8dc8482702c1224466e5ac0607192f9018b510e7e3c5e9359bf3f443edcbd3aeea2f62ce8efd65b8a7017cf98837e99a518ea696196af538c1ffbed4f0b03156e59d1ac78e9337751142c7ee1f8b4486c717dd366c9c407054b33ad618050ce9b4fdd8219f8146e1558d3e15a5064b2d362594180799079cdf33eed8b7c9a969f52131091dae3cec1eebe2c167eacb59544c413db242592c3ce294c2c63ed80548179e6e47c398c80429340de4ef8744fb185293af9d883787d89db7c2cc36c8f0101d8c1876bd1b735028caa2b20950e20a3ab94d8900ec5a652c4e715ccc2bb119950f88687329b91270cb785332d6f8a8f1ff399669bd8a8e906b97605c51dd07771c3c274c45ea0e15f9c74c5ef8dbbf442a30f403b29cc3b5d070a895457474e9e1f921e171a533315a5792f4a233bd4e7200b0fad938863c3caa3d47de15a3a18759f07fc6ac06da13c6f0ca13c7c29e27b860488bc1bb204bb287255530ae6d63915195b50eedfd75381d3df3e8f60f870bca133f5e4751d3854b77b546c9677e3fbab335dc392b7625c9137dfde902d0a3bc8e999b0a2c1d516fd963af7e23f3a746020fc1c11b3110bf4e08b266492ef229c2fa50656c50ffa42400484c613201500c2e98db51cfd9ac3cd9a064e0fb1073361477b22c4b59d14df341f48d74f0007b51666ccdbea0988575aa6023f6c91ebe1008bba06a31375e05d4802b7eb0ef262ff94832e1271853071135cae276a8d9ac3ee13662c494664843db51603251f8dc829ab6c9a7493059949ea6a8b945aec7ab0c72d80faca6842c92c959f563a4d00dae2888e8641534816cf337a224615df812e693e18868ca139fba67ff884fad28b3fb452e7cbdb0c7a6f28aa8a60c4355ad19098c7060ee79d4730c64a9ec8323edf08d9a2078155460cf4a2cf6d62a4cc52c0079ee9505e72b8482ed531e989ff8aa890ea4a3299aac03cb9179310d157393359d8f466af512d2f293f4b02de173f6f76d05cf4f457ffffb8ad4d75f40ad03a12148cb1566e895b6d48f537d965fb846622a9d7df0159eeb8b4918f7d28da343add36877b1634e16a103d8b0507d26bf656619150b9e9011c99737cd913a51929edadb8852fac346ef1727b3a5147bcf04d9ba3f00859532e8d94dee0137837c01c36a68a893f67c0771385a8ebb47f78429c36207c3eb5f4d08964252dc24bf0f1b7c9a89501fbc48140e193cd0eb285bd818311738fe364311d59c9f106402ec1a85130039c427364771e70eeb0070421a358902bd8c07ab74bb6e3be541399879a4517ec2bfc6d7e71400ecc4ae17215dcb5941b8e9f5f15da4eb9e24138a6f4c96f8fcfaa4c734a3d2102973a312ca10bbff92d98df0a2114a27da5293918495e2bc3e33e79cee6a3a25fe00294b240785004632c2cd7d293c003d0b18fd85c6e74c01cd4f937307890c45ef715c5e36d7dad4b85a77f75298e00edec76b7344b56ea5a57de78228e09009c9e7fd2d33763ebce5b10e838a442106a1d0f0c5ce94f7bc92e5defd700e0f41b35ad81c1f33e087387f1099374075e6de4a8d36319892c2ebb0ccac6a6c33b10a36189c6c1bc62680daea519849463a2874a257d85f6d504fcb0eef321873509d24ae2ecda4b21b0434ccf7653788293762bb1816cea334c74b75b8ceae649552624113464f7eadfbf383a797e2252028db8fc68492b1630038f1630e6ad2e1618f34b2673fc65ae2c4e142313e3ad65a846a7e8bf3659e2f94585bebf21e26566b882faf7450e2e2799e29c82b30eb665ff4f89532c9bf0e81510cc7f6a1661fb552a1cb918ba91528a20dcb2b716231867bc9caa047be15fa9e3bed30526eb7c7d21cd20ea1f4c323ab4b7f3d5a00d21d2f83761e9b6969a93fd8dc49d631dbaaec49cb7f61254b50784de14f9a10d80c23bf246df89c747213c57598491e4808aafdde034f4ba690fe1c0d3de268883c3ffc90b65e95e7222e4b42f6f6158942643a7479056a030d65716ef6f01f611a76a982d1c1a50403f42ca2572e95d2c982952e0511f94b9407e1f90229b83bd75f08e4b8905635f4d4b32d64807a862351f9f3f71f9a35fc546a877d5291218d9a186185a185a737ac3daef31b3a9924cb0097f93f4ed5a9df4b2dcda53006a38aac2b3ff7cfbd49efbe91ed4fe6bede269601a751df7f23e85cbeec392efc8aaa0d2da868093199d5b3a4462b33107f4e011e94bf97c5fe5bcc013057de45c12b42d19bbec4ff8ff4d1663b2befb6d4848902c540a1036b4526210813c488fa94469496b3d4f2385b584155dbc66f445c26329e3dfd1127291080726214e63b6670f2a28e7592b5ad7d9cfbce4c18a5d9655e7acf9e693cd733da7b8dcf1bfad7ad2200ed79d1e2cb6ff776f7b5a5bf73d6d21ea1cf5265531c121c9e1a753bb0314556a31b5b177115be721e34f81493559b45ff7ec3f3a4babc1e34091c3e986ba1a111f74b8bf30c5d1324f01f4b96f98e18cbf29db2cf14248a77874c03b5f243c71fb9c2ee6f9410a0ddbb4b5cbb544980e3534a3cdc82493de3d6ee8f605f04290e862e052d23f073b1893b5bcb816b4e8d81cd9e3a9c2fdf19b52e7830c30376c4db4af94f770269fee6fb2793b16e3c05ff2403414dce618270f0ae41c407cfc801432bf05fdabd9880b1d5f9c98949866bf5d1d2a513444b05118380779ca70c9eaefccb4daea07ef4193a8e79ee6ec97c17e0d01f8b70a6ee6ba6e4aff5a81fe23b9371a5df42ab6416c153c2aa61c24b598098007a4858b64cd3317e984e8286f1074e66981d1ab04febc4540d9c71c96982347cff95a7e0000a50a653d8a30fdc6e869d00012439e73e8af0263b06a2d3a25124336b2c1ca0f8c6a8b2569bb8fbf342547c75899b5c0b11687e073be3c016b4a0993017e67ba62fa60d9270701bd727a30db343954f4a7100a768e7a55fbf65465fdb3a5d5eb45ccd296ca315f136055f4aa3f5f7c4c23cec56b3b941a4766fb1e850331bf43c3a7132276da6a00bdda11a0909135dcf2eef90f805b224df6355b012d5b85be5b409862b5132af6aef36c52b5150687befc9a9467dde0bc913c46a1962c1f73a2e2c32a23407840681b3dfc63170fc274e299843fd4b8ce5ba19a7f58b156f12d847aa1152d16c8e220da03d0baec4068db1f3aa642289b80ec0e99d66049a3cc879979d2341aba1591ab280b7b98969a43a2957274f21c00643fe1eb3f768506ab5d497bc0c5b31856734d7f93ef43b0ba3393545787124f5ba228b63a4535980c08875a633f2b1ae274b5de2de40f64b425c4c16cc4c7379c5c7713f3b1a9d6a28b6a0cc9f6628b8cfc0378471d52d43617ed4de99c8bcc7d3e95ea3594ac3edc42bf82e5c0cbe15974797d972db83a550a3502d03e19109d9064d25d625fe5a3220776fc11703ec3b1863495590b1ee1de9df2cb2c60080523e49c086fc313a40ff9714fbb5437ce728b35d6542e2b648bf12484477ccbf42984d3666894b3559e598cc4c1fdf9e6c9ada3dfb0e125810718a9a65ffd2872366c792d0d8d50fb8bf146f3ddfac68b609e75686b20788cc70068d6b2f18e5511771c2546c87d963897ae7fdab413ef4019bce62321f23df03829c0c70a58989c66cc78dc09dced2b3c3e23c94ad542cbaebc3f6b0f45f60d8c7d3f727da12f7a4919fb45a563127dc07f70be2d544b51cc67185f22ad37f5c79638c41206cda4cdaa07bb86728a61a07743ac1faefda37838d7292bf46fa4f0e7771fe6ef7a3f4d978dc83d018cf5a027fe0c296d527bd27f2a698749a5832a8bab6259ae82d6bfb5a80dde3f0796cdf914bfc5765ac288a0b9c6ff1d4477a36b25140acd8cab961adc02057788f5bc3993845769be8655ffd1c822866fc23d0ac7d679ae6bf29630f5c0034f6a961cbc9e8ea6d2f01afa6141b6ffee05b2a001084c5a79451c9ab028ffaecd89d8ba772b4243ef6ab61e5c66325bfea9fff63497873b8865462e70decef621c718e685ad792a961fc4d743db4aa2eacf81946b4836c543167880d8a7b1bfcb1a0ab766132c432dbc5f232ad60794cd585daa6b3e3dbdf572429ed075a7a2282ea9947d36282178e17c66673e4389dea5acb27571453ee8a1fc305bf49f1e86b2ac7ba0ad9492b75f6605ae80d49269573557a6ccbc6b47644e965e141f889123e0afb0bea76e8ef9de0da57212eb213ce067bb69fb8270379622095c8906653b2d201a79f24bc47a009e75db551b9da8d1ebc48c603c20fc8dd7521cf7b92c138984558cd3ccb50d3aaf7554031a9a6b37da4ebc157686a285863d3d3f7160ef7b5a7ad5a6b965ae70ff8683a713fec627e0895dc6030122a4da6e028806ab7e32c3403c084cc54ceb0b4f4a3e30f31aadcb9cc1af9a2381482282f124aa7bbbb76d5b4847f84c795eaa661486cd8ff2917e8a1a0da694cf9bcba574c0beedf9dfcb291f0c61e2fae9f61444f039dfc0d8b802fa9aeb301f8e01a43248b6c6bbae11dfc691b6ea752f938aff93dc098420c29bc89bc32fca7be861a8eb7c5a000cd60072da65d78c9cfcaa4a7cfaffd95f491c90bdd7931a6e18e6a9e680e61f32f01f27930d624d692ad3035d0753e705278ade5179702082cd276899370b2019cea8fa3354cfb9dc70c96b2fbd18350f2f0907dd63d184460786a56d40f9ca9ccc22edf067d00a7ad68d3ded7617b027386a371cf5a5330e5f92b5371e83ea4a09b40ce9b9d7acbed3e5f751a093af66ec2139fb7b5ce3c289e5d11247b3af0a20d1010acc03450aad688ade6e0ea28a5ebe7410a7dc9fe018475084513a4e1c695f63a467edfdcc00ea82762a01ca7b7491f07b08edb499964998b2c5ac371947a641fcb31c564f4601c727770ddb7398c8e9d501c14abc3f3734411659a4627502273ef70624f23e4b1b004905b4e0b2fc6daf49e277b9332630db023b7614ee6786dd98603cd847e930351ac04b3f914bdc05eb9685ffc95ebf3c25c4169d0819609f386c12552ac05ece12760995410f1ce2e661f792dc62ab29f89ee97f84dd5b8c6bd80d086c6ef5d82438efec586217452db9efc725a55dee61f4c87da4648e0e208e96789c46687e7766c8d53481f9efd6bbc49015d813c72c36b36aa17259173fb7cc0501a5d97cb01f8b155834c9fba55dd860e46803fd5d3876cd08b8e16dedb188dfcda7ed7df9cc340a672ea9fe571a88dbcae70abfa6ef4ca299be8f3ff43df2cee8c07f4e26348cf68d456892efa43c6260407231a03b358c854a2704ab3ceae3f9734c9a4d794a5ced5d7b94e53a1c464d0998a4511819db1ccd6754b73c3be9364c3ea99f4b983655945c0b5d813bee19784c2d338265dc5fd9a1cd59500ccd9d9c68b13ba40d63b2388d814d0ef838c4c46ae6ee2aec21ba456f39e42eae6f46fdcb3b4a27ad5f63f09bc83ff178981fd30e1d0442cb01b61f57263095d5eb3c177ee5da146efe55a3e9587b3c60aa2ef080e7fbd3aa6d44ffbc32ea6e20da84f5610f0336b0c0df11da37874acc094b2d777669c4009d8e18208c238a8e9c33f62735dd6d3bd89c74b03ae42a36cce777f457c137fa97f2a831e29e55849df67b0648751d8ff0de4c9cb0861b5ccc821858f4c0c434401ff75fb27dc0a8adabf380f721fa1478a70c665ce1f316d370b95f751cc77ac7eb5db3aef03b72da8a48620c57671d218a6eb2de5d8fc6c589fdb3b566b9023a86fc4e7b783b10ca5aa474d13fa20585959bfc7b796a9d4531b0a93ce7a4e3a8787b777b57362af6a12fc9e633e88a33126b214af4f9e79f680ba81ba6026ba00ae76d96fa89db9dcb23a520b4e22757b1ef6eb6afbec72b2b7137886d496faefe7db2d4e9a826862e757aaae9d81ad217a0f87cd45aca8ad7b370737f4f1e1b5bc638510ffa67a1658aff0ddd9853b7acf8148019454a0172d794a16795187930993ea7f61831db9d8b2929a761827114571fedf7b2a0081ece5e6f311ff9b90373080ff56f8277887acf3ed2cfb86de8cb3bd61730521f13a3a0db921e461c3366588f07827b42470fd31dd9e056e50ac1965ae21a4fcec36107e7827376f526118be1a94f7c9427e382a5cba75720a8d9148d626c362da7ba82871ffa41910fcfe2d401b76270688eaf8909097d318a0f9e25726db84864c489dca06c0a4196a94f452827c9d4c5609c40a4c203ffe6aaaba60a61b48ee1a34a430b9a3675c2da06161c8c9b5552f8ab06d07f5a94d0a37fff036491c4643212fd51855ec7c9df4d4c139ea5dce61ebce949ca8adff1b99e48f07aba30bfd709712a488d10ade923a4b167da5e23c35e58ddcb97c9aa27236b9302c9c83e41663d48f9b86cf868c44291d7af45bf164d5c8aa40cdcf83cadf83fa868f802a4db22ed95a34d01e188810efe145d427e485e2dda5ef2e5635ee99d1bb5d41465fc8bf2d2312266b0dac004b21b4862c07b18bb83783d2a4cf59fa789189177469cb865f5bf9b4883150a00d2ac47c6e7e6bd28b3e3130a6b16d7aadc8cf93fb8cac6f2107fcfad4293879c45b0e5fafee6c4afafa4cca4a9c6c9077be61093ac523fe549fe965b686d10b1cfda6e8b857fad6ed036e537c7babe9be3a1700dc8b3dde240a057c68e1862939dc839724e336f230847bfb8797c51ed652a9da684d4a516e16b8c72a2c68ce437ea7aae025f507ee42112de02f985bbd4d526eda07783e0afc25012900c4f6e5d3b363ea02cf84a3d5665c89768d18c15037485f3a6ce59f146d0d46d9807a7569d95811f8e673bf58f858ff5d58ab72fb0b8aa8eb46996d315f5130b30031aafa2ce807adf933a2ab76861485f0c5e74f643c241093185bb1bdaade72fb9d8d3d95f22e7e1661ff748094fc2bceb859a4ab089c108ed974a666fe2604e67d0044e48e49d1206f74e9a111e38e7156d22efb5e6e595e648467aa492e43aae332253cb631365a13d4a2db50f4f43cd35bfff4c230425b1aa38b7cf3c3a30a6a0b4c81f5eca25a82e408b77b7e5e16a1156cfd34e949cc12b0c93de378166552a7b290fe32c3960eacb4675ad066b933b526b49798f0774bff95cb024f78c9f69b49dc82672bf8c427ff30ad14921dbd9ee964db0436d259efd6b744f03a414cf9bf7f8391c6197821edc2a3fbddd98eb6460c89b383c9968fc7acb75a0597114c2f2a6836023134ac55a4141e77914a31bf42295eed9bb84e51dea6599c60279f339f8c244e1f546a46ba58d074618121b241e2fb4c602c7aea0613e6820579eaa25ab1a7aa519794fb32c794a80180eb8f4ba50fbd0ebb26927b33829da4220fbe3604f1437fb07632230b95b1914505ebf3a7de445fccbb5170e32282deae62b8f23a2731c01727c0bbfc6a241b2a6922e8509003c793e48c79007af3101b1a8191917d056c69de06dd82e884cbee69257d4d723e2e6fe6e306a67437a0e890a16fa91eb60140789842e794e607ec2ccd58254166e1ba90db01c2d19d57f254ab78fae24601cb45984153102ccc9da16b493ce414c7cb36cf7b0df38b306a13b8e46c7e6fc9512ac29bf344b4e94be412089c051b8ad28e58fba7def6d3e7a21f6682bfff2b0049c1dd8b59f66ebfff0b65820525825f62a6f1a84bacb5394e98d6adccdfb80fb246d4280c2afeb7332c82931a6115d7e4d7723fb92c7961ed5fa3ac79fee325cd5862de6e61e273ac27c6e2daf6fdf7414bd9d8c0a1607c7a99ec0eb2f2c8d7c2119892de99b8bcb73fbcc1552e373cde89f7f20a6f073f066f7704278b391cdfdd0ee3646a186115ff86f8946de7ec9f8a4b1dd4ebd1d8b9330c46c0e2bf7418dd0d59f28be21f2f96ba50a5e48a534098055716fc90387c522ecd3a694c2a48bf868c493263421559b839f81d1c97298d2a624f5a508708672e5280250c75d909bbb14eda85a8a33cfd80defb13a3a98f43b2f8494a700d8f9339c071e95820bbaad58397b5f37c863f6d273594be99c36de7f0bc6d9d15d03fa47c5f9bc73b86850f723f3618b4183d7d2de6e33dfc4c68f03230aa72aa828df0dd1f6dc20b041e10237fc2ca7693a67b9e65dbfdf06535ff977869b1b46f313e81fd65878984281979326508cdf8e604e82110217da1cde8130817bb7ea937a08b149f54c74261469102af76b530db770e1b97bb35ab987804e63f9e4c442ba7d85d11858024e3f433a47299eabfbc92f0fdda4f565b328a77e862049a3c94106eb02ac4d97c13f2fa4526c9741890abb6157f89605cb8788ec9a5cda5884cda30b2dba8e7ab28a6a0baba699db35ff7dbe71f8672d460e774f833bfa3e59c6ac61a24c1103f0e22638b57f95762ecf66c0c664d386d1a3eb31c1033a7d9d3c755a5df6318c79fbcbc6631e34b1c701947bbeda9661ef6ade8c95339745aaeb65e6323234098dbbbc96095e65b5f56943e2efea25ccf698454a274f286ac4d2eba3e936d366a12c1c7955c9c9fa1c88ca4f253c394c8cfb476e02a618937c170f03f396d965e8ce5e65dd9af5606cfff889da10db47e673bbf9207f289f3fb8ecda2521fa779b44f5aaa109a458435e1a61b0f022aef8e8044225c28fa281f8c7fa0a154796461f02c3b6c24de514318db8512d6e04f2318ca761d03cb88e152f6fc3cd6696eccf86eee6e61aa3c63ddb5f7e30d1d6eeb9cb1b7d911c0c2233fa4bd9fe4f97183c79b3d7fcddc3955e6b1f8d63d765b1817f4427f98deb3d5a49f2671c5f64be0d3305bec6046ea421277913435e29f001c71aa341b0877ee3caeaa53390d5bd45389f0f5691742612f41687ef11e89ea072a9c25989da59e1df69e75d739bacbd7fdd2a12c1a2f1bdbca386eb2be0b7799bfbf4f36becc8e10da4baeced61f06ecc418e071204d8bd5eef2d45aa1044f30d0e7ddf2c76590d34c8833f2c6379f7134413aa0e6d1901b8538cee6601ebc9a150bddb49aa9fdf8a523fc09c3646ed9f1648d75363cd474795cef3bda6cb97f59f6b13a7bd4f326dbae451b1799f374a69744439c840bc0b1d5e4fe5b841184ac85badd268a92dfceb802e6e62873f5db4aa4b6172b1066515d2bd08f680826e3e6a745cfe026ddf266bc40d0f7fdf21311dfef81e79fe036125b6e9e7b94918f73e6cca7b282d17f7adb5f16f51a1f120eea1507ab4d9cdae9cf44505308f97fd9a13a723972fab2b59a56c512b9eaa65b5fc23d2c359f9475e27f772724a24eda863c3f08ce65f3883e234f61996df41b733bc40d77089ce22da37f93f1f3b7b7655402a3afba4a9546d694ef67d64035014b8325923088cebbb1504f552e9013201cdc6e8fb056858b4aaef1cb56393451c1736a871e6c6438f9e2b92d3bd31a3c78889eb24c17460af2fceafefe8bc334b3e56c20a294aae2d3373025435729c88ec146ccc970ee3fcef067b6fb13ac6c486266eb5711923d87762fd766077654ef0733d16ef0f138342f8effbf17abcbff5c7a3eed25821ef59181c1c47039df5694edfcedf17cea36ca33f77e9838a24bc2a3005d0a2f3e086acd194b272e1924dbf38b265e8054a8e355d1d78bbbfb79961eab7968aba7a30ce03131097e57426ae86d43cd133881ecbe388b18e9cdbb39b6ad2ab2828a1e5cc1d57fe37eb16778b38ec2f77349360f9733f80310ebdb5344b09df176f14289bb908e20e6bc84da4557ff3737990602e8ce944c68863dfa8993bbb680019fce2846f83a7fc35b6cef8156a9f0fed577e0d5968155df3cdc96f73cb7824988556cfdff1f0df4e2a10d8dc4dfb5fc50503032575cd2ba0ba9ea4ccd8acfebe23a5d4028696be5b366ba47221410b39c80d86f1cbdaade8e314f3ce34e123a7d3228f62f315d10c44765bf18d603c2e9e838e5e1a803630ae913d4a9b64ddb19b0a18d476afbde011f5416c8080d92f81685190788ee33a9e15f5ce76ef717fef19cdb5697fe1a7ee1f6c1fa563979a9bdf159bb8a5993b032bd6355e83f29fe56a50e17146049521b1cce1b944e4ee3bf483ea0476f2fe5cd09a411a9df224fe571f18d255717e3aaf04528564ed574e748e96268e94fc3bc56d70a1f10f7277a177d8b67cce77f85a0201c2f03c4e308a662081733ec5d6d89c65f1d041ceb65bdeff0c61aaf7d43b5bf7976a2e12d1dfea8af7f3d6fb679c29880fbc959a61f057504628ef7aa8bf6617b5ff819d8ce2e5a32c075d369098f341c66852a384aad314dedf013f2674804f45dee6893af350e3451d9080ced048c622b7b1ec29528ba237e33ae4e60312e142729a3a2ccbc672e443efbdfc0647c3d47522c41e67b3868e2737901e0baa6477784bcaa1bab635ec5d80f1d648a110363f86013e497992dd084290d14d143d977de93bca34e06b5670d43cbc72f824b2394fa9c744e11738036403f18a33535d02beb28e33b5c1df9643ffab4f6caf0c5b686426104f55eff8bf8e37dc267cb4bc549aff544fa98e35462c0c83c7a23f46f00763a5b4a8a5e99570200f4fca60b9f7a6eff74f32b8029e7e0cd590b042d2a3e8beaa6325d36ea427f6da2a06f5729362cf0884e58ac4a4456f5ea34dd8c8712df0e7b5b9308f8b2c97f892151550c491fc37cd3571dbaca577d564fcecbcac35d9537befca951d586e040060bca0c11ab305edf7571d4ba0a7de816d29ff3a28a9f0e6095f265c566365150164bc3e18f9544d6d5b3765750b1ccd34eb0de3f349d122040e3cae0217088192222006c7f18f4ccfeb8696694095c4d193bb94e9e039055a098f6cdac174d55a94407af01733af2f05868570813e9a6847a4c431d1bbea5607c9d00f3d85c2d605e78c9d0c00f55e9e348bf4fe1fcda83d92955fd64fba10144bd9f2ffe0b214d0529c935c360058aed66827db686936ad7f21358dabd40d8f903b8fd510b4cdc59f667ef05cb59fe000c695b6a01e79c5ad1ecc393ee393d3a259af8ddc129cb7334493817f0f852cd6d04db8fee59d12a4de70e03f1be7f105b36673b9bd00fcdcc6f2b6aff9f0e171c6b1228b7010b34b8d47315306a909796c04a479ad83ddfa00c1f1cc8d5d223c2aa1a1c14c0b9df7f12e86303e0218e11f2a0cc6884cc70c4cd8cd5f37e1306758975d89f1c31483502bcd24433070c408838407e8ab808a213928948fbc0bf96d38e60ef3cdaf2c6060cf75c0fb04ba5f39e68a05850acefb9a5193bc8802197b514eb0fbc2d9ab6fb662c456edceaa5cc281989af54b1bfcaf10b0948837cc1ed975de09a2752bce35ce8deda7c5d4e668e6e57de701f978a5474b8901fa30319f5793a08392ab211702a4e2ad585f2a3b5b9ca293b36e448c093c97c0967994698e9b6fd81c65ff07eb50c574325a1cbe7a6b67730e94146cb7107526af29bfb9dd7a9e7d928eb9fc6f294ac44cc5eec9b653d961fd41b5b402829b8020f73c543f4bd0b3b9fbf25ec520a8c1480d58de40fdb4652af526dc0c6efc78bac3a04d6aa03a211f2f73f3e325d9596bfef9d10ec59bcaec673c3980f5e4d8a76429637f720bca8b71123b3379d7088edf494475542d1db9ae12e53c771c27ca392cc1d0119d338e52a9739707f8c696472d49a3e69f192469c9f3281e1f8ef50196d5eed2ddbdb40c9c3f5795f2c491d9242f0038a06068358c622494e32e1831bd954619f22482f476eb9015c2b7782937be37c4265fe50719e4b91b1568a3eadd5297266003ba3406078469d1cb8011b3ad4b4373752e5318f6653fbe64e344e56e1c4bfc7210aa1f81543ef94ae9d0654239f86658bc61ce715d0b50fa66b47ba187e52d39d57fa4b249eeadc7001962afc580162b5a685a3a73cc71f6a60daf71f9fb84bd94de0b70aa3df1f15250e08522ebb3117f8f3f25bf21cc7a94bb5923c0c1934e16a4d1e890d10e67b07f3f0c581ccb9381f68e24f4219817359528a95efb648d6fd851854c0f94b06150cb2474dc9e9cf8d0c1216292aac1a1c261f002cc14238225e5e9c7f5e271da5f6d2420a97bcb8803d19f1c0341833bb615dc0b6c32aabead6b9d70dc8a830b685a32f1989ae3e814f93309c1eceb1fc509b69ded12dbe2da73eb5b0ae1d548b5fae22e6b77782d1a797c78e570dc9e7e9ad5b27ccbce78d483c096e1dc149a4dfc6a6b80af5408cf768234d70c0020c5287f6be944571df54953363eda81872b9d8a4d447eb07784e29c6343043af4eb29a5f7ee13258162f207c6695173d97529c315dca3fe732143b5c43fe2b5f61590575b3c5276cd73016a84c9eb0697e5a4c21417a65ab88125fdca6be02804684d6c4fa2495cd5904820078c1886c729c008460fec780d9b0abc9e277deaf80e7f98d4c23d4013911dfafc6ec0996518d0e40b7a3510efa2e97547e4004c8908247e43951a172d0a83a97a312d2fbf1f1ea0d4e5ce65091de11278f264e5be1badc85abd0b7fa3fe960f6a425bfcf6d08e0c14a25a09e6a68bb1b9eb7c7dcd11f7680b879ef6c82df4c70bce5a9dc44160317c746df5ac7335186d49aa71e32ce06ce13497c5891476a453b90fdb52c8f552fd2c0c3dfc5771ebe240aa8196c02017d13229878931c8e95c139abe04718adaffd69dfa6682f817ac34ddecad3c5086f5c2c022784c87ecc780ddd008ec6081f19bed1ac4a251b9c07fc943060e53c0144669c7729958386957dd8deaf81e570b749113a9bffd0c820dc9c82cf099728b1c3534a6bf91d54c4188d6adc5368d874fb7a96bbc1a74cfa31d624449ec6a66f96f8952c2503527db96b6579b033c140b9bb7eb92ee366e4095f3999b402074a9d0899e43bd00f9cbd5887dd5278f782bca1f36e6a7ff9b7f6f6ec327ddadf6f478f09bb04522319c805d92e2b94c1f46e7529cefa80374faa2d7317dd96438f8493069ea34716d7918bf8b5b4175b463389f24f0dca0946d7a2d7306989e5bd912545fba3eb2dd609dd7e7c27530a2907a098e70a1aca45f8caf33f3a943fb9638198ad8a732ff0c6980a58c195127231772012e0ebb0343ea68f5a951ff2ff2c648043eb234051d5b370babbdfc7b37be2ffab16db2ff60f80711982c9a54cffa04438d55b86a46cf4f2cdb93cbfb0e7bb83ff1b7378c336333d69b3e187fa4d724dcf9329b0959df10b53c094b2b043278413d1c53f6341d157c1fff8781025cfebd61dc8f1c09fb01dfd9dcbe603be8c9c4a10c141cce93caf53a6217242c2f8e254938a886e5c5c262c8ed0c5d9d5c68f244703d75474961c148fb27e67b97d2cef75ea9eff0df7fef0b34db5277bfe500b785a11115e5eb32828a9293525d79dd895f104611087caae85ce59359210ccaa0a1955d13ebe28e5c9fb32a8d27134c6553f0c6f9d2d72ee0a997686fc1ba7fbd0f34e0c5a23abc74a11ee0ece5f48347f5c2dfd4ac0a48df356500a17fa5b2001dcc74cbcdc2d0b5f0ae97d0d61667014842e37225892e8b8edd0eb6b9b11cf0462e3f9fc9d4e5fe14071a2ceafa09f21063c59a17720cb5bacd84c8dbce435fd18373648193c02916f79cb1d25c3ec262240cd8cadb209f5fb93c994583f10b429b5138b1bfa6459cecf3f4b2abe8e87ab2bad03400fcaebbc240cc7d85d2e516ccc2d499074359197627bf76397c67c8640a9332a5d2a419d017c771fe360242942681b8151805b558106ce09b59e2783cd22e1ae88e661ea50c04e567f769eb538e246cc1009c5e8897145f99201134460114233a6ff87d185eb8469be79d271256918004e8c4136a766ea9d49466edc2c6928b05b93f636486ae636a01ddf83eb78d50f79b1bb0d020b0c3b76672ac6646abca2d82f569ed6c92cdd4024d6ce363dafef8fd0e6784e74987c0c2f44af7d1a89c229ff577072760acb0b0a2d5ac79d4fd23919f578f2fdf3f677187f1f01258d660127d567ee4699712a166ab4a24bc6e70add2131ffd0d14234211e0caec29b2e268afede34e09ff559fc85922cb79216bb2748a9c394fac6daea5b1898bac55aa68af3a34c9cec154278c288b3c9621b8fe7e223922bda63779e66d0b94da4f9bbf6a6b2683dbbfb0eb449c2b917c8a1b408515a567d43eae544e9867348ff4acb082d754a8854c9e4bb8efeaf046ef29e60e0fe488fc65b952051b9587c91f6fb38abaa26dd863a14c579f4ce31e1fc038fe3cb6c5e846946befd9dbedf8eaf046a931d0c78d0581bfebab4a35f51f8c5fa41d13a45c2da844b1b320825411416c18f841125eaa","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
