<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"011ce1e15737e73c83ea80e92b0b3047d647bd482dbf85c1fde575789fed22f7983fd48cc52fe7f8addc0bafbbf8e3bfab9d8fa9d7fd5f5910759f41dd6d62a2053e80899509625d28666a5281fc12096a830a42f50eb5abf4a4e531983e559ca1680eed5ab9d184adfaf34dd2eb87c652f972ec61f5cefaaf469e33e5df03bfc4e0007646bc637c2e565f6d49cc52c74eb54e07890e962cdcb5bc17c1e24d509492d28ab39a937becdadbe16d61eb0be1c914cbe163a1ea9746b83b25d0e4d39fc1b8f3ecf88af1a29968f91290e188291d3e2eeb405c04336ae640cd66c2d50e8953aebf986d8fd07e197bcdfb5a55e2eca6a27e150391ab9bbf259585ce06847a21bdcaff85796e751a0f8fada983f406de74db90f72d287f267b59b3137d2e2fc58e68e69fca5ff2da9f220511af93e53f999cd4f27af53c6c859ffac45f57638df8fcc2def90b5c29d9a52a855b5b89e985746e876270ee678aea6460ccdcca6bdc67057a31b476b68b36ed76d25fbeee847eff63040f82d87f36757c9864fca842c3d65c0d02aee466e39e0af19340d2c82cfe02ee21882e681e7955c455104ab18141200e5a29966bd945bd39a6d8f028f9d80b07962d8712050f65b112bdaad01a79361cfb24c971212e90ad4e0f718e9db0c531a1116a4797577a5ec8c58a4eba500df595f308fec6289a0338308d2d9230512979381142600e2a10daf87c4d68f354d54d1a40ec0e5b9ac092cb65fb6f706966b5cab7ca24a819b061c3b5ce6c47bb0739ac4414923edf6050cb42d046decf4b69064c900c3da8e80222a608a3f48ff6d2f4a7034ef57ce2a08ca0fd59dc3ed86f8f4db4bcb1200886c0185af87c767601dbc2b18c61fa453b4838034c12cbc0772f844e0f3b62e62a953dfc9112264363eb21aad775decf74fd0fd0af285e0b4627278dc77145582fbe9c5628659221f0eae8c11f668493f70f24157e196821b8361cf10d07760f53325ea46924e350a6bb90fbcea8845d6c6c1c2c27208da2605b8e96da3736fa4ec8e25a2fbf3103aefa0f3d68038056929aafa4e8365f39a30196e79a42afee0dcf4f7f5787c795b74515e462fbb970b927d2ed1c643ab60d3c530aba7e91e55e3a2da2cd236719ad400a58607027944274388c70d6b70b59f85fecf03ad919a07a5ca6c23a3412b42714467e8338844073fe170369472c5e2e5a159ef7fcbe563337dd7576f5b9c44d630b649b3d5827da412f26c4a98a6c583c08a730924eb737bfa3b14f9aa185a7538dd8a5643cf2362bb483c927b76610e415057753988cb95c37943455b4b640203758e8f27bcb7c7008668b1171b5e867586f727070797b01ce6a612e866772ad5f981816b7f0acafcb74c62939c10fab3df9cf9d9aa54f9420440f7e2522570b5c89c934e554b74068c73fe1902b956b750f5adc6f42e319920192c2e5d1b68cb838ad628d98f60b97b7b7d3b65ded1c98f75b1de68818df0f8e9ee6f67004d12667fe1b330e709baa9e3190ad76168dc8ad398525e1bced70d44fcae96c12462ce7e0e1704784da6d4148535d8bfd20c1bb05d33d01c4b2097c40884b1ab8a15bd9d2edead05f636203f07c82048ee7eac8ad581d8bb29ab5a3afeeccb7f5ef2937f193dbcad4b24ee33a0658985f21a20098a23d83e045d65365c2104aa9caeb30fc410e5a02299dd490856a28042c999851c3b05cc2a047cae391138def7504a21197530449cf9a98a2488ebc05b0b44fc68dbedd94f5f1437ce536b7c708cd8a6b1e08ed23fe4ca8d9e219f21099f00e75edfc18f76a26f6d57ed5b3ecca64a255e3de6385c10d1cbecf86aa10ffa621b0c47b61b7bca46b1d2f7319117962d570a985b67a493fdcac9a211e13af95a134b796f8600041dd2974afe886c328dcd6816462596af851549d6b8641a53b6deb628f11b9b142ce111a835b6e4a6b40f600d2428ede34636e997fe0acfb69b9538675abd65332b8db01d530f11e160887e398faf737d8e1e5784c29fdcbedfd24489f805f6324c727015c033506330649dfebb5c19363086e0ae5a7162e99eca51c6b520ed2f948daa714df54b58005e2fefb5359a05cca9b93a90e1a7115c2a193f4729f22edbb68f77ac3c1d927ca7834f5405de0ed93a55de5d6eed02794655d9e05c66de1c7ad17d11362eebb23b71028dc051d33a4a98c3c770175fb67a4e6bfd91f01cdfbb247a601b46e03d67d27af1eca1fcc6be9c2d40110e2c636cbbc37496cdb9abd02f979f9c854e92b33c22acc192b8ed67455ce8eded2fae2b5729c4ddca5f6cff3c96af2c7e2f25914addd66debea8ad34a2962a5f8a4b5aa7bc6cebebeb3606f7c708011e7a2c571ccbd7875aedf5eec3d07541a420211e5e4bbda6eb13e8bb087d67301e4780f804106a96e1fcbfe7199e9ba7bdae788270ecdb9ba9592fd6ba3d36e6437389f8d67c5538dd68b670aaa86258aaa5d33b5a86226d2d7edaa279135507dcd9afdcb4f36e262ffb0dd27223995faf23fb9dc4fac6607eca5e5e4c5ec50629059f98d05614a74672877abedbe1266f57c4825b539f3fd5eb3285df7d32cee33cfc4df3516731eeb195b46615b948d941ca26bd127f9fa07dce68578e8ee651e251f1a16471e91c341c5cd802aed48f9e8dc234a532c76959791b3983358ebc0caad7aa2051fd189d8261afaced12c0ef2a988aa2a73012beb5234815e7debbf0503303fe10184127bee10feed96fb3163de4682f728fff2af7956a4c06cb767e9ebf72d84d222c50a9fc40c7b23761d0395ba9516550692ede25f972faf149c01bd03ad83357a9bf185a6c9151835e0c0c68441d3fcca7593386ddd870a399f218a89420c6e9a6b1cb137748c169c0a12d0fbfaa746c68e063a79ee1086311619cd51f2275bc267d44cddbb2e9f78dd8a75c71a8d5c5aac39c2657a5388440ca43f9b3b593dda2fc160c35b1452344657cad64f5acf29bd3de4d4d3f21719746578f8fd45855fe41afe53bd48b2e7489a502816cf5be7d67e9a1a51816b63efa1fa778542c8857434ad736a76813919fcbf43fd5dc5c191179b7ed7696a387ef76dc1ad650beb4866035573792c534121a2620e829a2859ae848bdad1f09fef000a6fbd25a2a4a7a50d87f103d9dd2b431bc46846fdbe885e46bc9d9aa5f94233e47342295c0396c871b9a4ac69030eef772d625c34e870cf07f5609c1d2dd8fc5a471e38af84fd04b8420ee7d2b713eb11209117c9b6dbd54a1b61104dc5636ae002f14e6168b367d9bd83d27d091751096bd437a2349996f275716fcd89c437b6bdd79acdb668c2f7318402eb8502849033fc08abe53c960b100fe037f6a6caf3e1600d37336592bc8274bb46bfd8f949de6fbaad63ec2aab12929d865820765f8eb0bd8a457dcfdbcefe2d3ec8187a6804eaabbe6a5aa45167f1cee982c0dc48369cc9049ef47d08b99b9e0a1720d7f8e47defc23066d761f53a0a1e319c1ea2a0f9bd6487f504e954a98a13d0ba93eeda66b6fc0dfe99d4d9dc8e06b105d6ba478493ce3164034dc2d78778b563d9ed05804a0d6f49886e2ae75f16da8134a9b0289bc70fbce4d9609d0accee0b30931efc29cc4225b81c97402d5dbd5ceecda0f4ebc863538697193e8af3f5e3e771bf857ed373463b01684cc2b05d3500436b020f67565d6f21870b2d1a88525ba0dc17c7246484349bc9c403d6358358c4e9e2e2e09e0133325fac6bce4f7b48fa88b0feba24381b594c0d7a22a468eb01d4af7c895e27a5a16b98c02f37eab3b8edc750dac8fc0d9c99c953c51eeb0b7dafb67f56b771e04e397e8f5072f0a247c9bfdf85ca5bc7a213189c1624045de412d436abd0e3a908fd1b505b5db2b24c10981308e2a74211ece93c1455b561bf31105839cd9c525e17d17ba864bfb82aecd26db0f1d61c52b2362d2e6097d80959bdb2f70b17b6b28d1d58259c9714cfc8ab5ad9138e4a5378236af3eb9420c8a63e5ee8d16e79968404e26851721989382641fc73ea70c9f0058516aa62f1e9336d2a39310f11f000c8e35214f8d4397e543adb6acf3c2b6a824872a4c1ee066e890506f640bd116534c7f77221f9fa1bc917cb6629032842b1d7bd8f6e49a157a1a650dbc06de6aaffb5b5a1d207542280ea357b40fbab87138158c56b3f6c114e272e171ea7634b4f5b5f8571f7807e50697e1613849194706687409a1d842128b0728bc89d8c7b12e26dbcbe1a1f04c7bc87f619b419e984e6573173229704e75a326438feced7613003c045f71920d2262f0cb41d6f55c5fbbc2db9fd45a5ac143fe232573f02485dc27880461160ed11b6b009efdd025cc501206572f6e60bcc969ab4a141e1cbdc2ff8d9bcbfb0e81ca015055951592c673f026cfe7f420e09e7f5e24576373bcc25089aa3e5b397264b04defd0c736162953e8ede773ae741788b4a589055d2065cb1f2bc85f4e6d9a99715d05cc776273c55651c8c6c303ee3be580afa9eb82b54a129fd96c77e5e340659e82f569453f9b376532fecdcb54a7086394a93d7c74d84bbd594428476b3fda41ef2262e2ed1a419ec22d08afb837c20b9805e649443e7a807ee37f5909a2d04c2872b5ad3769f47f939e151bfc0697cef42570f749bab1c3ee2ea6dbeefb1ff115abe412391a9b4fe039111eded45db0ec0fae37b71723bccd83d68de80fbd2e2868207d6748c7d99736ccb62638ad8bf4371d9f4742f09cc6958bc5aa82763e822e3af2bfaff0ef17c2f3d9f41456cebcce8a887311578187fe095ef593c054d776aea4f91697d12e67c8c4ef8c5a1965a22f111e4aef0810d584a7a2ca98042710b4b028a634900f98f233125dbd801d23266f2a0309b14abae0d993e311fa7dfcd25589ea4438690bd571865a00e6b7d63d808a47d5a19e4e125bce2123538341d951e02e0d7ef6f0299c0bf964ba4201e0604e6586972646cfbcf4ab15932e8b68776bebf72146d9cfc16fd27b04c09d9a79c30f5d8902498c07358e7650e39815cd5e21d1edbab4347b3216940abb39993d1e4de206ae6c6bf0f2b311a10ad6f0f334665114bee7ba7ad6b93655a500eadeb7630383699002475b3953e10c964c3ac430add32e7b7bbe41fcb5e36fcd5f0fef1a4b3eb7268d599f7d19f18b41c9b9ec4586dae8d4d23a702d8fb6cc8469a647c90e710c03f27e6ba12eb24349f1c6927bd21a18e5e87feeca68efcfa38cea3e92b9f6ec3aca28310522ceae5299ec17397b41a152f0334fb99f65c6860ac36fdffcb06a367954d053e421ea435a4caa50265019c90d52d5b94700dca32b17600a2f5aa3f267937705fe34bfd40372c36f72f3a6760450bfb56b5cab423563c7650d1baf1910cd30dbfb5e22099197fe99b86397380887d4e7c27b774f18a8ab9aac455ba17ccb965b45f92dd525eaff928fef036dd453b7e4276b45e1c2c772e4e65341a56434d9c2a5814ada8b9b92f10cfe5b2991ecd9d7f1c698c18c04d14d8ac11c6d15752825d422be2a3b16821369cebfd1d31be21df8acb82264ecd60daf549013f1f7a259c7214928362d6422250d3656c97bee3e2849d8dd4cfb2302573f3dba51b99073d57ca19de874021ddccdbaaf4645d5bd84067ef7686c70d33bbff6aa950454b97d0b294d6ab66d22f4acf75565a5d680181bd9e59130809e7794afedf8fc00a9839e3d38eeddf7a7fbaa5d35335359d4f091ffc2bfef008328449dd6edd32d3944855f75d1d86419b30bf6bcf434ce9c41bdc222f724cb464f8976baf5c1182d22fefb47b4ba0c9b8efc903eb87c4d365a9b0bf817849cc035aa56509de930a677327511853b205e2e84330e333292f446bf62dd8a4bce0fc799b46be00a98fe12caca893355485098c9c2f0f0190660c850672432ae918a65e797548022fd4adc82bfb7e10c9d9e7bdc3d66e7e3eda1da48e087c91b714e6fba7506ce9a035c6aef17c41c5c4f6277408e4358ded38a7b36dedfa22c3e1337d9521720cd2ad95c94a357f2ec4cf55bf1a21c30768e8185558e3199ad42ab73107fec3e375d5378dd5521ef91386613666dbb88c640d50c595502745b36547317834b3456d014574f38a483d3909a697889c8c09941db77e25e963b02bda1d0d100f1a9331477ac052a3530dbe12df86684163663efb134b66f884c74e96baceb8ff0bc48fcabb26b63866febffa3334ba2f497d960a36440ee28f44916b399d138d65b9931ebda6ebc55fa6a6b90bfcc636c333fabdf4930958178a760518d7dee006bc700e7ccd146092fe566bbf0a0654879d0fa6039ee29104e6d919ba04b608553c407ab88a5c646572b514b229ce016f6947da0e0caf26ffdba2cb9de646e14f8f41561d5234de1eaa79bbc45d3601051e3ce47b344125ade6fbc59ac68b84de523f5bb367f4f3b59580c1829cbc885065eafa50973d9e6dc4e9023d4950b5d1d96777bd85229866ff7581de0e0d6ef8161e394cc38cfba5e3bd97904bf7391b58f6989f700d2e54a918dc7ed2f54edaa896dd1053783d75fb440f10a6d943f8369a776c1512ea4b90e8a0d699816d45b45f670ad7691bf0bd14edc3ec48df6252cd682678bc421edea808af43314a5bd09d2b26d9cb33f86ca11d9d9f4c3db0e51602aad0bc7d8f663dc4a4a87730209785d4f932ee015c98da7a1671116c62702c553c580d9942be56cf1f194b6c7dacf6ea6ae90f148f24b4d6623a6bd4030dade404e73bb324d08ff83cad5fa74a3254b2a6a16a655b92a41f6d249785a4cd1d7eb13e9a0b142940bfbc3fd77a48c6dba4cea7ded7bd60a7c6447b942a894cfa558f0051d43d1c2d0d60adc53cd01659c6c37f9d1ed2e5091f182c28417da15b22941b4ed8e1932045c5b767014822eedfad7b163333cd080db13a033d14930ccc81e88a37098ec6d677e64acb209e42510d599678d29ea8e8c327c884a125540afdb1dbe494bf03958989a675cabe6a1fb910101c279c745f1ca303f6103d9aa275f74238cf32d357e296d81c367dfa54b9cfb197f449a773b896820b6055a708b9e8ab1c1e08592715a3ad5db3188ff993e0dce6c8a271383e847912a1fa25e78945d799923717371ebfcbaee4162508ffb897d6de042495fb7a64148b8635b0b9c1b9e48e7bd1502c8a84bb98c4fde9d3adef0bd7bbe107113f8bac17382513851477e8e44820687a4ddd3441453c68272b5fc53921aea91198164a63944a490259b022c9eb8c97aec899bd436d979b610dc260bf11c4e6afb2d4fe76eb04350c15852c5cdcbf7a1e06791b88d4dd721ff6d763141724f2f79ad151e873c33284c1059a6e08053f51d0c84cc0ae27062a015c3bb5eaa02db63ed0cef8c1cdeaa6997f3c3af4f29acde066cfad840e0239384163723c879b45376e112091b61e31c0451f90af819fb7046b00577f93dd3c996944d2120f5831611e1d56d78344944989ca811c4ee9f59bab4c530292c24d0a542af6ab23283b74fac2478b4be81f7f9af092e5bc953b9b160a6119e1d595d1acb587a04abf881c6796be0e2da380db2ff1b078b04e06c309db877f0d54390027873cbef8ffc906f9d756296f9a5fa2a25e5d3671d57ccb6ebf86851bc26bb66a375dcf5589be54b661c650d453ef2c1010787814ce1d6a3b467caad4ccc31ca306c74c63319c85737ca417f7af1d872605d4bc0e4ebba27ac4b18f7bd395a685f88a276e2f50cf0fddad3daad7aab1427d416a04f9a2e08c29cf06ba10ad965f3f0cf2a189fdccaaa221b8defcde21d0e1f386b4a934b4cab29a6795e43173537d46968fbcbefbb3285924f38cffcfda482f5158966a286591de563c2332a1b3fa1d2d7d3a266a27164df34808eec262711acbee78ecfa43aab4ade2adefc0d150993d803eaae1b4ede07ea186e62f17d51263fd31091495571a9fd35243a750baceb003d49338c8845ba3b5daee77ebf6afd3fa5f81e92f2148eb9a3c389be0c66c524abc452ce009704a2ffd641a2f14854dc235a204eaefce023faee608dfb674b82ed3eaf5fc009f1159081214ce23921e77f6f3a1deda1c57d9b0f8d53a69c06ad630ef60b3886ad6efdeebdeabbdd385bcec32c7d07ae59df2bff53675f780c53f481f52cd702b225509a658d2327a3654d86ab12647fd43427319f09d48c069c07a51a1f24f88c5fa2dcb8e710b8b0daa2e7d20011b394f8f47de97a51abac19e2db1b8d6781a584221fce54e6e1643b1b241780dfd51e72f912ace8c20741151727b6b0f9de714d4761cdc89e68bf2ee22306968fc2751eeb792bde07e1e54b8745f20686ec62ada96f926a2977d8158df457983e5ae8dec5767616fb3ac829ded35254ca1afa9a6a10ecf5fd74c069783d525ba933863c1958e955c21984f3c48948228c38c20a7befbc26f2d9e0c3a536d9ab6fdec7a3031781665b7f5ae0cb6a4a1d7a8c7b2966160ad8f630259e15eadffc85bc542344b12f491d90a7a3c5b0e3d6219df2d5b4d1a9b716140cd10bde92ebfdb40ebfb4aec5949c961033f7194fdb99a9b3f17c72e0836c5c011a91b76a0cb98cca0a1f3697bb962474dab09c82afade5c6a91bf791f91cda4015c0db5abe5046d5782e142727c01850105d9576e531a29f05ee55c6968ecad16589241df54fd58cd758876a610e78acd5117a4cbaa1f374b8f68af12e2d492d36127caae80fdefd1944aaa4f5c33a665756de92659ce00a6a910ba1ec0137a5adc538c308c29cb58baa34ee1c69a3647eab993aaca6d933e8380b32792600b80ec613d8d09336065f87b06e0b8b0ad0042a4071c8d6d899584a768c218268742ec70f0abc0c49831e1487a31fb9d9c11884d0bede2c4f8e224e0e6a74b5649e3dd5d6896cea16952b47bb7b15ca22283db95bc03db7fdaeda6bc8182706d90c24b4c115f8cc837ed89da8310e8042dd213da45d1e2ea5ff5925b59d93ad255bcba763b12c042aeaba3c6d54f4fc7f2a45ce9628f6cb763ff0464e6037c28f0310cdfd37daf172674ece2bad5fe674146d841a17110b916a7344ca26220dd96fd7ecd1d6f133be13c9ed3b477c00015cc0da057d806d6837162082a02d47e212e62473ed73a8297c4fb992e8fa86e070078945fe21ee33f3f3b28014fa817629a40d061a2b4d7c1576ec52b17f78d6861e8fcfc48b1914e5c33fd2e3b3ccf2c4cee97cd9b099ceb460278c7a59bd6da02c7f41164b1c578762dee037325d0ec455592f9c8c25f49c4e6e541cc3b05dd27269057ec6f396c996676fd7a4f80e24fd1e6fbeefc0235d684ff412ec089bac7acfbaf78e707036fd18b3d7217995034674c16088c4b391ea79d531c25d0ed745491a9c9cb7845420cc59e6f4d41893917f919ce4f996dd6f1454efb970a1d8c8f6a5001d5205083bf54b8d6fad354e3f27001e2f96037102bbc2e7e6d73bf8b3c2bdc92f7dbec9270b1f7c8a5f3ceabf2efc6ea4dd02e56b7e079d7551b82452d1ca3031a4533bb503403140271c7fc9c85c3fddaf3c2bdd3a99f6362fe48a2d7a876b3f2c4ada9465973ad3bf581095071cc01048063dadfe22464a850efeaeca177967b7858901d1b5c3be75b06d9f5df19e063ceeba3732a4f8f08fd35f523d3c290b2384c40ee6841a27f1a1d2bcf3723151e765738d01fba88b9d9054c5d201aff7451e2a34a47581eeb7f7b8f17fd58e6c05274080e9fe63ff30991d513932e98fb9d50e42cc4208dd8dfc888e4da203a517c7a7202de475f26e6be4b28a821241c41a374d2c9c46eeac1d482bc6d79d89806d9c80496b08559770d9aa972e551074d345e3f9406981e1cdd03c56033f48e4fea7a3335ac02e7fcbe6fd76101e81bce6820fb03596ed9bb0d2b743912fde4e9bc0c838dbb3168a10079a42a536bfd2edc4e88c4735dc7f03cbf2b0f447ef3b79892a6ca6f1afeeedfed08b163978dcd4560dbc1cc999b5f1d2e896ef67c3613eb89ea83efd69c1d9d5f8208579766c6f0cd25f6584cb38f3c086371a1c2291b884d73cda22eb9530671baf679ecd8e73ce821a7a66e9fd2723e7cebc0812475bc74479eabaea01d877e33d28d7faac2c1567508c4809be96d4712d87a25ab92be12405ddac89322f94c9d33bbab8d90df5c4e75f87d91f30a5903634feea87e488a91649ca2de4260290383692aca26d4fe0aa6c75c30ef53433b06c74987ff9e294fba233e80eab90ba48407772a72d16f167ff1c8dcf38c3223e16b419ffab45a8d59df449ce16a5572c034001e5efe4fa2e36e8e38e957707dc62b343a8abcfe2370c402aa996c657d450cbe5711771ff213ff83c18dcf87855df60013e85c4f6b3b60d39c4f9e2c64dca10509a216b4045f250a8d3c701d1fee3933c24385e35a5488b2bb0ac8eb289d2012d3bb488220666048ccdf10fd7712c652911ebf5e393087bc04bd55e03503c751350985e277e7373f60161328cfc5c266b70100447e35d5041d2464999ac368d1d3dd5dbef9107fe411688d529ed2d48dee0efe402a5c8605ac3c611e343286048b8767670876f3a2830f344d5246ccf063b54a4858fe84137866bc3502b31e1280e042d9a7f1e2b556cb2f09488ee98e734d15f30c9b709920eb9ad1b30b6445f1f03ea1a677431976c9273429394ab63d11e819196acbb6c68685d79563ca591d94f33feae5a4ca186566329911eaa551635c8d5cb897bd325f8c924c7d2cd59961b332978d33941f9540e29323c71ba5285f7bc386bcffefe25df08c35e4766650989b87cc769b0b88a1f0da2aa4ba566245ae5b9e1bd50a770d38e6f7e8eda1e28edbc2c6dfc6e41cc46fd0ad8279b6c66e24a6fd53dec09aba57591d36f6f4090f438a8ddab75755ca09de84e1542467cec2415b493e0c4e56d0233c909e4d09eaf051a06b5f738542cc7fe5dd0ce4104ef479927ca8a0cf54b9600212efe33a26ab1c56246c7186ad1be4219b1d797b300ba0c8b2290f265abbb25c4ba5d352315a12f7c4771a84b9a2de77b2e715d64997ad4ba19d2ed0b3f37b8193d28daccc10d4369355f78db9ebda85c41683d29ac71473be3135389d96ebba9fd0ff82832cb2a8b92cf656d71c5030819977a777acd57f1b140f22da097fdc87e70f2bae83e46563d89afe45e7f7bc01dc00041f371707daac05d5e16e875595b93712d0c68b782cbb7047e4cc630e1609d4de74df9353812df24fd076c7caa6c347733dac9e7ad760bf4c096e0e18f2cbe1c712382cc31c20f1433fdf64ee47bee1d569bbd4c332653b1a21feb0c8397b146ee2a0f4456cac96108a666fb25da02df1d9173719b290443baed15ac3deda62eb1f1dd20ff861edade1723b5f694ce1c3bf6ad6d95389855c3b628e97d68dd0ee1c0787ba187fab64915ac818c4aba02c0378d4e2c21b80013017590a3fe17f12422558fbd01e68494e57002b44c312ec8a25106314f050e25a410cb31f6774ad70d1eb64cc67cff6e9862b6768d218e9d5f4934f5b9424c4d4bac5af871a3a4596cd8e2cf527183ca3214bd85e2302fb64407e3a695f56031c52d12f9d806126e448caed53acf726a3ec6852479efad48a5831adeda80cf601060f27721e0ec100a867e36d460b042ef382a868627d26fc3b06be1c0cd06fbd0a2d210f07055dd4eb2c11caf242a753169222f2d7218ac8af1f7b297f2b38ba9bb794984d0afa1ff7a6a02e0866133a77297872d20f6a4399833a47d97534a68ba935f6b80e1b46dd9ebe3c86a353674446d28766c1d9243dcf8a2eaaf05181f0bbe03da0767259023dca4dbe37721caed241da335f0a271df40ed96f926d4d8166fc178f329f4b55f6b7cd6bce6c76064f9d467d4b4d035336d92c33573f774587041734a0e040d05833a08663fb702b2d7ee9eca50d2373608ff43215533ff768577d7b2c24d5e3edcb12e405ca0c162cd13976957009a072fd767cd95cffa8a532780a2264c6bfa30d160c4b9060393fa140845730b330eda28c197fe7873c5f75dbad52cfd5fd36c339560df900157523c549f03efe39c223485bef8ea082c712334d872d2b8f7496190e47904cab9205e4b74bfc94865069a8add6bdf6de88fcb93873d88449db2844c0456cfad47bb9542fa83454fcad6102c7e60c97d60c353839bb5ae2eebb84ce3f3b210664fa0007fc7a2e8bbcb01113b0f659e333cb29f2e4c06418a9ff82e9a994860bd2d371aa9df47836596f9ca5f0f14b0557023512fd6b122a7537ad49c8882821aad218aac74fce19d23febf286568d00ccde29132bfdf3235fe6a7cb153cf2d82aed6e54de64d2a3f0fb2562750ea8cbd87a186f9a3aa7ec0b62170467bee423cca6f66479f3a1b8b75de4dd63c76a5816efbc1312c1f3d61f855eb4ad62f802caa50047a7f8a685c75cf4eb69de7ae9e71aa1555d27034b4fb63ecf2bbbd753ab2c0614789361a574c51c050ad43f6d4be6196c934bdfde939c8283429e9628c7a82476813ac1193f68bff19d35c5a2a609c155fd3a858b2251a3185f7a6fc165105e46ee83e1f7c14d4ee62ff2204dcfb7c1c5c7dfee46a3ede285be6d1c2baf477b87bc219571bfc4fa5e3270f3c9a59aed698c1bde101f5cb9c412b5de1021ea5e804fa1ed6fa8e78208f24902f530f771375a129d0c2508a8a62344d0ac1071b61ac4e3c907403d28a213db41654831732c12ee5fbf27c218c300ec263f4531b3514b46c420d518dfdf63eba62be7c40860e29de9ba75b7ee045a1de1aa758e6140678ef0d706f97c199335d17a86e86be0733f0ef18317d4c2533002d8f4af22b0c59010b6c197114beaba8bed0144974b3acb4cfdf08a123f146e65abd6ceb692cca389f3b0f789792fa100f80fa218326f221944155e22e1afe93548ed3923951454c1d38fee0de3711f289b9f7353974e3b547c60d5e8e1110e6f1322696d3a1084fb7dae1b61bb5b8ee69610e8acda317c375bc07d8c51a828db22da889c50bc93286d038fc71d4c83d8ab1a14f532e32ab97c073bb05bdbc2ec939bbe4807eb8eb6f15ebf957810f143f56a290e3281f673222b56ba1aecf713c30ee2eb9c9c282c1ebb026ec5247eb0dff7998f4bedb0f3b5d699f1c8c293010f0cc1474f81d425e67f0b2a95bbd5e7e004247546c48c17d52bc8b54e8ea1e0ec1077add77fea1b3fb5e99bebc27be611a85c45df690746b6cf318ec59a425568b7f8fdd5f758e40c8f45a523d7a53054b2464238ab4d18a4ace23b40183603da3c9c73795f8e2ef58574f44abeae98d6dbb679bada456dc3e7b364001b55bf1aad823daf7a4ab97d075a51002a6d6d60f4f670196eaee319cb30f25651b628278c7a86aa46d686c22ca2cf7bc28e9b007d030a08f0a057d07f9b5e23e8f0ad4cd3e8ebd30dad1e54ae92becce7bc967a70bb04c4baf2a4186bc2cfcb5e2f367b420b45e417d0f210210eeeb62d598a7b17ec21ef6626fadd18bae69db24e1b68d11db0422c3164f3db8313fcee88810e8b3132d2cfb8a883516db3b31df254b169f11c8f4b281c372ccc2fe5ec3ad9a8e3dcd33aba215cc6eeeab9ebd091fa8225154fbbb187ec1c11a79143d1c7925442d930e624485dad146642aa5b55c84fc76177fdf7d278fb051c13fa79c65039e63faf12d03861be0967e2d33290f218965943c310fab07602e128b3ced0095025ddfb9cf031cfc26bf65500df3172fe9cd31caca0ad666041973df7a608516e84aa8bf519694a3dff4f7af04b46aff395c609e1a30a26da4117c63e53543d7a006b15cb2fd13663d2efaf67f133613ebd5c035442944831bfdccbd5726ba05e9317b145b64e58df02a643536baf2456115046af10a4082d56c99113bd3b443c75b65d607ad730660320e666656306c348e56376c46694aadb1fc4dccdb58e3d7abcf47deb7aca8414bb9be7a17e5a4553ec55d3f71e6c24e7d3fb7c8759eeab1b5a2635d58c734416e89cc994bf3d29108a75257fef81720eb0b28578d691135c6ca363e15a74fbf7e8f102570c1ebb82cd9bad502057bb2b58fae5826a8b67248c47e45e9d94019c01c399ee5b3140eb3c2fc233678857b6cbbcfe8fda3d8ead5db273464df67b147ffe1a1b0715acc2f112c2c6de9b7c5c8f30e31ddbb20ec86f57812328e01877ab8cd63680fcf6967d961c30d63e8718e42b56424c0d322ad981f666d290fcad72f5d2669ba65ee94ffcd4b44059ff186a51a378d0dd5c7f30b17646fa54bdf662c97a0ac241c516855d8a13a85fe3e11ce2dda1df391391cef242bf536f9e196ddfead7486c4c470f965e27fd23fc77695e7982647663a139bb0c5717361980fe572b9f5737f1eb61697f5cdfba12bd6d350b652055ff5951f6c9d634212bbad6af59da9047b19ac55a1f07ce4ba764ff7c828ab1e5b367f695375acfdd730d8ae48465ff928adbc8781b203aaf95db13b62d39af8baa5f3f1b66fe263ca6f9bf0e8b5438076e33f36b136c1104c02ff5c4782db2f4b2c15b2db26de704f64a11c15a18797d0d28c00acf3232dd5d2bf5f9830de40528eb8b141a4f36cc14c138467a9471219f1f4e09cc241f99e880aa2889861c332a2ee7cdaacbaea9ffe43ca19e6e4b9be58fa32743115d58008f7c12ba4875f71beaa0eece4ff712a028dfe38d802d3159c23e1a865a0daac6ff0cb2a14617db837195700586355e7e41ab3d7d5f2edd3e98e3a15b999b2b2af02a37f6f68c07ac657d755a725a154f68cd4d043283613cb90933973e84ea2752d9e4afc2633bab441baf1be7b753abd82ecf2e0474b14b2d9eea7572d8e6a607f992c67a1f0043637944320ca07a5b125a11ab2ead3edc3a1dfc43374387437ad30bf98cf94b9d5ef744cf55bd059d7055d8040687e34fe890218bcbde97a0e2f32ed6c1c7882bb473223fd4fc3b92f141a731355672d90e4aa04e9d789c0d517c89c829030d4f9ac1c33ce07de1d272773f455a333426ea88837d3b8f08dfaa58e1360a406e6635984c3fa752f7ba677c3fb1c04d508d15bdfe67b008c81b4b2d708c9f87b3f6e150f421eecd51159d98a1b9be750d636d5e90ac599dade9b4620781f2a311586962f8569891acbca11c65e25393d6ecc5816168e00dfb240c9d03c190ff061e5766a437c8138711994b14c90ed57b71e336d1b674f512e25153a3ea3dbb2b4913981c6fc04799edce0bb9767e85952eee7e18f732b38875cbb41121ebc4332400f27f7793e46692faaa1492c57aa18026365a4d79b9e8ee70b21016740021d56dc4fb2e375de30c2c9eaecaba3bec284058b47fb0d9769258ec5f6317b888845d675c459dc249ceea5cbdb20b19aabfe3b22196dfc041df96ad2e00ac8e0e82038b9d0bfc803f970413fe994aefd7b2e7678a74afbb7021440f285c506cf302cce6e7471610eb81b9e9808c29d41e9357780504bf6624a30f412a6b6c697cbc36db6a2e273b8761deaf1da66a637426db74b7aa650d1686e1d630c427d6ee74b3caed326b433ae0f01d60946a1ab3a8de4aae77497d558051cf05b0b89ee80296c8e7729293ea7eb73c7f43ecce7d4db7691172b4f5e1011e29980c7f875debc5ea603097380abb27db7ab9d46ea71783fca88e173df42770e068ca0b1f30900089f7c5c7f091624be725d97f57ac2dabc9259cbff1f3a344810c2d4e253bc491189e8adec7befd43228cf0e4a66d44910766f26c40b7cb2a6a2537536a3e3f3ee85ee4f62f775c412305c20f3b42e19bc91a5a6e5aa0d5bc8ff77fb230025fa152d9a2cfcf8ff4c9cfe6df84fd1471f4ea64257f08890fc840111b25798bee234dd34695d5c3a967f43e8efde92847ded18f7e86e955004c8fae843d907b033680b963f2972c6b652eb1ac6b9ecb13bf0d08f5d2017f7a919b1d5597e9211a7926ff2dc4ca9f8ed7a23155f776a530fc7aeefbc097df988a89b96b75a47022988ceed530b56814f59475a127d3ecb0a99cc6e3e2ac94ff52538c32f978bd4c98c248d0fb1dfbb61cdd119bcc02af543160fd996eafd340b1b87666ab93f5cda9ba3677a444e1ad998fb1b97c2ce0c45ec645a7e8bf4c41a046bcf8d88b17dc71ad270f416f7b8cdbcca27fec5292eedf96a337e69cea820b39a6c32c6aadfb8dcf0421d34b5373cb602fbd3b493bbd8d236df9c8c862714aa7ff14fab0abfc3bc340be6e15579e6bce8c0bade253ad6ca66b50e322a99449aabf9afe560d288b8f71b04aa87512c415a14c9903d3867a28aaff5263a83016131e7a3c3c86e3e2b4fca7c04db70c5b304b0cb369e744262bbd7ce5c5d22506ab1241baccb36be90d5ddf4f19ea7f34fcac59d24ad197d048b6b900e2c657c6b69303aa0adbe1321779526f1228f431170dbc35ef0bc0b63d0ff6a25badfd7b416d63f6aab47853c3d4eb3e782b7a882e1a65b3ca662508531c71ad433f239ecc23092044c8e73d6c80fafbbc22800752dc01df81f66817f53d3a233ff4b11eea8e5538ccd34c544690154e90bc5184dcc2d83e07eb87d7b31d3b6f47900aec56c5de4bdbcb4e359a733802752ab94200db76a2c190bf4aa71ea08e3cd739ecbb4d6ef6f3e21e9daa424b998e35e829ee95f3f8c35296e92131246eb2dece935fcf682e43646ea3ce1d8ddb38a73430a0874d3730c0896058ef8ae1c5b7572cc7528681168ec701a66f8f0c70a871af8e26e38a3a76841c5541c608b8359249c51e57b2271549332dd3a74319743123f6d7e7fe5b110a8b738b41c886a76b92d94126ceb7cdecb631afd60094956449e08616ec30148fec9aab53e6d94398405aa3d9f72d47837f54a037d23dbb7f84fae3c11eea127d0987b1453fafbbd179bf9c29e9e1eb72218c91dd8a3f2e55655c1a5194a9fbfe309f85c701b804b884d5bce9b7bfd2f4c03689bf9aaa38b84549b421344c9d1538e86aba682bce6086f60def925453c4516814d00f17b0eca42bd6940f13d4dba4cab3e8a8cba683d118b5d4cefb7d7b8c5fefea5828d7ce9366edacc33c920f1732b87c68d143ae5536f9b80bf53f1d4f1a7b928ba07aadfbdd9e144f706be286e2bfd8a18857b9dbcfdb7230d17d0817b7add290a9420e234d63d676eecfa2b3072b20e7d49f667c52a60a362a553fb6fde319649db4e46aca2c8d68e9f833084bdb8b9f5b4b8042c626e580c3e36d09e10b0bdcb153f29fedc108a0f8236163c5aafccbfda3923b44f88e3251fad14deca597b3d3c59ec3686834e0d6fa886c8587cb548265870ddfb873c499b2ab48746ce9defee01c4d8e9d91356767ec6fdac4ef4038a6c103aafbb39f0bb64d4e665d417cb1d04ca54b5b7077166a8593a0ec7d767f34ecb38ff2ed98db36002a42934d8a8492d24547a1319482c8c709095a0642a7956bd4dc46b20e4fb0cfd53180520eacf810b127105ea9abbfccad8fec989f84fa634a875c9fa13dc891e54d290e256ddeba102a181978ae045ba60b405aafc8bd7841e17f39b7a46569ad7b3b792ed86b95fc604faa4df942cc2c4abc4198abc8bdd825bc48ab551156fea9cebbdc1815cf4a898dc2ac8d33629eba2e28c845dec7f6da60853f7ce3dea421b502eb64d39e600dc2c723d558a3a898347cd79583d40100694e43831fdfeda989b75284dc45ec4787073cf8b2ab843ef331325071fbea16d618a7059dec405f6f0dac2247c7b3854ddb4b35c815e58a8667c5fae84eb42bdb9df62d2c8ac53330bc4c266bc46b7abdf6cc182959f00611ed46b132fa255ff867d96c84f8c6585e1f46f22978123d678ad1de5e015f49053d30c57a2d785e3b7f7bc8408759c87ca1a1e962355d621faa13bf5fdb6259d7a2bc21d834568269e47211fe8e13324dfb8b0f9edeef479f351384b23eadddc491ff4dc1ede7d67424c1ab23811d31148c272dd183272090c80d9a29a28b301f80c27353a8ca76d73124d0ac7a700386edb58de1cee184151854874836daa4f76076453b0932987f7731c021aa7b85bb03278dd61bc9ba6dde1f648dadd96dde3f33e81d9d1731cfaae5b9da5f22a59aab290ba93213386b3e4940d6f3b6364e02a3e5557b335603eb15db8d61c2f489ae5a8f73ff50a02244c99a32cdb80383826c6af782b18296b3634889129220d5541e0ab355e825beffc7129b3f6f435ba8d7748869594c4b8effddf85fa4d2f5f61ff762b078aedef4fbcb20b984c918fa65716a36e8a16","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
