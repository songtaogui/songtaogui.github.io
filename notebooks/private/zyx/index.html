<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63476eca7f13ed9a0ecd932b7f40599e1752348fd3fa23ffae539311808eae3f89199fe03f0181dde8f3c813bf6b314f36e24217d94b8e03d76eb79a32ef4323105ec3370db42cf884755c2bc2d0aa585d276a223280f6e7d0540e9590d6594f79bf49bb8c9643ff65fc0a1160cccc396b8f24192f076a986b691357910a6c504f1b289abe572aa6fb43214c397d1e1b49d2d9ebe572cece34c173f984b22590cbd8c9b4a072528ae5d391de037962601d57fa3c38a11f222ff68b4f0c3f37b369dfdf6734d68b2702b311c1767280a02ba9054fbe793b373b46e745e591cf1b9d4be645a29a3e7c570f073fff4c544fe9cec47aa9c22ecbaf2e9db1bfc07bd1dee33dabe80e8bb89e318ba94cc3ae0037fe2354afbee4b1098008bb28b839dcf98015b5d034e21b1f73f3b3d83d141270deae2b1a857fece246fa7cb1bc00205ed0054ed636c52211b28c2dc06eae5db4d02182ccf0bd55058125c2fb60f213f322e32298135e6e26bfaae6bb77ea67c43abd8dbdd2f7f8def8e9cfc1a37fc123d11944dde70dc3387465d8e0b4ad87bd2c98b9c04a26af049103cbc2ef6caf67ac2c2578db2a75316aa7835277342a197e8da8a26102c757c910e7a6f9bdc2aa26839fda3f71de9dcb6906e798dc8c1ea66ff23de826534b169d6cce6372b19fe8a5de3f3a4ee6af03d6e81a7890613b8c2af3cdf220ca570b69bb77a0878e2624e47331608cc804f5a7d6e8c73cba924f8770f7ab511db7adb2e07c790478a0b88eb913bf22c149f269e34b4e505c9a06b2446dcff3162aa9314ea6bf44896c1a7b2964743b49e35f1c8ea4c22ac9b465c8101912fce02f4fc2dad5126cdddc926b2135323d601d444169395fcc94730a40478b4e910a30f5573d21a977169028654b80d462d4296d56435dc09dfceff78f8efdf1b5c6ab900c1cc72612cdfd6ee06d8d34822030410fd86727d6c7710e03452d5a384f7354aa574b983984772a1124c371461e32b0d1645577fef18b3ab25e6be3d060b81b9a95df4b7bc174a62a97ade7071928101a2ca858c86e95af1d16ee61a4456c23079531c39ac992fbe83ce1c97544fb737768ff59e233d781880169667ad6122d8251f7f0fb8c5d8e2f07eec83207d9c406c711ef2136c0fcc528509517d34f251c2eb4df3de06fa602394164eb84ef40b85c9b28dfe76bc6dbfbc91031c608eefb7a6ea2d0cd962c09935326a05ad0cd94cd6b0ab2bed6b5d2ab52f4d6b3e621cdc18e07167296ea26ce449626764bc48e68db7dc2d7960e802a0c02ab2cfeee2274f134befb1e786b6ec98fcd9a6d9ccfef2211473c631f59bc4d3949282cd232122a08e1f2afbe7a5d25fa2b65db4ca6574801f96799e4b9b605e8cfaf32361e043c0351173ca2828bbfa29936a851b9199894df0562330ca925c9353e35e479e77cd41dedd7af03a34c1f24a769869ed04048472928eb3a44320a8f0eefc53aeec23283b2d22526a8f06b5c1c9e67f546f2e191288634b0e2972f1ecdc0aa11fedad77002bc42a7d90622a6f162e8c0835b9997f27c5c1f0c9aa958dd6f2cbb2d60b451111ce072533c16623ed734db79a2c5ed32a4ceb5e266729e33aef71ff1d530d3821ab8786a28c0a4486335fc13840e61e848a03300e272bd5c3cdf717d6c474e1d6b00c21228faf00e41c0e7a5c79b6629c9813092d0a1b2cf827cb3123053d58aae0757b6117b65e9e463c7fcec5e67b18b5fe6d5a957bfdbcedb1f4235e2c109842c15468b5695e543a76bd1c11f37e7f03d6bfa61d41acc45815690ad671b12c4cd25308e57f794f74edc1b88275ee20c344556b9679f27bc63e07a70b7fd64c18d5f868d3ecd8523422d499ea89eeeb61e85e7b2c0e00c14020e0f3035e6ccf91b9148e5ce77ec3a8744ddcccfe4ea54ab76779eb07834fd578a1f83d60837603e9c72d5dcbb4dcfc0d6dd6f73ac7219f2a4f16673e5f7a628bfe177be267d6c96860daf92235ab6b750af4dbb5411104c72f8ced2fe734e5dc4bf386cda87cd016d77f37430f937ff4fe610c219bfb9f1f7b10cd72c77e42d49f230bf54be1177df425b5372dfd88bef3bfae8ed09a741bf8be0e99b0330d45399eb931f160b8fa9b967f4b2637234c4c5d6ad344bc1c9d5daf29c1d5b4578c469a1dc2ed7429895ea10e75e4ffd2930f394462091fe34c234193c375e8733614b668e69db0b70741a5d32a5188298d17228bd899bac2fce5e6ce0b6616a390c8e4f2a639b6c97373d8eb67acd6957fe81c770242c7958d9f9ee90f7fa63d9426f3874c783c38748b374d6153cbbfa69f032002f7b7aea07616524b45b4f231c05cd1acc8356d177eed046f7d577ab6208175eb494aa1ae5100da0cc22cab30a22c8fdffce8c9638275a9f9cc8de0e5c395d88eac918c2d912b291e72503148f8603a7b3097d235572755c04c35789839fd8be41ec86a4ab165abd54ad83ab487f4b7cff8c80d686e6a6c2a177b45bba96a2011cff0ad839aca8644763263dd4988b5f6b767b6a78b1917a81b148bb66ed370b5659b68e53ddb2e44cf5f87dcdbe5f25cc3ca39f2c41b0a835f80f9c2fb1f58fe24520d6130874566bfefd1ce1632b55b274b39dcf78a6c46c16b35340aa1e3dbc09a8b498ecfd82ddd1942c9c2cab09be9c7be5c77a003c61851fbddee1b8027e4c995552d2a25db059adc1206f84482a103f7ff9b6ce6478587e78c6bf7e3ec2cc4a01fa5aabb141caf25f3e32f0451aa4a715aa6329d2d5ff4241f71f62cb3ffaa4e5841e4b59762d183ed609fbc70ab64484aa92bcb3364465a493e6e6e9f31fff88e4debd9deafe884cd8b5a59f9d08df47080f76800e2b078b2f076ba32f7b74c6b6baafb77cb3be44cfecdb13c6ec5b7468992a8d0f3572f70ab84926c35260e21f27bf71a652a1c174f53abbb21b9c390e0047dbdcbda9fa08416180e628211b40dd0e43fee5c6bc7882688965a2651ae95db28472939428acf8a141783ab8d84366af7b88de6b99f07484e8a46669205449140e923b13b784edf105e5f1dbce24e1006eec159736f68a0862d9a21c84e1673a607b406071223de2fa61e866aa8020992a47c1e0a1ea1de539acf0c226b2aa9596359625acddb5ce762a84af33d106d67cd0c77cd524766c097f7df5d5f0d952f8071cbf339769c17238b3718fcccd92e5103ad791ddfe74ef8d43f8a79395ac9d7dcaa465397142917fcdb1b267f094b7bdb9ae6694d8d27d33cf58411272b9c45fe501d7283d04047290c9b675754d85b15b18d66ddbed2b6692eb86643a7836842385c07b8785b24a28e377dcb95efa0a700d6bc657adb5a2c619c2beb7659306684382e80c6eda4394c0e37f7a69428a2e44ca43df3722329d897ec3d3105c3d042457bd4530a14a3df695299ec3e60b461d65770a95cc032f4304adef09b840fd5c09f3992ec87f737b0dc6bc8dfd90532dba1c51c369a3c1d613ca847fef33d67f633c4698b8627d8098051091f204fd595ff6757ca9f1e5b3983a11ffe63aa4fa0704015f0294c13076154b316bc110e53d4175efd9a510c95edeee6e7029aeff7fcca84af4458cc18a64c70f743abb6fe826c97f21d8e6ee7626efe37e25cc9b628bae58802568ffcc6abdf6c3ecc97ffe7578dcff132d7ab31734069a999de368ede564b3eea0e6e17e7b8d11bf4a34bc74637e4de47b4e74fc2a4b45a0163bc2dfaa7aa56fdd575cce7ceaa3eae37d0f2ada48773696aa32006c4f9762f01cf149d8936c7992e9510668fd5dab7cbfe6f005513acaf7deb08db9d52b5eeb7d8a65d8fad9fca09e426ae47748ad01caefc66c5a58bfb529a6fce770bb965f13906e7222eef794cde4007e0624e5bc3e8ced644ec5e6f5515b5c09835358fc471613405c939d4af3ebeb9e643555fb3715f031f6f0c8ac80823d4fee6936b02f8f3074154269f3d54b66497acde82b8987936ad80418e4e7c46435ebe9799ea9540f3cb37d9c3e051301d101caf016cb00378496b40003cc1dd0dd3e4b65c85129062a39880f71dd2aab396bc9111497daf767c1407c6decc6dc0a58fafc23cf1f6c4546756c60a55bae8cdc888d20a2b3dc1c035e41f30ac1d0dae9aa755eca30b08d65a7b0586a2f0d57a533ff26b21e20c9d24833f288ea5ea7f57fd39efb68d9a22283a9fd37a24db62cf57d698174ec6f78ac6d49cbd2540d7fa9a8108459686bdc936365b1dd1911adf91de00f3da564772ff36a5d3a8f9e65951dd75e6521ef6fdc9acce2cd7e7531a819a5542f63fcc1cbd2ea3c753fd5fd353401d09de5e75eac7665b0788c2f06616261e298e4dd47a1fc4561e3b877fcc3c6945b446f7043bb859e0e260ff53e44a0d723103c6801b578c240fb812e94834281ec5ce394c7b7a3a0500dd8836d9aae877f68e7ea53f635291eff71fc612f846d1f898a1b76ea0e515627bd18c6d79cb72435b416fdb40f943bc4edfc4e9aa5a81882d079e53ecd131859b9cc0211dcf381a302e10abd19b563ec990655f1659a3a0f97089245813a3561c51fe5d90f8067779bd7ba4ef41742b5e5e89a3829b60710f75644c4b0860281e3cc3ebc3a525b802f79687d4ef98549abaaa1acc2182d16a1d460e6a36911685d249dcc40eb8b138f526992449b3d27315d4b6a4abc2255382e5b962b6c428836a80f46af82eb919ade6f136037b04aae89a8839366a4c6442bc9cdcf111e3e5387b0ef9e35599930da23255d5fcd5face2deb30b1e81607f2a1fcb15e1c95b35fc54121b22e2f8b7403491e56bf6c7900ada9e32b2605fe3fef1662b0682b0d8bdd067ef2445177e4225bc5e4053f3163575e897508ab23becdaf39ebb75ab47e9dc06519976a99067903e4240ea41d32ee1f905eff57a98f12b69583ee27c38c3c8b356849de4adb7f3145ed1ef1bf0ab712dcbe00ce3d17e13b387c855b63a5b0f26ad462716c3611c601a8d8f7798a6a3211f43acc6c719c9b4afd998c65f6988ca4db5a0195f2b502646ad91afb90096775f53ca983ba924443e55fb75a36eff583cceb46491f6a8195c9af0f335657aaad6dab26689df6cf0eca6af3071d17a98647665ea5630552f526a38b8505589a3b17a996029d5def5a504d83ae2b73fafde91ee8360466d3f8038523523d2784e7417daa027b33b0891425e7aab3b99978c892a274d51c0c176e2828b8273bbaa1081b9763dc7574a7c6f6b1aef175bc141108dcd208f39b5fe9bc923df36a42994d54bf9920daa6d9e4570e9c93bc22b34beee3b2f9701c9a606339c12621e203cbabe999e4e14e552b8ea791905105c4222592086441ed6a9072d033560b84cb3a32b682e4ffe8904ddf1b8e0606758d3e02fb06d90f03edc5aedc2e5afa18fd8890c7797683ef7fd16d754df9cae8b0fc08451f4aa522cf2867affd8f97136d165b08267d9fd4a8dc75f739e001b627899e62c5c1f7434543a8aa3ac23fd9c122d10010151cf56183c5ec92b588a9992f60709d12997cc5f80a71a7c27c67152fdf48bd6160ee1a50d833ed564d527ecda2209ea0c95629c45495aae30cd3dd8bb256a31535d569b92e0406cb583b4c932c3fd2643143b5f4cea9319ce20f709910afeb4527ba297858443c6de309dc44ba77a8cba067f2e27647e98d84258af193064bfa7fa05c6402335c6a84767660a1780ad8b647aa138002136ff6c37263d3d9e9f3c2ca2e43d4b1ea7ee35b064e954208025d47fa43916041b2a6b85eba52c1dd1cfce73a814f54ad144b016609763a861c388bbaf7412f35a61d5937122a0dccf3c8807b8341513d6476c5dc52c535aa54dcc63c18155d867a957993b1a44660baaf26355fe2e60a303ec56472259c2b2268784e820099f48e8305eb15eff0236a655b31bbbf356f6bcd78e6e01eb878cd62d844c73f187bc836cae2cfb800b37d83b074bdb5731860ae231e8f6a50876035a48adf285a5cc20c8f35689bda5f456a896f6ac4bd44b4935f15c721abe92c98bc160546dc1f0643f7688b4ab44f999386496f41a36712abe6d7946c2230475b4a02935905452fd365a28e0eb872d74916422f4658b126c2f159be554ca8dd9d5db736c3b17e4dbfc074dc7cbc20259c28506a642aa2071afb313134dafc15d6470b6c6c735843393de9f9df929ce1c570b2c7979478f702087021e54af5d2fa9f27ed14840931c333d76e66b79ce38e9843a93c5d8ba107eaaa1dad139fb89e2dbd288ee8ff8e796d0ede42267c2c853028901e772f38bb508c213b1b28707fb1f5df80a42722e8028a88d4ea6234a2e6af96b7fd1e71005559e45df716c23a94fba5c908f7900e9045c3b32490495117d671ad8deeb9a60eeb5d130fb1aca2d655970a8dc0043d70d517695e16cc265e922cf2b87564af88e3499a51dad3fc967bb930619276b57042bfcd09bb22683e631b44288e562fe18cac120ecc5a9defec1681469cbb1bb8e3e097865a5a6e5d6fb415ea81e3bdcc5227c32e0113b3f9afa0acd5126039e314cdb793dfa66d12c0648101e33381ae0300a850b96ac946f7ba23bdebeb44ebb1205400037d1628948e4ce6c643bf47990668a38e2971112dd24df269224dfa9941cb3916dca82bdfd2bb2e8379e2a250a6daa40afc88de92018a3fbbca45f4f990d02ddc6aca11379cccacc130f78ef3f75a73fce388187512d5bf036d9afbe11336e63f1913b23f32ad63b86076fee1f058cc465ff57edd4b721be43883e83b79d5d1c0e900564a8be1eb95706baba320994012e79a0e2c594712235b96479f297822ed102ede27ee56885a881236629ffb31548986acefc2f28be83c102754dfe13574924bfaaf949f5b1f3a712a65e79b6543011a5e79dddef662a86feb7a3c6277074acc801c1f4e291de7cf45e8e23ada344183119516199b2c298facae4f416060b07a25e9fb3f10875bc26c8fcc58ac5f7b8fa1c4cc00f09800691289881c97a6143151319df4e9ae8dafb91b89db0d8d04792d52e29985105460dfbb553722ee3bc27130e456c18dbcdaaf9ced209ea7729942f77724a27b390d9d163cb73570958c57ca6d6f946e1f4bfe6b6f086fc04344e9e2f6d0ed8afdd18f0f4aa5daca8765a056f05416021db976f51959c23ef7c17e5942247be65738868f7c4bdb24658b70059de7fe8668e69c6fa5ede7126ffd069201bb1e10ef6dde8577b3397662a14aa1a3bbee3e1374c14740acf94250fbcbf5a6626dbd981e897e7c95b594871d9f03cafc4972bc2ffbd9e873e95c525eda8f9c648300b78d3e06cc9e363397d4e9fe9bdf903e3c9cfa806e90f58f5c808f29b17057144b163cd1d6833697008fecab4b2f5d4c4126313ba8faa4fd8a5fc75d3f08e382017fe4f8ab98229ba7c13a5bbc997c5ac642eac4ae5bb0d91392daa32b0b96bb2b2c293336fb43c0d94d8fd7b26d61c8597eccd859f18ecc3ba2b01d4f14ff98567d263a1b3958c0f022b6856af4fde2a3b2a4983f04521e572d36fdbed3baef37cf5c783ac2e260e65caed9c698ffea1b3ae35f341145fdf544f82c827f26176feb6279ccff21c6a40e518cfa5fa176b7d40f9b455488452bb1adf71a30dc41d57ea30e0e19f635bb43d8dd3815322f0bf68527cf002b9b7618a073b1fb658335ca108b65d6b7ecd80001cf746458df9cdd5a141aa9ba4dbce07fbab5ca1c41ef356240ad363525aea0eac2bbead4c47e32ed3148889af3c85b2d2d19057772d8f365763f55961d57136a8f3102f383ced2e8fe0f8463a3863f911d2514c96aa5e85554b88405135e0273bb6ef8c99185794a1c3ab9c636a1a926e524b2380add38102306ae83540acad1563890b2635d004db4b45469475d0dc418cf2bf7db902c157045930fef765e2f73cb8fa24e8861e443bcab0af751a2e7778fb6ec9a9e17f3c57395b2de2e0512d03ae9114f229108654c1218117f8a4ce8e365226fd169740013db002ca16237ed5bf07be3260c7d906030d2e07ceee36f529db16c2609f61a6a147303a16ee532388197c5bc0d605d26a0d5bc2ad11f8aed2cd9dbeb980e79a3a54128b0c5cce94d444b71843b1c616dcd3cfb4e51a8f2e0d8c4cc0cdabaa50b408e6d5ff0fdc49452e6efe38e0c6271dbd02928d3f1aedeacde8425c0d102e89ff588716f19a7a6fc0114734061c43c94411d2448cc8257f99f3b314af680f66abca32c24bff59955423385c00112fb69f218debcdef206c7c7ec48d3e880d9eac14a85508974dfb3d155b52258dbc5ac26d6cf2525d1e6b4ca35cd79b4c41cb8b5f1c13dcbb4cf934285f9a5c269689eceb89524c0c85cf0db6cd50c941854aa60485d1c9699583d47cc984735b12d01225255f35995602e9caf5512affcad2281c1ad22fe43347754875b793287c2c8a7900a3ac8d1d604f4328fd4947a777d8c4b1a5d7cdc6b911bf8e798c5b7acdbe87bd5e180b0d860ee311ce0e364f11c6daae818526d9cd1d1d86cc868e825fcc24f219b093db1d62b682dc12c67e065b1102420a93793ed25f31c430c260779e47a3380aec2bcce0a04aee636d278cb864f22a3942437af2e0b4166e79cd2aea3815cd18f8eb09fdf7b9cdaaccb99800ecc0c1b9cca8e50e9f5165485ee170e122ba168d5a70c0a6bc69eb8fdb8dd594b6c1f5130df5018eddd03257797a3a79399db47b2edcbea3164b91bc766ac5fe45af44f11340f6d20138264d0f40acb7a7a55b1368116de8d10bf6d98f8452a2a496790c999a8cd5d203356ec769f92e4f6758c0b2f2dde40f0501ecab46680c2dd5fcf5e4a39b3938b7391f4b48b909529d0a70b946d6507add610979c82a17f1c9d92ef24118b7ca2a7c9b3c853248b442a047a1d854483e9fd8b833c6407c29c86549344dc96a415831934f1938a24d6e3174534cbd7fcb695c24058842491dfc06990d9e0b0c4bd03bcfdb0f683159966fbafb164ae4064d2fc935c4ecb3f12493cd111dbc8bb13db54ddda373eddd99a29b064615bcb8cdf7733bfbe10763adfb2817c2dad8d86c12d4b05eebc791b4d30bfd7391ebd1ab1421fa9c644359d96f63b6f5dde2316d469d13f88513fd4976d9f190352ca9c8d26b791ad8110d96e7a26eab74f1c5e4ec782f865134fdd962f5270fedbf5999378fabc68e17321c523c1e519f556ad1a70bef21d2ab037fd4be5e8512d64e08ce2da2b30fe588d571db565b22001d6a171d33dfda0c6a8c0bb604797afdc6abbeb6ff77faab2d3620e522297ec99abeb56d75e2e1662bb460eed6d04759fb86c66164cf9faba62b73de24624c1dd22a0833d9a24a94d766aaea5a75513fbcdc4f4daabbf1605cfe668f83580e1d7012f2398119f5756d6c336fb680e76f692f69a67ebe5b068b4ccbab89b30e129db4c5d26938aa4be8872bfc0dc7b6f8f0d6594176ff3b9e511daedeb7c9618fe8eadb85c91c8353f381ac45f3beb95ee45885c74f9c0ffe2fbad21693b96447e13520b09ca6c46818d538483fe1ecd98b26d74b66648d0fe5ecf7ec501672b7a51a2cd518fdd259793fef16e80dc16b23a10639ada3d7454db0c9ce3aebd8eb75183f610dea0f7da41ab7af7d495c811c56c26996890120b998f797c15ce64ad636b151b7d4414f74e42c24c4993c7ec74365589b255097ff008630c18b97fc5ce1fe3d0621152a356abb8bd125e5cea1769a1fcadf33c885303455eb9b39f11de30c10eb92007cf6d0f1bac356fb991fe30c55d8f2448e3564673ada69aac6218495581bf8eb62b3e997fa9c14346baba78f23354bc658d0cb30b6933cd995e8e5ed573114b55177ceaa175dc983c09d93ded5f38c20260d87ac30ff9e4b6f09a5041832a3177b4f20e915b4f1fd48211a9f96774ce30851cc8dba299dd4b5e5e56a42910e39003bc32c760eba7e0db2fe5cbdd5776532e85f3e372b14580f5734207316ac129db7a6fae60428bd84668ff1500e7f58e4559f8d06d149a15619b1c49d674eefa13298a5177f8cc07f7cb7ea8155804e2be8a53574c1d9990098c9aa167634a2e5e0654b7d4384eb7d48178eb3b94b06f4619e713e1e1e46fec8e28472fd9dcfb5f35acd8641253fd8aa85ea1e582d22216a04d44bdc9efd2a496e873b543eb65690d3c881b8e23c8bb951bec5270bf4016450b0f03cf6e915f5966d53c3330e07ade64dd4230a15cef836cbd984e932e9b55f9f36403ae39ef0a9045d804026cf6af0e61eedfc3280834546ccd62759003ab6f7124c5ba72fdf1c223b56f333aa0d9cfa9f512f739218411a3a7ec837d0dfaaad70a751d774cc1c95ffc2db87f7539dc095e5e6da490947cef323cdf7e8c5916560eb12173b7c2ac2ed470deecae20fff3496268e90127b84ad86b74143aaac1a33df0430ac77443c721657ff7025900ac5d37fac3704e74c853a0aa664fb1c353fa5cb9f69f34248477174c75cd9d74d7079cda8076c858ba36f32b9acdbf11f9e320be961a68abbe3ab54dc96a47a48273c9dd84256cc240b85cbec15729b67b3848002a972af8ef16444bc3765660990274edd9ac1b753da19dafe0ea32d622ab30f7405878e831945002f2260b4fe3a7fed24d6d1dfd9d6bf68e9888d5dc34cea93b9dd3dfde14a231c1b2638b9447abb48849c0437a9b15f5beaccc9b6afc500a42abf59656efb183b6d5b3738fcf7f1918b0739a2df3268c98d8cea0d879f7e03c19ef16002f6509e84f9f8a005997a01124a696bff6e212c661ba030b529d9d574c190dac6379328bca95b59f9ebcacf03d703312e7048ae47a4cbb7de96c65b994b61e1d415f0e4b92aa46acf2c476dd2d413b7d9aa17459b79f69cd798e4a3018aa0290f42a4a652280ab637bde573076e731325d779ffb2bc0a958e5ae9e94f9a57212a3fa28d2ef9194f515f89978ee90d5731cca4c2563f29a4f2ede645a67dd876c6cc857d50e80d4d12b132b6d1f5c55e4bbf3b41137e330d7a134438cfe6b0f76713c291ee44f7039a9b447cdd95d43d65155f4ee33eb47bb67ef2a0174c4e40e968b98e65c5fb94e5b4c43520cf1a4f2787589a6b2a3173d7bf30afb9bb8c79dc954e4fc61dcecafa730e3e198529c7603e9e298c5cd0fb376f82269a2c8eaf2bf256fe7657715c940760c44313a4a7e25fcda2724a8c5b15ad0ad1ac7619681189fc698d21254e4c61ef7139b3cb7e0335822f012294ceab9c326fdde8063b35319571ca31f4b3e8ad720b1faa61064fc810a29442df9d0e461b6fa833b44f11e5a610afd7ba6edd842df2d95237c688197e3e007b2da9e05eb7f32a4136eb39475cb37d66331db936f1b92eace864b4c9ff8d5569d4e07617b6d843b33a7784e85880dec4dfb160c7fb921b74ea6a3db7f3d055f691383e6b20997a6ef16cb4cbf63dd337242a6060ae0f9b2340c83b41feda00ad1915614f0840c4451df09a45d9349b3486a5e5f3f2081d2c24c0a4e8a199e8539e73a40638abe844a09370b5e13d5d3e0632fdb688d7af8b7832cd6fd042ca2fce9d5a4a9c60d997d2c97f27117631d1b748c823b41d80c739132a332762190d84f3e3049b489dbdbbefe3f6e4bd86ca8610863179f06e2aa92f2898ab7641e0c900a98d400eee334452714f71a9eac6b44d9d2a42ccb446e569f24d1e860cf2d8e05b3c78523460d7298896e3b414d154cc47868f8f5a17d1924fbca226d08b10ac8faf66a31a82a56305d9f0db88835b0f93307e422834035a52a872b553dd529652d9c24fd713bb08f3cc101d7ac1f44e3445e7d76977d66f79320044cd04f61b1daf680f80a55e8c4224029e9ce60b7ae4d629e7edabe8ae7490858a5cad6a2d867caa8342035b7f1d14b17866c2953316c2a73f98de4d387198d42039eaa015f285199d657c10ffaee370925d247f55b7efe78291f8021684dad63253897167fe635f0c4f5b1e03af97b0397864e3f2267e9ec08846c5b54f6a21a8481db66cba934db36fc2205151c0e6ddcb6f65658a507e607332968223e0665c213743489e78220908c41b238a04d87d1f8e53b583ac0a5c88d5b8789a391514ad8812a8e112ec05d070c86d4ca1f6af4a48714eebe8e5bec30a351e4011340775eca5feb900ec19e60a115b7065188a0b731c05ed12a6c43c455ff0210abd2dd415081065d3cd766c5a9529c5c7644f10d708b17310d99cc7b221b4913b968b97205ff3fcfa1fb9a60a3a8ac3b4116727580ab48e7446bf836354d2064be5945722dc29108c837e223b51c3c28e0d8c7bad416f2aeec1f7ab73e38769414c05c9cb1c5a24eeb4dc8addb4b05dc3097b8506f0814ef41aeee724591fa453ec84c9f00ac62457de0268fb0f9e67b9aa6ebaf39b3d069e07ce7f03a82a384012aedc061e71a689f484ab01932aab83805fe80dbf475c2dc7fde2f718e54c72bdfd2af3a843087d83bd9256ca77a4657c76bb377eb70347bda33435f2d77d2853c4e0b93d238ddf629af41ec672120f09945b1b1e700f693c4e78944ae20b68c8ed35284679c26f5c17bbee24f70785f05df81299fac620f1881243a48d31f4e252a6abab2ef4596b19bc2451f0866004c5ae5428c565a272c2747e16e3430b9aefbfd587fc72ab93d2c85bfeb635fc9c49928a00e206821a9ad5f0193f4658303b1688ee83b48f5fbee4aa446b82f24c8a3b245e375d55a3b31f01cf2b0bf4d6b91d56a657a1df29c01e1a414d95876b7c9de95e9fb30d022e8035a7811c5c4f0e90da1ea535874c0ac92f938d716f89e668084fb41ccfba0b9e0af1a020a041970a2b2514cc47e42b345cb29a08716189371e8c09fc386d5769b503a0ff3ff2751163ae7405fc8eeb164ea0e97b9c7dc9b788cc5eb67c0d8f86c101774ebcb0cf7f2a734d09bc9825e989c4e60f45b1f17a8265d700b187934265898f7bfb10490f455ec2699dde046db9bc51767e19fafb51bb703a1c17a46771356d39b302be51d79cc9b29674b6d46cc0d6df658a19ac3f9a42d6d86f4648a92caa2f5335e99837fe4669e416c6d139d29b714664cbf097d8464fbd88a2cb543efcd6bed3ddac3e34d07d539339fdd6e6e61a6b29cee3f4cf4425f5c57388ca82063843dcc9834a6a83d0544301ded423b75543bce75dd92dabb57b0c786e335b62348f19a589d985cadba9617e5758122585695204ec6930b443ce40d3257a2e87bc6a36b13241d29c55895328fc934f46f92c371a5a032b241c5df25384958fbecf9184905da8c4fa506aa595f85b3157fab82989d6cb363d9ecbfb91410e6023105d238ef2ec3038d356809f2a161bfc622d68880f7ed6b670e886277f8d1bf320a3fd26d75c80e652be117d2fb017e2b536009c54f9d325053bedcc80d0fb3d648865207cae077e654900caf783db744c88124fc4724c37f69cf0041bafb479362b7dca67b71312d2afbe40ded7f123b8281edefd7a45dfd2f4e795c17fa25a4564fe5cdd08cabc95c0ebf1d5a0db995b5a9e7860efa40d13e63bd77976a3de44de0c66e9a8cc0a2079bbf33742e5148ea15df597ea134e0edf71ee331d8e0ef6f1fd76198ff8e2a3a7e1a64d27342daf570ff67cc41100662d9c8072b8f851e8078aadb4ea0a2a49f84c421329c2260501bd639e1b6a974acc048e3bbae9a07baf3614450ef3c748477b463302ca0ac5775fa5b3e1317d2e2081b41334143845f4208b855c780fcc4730ba2d1499f861d00a800d2bef5a06937dacd3198d60c5bc072988828b21d69ac1d9f7e458021e3ede0630a5d2f792ff4d15ec1ee54e19222c8b0ccf5acba291a8768615b099ac2f91a3970ce4c3d4be3dfab9060c5c5a26facbadf2341ca3a40d8ce2a53f9ff3ecc01809908190f702d7c4731c7edab145b54355e208cb3747aafaef5569bdcb530760ff6a0e7cf72659522fda6cfd127f045660632de6e3972ed229198fb0a4f336e33daa51aa6a46422abfe790452a830bcc2fb507bc6f2610918a9e92bdb3f1ee7d85abde3eba76266c66a00117e311d0bce1943c1c1b732c226555d4c75fb4deeffc0e03b1a5d9545fe086d3a66ba09cbdf0865d7e1c9742efe4ecdb38ee6eefcda50252d9e5a44e22c6a3f6861ea7cef5e66e844ba6ef87c5407aaa04c09d0437a3be87679bb775d1041b2617ef62a6b1a1dfeaadea93c472c8e37c09db778424fb88b5956534cde9abecc6384bc485a9cf26ddd97474962046608ce17d5fb2b27fa1fbc57a153b7266266d501aa2316ffa6787a8246e2d8629c31131b2a26d5abd493b01a1fdc6a87bc5a3503d0795b609bd6222f3c7f1778cbf9c62be79edcec47c3e874c1a76c69785e83686749ae7eea11337394ca353216cb479af136904522a8628873a9364a0ac01981dde4fba97cfa38713b1cf292e2e953f6ced9faa9e99229560e21dce2c32947fa64f70b88376b31196011e66c5e4f53f7e65d02c19054c6fcb7b78bb7cdc506ac924ee4c4f3b5811a0fe5c196ce057260156222d75ba88d781a9497e8f125e918cc0fa6a44d892736bf0bb0520858c57409bd6ed314876e72d6020ad74a44a85e5c647cecc912fd62d5b876d59aaf638459a635ec3b11dcf83ac20bbe474fe19ab311dab230374127af464d9992d8ff05a207e28d15ebebddfbeee75e68cc0cb78888a9173c4c035c8824016ac4702a739fac3ead316d193fa9bd9da743e4ca4e4750773be9fcf752ecdb645759d46bb16df1ac968148b89d05fd857d7c257dea7faedac64c27925a33c79631d848ed4d9c329bd7487d37c8af0d0b66c8c92300662ea10b4866d0b3b782baf3e4e8c79dcf10adeefb53701a8e3e853f323f1fda4e2c2a99d2604d1a48f595608b67ec2aa65acb6464da3818f0cc65b5b3eaff71ff80f69efa15d4cec154b6aca2e8e0ee000e743456fcd7ad0a68ea0dc1cc58024184d67d3ed0622487471b2779ba53cc9fc0eb97aa53c47698a2b9c45fb7b304e5fa440eb53dd1e8f80b27ca098c085108239051bef2f0b4da9056f239a53ba1f3765efe1fa466a1e29af8cc7478869726e080bdc4891bf371cceff3d21869ea950458389dafa1ed372ddb5467986df2d82bf95f183d0d7753181d2d5e70b15c20ede8f1d3899d588470699999859d0757300df09e2d490eba4502b611127252550745d01fb62ca2836c274caea1523b84a721dc243e846c4932e0c724f646da3f9bd9ba2cd9b06673e21871c1ff7fa24d5d016657e6c81116103fb4056ac0c05d35c6919904d3834a10685ccf102bfbd7883e75ae8acc2e81d75126b685cba97436a4e81322c1d61f63476340a8660ad0f06d6b458b610bf66b0fceb621068189a9f88360d86cbbdd11d20e8cafaa59b220550386ce3e890b1f511b118a9ee6c1f256a19fc33fe2e6c669a9b86f4bdb9f72905a02bc49c4bf6c313c1267e3704945286758d7420b9b2b7ccb2a78dd54c1dbde868a423c9ea7747955a3270562f4a133e3f86c963244c043d6ac51558b6084e18d20f7fa3f3cccf719523960cf67699275e7ca25c31dc3f44e0a041d71fc52fd69c983d55fa26b409632b52a6a111b497e413aad8d8529ca5faa071a6eaaf626973df3eb478bccf726ce3abb472791bd1924317f055456f9bb064ff85a03d1c590a43652ee140b10ba948acec4bd9dc836d57fe259498f8fd01c65b8ec2fd5ba56508315f1ad747ebbaaf368372b95a08929ec6cb91fcdef063c950e5bb85fb1f22db4b67e49b8fe1ceb648c428b62783561673740f6aa7256feea5bc68faeb3fe5ea66e35625b474453a8be1f5d684b609da81d0cd84943133e0bdaa26b7a95b3c4713fcaa09f79f6eca39c6a62962b3456641574fe64fa59f2dc37f3201e0b6ed7ec15914ca717195b6422b0a6c1c69f18aaaa119c51b2726126b010bf81a4cd1241e5ec1db0b2aec4716397a42ee1243a0765d9758cc66a6496914440f9ef57b0d181cec2a2646f7a37c4377d4ff827a7644db18fb60953ea940f11925addb6702bbe051fe35a0066c8c87475f532da48853434728a058e1de6ecf66cd1100b60b77a1024cb7651656b382c85167e922c073845285ac08e442ef5afb5fe7c0f2b3b5f6ef5fdaffecbdbd309a81a7fd8750adcf6bde4578304b385a24512700c3b648360e9d03d50ac5349d8d1c60e42aa62933fc6d9272d2c45f74989b4cbbb56bf4b7859936dccad3f48c004219e87dee6ee6ec501aeabbbd03e636464a2fc05147c3e55cf49bc254bbcc1af85c7bf858a44dcbe173173a26a9e1503f0e4edbb75b20a1cc8d4f1a72a7c14154cf7d071664222908d45352b74e82309872e40726db59e6405acde9016060f0da40a350cfe83ca237c476280390d971db62b7887177967422dffc8845f529a8cc7b60f2fdac270870234958d38843d245cbdef5bc525f294590ac325abfdbde08b976eccf02f5664de7cfa376699bc631d0978f3b47530e6d5e6453b7a5f7ecf358b75a4ce558611674edb124d99470d1e8cfacb60e02d6a7a15c425ca7248e731721681597af2915439df13e97c6b8d1dbb41d49a1180d2a32b99232cac55d2add2446c3909d3a5d588d6ea0f00a7bc02d53aefcf20466ae76b7104c7d0fa68fe41f7ede10e97c5ef1a79e829fb37f2da72a0faff3159ac5d427e8fc547f99718831ba600ee9bfd3e99830e48c2c425e02344ea7af85240d0787681ed2247baa9e74aab9943920e3087e32c2e1298efa2f9e35b5862b4499e752168c36e48b0d377582fcbdb08cea126a3047fcd709e8891ff737219ef97f4ba5adda51a4fee7c305ed9def91557837a2a8deef1e4616a2e67afdd7b7acbb9ea54011a8f3a90d400ef8906fbb775ea9ccaa48d278429793a5b68e9b5f0c9e83fca573b59c7abbd544c0639e8c7bb9f6e0ac24194d7c25d5b24df32384f164d9089e74ba15604f5d3afef1de05271531faf26d37811f1f5713efb098cc26aec3cbc1ea780c477288e3ef9dc56034143bad8986f288615ad65b033896a4787fb9eef6214958e2c4920c0cdee05a4fb3901d5845ccaef115c15cfd0f89f078939d02ba7cf4c132d1488ddf10f489b382bac38d147d68496bf16a04d0e5b7bac448b1248f9bb875d44986a645e9277880a1a407cc7ddc0a05048d21129cd690d37767952f77f10a8bb37bb5eb289dbb6c4b8c94a40773d2aa2ed1b8c849bd64aad12ee7f5a4416b79bb2bc55b1dc34f14d317d1a8690fb396bb20b6285931a61663dc49acae8213c713bef2683fc7884845db4125fca2c66b8b7f8bfff0e8c556c91e17693f63ea9de4800e07525710d57d492114b2e75d8a120c3847206efb8221ae90575167929503eced472d96bb50ee51afc13b1adec32182e1f59e119cb52dd4a0dd6ced76f3c2229aa2373eddc0fb88a23b8e231345bf6fa12a34f802a73b6edad9a19cdbfbdc3114298eff11ed9dc02e125c135380337f26eff63f836a4b37640229a7baf677d1fd94a8bceea97a4f0f9865f32fe49f61fdb3df2defc791413f23191133cbc363ea98e7eae275847d670f59c219d06928727ebef80dba362e1babc52e9f8914dd36b0beac6481054f0e1e44116a388c03b1795b4b986867ab7021bf4fa8ba78b470d73fa3762eab7c32bd81c1db37cb9e655fb5434ac4333c663e05c0a6fb412a8c79f237db8f84dcb17a5355a443b8496344dde0e8be58e515d5bdd89425ce1d6e4b609423407bc4037050b33b5013e00f8a596551cff44ad2a15d33f5be17b2c6be10d3f6b214a0e03ac27db2af45b71d6cb5789e45438e684596ca37aec081609678a18c131d90c93fcf5e08a340419583c4e5257fa4d468ae19228f836a25b990a962b7b5628ef504b65fd4160c0808d0316e5f3143566118047cf325a3b46712875a914867849e6b1a8fb51a1e4d572ae627c77c5fb5805c15ed10812c63ec7b1d8fe50409db12aaa7c0c68ea049716fe9f1cc13873b540509a61c7589bd952678c78b75c58849f50639d78ba5e62c8947417b3f426f037991a8575da0fed45f40bbbe266caf8d9f70b0cf239cd081084098e6b426b06059acdf2855c81d4d87a9f4f9fcadccbd237d49794c85e725c8cca7b6133cb16efc15cf2f52996ad4cb328ca1fcbc3131d6c22f74c9e6e0c14d31df5874c12c4d6cddf60f13e3d6584f992e525cce7fef49623b12f059ddba0d8eebc9408ffd25a7151efc56d6bc859ca880d5a22c20e150fc0ac206b41d2367d7cc2cde6b262c47d7b128d3af9c31e2eabff2a2d556421e598c1ba5a3de76ee5d907408633de8d28e6baf2c78f7e215a7fafb65d6567714fe5768c957c1889dbf49b2ea0b82c18b572255cd564dfa600811bdad6eb6a5079f60f24ded55604a41f828f0ec58c250b77ee5f2f9dee8dce9ea1b6daabd556e4688772f9c5d531d7189488732085259f966b23a6118873d193e9220f3db2afad7b91b739ed850cbfcbd1b8d510194504abac46c5c250d4c02db95ee16e8b95a8439b59a0aec3883a2c17c5bfbc333823cd602fd30c1bf855018ab0a37be61d9ec189bff4a97a36a66e7d81e110eab77470a66c265ec1e4d296d486d326f77f856dbe8cca2759a75a25471eae30907452c9d98f41dec384ffa80488ca968d328568ae6d4a5dc22d6b353b733ea3d7730f7a8c587efd12ac6255f78b1f541c5422837694d4d61fbd370972da21367cf76a9a3babed946876f4e2c6a8f6b3136ceaed2205043ff4408018f21a73c7234e3f48ab65f412891699e084bb59ca8b485d378378d83b38c1fd01fe44f8fecfb089bd0cd0c05f94cff212b8812c1d24bf3245275118c75f59f633c9f9cf52b7dc8275e647ac930d610147644e677f69eef9a96104061d5e763eb1fa1cf0b0131f2ac86ffa1fa689ab1fda13fe10f7ee77e09c9586d10279b5e35e50c17a89cd9a194b8052502f5ddf1641612d6d1e6f88ff2eee3be15e778acab18038d8f87059171587aaa315035fc6e3be465767a3dc4682756c1fcbd7cbe9734eb8c5351a5e2ae1e95388bc1c0ae78c2a1fb57ca49b6a5b88c5b5c1031f85038c504dd61d18bf74b06dba999af4bf6f439302b08f435cf12e186a5a1231587df01da55a66b4ac26a09f87398574776ad6fa06a1d3ed3afcf0d98a73db78c87956091ed31c1093e5bda234f67c2a6643c58814058c6a1ae558d47e3a20eb5c82cf613269b071ca8919cb1b6991e72f30f634073bea6a3348747f2af26a5fde02a4fd46b266f0e9b1938d1d909145f54bf8cb3d9e126979964300a7cca8e235c0a46a02cc6097a220e87f5fdff76c409756c7a040bc17e0dfdabb6423b308bf87002d7e7a79c72387d8be0a29a5e5d21d1200d41a973f87efafe3b26d32f6ba5b59d8907db90c4f0563220b3e2f727721f471a134a55ff864246dfb704377a34a0181634fc6943d46c2bcb6b1ebaac1b39caa8b12d8f0d059da3d0d5f4b16dafd331e040ebaf5e61e7539c11f7a434bb027177efe04e00f50a111eef74b458da13384d486fbad1e11a1cfbe92e378016189671d690e7219968f0a3f76f1dcdde2804cb47b670c89af2bcd11b8b447f005afbee7a7aa6d432498daae884ea45cce3c2ed36e318a7633db63d6028d941fb386dab1db3f169a3a5d55d142439c77b1346d0b83a2d139a2c9f591f97998ba4a6d0dd07161da3bae15a2cb3765c48028ebba29b84844c63b2db0fc1f79257e109396d9b161d1f01233e92281b2bd68138db35a156d2a92ebf8ad7c126c90ac783636733a3df19920afdfbaa3ad73661d9f51242002dd0aafa70a275f9c466e75560c0f29bc0894b13e26e24f4b6f9b4d8d203e853737547803bf10e164abda61c178722f3aadaa162bc845dc651c8cf707a33d8d16e562b7e2377461f05b35cd3861bc61bea916247b4cf1675ad8b201203911b11a65fc65a41789b646e2a7bfe9de5368c3f139f2ac384b67f1de65304e8a2b71f6e1b417924572172b147366386482f20b35ba0df3a6dc0dffbcbf5857772f22a8cd39dd48f0fdfb64b76e21a4bd3fbf69016b5a0e96c3d968be4e459d2d81bc867dee37d598995b800e6251e63b0fa103cba899217a0391c7e2d490145ce39c9c4894004836772b0c9d3956286e650457724a8fac28d07d86d1edd4038b164576b44ff48e39810b887f2f7a58d13067b26c849a5c8abba89dcc5fdff29b933750d5d8e41b131b5b3feb0cbd017e194ea84d3a4a4cb9a9321d31427b7cccd9415c4fe5707bb045eb4c1d51c0dc6b98fddfa562a1bf666dec36c89e29016192ab9b4ca8ede0fa5a492e9924a67e71b86ca0392956bac1ee23f092b0b82a7dbb7edee0f92b0eb97ed07d51f0ea98f3c67832355ff8ed37405b43a9b7e6612302c555f9abece30270680dba87c00b2859e9f2c7a7c36bfd2b9a0860bb2ce1382a9609958eeca276b9b6b94d409430ce3b58ca97960e3efecaf1e8d1cfa958e1bf343370c26711d97365e4483f414779ea6fb89f3365fd0773f9e1a54cb0a0f2f32d10ac924f6376edbeb43de15a83100d32fdb80a2c2e88fe362b5521cffe2e25a5cb00e4f9a5ca26390c49336b75e13d17c570cced09eb85abde60fe41845a20a415cca054d9c80581af662f9b52aeba8d523c6774a45f040c5db7eaafc5f94f7faff94ca560ce22985df47ca7652e75bb63b2c090cddd4f4a54b7308c88417ec79b79296ceb45df460e5f7a95b9246d287a3919b204232bef984273415a79b7b0c86e8db268c4bfdcb3d6e833fa2efa85ce245d019996d851450f49e0d820afe3c87fe5d197e92309ea400836e8d86085ff12ad8f34dcacf7a4522f2606dfdfca9cf6c5946b32b19b0f4dd7253edf3cf709c071cad82a6e41e26d7be47624f694e88f3acd06f13399458f5211d563a82ff67b408c021422e5c4fcebe584a348aa83ffac5ff95ba7ef061a55c1e660e8b62384a4ad3874f2814e361739369b4e35e51610c876b6541616cfee07e92ac92d3a10e4f74afe113c887bf65fc7cb827517220cecb4d90339bb0f39bd1bbbd153d56c45e355f43559ae7dd14512838d7f8cdf6383b792026c58f1cb14488b029189237c143cd5349fd73f762964f9571a2770d525580cc1cbc2861683612073e999d08a17ab8b1c3adba829328bdf3950026973590f80c38806575d8d297a839dfe665092b2788764f5527dce5bbae1a2c52b6ffa7c81e01a56616a69a0330316c39516b97bbcd5b7218778c05134fe3eda924c8d23dceaf3a7b48993ace2c3eba7fb3e8d685dd55eded9918f79109ee6dd02b5aa9ba12855fc9d0be0773143b5102546dd946cd49e5df0902b88d4660275cc0c66c0114b4d902f597acf2575aa96ee614305f924a8995632d6891a3869a7890f1837d19d0d37aa08ccaa09abdcb309b92a2a1871b379e754b4bdade32d243a49a0223de0de28e3cf33c90f5cd5d39ae15185f0b8d14c429da9d21bcd6f95c75422784d28e87b506bbf72dc8fc87b562a48f9ceb2c48551f977638d49ac26908a0522b70bf9bbc571adb22858b18f727aab8e4bc654589d0fdece811e825a2b09da81eec705728689b987fd98ef5152aa675ec7cded094f5ef239001403e7be8bc543400296db3138bd352ce8c539596e749168798071f7195ac2609ea3a72d6da11ecd7d9e96fca42145344f6cef6337d78206fbd8137166ab4a0f8a443e40ef4216b2bb5de275f5d6bde33c9edd4d5f58e62a90f7568dde8ab9aa2cb2ddfedcdeee525c3b4dd751f05188b938985153a188609ed285e3c6ea55f8ad5a2dedd562fa93732a08a52eab7c77c576ef603993d3a51cce298c604964b8f6e0815e065004775449bea248b6d72de97f4dfd9fb21ce92df7b0a9b002294f43b306ad66d236698cfaf0c45dbd076dd0d1202af93acc688fb713a82860c068618ff9c4f08558b67752be2340a518814e5ce520a3a91f0ed7e88557a94f41e9e729a298114016ebecdb25be129ba28c3f9d6138113cb1de24ec9b970accc0fb20c7a6a659767020fa2fa71c51b63da626cfc72f1c07f9faf115905bbf1264305cd3a46cb6be607d043b1156733e540c7d94c718c5a6a4be64374a4a11eefe4f2aff3a9b2c73c3cfe240929e14efede82516ce53d7e37435b148c3b5509ca94381d7f6cc92d24459d6ba9c810df8f155327f9d3f504147468c527024d8396c361feec06980b2917d5f166ff6f4d2424db721f6a04b5f53266107c47b17faba1ca3daaf552313cba6737dc9f13c5a7b4754070ab6f9b8d3421d603efa4116e4a17afb5ae9d8f6175162b9a5a901a4de83fe4a534c481f63b9364f757eba6bbad0bcbf8107f0d55727bfcc52fa091d0d646058d8568f988395d789fbd13480d8727f9e6aa34b99e7f550a62a1c75c5ae313d865cfc2ae7f79a5230fafab84dc435a2a59fc5620d6bb5d2f7e8aa0243a379b3f7d3436e12801e1b70667d90505688eac083da141a6e8e57dba250f04c125dcdf4c7a97fb03365eaf01ebf0d253f4de9e7e0f84ed2748cc9b202b583d483b8e3491bd5fc01c6f5dcaad9d8af111be53bd9eca0d40527772bd997dbbd4d9fc1784fd6d7d1194fcc69306fbc48cb6c9ea6afa5a6943c2b92d6fe354fcb82ee631c8d851d6d3fe87cb2bb04d2a8722afcf116513358d000325fc8a21e72094f119cf5fafd6b990b1148ad5e0143a675c4b7ae5983ce70e78b952382831a0a668448fe620b29b120516b5355a1993bc4498792b40c04a4ad6024e6611a3ac726a13815c953fc79024ddf8272405a3fe64520a157dbccb5f69ff2b6cf89b72fa75d1e1a70e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
