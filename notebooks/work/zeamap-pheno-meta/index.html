<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dba4401fec39b36e6f1f51b5de8950ec0d736d1f85578ab758ac3bf68a0edffbf43089d9068fd0dcb04fec2a575639d885f93330f7ff7e11476f7e484a475e2f791ab9af5b82e1360bdfd4977dd16ad9b9e8b6367135e5e7b7a1d3010fb8e5eb215a9537fa1e4d01ea45c005fe033366bcefe48de95b9fe0e883cc555f37bc56f4f2dcca0bbd045dd5f997fea9152156d07aa98c780fb0de40e80b153d0672c45eb647e80ad3f0fddd881e029dee4bfb9720089fbfb2523b548129145b4246fd71c1134d8d3428bc2c268d514fddc679dd40065810f1c735c04153eeada03f353f00f5d8162b2d1a95ddc444f80c5370d6ee71cbd3f0115fd47b4f7c88e9fffbe01a9b730ac750ff55d3f39d8be386ae2353cd55ee1ec3bf22f306339de3baa5dc98fc446f065275ac2d5f2029ac4399b693c77992e726335718c3047ebbaf62a66cbd93228b5eeddf0ce76289af92468e5cea3477e180fcc5a062a55fee6dbc05776f03bb4852c8039f0c60228675870c47a90b1726207a736fa61bfc1a8a034563a00e568a6d2e9cbf79a4e4944961a711d832751687684067a672df5f7fe332951532168859b65b53d83c81317e12f8288711707001e5ce7dc9621ced2fe011ab9e7757cbff6d2db3b84a3e9844117d828365924d574754c80e46a840e043c27e3554c9c94719c35e139685b58a19e1ccaeb8f0079b721dc47138917728d1da463126159b611c3f4c983b486403de2fc420349e813477bac1e6df0b9dd9eda381890c93188c66508c917238ce527c29ad3ec59cc99ca4ec829be47b281a770f4c0c180bd5d9b6daead36b7e6b7e4766f9b2acbe5fba0bcfeccfd3e4457e2eda30b642344e5b3e796be0ef4393c36dbfe5a2dfe577bdc819c3b684efade1b1288607ecf9064e6e3ec59608e3af524dccdc1c286b20e3e88f529878c9b51fdef9ce1fe7424fdbcd48206f8b5f11baf877ec185abfcf058b48494e2a85f9b2c28c6541e04a99f385b67adcb8d42408ccf61bafb135d569ccef335deb9fbf53a41c10570176c878a655324fcf39ca1b095cac25a2cec37f00673aa7c0f2df1f4e2b67c3a2782931f2022bb7a2a46b5e85415ca894722889fc2375e085bdf652a305280a870abe73a278acac9e400288df3e534e55adc8653984438e2bd2921fe7d43c69e728c1e74fdbffff5d3c6eace2dfaa2cb8ddefa4d7e93d92ce590c269993e75659536febaf91cb5a6a35d76ed7be12c9dbd8788d807c27606bc0b66c74440c8a2ea9a929adaab85a12e4524a15dc642baa2be22eb188bc262e4610c2dd2cc297fcef104b8cd92c5c0636be722c8e2f8006ba56af6d9a1f8dea0efccfde6b068856ff03505de58c71b238024e5117e8b706deef34fa089f682ddb23174bc9237cb07c7bcbc5f546464552a57437c4ef7c997c2553c8f757c5cb9026dd83ba346e892b808a02eef5159d2602cb7070ddcb9f975dd744c3cc621324893bf4d843d5063b77e0c5e08671f35fdc3e781be7b0aea2ec9ade0c90e66c9bc2f406115dab083038431f9854b5f205895e3edc0daec8e5ac47afad5b5acea10d015c64e86d4afdd94d735533c35dfe3088d8804df745c37a8767250b7bf51a153b4bef5ac56097050d63c67d5cf91843e55f6e7782792943b078cf94d322d9996c24c0b04445e09c6b5f005c6d39f536206401a4944e2883588314ed07ea675598850816dface090d0c1ecb1ac0f1dbbbbb56e589d2a517f0e971a2bece23437e5980140dad0bc32f503950d9f9b946de22db3cdf5c9f2372df92a3f327c04ff2a28b77e6f880f9ad720556a0dccbf0e068d1769578fbc3b586f717cef48781675094e035870a6b74f2763b39581ce75f96a7559c3bd844fb419e845c688e7c13a4f194ea002cab4464875449e11d8b63072f3fd1be97ea243d3b4e0f020221367bf8313d41e1b0e39db4128ca4e33feb1754489ba72310d8de0c630d4744bd1998f3ec5d1e1b1581ada7e6e8506e7b494db3a2005365c753cd99e3b801ea09745aaf515b0d052564150d3ac04ea6a8c35719fabeb7c25fdac40fb31820d909987e4e2d81e14c1cd24ed97897e7f8176c9c6ad8ed040ba580f77c01dd9ab3d49339c08a765390daa2a22b91c2c7a4ac5d9c716fae4492de084e2b2f700e170029ae20703b9e67948d734a8279a66ee3638ed22463a80341f68a7dc45d998bf7afbd5081752219109d3780e9407d1aeae275ac6a23d189adb2793cf60883f7307c03ae10c5fcfee22e992f07aa539108daeaf24498593afb60e3effb8f6d601f256fa791a88a96c6eed9c5d22e08c889bf5f8785cbf063e0e54ed3434e4f007d45378733decdabc373bce868889bedeb78d3fbd77a7b648ced0ac1026b22247c340d902f124fe6126343f13175f07755eb10e7c779be8f8ecd456e215681d1c9fea4b3c32eb9bdfafbbcb2ec91244651021516396b3a13112c5eb7892a57a616f705f6cc893590926d763c7c49f53b9be205d3b24f1e3abd66c17dedd23e26e3ec3ba047f17024744f877301c59fa93fa929bef5fea3f654a1eef31dee14690bf5598dc730e72e58ab6d62bc8be89a57ae53a7cce76e501ac10bbb1e05911de470741594bd4537a768799dd9dccb4f1491c27395d31c5ffa8942ab77d49d8361327319c70df27403de846992619d6a557fc4a54b1b4abd6dbe66357aed45f437ca8393eee79dd2d4f780200c573e952bd910a19af1502731645e68b37538ca15bd2248a9b72edef0c22362c6d5fec54d8b7a7a25351c3f9a7968963d09f68a46b7f3c0ab44f3bba9ae4ad9cade5dc83cd54f25421f9c9d50310a666d0d00fde9ffc42d06fc694bb8131a6c4337df328af00e80bcee2885191ac308312c36ed572b148f7ff94ce574ed9e42bfcbec6e5dba8ca285dccec791bd755e197f112972d6de340709d0837e75be2b8f14b99a36ba2590bb09b13d5074bf4f26aceaa8941bd079184df36d5c0432bcf145622181fcbebe1435b74989925e6318484949771670d0fb2e3b8eccda2023a43113b2c88bba9257ee4550fbeea93402dece8c9cca0d51803fd6604e907b8fe9c68f3a7f933c25cdb7baf45162351e0ea3d91aabb091fe22c15c79fbcf20b0caaa6038215af0b9144691b3172761a1547cad383794b46fe2ba91fad28302cb25fc9a5a7e07df79237230f7aba7316be7664971103e6cf1de8c204d4ec11fa8a780e7d7250f35e8ca0ef4d8205415fc469bfda98d7813a12c7f460b47bec553e069b3ff008865c3828acf15f8ff567df7385148a155ff810e378151f89f37bfa89019b92c7c99adaad58b8b9cbd0b10c0dd19bf43f332b48a71dee0894c46203dcdbcb73be863f29c77e0bdf126b159cd3086c0af60c44100e2f04ba8a23a0d9a2c37bf32e05e28e5f1ba88c35912b03e14d7dff1c4646a2e849d33d40868c54d857fd22d01ed7adeb49bbe97f71ce969015b54ede1ffd075e8827b1ff045634cf289a4b8d53d61b6997f13a6ac31c50be9c126cd3cee88d8e81dc69c7c667b6bcb37a6583841bc52e294df920e079e52bd7c127c4e0bbcb787e25ac2a0d306813a67729dc94f456bacc99b3f7f9caf777c0c15520df26af0a7e001d80d2e2f457890ed31189729bb6a654298d910e1e26b31bb0f8929a376aec3827d39a6dfaa177ec707f752f77760d84fe6fb4e2bea0a64415d3204be654adc3e066e596e0855e9ce8eace842ac02d8c109d8492f9c678ec8fe0f5177a3707689727ecbe536bfdaf976bb36cc7a22a01fa0dea60fcf9f17d3bbc6dd5a0ad64858b395e83e00f3690ac784fc1b748e83b77669f521ea7024a5b912e6fe5d20755dc7f04e1ace23bd95d9c5e4de82a24d70a1988b669c4b08df67cc1628944c9c9e5d711366f25fcb1b13e71c1f930815b43f98a9102fdce81fe7121e993e9d09031dec7b93171ad78962ea31507ead17954c7e15b3632b0b8654194db6cdc94e8fc870d8057cf1b3d6e8e8aca8ba15b4c78e4d83957d3505ba8b194cfc3667742ca2a452be45a6daae3171449210cb8cbdc32563187d768932664f783584573ea3c078b7e254b0e668b5a2477da85e81d1707da45a44395d002f17059c4e15132838bc9716a46a2ad5473d1b7d2bd289a1213bc6289dcf81d23735ccc4908b3b9adef55162b36bf5d448b8252ac7a9fef49abe495ce7ac1ec66314a8e8da738abcd8288d3bc29aec626b225bf3061018d55c24d9bb74f346ab4453751fc69f3d18a08d136a3e15737d928319bece62a6c026bebace27aa4e1c7b35abd89c3b89be11214cbea824c3e973e30b89d6914108a53725105080d61d819821ba119cd724b866031873718fe0c9c54184e7ea0f01b2f625785bdfed9e3ec751fd3ef08c6336b86572f17b19c585f91b052f4e3ffa02ca53ee2d1c25e0e66320bbca3bb63c8324345da8260292663ff1f207b4a75830126b67ea7d0d6f7b1afabbe9369c08d6c26c31d4f3d74d2689c6f55015fa7bacd3aa402c97ee924d74a96c952ade6fdaed0c6f31eb2c2983098f50f07b96b3abc2e278327ab8c704c8457a675b78050c404cfdba414a5a8aa9c6e4e96d8249b5ce0472ec95605b61657d5803c29128bd6778286761416bd66820e6cf985b19fee2db0005ae8eeafb05dac7e74c7c94b9756a94eca1af81e5ebeccaeff7786b88f21c5f1aaa171fc8c50fbac660faf88af08280f8cd14e27ccce600c5e0cc37289ceb0b376267fca6f5c3ccba597efda24cbd150a1dfb424fef49ad43bbf92f00e02420bf03f34265b408f3f48e502a2a67695193f24c1efd5a62c1c4bce8dc4e88f48af46cae66b79c602d2d5870a105597330b2812956fafce22789c4702e1034725ed3b2dfeb1fe63c377fac172ee8417bd2590df018f40f18ab8dc44361dfbb99a1e0a8f992845aa91775a1be6d5bcb1ee4209a12a5ff9a8dde0984d8d9aa8f9f796e03a1e74f1875968725665694a5a943f178ca52b1e37db879c435789e10d637866ab61e77a6216fa760d0b2a3d2e67ecf46eacab0499e0e8a0ed340639645231a16decc9d1e76b5c061dd18480592ad10204799dc7d1f60a5d07cf9811e776904edc9280ef2e047a2f558927c8721e1c9ca40bbdd09d0de9760985f3be26d81adf1a42ed70f837779d16c48ae70f83fa6f5cbcc95ede4bcb77f7fc37b6f8cc4911bf9ac8480de23210e5f87808bd15d9555af56b9c2b6ba33820b31364f04731dab18091c185076ab32c2d46e6e350c16fbcdd32fb1a65cd3fc3ac5df075e7e2e52c71b305bccda8109bd6b10c87b67833b08f956cf733b6e5eb8234e4b0b5db0cbc64480caacec95cfc1dc88f8518f65f7f691ecd9e77b17381b2bed1ce07c66d66e91ac07565d0c7c19941dada0056b24373833e655f37034a6ad46930b4eaed539ec9c3d110798d539b2d396750d10c49c14a6048bd8abbc18f895ab2dc9abf588f13ea7519e7a2d20f60b255add732b96de7f6a38fbf7a70370628e346880313beae8973a612a0ad32687b18c4609068071d5f9388c62451056290594723af1663fc401af23f48397634840bde2acc1c65ce5f986dc1b9b920fb8b83bbe30efa4cff645214308f2591b29b0181472a109ab2081c39a1af0a636d1d1e425a5fa7459da0100c9b099db19daae74fc92f2221e4c754486d8a5c87bf62ad27111da25370f2c267fcc1ba54155e3047df9f564f13ca743b71bf81febc9668a8c5c2d9de3888352d5e1dbb95bfbb4579e8888c3c97c073fe9527af09a2bc71addae50bcb3607fb608c5118f1986ef7774e5a7dac8a940140d26d9a4b6f2a1e6a3a679fb7de233277d602b955e1e1f5277f6571c3bf340a46e223fe17e9daf70795a33b32b27890b21d62d43a0001c68bc1d9049326a73712d475ade3e00ed776ece6b70106413398f8157a5d0de9a10607cb9575114fc14251e87fb567b8f3f4e64034f2d53a01bce9a9f5d0a29f80886c2f5d35765c0a248be3d5c51445c629090922a1b6caa150e28214c81f44e9ac74a89d91b32f62887f38f21d9192897bf84ecab0f2ecd2949ef8098a03fc3199b2cd9f15d3441c340ed3dd0cd54f10f399f5abf3225cadcdd3fdf3dfa7c34523139c61ddde1b5b60952aa4a19fd9e80c65facfae882c350a8599d4f6b75084e72a2f300a2c0e91bf2acd04ba816e682cfc6f233fcc3709fc3cf62e55d6749a450b26262c8ec977d7141de4eb3195bbfbfc8b00ef1a7ec4ff9edde31ea72603d76de7dbc460cf7b05f201907b7aace79779f671b4c001b996381577783e9f9d62f6c4ddd011dde244d2430633f632b032ed3f8cf445bc3f0ca2f62416fbfb6555abcb20aaeb0f36ebe042d0b519542433ec442835dbdd9316ec80a5553f7980ac65c0bbed60bdbf4ce5662b63ee6c38a1822df198cb7dc9062fc43a10b0a0117c1897d282c6daf6347fcf207ad71fc68a2e497291669f5b7e481c7ae03319741a07940dbadf989790284b8fb87477adafef4cd25c36450664b9ba5437c7e992e2b03c8bf3f829a3545cdc88cb64a4e02e97be5f10a30ddf8084341c3a3e3cdb7a2c01867b1b716594b7ec2e3e1e42ef82f31a09d1118281d99d97aece175964bee42a7ba286d9af6f02097d7090ff06f7eb16dd426c7acac8ea5b2561024fbff034c644d983b5200d61fe14c9089bdea65867ecef1f9577ef1c03a32007ad946a30c8c18c8b3597638a8286497026ba4a2445e6c8d5ab3fc7bf53d504aaae0842b5dd26d5a1a94f2a0b51de9c0248fa758f45e50ff2bd1d90ee1f994ffeed29acd6800bab3290ff38fccaaa40a5633c483963b64dcae1f6853ec0167b0c3d6d86b67f9aa2d29eeba3f10e60598c9ec35d60d1b81e94e43977a92faff62967e142780c11948a02966d857c064b1c24658b4deaade367a50dfeb19d9e61511654f2664a589f54db3c4fc9df7d38d5a1cf0d597145b5c1d9077ddb4cf074c1f311ab6240ece4e6d87962575ed6f2201026bc65771c96aa78623a61bc270c0dc0aa37fdcd6dab609837a0b9a129da407314a0cdd54e65ff87f8b6e0c26a9bd6ffd4ba0c833800a6594e040631fa00eaf1cd6e038208f91ee8df31df0b56cc2f28430148786f7a258c12eee83675401a68807a934fbb654299f4607eb673f6b5ba10a4372f749e732f3b1c25d99a72849bdb694f17d9a88faa6ac7e1620386ed34667136681d4534b2022b46a194334d2ef3c70ff1af0dd7b60987c3b1ee6ce0a32e7652b2ac27bf9e7960e759073b203e8822c5173ad14b49b2970bd5eff64c73b75eee0279ceb5f8e774bf57246e29f8f181468d3df4ba2b3970c1eda2aafb71e8893290e8921c1da6c0da806fc8460209d6003a6b71424506d0410dde954ce71201644c6822d0514ca5f2137e42dcb6d7459e38e26a0748967b14ec817decbd9af2613a3eeef2f8a01408f1b0efc2f77f4ccc7bd08a3fe144affa1fd5cbc3d87ea429392ba1f6b4b407a1d2a10672602e7ca61fe3c4864b078468dfb0aaeaf780a3b4442af2d01ec3511611d60c4f8134c9770a9296e2ea5f4e37123fbe77d308f9259f87f0b5d9bf354462a3ed804ce87ef7c1d7b9ef195d26902e8d675c1e36fb6d30d3ccf176ed3da159737213489519b23c2931d20cbec3121c952a9fb35ea3589b1728bb7ff807ba924bf5df369e8d1c0bc40bbb1e6eb19da08211a3b0d5305763d893d72b059f0ef1d7933dc4dd499eb7240fe252b0e7019902c9f1087a9adb460803cfe18ed6d8a3ac6edf5180c76f48db0d670ec5b8393fd53f3fb0d3ca2e98f187e84013f5273f6d06802fd93f76fbe3e66cab3b64d3991e374752bc3297f6984363480afded05b8ef9dfd74e90d00e20ecc194edbfca22d47749c32ca12acc89fb18d13765d266c549070f8917f745b395c6b946878a77bed4a319fd01980037154077fb0a644631c28d7c3d66aff3048abd02b78cd111ba7ed79a81083f9157233e6ab117043f42114ba6e022e27b825c1ae58646b8fef60c4337e01d7ef7f36fdf448b78dea0a9b0fe72c0754e46c07752e4491c32fecab9b6e4efdf01bcfd06438e6e18b05469005f9e41b66157ada7f10e2e44fb7888d9386a7725811771d87d866a42173418686d56b9264ab81c81b52358176ecdac65e6db45ccb1d301893214cc0f1a9832501da8fa4f453a1ab4356b5239ded3f18635716be0e0e593b47a5a218987cfcbaf64e62f4e033735e3252f8102845bb859493add362920361501f96bba3525b3e5eae59d3b0bc0b2dbb09076f68fa14edfa86b73dff306751a0a082b2268202ae636b358d59cbbcf7b71e29827b14df4e6b785a7a55dcbdc0c4c630e639a7b30d8705f28e3d819864885e0ef4efdaebf6e1839c31a8478147213bd1ea49d9dbbaa9f23946960fb6fd8e785b0cbf6b07e3984d38dc9564e0559402a0e0ae3d851b09165c6113adc525b52f0a5b47615c9c408ea980d7bc9cf2780af78ca9c393e138f9a99249c32af2bcbc9c5daedd20b79ca9f523c7d4cf2a16062a2fa94797f4c11d414703adab384a7e807517c273f37c55101325400fd34e167ce6e7d21a094ea412e8e9430df731e3cbbacb63c11ab76e26cc58ce0e2a6e86db341b898e2ac53bfa180e4aa3f50e7a6d5b7e793eafc3ff1e36c29c8ecc6a8697724165cd989a2c7066b297a903e8bc2d590f0a2ccd703702336dd6ac28a5b5c3a00dac34ac27845336ee0ce2e35e49df0d35f8a8d27f2b7e2d604d4fb2d9ee9917d05b0cbed448fcfbccbc7dbab2eb7274b5dd526234006bdf5bdaa4d314aea878ab18110c76b91e811e1b8c75a4a1e46bb84c7deac86b1a2d44acd4e3f881a48620ce7b346d314b0eff4ee76eb24da81d5a08ffcb994cdda18ad23b5b17c81c42c7bf4ca6779adc0412f60a60134864dd163774e84da885da44190e2d8e74aa49d9833d31138005fbfb2f01f9b0e323b7b7206e13a16a3951cd1c50439571c668771876bffd09fc75e308fdc5b958a68afc3e8c674658b42a6cb681deff3bc7b35fc3ee06b5b1c2e76c03b62dc18d129b8a3aa8f1a7f185328bb0c3c54fceee85abefb7185cb1a84af5009ab3303559aca2facf0fa9e2e5b5e21f0addcee9eb240f5fc442253815dcd91cdf9f8d4154a6b68be4ac6e7a69e15d30cc2ad53769a9dded2efafc22015bc7002ba5067f792ea28b622278daa15f71cbf87ce9e923339d83a1ee883b97ea47d4ddb8e5fe513aee1d21dd1b3e4a70df85ca09aef0e6286670885cea515ffd6bee49b560b19b1fd60bac7c05f3cc884653a5ed4824a7520ba3af8e7cb120137ae8da37fe9923620b1059a8549345fedf282edc7e6ba50dbf43fcef9b22cf1e5097743dd266f30ee35949fa9c90a0e92b67e0375e23041ab4a909bd6ca84530a8f625359ddde4162b38069d77ba5cf5ba8440a8485cc7876c7d24e0d59e30c4c6be9619e2ab82a813b6fae5ef0b82c63fbb125e8405b37af3f9cb1989b8f915063e9cb99946928fcf8e87364c923d4c4399d11b4a46dbe9fdae0e75ff5fa0b74ae2c58017835d802af0c89686c55aad7655a15de52c201096fe81a95efb038ddb72cb37adfecbd56b0948616070fba93c4c6d355aca9cdafb721218bd459a1faf79d8b93d739c70673b74fa9a8c705ba122c24e89adda1defdeebc4dbf02b48bcfa40d29e9302dd771fcd5986d28d9faea3dd944d34e505cc6fc16b93522458b24d553bc1057b7b1429a83bddf4d0481763b1a3b14557edd3e8c1ef2d24d9b390591d8001c69a3121a2dd1583d476ca04ca714a954cd9d888a39fc1ff0dbb2da3d968c7a276bbbfce2e334db71df62476a33e8074cbed4925ee14801d8f111c29f2ce5c33f53a48c751fc1c632b1f23116ddc18eacdd14f98ae3e3c7165323d61bc3aadae2de2fbc69b53ad9836d7f8837fc94bd67bffa380f9910d09f65d2f9b5a20f5c7f29a8bcd6b6f60a42ba5391b79ab580621aed160df542f7526e8bc266b1d17cdac7e9333f468b2f48e331d463ae07be7df45e9042de23ba00c558361ceff1ba2dc4fb852e5148d32b3b87066eb2715caee2a132c8c8fdab560634b302154f90ad90c217493780e826861ce22294be2ca7234b7c3ea2affed78dd07e9b38f386345c85e5c863ced71d70993b997031ccb6c218ffbdb9779dadc7f0d5d8126ac20f852ab6de49952306827e5ace86bee052dbb9c4ab8ea89c90dc4a5309890685d6889271cc8ed463bb453024a5e0b86c6c751dafa05722fa2da5fd06c356bd48e034ba7fb1e0b4bf577cd0759833452d53842b91fbb587f4994fba71feb355a571f11b3bd4ba500720944a2fbec77dbdad591223cc7e927693b4c74fda800933182053cf5bcb9ce88fdc853b96420ae7e8f3fb528d3a207ccb287e15c69716dd3faf67ff9fa20b3466eba8099509c3b7c58990ac6b81e56be874bccd019bc9a0a0e92c44fd5012b441ffaf68853154a8f34db31da356be6b0b72d859b082610476572fcecfcceb8b85121bfda0812df0bcee8ba0fe6f9bd8f969dae22139dbb9e3a2bad9dd6fe6b803b026bd4210b6d9c3ef7de16f0dc4569f8712efb1a3082630fe35317dc589e462f327d12eda46330d73017427ece9729b95b1489c293231d5708f0096b6ab8c7302c41562e222fab64a515848ba2fa070488648fbe45f0756aaedf21df36c43a02ce379a5697bce66c0ad97ae6203f4794cb02aa998f34e433ddb6d0cc874f39ace9bc4361e405a0227aaabd40f28f5201d18777d3fc0e635596856ee64489e9f8aea83374582650d2c4f99c1892e94de3e097426e535aac1a949e78c430f5acf5984dce3759533827d77f36e8f1bf35eae3ffdafde7779f97447bd01766f501347865644e2749133c8640898a4daf91df2424c9b2495f69b1a4d2c511bd563cbeca7b924f2f7b3b035cc89d7fccef5d5b64ff73599427d6374dbb390f145124ab254d989e6ba63f37548eaa7a5297ff08769e549b1ca256926ed4ccd76bf51cf05699658d944376f8db47c30f1b94ce3aa5346f26e06e69629c580d9a60447f9b27c3b4c2b2896ccedd11c03a2601d01139724f808c10316215b6758630f722b6cffc41bae20a46d23fb53465f5159a4a5519dcdaaaaaf1aeed6e5f0b7c04991ee2c27e55ea952e0868328ff2e3dafac082c29099f92b8c3fc3f90fe3871d2b4ab7e67eeca89f6fd6f542bc6c9b570c98c165309cbb6f6f3c44ebd5186c55f657e5790998f743dac434ac80dd9e799a67215cf3ba97adbc972946395801d7599d5b7778d3856e17aada004f10871e0035dfa4d269632a697e6113b35aa89298169f9b3029d1bf98e09e3f49ef657b0a3c976c575b2d04c5bbad18cd003a86c3acf7b44a842a4f8a7d4125497f030a39fb26747542d94d160bef0f023f81bffa862d3a57d60bafd9a06f4610db38b454c55d76733d2f2180dc6c700dbcac891d8759d7715e234f4652c515c83892b510937c82f00ecd26d1037360752ea1fa91d7c9c4b12ac8fd8d1e516398e4da656d192fc7fa0141dba712623b7da8a53afef2547ad1a597131140f30170b4002a78f8516cbc5470eb900ea18a56b71092889dc4e5839a56c8d096d820c02f8fab06110d00cfa8e5df9f66ee22b76501a964199218110e3ba61af7dead83c3c12c7e5fa7138c210dfca48715ffe2b852c93d2af11114ae45e78e9319e028e1abe628f54269c4782f9b93b4e7d1b882f569aff8ea7208a9354e7fd8caf471ab9e51b5fe75c748415cc7c2c6c2fd0134d443050bb31a289987e7680d957e00d86205078e7419a242e0df36113a7e217f35a182f5b05815e8daa32b5bea831e160e3f6da43985f1a038fdda3e932c282f0dc92ac015e0c42da819c837820d6b16369c7835f11aba9c0f6bb635fe90dbeaef49500f3a362d4bdb073b6de5f3db02c3999fcd7a83f2eb4396e54e261e46121c16878c7142ff69c2b477957d54e2b5f45e2074fb3c9ce5d7a31856c4ccd68538e63bd2fc214c1f46b18e91c18c9e3e46bbfdd545add9bf771657b21b740cb02e22f5ec5589ad706352cfb66bd1e752164b268cff6fe90262e46c22c8da75e349c960b8a9216d899aa706af06bcaa6e9977426168af941cead8c341153feb8a1b33e15b873ebcd7f4001a18a9c24e42ebf6410a3d7ca30f241e360c863ff7f811d65aeab15f7a75d3a9d1b656765492e28546b5a51650a2b9197d9bc2f307a23e30ca99836652195a5450d50e933e67efb35672c80d89544df69c82e80856c4e28546b2b2fd0237850bdf637458147decc8d8a659682efc56193e99e359b8881b396d42ce11a1df068cce88e99cf1e6c6a811ffd6a2503e923289dd10827326dc9fa700ac5ee874cefe0fb5d59b69ea0d13ba244da336b7106d59a5443ef2a13ad88b50699cdedf82218deb0de05cb25b6d1f3ba192a93227637366ff369244361559a2fe710d51f0623e8d021a319c600f6b4f8da2fee28087baebab6877e29003f5b8a8f5e739ba3b64f4c46dd239e420d99475cc2e6c78e266672ba8cd9db43706380569c62fe87d07f791236492964160c45b4115af1504d81fed9294a541d07c075ec07c609fd6c212ec76deab67e86b11f33a5760d8d79110109a78b7018e2c517a49cec0ebc6af546af92730ccbca6b2d676d7ef7e76cc5e84a9df8384b01cd9d754a9e3ee5925a51d2f666195aa0c219dcf43643461394478e64a14163475a3f10c6b1b76770d2835ee8b66e45576c37d6cd41244b00bac0137e34a19352b3a9ed8ac0e370a1089c7249b016a09fc2cf346f2dbb1fb152d6afcf2268240ae727e9babdffc2d6b3cf03c9d7089388c947842beeecc1a77770a8a8532aed01dded2c09ec3ba9d9b7cb2c91be99e4ff8cfef9500914fa2a7a53e4d4ff5298f92929a9978d0707c88f0da7ac6e976b9f902f8177d03511dbd8a149714e7bd98255c43dfc89f60cdfcbc0d9418bd98f876a2e90768cf36b2e5179a72dba1165c11054ac84483c8dec5c2a5c29e28f7a829ba63695c2b1f1566f5938a90ed49a83aeb30e3608fcc56474161474ed2ddb9881e03d2a90ed7076d9ef9ae6633da561d52a7be656a699b3ff79e3ec36568c00776b52115ea4c4da0d8d0273516e5bdb58579b382bcc5164ab22b1d8a0bc94133adb2c0477527d68a6b2f9088a88a147780b3eb12ce59aec81173e61999918fe1069f6f1e7edfc1e3071d7ca1c7d3182306504436a29da9247b60a93de5967487bec4c4206d1d71a972e65f90770167efd7750d432316bd09ce059e24d219ff03537ec0f52a30a41edbe36ccdac3226a80ba9977b845f6406116c2fb035a70b3eaeeadacfafdaf672716d961150ed0bc1d1225205834afab4446aa706d255f8d62b70da5050ca6b3556b3bbd98f5a006cf0d2fbb003f3adcd1dc0e3f2fb8814ff80bff52cebeb8dfdd49c08bb38f89856845724926e8a036a28cb20232c03d8c38079e07a10b09a6a19e6bbc7103e622e9df38d35789613ed45e908ae47e66e763a273f07f06dd457fbe3d24379e94b2b32fc12eea9eb05684a9e7d4cc651fce53200793ab2edf75f5002658f432a877154f4db1c1c685b7b16ac1dbb1a18ed8d85fe12f7f23ec66e5a2553cb10b53cc99a9918f14320f76bf7c7cb63cc535776d6eed3f22df4d8a11ca9b1a47f5d3d2c0f559959c422040273b7a73f477a90ecc3ebf81df69ea469ad4d1276e2a590329c09e40ff7be4cdbe29e9057017ccbc65766e851b3eb87494b869f3906bf91c7be48e83932bb02dc9f4f4d426dcfdf604c7e2ef795d8bc292b0cfba01ff094aad8e7d4a4dffdee5efb6e2deb10b66b15404b38e8767effc2465f5c27940b2b0da63e000f79ecc6d20b1ccc93a91cafcc6d011a2cc8d2447e709a4923c2b4a050a874a1e869c221159bf42ff967cb186d97d2fddac926c4329596d4d2ad9f5e0f153b7fe1f3e1f0272bf075827b3e452986ba91b02d3b4b6ec1c86c7347a5bdbe86d9fa90cd53d7436523f9195f0cafc5a54b2f8f2accb42af54687e63df6acb5ae89dd8f8b39073029a51fabaad7cfbd9af728c4d8d392f31f93564bdb6f4cecda53008f604d06700a29496ded0486d65e8ee4a080c17f06acddc8926a1bae2d8768204c40409513c2b5af742ea98b86fe825a9c9c49de1d9d491c399a91180481f00a6711d501a86a74883f4c0e210081a24a21426b96ab44c6c1109789dac8e6a1716ef915039e1f2eeff8452b5e0b6af7b72eb8d7fa71edcdf06082aff894bd67c3834ec4ce84d34c01f8a611ba913423fe52a9769e733cfdef2c0eeaa3e4090106140530d81aaaff01d39b4ffc5576576c99214625a7599625f207298f8a2557c9ec35dc63bd878787f381ef1b4e1a268ebb9d3dba980f571e86955062f1a5538cc9a081fda29c3c37319ea46e76bf4d763f0f69be70f88160d48de95a3cfc02dd80a77f62cd210e3b671782637180039e3b8dd7fd57c93c5a87fb8775381edf1632559aa29fafb8bac499bb85652daf8b5765b87cbb612088f549bfb59471658fbabf9e602fa0db892cfa6844339e8628cac0fde09003b8e68838dc94f04ec4fc1519390e56011b384825df557b4db1106909e39d091003066ee8629c8e4b3670a4b6c13afce364885ddd0781c402961e65327df1f61cb48b459c024ceb675f9def12a4ed591c3f125e14a62f1c084a753deaa73da04b547c662a6536b0ca02c207f01d3be236b560b34a49d9ea246b21b45a3a6510f0d174a24b4d5bc70817975299ac11cf766f7c4743910114233e3eece568555ea199224d54de7ea36a37b5f2470a7bf2006a97f632a0c2ed873ee5a09c207f02e631b27e3b4900231fcfbe76e2c00bde904878052d69b0911588e45ee9fd6a83e905a60b89e5831a4f96c19b20f7e23c1aeda14d9b49c862c2eac18f706566b9146d423851bb708f8d982eea820e40d528bfd231f2e4d2a93f27502e1d6c257cbeb70daabb6fe44a74c4ff2b7d3c5ea15c6c529bd2fd0d9835c38a1af2694c1b19495f2af6cacdeee6e2c2b66b32f4bb67fc7d6be27d96903b2d2f5b32e5ae605fdac9e4a6715bfb71aca377ea6029ea407dbdd684167e5f1dcd2b8eaba46392441db531e062eb4cc965e4e2c4c51892db9b948eafa638ae4cfcde1fad873863e421560d4de29fe737d9c82676ec5b834e21789ae57ded3ac89f36a63d1afe1dbf6d9f5c9f7626a21d1dd59dc9f9b54356a4fbf3fc27384f64429e22756897f38624f7af06beace6e682ef28ed61284ac6b845654ef39fb565d14208da494dd10ff97a06dc0d0c8e49991f56954ef9ea9209520cd0312bb524f59f95244acb3e80aeb7c1a8d5993f2a4edae6803372f8c1cf9a0d0dd8ecf80a8fbd2b8a7e802e44bb92cf379fafeecdb93a965aefb78ad4a29973a62573be88e0b063b56aea0b3eda63cf22a58d4deee25b91e155f4d3b429f635bb8ff2f08e3656255cfcd9998bf79917cc089fe22721fa17e140aa29d09bf4806b086665d6097aa750e4135af7499ad6d4b14f1b35331689a463caf7b4236ecaf7588657816de8e1b851022c24dabcb9c098097ca14ccaae378fe0a7245c97b9fabe1b3b2ee5bf670e8859158bd508203b84238cd66a53f85900b4c604815b6b324c3cd0ffbc0d7ab0d3842aa1c8418762029396ec19f5fa525bf50aa76da2b1c59e963e4bc282249f2eb93902139aa4eaf75d7647db1d87ddeae27f08fc2011b97faafe69149605157a172c7cbef9fbf7c1069ee5de9e8fa0820af706402c9e66d24c13dcc119aa7aeef400f54b76d08b013f78f029712a8bced04bf1a57dfd6467da2e1084ad935e567c756cd806bec96b726b6988163ad2c973117d30c5f47589cac0e2bc8f50f1b4d71cf5191e5d1b8fb1f623da8bc4c2385b55aa10965a59ae466161b1afc96273a1c9b01f75b22cb61d19a13dfa05012b66ada722619e09a083e2a34a03b880d994f93cc756e826c13eda44c3b233bcb5db68787fd72d6cdceadd86a410a7eb0979604dcba7dcc5b35d27f03faade2e6bfbae21462f73994e580c939899031dad187554c11b9a5f9a9d6fae947260165a58a8d7101efdcd13213537fb0bc2b543252dd724477b8b2630a53f288377a62a20e5b1c0d935607225a5742a1b63062e5a7de27b8f879e66f88a9a0ba0d15450dc91a9e19dca5756c5ad30286db451e9e88f6bdb18230cffafa92a986f0f5913eb574806c593117a076953cd9106ddfd20bfceb15844f701bd92e4e07bd480243477bd97b7de062e81e3bdb06252a49e65d85689a8b4a47aff65a62070bb996af39941127b83e6d933478826ab16321887364f585b0f8b1110c993bab0500e2b4cbadd579b85e610f34693df10cb20545ae6bd1818e0082369ed167ea0d1d9e8fa60dbcb3bcde539bc4c45a6eaa22129c702bdd75d07d0d6e036b77e9157e530e44d6e0e5542e35ea4465b1b24d1d12e4c04fb17bdd544d52e5409ada770f1ba4e0fdac01ecf7c12e66335199400f5be463a9206dee9f2328ad887645705d59aaf4cce3696257b99134178170c73de0a30fb1c60acda367f4ffb181ee810cd4935a79d903b22c9a9aa66e27130f88b14511bc33e482b8ddf6b22182e4e3d32f4315f0f5f8c3f3d76e3c2f07f0b5a776d9db1e6223b518ad638b9c0471b74ff5fc200cdeb5c3109687b1017d3a0e7f61c5211231162089f586e70558f09db00a2e86926facbc43edb51c50e781af7435ff4c49b2fbcd55d8249ba869d7624267855166899ebc8fb2e0d15620af03c79d73056cd8b3b5f61705fab6bb94280b6cb40799000b5205fc7258fe7425d14585d04a3bea760b76825223761bb091e639400e2256476c82250f29e9bb799ea999425c253ae40e77ec63e94bec1d4f661075ef183bba552a678b559de7ee9961eb30fadfe9700047b7a9e4dedb46cebd5ab84d235e7923a382d0ce36021dff8c9ec3101d2f10c3e3699cb286aca6f7e442be2ce002caa62e5c18d4e4861cb58261c05fc00e9f739e805abf3ea0e51c964b7bb31b57a992f6829308ceb1c875a1dd89b7f81056ae090640deebd65652cc43d4603ed8e5bfc6ef4b01905162b0977ce41c4458c8bfc9db3a26ff52d4832ed3a3814055fcf5b389592fd634ef5f38905d1109d4a57d2c0fd6e71fc1f16dc4c83ff0a8d1bf1b25cafc33755d93ef647769043894d5bff49fa6a62b93d87f9cdc332d986c384e258134f0db8412a679b73c9b28cce4897359dbc46d8ada32a78ef6d2bb3f50f7627d63197260eb81126681c5d97e7cfcfd98398064ffbaf15217d4e3f81248d0a5d45662d77d8361b78218e314232e91dc02e35c123cd3f3db40a1c2c387f93291ff55b4906175909e1567280f69f750d76beb9fe43cd1e6d18a92fdb6838e52aa0bbe094a5787da3bfa87f18c19972a0b29695263b9cde20672e9dd64a4886ac73beca012c4e35dbe5a2815c897a52ce23b9c62ad707a62deff5f86c61798c33331bf26291ee08997fc1252994cd9a722f616aa70010cc02510534c563e16a2d7a2b365f89ac78efa5b8d1a22b13cba644cc1c4f2480c90a94951312bb037668c50c860aa8595a390f5adc85966e7b3e8611ff80595dc9b10059f11df4650ef753a3eeda6ddf5f1d81a123c4dac4ff6dcaf7ff37ee844d566fe9b4b236fca0d7d6547665ce1d556aa32386d6e733955467ba32d16ef3f7a175505665bce267ed6abfa62a1b8d0e367820045375524a8686332ae515c2675b078816a1081fb1c943cb9069be974239d3394915d4f2a3417e0f483a6f9370f65345a9bcc19c4557bf70c5069ae398cc5445216e67eaf291b29bc28a6ffff5b58c05efefbfd224dbc82e9527ed2e3f3bfb6f82e11b56f9fa849c53c90f2c38c18cf3bd153ecb45b3c813771fb93ed1f1cc8be85aa0a197e4aacd41c768ba95939587cbebd185994e788ae2b71f5153f33ab01d2543c97f151aaa08afaf9f9c4961690ce500ef2e698cfbe197a20538774b699ba763852da42ab30474d8cd99b223da45306f230832a7cdcdd96ff643a3381c71a9b6a8e29133484b951f69fd1ceb2c2eae828156938ac3e70641ff8d7199cd1c5f404f728f7a091a06ee7715d806a6ef61a6bac23a41ca9e7be4b10c3426cc68069ab6e6e71f94959b08759363a449df2cb26fcbc2aa3ed8a633707fdc16ea89b0877057","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
