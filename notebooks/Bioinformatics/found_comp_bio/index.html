<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9cdae998108c73b5010c154245ab0f3fb1140dc27a071166bf9f7aae94adc5deb5d6c449994790d51081129d566b7b6e14cf1288c7a07cedf2c03bba0e2df145335e99e774f4e628a9daa23100ee70e06729fe96bfcff5b6897e739f0050f6c184dd7586ccbe5b6dcbf044e9aad3ca1aecdabdf084e50a359d918618ed2c6192df0d671d978287a0f563535c9ff434281c9384a010004f6069743d5bb97f6b09e46766dac66502a04b1a647e1ee01930350f604d3d448fc140366ea70ecd6c1366767d1cecf2da864d8343ea813217b394fa6ba872aa8b6f97487ea4ead5d43a9e027395287c11efe1c1c9c95088ab16f6ec59f460f99d944b472ab7f3d3a101714ea16729cb8c126035facdb9a31e37e56007cb5d6ae9f9f091959a6ab5aa5aabee8f761eb5fde544cb0a1afab2867fe0c3e9b63f4ced07f627fe8406bba4c23062499324602f956da189fd11d9f8830eeece67e52e79d064622caf3bcc8c717fc5dd2d87a77844a44413da313949f42f38e8b09876aae2cc06bf7c283f232759489a85d7769c107f670201f6f69f4fbae22c913d2c566a48265b0247977981f1bf97e00ca3414dce9e2f4fb4c0d24cebb6c808ecc09572230c6accbc213fc8c0d619b3c128fcfbaf6443574fafbf715c05e08b1bc70f64c91e0da877abe4a9975116f4800997d004de63809436eefe9a6a341bee8106e3c09733ed56a92c432f9f518aa5c3c244b4ac417214fe4506874a5ffcb9d1741a3c8f50a8d1cf20a677b7ada57d0e83f8e1d560b36c8f4d2b2226f3228fb53f2e5d6da95dfd8ce5735e44ede10b5c03cc998fca61f795705b1193c32ac6adbdb4135ceadc0c6809a63d18b4541c207fb433cbe8ad93e9a431ded19f3cb70f3ad3d98a9df4474eeb611386064adfccd264218bc304b9d5bc03fef06e03c74546c4521adeea3ebbbbc5abf50a4dda3a8c5da8640e1d97250e361e66fc1156234d0c761e770ccccb03ef1ae2a63f85e830e90491bded6d5dadaae3cb1dd3985811751a8a2b50cb4ef31559db2103b5ab3d09e69afeb72515a6b8196fe9b511e57b8fca947aabae21e5a1c8751e3521aa200e6b269f5208b932818a28150c32eaa8dc892e877064aaab1b700d948f73d4d6b64be63a5b7a2e85a7fa5e4c180fe9fb13069262da658685a5cc86fffbb9ce87d645739eea21752aba6c9f53de33e3d09a6e4cfa92fbd051e412c959a7d8ee1b0fbd5ee9ad1bcc9db09880b104a821f290c32ae739980d9f29c4799e29b2a5b339403fd6058d5eb4ef3284995524684a1bbf2ce35884a07e6360bf7db5ef02ba3f88068cedcaa5dc87a0ee0cb7bd33a98108ef02e56066a49e2030114ab85ca3e2b914e497821552abab60e55914c24a78c3de96f671475b9e5ef6af033c9a994d62c867ee20eb339e9e9e6dee245e8c4b4232b6c68c2f82bbc712f1322d4a565b716a13bba801a857adeee4f4cf138ce64c50499f6d3e6d920e1f327dbd19e893a0770aae40b48c67c02077cef2a913a86ee72c9594d4382315524e831fc78a4fe533af343454032bd76b2869fa0f2ecbe5ef28deea61ab94cac46e41704954c7efcf102b19940a024f9d687167cb848a8d2519ff525456dbba799720dd03b8f3d43647c24100e73c1ae5050e14f7425861c6bac388b9cfdb0d440e3dce06b5a74b18362726b4c87c0b7ba915f3c9ee249ca7626abbd32adf39f55be0ce17591bec746932c39cb46b49aef59c80d32ce65ff2cd045b15dab1e17bc717dd65a188b394e94de225e34aa525d3fa7c71b98f02ff52c3f0afd91f16216a870d50fc0c814c0d9895e796e139386e21f19e8e4fe597e0f61cb5aabb1b398834bccdc1afb4441a1ffe748a83ddfdce11959c5707eec9cb18420fdd8d3d43a93ae58ca4ce6906eb819bc6d18ddca6acc64fa6fd4495e77adcfb10a4959c60ee46f7b4f7ff72020880e12cb6cd83f6e5a86cbeaa165f1fa2d3e9a703aaa43cb2ee92228f2c1338203b134946085d20e0793cf88b6999ddb1df57eb2a16f2f35d3a691fbf6369fe88ed1c3a4365718768479a97dd137a7e3d2cf73c47167bc41984226ae6b4bdf90d3d74dc8d59a8ddd6e7295e55d2a139db0bd078c255c3e6b268ff53544f2e4f84895669b1a8f6b64f21e812e17b74eb688b10e2cd2a90f9c6057c661291a18ee365af8a449c0fd9b0a7af2307cc945881fce585f4435ffb07c40a63835a091fa6cbd890b5d33340985864525c4cbbcfd18fbe1c2f597ac452b2f0b4ba9b98a65ef87e621df57b5f61b2d3e2f7acf0252cfbc388282eed973228ee9d1e6e3be77fcf52893cf511b8a9f443adedfdfd90b75851e7106c0190fbb5404d3f74731f20b8065a46a6200ca6e8a446ee03deb252bec5ed66eac69ea0f0ef3cb06c9e14b88e075410d632383c62d6b894c21175cd6fda972d16dc4a7f5e6bb7015b4f93670904032319e29f27f26878663ed4e83c6859bdf08638c40b1f01396badc93fce75b0d1812fd8ea74d3a605d0bfbc06cd038e48f12be0b9f17d5359f807d3bb5563e9d853332a48d94f8e5e8908c8a04a8943474bd27f003cf197efb5cad16b8f913f11f849b3c8c6ecd47837e377aa07298b2b559338aaeb699b283dbeb0053514ea60e5b9b7dd6ae54510c9bb51e326a03f0e619078541461a90326951fd56bb4f31461e586bc0dfdb5c743a998abea835a410482392450b527340bbab4e1f1365406e48513251514365d4e1824bdefb500375ca2496178286e7b8aefc8a895583bf10c72d0b52fcd88dc0f87d6aae98278308cc65ed7a8e5934587a960e02440c1f77a191b9a9bcf7ca59d2c28c17eb4923fe202faebd1420b6dfb8de1d9408298c40f70913f7cb0f07e71e205a6f1a235a0665170bd89b5a13a24b7b8f3ce9e8056c5637eec9d8700f2a0f79c481bcc63ebcb0182a3943b7abce1726223e7e6f9cd65dc16f4d4e40c404a468d70fe3ec84174690fc0098f4a6705b8abb5b909b9e83dc74f13a517cf9b3c87b02da730620eebe8078ca53e9d8246a50870bacef7464e77684c28184b20552349af6c12a7cb5d7667992b725aff13f782b15d5fb5a5f121c5a7663f559301e2b145bcbe7bed8b67aa8734504321661d738557ec3a69f1f4ead7c87fdd7146a66b2b00a5a87c8ac0638e2812476551d4ed554836042f697dacf174104e1e023e65504a526216e446776f51a15349889874d41dc957e412844d03b3d804bf5c508be11f5ecb0d406803255a8a88dc7f1c4f1a6bd593d89e24d46cf9d1584d23c72f775aded6885610883e224b958ebbcde4d9d8967c1fde6b13604987b42702b1c9785a1070214679be1e2c990d0e975c0d0145543f7959693db294928aa1ba5100880599f2211176ff1dda7f0143031b4847cc837df593699ee40e1bd91d41af9dbb935ebdaaaaea02bd5f3c8187615b9090d4d8b2dc8e76a497106832f25df4da66be7fdb44afea985d1649e57d946028e781618007faf3bbc26721759422fbabab61c17643d7fa18cdebf1f7e426a6cc68af00004fab963b106dc7d69b82afd298700a47fda4fd1fd9fdd61cac300e592e19dbc5ffd116474391b79343e112d1cbc3b103f4a7afe62516603f715a77bc62441a420203f07fde604375405ff86fb040a8f6dd69335034338c9271b7ee7bbf953750c9abec9bc2a896b84c2861f77ae14a3937eb037b6fa661a73947cd1357327f29899d143ae5492faa116c9a24c9f77134947c75b6385d85f7357fe74950020b3a03a1cab04a9228912f6bbe5daca6a73fd6630c2dbbf721c18409c50d4ea432c566965e718cdec813f90ac63d79a6771fb097629a4424bff45d25353a9851a7cede8a84acff1b907985c1b383831226adf17f944f24d9ddc125fc546c66088a7dd58ab583bae6d382c259ea8e15b9b54b5f8cb68bcbdfaf5264363d24ef279523b9e3135f12eb7bc50e793bbb4c4bcf9252d7937c286ffa821da6d8ae8512b267c99e007cd415ab80f64a442a5bc339d95fbc79faf9bb76a627d619275f91c839af3c0cb5f3f8fe50fd2a24ba90be6ac73fe2f9f44d5653168f98b1eb7693b9fe5c21706d2361ebbfda076cba1d9b6b1a0a8218b874a1b48c894562509b18d74136fd0b5108ac535aea13074d699d4cdcd269f3ed27e3fcc607716376391a8bc9b70863e1677bc3e65473a972f1c6e158bdddf29f96d7508d0b0a857522e5a573e7923842f3a663f708495458029f61c3f925aa2ed324e4accbd7cc7c1b88ed8999f118afcdb18cac6db72abd53a0f495ae0a5a6f2dff4a5f064e837907af9ea3a37102d682063cca29bb1ac53d77afdf013133d60dd1c5e3c4e0227708426e59874108c4ca6b3b64c9d1d84884086fe3f07bb18c3926b8ac184328874c5ded26527fc34a08fb67aef161677796aac9244b5a7fd17c6f86d3650a922881f244b294228e9a540a00ea7da2acd83784a028a33ea66f23b2da53e4cfebc729406ae5c504b753319aecab8a3276ff76b993d82eb3af333e2280c53f46dfeae9594963a032b037af84f556829fc053f02290b7ab5a4e109a947cd02de05d24f3a37225dc6e42594b30890a4165dbd029c59de46ce74a92f67602e38cec4affb01fa27bb532430d223414b906e33d0fbafd733a0405b2f419335e4e915a9a50387372138d5217a890d56266655123fae697ed41bf0d782429b9651762b44f3bc643e3ef5ebca5d92758ab59adfd0c433ac573d90dba983eb3c87b0382fcb77213aec0c5082d30ee864e118f00dc95f973f671670e6966f6acc05d801ff09856ab02352b371f761449e7b7d2e3aeda27b0689db72636d7bb5ee00daa621d26122b939d812c74c9365a37bffc66c8b037c7743cd24f0ca4897ba0308582e7f63e0d71f9daa17e82e0817c36756070566e3acea7510b64cfb4344e3438b28762a69dad37e7a75037ad24b73037dbd4395a4256b6a8d9ffdc3dee3492151ef1837db1da60096faedfd46b3119e95f18b551a2de70371ceafb13cbd9fa25d6c728331e85b5af05320668d448cef127addc96b0594032762510f972be6c1cc99a72029dd40d45a407db88921fbe8d859234d57086e054db8703be5cba6e1e56c03509f9603a8b7d0aba49ae20884cf0c252fb5487f83995df76e49aee29a039dfa1f61c568c1c9d3ae141a4e70822cd5d04dc617c9d7b4f3d7f7fdece12615d43c61384bd6829bc6197104d39bfc578f2cf2dc22684d1ee83cefed0dcb78aa0f1d07a53a0cdf3952648f5127f1af2e1bf6598a7df31c3df6e7bf830504ad463fb173b73be0e2cd08ea4cdc134263264483779b6dadf3d65bd4899080e14eb64dbecdc4212dd0a4b3a18cebb5fe2e047dacf9f0d53007fb7a524606c30bf144a8fb1f655c0121eeb457855c36cdb8aabeaa98685c4a72d7b355e5974a3406ebdf6ab2b4b094a27ccb15e852572ee0e10383ed215f46ef1c17b3a97c31c8d314f44d8f17b50c033465ef7f871aa76d5fd618d4e456d86047bfa7bc3c11fc3ec290773d55518d076d26f7a6cf1e7e7cf9290a2e6ed469e03b63b4dea50cae9f6afa82db9af5acd145cf323502272fa901bdec1593b9b7bb3db0db99bc56cf267c9d5eb0ac953de89c3a25d0e765e65fb8d5b4e5b516a93bfce5fcd386464a13cadb2266793ad6d725920adda55f0b155c9b4e1ef3909bd29d9de4c24cc5994d8f25da6351da40983c6ed82a52c1c9c91e37975132685a14d111c214c36f1c25651f0a2ee68a3555ec615ac37f6e4b1aa913546da15efa929ff7efd7dd4981930cb771b862ad2d25a1f166baa3c420d7660ded711212deb30388118a34ec89b3d7b58d908ba15d7f16729ec6d14e51a6c2f96a026190fcacdd5a74f87a9048c39d9b02e7ca40330992a534b79f5969260e383692f27a4d538e3469bcc945f7e3fddfeef47a627986b3391547abec0c704145b2d4230da62a868d0dbf9abce95b6032bdcdf8a9d167b7ae6617d1051c03faa2805beeef018c6e32f2dc7b97f9f435d603762846e9a98602064bcaa3ba0879556fafe34bc30a9ac1d681c553b5bd39bc823d0de36e25fff29a52cfc8892f36e8dc4d86fec81550c5cae0b82d42659574e7c16c371b484373d02d84b6ef98a30bf0a642baf5e0bcca4d9a460d9e5db05c883c9f78ae6508b1375c0dd13adbdff4f332889f2867fb5b922a837fa54edace6d8b119f34354708828f4d17ac71ba8239eb8abcfa15a98e33680bd92343d1bbd4441825b57b61549f6b20f8b44fe4f5cab62ac6c1af65d78ecc748bee72e1988d31dbd5374550f826b7cf98ffce97bf6aa4aa2dcea116d160dd25085016b415e86838db06ed5e0751f9579091f94b265d9cd363b64ab954d13c298bbbded6a5471fa574aa9279f8ffc9f3c865d0fa44ed278b42fb10c840efa0a311e0e46195a428e658fe8d3ea3d93b9868a07872e797b39baa43867e8db84933de8aafd7d6863c23ef755314b7c05c0ff4b53dbcb201b0f4734c525326c1d37354d9b41675d2252e90192440fffc72a4b46cf49378ce69be9224337db84ba6d78bb14705b7dca184d40cd54928bc9d82887c876debb9d136a6dda31ea2d697ccd9b870b634d46debbf9b2aa06c5e080fe9dab8723a68cd6ef570ce1ed087d18e7ddf067dbf20839e2492a34ac32a6b2879432df7142bb59d039e963bb17e0fcf7b77f84d4efd49f9d832ce05be577a44adfc441c343f84566e536c37578d458a5fe4a00bb8a96369e01c72b1e61bd4998a698b998d5178e9f76fdf298681aabd1b7acee5cdefab0c4103f1f547b0ea97a2ece158504065cf2b2eb40009756717d2e56b3ac00f363b8b3706c7835e6196527ea7876fb6cb6803481fa7f5c25cf6fab27f372e72ee1de86573b5b48b82fb2114db89c1977e19dcf074d140de3a614e39cf83fdfd370aaca87a275c508ebc052a3de9f759a915fe36ef8884fe70c1b31081218561583921503d8a5e7c46ca1719ddee65fc35283ce7f81a5007cae53a31a22c56bb70da37f8810744ec6b6efd5f326b439d1f3c1912919dbbf83cf040e906156cde759e14bca867e59044d1022b7a053088fafaddc3b7ce99672712368a106e1fd19ba6f7f9d219bde25fb895565cd82e671386cf36dcbe873d1577239a21f911a481506c2f17e66696deafbf572af3aa2b5d6affeaaf0290c43b319a56f8dabce5f5f4af16759b8fb22f429616394e5061a6096be66b7665037cae328b35aa8344045d04635c3456e1d1a98e3fef96ee5669e6875e10b375b7217e5d564657caf45266266da864f7826c021f0c1ff89863316a5a45c4b889ed83d789cbb95aacd01253e6143295ab706f97aef91e82cab20da5af2e1738e459e3b265239c5ab88ced4594f92eb8a6fc39fe7e169955302ce1d88f824cb258c6c664d313a8fd06f1fb7ce347634834a227de5f276118083635e79c9b7b1b46d22acced408720723dfb96c96a0dc2ed48cff12ebbe4a09c1f14fb219923c6cfe52cdb049e2d3f6d5295e6a959cfc7051a68fc1862e1118f311c0e98667c4f3876f215e9021a6a72a39e1d78ffbde276ef030da0b0f38a37988293e9dc16bb7c6f1ed7216876e8a97acb38d08d649620cf70cb33f9a9e08b471de1239b47dcb348eff445bfe3e912a82d2ae7722194d91c97d2124f3edabc9cd457d7c644de393a5dcb0c9e0bb8b5855db177f1ddf5cfe15bae89f6b6b88b77e448cf69ae7c8915f875da800cfcae0446fe13b212e37c5c2131d55514090f7899cb6416fdb97156eaa71748d7bcb70648afe796faa966292007b3e42f75748bb52adc7c8e382a00be36a82b2f0b1049b881a16ecaccc1278c923cbe51ff1a1d3ca43847987cb7d9e7e7fbb39526554e9b13c1492f6fc167819ecc6a02923fc168367e3b8256cb584bca971c4b2536be8a2c528874cb6d3a3ae3f928e2d41b5b74b6701223928bcc2f6a43732baba847e3af3a19c555e35d23919d96f29f0f3ceb02ef59411b8ddf710f2fb1890062baa04ef18687dc16cf4440ef560511f31c0d546e40f7158acd07478185e9581cbb6fdedb240969bc938bce544084511cd059575b1d64f07b42f72e0dc8c6b6eb9222ffc0cf2ef9028282aaa23edb900e0511f46667b8ecb8b6c76173a3d93046f7a011406d1883bf730c3402bd0e0b83b8e30ea398de29af4ff7cde2e9f3a45ed41b2bd683cdb8d9b032a7cda19bade98d9e7f891b25363fcf792d4cad849014483dd953cada79b6f048aefa0cfd711fca35052d508cd9d7bb48e4de0a5e74658370309599aa9f75983679326725a4cb39a11d304bac1ad2fed56680252fc13f92ea04a125cbcef73154eada1131096df7be4d61eb47e505e63ff8e940927732e7421ca0c5d58cba60b31bb265feeae6a850652a14b1f7acd4e92255987c5a47950d3080f0e4e44bc119a1b4ca7e8f89913b153e0455e6e436740fb5db4cb1b931bb59925265588f40b8f6cbd5c64d494c44deacca1270762969e4cbdf015f4709c61dc7f07b907945aebf5c3dbbc8777aca4021e6bfa1a1037d3a34266ac266ef0adfcf6e18f50255252f98c4a488c6872cd43b9692dade0bdf36521122945338c47f1529cd54be0a4f5d0f61a361bcea03a44a3e0aac3ac1e1cbfad44cfc3bcecc74f51cb52f21043c609990b1469a68883d768c8fb7d85f3a6538143402902eac99074dec8daae19a023c3055932e378bbedada5531d08e561f9ac1fe6fd18b5e877f6b8c32e929ec0def003470cd9d55133c5adb605b52ba75d4e8bc0c82a2cf3162e8c77b7a1754a7620fe2ce67ea26417349fdfe940f8b01eeb6cef2bd4bd908b09cab29165eb06bd52f3de5d6c219962c9b74af32153dc5fc5759beece5c1a642f5ef63075ab72b06c25d0f0bc95aee8889aa36602647ec67aa21b6419ac1ddd47f026d7e3a714121973ee66b06ea0829402145a844c9e505050dec96f44920539888f04adb4f764de2501bb11cdbcea40964b95b75613186b202ffc71a74e91d97542ee10c86b14e535f00e5950fca197979a37ea906ff0fffbef0c4d8614bbb19d2f864760937cb72a22790e79c208357f4e3954e19f75ff8ad5b436258053b7fca63826488001fe07da63d8f68940aa95d4a122971c05b3f08cb129d28d95478f97fdca93181c16e05498ae13deec707f6cb3d9eb863748cc36b885d77c38e15b64b95b9a448d779499937635e265c451eb6582fe67b2977e8fa7c7da61c40c92f204f3460fa93f13ee900f389fa830db991e4073547f2094978d898e162590264ad6709400ff65c6f88fbc62a3e87dd805265d62aa5450840b25c064c28dbe28142b02aee378a0d07ae770b61890143dd459fee7aa8ae12f0242e482bf880d42b79f77cf4c2cff338a272f269f4b7cac56165276ec6991106efdf030f0599b8480d3eac6cd0a2d67f67f67997178c2166c6e67f17057d5106fe6a5b007e010da3edb81dd1fe1f1f1dd142ef3fc668cd36a73950d8f364974f67d97ae3ebf5fa408dc2f910eb043ecd8be19b204cdda5fee780d521c46dd9c9249923a17413a2d54e6c9b8fc7969e017eedc2dc2aac08a72555758af733f04fb9239b6563dfb35b978e3ff0309cafa44b43cdeeb1dfdb876dccaff0f034c203b6a6c5918aff28e3b9821ce4103d83be96a120168d80b3c8ccf839958ae65f599420f333fe37b449588827eaa36cd30baaa1eabbe2c6ea1bdba77c92aaad22da6bee634593c28183ceb6a54392817fdedd093db73cb0cbf4b7310ed557fe808e9241ce0713307930b2b744f9b1a3928ff9935381db27d2c5f3a4da114ba9a738aaff1a9e986dc5553ec461c1067f1ab15cb52e122f0ddee5afcdd7baf22532613d873c9db8d4fb47e06d2d88b56bf435c67d807daa66cd4a38be944d807f4473a543dd88065b5a84923ddddac7837025acc0c4cc6e392bff52166f1687ec65a329d9fc4dbe3368f4a4501753ed675bc48b8fe11c192854b39488f21a8ff5b8ed18583534f77d9fc59b3dcfd7606848abe583f2bd50fc634b2f880751cc4816de11b99882d84fe2125bbc528b287d25aec96218e304b4b8c4956c94750856718ebd626f0a01ef3364c4531c482664a254c2bd6dad5be371292febc0112d535ac4cd4ed152bcd93b5c4636c62f4d3b7b600ecaa338cc7bcc22d54f2c3b008876b86dac40730940768f190d74526eeb0955c88ece38a7a89bfc2e66a237ba6e1354e0cd1186204f8c6e8fe43211e669b055f65f887eb1eaaee27ebb528dc9ed2fdbfaad8d4ec5efbdc973ba3a1acfd261940906132bee43f49ee747ce1de428296de0e0a8f76dd032e520f2426d90fa6e751eee17dc769a71f45e8d50130e7af84513107aa17c65bee34c08b52ab2fe87cd62e001444808549739f50d0f0a813df7c0dcfba49b72900553ee43569930450e45ed8840c49f5524fb264af11a21e7ae03eeaf3cb758e4380bbf45128f99f47dd7394348882c0e46f262bed244751565efde4c4d667a821c5832ff721bec1c78d76830e402c7babbf885e5298b0e17272e4b89b04ffbaa16931018553ead7c4038b466aba1170fa81cb9fcf1af4bb43b669ece77014fdba820f57462f18b2864a643715cfcd1db4e55299cc4685d712075b35d23ade6c71a8925063f4e1a7819631e47f7b5f62f1addfd533aabfe79d58b70bfcbfc11523aad87705713eb339a7c02107d14dd16767908ccb7731e2c31abb8a4d0a8cc6073e49f641eaf7739d62ec8f8cd9ff25a5fa9b487e1916ca9fa04c8ec6afec9f412748ec1c2e325809e99aaed0da3095d3501af29b2d963ca2b053d6f01e7f9b190e03e5ac85c798ac8a0aee1e931d2fa1f1ab9b16ee7b672595b06eea4b1b623c47cf815fa1da623e6459c041065384338c9d2bffd0bc800d16b25eeb785234044bb3de2740e3fdad068720546f99fc518b3aa562095d7f64d6b9f7e1f97e24cfb8f482871a6b053f671ea4807687ae5c7fa9a97feb1775958245009d5d87eb8db362859df24073c72ba4483a67e8ddd8424a63368fdf4556c89d2f5d4f0303b932456db81a1065cfd3dab19ccb486ef76fc82b2fc851c6df0abdd9f0acfcd05ee961cc80219de13cc50a026cac0311a51a31e2b85e519c78dbc142c7a0ed19f160ac6aa0afb1b29600f460e3fa72afeb5ffd436a4fb58096fab3ef5a7c5d75c459cb4daa280a99d487497ed9d1f51637be69ce42b0185d46f3cd6c8ad9985fbd290032f011955c5bf041c016e7cafdae3931e508dcbd19df60e1325a9bedc3a40759fc9da7162f047e8a598a29eb33d28d14c7a30171ff253dca8890b3b0d33a3b10b1a900760895b6040a3f6dac03648baa82a63d586118c9ca5449a3bd32271ab4eaf3a4f140d88d0b1a70bf138f13998f53c48953833ed3cfb2d51d81a2fb919ddfafc30f2c299f8176f5e5fb953d246fdfd002ebadcb693fa93b4124a626711017440d12c7b8707c5cca0a9ca073e4b5063455e355486987ba4b048e58b3aa88fc2391383830ca4b1cc37ac36112186f76fed560e1766c3611ba611a179468fc9f5d0acb1df71ddfa2470385044ae8e7fd67d02e5008e51e60f3272cb22f775f91938c1381765f7cf4a5220efe93db4c23055a70df529be8f61f2eaae727217fea2c08e0888f09b3a9c73493d5df637e72f6daff21aa0a68363c8f338fec44ee7416ed9e1f08da54aa65c77756ac2e96cbe81b9261709d520f010568f45262423c3e3e743adcc197a8b33682c022f8fbbf737558c5d6ae77b03a7fb2d291eccd9a75a025a4eee19d47b1a7191566585c79efc1999ebeee9313352da230c9a50b151c17bd5e345ad08c9c0de6bc25922f8cf63ca250af4e824859feaeaab08dfdb918a66e82316d80b2f72af1ae6e8fe3d9a274b8bb13ead72f22645b4ae283335d8483f97eca8ad8ac428d8b39b2dbb46e071c1fe4e52fd37fac31f229af20a398786ede956f621154d5cfe03f5f6e15adde941e915c1ec65c61a92ffc5b4e8cfb907110f815b6403d57fe5081882d3e4ceddbeef4c9b1fa23723a0bf03f8c2df99ba807da66cae331b662500ac795106091cf2234ff6f0ecaadcc2206b76e2c2ce09d9eff108ce40d8065f98b5e9a753e08f69e7d8acf310e24ec0a475415a0652a084159f8c136e99016d3f140f33b5849b4bf82464511847e1d460859418944725bf9e9eee474e01d3492365cd58527c21029a3634fdb78d2e02148994c4478a8215419386eb0c2ba5a37a94da18fda57689f85f33330415c96a94b7aedf85ead0fca7af5ffbe973214b8edf8d609e36d065eafcc7fe4bf48c7c231d43846c2cee392f9182f7fae0ff381f867521998ead6db951d19731901a3055549750d2d92a255da9e5ed8cd9b07cf87f8217e5fdf65523e9f35d8085248121d2185220c8291229ac692b4b1b8b327b02da7979d4d62ffd324b2c90c3f2c17f6f19146ca275137213c2b3ada66262ddf203fab1a19644d9a557708168c9cbd2681a324789abb23e8c7222856e2670d88c87d7d5bb7a030aed0b75895ded6853b5d1dad819fdb8cb0a47ff60e02e027cce2bc7c792f7b65684c119d30007a82b99363c6cfcc0bdc11b3b89a03082e526f7beb4997a3c71cb961aee403f3e3398c6f2516b584263f186d2f5b108430454069110b222f286909b744ec38e2f1642bf9aa1f5cec3055324b2aa1bc56ac20bd85634759ad46912284d2fa532bc0efe7498aa66f498603bd2974e0f285333f81c632cf64961a4f54a17e2f7e623d9f72c4a7b6b0c11d9e841d79eac285f79f2bfd5f99719f24fac5ad84e83c09e7b90fd4216ca2d5f9f33789a5dfc3dca50713de7a33f7e2f836b9c788db15e4bf76e3376faa78c71e4983c2f7b494d0a592175ec119bf3cd40804d27e7c741a72b80ee8662b14eb2918aba35531431195b1ee57aed503e4e965d1a23c545196decad453c9ea1f158604d54c6f5ef97017876a02ba1bb90f48539c332d222d7e4efb0d122ba8dfc83c1db9af7ddc144ae05dfd867de33c9c085e60d4c0f2dba8f1610255cb85d4a701fe40d1548d3e0eced7e1e4163836d7c34afc88a8ce38718124f82fdda21716bbeb887eefca5b5c36d7bb59b3eec25f24cd7cfdab787d3e55520b4d4229eb3720e43e2c0117ab1e18f33e0c7253c5edb12125813afeee02d7364dc957f8cd57a46183d50d76c61454221f18b6c29add43f7cd22e0863864bccb6426fd79b27ae7c3f4f54670f159c17d9be8e8c0405a8b1057472de63c5cbf9335a91713cfe93b501b577a162aca3ad7404110603228fd1f92fa5dae49ba4f3848bfe91145b17cf852c623f92da52a1c63cc2bd0fc1d5f0bb0be5158ae60d0db8a27e29ac4723207a81949c44f7266ef9b49784a0821957ca104fa75acb88228e68f2cc3d0dfce226d0ce1179d6e379e23e83471079ee3a7e4d821ead5d07a0c37ad7dfeaba154d5d8f81a3674f48d2708318b5325ad6ee32a08d82175349315b6283b16b1246ad979e0ecef39bb3996ae950a8547be10e9e8fbd99c4b45a3a02c5bd32806fcb4b3f684db13be71651a007bd312453e3b0a6bf019736de6569731661a49e8f593413e849cdf53e8ad4342cf6826c85ef0f14ca613d1ebc8540515b4c018b511d04deac01a0f18de1718ef00d89e783d08d62b95bf227c3acfcded1fb2e9c274be0a9789c5dd247bea43454675c0278087ab88c50022fb5f1eb7b5dca104d33cb46783a0fe635c69738e9df7602b085ae5bac14ad4f2ff16af811475603664ccfb42bf0f2ed60520bb20605d7fbb923a583b8cd930671ba94f18d1000cbfa00f87ee662a282b02dac9982825f825749cdd64e2b97650c29acd168909d2d908cd34c89fbbfb1b38afbeaf3d96080eab62704e2392265c1c0482d6001c2b5854ca9478ed038ea6a2e9aecdc6a88b120964445c010bc750d3a57654013961dbb04e57541a2e46734a177cf034c386eed03bcc0031c6a50646596264672c40bc982c68c070f031de9853c64ed9e681c3d25cbacb229543368ca29e305174362a51d4ffc05415f74cd1121226f963ba39c93ce1b5ec399739bfcbd1f648c87eafa1e42844b05cfdbd36dc21df056b045b483a79d4da4cc4089eabb51a16bbfd15c701a5aaa0e431d8733add9486a8d16b39ef2f7b344bf38a6802e4d6e903c5c9f71de994b0c07c43ec1a384ddaf380d55d9fabed950a78d9bf57a13b814bd2a25f0e6afe86993bcc28635fdf3260d21b21a760a050c98214ccaca90d12ed6503401476888eb11ce571d88c05e86265a477453ae38c8b12a41206ea7489af3903dc7b6adfaafa3222f8a5fe7ae735fd324bd10d362a987dc01b5c81f6e70d72a01c3d04881968c846855ad42c9671827ad65a15b63d9b3078034daa591f1cf127080f4be8194852e5b127a2805fe55d9055dc86b3eedef7190c81fc5cb973959611b64059e3961b6e90b22f9bd5edcd18d10aef2912713dddb71bd632029060c42685e2056c7e4f39f79485767dba9f055d0c95fee889ccc9aaf03b45e23059b831ed564889079c50417ee6d269781cfa99bbad0799d9e6df4e843623f02185218c689e096bee43b40ffc46237fdd9b2839bec4f793b64c1220a8c9c0594091021762b5d8cfa888018668955ef5302a8226dea98bf500a3f8b4e2375e632f1dc97e934e2793e047ed18f0b95142b06fd7c21daed1292c66bd5195c23dfccdfc7fe860f16335f846a1181e371fdccfe7e0e961ded3c4b26a0c6f15e1695aaec0dbae661e1233e66ef7cc0013a4b78ef7c784aa970a46ce29de446b161c2960c1d691a2fa7b2ce085724424857afe3f6e5e478cf7091cea06e47ae0923430011f9c9dca8b078c1677af7f03f45db820896effd1820505f7c7bcc829d81859466992f3608d8c2a866b467f0823d0514fe4721c8b5a1b6a1af71adf5f573c2154f85fbad89a7f56dacb74f821bcbd62641c19774a6fce6e901c1321e04c53515e5d4a4508b7f8f1b952443e3e8f5ce4f16c150e99d21b22ba007ad1ba8e1ce9c0e05af3f08e8a396a53d19ab6721ab0a60a681962942b579ce24aff531b3dbd68575468085cd0fec0e07e0906d3f79f22307f13345875bb5986b222f92e8efc12205a4038e2bca622c5ce93c0b0a7c1ba7863b3a34fc8c9e7ba53b56f44eb355bc6366ed70033c4b7167cb75124aac869bc1889b64eaad1aee52c630bf65103ad94e093cebadbb8c42a25ee97d3db7a2c69fedba576d4fc60bfb3213f054d7d5416f623cbfab669bd17fa44b4871c8de52b57e719fc9b27a031761847c4cfa78a2537a56370a7f92cc242a8e7589675e9f409bda6bd39674f46af49c1f1e4ea1d27a599fcdfb50fee11b8d9b6c7e922e6f34dfec03eb3e8154ee31f2b00c49d1424ee43ea66314169616106ff06978cf6e1ea5af504da299c6c8782056c5522356467148faaacfe3e9d3abfaea96647ce9a71cd43a350b2c2ec1c469ac088c821a327db1b4ba6929d611ab9d1f52efa7769f80b765f193eff560a381abd40a813d957d406f0fd7f4960a2eb142f2ab3425f29e6dfd54973d439ef3476c82a2f2c1a5d04898165d951630782ab8d94bd70ef4d2aaa90ccdd89702c8659e2303582cd31d87bf8fb5fc0f2b2f85710c61a2e06ca3162e46d170cc7ca63d4d064a9491bfd082f629c64fdfc697b178992a47604e3e7829bf61b6a981c1464929867d878099812727dd3a679ae8b03e30b8d04cb9982641f337edb4d9f057c1c34618269f327ca757206d8f8465736eb4f58433e9b60fc64e6d793f2b0ccb3c483537fec129778f71af5e003d18e21f753a9c4221daf8ab4394ddc03f5968b361b4dcf88dd7584a619b15d4f55d7043f03d2c47586fd3bbd2dde0e0bf20b21138877721d7db74a17dd8650073da5837fe38cde6c8b44c2f94c0aaebccfff7b480a02425263cad2f737ac456cf025dd9218fa84f4ae95cf0918dec32a8517a619e63572c9521ac1537f7e2b26cae603d6a8b0a101fcca1ef291df6e0576b44929e5323884b41c0a2abe2227c74f1b8c1659df73e736cb1464b1ffc81572de072e9133e3990f87b6c43e0c775405db311dfeb1ecb2b7669723490446514a19cacce9c94ee0500f35aa2f8429b1c69f55e9ac04521230820bc32c2a6ae44fae6e8a116a180cb22c01f66430d14511a30066510c59eff7b0e0ed01133f9243d3ab52fcf18a9edd19ad584a89813f2127673b2f270d6685037c47a7819429f6b724675201c2f7782d87231264003f7e140afa000bc8986ae214210efc5502373df7290843fb0d475e4b6d9afa51dd7c53217c45448d01d51cacdf7db740bb4588b6d099416c050808ee5521126cd0f27e6c61a7930a268382143a3bcc0a3898d3ddcc83f7ebc320cd35956d06fe8f87ab4f2849d8cf97aa137c19a7257519be2fa128e961a0c49f090af0e4981a9780bceaa8ce15b1595d6bddbf9140df5e39c99b27ec17be30d0360530b8e164e488bcdabb1fde6b77d203de1245d7ec5bc5e4c1f9904c06c498bb6d99341b2297d14ec8094175c29be9956993b3aff70da428a9d3b8eb87f487e5f0ca282d519a3aede6778bb5f0a66755a5330aef71bf9b8ace6449ce155dbbd55749fc659d1ef3a71ce10f9a28946ef595ffa920dca0fdc810bc480555eee0d697d3dbce47b3ce0d8c655964b2d39fc49c24e216dd3e58e669f2c8b8f4de5f6c6054b230a680451ff29fb3b80d030cb8fc03434c04761476b8961e485887254cdf86b4041b67a11a12cb5c42dad6b648a59046d07ecaa8b0d61ee876cb0fed1dc17ab2723da207f33be2baab60286310f41415aa7ac27f41f45fb192ace5914f18dca6c9ec4ba379f79a067923edcce12506511f9fbfbfaca2998489f89e964172af76f3a129c34a751ee1761fa25d72a85b1ca2e30b570b1727aab8a44d19e8b614a71b9795162287d46cf866987e9a7ef77e6a83aaed2e934edcd71ee4e2d5bfc5bf70f37607d755870a713a8918d67c6ccf41dd5931814bb578543a92d2ee1774eadb66a1e241c4752b2e1a1a44c3fd1efcb0cd93b0cb416355a4a39cd64630d8d8ae597a057d39ff9401617d23f58afef918f5708544079d11756b0d66d7dcbfd45b86d55e41537bb6a175fa463e00dd9478ed8e4a4288c853b82a5b15ba12fb38d117ad8f9a195a2daf2ca670062aa999c8d847c3427b94e9caac85a6f845676fdcfdd84d0eb5879b2ffdf75c2af3b2df1ca612ef80b6fb982b5293c495f7285eb8827f0a72eca514298f977c28a2bb19a5c1de1bca576c7478cca621ef98aa4cb77ebbe868d01e914f7880c48e2f9d3a3b5a1e64a9ceabd62d64aeaff29530f729b8af1d9fbc3ec48a2a4182f69fbed19870a03e3a2f875f3158cb2b1adddbed64e094b552964abfd1faa17895d652bfeea829c1087a4fbcfe0b3ebb7820a4e8fa7d3092a666d3109cfb79b13d0473797bee744d1465c5f1917bc9a3d1cb5ba9397b9f5d1021be6257a99cb763ff1f9c7c2694ed244b28ebd3e612ada6207047c17088cc5782deff08521853c45d88ba02abdb54fa7000a794dbdc3d629e0aaa13b16f4b7c09bbc2333ac043a3f0558b8da3831808da140076e72e8de8ad5d5347f09a46c88c72c26b4f12d1fc078efda6a7db3e281fd9fe7e5e0664cd5db4ecca85ed41c31740557ebfaf54561df45869a48389873b19a8b4e72bb9d7c204493479ef137ca42fbc77d7c11a2d6cbb4fcbad4d141f54d3520c4a0da43b63e04b46eef4a63f1ee9f48815f4138efd79dfd800e9fd3577ced8517af6f1c538b08656ee4fff1516261e2a36821ff2fb85ffbb3be075f3f4f02e1be1cc23e7bdacd3efb34d4fc292ae0e869876e016ace89a8cbafae480807b01792fe76781823d95c5d235f3c31e0637ed6a1de5fabfc631b36501fdaa8375a71b23efe9a58f2ba50171c3e472c06fb43bc1943b2de8fab4f5ffa295705ff9bdbc63ecb91669490ce66bee6123dd4dd1f2558be3cbae1ee809e7c8ae3b85504c69a5bdcc6de707c5fcfc166977cbe34898d50ccba7d6794f5ccadb0295d7029394925f28be9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
