<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"85e5726a571a4691114134cb7cec76aa13f1f1f8e8d424c655b43de6e820d99e1d153ee157e7e6101451a85ed3f39331f9c669b73f151917a3a42a48e6c7ac6c289d7adb18f3266714c79d833e012a25d4b192f33167406329fc035810366750dd607fa56214178c0d18f5324c404a7101d41be2183617da30e80bb0dc248c2da0defb963cc006e8c808922f5858d361e2f39998ae4f07c558dc694fa8466e228dfbcaf02695729bfc7e5612e81a0d4d702052c32c5b5f7c30ef1d8bdcd4d6e4d81d4c346075546a6b1a5082ed02894a342bb937f37a95d2427f50c098be033e9a8a4aa21714afb201ac26413724a1d9e5657ac705c206b8fa266436436034e7e2c98a547951285a5de487d3abdf28cf230d95e07810d280c889c45667d1dccc01133cc735ce4f73f295f9931ae365d5b793dd2c3aa085d0e28b56575322289dc928d61b60fac03d95c7def5b1390487b709340008eceaad2d8b457b464ac74bdc26750d2c03408915ccef33a78f1cf55f0de6aa28171c109c1bdc91c8672c6b9887e08a33f9437bed5adf9e5b86b3676d47cb2cb2e2f9f45fd72266df9dc2b336817b3ce6c75e993ede019500b2f0bed3b32b5a26bddf0e3a0cba58b8bd0a78a931de0aa679702103a34f22ca1a34ada88e8c83e7ad463bbe06b888a6e4397bdb0e1bfff5e7b5c2c02e2198e7bb4c70e951dee06b58156ff2c3de6a1504ff88187b6948f5e7556b4b59c49ccbed572054d8a1379230c4ab39201ccc9661069f24ea59792e8eb0c1cb1a987a5473cb69cd252170811c1ddb811598fbed0bf45334d144797cc0c6e527310582df054f7927d17d0fd53efd6ebad4c13a17bd472afc216942a0bb05e832aeaf885e98590bc0efc12ae30d6d423c0047ebd2fa242b55fe53d4c4d45d6c0b6db5f23b71b5da143a3c73416b402e439fd8669722c412ffec5abb006073ed33f284f6c8cdcad66e82d068d3b485b29beed1a02dd4d4356c7035e42ccde5b16cd0ed14673e4b682485edbe8802d80939467b7012b54f846a1a773d7ceb754bbc18b99e196b5cf7e768cdf2b237a9043d709590506505cc16b46b7cc6fbcff924b8f45f4e751f98cf2774ffa7784d83d2a44168ae0e4e4fe4f91356ae78260972043b036dd59eefd56208883f4e7d5def729895c598a87c454822dfbce7212c979ae0ddd3330fe6bd23fa0425b0338a5d7f46ea3d8b39c0e43a6d13a04d83029b4dff90bc3d42c1b714f15d61dd0010bff29249918b60a4698b0fe9be457f8efd72f5b38fa983c0d9f01cdbbf3b78cc967f9e062b9d5e43d8f5dc0b6dd73b7071a42546fdb4ed3955975542d26d0783b56f34463c27ca3ae6c9b81b9b5303ac56eed7adffda94107b500038f4d265c171918e7155fb792f39f9780a3cae3da6117eb12cf8cce7f05f86c802e4d67ba51e3777bd7cc28758881e88495faa2ac5fc36f34d5ec5b02cce5b6f51ff0dcdab32615be2822a23585e2ee707661fe06392dc16c12d106888452585be0b52faf83e752034d14174a0745c6707bf62a5467095512b4eedd515b664196b49a64d56dd8e9c39ef75c27e2b18ffc47b282fad1c7ba68daea7d75143bc91633c5c08879f654b4a7ad7b130efb1e9e1dfce24e8308a779098d82764a16fb7e0d69c76cdea1476648fbd2d0c9c0c8b42ecd5802559f5cadb81c4b59573764a32e64c6a54f5723caa27c53010b0b0a0bff96bfe74f1d8583692dd3d263119a49f67c8916f4c0c035087c0464f371796edee23f4b560fc5b0ff80beb5fadc1dd3d956c6e488fbe354c55ad4293e8b68c609e096148ca13c46ecd1112f24f2ac04b54d60d8f786f15de3920963fbbccc4f88ea03f7ed71751fc5707e0d038e4dc3f43da5861fd02c8816bbf7e7d70231fa3571041bb1b3807b2fb6dd9699cd98a6c6715fdd06540e816432b7a2e500f404e85c67f485219a3ecb345e40198c9ecd11bce877cf67fafe2c2381bf8a11a36974b2f4ea3389460bb669ed99100d325ec8e48105236271b829975eca4671802b6217474f922e8a849d592f005bded50d4c0510294ee92148a8d9e2a2eaabf2c45f9f5f2a5110167a312a609b21e30f4dcc3864cafc2c3bfe53f3cb7f52157364f992ed6875b8b638e8c3edb9a5f37f336f252debf77015bbb969873f918cb7f2e38adfc03e294e6d41aaeb5aba4a925c67797820cd85d3e6baa78bfeb5bb44e48d9e8b3acdee18db8b355ecfe41e78da806f4598eac0e9cf50ea5cd4902b37280c38d377ef4e84fa649faa2b0e9720065365f3f7f4547da7552aff152ce0539fc3501480c6b119d03ca3973bfc3c10c34896ba6dd27e0b1a83c5faf9354be69e40a52ae2a4ac41cea9b3089923838538da1b4578daff1e5b2e6ba92c1c8377dac4e4f29359a10731ca11c380f4cf18cd54984d400b3e447482c64c844f38735b15885d43513e0e4d78c3f0337ed4fe69e07dca62bb01f358d7009cb62e1f9f76381e954d8fa3eae962eb9ed1c4a96d6b032b8840137aeeb3e3960c3f5b0db8c14ae09bc4642fc814f20606121407ffe1556538e6821cc236770281d71846fe6ab40b8f3efcc575bd6822aa4848674c5cfa1ede42160bcc1e7d3ee4f8272089d0eaf041e7cb0b2d5413df134158067f8467367bee30846e5acc8d1b30b6bffaab1fc5c013bbf14b2b5414fd15336728283cf5bf5f1b3387d670c3fa361ed985127386f6694e0809a8a2a1ef006fd0d700b1e1170e3e9f225a56855731739d916674088e8e7c292aeb9649c183dfa2af4847711786861b9cb73721430802c4d46351c78d5f6dddd3ec05ed7810ed57234245be1de3bfef55e86330e064c8629516f7e8586d9ef2c8a25e6a4a59f5fc650c85c2ed3de89fa61c5e69eba7a5f285ac0fc8030122e13dde4a580bcadaa49ed5aff1561b195afc8701ce1deb5b83ffbd086aa38924062d577fc0dce86b61b6195f5ad1a309d5b71abe5a928412faa32951293fd0c37b0a2dad8f65d4590fcd60276229426d057d28369988e41e05fd8aecab90b2e9fc3058a9b626b66921136d5738163796d4b3e322acd24d7ecf49a3542a03305b570058381ac737b1cf5be622c80a8df04c907080d8e7f45acc5d1b57f9356097a55e11d06567198222ef454d9947af747cd6c566b17b24684b981f064e4313bf73c18b7204ee191a12bbacc6c433f513d9ae212d6e5a9721e4711d6d9bdb7931fb9c8d333a270f2b4ebcaa664400aabbd8d2595adc3fdbdd16cb098752473b92969291d8a5c3388cafeda69b8ac9617bb553c59d461bb66db440b00779f5f5bfbc761068a5d37ba130b21e0b4860e6ae4c25db5d6225421764a7bc74d98e945251a65d97640797d0d56949ef443eaf4d331e452eaab1847d5a82da691f40f4464688d95dc303ac24e9955f88fa42453ec39a74daadcac101bc7cd1f94c75654dc43b45acb4864d99ea2a20bead20c8fd6873d0268a41911a527e56934cfe6d0e89c986bafb2dc3c98898cdc59d75e90ad4a0d93e453098ed41a267a46e1b91c9a8efc9ff604fa043ea15fdd803f7069935b2c4295ef583431eeedd43390660a6dfe5cbeb9744b5e96110c84396856024b27d5dae2709877f07a83d965312ec46b83a6080f9647f472eb44cd9acac4c5023573b5b6a11418655b5df919d479b653712a0e6de62853d477a67b07850cad63e002048d1c23ab3133e2faed8b8ec45d5b780320b0605bc897094ac334cec7b2049ec715be5385416126ac58b2112b368a19aaf6e8cbb9c94e211198dd8ca9ee82f14f8fe3ae91e5c64366f1400c763606f5e4e9e7009c98caa3873ec3b9a06b828b34f430b54e4f56e1d377bae6c5ee959df0c59733c8d11dd91ce6e30a40e19b14b5ae651b08abbf052df38e01745c6837a38f92825b7f01445a53ce4487acdf7f27d4139dfae1028fc617fbf1a2725e5c87bff95850f20458e5b5b13964c808dc8b890f201832afe7c8023e1c2a2b415b356fc23b623e87607f584ad50a552533b369c76ca6b146a0d0210148992982413ae777b5c6166c8e3226379c661debdd3d8980e9cc1f883207d8163fc3652c38c1732a9fbdb28634d848c56709f2e0b3aab2395534fe7ebf16a7726d9bfec873454138eeaa16fc8aa7c492112db8281331ddf56044e8baccc907ee6815c6205c5018c497cbe36e63568237aa16fa38ad14723bfdc04c241976d67cf32352660bd120093d2804732fda991398e2d0d3d9eb4638bc9bb37ac003a5bbf34002a0734b69eacbbab15d65bf0ad0d18f4a374a451ef998ca29514c6f72c145d7b9329dea0451000c59b0e813629c14e79d2b53b0159447c0123603b96cb8ed405bd5015168bb75441e51cd5daa56c3dfb8251b364a47e91ebd53f03aa67067445f9660a1f60bb1cfa1fdacf79344099f3d8e721b95eca7c32ab68b9caedcacedf4d05b31938076dda22a06d8c2b5933aa6a48a29b6f0b771bc4b4543c07f5bdc0f1fd8115eb01cc5694fed5263f8c2c6ab5df09a22ba6cd8e17b1f09b216052c7137f5ab3341cdf4ba598a8d4e40c3cdd139d0db043bce37aad908fb15ffc7048f719f70efc41125960ae6daa0bf9f968cd311355753db6b5df87d8a6cab6c1f53a44ccc5354f65edd58c5a6ae2dfa0288fa0362d353638a7191d75539b7a9caddb9ccd71f140d195c70a81ffcd0ba11bfcaf3b25904b0065f2db15f1ab928e302afbdb9507ab022da72bfb7f88c0bd78ce7b977069ea4dc963b0fef780582f8bcd8a055c72d0f2612dd2201ad14692cbe93651af3bc6a07ddffedad92ada723718d9775f778143d677d273251e379a99839b5c724ae14b0c5480181b3bf8562b40235fcc8628f11ae5d3ba494091447857ddab4bda94f331d355c4aecc96a3a7c77fcf88fe4a7a77cdd42dedb1be418fa16b98ef17a65e42495de88ed9de5b1c810519d2a393984fc9ebae15f91cc0086a59a0d05cea467b48223d7116057319f8e939ad059db8f8575a93ca076132038551d7336243305a68dc25790c529a27545334b0b5c6de2471850154be75b5fcea372d082c4c5419133b1343b39600e404c0a0c3b073b9e590cfbed0bb0b04a0f3d16e3584e2397014a34632648a97a300edd82781af0e7701e115bb66d64e61d6f115b1f7061aaf135148487d5ba4b57785218a6a8b5edbd498072940e390264e9332fb9d0c507907c30c4f0173085bc245a6e453bd8be1d816ac1227d6612f3d8765ce2021dd1b33fb2e57ae98593d7ea7f7cf2d6db3581f54f3adbe89b038f746f417e4ab68aa74ffb0e3d38e57c2f03ea8fc8ae8388902a3b1b96e92ec2270d0ce0039ad83a0512fbf1df79554da8c8668d25e06bc8ee3c7c037edb0d96d0d4168304db0c8ce8dadac17566b81a27bc1ece7ebac4d8c1eab0a450f104631321d377db410de72808f4e07507afa912a97de690e34e615a959b34a2e448dfd7b69e8781e8779d65eaf8ccdc2ff2b7cfa1862eee4eade18e47be8cf997eed855a792641dd710aa965dd3d0e711a1b79c96e1e3b67b32f0af5865d53f3f3b8e6dc7b3f04ee4e07a8b727e4b5d7f5ee920076d99c3dbe149735c6a6777653780961a1d187dacbf8859b0cf4a356ff81a3862ea33aebffe0e3057a91c3359116d23576b6d222ec54b72e5e81770a15a1592d7cbbb0fec633cc95dac8d77c725c2076a79b1564fe306a8ca78d38be8509ccec14f0e03b3b987203a319a8e444ec4b979356d8d16e6d8dac40f97ed81e2b6f2a1e3f50be0329960b7eb4a107fc3694f38cce305b71eb93ba8a260c96d4670cd6957d73271f3e9503587c1c0b8ca7f40eae3351a3488b1c1bd6265560b1575b3d4d447edade0f87e8ba69955024e54744aa7754e88db6ca3993133887ee74d6e568fd398c06f9feae0e4bbbb2f55035397e6b36d0bb2e2b129750070714bc01b92dfa252f116ebf0e62a94697efee7ae2b8c439093970cbad646fe50924a7a245db5b121beb547e1fe365dfa871f941cd070e32b7cd8156192b1489830816d40f15a2b621a2caf1c41fbad896fb7270ddccf30347a8463e06f9a98e59469e6323a341b3f28ea441e0d0b00a1da7e421b33cb536077c1b86b760865dc0832a90eed4ec08ab1d25737821edcdda03b169e20b1d399023ccfd52bd9c9995bd3726007f17ebf718012ca9f49c6f4100720201c0bb81099cc8c885943f95cdaaaa91fecc9fc05c1cb23c87e51193d3202c28b4f91458171046c5a0b6dc0cba4acf3ea8330270f125818da05229169c3e31643b4d57fdb40a47972868d35a1d89844439d4b6882dec1ef738f8094012848851be47a8ee32e0e47180af1a6eefa8b72195189165a81bd2ee742bf6fe26e076b6884686cfe7952aa0aef379b088da6ce35ea9ca79f87a4e49dd8cb303b879a002a9fe32a504ab85d4128a33d75f2e3d6bba115a9495e2e100f383a90383ef5e3ccdf4c81e5c690ffa6e048dd7c777aef525347648cf5673012aacb71e7f7d9c2231f84fbc78c5628cfe997a08ae81679ca6d39eefa11318fee42d9be1d6c870e33b4ca02b1d171124e04bce730f80ec5f10935a087d29609d484f29ed9ceb7805781b2f428b6cfbef8f2078062d9c8b82ea67d5fee0d99a6745d4ce12f9febea9c3ec325639563001126afbbb268b319190fa14f826f892480b4de52377b268465de75df251ff3a06a7d749e16429e0892118643df957a4361c20cbc58d54d090673549e11ee237c84c4e4deac4baccd704860ef1159847fb463d28aff0e84f3e7f3861b843afcfaf40a7f8745c8a8284ab35b2ebcb16b8cbe09f34d678ad36ddf7f35c48d72b64d08b40117dfbf19e4797f236d207105befa91b0698dcec7441fb1e41a56cd106b233350c2e9ce439b7f3b0f1eb40f36a09eea7b74fac7a5423c34785d7307d3a2fbbf7aaa9c5053395ce05bd8ebeef7470f1878a958916899081fc2e349546e96b47a7b88380538d0872f7f451eaefb7410d6d10001e01418ae76b7c6833b394e5b3d50e7bb62be51e705cad4449c4f50723e45dff89f99d44c9011fcc61be295a0f5ce332fc5c969338f595807f30954c58db7cbc919e941210322a100a21112218fcf6bffc4ffb8e4e78ddb1ec2bf1c7cce8fc87cf52b836e268fcbbc130c14b20fc7bc1b228b3e1a4b3886450f2abd3126a5ddc4cc8dc85752059af0574ff83984df1761ec7b1ac6ba0149c88d143e631910b36534d95f656334403d04edf5e6ec5ec5ccc53d9c548a777910715983480c995953ad97b2bdf4d4001f23fd29c093a0168e19205176176b1c47aef88406c233a74ffa44b1f276ef1e3f177cfd2ebf20f38e5507199bf76c6f6f41dbdea73b92d16d059819f63e4dfaf19b322188fc5069060b4965b5e6fc0f2605aa1e4cd21e5fb2e8fffe39863e679d8c0e020f3f4d2efa4d7b0975b8b7fab996d070806925d740cae0da5a4566d0f3b25e9bc4270a0b2f4951624a399964ad98e71eb364a0319cf7f8fb0dfdb588d38d8c924d2a042c006997f0d194eb1c8237b04ac024a27e6945ec99da9b09ba02343bd3b1bbb5cae08b764e9718f0bc88d8d1111e789abc0f6c2f3d4cc55aa2031e0c7a78d406ed4263bdfc9537cdeea55c74862ea7b8865a7dbede4d91da5ab0642f752d8ea31cb01dd50d1ed1472ffdc10a6c9a373287dbccd865a93f9386e842b4603f9febad13f52ddb76a01d80afb8489313d89c9417b4be98401e3078969be04690b4b7ec39ff3996fbe879e3cdf6bcb52565001d6bc711f9f2b45dde087c3a01b0a44b9cc42bcf66674d1a45e8a6d002416af09b1065062492d2517b64465ffae8146071e426e8d3b4b6bc156e500e3f8887da0f823239ac3083913c324e82066f95492c337d4181627ee306e6f3fcf9747a68479a10288a9d104a0a83b4ebade0dd985ba720cde174edb68458c3908f8af07464b156bebead9c21bc8edea92fdd76bd9164b1d6d40a9e4a444d4c26937bb1dda2b5c3344e84cb4846dcc8dd1582545f089a6c5a779e5a2ad9f468b4ca091e1007883d85caefff0ef8a6c2455610c91b51547ea5caf5fa1cf0546eef6d00bf52163857ec2d4ac8bf8e9b6aca5b661885d3396d220c29c9cb537eb0197e7012d5d02471ac12012fee15545b080a8b378c66fe9e30e51a93a71aa4653fc8ebc694f6f9092b95335b99a27d6d0d613a11c060853c67d7237cf56b3a6105202e023238d8fc87a6b8c7e7b16c204d0b447c4741b3b1ede21faa600b59e0c0becfb2341d3f4c7adc6a9bb4ec6e273b1c41388194bd9914240ff50804b2286313c142a2306ecd38c196b0c47ba8c4c69bba4755af7846152e2b875520a14380febb99af269215326d728663265e75fccd0dd04fb2c8fd28613593c26da5a2b4dbd64d050fac1e909f9d87fddf3fa98e164b73a51afdc87e596962b7fe814311e6410c62fcd65b54bed14868c7a8612473ccd61ee6ef60f4d25202c25d90a81fa1000ddbbd5e275b6ab310bb61bb6e0cbdb71792279062d4088939df2ca84903196b765acaf6c1e700faf3a94506a6387da840af04f738f0ab9c0a68bcb984b6046ac9d9ef6e1867795533811598f186d95f91b68e298d7cb4c885c40adafffc2d8eeafd249d2dc5d0d988071ed330968179f6f17b709c581a8dd817bf00758c39e9c853d08aaea17c0a96bc3c43d2ed697d7bcfeb35a73c2ad10f40656321f9d276263bed46f387fd561524be5176b50391b07e25ac40e04965b236eade243076a20d0b50de824936ec487909c6bd747038f438255e3ddca45f67c774d49b1e6131ba5c7628d5e1520bbe3d2050767d50d354ec111806264cab29f56db914c0c602b1ac77549cb1bd23c9d3fcb61edf9b86fe9f0a10fb22c9963effcaee0ecedc94cfb4ed67170be9e9620badb2a38d67a02f9a932d015172d0a9082f2c93affec10d153286d8112d7b71a2d95b5a97009d084ad4eab456021561b7158df362cb0c5c254325a1a14585917fce688ef0751a97512cab49ba23d3e14d606b36f18628d7bd762209e7872a0bd9d3ffa99c0b411a31a9e946fc7931ae5d3db82198f2673ee733fa5a5045534500ee710d8b07f2c9f086f76a83e30005da588af2f1b79156077a4029539ed13d0d156c0fa327df5c95bb8eabe5f3bdcd13e4b67f6cd56b7342efa105b6acd91863d4659512d8303c0b8afe9971ad013eca713045424cf0506f543025612601f25f543daa70b6ec7d94afca103a8c4ccbc08970ea222a3788f3d318a6bfbd529a6df7409a85757be47f0fbf5f31b27dcfec8ebe3c393613e49aeb409035133d25813d5ba1f9e64a427108bdc789e73464567461ac414cabcc128941788c0422cca03a1e4ea801d08ab7c53b9b93b8bc60ae599b6d6e598e5649f3ae61987994e2ed4d84fbf769bf1cf433ab0b71e032287ae75cde44cb68cf7585410ab827154d90c20f6a67bf51319432324dea610595dee1174fbaae6a7b60443d06643da0932725428f19df8ae1fba3cff7859010a55f4a1d2e260032288f8894943b9f9f6cf8d2765bf2ced3a8e342e5f2b89f25c161cea5503760953d96b469d602d5215110483b8b91d1178a982cf1db28f36b6732fbf01e66bdd699d4bb25d45cae7df990a283617c19bb06e81149a00245c393df676e4daa387cf331cff51f39b9af1c858cfbbaeb0c182b6f2eb7480320347e64f88814f20fc3b9e227d9100219e30c7b57f62ddc021562cdd937c25f96e249fe917bd4794ac5b4e681ad4b4a5150f7caa4c867bd2c0333c1f8f5d2f9dd298a514ef84934ccbddad240f0a3da0b50d9755fe80bf9bb9a5cf73dde3d7dcd49e99ac65018b2f2bc756609b7f9f70f54cb2bcc55b249e2988af75afb1f3486671af27ca8e7d214d1876199ba4aa6ad9dd4da2bcf915d6dcfd1cc47357d3db53310c69782efd8058feca5c669182434b818673a649ea85587dfa95434c500e2a346abc7e3fbecb329a02839a0f6f72a5184b706f41749c8d579bb70d82a36eb0c67bf93bbc19138a68113566728e45d731278e75f4e258e3b07ac10abd864afd7e52fb5f1ee5faa8792121469129c2e0f49eda210e8f7b701868194ed28723e5da1934f85a7e85f26fe287948b3ceda8953ccf76d9d2a3689ee2d1889c5aab77f192a605f317e4d4eec0f2f1d9b73b8e3eae7d13483f5b59ec460cae04973ccac77485d698e9f487390358a92c8927157db5798650a55eee69e8f886815e61534767deae8aa84b17787c54540689e32b61f9edcd1f2065cc9db04de419e4b95586ca42ff0c4d291f114bf8dab65fd22ecd41996a35aaa115a4b1805aec6cf5f317537c651e495bb8fc743e78767d587e1928bde88446fc678e8c5e31eace73252db3b26856422e941197bac8009d17266034b72d5bcedc171ddf234b8ac6ed1cf0f6a4fdefc9ec790a988b10fae13158a4b1e3afd97bbc74be5f5dd8c7668fd17dd8064f7f62dede992ae11c531c18981b7227c4052ab6591b5e2bf0a97226321dd2f9021552d5d1fbc992f7b5a8f47faf33517bb26e9e68dd2e83f38f3ada170a0fe321ce29156f9dd42bf2ea306ee0f1ca7e2491d367b560ab650d821aa292c482424256d21db10b01ef7940b377927ee16a56c2a7fba9cd2ad10a51bfd28ac440bacc0abeacdd6ecd6cab778b4944f5251d33fa0ad86857227a912367c119356453d1f0edbc30b41286626a0d9e5eee9dbefc09a0e9f1907743fe7690a36968fd0b1370bd668eafdeaea86ccc271bfbb384b18ad676bcdacb94d4d890dc5332048e669f1a75c54d66c1c686f41115dc0284718429b389d49e5405756b26dff33a62e51fac943037eb39e0d317423e9d44a98fc5e90bc79555c924bff6093d722af1e008b379c332805dbda86d5f03feb0b16ca9e432bad254f8f6a1d547c4e59928d39e385da379a0f1638bb807f3429c43f1b0a0ec69769cebef67c75566caa1bfc6b35c9aa92e8a7d481fe256849bf6f2e1054127461e4f6b64867a4860322525a507813a5577ace28defccc62d3e3d351a1624e435492c804e4c826ecef87d16f05e7604a3bbd4b3b924743567fab33f1e7382359d53c00c1e4062080022be26346627276cfa6fe4063d1bad0284cde67127f40060f41719d3e729f97950f57241ca7201c1973513cedcd594d6a4b344bc439f6471e7615ff55e4d2114d1e94b4d49a59a6e632a74feef6cd8a9ee871e58a4ba49c06e5eca4a2c47f302d270cf61cbfb2390528544c9f3169adbfc634876f9c3d7017c3dde44a3b420c2271adde3b5b32b0e5c177b352a20796437ee21905305652c290d4700d1861aaa7b87cce875e8de21bb45688bbe5241328943aed2cba982ebb9029cfc5065bac18ef70d24893a272240ca98745c6cf01f5da255757b9324220250a4f358ae71de0e0b1e67a3bad143b96058fa68a3cda5aa3b5cc36a6aa0725c43fca4fba98f56007d8cdaec74295be38b8e2b327b866e8c2410d7bf9f1af132473ec559bde6381fe48b153db1d9b7de75f9fa9a73401947ec3603a302e0b26d2968348554f286255b3e49f61327f898238fcc000c4e2dc7c3c8cbb7fbaa5719a239f46ecd166ba38de66e26ae4f0b0702920a5b35809bbdb0f8c79a9b57d1a827e593deb20e9c2517dec32644262a203d579d8d71c045cf4a1190553f122565acf31a4968e806aab8597d90e7099d1f11cee42c476a5d291b2a4039ab0e41c76cec0df2798adf0b96b1187751f18d121129e2d91fadc181d841bee84e163404c75017c6508b00166f79d052cb94f4445bf0bcf6b70c40010380a0e4dc0f5533f84d6f03f6935e368da1b33fd15dad2a92cca3c5769d86d5bf450d172bcdc4d7921ffe80534bc5bf03128af7d2a150ed5c1e988d2dfab18b3eeee99ebb476920a93d4dea82e23a411b8b2aefb400d9c8066168a3f9a5edc630703156cb8f597ca9fb33d9075624a8eabab2b247c84a906700d95102df81ab96eefd383ddc27b464f6f9e3c77648b3b6460ad73204c6c388c5cc3a8e0e44320f635ed1bd755ee7ab48ddf1d8d0aa71093c5699e7efd3a02acfafeb1b826ea4ebd852eebd30cb7071d50189585860dc54ebfe75e34fc7c7ffd3a00e12bc4d8c388e618fe208c5ce4f809f0c1be78a6e2554eff1bf246f81203a97e8475840f3877f4cb09833686149347221d062d90cd3f2b2f7769ff49b8674bc02c77ea116d74c33d3b97f4fdbda7413c6080b477b889636033af01fc9e40c52b5f2e25f91a2ed92dfd77ee651ed1dec522f6a05b5af5ba04c80d0d3f4ef471c37ff07658ca824fd5a2551f7c756387e16770c29aea8aadf587fad563915ae13c8852eb8e242014649aaff24acbb5cc50c2d87d4dedde34ad01cf684d907c3fb1622fc0c30be8fce6e30dd5c88a0de6fce4d6f0ac260d4e567a73032f59155f1ab07b459f2ef66beb722e9278e19af54e66d423cb38bf6f95fd20d8454cee40a920c3642c0f512b6b2e8da4a761a2c2da8cfd76c0dec676bf4ab619677e4db9c8e1c6bfcd32ec3c8bf596e83e2396b4ce15c205fc8a731c5c3bb6a7ae1ca99c9d926821adc74f028d282b2f1ba80ff4df7ced73c775d8adbc20d8cfecf41d9e5b1ecad65ca2fbf7494970b74a5e6a4558af1def4be713907f6244922356f9b3dcae90f566166c92c4693ce41c228d5dfe5c12ee6ba2c6436186ea77c46805ea7a34edf4ae634c88203dc95e09f1aad8c96d4a2aaef61c50455a4a690947aeee04680cf63aa70ecffef3d0b6c14f6376e70817a4b59f07085f03426a8e645f033f5bea90ef01e142b18db3528aa29952cbe98f6e71a69bca57d148f85bb8405d1b87546752218ae7762390e7a400bab52333d82909134520ac25a2d98b2dbc16f4e175b273b916a7f28d1a91df5e8a132e3908cd618a91ba045726c81e98c41c3f7a82a0e511c3b51acfedcadfac4e1bbd0956031b563ef24a610eeab27088547d3ef76cbf594e62ac3167bf46e04dacba0236f28e036aa80ebd12a18114630eb25fabdbc61c6fae3e53b2677d7e2c141f4f8918b6c16d8b257a20cfaf713ae71c32800d54006cb3f06bac9553cf0953f8a1c7fd596ff7f0746de8bd81882d751ab9c2304758b3dab547d8f4f366319c7901751270e7bebb2b7d4cd1cf3bd6cf9ec8c596cbb76e54f7249fdfc0bda03d81aca2e3b4be184c7439474b7c8d30f62df1b5422115cd268dcebda48ddce78ccc452e7c7d6fee968d24799cf52d05e85ffdba72aa8ef0ca37158528a9be658fda8065a0e812e849ae3fb96ddcf1d008f350c54f71fd91eb40f7bb3f36c00db73ab3081380e211f61b113d5ecdfaf67688a3f303019cd9d02c562ba9d451111f05307192073502ab9db56ebede92ffaae3ecc74e61f4dbbbc50925b30388e4aa5abadedda5d5b5dcdb9e11fc0096a9105e14258588fdf7a502d76dfb57bb8ef3999b08c2b8c4a902764f808c4839c4fef01dc7467b1f4f4fb375f4db1d58385de37d25523a566a1ccce5804357f14a7b92e19da456be4d4badc6f80dba56eff29a8770c9678406d8b2c6b7a903789cd2994905ac8d95c363012e8fb356da4e2794796e55db1a8f8222f2e0324a0aa2027e7d729e2055b6bd1c0de20019c44d24c76bf9b1b00e456e766d03bd0b5919dcfb520fc2fd11b4ae9b7fb47a881d41c89e676aad974842a7757a16d3b84e0329f3355511e6f56a35453c4968de1d4178c46edec791aceb9818bb3faaf8328a68c9297acdf461116471b1ed795fbafc1f33c7645a67660361f92f71860cbfbbe8397c2416f0da8d620b1dff6e2bbd82a5b0db3063d2c6cb4b3d2458d73715a6c959306b23b848c39db83e565e0c58367cb0856d5588dae7924369a1cfdfa406e65785b9d4ed43379fd13bf2ee242f3980fe7999b47ad9303411df99f93e42dd692ae9c75577b7a96e591f92c91b2f17c38895a188b93fb7275cfb919bdb1f18f5105d1b65a7cec836b319fc0e7deb4ff59e8f069d5ac0d28b3c06fd91cc225e9994a998bcdf68b8efcf60a9e61ebde53e707b5d63e6feeb4255456e9b905b9d0c59e6c960944eab7550023f78b3861e66df1b0bfc30cb7c9e9f4e82a98a76bb9ca40d02bf29ce74a34296d944ec494a21642b07bee28f61926e1e5de22113a04afad8d510241710caf37f21f8ba0b370ca5018de48260e823a279794096a32cd9d31a18b6a113552f955b6fbd59d1887a91ab17fa47b50d971c68782d4f30ce4e920e120471e419fdf5e1a0ed808f9b529108ec66bd29b1593069e36bf9d776a1d41f2562a0fb57945dba63f8eb910d8cb50f6e5515400fa729699f07809d1c0ca67f78e022f297a52171e9985ce12786d04f0b01b588712d6a339de47d58fdef39fc67077e5b7777bc7ab78a7f97e97b6c5b793bfcdca653c24efbc9f0fc405510da978b59afddf34813c97e6b7d9fa9b67aa0d415ff500045beb18a05bee481e4fe163325d430fc7765e448f5871370f528bab5498272f0d92bc1666c70d375962e71e5abca94ffc78608ec5ffa137b5111843a19e506546b9446a7d29d5801c21f94cbe4a7e7fbaf426f917c80164296cec0efb8f58294225c99e256d2d7e0ee59e8ac4b2819372a0ae4fb7df15d26fc447591f961d5d1174629db299ce620179b95cfa8bd785f7e42da84e5936b32422284feece60e3a70b9066a52b7bfa2cd983512efb1c1c82ecf7c2ed053cdc0d1eec621bcaeded7fb473f8832cc763e735ac14de004c46384ee5cb0848486b5fcfb66a5e305f962d9f3739af2691b8152cc9cf29195a4036976fa0802c69f8c78daa22a9df29c786aed8b5dd1f9c25eb7f094fb02d6433923d9cb0aa205c86933bdc6defb5db83d8a3e6e903209690febac3443b7d3c05a1590086943f22313580d0eb446257f45f2bf3b13f229eb80aa35d0dd6ca4ee375c922e5544a75d9c388ddcca7b1b95e37cf0454f3b0beec6d31f17319b8eed1e8890138563db5e3f13e2415de87a4b44243e43a522a391e8e641f2688f22872390463ef120fdaeca12ffca8a889b6334861f1e1f96c4472d33b04394c28038ad0a637c68be4c01a1b109a88030c09f0f2108af12f01527e659464ef9f7a4e481c0b01e143cbbd6cefdd56394a091b67bb3ac34af49154827253a6b83de540f7a0cde55c8887df8ddcb007d27a3c2ed3b26da97f886d00635c3ef6b992fd20a9854adaabe462b7257541d2e8db130530ac47dad9cc8260ac7dd6c87f75de9040b7d64ccceb8dc801a0319816e3c6beff2001bbc0f6e6c08a9cc26a86a5844c7ba5ac9a1a3a0878e6e5a2420bb8ecdb0ea7da3cb003f309647b5879e68396519ae48b2924b93ff394820dfa9481e4234c2332109c14805d3f223cfa85d37c083cd4cdb1f93182509033fa22123ffaa404db1cd02f6a3cbaf6c0277280fa8a0a79d3f6c897a4f2d12509f1d719127153e99723c5dd5dc0e60336c5df0bde28d0678b7f69e3706bef2fb05b9c679eec8cdf5215870e6ab7e4593ecde6f6aeec6f7b09478726e4099a92114344dd7f41202673a771c44b2530fa97308372a67c20fed17d18d5257ae9177ea2ddc10523a74693867dbb59c38125952a9f75d2fe86dd0841b711a4b6a92d742273ace97b96c42267283013e71efe26f4a2839749abfb95f67023a5c5b8399d7fb96e61d670c5b9296868619df21bbbf92172f51926f31ef1ef69a8e999c8869dbc36041a17dd4caee236fe026237d878ea60ceb6fb544c2c60078a3ae5704ffdf711b64ddc56170c6f2e7a18cd458d4a33a3ffc7348ae470d554338e2fc279f7ee946e5d8d002c117246ead85f4707b3c9a3f0e7317f1a55f3377a742cb17f3560f508d2131102f11d1834f3667cdf2dc0dfdf738cf58cc30bd1735d2e36ee11551712666ce2be9f5e33eb9de3d30648ec19d4a01726212dde1ff53f06bf217aa112c23085829e2e1a8887a050c2e9454203e28d8203ff27fe602da3fccb3bb32520fb7c8dca22ea6d5f5e803836b03b40782c4ef8ec3fa414719a003996945ec030a8c17c00d1a98052fa5c455cd0104e1105537d0f60ea6577434d2cab0532ee0fc370d16123f485c8dfb6d1641b6ea10491e72990358647180832cc116282d827ed890f60bb4faa555b1a3ba8d34ad1d688c4d7ff7283d727aad560614acedb164cb2d7beecd95b130e203e0cf6eccfd0624a67ffae8214cba259909f36b4f8ecd84b33545f3048e1b8677fe4cbdd711201102832f787feea1495e505855e69c4408c317c0ad951fa095e3f3b95f8bd9208f0b97e5df2516c708bf5f32f7e04f87b18424575973e399664e1289a9836e046e694442a588f9d84341ab272bffca98dd610f09345cdf48a11a752b2683efe15c40bd8239353faf5cd9007e52a6a5a9db85930b03abee25155fa7ee4bd0238b7fbcf085e7c91355a65103b00da8cfde8db6c5fa6772df6d28df27898029b206ed9f369bbc16abaf197a35856e9895d3eef458237a067b0fd03d4aa17e8484531c65405160bf55588574782d34c519f145972bfa190b10e283d5fac54f7572294964ac259e02f8c06e10bbdd942cd56a84ee07e792a26242ec7f343745c23f24c542045f092f6ec4e54ffb6b798e28a436d061d29434a3a3ee824b7b9b7b1fc22eaebd8d098b8cb81306454e09cfc0224c6fd2522a4f49124be64518a7a4513422ba9405c35f226914a5b1ddb2d0c89fcdf8ceb80cf2f4215121559b448d1813401879f946371daf7d7b33f1da122b9c4dcb8459610d17353feeb1d8fb0feff6a6f16d19cf1956b8620345a4df1c0d6446cdd4ded1e7f28fd4f69b7728f9ce5f20547fad692f779edb74d820e972efe1981c729e50c224258c2e7f38de873d508fdbf2cb9b13cd808a0fe468f0bbb568eaaf4aa821800191e5eef609817672ba20a5bd12e1e051272bb23acce974fd017cd2059b315b08bf77e2ca3c5bd9314c68ffd3ab7e10cd2e4d6fc005d7e5956702c7661094bca17c8273e990f55a8186c2f7e726c9d2698f5e57afea16fe9a6633ceafca156ef18ed0a6ee139496d1672db4f4d3e831462f7c5611b08661d17d7d191965c45178230e9d9d3d8135c1bdfcb04ac9574692a4380a22c43859db165b52c3ea06aa4d1afa8a768ac83bd5e4ae174a43caf24ad7c62f7b4b200632bac0bdf140dd3d015d70de734349f053a95627e3d7eb8403c8773aebf4aedc9f981ccf47f7ba5141d466a12e11396d61d0224780e1ba365a3eb58ca6e509752d5b9c804c16837c23061be6e2fea0468b95e7ce570054a63431e9de5cd3a80f3145e33367534efdbe14086b5f23bc0a3a84eceb9be473f79e973b312e825ed055582b232e1bc4dd9fda0c001e8751816694839fc9fcb96a9b75c72ddc413899474df90cf129fff33241ad95059bf0ae1eae8d54f39f211fa681838839de053a669d6cc22b1f73e7dc768a7186147c2e3c196dda24b78c5ea7debb2adf4e2262f631d1f0d95ca919f7670b58de9fa3f5b65befd2d4712a081981f8011b6f1a1ce6570e894facc8df023bc50c3ffa50acc0226d31d49b816fdc4053ca71c86e5ccb0f3e4e67c4781192f1d044644fb37f1edc076439c44ec7c83dd41dd1fbabfaf59e68a0dc0b9adc37cbc83d29ef81642c6251251f6e5dfdda9c63b4299a4e9e8a18ba653552c9089d939e56542206394a9463a30027b4363133a36e415e1dec407e4c9945d1c3d967c9c0c0d9178fc83ca01123319a26e9cb0e3ac07495e67c1c9571884516fcd678c690839f7ed1ffd287065a647da0f1073be2a09ceabe20b57dca83bccf21c01c8c5aed2d1812ba6766905283f6ff7cf9c5b81539c329bb6b07ff49a0fb639149f2c821822e1414cc1faf22d67126651566f882eb9bcddcd2cd05060b99bd8ce763e3da90046de9bb736ec1d3f8de0b0b7aecaf79b9769a2c631006241e49614988dbd9bac2fa201ff815925d537165a77e9e742816fd40174db49b468d7423638a4f454d754dd0f999f4a1730a76c1835dba655a4482b6ce08bbc065ca27fa3e8be4bcbc48d10313191f266e41bf827f92e1f24cee04a672061eafaeded1aa839e8ebbc1f071c72f2f2d0278971832d079342516cca106950567d4383f0a6dab512b6c3472037cf409ef1046549e8762dee05356a9f04e4b576112384b60927e8a19ad71e36998c6b6cedb8ef40aff542e8541bd1b2a9c58eeb034810134f4645bdb1fa951eeaf2d2396ace0c73b11f9c1be092ddf2ca3c6aa2622d0c64f6ba0cf70d7360a5501e0782bcdd589effde51f3568962fba1298447055b2da4cdd33fb515a20b2f57fc915cc7364e83b46610b4e0f9ee67fbadd36262bc92c554b68d20ceb64f2f528ae00636b2f44564195c3c459799423be770d65be7f8171bece20061bb5079c3b236ad419760d99794406bbba3136359a864cf606f4ff8a01fbcfbdc831e6d8ede711f796f428fe4cfb947e4dd146c60ae9a1400df6c32e8ad31a1a5e39bdb2787be6802f3405a2f8a52ad741c898fc6a074519e98cc30235f8508a82c68bc03bfda09806045a1045dd100a848708221918c50678e8d078050383aa17450c35e41dc9560e6be673b450cd5862fd3206dcbf1a9674f6267232e55a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
