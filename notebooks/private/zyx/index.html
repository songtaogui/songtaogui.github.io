<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"012330b62fed7241905bf55824e219a870012bfb31382a039b6df9fb3e12aa115febe3ae6c7bd0db8a5e9b51c6a6b17efeb779ab166f1cd6cb3b29e1d3d14753ba10040952d37eb1553432bb0132968a4ac61761665ad6584db10b9c79090b1a2d93f1cb65cb6b814cc1752e6183c26c1a168b5d81acb9679c59b463dcccd218182c8c7bf4f4315d2b993ead9a24a0b1b61bcdbb18d51ef912614c773888534fc9a496b6a17ecc239218df9091f2b61dfd45b32ddf117f8cf8a900f8ae4a7d462f7d7e31fb790946179c04d77375d4febc168439fa8c1ac93a0210d0cb2f2241cf5e2a7ff9910497fa9310361a3e6333b69e61d551b5dfa46c40e555e402bfe8ff8750fa721c6eb0b8bdaf46f60a17267de7e92c64d1132559a0b304844791277d1454addaf663b24b103826663882b0cfe3346d5e3bd98501909a35f780cdc41031caac9e44ca8cd7c691a50d2dd5a012513553ef9013dbcc82f912d784820af7da2fa37517e9f75482e108d2c4c2f229a04af4992f55249b3b9e27360f9c319625701fa19686160a448cfd286355d87c9246c06848671754d2637c80756b30104d6dbc514e3ae59d111f0a35f241c7140782f29c672c05c0cc03052acbe6f784da5dd99dd3e266c488b64b1385abe4563c26a7b884c81e0e55c1b5189b0df7bb7acb3bffab66ef479748d63883e91d82a11255a53c96361c833f73d1cf39e1b9dbe12b7f5b358b5c8425b7d167d007672701f05efa38b31f42cdae547452049a768ce9cb4ba3fc385646045d641c0662366ae65e4bc2c5f713bf2ecafe337b5e590ad9ab3519e2924fe350a2ab48b9ddf9642be69d14c07c875a3763aac11f77f9765eb2892793302d058a14f9bcddbff816ee4d4a2bba64e41d05ccd0f5209119e528a4128b60ea60dbf8b4cac41758f40330206f077aae7bae5b9a127088194973add111d2db2fb74efcee883c73f7494e1f35b59b54d1fa9d89deb6981350df4b765bc5e47f3296f83f985f8770bfeb502e750c9dce7c1b148e55b06966f03153be18a24eb67d31bb10f33966f61224b99c9260f0cf672789ace88399d57bc47f85b3016ed30716487204cb846520f1c60a9571ec2c1ffdc7ac774dc59a1e5eacd67e5f2230af4b67b1753c530ea72e797ccad95737c69b8ee193a808a2ceb7b705ab68a0de9d0999830b17d2f32722a05687abfdcedea635fb671938f0010cd4bc6f644f80022d53c9679ea5216cf28113f9c067e490c9021b566cf736d78162f92c360d84079507a5f3f277f61af637bf1bdc7c29c2d07d78c214fbdd1682910614f36a4fb4dbecba1758029795eebb4be12349e8d185deb73a81eede1ed1553bb9efb0fc2a196c96dbb5ce17e99a0016882c36e9930bd7793c6f5776be94769a505c07a2f6e9776581c83e40459c97679f093aca756f45201dda0ccc424c99add02565f6ff5736575eb5a34c7421ce3333ea69ec0600a5ebb4d3dc1b5ffbf926d42979cfc87a8916bb102f1db38f632ff12ea2be001bcc164b1a5ddc9456328f94daecf4f0ca5c1563cb045f3353e472a5f6fa7b784a82490db2a4b391e3d90a8d29b55e2faae54bdf87eea7d425852032eac955242d06dffefa3ebb1297593e3f6afd592536dd53813fe036a292fc95edece14c381f000537ecadb42694df2bf934dbe08bd87c9d8645ac556860177de2f8e3b731e9b264f0fb6438c6be871155b17dc9afc46178b671bdae95a88ac227c7b160cfe4dd805278a96ac701bc6634adcb24287190dfc5aa8ef023fc327d85291727e5bf3b93c84cff81336277722f75a87080bc598e5666355d8cfc49c18f18a2cc2e02a81399c2649fabfcdef4f1e55c6bc195a6e3bf8c51b9ec944a1008f49b9cc8724c48b1a14e6eb54bcf8f232b33f7e3f8ac7148117a23f41c85232fa9cc39bd62d7435773950e8ff2f1a7301d2d02802fadb66e41615648ce6f7e1a411651c9f72a3a4868c79baf5ca0d6bd45aa14a5a5c73df02b747d9f3890879be4a5786369f893d3dd3e38403621633535d9c8dd0c8029e7b402b8e2e9b5397e6b26a09be72042612254ee5fac3e3de124b73988a49b2811de768e785b4a69c3b73328b1b866c3d33caeebd02e4be09319ee347f2a189308980b6e89947e19a4f3a08d6859dd0727aae24dac8f26268488d3f95d0b049356c2bd8d537769b6911b6efda305c31cf51bd0caf44f47d41ea322bbfc0b75dcf0a53cf284c637aaa8f0ab2c3b8ca2729896e384980258945d8431bff736d958d61d9344667c4664fe0a4a16d1a9e407b762f5c7fa515b4932ced6e8ef7cfef1bbda4de606408a70f4fca4724fa9a6b24ab811f8ef9e6c4a26202e881208c8e6702651b66d85a4eb22e2d3b19298cb767514fb899035d993f7d53cced838df8d1eb39ef5acc87c4d72fe03e14290ff0c4087a8c2bf69058b58b2011339bfb931cb87145bf8719ef2d511a392921a2de5864c0da03324f607220d00cd22f6cc2e68ff23e235cb001582cc238d955019256859824b58e526466615602074fe527e9399388572938600107ce59ee051cee90a3bb3867a092673b9042c42e32fddc04a336477898c0a5a46bfe02c0efcf03c120163f729993b165712a33c10eb22a2906ec154034cfc9c3f663a5bc0495eb28fb8f5fcb8ca2c0350dd7c8fbb9515d3615a24346765d8d30b66db878a1f5469e28cebeb77035bd28d3c800738f56cb20e44e51a53b3b6d9839ee1c695aebc7a4e1b8505e5d8845dddd94aef8add39613b6b175b3852b130aab03c429a25cd6af9e9a8d66d6e17263cbc8c0c6bf3f1ef0e79d1ac79e9aeb707ee661ca7ef9d434738b3505f9b4251aaef14675446410a9d2bc6ae8960502453895a569bccd39f1cfc44bae8487a0fa07c00999e36219a6d3a91e9e7455a8cee36b2fdbf1db000e70fda298644756fb844831ecd9e3cd1f95f5ef0ad0bfa8e048c52c45e00ce61981c3ff7c659c839bd3093b7125803d45f977c5f75c60bef40c38830bcc23ff8a3152ac81ad703f5b0084f0a7257001830224a5b38366d7b2af3debdc5273a4adde850a25f5a99a1a828b735814db65b7a6ee85930c9a59e4086836136c1336b702b732c68efc51cb0574269f3f8e34fe140816cac22dbeeba42907c3c19498bee08039f65430d792649c3760c8c50d8d77c4540928e21e6d0ef3482f1c179f1d2b035ba5e0d50e4b83f3ffc200ea053fc0bb757a4d2a4f7706c7556e754b489ef5b37f13000657ae97ccef68e4a5f105a979637eaba5e26d7b2e3f65c9411336a16151fcdf5cfe06fa4f9154f0ab7573fcda49d658156e2de6e6b18124588ce21daa7f632560cc2360d5f3382ad0e1b5f2f5eaa727ca69aa18429146df32cd66ab110eaacb5d9059baf8a7e9c6406644751b5ea67220c06dba26308dd8f17b76128356657734eb163899bf2ccede41633a1f354d3fdbd7272ea2f8784dc6d816b3e3236f802cb6c10a6cfb8255b0260da3bd5e642353f99fe0b20699ee0a5d55fdac3dba7d7903077e918fab873fd759ebcacd4e2c7cff5ed5fa35ce8d46bb841e7768d16d903276e09dcc15b2348d05e8790b86b6269e4ac95cae9d21f96aa8d6270ffdd0818edc7ab63e7cda47ace6df47bb5af7cc851664b5e611f054b134308b58c88927f8e0ad3c64f3561c9b99ac04e136148e0cb62061b170cf3af8d50d9cfb5c2f5b93f088d1617231fe247e9db3d703926b469671811fa3195a43c509a274d700d2314df827d4034edeb78122f5a41d5eb3e0d00e4e74b0f39d768b12fdd95a9489d0fc7160827d0dd0b01293b4e58f35fa657cf4180601416a8d6646d0584d1031a2de510e2420ee30fdba90266f603ec53b77f0dc98d6d86d0f727f8b7837f45993fea1c1a84631ea9e724b14e6d538c0d10f001a8bbc43161bf134466b2f73e131bc85cec70509fbf8bb36745ab5adc66bf77e97ed9dde2e535f7a513eb8bb7b8d2d1128bfd7df387e8bddd33252060c71549745ec7d8e8f2a7bffe148e8f00457a99e8d5c92761e8f06204f96f2bd320e774ff173203ea0c45550b8393efd7f2460c43259b5d81ff425b00a094eabca82be3534d7fac69a111c30485c5f908da62617156a6a48943502e2229f2d7e35f7f6b4aa56c853bb332096f4c209ae9ae2897f1695206bd9902e5cca994b76d0ef2569f2359d0772bf26fa18f878430653c32c8a02824544fd59ab1276761398fd659066f292bf1f5bdcabb7ee4bf587969243b60aa48fe4072caf937ac2add74b19bb24db69961cb2e596f1ae20a245d0b2474ccb32f6eea0be2864763739a1ea25945c90369b2f7fa4565ca2fb885b2e6a01fba036d95da450c3d8990cb9d34ada38839ddd80216ce8706b57abf8295ef0044bc6cf6d3fdc5d5ed87f695b2670913eaeb642fe032971ecf5c17faae813a7016d5920bd91606d0e210442c387372c2c59983145ecbf2a8e4b79127fa90d56de773c5ad597aa40069d9671a76e7cdc1fd05f2ed30cf5704d8e088a7a677c6cd81214d77a263439e682bcc9155e640a78521a7d85657ff9a4c2ee7303df85345b89cc4435371bff3cbace30e2f33545eeefff25f0b5ba737707926c2d718ba067188e458eda639bf9be5dd558576c717beace1420b176623d602913532292f69296d8fdf91221eb1a60300c9534e5d2a3326aa15cf63283b3503c84c37dfd0d53d0c1d0189e8f50f5e811fa2fc8d74678c369174252ff0f084045214fbbbb52c05a7bc12a88e12cfffb3f9d4d68ce7e3f7b2abb9a5c863a14c64ed8b490e81e1c3f3dbe24d3749d4927ea0d55e7665877d5b2238903fe1f9359178d43befee424d0bd6b4cc04efea2a963d8dd07a3b4978812e7ecb61b7cf9397b294608d6e2664648547a1ac1bce90c1b106a599c0ee74eb3780b1af393d8b3825f6310be4956adc591f3df01a2818efff1914e2cc79bc35bd562f55fa7e32e793d25f96568780f2e117ed9b6def8bff78be4ea3af008ddd984f285f9c86f6250a553588893d86cb883c3480dcb32ee17e353e60df7dcffad1c21ddc893fd6e960822801748c8cbcb048a46d4bc609614f53c14738cb25d24254e644dcc24d21639d8847c32280ae5740df265cae1a6153dba9d3552de870c1f525a481fbc90ebdda11bd1df72be29107e43eba02ff6dbe2175430617052148fac4a153df1667569d4f80a97a3e22c659856b2dea722f2463e24ca3af5c0182f8be21b113eaccb98ed7b2cd80b2bf56ef67d26d5fb7909d33e97870a7449253e49f25a756eae655bd05c0e4d15e3bfa5ec9d5896af2bc94756f2a448f88a2fb57ece6ad0bca47054a7901eb05740621082ddc84421d7ebd335418078215720d89dc434cf545810d8bc3ebadd3b83214cabcb1363f2d9bb51b40a6af7a133a7cfc4c9c265a6a4486bf941d0843b26bb8b47c82b4b4cc2d7f28abc4530dfc1c198d0668728f0ff74b9c659cb5b14710a529ec47a560cae3e841b48f33f2e705a2d217aae2b2d19140e9e3193f76daa0e50afd74b05d49bf7f255a9ff184fe1633b7938deaa7bb8ca3a8dcd3c0edca7086c6f131487bd1705baa0ba2eccfffe8a100f53e78a89563386d30eb109b5775d18c68f7cfd607474fc7a301b2fe88b747604458b05de9cfe2e66ccf708024908218b2198feb8f752f5493eb51c972c7af3103b3c832f3ba84e4ff50868b2d60dd5aa09418eebf4f5978ec05875a3a486b6cef456187cb6e9be6983721effba44d2e54e7938faca4315be665e2dc5c57228df2ee39fb9a15f29144d916a819c80f27280cbb4631af3de5a969e01e6883208dd1327a99bcce90f51f7be574ecefe4283c3e07e650893b00392ff30fb7588490cc8ad7b3bd5d31a5151d13d5c7aae1a41d0d5b4b0dfd0ca01560bbfe5fef63d69448f038c3ce8dabb007c8e5cafe7e5f333aca18cdc23cdccd2416fe7cda3119cabf50aa49ae096020c14c110fb0e2d60a9d714eef01185ad13ebf527f6f029793c0b19f79652cc4ea8e2ca4c99453882ca49e6e20e3b7b071e9bb94be76bd99f47ea8840b9af505839021df3097f5702c5eb29d5e7d88b0e1792a531af45e71c20d294291feb1db3fdcec26d48cc04169b41c761be56ba980ae74a314ce0577e65f8f4c2797b19d33b016f9a0d254e2e438fa877fb7b151b4ec48581b85e17850f71d877b26cb78909efffb6bbef7db50a080ac14d9dd169f8db196013559bb719982c53d3965bfa96aab895e75fab709b1b8620bd1a2bc40afc89f301f068efea08d5f6c7a018c837ea2cc8c3032223b7f41dbc20ebfc76cbca51fa7cbe690071526699dfaabab14d986361c6c2b774f7fbd5a44933ef3b890d934d3c52214d4c8fd6ec8b15c39a0d9c3ba3ae1d9b108b3025754f2f84a7b9b6f158e40f3a839301f22d51bb4b5c700f8201c8a00bcb583960d033d71803c53958715436b69bf0f1bc635307319f70e038dda24d3e57c1c89921ba1812a5bf40a7a5c195e76e22e780ef476bf138d13398b23a5b0afbbb923689b614ca4c189b9c9ffd5043c29e91b7ff4e382c676498560b7b3e6ccf96f9620a5d18110cef4debe0dd30c0a8a501f96209f323afa401178ab6c0801d2bffe1b218d26c69b5ec7272527e7a6bd12468034666314b7b36ae97da5c513b30d9c5683042887be7a2f15c13dfbf3055d9e9eb3e043cbc01d0fe2d36ed63eeb47dc4462af74a06a08d139cd7097d060af2e63f061ba7cdc35c36834a845b2e08ba3f12f9f87f647b3286516be8426177e69010974f4b6bc80d59741e81d6f9bb84f8b7121e0578f3d447637f3e6c9de55cc871b441efea68b6817212ec9cdfac6a401a56f7a15bc53de1de13fa3d284913c35af404318e7ef504768af51e05934548c21b7bec5ef85d8e7478c9f5e586b9d5d3ae3321ef9188d233288ff0b2ff2e45352b2722d0de06f236e598ed4168f758e90026e2734805ee9669f83c9334f64a45dac2e7d3c6fd04f2973486e1127f5ed94ee6fbe9a0d0b11b302515407fbec21926fa13eb4fd1dbaa50f7bccd038ceed74303c8c7dfa2c6deb0802a5c3b904dd1838df984c7ad717d62d9a18cbcca86df2966c63668b07fa0cc26c278362e55207e4fc70f33a4c520a8d77ee783dd9e3d029cf5b3ec514cb13a0500338328e7bbdb1ecaff57d1c71e6e1baf9163aa70610197ebd9e2d0ba4afb0cf97630acb003ae04cfb82fe869f423cc3d0afd58931b8919f5cf82ade601d92900c96c75757411773f5f034843e5f7c3a137a8f72655d4d964add6c0958c3aa982ba1d496277e25c9cbc81b3e798985eca8e5fa87d61d3ed78620ea20f0a5f0218aa0bbae7ec09b98f3707d9385268d6c571dfcbb09caaa17c459802b489afd21d7b7c7bd1554987d967c77f55e04267f452a7410a1a80d9042558ce3f31fb4a543582b2fb4507273d9f930e392da877c12674c0d061064bc19f480d7f190b7cfc70d400251ecc1dbd8b78cae2538a3fd331c75ba10d3a78388288613c1c270e5641974d4ff5e61b966d03e65b50dad3edd843fbbe4ceec6f727830ecb5eba2821b35265de794370b9e18c55c2e04c30d6657e74cd9349e4adfc5a3579fe667126fd7acfe86daa7453af5c38b82b2c477bf1631e33b8fd25627cf8a34ed262bf60743685e9647f127f9e83e297cc44d58b1107fcbd13ae882d2f7f682e048c9e6c234dff03acdbb303fa3f1fa27259c0dfdb6b90c9600eeb982360faf352eb566c2bf3d97418a073ccb81594659f9c5e2a681f1ee5a14492157007effc0b21c8bef6a7ed44400fe506fa49d7f10ab7f9ec7c14652d37d4e8f88f1ec53630392bf51edc5fcebf932ece05b43cc9afcf305ba7be7f52376fca71b74f59c47c95931934930ca4eb22946dafbfc7178250255ced7b109e59149b6b64efb2ff579f418ed16c7ba531d54f06ea173272e06ef5490630c4c17c87a513b4e5ca110cbda0e554a451016031adb1657479926550e3e657cf225a04fd83b75d4a12a2729a52d0e02bbcadb3e41a550467609b5c1df300a3e739d82727a2e58bb9020d6a2201e639db009004b868a0ddf4c9cc375559ccda74bb338484ca784cd695137824a3cbe4b09a85234274cfa67845986657894c61c8f923fdbaec0cbb470eaa73def5d070095a87baf32a798552f32b2b6462767a6c0561014ac28d41673acc5e39e57a8067835127f959b7c1dd62256fcb477791f388fde2624a6f2fbebe9a33eef2a7189755912011e4c670e26e6e197bc98f1ab81531e724644a98f114a053b44c93e32a30b23bc2fed5b24b4cd7030f7b7ed59b9cf239da160032758bcde3a8409757a22366b814f5493b3f26e10e2c33d19310aee14914a9b9eb2a94a564832a038b10f3256c5e2091283a7fddc35a6f0c5eb57e106b737e3937ae88992a321d8242642aeb1ce8afd3c9f4a97fa297c565ecd7645ef447221de7da8514150aae9a1da21c587b80a7c5b4b20d1c9905fcda32b2dda9d3436106d6822026df5e2e3ba3ab8268163fbe29dda72b45e9e0fafabb049693e904d5a655f14f9ec382e25e497f3457df81accdcf92e45cfacc65d25791817d6fd89e7ac775a56807e4df45c9ccf912f3d8fc01c23bd42e9361a06a94af37b53d1ab845ac067c5cf5b4aac07de555bd8bfd36374690de2e5c083d62259156e03736a3465ccad4dab6d3fe904eddfc10bc62f64f485a9d3d58dde6172384a132e9116d9a5ab703b47068834bfcc734984b21d9049cec7734e876a159bbe652ea9f08fe761cca32e4f21bd3ffddcca3402c18cc85b8254cf44958ae5aecbac620ce217138992c2a647b152728c018d3598fc86f6c5836c3131003b8d2c2c4ec01584c2d4c78841bc4a0c9ba97c19aaeb61022756128cf06063482fd9461489254e32d3ab6b07d4a4395363a8dab9bfaa80a648a43ce9dbdf4eed550b7ddb86e122ff27d4f5ea1c76ffcea1a2d613d8a1f5aea2ac3d6e61c96ff867a9cecb015585f7bfce0d374649e3d9bb931283d3865df7c11f343384f300ed5e8898467abf2a690d340855e44822ba97b309ddde132eb681ee38ac952efb3205060390fb606bf8ef842e2c67956e24eab760c38558e4a99c4ca7ba4eb6dd2c346af742af396bb40e20ce9262ff9b23c4e3fbfa2406e065f7fc88464f5065f93c33a3cd61d940b385ff272d0cfa3dfc43dc9ffba973f2afcb0f9ed6b3d0d7116123a9adfc6ac8b317a65920c047f0e100be69d6ad04db6933d80b6fbce3cbf9bb18c94934b078ebc7762cff9d3087fe0526eaacc1ad7b39c36db7f445d2e0d81eeaee5f68033372d87f49d0aab6846f3616b17167ed3a86a4d73d6cb0466c42bb9c08b9053a181e5b9f48bbfd00da960a0acfd5f8dd918c8e53bad8df782baf451a00ede405431cfd0893f1507eff46afdc464132291d425cca025b366f54bf1e1e930c2a5cf5b1d2a63b12c15f436158c470529d93d3c98f44ca155b7a3a31dd441bbd2424f2bc76eda923ba92c2d4ef45a8ee7abbbc690451f3e746356f278980dec067215b60c7fad450a612abf0f73dca2096e239c437addb066a1242210a7703f30b676843aee4d66a46f1566acf5b965a3c87cdb5a7a08453c704284ba489d2eaad0a9e8bf65470bb5c0560822197a286a020b4ef2768a3d50cc4413973b94d6c15c1ba5faf81e91559c268c313bf16ec3d5dacc44fbb9b4b72c8e5f896aabe131d422e1bd565f6c930418fdf3fff021a65af286a7e91cf23a441fa95c798d3480ba46ef6e629c1633b211b59031e48427aed1441abc9035f0636ee9b101c1988a672a6d36001d8a3a2f69f12038e09deba76f2b533d8de29ce4e369f435849d4325c3777b0a0e15ae31a594e580f49f7bca3749a37a163717de1dc3266c2f28de60c06642c17b0d6cd137bc7c0fce4e702dead9144d70a8b6ed83e0d819987ab1fee44bcffe082ccf6ceb0cdccfbe1196bcfcd0047de655059a7bda3323df5cc1aa374a66bbdc355e2c5cadb03d8dd716a9b2a7c3b2b6c61c4ff237166ad8b0d90607500eec693b9dbd10b07cf6a041d846f2690f7568f422393bad6a331864cc271dba5ea83dbbaef088f59ab6747c8cd570c0564a0cf7194f165939bb6a0eb88e0f449bb787d055fb5051db00719c0466fbaf52fe07ac90d930f13a396ad3011f60951ce8d52ccfd47f17f008a84468b8cb33bc80e3dff6b01651633c4724107a1f0d7a0910d408e4d8bca6096c887752de33a09ac50efea00be501697baa6c750137270c85ab1f6af5fe8cff49f169b0eafa61282a6f1635449edb4d9e2a9f460a190491e1be0d20067073a60e63c9fbd91d2517180250c32e471731eab4e97bbe3d569eff4499f09eb4040ecb28696bd04db27e61dff593478b08e780de7d0628418012406d91e7b5b034fac3fb54cd2f190cd179a621a0be2b1836dc898d92d107f864353e92ec8923a312b6820fade06864beb4b25db0d80b630553da1c1f4eff29d8b83975ce65ef05d0c8c87e9d433bfb72895ce109c559ae82ab3a16d948163fe5a250e6dde0c1d00ff79bfe898161f59ee9df35a24b1e65afa2a45ae095fe3acd561156fceaa22ca50fca65f36ff5403e12afd2fb9453c7d2b6a4b75993318ef0013994a257ae02e1c764e9b7905b7e686a44cbc3932de914ec747e01f442d28fc5af4b31d2ffe019ce0437a3865d78a4960a9f22d48d41bde6a76575eb118f33185dfcacca9cfd9373feef4b609ef271867554e18a3b65fcfae915c7a931c64855870f807418326430d5db3fe65c293ccd881cb07b0d4d9254cf154689592542439625c04f9e3d9b91d31e3ff969526dc9838dfe78e89ab4889e78c625adeb9f06b028a06e9189f32349b6dbdc62786ac708e6c40758d34f359dfc2201e8e546338aaa94172b3cbbb8a5441b5ccafb3eba177ac0948ababf75cd1661a0bfe0260e23f5aab406ff16138129bcc05935a72b975135d4259983a87321f04e4f13e73570b6672025c413a94c5c6397e544b531d551d205af841021a61e48c59640fc309e31bb7b317aa7e76df9ea692fe2d1805bfbd009206cfc6877f5cb5d295a7b62428a206600b9b8fcf8125f794217ce1e95fba815105415e284d0ea3e34332b67856b815875b66e6e135e4f6519b86c6263af075077e137e7d75d82e262e3bb2d61d7681c3bd50d1ca6dde695daf0dac69dd65b5e2906b25a41c1ee19c4594d66ca226df8df85f249b347ee522af649b8b208eec731240295ef0748eb8237e6547abc4deb4762615ad48ce4a7553292754d5931da32ae8dda3ab80ab088fa7d45192278e2d9a2225129c60824469765ebd625645cc317a4e81f3ac216e297b2fd75f888193241ccecfecae51819e2f426235ba068cf897cfd3cd59a3c8dc65bdf735f4b78334d4321b86ead72109eeb1e7812807f864ad385a25012fc9af2198a992bd29b741f3c7138415dc3255d32881e7414054632b367304ad62587032a981ad48d3429529bb11e8c394f31a8704910395a6d0c0d96d8518b55ba53314566dfbe0b1eb222150ef2ecbeb1bb632b87d875dd5944d01f2605db227bd799a947df529ada7a8d7219262384063b048d51cf8ac955cfb5130c7e1e7d77b22b3ad585b9f6d2df022f5264abf40843edc9876e9190bd361b23b107847e4248c0bb519be68ee07ceec23ac776ed4221961f31075b06a144971ed6411539210d81035746b87604ae0cd2772bb7c7915f13dfd390c3f2603bd54186a9bd342df04755068a7434311a599b7aa950da2d7e48d98c616322eba008bd6d0caed20bbe4c3718a37b95f7ccbffc430c5df310ed5011fd8d3533abeded41a34859729f0dfab4ead0cfa57b2a98ba33a342d0a57b5183ad6a9558ccac94a380e701c5d27f32757e2445453f336555393698feb7839b11e6f529ab4d3c7e9f789536e0a6c470ffd2c03d3336b172411b50cb7ce317d8b8560f8b212b5d0e3d0748071e4340bab77d2d758fa3b8c085f54cbd52c8084a3e56e63f211975e394f9992a58bae44a305cc764e176cd009d042452be31e06228a8a9e250abbbc583a75a51a7e48ffce9aaac8155d61c7c3a2cc245f078f3762c785048deb969738ffdd409abfe341ce7bd29b1a42b6766831fbfe2099a93cce62f15775dc01d766db26f40a961e0a9b85d9f05c57a72baf3eeb39eb809aca2de0ac53490799611cd8a622e59543b45b994cbbf709ce872a3ddd550fd37cdbc3cfd97b8da387523b0ad9d60e86d72ae17470ccfa572da26e5084416a75055d9c58b6288cf1e184ffc64bd43fa011e4a06e964a0efab036d0a1d49cc8b31d90c07717fe03347a9d85de3ca47868553e99dda16f926a6f5240fbfc5575cc73ec761af2e0b9aa209e858c8ad61a0607ca66cd696c5cb7dae34c398490d769caa4af64048a809b9dfa584cee6326c21ef048afc472022c2ed906c13ff9f183056ad891603ae74d2ed14c457696bd88c3e1d8f7a6e1b8a3e4472ce1f8144bb421c42b3da95020662b27bc41dcd305c8f74076836a9995675927698591459bfc0e73a6a1a21ebbd2870e29edb4a0ca7ee7c282ec6115e92e3e05518e20a6710779ff90d40b86260bc785fcf0ff8f3c90960a5d21f5f98f3d50f9753118cb3fafde2fe883844a8a6fd3f435c893d0615298c96557ce6c02902c3eb19ffd073fe4afa69f585b8cc9476be6b30fcf6379dcdc1c00d1ea113e947c25070b12a9a031b41d931535522ab9055f5b2092c4bee247c5b0eb83c564690bdeb46b0b3f9d8b5433800959fcd1f5f1652b89caa9ade35bc0a7d26e6802a3d5e017c3c535fd10fb5e4f66cddd96f42d8c1234c4e2e91b98c890ed0c2ba8e661b2f4e9df764a106f4f82473f774bb1b7a9abbcce824ec597bf54cdc920c1c8e88d9e6fea7ca33fd87d3a6f7bf4144edab6bdfcaabd2a02d4d629667bbf5d56f07d7bcf34cbde44972a826b7f803e313fa37d46f1df1f1cfb9d5fe852fc5026189f007c314bb55e61a72f3f9edcc73894b17ef00f5025b4a5d45a27bfcc77972ec20f19b44a95f63abd43be07c3f1d528cd608b8c0a9295c46a7613d3f5218bacb9b12cd481723e352b2d683e32cf8a74fe9f922e3ddb8b246a7776965223423347d11360ad7427ff36d1db99e8f440834ab4eda54a8222d3865e2415e04526dade177c8e77374f52623a7a2349024d8a63325c52d23f962b0b1b4a0a688fdd3d3d056847aec3ce6552988eb210943b040e163bcbd20aca8d00eeabad66d364b7e267e3e7943b86a9ebf2dd7fb93a866ed139eb0d08d99f2fd63154d5c888b8f9e9317653c1790b569462e09b367eb04e551cb2facf348da9e16617d25f8df5b777f472a8f713a20d43e266a789b35f63b85ef58f19beb473cbe61238f6550b54edf1cd5fe31d50eb7df378a427945ca9c3b493e06daa1bc0e563074c7607d59012a447eb95a31fbb2773c66ea47c748c8e124e03030be4a00da0fc1a27e175304a2b99f245b6de832844355f03416097da165bca8e5c83ecdec597afa5ddcc07a710869c05e806d8da125ab9ec8b84299477b016f0ecbdbe2f382eb221623f0915eb44568f8348bae1767fc3defa9e81b78fb12ff0bdf654d9a9fec424f8ae3fe5dbd6ea14add31778b0ed5edc35455bc20d10606680a700756e66ba767cf59b4949da9395cc7307e1850ac83a2ad3d1f8509a91c96abbacce8c8a03128a5b4c43ffa6343e836b2207f68ea22dcc851ea49c1cb75a411e1e47400c46e4b8109b1c6f0d51bec5c938adda05cbf4ac17e29c8262f6ba8bf166ca5851342b13fc9bb1fcfef0ab7869ed150334afb72fdab781ef1454d44756fce3c26e69051903cafaaee6bde3ead86393f16df2835dc098e07a3cb38aa8b81f769800656d7b03d8a5ce25fd30066a057c50354eb26c4710922f4dca43c139ffd12956867884da47fba68d7c2d44a8eef8bf1de8cacf07d04d088a4ef1ad8464cfd03dbeed8ff762efe3158bd54f3f19340b0ca043719d326074caf3c3eff524031359b5f7e69cf04cf9de5f39960d455e3195ad8846ae0ab3afe0ab81846355cbce13f097ed8c35e2a3520da92f2ec01648f9d7f230e6387422faded9216415b0ff0452f845ae5a9c84773318861c90ef61cac9a3dba871f25bac745d6458ae66b8707d77f35378c1a8cdfe9f0f87e259f057ae135c4708f74cf80e81a60ee6b5cd21bd4282333cf161ea63bd6be27b4560ae64db18c6adf064c91fef40a91575fce40224c73813cf0565b8a6fce24683c3790b5b94b6fc323bfaed3c5c3ef75007fc042f993136db20b28cab893cae6ef42dd1901d3f49e6c4887ea7b92320f2dc78e825e8b46ac27eefe8f1a4d1f8f9a1be627d686ada9e3be12aa9bc2ab3fae4ce0832d738ce1d833bafdd6e2407517ef955714e4bdcc67fb8e0ba048664193eef8ab7566c22f9f0fe28a02d94dd18a5b282de94c64db212039247ab375a06ae9ea483eaef05bdf70314f987571e90ab942068b7313efdf11f0733ab3d6f4f4f709dc00bb8ee2ee88ee1b63250ec657b621e85b09aec337fba526545ebaeba0dd2b727a45eabbeda15db9af2ca6878bf53ed1e260176b79d003d655a9799de0dd1ed086030fd687fcebf4bed0a0d534775691d58c6a5717683a38640d3cc1b41a24bea6643085cd902fd52dae2184be7de8d4fd6404a26b0e8ee6c85bd5bc551b2e457c194b0fcc834e9c1540b6fb5e33d547584b932cbc030286d2a0f8aead02c74a75fb71c67e52ea608952035d2af1917798641654dad1b65a13d318520c5a358f16526d725f3db064ceb7f3b609ab2ef7d888cfaed9b22065cfacbc69dca8406c0f3c8c4e2329aee7dd7e0bbd4ef3c28f6223da6a3902bbe90c3bceb6796ca821042dec2fa14ec71acde2e7924c7e7bec1137aa35ceca9afa238fb4c45bddbe5282e0c5a814e180959aeaaec67c64b714cdefeb9b569bb03aaf6130ccf193289f4c83bdbfaf107eb617ec8672e0a181c0bc1103f7faf463cc7f9dd54d414cba043d5f436f80e8458c5fc9dc47bc3c3385917e12229472c448fd36d914f34754f035e7e935f4714ed97a0cecce035c584beddb4a74fd2de5deafb191e4e018f85eed93fd9e0d7be4f7e776ca2bbe302ae7d23142b1bde89aee0cf5016e5c0dbc6adb16b7b72f4fbe4042c45e1e7dfe6b8fb8d22f07161871271546d8eda7126084d8621ceea246388a23219bd144d13a333fda7e0d19a6bc4b2c315c7b36d54de0894ab86e3565ccc9277ecf7333f22bc477da22bed56a04b2d21f524e9e611a321312f3a548184940b384330c2586d4ead6620283b92d16a2321e5f296853c33365b7b9b8bb4a3e61f49b892bfd0fd26e96ca2a3e314050dd4863383cfd483d89aab9cd5a2d604c87c4fea3d6160689931e8472f552c84253e2b534de7c87cf896e36875cfe30e516e2fce3dd891fbf97524b7332039829fc7f0517d83f56a72af755cdcc9793be598fec86c3c26c60014966152a590570f5922327d007e25a82f2aaad88ba2bad1bfbd1b94f2c8524ceaa6274f6de3277f4a91fe98185aa364ee711a46c1386fcd11fd51da512025b74f456792cbb9c07d4ffa4e49c652245093b014644e98f02fc5bf6295e0a187e8fee6bde97da47c5314dd59d1d4bce04ecda4c115d25fb4afd65dbeca644eadd03d7f5ab1b06a58bbce37239d3ef94581c576081593a522c82f77b1b2929c3d7a1635e783ab35dfdeb789529a70e01aa1914f8e3a3eb8e48701ccec38af4a480b86b435ab84c9d7675e6b3164813fbdb45fabf711e5b5f36dff8cd7f328269ea3266cb1e38d1d7a75c9e39be0831cc1e486b78aa7c8260f05796086171f0ef3bf9046f1df84d33fd17b53a92d448f6e547e7f0f9c8a5b700e0c27724ae118472bd6d1f31853b6318cc7b9df13071fc9e85014e2e49c5e6d9fbf94245a00c42f7b2ac9359b09ff6574bc56ff431085fb22c0139d0081f0a6e396a98543ee02b43f007ae9969495f89e957a16ffce262d3cc5678247479d1de2216c1ea2027ac196aeccaddb7b29d9cf440ed559a3182cfd7a4d1c558c8c326baf51b86ae6eb04659ffc31ac30dadabadb0f3642d46f7eb61a91b9f3f8ac13a80cb5bafa4d6e851ef15e5a88df160bdfa3b63a2ddbb571855972b8d77b8a9b766edd138f9fa437fcf0e09bfe57d83ad2ac2367ebab42aea5917653ffeb315eddd2ba4333b932c0d043c71782bbafc1b2a3dada5506b11fb6881a81ea0a60aba7dfef601947905aa4e98a5b7cb7dbdbb94c2f79355c2eae07633414189b158aaf199483f5ab9f0747cdd4030229a51347f95c073eb33e4c01f80995c06f2a6285f6d1a6d3944aca1d669f3fd87bd74e4f1ceef9a98e1152d5babb6049659db3676b0dc86bce9e037a964f62a98a51676843ca4a3590e75d35273e030ebdf834e94e9a4231cc02fea6a02149785f7385ddf144c45acde973fe0ac9a1aad276d15c6734b3253481633c7a7795d8fa2a1b35702729a5f8d716ce66eaa27336c2a467e69701e73a95b791b9460812a0429a3b16d70cad18b0e0b51721256725fec1f36b6f356dbea63efea186bd5038f98c02e696245dbf48c96deb2657aa4a0c56628c5ff3ff69f8fb428e9fc33dc174464948b5ea955f1ef279d7b2fae9fce68e99ad64c906ef4b5ce3f1ce18a33cd41546538b7b059f8bfe5a218c1200df8d14ad8f6a93f076fc081bfea33f7465f6adf51c272a4915729b638e4086c6fcdd1ef3f06309deba7ce60ed17ca24b8ae2ea594397262cb6370d3493dcbc4b98aa12f8d4a18804346d83720f1a61bc5dc1d237a09d9dbb96a23223507823468c44a13e14535912bc6a859396402008d47367d39c686790c70308d5090973f66558cb9036a1e9cf0827ff5737ea245736ba6eb96ba9913211af68dca09710ea413040fcbe95be8cb7449b95a53f6f791690ef6ff29c9d0ec5b275580f3c7d083e0d582f39c8c8259fd979162c90b66c98ffa9777925139f7ea2bac75d6a21b590a0f915627b376b7b60b5fe52ef5df7cc47d3f7ca92ddcea48785155034d325610c436d148e40fe963ef5f8e0a98e980c2fe4185c70e1fb98230ae735d39108ee60660b1e79d739d830bd195ded890032655b210e35b494f408031dfa07069b4864f0a5ddcd609402bb98cd4ee021c4177e13b2dab58693924140c3aea540a958495c2b891cad72acff0498446a423981774b63b7fc4935e77ef418a817bb2a87de2a8292dde938339df4bc53c0016ae75aad145faff31b3947caecd7f3b2203f6b25a821e807a26ff8b757d48fa6189f06160ecea6525d56760e5276bc697bdff938753ba39459937055955a1133a03ec688814a7473b9fcfa57791bf85a5f73c0a8b1c6262baa3cf14bae77191f2572c2bc3ff77f6758f0b40a83d90e2253658884757fc370f75d91b248eea96815c5fbbaf6dd7c24c56a47b940b04851f540adda703f62a73bccac21c7e0554cdcc5c2dc08c0bbf0bd1eb1f03c3e9cb5308b0178083293a76e5faa5f8af46b25de58de524e42e1506ab8d7e522ff93346044a339138a0dd01f70c4631cfe36de714f63a9a459279c6616fb8a6c6031f7559bfa33fbbfd9c24a03a5fae88900f33dca616e7633c841b5c8b6a1679a158b35ee6962c8bee85ee53b1c7bdca97e45b5f79f76072236ef0af2e1e936ce8538dc3cc1657fd257bf902b0fb80eb75656da1ff59ab005df1db4aacf4ce2bdfca7b9022475f6cade582f1931b75ac598641e6edee568f9b83fd0ae446c395dbfd994a429292de98a1b8f2d3e25e48ecf9bf45a8b0c219629cc0fb35fc184ee242241ef0302290c0c599cc2170a2256165657fae26c03432b846d333280051172e95643866400dcaf85d7d75970af44f36d8db031abffd8d406ecba5af809f8916bef9e9a47284a8e1f5de2cb9fc9a461739beb02f9ad0f6ae2b656689b340a3c0ee7363a8ddaa2aeba9abd86974e73e8c67b43e4a0a5113bf29acc6ece2ad0b461ee0f11f9d93070fab892f9beba71b02eb835ff39d5ea344a0c79c8d1af91e64fd6447aae0e1ef625d865e0a9e63cc6cadef699bb84bc20f13d5ac3541b193500ce676be612b53e229a7d10338e5f04b77c1bb9b4cf27d08bc1864af363e49f7b0085c4cdda31476c71ce7daf70126804c8c2ba0785e0472aad2615e4c4b29509d1e2193d5cc0424410f6a1d7011947a3ae60b12d3e8a44c9b2ab429a1c8d82e2a309acc526eea0362f82b41147237142765bbf2b5640d55345b8e7247a8de83f1a9457aa8dfdf7944e4ad7fbd4574fcb565e94afd19b0614a3c385567ce31dbb763ebb2181f47e25b7cb8605b4245542efe62f3cf84ea2c71adbef198f0715c08d982e6e9cd2576582b1ad8a43479a186039bf4a2c093787e00e31e8ade9f7c7d7d93fa29a73b7066d0847678d6a388096da3716db302f90106cdc82171274a792b756f22f8e54774f1929bfb87521967b0d0b0d2837a168013cbf506cd741f526a474e78051e50f3fd64f9d85ed2b5a678ce89a7c8a0c22e89195143d3e3739c56731478ab2a79be322a0d78b8847c53a68426c571e83eb3212968c4a6d4ddcca992910bf96b2c0769de4791458a61795eab3386087654243f817f8c1aae2bc0a076b9149c68a6301c66e55703f601a86921c48cd5b4046b9c8fffffc6fe757962f3d0d155d2e2ee76837b38af16016e27825611b8b39f7f2e02731958063bfb2ac3af6d3fee3f1a6361a03cb267551a4615606df3f2566b4befcc93aa0c71c05163c8dab3687f0befb7034c3f4ac0b0b3994f18311c86be9e984b6f417f877fbf7debcc06fecde8fea714dc6dc928c278486a61a7d392efb088e4a6a8fd719a9aebb902ada90181e203a24509b934e3d90fffd32627c3e5da8abc8c8d93ad1351c2df0a14394b01e158d46b3d76d837a912d77dcbcea1f8d28dece242a5fa157b97aa4895618dd0174a6a1dafc17860e0452efdf1e04f20d2eaeb251f4933d32dd8a322d182d697287e2b077dec123bec26343cfa4e20d7a4216bca4b9f3e2dd0ff45d1c93a1cd9962b10ed24772eb4f5e4d40a5f75cc5503815bee2c121ea61ced50756727d0292e84b1b73ae45f39af4ce9f32f917f28a0da088d2534965599872651f33aef11d19e2ff23f1e1b29fd1d7fcea70ca257a0286b4287f6062d2f4effecec21b9ec78538c748ee2ccdecaa00be7d4115768371ddb149a8b8f49c923562c6088a08ddb48e19b1c1d0ed1f7893b2e7cf94222dae3e53fa4e19190a0d84aa04e1a0feeb34beb8d8ba1fdcfc7f609a3ab8e4481b615bbb7253dfd17d8dbfc4e30a34d81dd171309dbe0e2de9d7be014e5226414f48f9c2aaa1babaa1f6a333f719b38c91b658596ca3ac270ca1e729e5b487c464cb8b7f19e3effed5bb4ca47a71ef2e224322b212e0414421d980c389ed989df0a129124dd6af0f1995b2d79d0ec1a464ab01398d8ce745727d300a0330a7d2277765345830b1704b9be037b1dc4edc0489d7b639d8c16cf5a432e4c01a7f29c9c489e9c5a9dbe721fe71686a62101db233693475ed8477a90cb0ada05cbba43264ee15cf37c2cfaf828867731b705c4139b0ac07b4035a4647c677e9541c1dce18e8414daefd2d23836fc07340fdb450307fa8a1ae5d09ece32d74cd0dade30b119016082c906dc5535cb757226cc82feb39c6b9ccbd7610c47ff0bc34ed6b26e841b42308ed248bc1ffa9b0ba4d2a865730cf7e365b2effdb0a3d07c437b7bcadf75cf408823ebd1347025f31539564a3fb1ed27a2dc177a1a7985b9d2c2aa7ed8eb9aa9de733b3d184e9c77ee4f450f9c8fa7654e3fbeec2e2950ea8e50d75a2af20a594befbfad2ee72b2595473b35546eb057dfc9b08fcec23f4dabfa6719905e3a0aeff3397c4b54dbd6199d00864082fa679f4aa901153213adba03bd9ffcc2d96ded29a8642ec406ec5e67ca1f403602495c27f516547676c69504fc5b198289d0fd7bd9ca9b80a1d296d2acfba96afe35372ddcdd0c9bf37a23ee9c86bc653224f8b9f86b6bb57d57edbfcf509ed386d7e8c22cd711451e9a52e73ccfec0b048848af4dde69a89e35b6c91ab067dcba8d12007ce5502e8df07ff4cf00d9efdb6d766ed74df57fa6fdf0dddf956e895d54d5d677d8b847d1430709a2feabe661ad8053175b3f74361090d47462b329d34afc64ef64988ed305af8e2b6320a706028d148e2f630c8e82d83c130d96db64171ab9011c22c6bad2b952e4255ca5de05efa45ad51a1a26aa31ef9a9171cb188aa358bd884cd25f877a429fab78ff82b3c299507b41b7bd0b41b01ff8a0be6945907883efd8c3536fc35612a2d8305645ddb927cd75659fbaf5c495dcdd83f12ce1bdebfe1d19773e228d9db4781b3ffe424fe2740158e6ec006dc2a0c873f923fdda3ea6e68ae8e40b77258d1a2cd3b6c4b5b2d82304d4bf06718dbebfd34336a2ef6ef766ac93f4acc23e965775cbe4915c57855671de579dca627dcc3f17ca767d0daf2bc75e231aff2df02148917c6f26157b761462b67d41e1dd383a4ae61c3dff184304b3ef1bc8d6ac00adbdcfce997fe376e3b6ca8ad7679f47edf727f3b278ed04525a7ffb9900cdf527aa6024643e0532b54d56d34e02568dfac08ba2f5c4a7b9d3a5df2effd9fe094f0f648037cb075c2117337b3c2ab007d73712fa6b62bac1f672089e59c061ba9eca1f134d36011b6dcd2c8958eed0aeb13aee2a869acd174d444a0b1bcc6a51a16e3016732dfee176d43054f47aa416bb322d3fae9f6c5c5fd60edfe9d2080c53d2dd16664af88ce1d3ebfd1bbfbca197006984a1058b611a05c8a818e8edb1032cfbd393acd613629637ccaf78f8ef6f83bf823b64ec45986807f9d8ebc5331da1e080599e32288dd23a160fe326d2a21d96683619da34e74e08b5be5388bbb75527576d625cccc825caeaffac821a9abcc1c43d7407ba9e6cee7a119b5d2388df0e8029a1dcb23f16634751329cb65dcfeb18bfa98759e8869c6e4ff9df2cb864514069d65b1f808f7717557cbbb638cd04fbbf4c99b8b3797d7391d9480610565472c5e9f226d0cdeb88d0f2b59b1faf9b8c3cd2d00fc789bed6026863d503950b8b994465d02106615355b2b1238f0ec7f2393d8c003c6facb4ebd716ff359f3f22d8f0b179bf15a700d990a62695ba7d3535710428a0c630c9ff393d433257140f1f006778b22037cbcf707c15150134374bb6d80deda76a695b6f323032904b207aea5b0438bcb224d10c434075bea810a9c677e2c2a6979d18574b77e5196e1edf70a25cd0df0098a39b5458a64c4848a4df3a47a5ee17f408d8af5d0240b404fdcddea362fbe50805ab919f82a854fdbd4ad5aeba398fe78dd73f0dfb269cb4570cfbac91ecc543167c03e1e6cb7506ebea8eb231cd9994b4174a2ef97aedebe57620ae2851b9591253b123c7b14eda76062a98f389c088b40ea97fa5cd006f6068c649e8212fd3470f68e982bb6ec4a01ed29ac6664351c57c67aca0e560ef25bd8b2403dee0336205001e61d3be5b3a99a47667317ea114de1f97b42e10283b521b372736e114e07756a671420502802438f10b894cdbc7aca804e6e6919992303c9fbb7cfc4bc379a6128dc9b2b8c776ee50abe4a1c05a3b58c47dee00ab4e74078a15d88f094016a985daf5de0c84d18bddd23da7d28439e23daa23379b3fe752c4dddf37e19d00ced18842424144168622de0973bc1e7fa2dd2ef4718cb25136f15a01c3a9fc004d13bd83c26dc8748b23eea99f298e9425c236829e8f8f4069ecd73e8a98da0a015eb905c8986ca4c5b87a8d05d99e6246c530d046bfe63c74278f8ac37f04e56aa2a7a07c55b0ffb933904b1ebdd822a2039c7e0ee1163ea0b386bde96dd38831f48a1c9b1384d28181cd2b00b9fb98b92e1e054c9809c689d3d7020f042ee5908fceba14c7c79dc0f5c9e6c117000cf7ffe4bdb5494fdc3c0994bd1ee9a79e7f80efe0fc7a57b93226a473b0e445a1627383b8fe4d924852ea18c6ec32400e8f8fb92856baba9d3918e6da48097fb871d3bcdbbd1a3a85c2687c7e5db68acadecb5d5968e2b8da75bded16ea74d3d9a4feaa3992b86622630da2a2ec210b1f838eb770db02e9207042fff42a46b6c207c5d1c98c374557b08ba06d8c52ff749f36840e775bd66450cca131c155a66959653efb14b0ef727859914fb80ba0dfaf9f0689b778b35675723049922d133e78c349e5875cdef0d057c78ad3fecea86295050a4ac57d46a31397988883429a5bed2be30d727d05b0f5493f6d5f6a4c81e21a3a43501eefbe5764803ce64f9e89999ddb45995a894f490bed02fb88359022d23fa1cfb70a3b6a677c28e49579298fc5e0286fcbaf437da8b9385b5e0e02b9b80afbd5ac92be803569c55e9706e0f57e027c2c1fcb5c976288741dc5492aa6d1db3c08c528ddfa6da85b036819e203a20e018d540b9c8ffcfca599d9fcf2637a2f9147b94c6815ceed7d1fef6076709192ab245cb0daf19964c02ffed64585faf535f382e12af1c0c79788430ade503f782cb81cd7790166d10a4a670bdc528a0185ad2f35aa9633e2098a1b412e8830af3174b216d57797d10142151835dca2a362695b8de8f8484ea707d70cc4d06ebd6583808558d2019adaf7b4500301d0bb3baa547819f563e71154c12083f3a6ef713c1ecb3ab40e2624c0ae98150d1c3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
