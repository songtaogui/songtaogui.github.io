<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e8ceff0c7b347e690486bbb6a7b70baa442bf3408fac2247f3454a93278650cd4d61fc7ff19a4f4945cdd7cda281c68af5424562034dba7cb06f0c2ab0720d07899156423ac63e738535b7874949b32aa52866c4f0f1bcefeb0ad97d3170d32b6afa953d289d175f05d75d43a2e81c4ab3f5e506d2931cf6f6070a6e4cc7019dd0b4ca0e089dc27e7722d95c1f50fde48cda9191a8a6462d804af9c1e040723e09c135723688d5ef814d3d6b8730a7d394bd1e1d8cec5866059e29a836fe04b7dfebf76282f9efdcce82cc5cf7818c04c56c6b6133ab8133fbbed8d3ab5cc9df24325f1b3be5120c42903d688bd351e11b9e071d8c353b17d41d3f341635733d7f9e6b7c89a963555950218ef85c6166c1c17dbfa30e81f47fa34f35e18849f3a210ba6a659847094ccb973d74ff5dc3eec7a3362e7785638859b59092e63b8d82d20a2a6d28e76375f848c3eac3c42d727d838c9d5df788c9255b2d54cb9e8a09dfa46be668bf7d5bcaaadb075952eabe49eef12430b7f5576b91522d025eca21465c99ebe2813803a23cc36b75499a7c1e6a7f70fb085246d1b2439841a3dae3d2894854f07e78a2ffffd7a1f62d32dbd2dc4948deebf30e88ca4ec340fc6ce453844aaebc3737c4ecaff5b63734908cb6de82ee8593e86f6cef79f04e709903abd0b12b024e6dc523127e510bb24d493289ced6982cb4b5d05e5c9bdc87c6860ca4277861815aed2d487fb00f44f6e35451d3125d0e01e59d74adcd73d5ad0ad92dfa943fbfc3346942fc3b15738b381c3275c23fd6ceb5e14f0b96e777e5a8e47fb4308c6455e9e9d1eae93863a4db90d307f143f5695af91134c42864ca4d602275c8e39a6b90eb797f22d750786d28634f72d566df0692e714341e8d5a36a03d1aa7fa794b689f094be4570b7faf0aab4a53140e26a074a6ff0406c7f1bce1ee16449ebbcd4fb64a330ac7e0afe813ebc5ff8e3ffed3f2adda8ba3705d64aac2d6994841952be584fb537b696e3a0219d5512a79fe3f700d97186c81f2049b2e1ddea1bb4612464d634cbcce77a01611f41c2addb7637dc41623add3794791931573914e08dda6cd9426ddfaafc414f1d288d898cf0d507a3d8313c5040921c193805c00b5fb1a38fe561530c9e9de502c20d012b5c4d640a558ab9a2e63409ee92aa67dc904c3af0cdb80f42b5e61fa5f70440c40f531759ce468124ddd80662c9dd3dc4f2f9d41131b15646245a0f04a13cc02be6fba8e878a67774f84c523ed91c2f82cfd075682cedf078d589ca71ffc49de83217379c01fb78acf9fb14754f0fb6eda3429a9863f58bc2b160ab699fc456aba4a8efb886caa747119fa608a727eaccbe72cbb3a7c5ec4c5690f0480b7bb3b6227280b7669cee6b5bd048b8faccc0a65c142aa901b214870ef60640876fe0979fb32a5aa07965e6cd1c951a8747d27ee78b44b7d9f457a24bd860e022afb1cefddd9e9200298ffd735ce5fc02015ae60ae710fc1003a3dcc22a0267f8507a84477e463fb94ff1d4c4bab12d718b173241df6af8098b520c8d30358ca3098a03de0dd2032de0a7a55dffbcbc706dd65e94b57aab60cda499a156192aa052bc50f57d4327980c3ae2109e0af02edcf842fa24e4eedb462012d2673003277c3b1f0e109f8f9e3206a39a6daa23c0fa0fc5ba4d820a6e85179868b79a4de642eca927f408d6cb8c52dbac6e25b4ec0a9f32f08e4508dac5f8c7457ef3f9c0d22536a7a9daee19b4c75b8cdb101b924c189cd34e964c26333d665d8e14835d097d6d084481d30347e92b599a93e250f02d9b1df80b968d2bf89aaa85f68951f26aec032cae565fb0eb1bb9504c706cd3c443765ee6c1483e5333c077eac23286363051ff92a9729685153bd51f55b33b83c3cc98d5e167c4f23b2cb1e2965e6faf3db2b9def92e1a296b70a90ef0c47586e3d369d41d731493792d58aff1f964cb1fe804d5ca42542c80cc4e0e7abf9ba8a9784d40521a5a9f514c6009e54b3b4734f1e176f31d828e0cd8cb524c1b14223245f8fabc50af0d13088e4aef5d4f85dfc5b54afef20e7173f594e251203f1240e4af43c067ed5ce071c227b1497c7d5255d966dfc5dbb2d0560863be46f8714dc3b772965cb1be2c13b9b84e83c2dc044e0443ce738451180e545d43777d03fd082d4fa1e21ffef2f074ca64730c799d366de8c71e15054742969cabdefc37f69182e7096422ee35e48dfb9b7ae8f3547bc156b26fdd9618ab0729ef6f268a358137415604b77893e1e6291712907e420110d9c32a49d21b1ab99c0318665c16d7622ab032186b1a5cc6552fb7a8cddd4b4af5eac417db5011367d454d7ae21f2aa2aa39bb909f293e4bc4ef761ed2a65194bd30cabf62535fe466e8e7eee8e11f4eca6b993303c995f3beae6a180e2d919f160a238fee660751ce474d6c116fe7d1ae19b7be82b5292eb683737265949756ad01ac3c4c2ece98b8b8f0130a1eb1f6474d653c1fa71908d247b4d27ba5375628b892891f439752359583d7a411e6842350d8aaa28d8368709099734bfd603ccb481b9bf4a9c15dd7cbc6009e54101d204923b058065eff13a4467608e9e05a8b6700f7134e43106d905f0016646055172b031a24f833038fa03fb46515b8ba74700a944029fb6bfb41fad1cc3eb6789c12b328a4c838f7a0a246ee762bfe423c9a86ec2ceb4ec4a319673da9b100526e2f7ddabe1e995ad251d6ecbf1478667b888d622d84dcbbd5760e3af2a60796cba28d9e51085ee531eced8ac918d35dc24737f2cae247336c731d20c950a72fbb416474de6a80892f4930d64f8bd60ea23d46206a9b480177c4499a8954c411c0b545552e4c2f74b93d60269d2a114446d84d98f64a65428efef55e6b8b15df8170185d17781fc5093db6d17436ba5232b6ffe5439afa796636f9703ef445034e4e70e16557b1adb7ffc5500dcc705092698d6efc097acff11d57f08d5ed045b0285710df65536ec5265c7f1eec60c8c363706b7a1a1ed08fc77a42739613c10e85f7fe3acd928c2de52462d0f16a8ab591c3dd84fc9312a6062a15fe5ea8643ba52458449372b7c9486d41c7f9a9ee210a874538b6c5d5ac4236ece36df6d733d8f6b29b9688f1fcb222957cc6a0aa1fb834913a59e8cbe28a527dcc5e19d6973b8f41e545a8e3ba72179db44e6eef30a11d3baa5ea2c03016b5b40fa4913563be3d2c90ed42ad7616383b85c50726d7732b7da0933ae96f78e430ca8d24fa6d63c2e9ad46cd658de771805c029da98ea89fef5ada7739ebe817fbd79b3670c5f478380ef16fdbb1abbbb1a7cb0be3b62e118726ca94d3ac26dd621225b8d4fa25b59d6dd4aabe6aeede9fce4a7d77142a141a69e43edbe642e4e07dd3e573870409f804792126b9106567b50d3110d07366b81deacaa0c6d8535cc5d6c7752c6ddba9bf6dc7ca88ec859b577e692a6528295ffeeec02ab97a0971701c845376eea701d94451ba7c1e0e88fc6fcf647c9671ab7394d7786e3500630ed5f028c8a955fabc917c39311f7b7b822230419cd71c87a42edefbe30f233892ed499766dc4934fce793307edb9cc00b376cb196d835e78a1de0db97007699ccaf36ef8bef69f99e90e2e2bf9ce6635a59d511ad0f71aaccf5e8d3001b97e1c6760947512e3c0db56bff43e5b0faebaf51562aad628b9e87a74c130e57b803a41b585aa052155c460fd22e3d552cbe4d45ae970e9ce342a1c3e3eaceb6bb509d2ea081adc45186682164e42ba5a10c134041facdf24a364dc000d2a1336b8f937232d9f6f46c17590d40cb5f357d0c1c4cb5ea00028b61cce3a9bf1e7fbd0e4022db42d9b48f517642cc0ad91a84d4c33c84d3d0a5ac7f51a279cf700719ea9112274bc4498e6abd4e15118dc269c748035339eace0de8aff470fce56c9104abd4178735d091d4ad6ada88c5447495445f1f551f233cfc76bccfab5b31a2cd7794554a718da6c9d394bd534062468f40a416b6cd3ea0b6e1d171b72dd595515a25cc97c10d8e2f8bfc1556baf909443a7799657effe732bb09a095e7427fe739237a3044563b2ce8f0898f46390b884e2e07ed0c477c96d754afccdc3ddf7e679cb34512817ac24e306fe5b0ba28efe0383d05b34f7962217d03a088a763a97f5ea9d1972325df79e19177e811f8ed7f613ee0d4dbae76f5f761cfac35f6037254b7f00712cdebcca4d1f826d4ed524fd394408047bfc95cc6d554653f325bf9a69580dc51821af08b1e6c64a85816577ca171703a74e47f5b6cd4f34f1a75922c8d7e791f726e3cbdd90d6c9b559b9ff46e5b5a16ef61f8ec15ca7b87855188022cbb015296423318259065693549f4c9f6708fe5ba29112b9289c9a339f8fffc9a178e762524d2b7d2d40cb4a60f6eea156341f5b4b4357478f72a9c911cf404763e254a10908e19f1dda26715e84a08149700ce58cc6fa1804e11b2263bab0fb46dc9ce6a2a9f61cecf0259abfe7e92f929604dfd117c5d60b0a0b2671801419657ab34a8c5572bd20b6869242a9ab6cae794c4629ea174c1f0831c55aed08a9de3cf8d6ac90a7793296b140a351641a52cde36ca218fa68b74aa1de8240f8bfae03aa4168bc31697384040816b206f27c15674e4e80300f69b4d3a382bd9e0a36c6376bdc1c1068be43f74f5c1c09d139dac3fbc6f0c886ac9dc254e618c6cdd21839d3987ed8e8dd9c3bd31669080140e6a2524105cdba76bdb7106859062f42bdba797a66e9877213fbdea50465a3363b3eb35e13d7227dcd033e6df2b0f0fa4345b9404b129e3f77f9fa12c79e79bb5d34341179632d1d8e568818237130be309f68b8f52f1bb3be53fc44c4e1490a22bdd833b49d3a102d4974ca3fd621e1524d3379a1cd0ff83d5514a85b0103b63cd086d7a128d5053fb7436ad8901f2699cfced53b881250254157ec88e9ee6f2f412db211d6d25a674089f20a3f4ede6eaeb143e82289cc749018c35bab9838441c08c5ac3748389c4b998be8fc15fc1e299fc37ada72373139aff639e3495ed2f4724ff040dd228f28ec3a87d6c528804a130b77ec94764dd55d50ee2cdb723c48fdc5c6d4fff4a105b0ad963e75005401a8a33f5402e4ec148300a009081f4df961804d0bab95cf8c08a8024d90ce167d6adff3a90b26e90c9f7a2720fdc721f886b0216e298991a2bb0a23237c65abd64a0acf2bd66d3cec7e5583bbb848bfc3574850297c478395453cb08c59d7e1292419bec7fe0ca1504daa923afae912edb81f9a65173f4d0727ab9fbe9e915499c49e6a7f9d7870513a95e41847fa296ec211af0f31d92b429ef96f51a1a8ab1416d67b289e653eb27e0eefdee723f5edccf72877e71ce558d39e25597fd0b8c277951b6220ca064619cc1ab35038b7f9df19b8c1716e511b0bf01730eafbc4daf7a058a6c5c4a9c93be5faae9a211690242a8a5f56b59bc41bd5b19cbe3c759ead3842cd788593597cbd14c5c773970fafc6c935cc89bcb75f2283293fe5d586ee108c8b680d3947793df425be43011e630585517ef05e46bb2913c11cb7bd3644ab512b828291eb743114ef69185c810457731ee47c93903048e69dea5b5e18256ffce05af463c4311d7a52252126818c45dee90bf6fa5a90c9e23b522e0cb7de0ed2dcfb813e87b43b8e1928592a09f0464b77c634eaf49dad48d4852e9e48b34642c252c503785371ae2ee7779cdd22bdae24f4166b9e23aa187159c318fbf890dbb70fed7a14bb2eb7f5c1be86befca4954f351b937cb96f156c1f97929e9e82800850ce6d44e10b49793d6b682e7521e1505dca4edb7c2125aba6ca2cfb792085118694d37abc676ee4e496017335232b082d35536795d6609ca518db40f783e5d6e84afffd3adc9ba6c21b2ff5418b9740434d8495356bc8b37abb0ffcca4e58bc507e50bd38bb31adf811e41b54080787d375d88fac18a175dcd61c55e14088f999c671f05c31f12d1c18aa16ff2adaf2c360a490309423b121ad75fdcc33c40cd7272345fc904ef7f4ffff51c9efb4341bd37486b8a777ead062fbc6737a5ae731933f85f21f50a1c3cb898327811f5ba20a85f90a5869156d245b51bb8782347585b3612a06b1400919e361c34e8c57690c695f6575931b4fa7ea3d9ab728cc047d334b4ded208a91cacc614911fbdf186d985874c6a57282f0628209588ebe107a29ab13c933b737ad5bdd0ca5a9d953ef8388e9d1e5ad416623efab61383c485182af87a2baf96d0f0abe6c94d0ad595a2951a9df59f0752013ff4ac18e547e2320f9a87478b70235b14cbc4df43a40a5d5a5d54a4c54e8b5665318b807af348d069e5c3841d51683e219cc3af3eba5ab514fb1c12e0536136c6c3d959e6ac17fb9357312568bf6e223d667221c59432c83b4a3e0fcdcf73465b1f67f6511ab1ed4c6a5593fac1974cacb4ff7d32b814d42f8660a9ffb5bb109029e59e9ed527ef1893a80f422f016b80237b9f10221e61901238c22cc8d29d90f16cf55134109eff59148551ac283562ce36e32c71598cc4b665872a1dc58a19a248a06573458fd645a0f707c0767fa5bee154ce493c1e73b596b45a9e7750694acf14ff742f10abc92cfbb416dce5a61089e9eca18accc64dcddff5df8195d2f8b59001a57a8694890d13d09678b2826e9610e96ac6e8baf893479ac9a4a2957df6a7696eb3192abcc03c556b95afa737843d48dfbdb34927e00f23b8683605d1dbc3a21890d28462090ed5b23b86d8b40afb73be70af2ec54cda32efe00baa62fce0b0cf05be8ab5a9554b88f7ada4c26751a2afcf0722a269b99de847a2e85d921b22ffb9a23e090b927f0d1601ea01208159fead99b1dceb67dfbaebdd252cccf9752c16d7b2f40805ac39d158387494751133452dd7296be1b3059d9fd5e428c7818303f5e0dec3a5ff8fdc7f53f1c80a316d6d2924d600a82c77ca5092ec61f7ed0a80fce8f6da9e00092e368ff0cfc807c3e06fd881a4cb3a9f9cf910262ed817ba53dc353d774939bf84981d47fd7f193fdaebdc0c076ec7dd805511c10c19c3f7801450340d39dad2160e38f4e386be151b50ebbfac7118b2c0f29075b8abad7ff6a33fcbbf9ecb008a796b7d81fa068e7464f06b52e9d9d302eb4ea02263513aa20267a56b4062319ba5c5c22e0354f10bcdf0e7351c67e98444c26632dc3e8eb7278b04241f84c6d2802c74c069838b3d996a9e3db5c44ef361707323fb0c206cd4c4198eff8a88eb1794a9c549186ba9f45ca3a99eb2702da4bf325e33f53080ae95556cffccfe6b975c7be03ebfe486b1d4d06618a313084f4847146b47d4328b327a386d2be490ebf550b541441892b28599f10e7400c900a2d6d0830228013cb7a8783c3ebc2db84b77b74d0c8e66625e346601befb9096f083f97e65183790c3f8d30a6c88c9601fec799746eb06630752d01bfdb467ccfe9764d8029d4be3358694035716e0c8148d48f8e0f5f181e3764e7daea21d6096ad520ce115d0157150a2b11cd7a3de40e42bc927ad1485e3815b9a9d21f54fd8c13befed5b00a20da81b5c99c174895326e6e057f61257f1152164b3fb3301a2ede45c4170e9c5853ab4570d0de783aa4fc84f9c269052c5aef17522691d04c4b0f665fdfc43e2d52f4fe1677bf83b358a292137202593badd06522e7ee56863548160e84316f516578d0ba13161126bd336623123f99eccb76e07be8de6773500eb860cd34baf47708e8e5680474c079a4924c087fdb3f12167fc34c76adf683a045af140dea54fa7b5c218bed7a48c40acc0c8832859d577d94c51f3d3df728472aaab2e0f4d0814bb062dae7a5bba02e4e169c865c4337af8b9e9f299e733d700b7a689f4365e049da913cd8ad61654018c01939cfe7a9e274d2b95c0951481119be7a178a0abaeed8dd15893886bde8812ae294673921bcfdb776e7d55b890a5ae6f3948bfbf1895fb11e3534b0caa98cae380f78dc9eb6eb903b462924c3fa367354d2fcefe0588014c43ab0f78ffbb89f0ec543b1a4c2539ba2fac36c637d63ffb27133a3ec207c238e58487e402982cd1765ebad6e9c11b84811fb2560e9e719f39169655326dce20c63b8793191bba51a2cab04e5e9e0c8369adace2eb350f39949c7a4442902abb8ca679f1ed910a961a09ccc9edc3d3b83e73323078cf768517fa421315785ba3cdac173498077883f0b2b667b8aad999732ece0a927e1e219037baeb6a550a58fbdb3fb3ba6ed38a98b7f93f258a15189f4af0cd4115c6a77871796bbc4c65987aab2db44fce4c65fc862e8cd00f71c65ce6f074a3296310a8b724fe3fbbe9bb04d7228467feef374bc7befd15997d8c8644ea31833eba29cbd96fd62e401c3fac70c8900a906b62c44132f08a5efca7ec92f29d28fd22abb8d5bb49f898debe6f6245738edd0d04ac216fcfaac019e87764c4b8c1c267741c586e0b5200d80a3c8eb5f57335d2157abd18975679d01cc25ff8b365c2496a2a5dc7a9324fd3f24da59c267ac08caf950bd51551a82f0f305d4ab21ea5048913db107813473b5f6c7f4ee3c1f909c076c871c2359b14de29ce0ecb06563decd91c4155de8f26eebcebdc7d59bce3bdbef33836304d7f1160ec411d1d4d84413cfe1ea78985dbe31388a22a7890a32331727704348c17c76b6a51780f349afb87e9358ecb037d81d25c5f40433b8f0d552cf85a27c5f082bbae582b1b534122c48e02981e44878e71da6712d3cb39032d356c7446e1e941bd70a4426d30f49fe0c6fe002c0b3e642520f93f70859adb8fe46d8b3e41b6960327b90741f1d54027c146b5700414f62684108c553ebca9354c982ca308b241e15f892fbd8d0545e8d29593288ed1ad1be81009695f9566319c8a48e1612c8d4630e38b6c5cec49dbbf4823b4f3ab55c4aacc014a919f29ea6ff692b5c13e4413396778fac5b50582de539ca3140eac1ae32e82b714d192b9c467e347633046b94e5677e8ed738bf214b994f2ae071bd8a7fb058fdfa57446ce1994dd22ad1311a4844bf6ab38dc21bcb8766723e17f4ee7da54662bc3153f486d4a3354db1bcd1a3324875c942ba7804a67ef04634d5834aa9f10712d380b5eebb005402b9916c4da6710805ec4484a35914baaedd54fb2ef9a7387a78895ba5c4c9edd67c5001c56357d7656acc2da1da4d7dd41e7f242ae06adbca7f71d56c562ec276d7d16c17575c02be587281565f639ac806c140b65f82ca5381e06da128e0a65bb4f7c2b2587b5399fe949bb19cc476115694665235616397b61b63caa2a12afa4132e7b16e52f37859cad3a56a1aed689f03112bd4a986ff5f2d0a903cea3db8c210cd6dccd3fcd6aabe1974ff60da5fc7bc922cfd357e08ab50b8fc987f4d6e4c12f836b6ab9cd04626230e1c1caffe7fe13df1ed9b6eec36b9ad9cab4648f2912083b2c6c3d93d3c34d633ecb8a8973ec2284a3973caf59aad94b285463d3699b7c7bfa6ef0f4ed54d580e6cfa8363f9d4cb622d4ade082ac65dd3a6b4fef33c74770e6e944c212d22e248862596d0cd01f69a3169201f6a753e7fe6fd1ee755a1b6e67077e72b14d32662145dad5bb8986afe5d845de05e7ba56bdc7dd3c8712d936796a5519fe2bd072fd193b6ec0a80f53e01cb402a6421e82468b9ea67ca1ca3f35a7484d8d43981013208f651a616799681076db2fd0860f5787c31896a1dbeb1cdf6746727753d0a0873ee2d7aab76e10db8b729c8fa693fed50cca690bef9ec6174071d950307a701a1f1ddd7f709a002536017c4dd61f15668da175b7c84b53d698c0fab094e344529c1c4323651a1840fd6c9d05927dbd90e8e2fa856469f6c984cc5d87ebf3f3a857709dd76a907683565ccdf097243ad618ab4955b4e6d5e9b05df716f6831c37c487cae3d8b6fbe142191361b5be324102d0d940013f8dc559bdbd14151b70c9427a497036cf644be0f5d8b49f158d78781d3c836a56d2a7e9db96031607342df16d54086c951771726526cdf1762cd36ae24c3c30bc0b6927d0efdd3f3155689d4ba4b217e744e57820e8e405d9ce5ec8cd6c13fb2ff94136a40106ef9040ebe55ced288fbb0e2ab00ce247b8ad8dad50845b1271f0bf808ea987a7bac7b31b2fa1c93e0da364f883184efb8a882bdc7845e57396140c898c3d59aa4bceafaac24ee404953b91529bb165f03b2b0966495ace020cbe04450ff4dd8dc114491db00666f7200c8314e3268de79422a5dc6c080deb40674d06e6317d9de4afddecca68e6ff9419af33d84a6f2e709b0a9059012046c32ae1866604c27277f92ce651478cc9b5df0f9bf4e96b95a29675d5df422b0367572345af85b1c7e17abd990ee470cdbf6cf078423b45c69f9df60d767bad1e62cbe4b7f1019b9fa38d0e1c59fac03d57fabfd52ae8e0b36b946d1cfbaab77a36b3fb474bd2f68f83aa14455abbc4784d8b87809e1f1851386e843a5bf0380490a161b48616e65adfbc2c0277771a9915f3ed961e4a8ea5933528a1f5526775777dac148f344de363f2188d22f8e1f8844526e9cb198384778de8b89be4dd883d282a3a1fd02fe53c02ad1242b22b6531e87654c2c8c570896db4da31c93ed66fa12240769c764963ae28954ae21488ae820bad409a10f3b1fd23af8d59e05ff654a1eae7747c71dd43ff112206f5442afb784f32c30e1b010c331a13db5514beaff063ab437e3ff6e8f2e7b0d9d5241a3fa969099f423e685b854e73d7b5db9f767464d62c50eca4284540975abe724af35da5da48f605e2423a892580da8bf0c97cfc4c7328f1ff08eea69f4256f6cab9d8e84250910d46611d0f571ae949bdbc50ef04f8684304d3cd09863df7ba6ab8cc57f880600301ed3a4f28de9b5d20fa52df62fdd78993dec8634c4dd78b85c41b0152023827b65e7b7a18ac4dba9921a78bd0d7dc0ee0a634aa9edbd376019a66cf296eed61068e32952fb5d22816787bef5f30912b79bb006688b33b85c91ab07311820ce387c6a7616ce225ada5cae8bab1629301e20666144edf1c8bb0cf1234d10a240ad29231b06b13e66de9c1a6b2390e60af2d3a621e47ec0d061bf9140121a7625303cebb0f9acf1ab8d96ac28e13fd0bf0d5510bd9bdf2cc8de5fc21f61504eea3a536b88abf95a2cdc2417911262adc0ed35ebcdf0e5c549ca7a1e460b873d811afed60426c7764786adb905fd74c52d4c47d6562553f541db0b65f777f3bd975ca9b137caf652aea15780a6123a63e1afc3376e5ad98c96ec1a4da206717323f34f014c76f8ada168f3693dd465216127a07c0f6a70ad5a95d6e858bb365b55a0919c431a85bf8d8ebb1dd71ecd37259cbd1e7afc4dd210b805cbf4d667ab69c5d53a901cea029ad1ad02c61289caca30a76db0d23f14de4a870efb45a2eaf2e33736ff6c612dfcb83336f48441aea1a0e2569b0da47a2894b50957b4bb934a27b61ebbc54717b2d05e54b07f18c2161277b39a7bc67c79ca31d94621ff217deee9fbc83912053ba5613ecd04c1ef8ff1fe1dcd1b5ccd39646f29ff6f681cdaa693460c324ce9d68fb00a5f5694a18bded81b793a8ea7f75ede90a24758636706f0fdc2508a0e3b6ebfd9411bef178fbd5c4e2df2ed26858e41e04c1db618069f0b1e8a60e0a89ecb7b8b44c1d0f648d4c64bbbfe3da7c3f8567bb1e611f110c58dd7bd4c692d7855f78fcaf0fe33e65703954488b4bc94cf8c69c9a43ece6efc0737a5c7c652b0b865decdc364e5bf45e646105a8ceba0fd223c6cc37408632e00dc6c8a6a412200c8b31a751347a9cf5f2006c97ab47f50b02df9e6841dedc338f047fce1151d927c859f352362c8271581df55906dee132f92735a4d186beaaf5bc6dfa69ef5c5f129b920c76009feb24925ce1c284fa941563ed81dc01d10492e176f7bd1a7fc3cd17652c21efb72993ff74f8c7a97022850ff5a48c0047e8f91fe3433fa9f4af971213889e710dc2f857114e0fc7c7ce223b948184778932c698fc03dcd9631c9d441f101d903bffcb88a91876431946c1f448e239a564d894e77dc60d6884d8466aee3e5bb1ffc5fe96bdd626878dd1517ef086882e1120b33471cd050c381568caba592438ee4c73c5f32be7b75ba7797a45576dc6c3d62cf13a48f7f213059504ee979b95454dd776705375edeeb4ab7c6f456b8535fbe7d6a0f17a00dc66078a4663fb268189331722af5c21a5d59be4b4ce427eae1ed1d2fe0f4d7af7f96aad0a00ab0e95130a70e0bb676eed61749864186b70ab33958585af28e034aa1f7b5d75b13448704d3cfb8eb92cccf264e39b164071cb8532a8c2b57c30bda252d4fcb41402c6babffcb34ea06f203f407a53afb26f809bdbdf202538a76b11fc45911b9362ca0df5728b07d0941c29d039663e60665d43ac688e94ab7254c50e22c944c3b271abb05283792004b31788e4b2b5d92adb0aa38c6818ff02cad9bf10506066b981c3b85f56b656477b1af7ec71c4a6cbf76645b8281b41e01251045a280e67318f1c5af0dde546b555fba8b7d475b25c95fb20a561660ac6c630a8957f4e1a4018a0aca108882516b94e3c611105f7ac873d04e81c5b6f41e8882a24f286e964cae58eb169114ad6272f4124b0fd2fcbb0b3abd617221af7767ee160a4939e79d1da007120a7ac4507166f890041e2bfe46bec3d5e14c06d8def4ab179baac6e4ccaf47a41c8d94450e350517861b9b13e059d00d93d9fdd38e1ab73dcd8c400d91ba3372d1c57b3e5b2097b15ef1d7826204d7c5e391ce2a39fee5235ab56849a3865edb852cf0c6b3fdc38d72423bc987082f35a738f1cfeb130fdc28c0ee51f6d82caffd6aa223ebc33be2a482835ea4a7c1e3cf1b37fe5d0b083788686bf99b16019a7785d0198cc01a91b84672f86ccb82d74041f9a255a78209e80e03d90daac6d3982c70880ab6f1943e6c5f1ff2e56c5f08c61e12ddf62066cf5b43fc28d1730cb64d48ce1a53905a588740016746b572daea10f531dd9d110a08da3e18b601e58b1fc06fff82876d154363402868a2e067c3e9c89232f8a3a7a2f0294601ac29e1401a9774902aee2fa2f02414ced1d8b0381dd9b50561826763fa5c3140886db7a4b9dc80539527b93d8e7acd4c68cbcf5dc0112d7819bdae967c8a3d3c79635230ad0c5b17572ff0c9858fee785a78a7085b73a7c2952b79edcc209803544755c368f6154704999c41de00cfc88d9e0606186e2ebbb909fb0bacdcf2bbcfd4208c05f51927be8c56f6831aa1eeccbe977c9cb932212ebfd6a782982d8de6dc6d03823b1949df498c84a6eb2df46b262a6c9b9161c225680a1487761e75096e2482e432532705e7b5f35f711c43e0ea058dbf0b64faa756fc6acc5c33272236d37d6a56610ebbb9487991ca21534b89d8e7b6578bc2f5454ff44edec25949b641267027d502ddc91039db43d5da4caecba7d5ad648e51413c0689e0c98d139b1befc20a53611184d237bc0d239b7673420734bd64170ad66fdba2be15cc976cecd5714ccd05f08c89220f2b64fc1eed3bcbb22b67e71b1fdec4434e599d095779033fc450431d7f5698561ddce3621c3ce4959789bc79fb1b19483bf64ae68f1f689364ae72bf6dae7a96ba9bca25fa58abcbf852ce0823840c51245ea6a737796562b1d9ade2293adba9fcb02661740d4857a95be925b48292da481c219f179aa6ff9ad0d417da1049eb80be79d09e2122d98b42e049178302a3c2901662042669be689bcc4e04fe9067c2c9e83b7aeda3e10d668c3f1d14efe0487301a06f3b7d15591476528ced435d780db8dc04f14068d65b438094b2de125cb321ebd0755b5c212238b5c7e874d5c1ca553f9063665ad0a5ff5ddea4893fec0e809c2621db3f5dd4f8852d1decd37327d16c992c12b56807d645efabe05c8130db5d34864c34181a6d867b7fefc807191a687a83908b37df780c3d24ea92bb317a43bf74d6f9b8f90eab8b9c6e512f1ecd9602032d678afb458b434c84f9796e8e8b267d090fdddbe21057804cae95a97bd0758f3ad0d5024f30c481fd256e7c3658f07a4b45f930d62ca840663ab1b35845ec5c6e3fc8a981136c0a9f6ebee1b03269d2372f49b7320fa74d60f28b5d958ffc65edc64eaa0a2edd21e34fc1b62208a183c708bab4b3d2a17f0c505c9312b86f823480dfb44b4ac3cdf5d632ccc5dd37669ec40331ea154df5a61c66993bca692a732471efe6d74e34fd459641d5dea663a89466f5718dacff9b542ca1d82f3e5616556428bda65f7a9c0c14947befc2837250bfc2e621dd301228ca4b71c918c96fdb5b1a6f762e8b571b305f244da6764f99cc62e669c9c20fbff36f082d58a0ab4aaeaa5e634d75fc279269e854a90f425303d1c369b1080f576e20b1983879c5d8e85e90babc2505c365664bbb020ec6c7ca1a1b4adf0a4ec7ea7f9982a331aec827e0bcb311e945e85f07ff7f8030901e813ff2d1c2ff7c3d42167c6a85b66fb87c68dd09eab19aa0bc8dd566de9c39338622772f7981be42646a59b49cb31214a9f6de08d832821ed50441ccdab9a140e94b0b2472fb47eecc94aece3196eb4c1f8c93f5eb807a1b4b52d449d6f15371b8cc97b3e95a357fb380401d8331aa3440610e3c0eb0d58503e891c41423db3539451cccd5efdad518801b52bebedce1e9aaa63d69c80b7d1b06ae2026ca30e456ac66f5ea23f75d4c8c5bce40c5594612243612e320d1ef9f878c09d940d49d81c28cbb6c9a20d0131b13f69c56ef196675a90996de25f15c662429c69007dac0f6bbdb488007bbfea39bdb046f4c8f10e0c2d3bfce2e98394be1c22606deceff0859d81d5849d0c587ee40e7d1ebe3ebcdedd9e050a939feb1bf42bfd5a86248bde6a8ea0a384c24f478830c2affe578c154fa3796cc42b6d288b61cbcb0a9cbb10e91b777c343f653b32063259a70c37da7df6e7fb717f3fb7c4cb9091717f0cd47f777ce6935960c23cd174cef70e2545860dce5e5284d22950d23ea076e4c6e8b187a729472b68d0509bcfe05ee201e13abcd96b518372168391de06811021ed7f479e8df4180381f1bf4242fcf89ff4cdf0bf986c8a53fa6d1b244a38a456d51664f86d99f2f011cc3bbf83afb2a79581c47b41138719325a4640de58f234c523b107a8c4cc1558b04203c4ee6c0d4987df8f6418c7b3ab06a904b06e5d84dffe813ba066de50c011eaf76c71fa42768ddb00ac438843889e5444a313cf4b678badbf4c7d1a1d7311007a6498390f969b11ae4826bc54b8d89a17116530ef75b35c0aa05dfdf3b3e28e5f67c7f76c65910970caa923cc998479cce5256931ba6d8ea203e337caf77d25f45df0b367e826cfdbebb011c2697e69eae6e989594cdf9c046f84aec680d371007f046691b5d4fb69299602a8b901ffd95ae59847161a348aab26b2661abf31465eaac2ddeb0f9c7ec9b73cf47a90701d66f6992d784f73d01ef53b2e1e27093c9bd3eb5c5bcbdf62154cca5c7a59291cc453a4f2a6775c123564c062b39900bec967356c4487a6ff8699c1bb1459f34596950c97c9a917cc610036a732325e8715567b8d8aca65d511de3f182efb3cfa67b025980907075837b376f3f25489b5a73d2f5f46e33c0bee3294dd6c399edb5c004b6285d8cd0f028ade5c0d122610bd833b5609bdbc9f4d40dc077a669ed606f03e4029bae3995a4b2957db5516f0ecd2e9413faccae4e2885fde25c5096e94c7357b14554babc412906c29766705c2616f7fdc68601ff3682d2c38e199a05fd325896a314c000d3236017c69b6ea10aa1caef1d082599ba5a2cddb2a9160c65eb07edf2d3724d6b9397093687cade1ca6ad53a3c1be08ccf8bf2b07d2d6504c492f50be417eb9368311b4d6ac56004553bf3455432e23c2b2f02083e8ff71d08e6eb06b1f14e3096433a980bc6c3ec37b12b5fe1138c1a8e7cb0181cc0c2045e8a64e74cde60b832de8ffcc33d9082b928f1b133e22bf1c60b0e533a88388d30a135381a9e3e6a730a05910365772ba2356636f60d3c5545e8dfbc14d89651d5aa0456825c7d76ebaf4f40448b1e0463986df300e06300ed9289c1de3674da7590d81339a43e5bf1878d98bf760e00b054ec929df0776cf19b4eded05a3b32b377f7044182696b12b8c209fe83b5d037e9526740883424d98d337ec2039b08c024f1643a70fbd301f3df95156e39d72aa0df7c28a293ee9ee84d1083593a3e89df9e2f6a1478f54445dae185b6f5db8e0a69aa2367f185c4bd76cae538e542b32dc478bc789df092d89303b566e53908567e8e8c7797931c8dfc781389e585db872041c12bd5cbae21f384d7e7dd8fe6db01dcf44b5db2aaaf54cc403f00b0948e3f6cc88f056e1074fbe9fbcb09a150c3c2d355814aaceacff0aff9e0fb7f6e236a41beb253afa1941ffb8ebe0445ed02bb36dad864a3f5208508f0e2fca9dda9663f980af972310d2f01fc908c794630d1f5709320ee77fc4b075415337fc71af29976424998ba22eccc37c0c0f92e79f2f538b4a9577210d5fef9a4f2c867320ff5efe3e571b156a84c688fdb9d390fd4c95953ca8c0baad5b9b558abe15a779f79ae75453e3fc1070dc454d59ae3bbc3e32b2489ca21cfd06438f3fcfc92147a4b5f4badcfe9b9126d0d7499adcf18d6fd49aee123a9dd845c99911ff91f47c89a8d60fc48a63654253e5778499a5762b885e2dbc2734f69ec570d74bbda8f7922c133c4fee3345ea3ae4ac7c29fb6f497cb043c64dc9d4a2adea355448f58f31e63ecb9f2e6c5f32f002123042ebca4accefc4ec6eb658269320759c26eb540fc60e8eb7d548f7ea923edbaf3c3abd28810333fa9e0bd971d82c8af0a4fd6b29eeb45d447f8d5f5681c2e80aa22ad42fb2a60ce59ad667579e3421e1733fff5588cefe9976cd3488040439a6f8621e595a1c21bd805328de4f8d3a92dbbbe2c148d44d4936f0e3f7f91be4d19307406204c1ce6410d5fa6dc7aa3270c85266e2ed3918927566b622cd94b2be7399a41c0320e4ac8636580cca4d0f5774db7102449a1db95fb9777b54f3c0e1feac13cf45238b0e8c783d0d2c6f1242140ce0638440782d8ff34c926aae092460b312238cd7d0b239a707becf6cc557477e9491a2b79abe483b0ecaf5e0e9b2066fee5270cc6689240152fd2f4e3436b271737c52dfa2b9efe29ece1664b1e3ac58639db313a8c35874e08d0f5dc27ac481c748ec8c013a75126e854ee7d003fd4138e2ed35d88a23876ec3b219aaa09dcfed65b31ef7604f9d5d38ccd4cbdc7457ffe56e19239f4f67cdbc552e64e306a94bb45e1b0380e92352e8c138ffde891e9205a6b570b233273598e3a6fd0ac245ab6b8f288db34eb9251b7a23cae943626a89ab0f62b7119fa8e16ef1bf0177fd9b8669daf6964b70b5ba4eb498d5d0334d94182dd59cde2b36c3b68859c20d72431518e3367790cdf8670b7fe9e696f14384f0085864908b17c67867c4b4d6c596bb3a38ecc26f3f4263f70d51f159ff25279547bea9eacfc5321c0a54997661effcf730144ab738674e54f5fb0e53637553a345e04e1960329979cabd487ff0d2e6fcbd46dc7f78d04a1c3a748337e5cccfb170f37e134e18b464e22464cb28ba75de4deb697e3dbe38fc7630c8301414df14c06d8ea1a5114cb143919b49feec8ff088f6b708dcf65c7b68080b13dd48f6eb00b0c5e23e390a9976125581cd95bfeb3fc8d021009785e4fa7ce306c27aec6e6b8442f33fb098a13843c0407f09d74f09df0e6408ff9b45d3f867cfefc469334579e3c83819f69db101f5b047e536728c11fa278ee03bd12e0454924cf40512e1eeda94f0bb5b1fdb319536a300eaa846a2f09f03b37e33018a075b1d45616767de4e0e7d1dd943cedeca8e73ebaba60ab96f3daae894951bdd35d4c6a1d476d8f1c1668ec72f7b37acb9a95f4a7745d3bce7d78ac592e06a7216729882946770e46f0a75180650053a34286dc01217fb0cadbc9bd19db2e7996fc35a70f5dc0a46a368cc4b7924abc28da2eb7a8b8d066ae89d643ff6b780570a77bbe5a72c6d873d24facb91eac69e7fcc43277816abbb695491507d382a1d1eb311fceb8068a5db500ed2b53871527dd3e50593c4dc394e3e7c0df4669c85e1963ac3782021f48696e9cb5c773ff2d80f7bab825a37f9dcd74bff504a245532649a537d0fc85ab2ae97b9f631811cc0fbe19cb12902c91274e7c36ca679af2300d5528438de1cc78f0d752907ea7b677940fa55c3c5878d1e143dc5f82b907b44ab9feb1ad6c26f806c08a8fe536f53e5e31647cb79262f357f35024d03aae9805c38eec77de582425d252dc","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
