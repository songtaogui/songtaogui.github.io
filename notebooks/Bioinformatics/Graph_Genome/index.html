<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6f40ab0b7a8307ba6daab39ac7ff6fcc0fccade51476d9f112532f7f2b16017c6e1fe235eeb98e831826242c859c3424bf3ef4e37fb5e985b9b88942e8f3dfbe9f198173164cb22692f6639107f06d846a58dd52a28ce44f175bb63c7cf601a95aba77c9ed5635f5aae2c51189f3d9fa9c6c093ae7343bb3481182fe3382c6216e2906bb29e9707e3dded1ca20a750ebd7b5408c9c1b06ed2d468db40f1bd2ba7e815d6773690d35379dc664cee56951ba466bd1d10d561cb3c2a66c9c920357337bc13eaa6550063d0395448cb01af0b804fa88ae2a4c50c1d19cc0bbb1cd6594710b66280a9c5a45e22ce3be7c0ea2839175e54963414b4a5db0b9d07e0487bcfc8cd78d313d7c4348d1b8740b590ff7dbef7aba2b549ed76a5fa47a7112575eb8330a09a54729cc3dad96184f131105741d64d7fd1d53fbf95ac2964f80358576818e5433b51ee1e9466997a2504e41f59d9b2c8aa71ced710473345e0bb8ea14f3cda19ddf06b11a6161a2db11144d28fb2cdfc12ba15f942afb3d28275c24836f0875a9ea463ef1beb91c014694a7cf5120a7c4b272112e3db18359d93e8fa2d0f1eeea7064524f96731d4f68632f5aa01b1957b3d741ac5cd840fbc4d254f11fdb6d7b178d27c9ea84ab785ddc85e26f0fe0191ebd641b9b6ae2d16ca9e066b2fb9dd197c46b6c5d9d09c554c46a19548855e60de0ca440f4159ce0edee8f99c89341a3c0c5928bb868728d71599f5de8e7534685458dcd1aa02258f5b80e8a97d79233dad1b68126a982ba45a2f0f489085ed1fe7fdcaa2ce31614d784175592fc62597297e9250ba26c64f023739403b2d724562a9a258e6225c00a5a4d96e784d0e88b0c2069b038d92de8f7b1ce1d1497434414e8a635453feb526329a2f5bf37731ed3e7c76b3a5d34d4fd427d90c7dd9a7198c281f3fdd9c4d232f39b7bb5a8da15ff279843068afb6aecf7ddafef2339dd2ca9e891d08bcf9e62eea70d7966573bd566ca34ebb7219a4f0b7a59a8aef74588d43a10c3c7f22506d14ff39f270d0e5b630a7e99f63ed16eb4ba21edfb52dc7a64d395ee24cf96c14de4433c306c41806fb9da9846a1d31de88ce39d7ffeb22428bea9eece851757564e4789168abec85f9d9495425068a37ae94339bb93e085da31024f08ad1956507665d6995a2ca48e6f3143d037703ea20eb039d2a417d56645f932f096514dc790514988f735675cb15696a637af9ea6a4dbe7a232124397e811314e4286ecdc83bb8f4f928ed02118f641b59365aaa9545eb66faf583a9cad25651ad2a982119126573caef232d78eba17c32024dfc9106ba89a12c975da23b1a516345a559d35e28ddbb92db8a4b880f152b8c8048c103cc86b48d0620a8032240a098f042f25a4d1d59e71a12b8a47c79289cb8e438e2e45a73ee0172f44bdb5073235b4e56e85081f3c7dd30d974b87439215359737f78874cf6bb47c95e48502a1b2878c6b8d393968bc8fc97c2f0b4d032d1046b98f6377fe67ee11608525a8aa5f1b514b58bae8ded4811ed9066514204192c80aa3193c50f2adfebe202e5e96f60cf05d746d2b4589e0b97e8a6aaeaaa0d34683542d8cbacfa834e68969fa7ad2c4dffb25031510056ab69e23fe105b43d71aa1472c0413cc97b6736226e4e1925e2b9fa9b8f3c5cff2173c2f5b8e086a0441ea3290c61b864d7e7f4930968462baa681ce24ff196a50cb7f2fad00d2bd89c532d51b94557e0866fd5f0821bf97d1f2bec3965db90ea47c1f58b4e1f76bf98542b386290a590e978e41fcd355dfdf319c8be5379082b1ee2a1287890831dabc7a6050de20890fc4ec9bd6b020ee5b67a7d01fba539796baf0f42f54ea7f2e0ad843d98d5df8134933956ef0793fde2096e949bfa187bd74c3839531b2689341ee6595bcc9375f6ad5e16e7cea2a694d13ba8316fd6163ea7edc01be343454ad77c34a069ea6ac0c48640afa7e2e377eb59f0bd61662c6cf3f9104c3bc7c5b74d99331b962ff839e42cf1b789336aa3e300a6c5659efc07a2cf517234aab8cd274686ff5a3344f9be727da900c82d8b5c3792359f19552506625306318cf6e52285b37854c83fe1c97d9853afe1b6548c2baaed6b37cb0cf823fb6ab1a4e08222b81cb546c49f557b23c56119be88f28e0d2f1a933294e6bce8251e91bde66b968b9d58481623e88fb15c6d8bf6c193b70d80b61b9c54972eceba369c817f82d043a50b2c2584903c4790718d07ec21302f76e53a6c618cf47952222ee660986fb12cdb384d8da77407b3007202d4656cbc2590b44ea6688ff97490ee58d2f04a92d07fa1cb7ddf4db74de5d58f6c181ea9e1f41d5340ed01ad324e913c4049c2f9fa3c6ed95d1f597f6c59b568400a4fd11f8c8b31f28893c302aa829d91221c28a51c27eb19f446e46a1e6302ea99652135009e4322c7fe578720dd58a88651cf7037cf2c5137e5e6bcc2c04263ee34d0ac33048428168139fb0af4d6387c0fd4bb3c3131fec384b7fe93623ccb4c941fffed3d1dcbee627932fa16777b9f2e21d1762461b5bc5ade8bba4b09c5c983a6c9758e715a75e80b580e419ae433d1bdec6d666e034471c5523970f83b94b71ebb612478b9584c31d2e1c88d46bd494ab73ef9c77e04cc9d2e2f219b96fca029b97894280705e0acfdf3252ae379e9762e40aa273fe6ab4c4ac15ec48e7af52d8b4e10c02818646edc7ea022c9ade483610e88549b47f1b58bdc4b824799fa047f4f6f55298cecfc2eb90f799bd84da6cb324c590eab969d13b3de86d06256e175acc1a0ab065022846de814bfe6e18edd6789367dd509dcef4d7a45b5f4062324d581cb02f48fc7b84c62a69ae41779c162588266bf32a055378cdd1c196f540785e47172de934084e7a40d7d92acd413a467859054899c783d26ae3eec3bdfacb05600ad0aa98d8b79a9967d580323cc64e25ab0385b08c422cf32336022c7555ec1aecc2a077b3d6e3ad8d70926d3c131dd1c40b6d129d2e44a00ea9bc9dbd6599fd87eb6fee64648b9020887f6e63fa200f6986931c005608c916d9028ce4598b4c82d5acbaf11fa350f9177f685f902dd7fe3b1f503e512954e69d52979a1ef149e8586e063828a5844f9b7999784fea9ea44dd62a4a38786adcce103dcb0372af21f6f492d8c6248acbbd8c91f510f235e4aadef4636ab7ecadeddf8cfc2b8feede691ce4f70defc2ead07363a7aa93d5052afece380f97545028bc1e5a0d3b885d959420013c36d4815593afc90429cec9bb693d8f4c084287f8f1c14a88589b3f304e2b99249064d392eab3fac6b0a69ee12db2cc7d260c98b55d96958f34384ecb8bc59128442dab200a65b465092f1a5f7ac9540729cdd4baf45906e0ab73e57589512e30a413be451c8c66cab86e9b0aecb12b7d6488a36c2d0f096cd0e08f6ca5c09781a389cc85502294094f1913b56c8b179492817104f0435983ab21a63f9c06bcce3bfb880d7782988566f306e30a8df69d09fc1b7d5cce6ad531e66f12dae36ce7d56caf5b4e2fd9940b904d620859d696f53c9e20c1aefede8f34ab456ebf95412852d41831922b13d739e84a16b7d592ea46523cd04411c377a3efcad059e59fa5fd93cc1dfe10efb0a9c763ce9c99e608548f77cf8012cde1d06ab459cb11774e554145ee12cfbd982205df10fbe08b0ff6bf2a7d68a935261e8d22a3063abbf679a652f60136fac140ff59250162b93ceec74f74c3e91b7868ddc0b4e76a533fa5815bd1e69aeee1221b9230f1bc8ce980c61012145a01142a1779210256b71d90a12ead01469f7260f15634ba2a801758b4d6c461ab32bbe06cc120da3d4c54c6f134975c556b8fc1a17a212b14f4bc03ba40a8ef0d71950b334ef8f76891760fbd4c37497a7c78bba105bccba3bf2d495846137ee29b7d05968cb2fc1c6b795c722f2e3960672617a8f992b4ea1b142523ac4c28735ac1073e76460aef770cc4a1d51ab9282fe92118fea0198f0d2ce6a2577cb3e732ed7e79a6db942a7ae6a3c3ef7f9cbc9e3ed2dff716306c3da8acb806ae4f8b4c33a154642f0b31c16e14ff9851aca23c51840116a396f502781c86271a5fbe60dec4e5a1153ed24ef4eeef7eef6760f410be95cc201659a37f2f2f65b7961e26f315137976ddd38b9d8f69fd4e82d72b4ea54b5a56026765736d5eb16dbc648cbe40d900490128be0bba578113eddae53436f5778f15fd5357460a5708b9c7603043f4bb0f9f6e1e654d8756212221698fd7a4a7c476c3589cb9033dd82282cee73d9c420934e963b062d74541d9746652f03915c75dfd8a7e0b6ad8bcb3bc06e458a3fb54e0161ded8a66c105e119b8e6c91ad3167192cec11152afb0858d246c5149ae78d164ebdaf85ad766d7b3366e1a32c06c576ca8f51f32c3db2bc39ec391ad21c760a343f1b98951c356a800722f0f0dd5bbfc260fe159818679cff91545da1d4d3ed904568a60e5186fdbf9efdd3c2f4fdb98852deb708cba1e75cea45a68b900cffe409fb5be215aca0917205304e7b9218d03fe928bf429ee3e3d7298c307b1f750b4ac083258fd2a6d7537c9dfad031b24f162b16aaa0f1b0172a8682b4d28ab4ba5a1525e6e86363cb937864cb5a4624733f968d4643c67ba1de46f7a34bf84aedbbda348a7de55fcacbef95a64683d10bd28599e03796b54609650af91d1a63579cd6c394c4b3f8dcdd1160927ebef5aee86305e8bcf81b0801b4c4bc6b9e154dff8065d7ed964fca0c14eed0b22887cd9f1ff646bfa841b280c1921a7955234ebadd2120a00c24c80242b678ea5c039d51bdc13e4c64b8d48497f062da1060704c78ed22247092bf99bbbdfacbe138f2cea4867c1e755cb2c71334ad639d4dbf8ad1f42ab6a9bc729aaf7690ed0f76e997be47dbc64d77197c4c68261ce549625919514d96df5319729023d203addb8e629276f2b750a3cda02448aabbfabdecee339af0c414d102c8c07887c051069321ad3ac0952e5019cfecd20dbe96bb6cdc140aa28cc425f47ccd22a2a736a65b6241b5ec7b8c81530b3233bf8f836bbca64610dffcbf2dae87d4d9d2e8524eda1ede06fa37a986fc7e8bbdc6de139c6a65e23ea3cc7e5be34f1019e42b16ee4cd665f50aaef94dee3a273fe39825b87cdf909c87b21093785cddc52bc3747d0b4f8af4eae8305c576897a0fd50b8d7800148821347d53aa7b012252e0f0840582cc06254bff76c98852b6352916bcdbcfb127cb0011871be89d8a0174b2f79cc4fb276ee972b5591f120af319f6bedba8cadd17afce1f8c4b826c87a19e94f677f3c45ec587220b6cbbd356ed69e361c45101b15cece2f0546089b99582c59dbaf148b13fadf11b02fc65a959865f2dd8fc5b4bb62e7d93c791b31434b688de018aeeef2cadd97e2bb6c6a5807d94355f7fd1f5593b0acc30e618c2600658ca1afe08042d452232b5966fa0d72d4ce2349d142a7743a20d65895813653e30cae61724c9cb7fc1c1404087bd5ce54d4b840ae6b9c1186038adf01c4aa518f54a4f895e87415926dc69ffa7c94672d7f7762a868b4807060ce5164d5c5296db88286002aa7d600412a78e720c9a6e2ffee8a5f28359ae45ddbbb679ff7a4e830efcf0d2972d59753bbd197f840a8d205b31470e307f5e83a2628535d1524689dc2e75d2e90e504694dedac4a5c5cce294ce9a0f63a39d3e07c8e11246ae182a34319061a6075daff1b51719fc2115bd10802c11cfca92d80322d06b9c374159e579c00adfd3d1396402368af829e0bfb254b8fdb0426b738e8fad460d60850360a698182ed517b60705218ecfa9f7d4fa79dbd8f981670e64deeeff4f6e9babe1fbc94b838c2d3adfc57c7f454a088cf92594459398914309c51df1879633f994df1f1e0a911c763fe1298531b575888895c29f79bcdae1cc6de840e6b945d322815ec3f30a9db811ca3161874febd56119e9244676ad587e4405c027f8395a95b5c3cb010f72b19b7ac79adeebc9ef96393d3d9054402029a439b8c6c1bc7cab3e3772cac3350886e54b39882a2c61e20ef240cdb09ed2c23e3b0a4ec7dd507a9d87baada3856d918e779e9d38356fa65e9bedc7b85f00787487a23ac44f329f25a6bc2c635eb9a61cfceaabd022ccd74261f5d4471501e635af8e70d6dd31a2b872e4bbc0c0b2ca1b60b01c68f34cbdea547161641aed00e81df99a32546fb9c22dc317ffce03a77e2d3016a316773d72c737952e5ecb8afdeb7c6208e4f4045ac225d87eb848cc8ac9857fcc184ba1d36ead7c1f73b3079224971928b60930b37000f26f82c5b0aa41c2026c41b5bf5f33960c1e3f74cde133d7c2c6c5a4cd5ea43a5ffea1195b80d4d888ff80cf07b1f12f345c4506c62058b6457c3a94eb4f326b8076afc907a7b0ce4260a95fc701d66c4d970e4bde0fda723a3c8f78700c47dd612be92a125410ae637e96b3910b7982cdcf533234ee7cae3638b54eaa1f583108383f8baa0c9c425aad2d65887c9adcc69ed1b09fef3e0207162292295e94a8b20205f885f960a53b4c97de07f4abfb3143a3b303a7f9e1734658e41813511bf3a575ea6f4c4129b13ccf4ee444852fbd6d4110e28c39aaad50d2663802ddee396a526072da21a24770f3c910c31bd262d2e5e43c056a0cfcb9e4a779be89fed17a0e9e2b49678dd2f901544be36e6a9da6260421a5fc114ec15a29c99fb8c03466bc467c92999d344060dcffe43847ac537a56d97c5faa484b1bcd73019ca5cb01068f3e1e84ef2993ad1f2ed48a958f5c8df5a854b6a2bcb59a6fd25a8ad60826804352a2b6538942f3f130a57af5820146c5fd19ad35a2c074231a300b14357b589b6df77ac2f56d9af527216d6afe1026db55eb095b7003e6c1a77512c3fceb8540395501d1b25b633f0437d5e580c7f0c0236687b85cf693e75997dd0e4288464f2ddffd51720a9796bae831132b64f77463406ce07acf66bbe38fb359b743d1a094afc8ea03bb024cc822be5b58fcdcd3b8ed98281096425404f9d88768ccd0d65804f3fbcea2db54c48be73de803b23f3f4ef7b7e0025dca862fda636c677223cbf3f2cbec506754e9fb2f08379156a4f36839147beae87b8732cbc7f6a34e8f52824eed4ccebce0567ab4c2819f876ba35b9627f9ada30ae3ed282f59985405e59fd5212abc768645121c87d000201094b9c9fe95dc84212e77129e1d3d0532ea77a4020ad3c4ad5be791164fd0add6bbb5541f6de8aaf77f7a19443beb1eb3c6d18509abe9ff68f0bac9b32d9941404f01744826a504af22f4c907a3d4fb542b38ee88966ce5b1f0db79ee13dbad969c02df54973748b0992827ea7d2c4a1fad3da527f126edbeb79b8b2c88916271dcf9b7425c162c90c106345d753be7a66a54d22aec02ef117b3d6f9a153dfc16503841bf3462dd0049a5b18687d36c0597592cd5e8cb02a494e3067c62fee406ca09386c168c1a73538ebcd8067570261b89f08479b7ebbb64a7741353930a46f1d924710ecf38b8727270751b5ad57604c42e34a1bdee7649d283965a014aa52c5755dc7f47790bab3555bdff8d1d71d0fe537b88d221853671cbb49ea1ce135b42afaa1c9b134b82d89ed669560d5ad20a369b347426dbaa05c96144d1d5b3b5b0f684459d78eda414053e268cf705c7ee3609fd0935a3c23199cf124c12f2e329fe8804ad03b64699b21eab65f3ce78e13f8b12f0e7ff333a0fa7708dc9a916b969a6393b78ae4573c7ea80bbaa3f8c1ba4deebd82520437fa4f7d313875b763d9c90a4022a7f18c132a9a3d731936f9365dcd5618593005f17621cb79f503c2fff188ce4cc0dfeede39a4ba6dcdbe9b8d1c480bc4e2b75cd2ce4f8c5675cb19f020aff9fddb5d72ab99d96b3b9a25ca1fcac6a3f40c3b6075dbcb232cd34766f345312638389b2c732540d2ce8d628bd1ba056857c669f93b6740595cc64e53e08b8a32f5cb74f84f7e186cfebf9a8b32079c6c12b4820273434f78afac93e20c9b3c10763530a7f1ddcebeab3e4e1e48338a1bd492d5fc2cda2cbdb8b9da2bf14716ad2fb096fb7eff1f17a3fccfff6c1b48d5e96a5049db7b9078a4829efe6fa9cc7acee1fc0b81c0cbd52b40397121a3c9d91189754828382cc64f390f965d29eb5680f859da42fe91ada81a19ba7c1ad5867709699967055682e13faf0d26a27097f17939b1b094007cded3cda6ea06b142f74d7e02c5df91628bffa62c595f620cf386bb114bbb3e792019f1ab8a727119ac47cc858ed4f5d478e9837cd0a66673fbfd586dd2e4cdb9ab5ea89bada1c16c15f677584588faf25ae482f1fd1ebb8d1bbfd4c0ef32dd59788b3a62c99d95c4ee233996f4d8d42b62013b9fd490db85647d814e1ecbb62963cbc0fc058459e905057c24dd12b875f5b5e34866b3d5290b888bfb0c384c2462378a9c569f179ae933237515e27b1a1ec710cfc49b57c47c3007f95bc70efbfaf0e361ef5b6cd453e3ed83fe8b4d47a4fc43fefd69603a742d6939fc946b513522dee77f6f085b82b7837d199a7fddc3836377a0fcc0b0c99f41243224306ac2b4b0a0d708c9a071283f165738a919b653084257c1537e8fc469e34254c6fc5f159111fce3273b5a324649e2d18b8074c74f30f5a4610f212b755c88f0f69753fbc970c896e63ebd9989885df0ee87006f6e7adb7d8dc7675151a4fd6e643d8b4728686ab15d10e981933f378c8452cea7125c7ef0ee2601b7ed8bab41010a4ae5c20967f121cc9a694849bedb5267d2475414cbce88d3dff3417c6a41005091a138fb93ed43612c948cdc6126b028260faeef427974254184372f4a1b0a5d8ced5aefc80a058dd6d41d3be8009b64172bb792bf845c9130e8420de87f5c2fc0ba3c819f54cf7979c53732db69b0fc91edab911bd066f4563bfe01e228a179cc2f3427e8c422d3c84f4f358dfc782752a46c62b9c4443d2a22bf2fb8f640a96174d9dbc4b0edb202eb613114f8ac296f46bf52f4298bb4ce8d13dacbb2b5b2746906639c3386f8a5b742c1b5ce0b1eaa5325cb126cda1c91086712a4449d713b7f2657d65b8a4c6b951f219df56d97d5a213f79b2c6e1182e1f135817e67b06f681261e22b47228cda958a4695f89231f58539d5ace4c209fa44864dc411c74e5109dabb8b396658a19c1eaf29f1d7cc4a1f4d918dc35ad3e9a04dfc81d35e23944bcffbe79fe1e6fadeb2b4670aa4d78f7d20be87ea876051a13c8e4a2124b748ca7f8e21a8ea98631877b82118d1db0d3c5436dfd4b949f6d065b28b7cce8a3109838583019963f834c3a4633ca3db1cac37beb6800ef65c7ecd6650a9ccf63cb7e3aad5f791b8280e9518a74d183604627ddb02757643d8b82e56331529931a3beeb1fe49fefb73debb21f6bd479d622fdc2c0fb0672c62085dd200c075f3156f0517e6d803981fec8e416b18e8055addbeb38631a08da1e23411a58d4712d066ca6d8b16a9f77504cb6412450a22540aeaf3f3ed38210490f6dd10fde79d500518c8e9196a5ba99e46470475cc342b43de98dd7ad3524c76e172e33ef9fddc2f0b626bc959ad37c28771337c85cb2a59269913fbf5efd007b500940a95762a1c651677b22a71ac4095710028edf469f78ca3fb30f4b2048ace13940e0c1aed71c0a4f4cb26c3dfb0b18e835318856e15bfa7313c8056cd5f1b06342adff851cc682c55224a00663bfef22dc68b60d9f84475d04ae644fceef73b39a492bb7eef414e24ac16c2222311e3f5bc275e25ebe1649a78a6aa865f65af509bbb679635fab91e4ee99cb97a209f48a840b7c0e505029fffe7b524ca2ba1a6ab505e1598f1a1127a0098b3138f3e082289f9bea83c822f3f59dbac8b24e46a451a49f5ea60f307a9b7ca70f59bc9ee78934c818ee9ebafb99d0e4442d4cfcc3dbdc048535acbbb96155734a02480620b76cf0f4d792efb650b5be31aaa95532bc74db02b28645a00f04371a6c36117f56d868a7b1147925e54691433ff8be78d84ab44704f012c78130b298b0c8824916c1f221a7c5463a428ae59ae86360c6ea259327a441fc28ca3418e71e3fca883ca560040dfc2257d4d4fcbc86fe2171383773514ee75d5a259277f0a3ac0c7ec3421f1621d1a91f0e8cbea91b4e8e3a4686e67cabe6ea10b8c52c4f8ffa4a730cc1549a382f99ec840012492ca5115f995b6206f6ba08709f0e711114bef23184c6e91d15cbc624ce8c595d21f65d79bc8a71c8cf989f5da95f6dff5ef0ef10e58d2c79d63d727561a370cd7e982b0d0204ce6955a93f4c73ed930c6ae6d3616abaef65097b7a478d116fc7f76114259739d5e3cb91373182c687b9de5671ee3aeaf704ba835a0e2b846c8a10edc5ab0747980f460d93c8aa4d58e2905fb3b96b65aa6298d9e51a8f8af467ba01734e41ccddbbe47c9ff655ebbd07500061d891b5eba939224fbb374769d596f79201c7f10b4f9c8abed05487130f5f7af0728c010ef19c1f6e03ded4920b411e226277dddf7058852bfd457ca7ca1f532d945694a7e809e153c59fc974cf8081e93e0032a34f95df8022a685c0b7c01ed47eb3a67fff5633b98184398088a64cf223a050a65327bfbd5839150ffbb0da053bb040867265b019c994e014b8fe6c949b2a847867d2e3656a01b94565598f40ef8e257dcaaa2fb9e1d1810e9d5cf81c5a45f4abf289ce73343dc6a0986f0b9121c759e2b21d0df066a4ddc99fd8d96acdad2ab473171eab528de717365a35c062520465927de7b164e5453d7993bba08571b6fa23b4c2be59a8f239c21940a96f651a722829a40281ec9f18a1f4cefed4148ff17432086734a8a277452233d46dde8cfb267ab6634cfa6e6ff621bcca3c6093d77e92f555b6aa21d0259311b5ba4aa053d79bebd73e2d4669c5a496ab690b0d3beedd086e6e0d57220b02a216166e2cad414f25cb0e1c48d44beed2b2696be497db971f7193ebd347087232c28640a3821b098f9f20fbe6f33072f774f80cc39d2a306faab02e42da036f0945f172b48363308709ce6c924b5cda780c264bfe945bccebe5e1388926fa53d6193c6bf44c31aef02430596046f26e70d0a893633e026e2a69303c47b1192d63e79ec078ddeeafe862824c7bdece8200a2328017bdbc05faa0ff9751e6eb9f538813246273707be99f80d7cc0746d8827e714507f96bdb4520696da9f00bbaf0205c22d43ae6603fd54c83cb29ccb6401dd172d852e1eaffc489d2f45d30fc6a5916839db5db45d883ddd396365080a89e284007f1083540f6a9d97531d15cac9ea7e9daf8559afc70cdd1fdf09dadf0ca1b0052c666afd31f5bc714ab3df269605b860a7a6a4cab247fa4a96ac4876a8cdf58f0a4ceb10ddce82f10adf06c5037dc2ccbc8f03f140aa6c99f344abfafe0024df64cfcc9aa9743bc20cb3bf7d9f4c26c1117baded348ba8e69ae8f695ce1e97739cd4a38d3f696ffee7147b0ee584e95cf21937a767ee5b77770c2ac75e69a5e2384107404b349dacdccfe9f68aeb234fe7f43184a7b6b1dda2516b90e146b9df48e088955a1319a4b2561e68000441bb95540e225e42a6abeeb2bde030417d49044f3281f1fcb2ce5075f6ba4e9f5e45004545fafe9ef1eb1a6f1a9a7595f72ac2dc511a139aea8c8598ebd2478a41b3ac4dd68c287a7e870d565117dfe32e90baff617126a1135991aa54cf6617c0bb1b09b4cf76bc82e8fc242734a0db20a1f2a6c911a7f339cf5751622da9df83d9d2be4754ece82bc089b94026216224451bcffb4e1034d323233e9675b96d9dc57d814dfa8f513987025d7ec20178b389017eee8274af8f2dcf3bb70b8192de8c36796aeb75d4c4656aa29e14d52f4f9f88e9dc07a76ccad700690d79cbb0e95a47838b0f3527e45e24939de25f064b99cacf1618dc99815fe2b75ede0f93035c7a9a780fefe60bfcd3e53381a6e7005b1d1f08561daa6ec24b226f68a2e3789c6e4c499074611e8f08345f9cf3278f8e3de107c48de5b5e31b3225c8d82e0b5ca0cf2bbce4b93efbc529a8dc0001121ff4b8c373d8a23245fc15a09cf43878a6f38e3f94b95a855c3dc2e920908f362d4eb194ee42aa6a93de5a3de80ff77d10a04534806f720b9677dd5aae6fe89e9d778e2269c3a0c6bb42e5d09d1894117e728f148b90e53b2f6db55a0447e0584d15364a7cffc88ba94beb1a0c5452538633a8d01903d05a239ae270c31ec3a49034dd7927632b0d97e6e37d3f78b1cc6f92961de2ab356950b8e7d63209775f869dd38b9c30c6bbedab184eb66073834dba63290b785bde029e2ac901b184d902e4ae9aa6f11bd9b9e230d91e23fa0277fc51b3077aeae44084d6f68a34160505d18ee8f27f4502e36480e8b3380da84d5867233d776110d3280fb323c3b6fe62a8083efffd11d51ffa3a0dba12e4a239a6fdc95f3e8e4133a12dc2eea5b1c3ebc0df1514d3f88768a8b1a75986ade3e3626b6f9114d31d81c8bce8f82a9d0264840517dc571f5243bd06e98baa6bd3743ece78ddbe4ab5eaac5772311d876b3db499727ecdd7819f90d364b0f70a01a1f5b614a157f68d07dbfc54d0b45eea11fd8c5d764bc0506a79fee1ddc24dd2dbea7ad8eccdbf420233008b45557d18b53c2200463c8392abbe8035cc0edd80c9d77d7f7817b1279b59d05dfe292d21edbc0daffb88caf149ee68ba8a185b7e4fd381a57199b600e5acd3f2140c6d43ec9c238a8cb4acaa436f4ae8937d918d1723aa8b4eaefc1cf4ba7798472df456f11ea950c9787a46696af2082860f3fda93261ce10afbf37a4d4580a43ebfba4ff30360a29542ffacfb00bb26a3950c9b0e060e88e3136292b98e0f2a048434182a448e28d79607526c6fe9547c8bc65907f1163d07926468045e588cb9d664f6e8d972c3029177b44debc7a8fa3033292a796c9cf84e5370af4046700fceed9382a0d130e967d83b30b286ff136052789c989fd6150463617056ede69ac310357de8e3a3cc5155a6c48e5558b66939e80dfe578fb60a20cebb8b047823b32f6927bad51dc1cd1895c7c677f2ef8f92583b576f137489666e38aa4ecb56a7606079ddd555b45609763d6651c38fca73b494899488d77a0818e651801b32bc10357421d01b45923527a851767f2b84fee810577643dcadc828ad03f16f91e1e59ae2c020375f88592bceb286eb9aa2f583db7db76dd01220f1bda009c3795dc748fca6746a831e8853e2626d15ad7e01457ec8ef675c1e861402b9c38dd280638debc0ec2193b09595d1d8015bea790385aa05a53c2fbae9ab8cf347bf2171ec1da9c87b8859169810127247811a066e978eb790fc187b49e81e82be3ae0370be9964dc0a8d171c49cea6d86175ef90ecaa808119aa2dc1b3efa7c5cd2c387a7465020cf58ff631c2b286e2000aabfe8b55accc25a585d3d6ee32a19f66972ace38647748937d09ca5a08720981a011316e01b5b789e32f370ebeff4e026815b88aa9389d7ea9265fa3d8526e935ae1c611883c4b2de9aac5dcfc07a33e1c63d9bc568aed06a95dd1d043987347120e02d10944e448307acee89ad20f46b8c6e47c8f286115de9f750f78c3d5fe3dc6096029300cecc30d91e1b35ab4d6e43b48b711185890971be24fdc4ab290a5e6f2f37f509426fe63706c8dd57b72c0366bf620d8c83244dbc2a4f7c5a83bafee9d82268c6bd64311eb4b6d396edf2e11d8dc05be3b5e38e84306c1b93967b479766755effb61ecd0ea8ab50659925ef3c2d5282d3331a929ed7a2367a3c2b25e058e68e39bb6cc334173d74da335028742d689e6a2070fd3591ec27af810c20f3e1781bcf87d29568c2398e69f82f10b71bae8ac49a3b797b9e15d5d3a9f2a4bbede4bef38215d9a0f48964da98f828bd79152be5f8ba35d8dce1025e5980c36383bdf2c9861988de07e127e87529358cf46ae6882b71aa4c4037889718084e714a9cc09602e1d12405d11756c54930dc628a6fd4e93af6f153e62d003c5e4d670b33ce084396ab01b450e31ab347ec29a59c89164c9f0a710084a962f244e2ee7d1669b15793353e44c907be04906e7048932d02c3fb840b5bdf596c901d141059ace796a216001c7f525860c79f9d3203b224a950978d2d4f6eeadbd2a6a4ea622577562f35f0b96737cdb97a3ebd0d16b30a3a92ef626eca738f92e2bebf80113f8f4385236a6d4029cf663bd6fd0a302d9d7e2143f01b37ffea3b8428976d8708d08b9d2aaad218714130682aa5583eb1b4cc2fb71405fef43a279627958766bbb665e4d2e267a45ea0883058349443acf514de7d0d29af28d5ba1803f9a75e317b989c319de6a8ffb581049814af06d00071e15f5bd2ef8d9079ff7b03aaa6ed01b38954044ec9451ce2c00993247dadb019678456f74b9eebe83e9764d3abcf49aeed6748419491fca5368f2cc8945407ee743ef1bf6611b21ca48332d991a4de5945c9c9dd671d9e06f8c23e7eebdaa3b308298afc3726732595174dea50bbba34fcd06ae4a68bdd6af4df726651ab9e6618d853aa46d82297c9d3af68cb7ea055be25bee0ef8658ac5739065cd56e916e5c574b6991fb03e4f57a8247ff1e253005dab94a718796768c54c1039b80e664d06052f48e9b9c5ac05b892647f3da822ccf39c1aa9b3dd61db8d9618b7a7b0de93993a861766a1759208b15d8e2a238deb4d3dd4efefd6099a5ff8a8efb7d8c9e21bdba8db97918ca156c2e90ff107049006ca6bc8dd260c987e7a9f6e53a0cf1fbb4660cef8abbb3187c5a3476b809706565a6eea34b9a985ef634a971b2619f9a8d29b305ecd539d4eb6d6680deb0053787c8939654be49eddb9c13293f7b76b4b9c7305883a709acac22b4710082f4bcb501941af4c894786400c277716d69446b2510de5c8aa3de5b2d7f58eba1a849aa6c9cb90e36a4f6d66b4bdc595c448d14959256a49ff2073ddab121b3c3f1d127d21569ce45bac2f076254ae29b1e6b2888dea68d2568d3f8ba572203a9375dcf0778b9cdd7edf0859f4efaa85de5b9f0a1dbd6fc06fa08a6acefe1126939c76ffd0aaee654bdc3883899858c3b6daabc1bbcdbdc9bb7a5275c4aafffd027afa8f2be93c9e34dee473c8281144e25d6068cb425f18578d8ae18bf783bc411084c07026a6f129bd3565541aa959bd754cdc462fe99618acd7e049e3063cd965092e025d5e4d1077d5ea8f493c180869b514279aa057c38874c6a939febc2addb1575667503dea7968115a10f217941c34fc909e679432996514e87d824adb96c45d871552bae431d388f4a7c08fe476f74e3caa5160d8cba5ac2eebf5b8cdb5984dee201cdcf07a4cb62ee3ac9788fcabbd7f3fcfb0cf0c77a68c0fb417670499b18b77988dbc136d788b6a0572b67edad36fe9cbd28651acedca6c4ae66481ebd87467480fe35a76a811a209442d155dcea6f039ad23ab6fa0cc7888107d1c90fa168c39ce269a71fbaa862c365f7d1b3818bbf9b37f98767565904c4898b67a6f00e573c6a51e12baefe3d4387fd6e3b26464473057357be5b57bcede578ee5b1e1bf482ad28d9e8ca57a75ffc0ed9ffd50a0694e6f66c4873f7c387ba863fbf79db18a49d74f7edf357744f462e1dbbd51548575c0d44ddf6904b15410e98db1f7678e3504461de91433246e758b3c9737a0d9389c29b4d8c07d0108baf84e23adad8caf63a110d24c82603fc9effc4df256475b59de929fec4488863860d50c6a5ec3019fad2ebcf46ce06056f6b8c383853d554e7f0cba82c11d6e62bcc9dc4f02db33c83ee7cd72b35e6112d44adf9d6401eb43b8fa7baa95aaa873c3353e2f4cb10ce410dcd2eae5a566b528b18c715a6a5c708fb94b8a17cf704a4e8ee92f139833618dee1eff8bb7f838bf0823943df8e8eac52f9dcd03c827caa19a2f80bd703a4ac81a98ec397cb788192bce99efc94901a60a6df2da426d83b24dcbf7630fc7106d70c0ba7e53287f4ffb405d93acb08ce2cba2a13a2d86869a5c47e509fcff317772d19183ca6f8c647c56b04ec3d0c420493098c92a12a8c7a8cde4337d65b3ed6760ed645dc1a72da5861fcd88127ddaf7179da760f4cf5c30a5fba9b5ab683373b6cb3e9184084b958a7d191a9d2e4cc5067fb4a073959805508288040e6e9870f663503eecd68975f18d29e1a5dfe45ed70581700fd0b60f0ea351bd5acb4e163a153ea4b74fa087c08ac506d7d71d54461cec261d0435ed14e3f5e512f4c46648eceef7f7fd92b47ac9454ef2ab6991723b1d388d6a81bc13a7ab16f7b37d8ddadf35a1866b63c8125cdb76647f2ce9eb7cd1c020be69f723e4fe2048d5d3215936ceb8fb8ef02c3cec416585dcbc63f50d747f5f84838e6d1383d0ea2d59842aed72f4fed12a24b86e86918be338f3616d3ac9f13d1bdead695ec3f801e34d27e9a128151a7a6921cb5badea1f545d04fa76e8c7265d0a4b9d22834d4eea900345c2504254341fe2e50ac268f43f54a05994c070afb4177989ceebbee53bd1389996d356801c4113dc848851437d97896d26e51b0776f89216292bbc37edac3d07ae0e042fc469b50993403886c7728e71ea84a479ee41e353d18d174b320c34752be36969e5746bcb4083e39bff3e2918f207d8bec8a62cd7689606032536d382a14d64ed7d440e68c839d492990983138a4ab56f7fa87fbe4b860c1bab0d6c8618b0c089afcbf9d8a80f5d61b7b1131bc7ecf5e97c6bf1a729f36ded07da727f069de0ab3fc2ec16e5aae4a3a19a359869ca901ebe6e099af12f50f7ff4ecb52e7c30f6b8b59edeca6743d8b480ace19fd9291aadff48fe2153a8f47f153f1a64308a0a7502c4f37c0c357114fa1bc06e789605232b5b34a0585de5de2c43979869f7038725de50d53d9c72871f89c4343b8b924963cbee70fff7d8a7f495f395f129ac181c282382c765247405f532bf5e0caa99d4271567af621af400fdd94e10def60a16c09083ce0b7e9df29312a8b03d41c68e9fdf2a447704745396773978c0c91b65ca74473d7e59ab89afcf1f76ecbd1e37c031f61ad26f841cc962c97d3811ec8350e07bdc2f1b8a2b907abaf2b8080136eacdccf920819388512e940eccace33fcf7da852261c65acabd93f7a80bfe70a6a92d3144b5112af2129ad4e92aa630894bb93e6f37253e13846d521cf75cfa143ea040d29d4961f999f3fa590f08dbbf80498b32c633f2ad0a812b47d08b121b0fd558e4ea7c181e183a9add2cbc5e4d6eb7eb520df5b3ccada4a41a012f6c55100ed460aeed101076a2f7ad8b44f51e73960f639d1513522c5311f97acc44f9e1c1314f9e7af2b54e031731a8686d7588e6e83bbd74c009d39bc7341a80ac58e2b5c5c680cfdf5f56b77c4e17fd6ef7c957e4a592322908ad63e824e6d6cf422c9e3424d3c2b5cfbec6df827032048e12a348a0ff927b576d1e311353e4e868cffc7ac23f9cef8e8433e85b2a9dc11a754225bc023a04d96b862e3c280b814a27d827cc24a298f5e26be16b24e788f813306bd7aecbae42af4df9073e76dd4fc970da6deeaa11ca446a1b6bf148e1aad614a3e3403cb53489d72949ad192bd1aecaa756ec225791a1823c91a659129c523bc077d9a23273309f7cd4b200a842e3a31532f67ed496d9972a0ffffdc4226cc5a7a128539792a2a7143a1bac6efa14c89f300aa4cdf062d689ba125860b7569e02c2dff82f48f592a18df12ff74c1d7c6833a0c205369ee6d9ebae9fc2116f992d8f99db931f213bfe2ac4afd3ee89ce7301258b9a3518f34c56beb288392edf68bfb18401a7239bc18bc8f15a14aca2e76718326075471ab52bbad7943c3294047785f3bc083413963325245a35f5f6336300d5296015e3d2f7e64b14b388055012f5358a6894f90eecba2775e513c11bdfb03f248b95772b12d47cdfecb9fc6a01021540bfd550220cc1c304977902bf7fc8fcb38601cbc495ee0bc283d7eac09285b7b6b5484151dfa272a2f97d32317abc114bbe1afef1f3127664d6ed0a6005d8c53513632e60f00759c32bf178c2957177fef9472ba1abf7968e160e883dae486a7f1c3d357a35feb88a69d7cb462fe42ce76f97dcd46967d8ad52a8cc33b38c5077c94ac43fce1afcd38d2d45d6a62b467cef9248afeb898fa2e9be833b6df2b00512af179977205273c6abd64bf6a8c7f7e42fefe6e914fb7de6dfe695fb685f609f5ca274236850fac100e044b9fdc242264ef87e50dfeea62a447be59496ee8427d49dc7e644f6520f8eb1790afc0e6d27332c12c076bfa48aad3c3d5c54cce6f2ad8c74cadf786d6a488be0c83ba3e690daba173037ddb46236fb6203a7dacb219c90a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
