<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"443b05925940c0fc7719e1e4c347c04aed45f7683ca1c374f449c33c2b0fbcbce536d13d569b9ae8cc7f640b0515ba7888fe5fe5e66ceea5fd1e5629d1191b59226dfd8989d727c07b76e8f6c6d22ac3c74b47ffbd30008bda184f239d46ad1b6d2785abfcb2c75a5416a44f51f90e89c1935c78db90eb8118375ac17a7cbb0dd8bddac59d4416a9bb097793c7fb04238fdc6c36190b46cda61ac986af0b24c90434e47a8220edf1569fe317dc630d9da738edaa2b2405bc9ee94b437928b826ef0b1674ca3135a3ed1152ad8b7b352d8bc21bb900caa0843d3d26352fd98351043ee907a6118176de0958ed5bfc4292ff2f1ca93fc3f46c8a1ff825dc1d9f1cde16dad8334b05427b8d64bb9a0c75c9a2bd54632a6470c64a55aa5359218479f7b0dc9deb75d706b675ec25f06e3e5dfbfb84a8af3ff4a6cecc0ddc3023d8d6eb2243edfd3f82c33bc1b25d17169cdbef7beb88f0060d8d1daf5c44cd466e40d443501043c09ba69bdab4fb73a0a8417eaa5b8e76e22a92b035115287f8da4f6957cbb1ee41b100feb44e3f7b54c09e7c1dce406a3812a7822544349a0e707ce35a69e4a1356c16fa9a5b0ee39a1969a845daa5ee69538dfa5a9d084df752186fc5d48205f5b4581a26b385eafd34240fe06842577e4d96f6997c9beb7196b728f3e6a3024746e82f08888b72c9bc6c3abebd78517654be79301ab510eb95ab0cfb6252755de0f5d5b6b7a13afc3f54f563060e978cdf8dd8d4048eaeeb5a136c07cb4f5aaee0a50f520b92896617ef272cbd8f40b1cee1064877de2cccee18b63b13343b1d95363e1258bcb7c576c9a0538dcc4bed097740edeacc61500c9c252212509a6d1bb2224ae3bfd3db6d9cc60365f5a31adef265885525fc14ef1d6875a4d05f2d5db43ca59165bf86815f46179f9556253fa4c0578f4eaecf663696619e903ec90be166ed05aab9c3d321dbf9659119cbec5af7033896ad116a7d163c9a9ff0c93629911bd5b49d3ffcb982d24a2a7b33ee5f17ff9cdc811604636309f23e0f4b6f2a6e1b50f92fb7960684c3787789fff9d66c28fecc101271c83a0c2da6f9e0ffb70c9d9c38c0250be9c61308057fc98eca900c349749238a5ae29ae73c71948c23248273ebd16eb84046d0f976aac747457ae21a133ca64770ba543690324e88fc8ea7547b796da53b71d66b46f5b3b1942c3f025df52ec77ccc209c521cb508a5500f23045c8262fbce387396dfe2fa64e5f4d9fa10c7799aae1f0e9e8fda9e60a5c66a9de96b62d89f3010af0638b1492131506e42eb5c6b5a0fcf51fc0a3e01862d4deb74dc299567f0ec0ec88f91fe73d87cf77d8ce0a0cdaab824a637fb1cc37cb6dee682e67acf0150b56634e280111f6634fca5e56d913abcbba91e6a85e865c43216027a8cd7490286b08f12593d6f9aa83c8258bf5adff85d27d5cc657ed3aa78749e7f41fab189e915a3de5635ef8733c0402d56727110cf5b2f85bb7273cc2b52740eca8b442314b61a6d3ecaeb21563a8213e8dde69beba4436a3eb1324f748a6fbcb94c82bcf6a35a1553f256dbf3a2fd64ef24a955355b6e35acf3fbd41ab93f6f8bcb2eac4bcee0a686fc9e08f2c492d3bf0663834fafb68a1b591b5d44a5dd9b5a597c0f2d6197db63bc89aa5757001d86671b0038acc21850d9236421927d082cd4d7100101d84f2cab368c448866484fbf1aedfe502824412da683794b94428700bc5f77d1ee40bfdf11062bcc9bc45cfa27867040affee88e8c0fe2637e307c5291bfcae6eb42c8beed83b030587134ad9e08d4e3e2ca253bf838928e335c037574f0f292d2bc7f69a251e65a084f257cbcb38729c1ec6e4c99aafcea8282e7c21befa3f6b0af0a73ee35f6c6629e525188346e2237533de1f8471e98c83e7a4931ca03e661c4afbd4ab2a3c72390f757c5af7c3fa879221ceae8855e7ec6be97ed31edea34ed1222ffe442e59b90f3ba68db0cf05fb180a3fe9d3938ddee26f934d7f6d881e6b399b1931bd3302f9c470280176d9cb818ab6760f978af2879d77360edf68a7b4ea16575021e8d5848e33ea234988bab9b8b1f48525a6db88163b22d124cc75f37dcb24c052cb6891a8fd96ebe3d1fbbd8b31e062e0950eda6c34ffdc24d8be423d124c49efc8648d48a63d39bb82e772efe3866555ff950b3e4c9993b977cbb8f8965eee2a1a4ee40ca738c2a0eced213d19a3c843a9274a491d0b46cd088abd8fa54827ac89bac82879799e7b7afa052054306cacdeac946af6a088a7fcf4bc0630c5cd00bcf0056c76a100aa65aa96c0a8a726064837e5717675ec7350e01b6c2f3b6ff1726cf479253412baf47a5526683c722aa0337890f144fa71cf12ea3d103ed7ba3d117a045e3f15f593a3bc865d1320b4114c53e5b440366998b939ba0d664c8b0e9e595eefe1c6820b2551c55c6c038c3a9f68a9a9a022db825a1607691cf7bdd3bf0bfbe56d2436d02172cdb73c7b21b91f7d8168c853962b8f627d9b4e25aa8a93e69c35387896eefa386502e1cba1360dbda8f178bcd1c7f07c611d238f19b60b3d2c39753cf0426f916e4793f9f670995b95ddae9bae04d256054d47a111a6da659024114741fb7c3abf504a72538ecfffcbf5eddff6c121395aa4c65523bce88652db45fafdd18e0bb59c2e29ae91b8ec5e05e38020d916af328d9948dc1498dd79e31a0aa3995be3f96250aadaad550c1c36849c892de7421340c05b78fdf43c3aff9c2c09179ef1f442c1bb5a16fe65e7bf64faa237b9f4d25aca18b5ccddc815386742cd9c1fd6c76fb950716fcfd7a088705e4d77e5b3f0801c67686f76e3f62a23abe81c2ed8a6729f1ce7bd641108b0e4dd6cde4d254d5755100000be6e6fd5912b7b415e36f0e4700d6b13ec3b99594fb471b64371ef9b13b70a28d9c035907389a6f106c2ea63bbd15e6c45eb78d8377378388263aeef10d33a7f249a8049cc50236b710d41ec4da7fe4b73d83335a2f29b798be57c6ed3783c13aabe8f7fd9a6bc9c8c1b07269ef961e3379760a9f8e506b88a57dddcae70f4ec9fbc43538574a638c7eea5dbc450f2725c02d4633de485f5aba22164af52f6b9b5d767e254f3c16431f60caccd76fbd508297d72f6e4aa5f64dbd4995d75b4d910a0eeb1823f84eeedd911b14575a4b633ee1c5f943aff357d9375891638729450d7ad7f5cdc21978d5fad81550236adcba78600337b42ef66e4ca14c9b82aef01adb656689fa2b0e99c9637b0a9d79aa052912f48d1fa181a4be78ace7940e27ea868a1f1d41a3528e022501b564dd002cda3f7dd089fc127aaee62caed6f87d42d351a8844691c63aa4a3ecf5200890ad22c871b914ddaab1ede16c0ee43076bc5a54062bfb16be2b0b881e6ebb141b7ff575c30b19078e09d7e371c25971a8e939c317d78a7d858cd3a2f7ff7136cfc15ec339b4dedd7e332f2d3f66273db2e592d898060f655d8093f8b0f3adba08835021aa0ae3fef670ba048a570ebf4f920d79894f6a53d5f04e0953da10c943228edd736354d30bd2d74e1cfaac9b4df4a817103646f0a5606aaf848fa7a719a6057bb9880928a13e25624918d41bb599e7f9bd64d2bae223216954208c83b677055ba88874c4b79c0b4c933b3043ba7af1a0eeb919c600698ee19aacdfaf284249a7274e7740de158bfd67c9be9839000aef5dfb9980eedb6ea7004b466f4a1c47d38935bacdd9a67b78702267b63eebcf668fda057b40b871db4e9dd5b3c3215a88fc49690d1eec1d11a1b24a0d9f6b8d6a931e580c28bce855afce2aed4758a6721ba3c7db57bd5e96ad57fdcee45469c426fa758c6fb3b427b11d57bced3f463a5527b31397e632e74a3017a442bf9f607c3d827d894974d8b806fb1065454a46d70df730bf6889124c379844b351b931a894433454261d51f8bf6ec472522224797afe220c7f767eacaad3cb3e3220f0937495ac6c8d9d305e3fe2f91b1c2bf8cfaeeb2d0a7b2d5e3a5f50291b88b3b6f34a6c88df3cdf23628293c45c6b7de8559b59884d3155fdd8250e688b426de4d3a5f6eb0494c65cd566480c084272fdaa82778cc449251103059f3c3163e2bf9e4af726ddc371960b430e721732eb5cf1f5ea4c063fa11fd3de5a9e03bd292b6ac35d4a732c34245b8c85a9eb304e3a213327c11e8296455149a81e72ec8a878a5addfbe092ea204802749a10af27a87a741b64f2a899728dbd71c8979b67c004e1bdf6dfe0d485b9b5138613072a0e58bd9b4c62df1da17109b7a065c9d5876e8cd011847cfad4da4cc616b5e17770c38475ebdbcd73523f9968691876c918d8a95bf462e41082eecce892d78e0fe0810ac28d5bd9230f99e587ef0e3012221184833ef323f7d4decc74adaf6cf576a3b99e6452cd5e7ec51cadca41bb9b6f3ca86a8b8b7f6539cb970150ce681e92c10b9815184ea2a94e0cd68ec270f087c6447786d0d7e1c1b2bbaf03e758fe4a5cb2f5bf07a5557af1f13d3d2517a7f1394878f635641d9eb3684c0ac16d9e729604dea677c8b277f0333a6ebfe07f7ed0a191c28a832d412edf30087eca3994a9e93488da762d4abaececc318fb911c98a78fada4d114f1e8366a4f9f7b0144262ec3f88290668b141e894029c180cee37bd26448ce4394f4e5f8e2360d861a259ad746ae679bfcbb33deb6e585ce3e6740082a03eca51305daa2efc0e1d14efacfc54af7cf22b876c985b766d54f5877141a972badc333309d427cdd637b214a764dcc3940d686cdcbaaf0795cac9c35f3e37531fe8358f048b87061fe8bbdec619024fd0d9e9fe490e7e79f5d73b5d99e3889f450cdfe21a265987a9ffee0549eaf3128dcb8b49b735d851780720a66b1bc3bb2ef94341fbc92c7c94a536c9f3e4858037f51ad4ae46104c4283f03115efc9ae1eadce1b30da74db2f33bf9863ab6ccc1422f0cb0517ec772bfaa27dac8d40fbbdb64b0ecc44c1d066f4e2a17c62f565bfcc4f646f362f46db0639c36270044ec1ff5f877920ec2db23ec8d463130a8e62740aa73f7f3fabf9cfbb6ad8184bc71e305f2de9ad71fde7ca2aea62a4813395e6ee1de408dc131f1eb2b5dd79c8477c285303d129c8763da9ff7d5b6f9dce1080b07ea9e7be74557bb57614e96caf941d40431e8bd3b40b694bcf16033f6f98871a13816e24ddeedb4dfc9de064355abd9324367dc5b11c1ec01457e04afaee6e5252cfb2dc37adb68ebc5fdb790c89d0773cef7443996f63c048c6a92f8e545ad4c3d2e200eea9a06cbe51fa1cd0a7969ada3df27a8e245c895abbaf8425131a49d1335c5ed3285a0344b0b006ac1de483102e50e7a577dcbba697b658cf417b706f9faabd35e82d8c20d592021315fd209ae7afab65ca6a12f8d86256ecd59cde62ecbcf7fd5c6799e9aa841f9c207641978021997f8efb7d72a0e4ba36d085741d5065e56b2cadcb44cf384e881f1a83d1144a6f588725e894a54c094f03294d95721a1cccd966cc12fce4a83396c518f96c0d2876e9139d9f51b7f13921593932e2c45317230600a5f05921d4003f65d5e2ec9dfca8c0619b7bf30f3db93f7e8b828e46569f96a844e0aaa498d0ec1212c73f6e21753e19c4efba72cd51b06821b01170926d505c2a9d70c02ac42ee478005191e1d65be500eb7f0da7bdbe8cf68e4d2773cc0bd86ed0625301ef4ea19c8dc994e21250560132e421e367f93989e5a79f9297d66092e4507a563cc7e6e937d015b21655dbc48f23f875500badb414e5941dc47d7cb1061e101281e4b190c3f9859de03a68fb08c16b91b76f8ed357365fad0315bbfdeb1b9dfc1f5db4a43f8d26e0aefbc7196a432667c668aa7e95d09dddb4bf345c827d76d253e7665c14b41bb4633bc43bb8ba682dfa1ed6e64bab83e5e7b2cdca912b227b37cbd69a206b0e5edd36779bdaedc64a5b6e0f51fbfcddbdc803c2c9dc3490a3578a7e75bf7776efd9f097d8218b54f0216d82317239650a61229c48eb7aa6c9ba16c7c9dad73181305303f0531b8373cc8afcec99cca7a9b88fe309ac5320501133db17948986bd226002ca41a9b90729adc27e46628708024a7d30177b91478f47483e090c594790ddeb941c5cbd1c74e210f98963a719ca7a821cb3a14dad9ad3f3921fa939f1f4cd50a2e92e51154d3ff018e3b4358296f156faf754182ab71c586b3ebcd24c8ece4860b76b28cbae96091e4168663cb958d8ca812efe5c81317b7d3e59e579b1e2e14593aa31a78f7cf88ad06026e53616be2b25e043e7bfbc376d13d13bc29a67ae74e9e8d3202fbac3dc2f80fe78900d1fa36d61e7e16a7b1d87f979e63a0a0c69262632e91ea9387e14bba155f478b3e3dcbf8496e68c9e5d50be5a092d55d0fb5113ab59115e3aea336a7d675dd27bff889cd98c239a6e8b5e5f24707fd46b2cb2998af4f270bcc0ac1ab61ea1f9a0fb2f83da694150f939918956e89827bd5127380a5048a9bf80eb8941d0c841646da34d0a88234b18548dfdde35995a2b21e0336c82ee111f80c4bb0f5542aa4aedceb73e6c3c3514e49de05f02745b7d66aa4c7474fc92894cd80a4693f56cf2a2f65061fe20575ce6e30af381ba8248c7e1643b7b80d52c74d2075623f8bc7604819e73ff613eed53de17e22b64682a06aeb475994856b02f122a6bd529590fe2ebeb9d706877b614bb594f60c0046dcb8868a7ce76c17abf168647c266951168ee964e43626a2c1a58779e3c3efab180553fa82960afd3797c0c471628089c3e449bdeef25892fa70fab0190547791bb4d4babddd351049215e96a6d347046a62e6f361915dfa997ee45f137c4743610b87b50bcec8d7244f260f8ea6692a5d3fe987e9c764a3b4f4b5125bea74722359fe60aa9cd99a6ef989396a8667cbece728e7ee67aed7e965de15f15e70c14c97f25f697bed304ff000c7146428690ee060a45461c28b8dfc8ad391e533bc5fb98413079b8996f1d55eb046f3389e277191931ed0badb71724fc81aeec297f84c17b1c7ccef0033976caee38a360b86aff128305bad8ce273bf28fbfd59cac2b48099615ee0ae822a99daac86cbae78ae77955ea84cd70010f196b00168e844c6f988b1636c3ec14ec1292d4d0684e1e81b16b48bbdb7e4c3a0fde1aa5d3578700c4c03e2b844efd74d5cdbb31dd666f649c653f55bfb5b733aee9d4fd15d5d810b9d41469a38188d58ecbcbd6612b59107b08bb8883eb4ab42859d36e8a61db1183384fa826bbada08cc97202247326b59b4207240026539ce7c0d80b54b7f71e2f6ed3bb132b671d4867b79e5412fc3d914d4cfb4bd5a4452f00c7976ffa0e556cf11e51ef5b98d89ee3e1a12d143271232fe17e72c126471d9afdfbcf13b88c55f25c34867dcb1a581fca1d7e4991a82d53f1dd9bcfaef7b0eaef9ec4aa3603e1951fb34f8ecaf23d743b310f9e52f7c95ca3333c2cf6a6ca911267641135fbc1da42de79f85cc5c9eac9593834664e7d8306852e732dc41792d42267e7931c84ab830ca5b9863cf05633045910601fe4e2f483d831d63fb379161d0b1208006ced968e96b970cd9c7356baa90d25edb66857212529e88deb81e9ce2d3ce8591ed6c543fbaadc8b80ffe0ad91c49bfc0df57f83019554738bdd56f74c091a5492a52339673c2f221c8f7515b27b32d81a27f759dfae405146d7883b1a4f2799851589a5475af75a1e977cf6106e1058317b7849656f41034e8ad1fa8401b44db9b912a56697730d6a64e9d5a41426a892ce1c63d67be8a6464227f348fb5f1af9c423e39304daf948195b7af85e7ac5d115742da1b583a7930f1788a9fab922e6f71e88eae7035643c54947a2a0a8253da28242e9713eb6953b969f4e978b0b6fb4d1519a95d3a58af9fe659f9af1964fcc1c2911ef073e07215e3c076f1fd91651ea623f34c2d6079ba1e351d5be8d673a927d3bd463757ebc8ca825246ca3442e74b166df66c3b182dd11c22d7b3664e3e98c1b7300b72eb85e8e5a2f3387a339b73b564cc01d0de6ba61881f73b09dfe3650dfef98f1cd20fbca5c781e943549ee6616b18a15e81eefe3fe6cd2786fbbc47fcce28a91a9ee4e8e378f94795b7b26e0aa4e8e1b872d1e2ea107aa5f3cc2082b61ebe95df8dc612735c7ff085e1bbf94279d6e5b3763221f15eaaadcc2bda3494dc0d77c6b4bdbfa050195ec97de9e362ee6b550fd30e827c3d33ff570d59486fa4b4343d55e08d0651ad5bce016a85db5b928b33c73e857cea72a53e31f979b020f532a0d3235e7d9ac37fe48bf4f82d14819cf64ee4dac05025f22c4099858bd2fbffb86ac00863f19e72df27a5e719990d30be9925bb1d58331a1baccbd72b51544bd7b0a3548401bd7fe74a793e26e8f57ce5a7c73f8d098706a9b659c987f93f8b8c275a7b1256602dc02055a9099d1927240210877295f87b638268570d2159e803eb010d72e016b93ed48248b4f20e293c172941ba7be34681f0a7648f0717e26ab1dd8cbc18909e3725a5ca64f1c2fbccd8bc1ff9334ca1cf670691372c17665f11f839ae69f49b3c622fe249ce33448ab9163a42ede361afd75c920a676c6a925391ee1867bcff271a8b2d3b3424f3fa1b371936ec44bc08eb563295fe5f0eb88f57c87c21473d3e2a8097da185fabb23625ce525f792c3863bb874f1a1242969dad5e944437e6c761f305f3b3653b967407eb0084616911059aa768cefd4e6fed6e065cf2b5ccd3baf661c1a0e299cd821b24f0255a64b945a85a370eb1dce27e929e750b0366b027d9aa08aae6e7fba8f78eb79c38683eea941037ba828f1879932259b33e9d52796fc8c8f590a4591f403e6176ae59c2fa9362a7c4993232c34d956bf6140881c6ee917766b696712bdcb8ebeb11c16fd577438c4436938e317e542c37af9635932640c32e98ea138f3d9987a1a0695f80fa1584d59f9ec01e7390a74b6e0942152ab7eae9f3f15428db4aed00a751aefb3c486c68e613d349a13c58c1c822fb2b326718dc0ac7d485d5723534483f228a2cf5274dc4974434fc0ccb54cf38ba483942502f2db938ebd70f3d177eb20533ef7e6c9edcb80d7f37581396dfede01059b875910920842a1a9a4d7e5e26776c96fb7a0eec251ebd30de47bc2bb33652e113efd575553b4425a6ea8b8458c7e4a5a929dae00068dde5f0e3b4c9748d7b20dc26b20acb89850f678fc3e4b8394bd2fe3711baf673409073ed8e20c7c81431a548783a70b74f58bd34642409b2918a8021cba6af54eb834cf99dda9feb47273d2c9c37526c99c77198824a1859b1f9b5c80ea5e9f9db27105e8b63aecfd8d63a951cb76817c0f722dbae2af0762eeff6b13b3213a3b316497b2c65db2747ca4c19449d6222bf67026c2a3e837a5fc0e67a3ac3f842d953d3858d37b164a3a6fffc018760e0a6ec286bfa2d3d3474feb90dc40a23ccae8b63fa9d4ceb4d569772b0073ffcfb4afb9315aa11cc5defb9a5395b19afcc69f488449e132ffe7c80ccfa67f0b24ebbe549a76a8a2efa992f7d54f3ae2b8f2fafb971173fc85306dae4cad02ead70b2cf6f147cdb2e39a762a382235f854c50452765f559c6e81064fa306458855c662e89d67a1a8cab90dd2d306c0874f10f7bcf56b6ba28ddbf342006565a34fe2668ce105a6969beb8d8fdef9f151bc4bf58c38106e2a690371a25057d356026fd1e0f199793feeb35d3b74bd8710586f34bc9ad2aa18b1f211db7d882e3ce93e7857b36a4e9e807b1b1ac241f19547f8ca8e8bda54660a0f2aafe4c037307aab28ee5e077a8e43fe7b5fd07164e0f34c8fef728365f283fd48a1524bd519aac511e5b523e4ee29d6b08ffc1c115d374294cad2fb52d69fcf71699299ec278b47842073d171d10d2f7dc2bf82ae7f8a8522216ac4dbce67da5519b6453be2e8c4f031749cd3d1c8ccd73e3f5400bc605cc6795473eee16daf1eefef23104afdebba79a34ddf768cd4c190b05bcba8f2394853d0de7436640a0fcd02a70a09b456faf90959605c2c3a3ba773d9bd6163947c26762082502f88878258730568c738a5a5f1518caf60bf9bdef94aa27e36ac6facb83c75aec6666946248d718594217d5d4a43f905b24671a85e15b32da0c727e0bb124a192395111826f44b578a0075b37b1ae7f6cf7ac4269fc01c0138a81d4cbafecfa691a4590611f796ff298b704994b269f005c79c8e94f955ef0859446325993a1ccfa7cb62d7565ebc718671c591aa01f398f002892efc0d160b74da64a49af13139d55fec553c52e2305800c2cc351c85adc07fbad8a6b8192713ca049a821874ad1c7526cdd3f816f62b01ac9f58d36da6c2849bb1b92aa85e52eaa043881bd5ebdec701ad79ae31eaf12cc5850baed346466906b3ec9df15166d00b8e0225350be9f929c8f1bc053dadd16057db82549952ad559d3208c39fa0c5c2ba8c30d4b348cac7ce089afb43f41d0bda563730d64d885babcf3e9e45bbaad24ce3297e5eea24367dcbcdfa503e9ae7858f095c091aaad4f36b75051b14035bd9ac2d05b3aee236d40aa4453f4e647bfe26f2af705a89ba9c96a3ac95af99198233353239414c0ff861541c644c30b04fb10de95b7701fe1b0c07d03ac1e7672c79cbefcc439d10ef1dc6fdc7d511c953c760bd98fd1cae224248096c8b70628d95a32b7b25acde2119d34fbdb7000c7b0106d89ebef888973d64d2208b8900f7cfe2c0defa7acd10f1535fb35b45ccafe02bb8313ab9101f01714baf5a39580801fad1057d58c4405634cf1c2044bf54804f6b57acc47bd98db8dd5640404c856c25e8a09a6ea0c21161c358fb3f40caca99315e57be8461f6446255ca99780024ce3c9dbec6ac6e8ab98b27e0913b7eb3af584b9d6617352e6953c5ae6c4bc7a9c0ed3a841139c1c78b5da98a1b9e14b277be5680db40c9c007bf9da5dce0b371f1e416b5ea5d737ddd2815fac250c8cbecbfd2805c29c6155b88b74fc98e6688ba24b6bda81da1084ebb7fbd509c3c191505d3bd0d9c50e29e8209ee8998d3ccee84eb922edd71a7202c796ce8f763ad18aa1f58fd071355e9fef36cdae504e8e807030abefc4a14d5db6486762b53b22359f6ae87157888557a4276a8c190213162d0c1b0af7a55631902e6b4a24e8fb35bca235249c40f92595335eb515da521dcd957ced4f11682ad2e380679219b661e98cd9077da24bce2f98b672e55b0da44571187708b180f4e66d45949656f63374f6bd1f892ffe9b243009871bb47573dace0f31119011220790d945d869c0655bf7fcfd37200eafa6abf64ba11a4270f009905b3e015f447db747c92a312f18311c7cf10e839766bfc44f1373adc609a41ff8131efc97249b706248612a8b15f5af5a07723a0db1716ff4a640939c6ec53e51c31afc421ce4d258426ca64e75ed0e823ef596ed17a17cae0eac43454af6965c01564ccbc514705de127004145fccfeee77de5c234d99c7dad25138085c44fde703480b3e590d8074041873fe1263f44be5005cced2be6fa2b223e9534e612c259d4f85785a87ec2494f1c1281e05e34f929f7e8780e457e8863cefa0dddf22abbed89ca93ef51ff26106c2f0b0d551fd5164ca41ed55139f6f192146c1208e9e1ae5f5945f9997cfcfb24aae60fd7c7e7a761eb0c5f85edb84076abb2cf54257d1bd7e173b27b02e8adb21a35b74f878abdce32e5fe3f839af58cc7b968a831dbf1abef70b30417f740f9f718bf8d2e0768a3327e37721bdbe04938fa4185f15ddd61e829ef2293a1d60abba072d140afb4b6fc22effd16513f048778ca01ef3749c6a6aaa0d257cce6f3a3e2dc1e081dc21232c9186b1519ee19a373a01a52aa7ce1620c8343bf7bf294611c32c0e7269d4349c563f969739bda1fb4243e8c356719e68905479cf9674ccdc6786ad49c38fdb2a91a7d609eac1f4b6020620e26716c2906336f5fe5fda1018abec5183834f073cfe1f1cc919f2eabdc1edd538669cdfff2b44b844123e6e51cd52ecd6a4126cc70e33164978f6750f74e2c0e842e77ced5f96cc41267c350debc5cb5384bf34bc8dd18fb4949541fdd0e9235681bb28100013408fb4219ced693defe3217b01c428213ac8d55fb796981f02565283c55623427dccbe1821b701df7e06765a8a764602a6743d7bf8469bbe918e1e7af064dd1ce950252c613eda29bb09a80ab972a4e0bc6a2b6a8ab4ff8da73e85f9264a1756348003eaef15bf23577bf68d64183bf5e4f840e82cdfaca0d13d0943451447f7eda1bc6aa68198fb2f9270453a901fcdb26e29896510b63c2fc6924ea20bc648cc9d40b09a380aba58442b2a978e5f8bea40fe966232cb2242ea3adf4fe25b5e90b3a297202aa6609837f0b3bd36f49123fc420498ac8575e8abc86cebfc41eafce400974f924379b68d1aec1a45e4afbab0b3c42fb3e08d11e5cabc0e0fa9b223390b7aab1b0bd2ae72b16579ada4ff8e713923e2957ad01ac316c5f7933748a7168a49329cbb843540b0c7c29d2afe4c3779b002c52e3cfab62fa4a366dd14be08aa09c7724f793142bdbe379ed812168529b5895b6dabe1f68047840e234496a7bd9a0eb34c46a472c47154abb8ce181d5dd815488f8a869288263d0d9c8630104b1adf7b88dbf1a7f6963a83b5536d6306dc66e1c3b619affa19db471a1b4ccc3e93eaa6c4b22975d651c7c424b4d73d34829bee02a6706c6b0a51537fc919109d4fd077e3b2af536cfaa98eac16ee4cfd8ff33a6b45805bf385902757a084717e3f8bb3735cf2bf7e832456bee47399514f8fa5abd19f539e9a02a2634011bab5e86f6162be17ff91c7bcd08bf6ce848ef34f4efa8b7105a750a4484a76fb9801b3abe00485867dbde7b33bf08d72b74c4ffdf67adba7f802bf92764c281cc4ecc9b958c7b554cf002895beedc5cb21a31ea8e9623fc7cbd54441e8cde16d023f1818f336844a5e8f46e9febf76c30b994b85dab423fedd4e2aed3d912087d707aa31dc354977f38a7f5cf035c9b20809d43a3a57619e5477489836c81e03b198eaf12c9922a67a1f35aeca8520f3ff46c4ff6168ab8147b6f72f2bea58acf4809c4f1faab98010bd6ee4a02b376197651296f9a94d171dce2736647ed9588d7438138a4657f186c1654b718d755341d9d04628d79f2af50fc48b7e3715aad4a54171bd1b53fe5485d5720dcfdb22912f5ea3fb6e367f8bcc0da2aca2e8128dba70a7fc091157030aa134ea4543e01996c22800d625d153fe23f5e3094f90f9391bb615bd6668e73341d46737436b3a1af00bc84b15f7b1b1edae3a0ea8f48a5c8090170a7083157573fe8295904ccc6c0664784de0973b08acee092edea0f14dbb7a69563ccb0a7c7472510f4aee27ef001256cbd22a41f3541242c05cc3e48b5164451faf57c82311b6261aeda3af4884de63387d8ff7bb1048a271037574131f75b7db211201dd62cc65fd517488aa40904afada1098dbb678d48c017e9b072d035e0347da661bf66c78361279e2d151e0c49e87c69131531dece4cd4dd1f795acc8415155914f39fade62e386851294975946981b688d8052851ace59b0c2826f89050c7808c3332ed2181f1fb24ee24be1b71bab1268a13c59bc68780387efb5ec70cae63a2c31da14a4dd35dadd4302504a654fcf9d1670a7b931d1c6200dbabcd33b03028fabf95d2a3784677ea19c70f1564bb2bfca03ce944b01b11af58fd8a5bc5beb7778c6f320e338a4d636014510d9fdb0d027c0c8cc56b52c4c288357a6e271d81b811613ebf6157185e7bc7a543df2a71287c0a509200f35b1e11b773c68dbd22a38e1bc7eadfefe55d9a3e07523041b71adcf33d50e0fd8d0d4f65b5ca4d469b88e8c46bf4191948baf58235fad1ee98676a93ca367cf38946c8d1abfe440acf13d0d527405ffb1d249307a90863881691ee15ed7c2c0e6908b125432ae76c4d8914b0800d724a735f5bf7043036fc5a1dbdc2dfff02dcfd8855523afc57cb50e6062e98d136ed107a0704256e7dfe42b04294a6305422a57a1bcecdc5c74df4a10af699b5499fd7bcca26b72cbc8116e556ef4d82e9f44c09d483ed49991b2238a795e8e74699fbc272b7a877c25eccb066347fa82a09b5e946f2a750b40582eb04833a9c4bab41e8613c5dab56663289cadd3fdbaf5bcfc262f22b2bc818196f30e20ca0b4a1f30e6f3018f1174142ed314b678074cf918cae13df852907161a4d135712df062134f6393fa0da8bb05be63afbb4675e2166eb3779077858c47b9d9598d41796465f6eb09463bee93ea30da5fa51df3bba06e8c8c08361349f19e7f172e926c339f34a4f2810e39b057e9c9fb77c2357768ee04ab56a514ac4aae7f9a8e75f6e6b418e94079fa3a3566e1675f6cfd7bf6db2e22355e0dee1b1179ca9f7f6ad2f59885737db8e0f40b186c683379327cc89362f5410d1393062895f4dcbe85de1818d0d5b725ab9bbe7d3c26f714877ff9ced3475951bc0840cebe08f99167f9b9aef044d835ba51483cee2029dfad9d3a8f18b9498711209260292b46082031c4387fd690dd891c09a34a9025589cb196dbde793d60c711d911982b2c374851f81ef9b9a0012ee32756d930bd5e43071dc637e7aad2f9756d86a460e9060e22b611f02e3d4c5221beda6b9958c6ead3a65c4cee258587e01bca245d7f9b11f2297c9df663923881edfab5cce5e86ef43f4afe93b39bdaad53609ffd90a5771f06e38db5786e7557f616f3f2b11831ac21f47efd3729329dfebaf6201ac14939ea772238882a53fac014d835ae8c316c700a4a4214224e0c789a24049ccb25cf133b95bc7613d732d53b3cf724625adb1e7cb2aa1e580900999051e0209991307ac7edc93e6a09c476b4ee3efb617377c9d72fe3b981d8e75f23f93d6404ccc6907c51ebbf75e257f97d2fbdcb6a78cad6f955cb1d889ff29550cefc99f3464e8bec17d979013b0eac34a30b20df3b98645788898ca639542432161400343a4d8a477a6bd2c6157f158733079fcbc7e827b51eddc1376c28375f7b15a1cba0c9c59ccd182e48180aac37ba594d999eaa7a45f014ac1b0f9f3eadc67cc2c6f78f38d540f72974bed8f22e4aee12a378e424a7e5a5ea41fe67cd9bf4ff9d0b8839ff7247d45362ec76eac459a5bb3a4718e0b648ce1d610b3b1255d8d80df6fcaaa375fa8dd592531ec64dbd458f8b9ddb88bae0ecd1662ab82311d65a880b8f9da0311b89384b76c33d2f974085df41536cfb4629786436ccc4ed3caae547aae0abbfa5f9d8dda99b64d3673aca4d7f39feb63a18581913137ce039cc68030633ad2c7e7cc9f698e732428786f9ddd6eaf67f3fe9cb13aad5c40ec2fd7cff7179c9d55b915495137c8028a2625f86bd1367b20807d154e0ec82c5f997cf83eb689dc72569f3ec27a675821d840c19881e7d54de0699f1bcb458acbd6c26777ee64f04fa561ed8445121072c271edfb5de33c8e59c2da9891987296a65f31368d13da017572f6318f6a8ce18956b7af07034f8d9ec4caac58148f15775078ad50b779aad3003a50125f0efcdf288ddd0bda13f5f178406d2df3387c9fa8b19b43a94bdff61407dabcf723fe58b10b37b4d25ececb1159ff58ae3224521993d8f6d97ff2d7d60de9fd91204438a996f07fe50c2947833395c8a76d26f77914e009ec3eb75206ad13efd371ca211742b6016ed5b16f19362a69f5aca30770d32c551eab4b943bde51e9f7d36d477f29bcadc195abbc0ff423da9171c010136163c9849ca3ce5585b02c28a2d3de98c3f1e0fe33aad48c1ea683a1cdd9d2d39f335e70d7380feb060e2737331c2cc28e197a62d36790fe7e9d0aff8ad7c43f7d092b7d14cdd53db46e1b4045a7549fb4663472b1040e2b024798de13e19995b8820784803ce7e7f7cb71c4aa362ddbaaad06058426df26067f24ff7db85cb0b70196ab624ee23a834cd3e52ec3780191961c3d7a82494399ddb3ace3394f3a165b8b434dd1446a061111758280641e4ea3198bb6ed8daea98814ed824870977451a195313f9ca3bf2cbbc31af5e482b2ee7866cd529fa7bd450b6b03d03462ea47c1b2a850d62be1e966f425d0eb20021e2be08c68fe4a160c313927f8a204a6b1759c3ff2dbbd921e1420f306f6c60d56b8dd40d96b12b31d89da754a920dc0fdac98f85657d2c407d71e95044c6b1c36e67e8d2da5385d05690ce1175f0d24d852250575b6e462a4802991a843a358521376751bc3a81d0e2a6e7d0d998bceda5a66f4c6fccd4f981a854645301d5ce9c8dadaebe96a5ddd4337f01a56faee01f9eac01e09f3dbff52458f5de17b885e7469eddddb3e88c6d657dadf1d513d7b6254e651ac58d98ace2bc332b8b78f60e34e1606d79228c06204e0702da14a2c595676b441d746360e0e3d7a9d74ba677c31b9b33c8530fd70cce84a22e40cdadccf29a03eb2a5f14cbe67b349b7d8acdfbd8b5f59a48f657d0f41d0bc3f6aeaf63f24a4eafeb4ccebf79231f4c5ad3c0433544529f66ff9d5e6eca087d2e3a2650437796edb83cc42adf0c082ee77d870a88b06455384a9affceacc8137a2233c1f5bdc63e4f55788cf6a9349bcffebef4742611b6759ac366c19b226bc41a65dd701a0d18afafa9991ed560efb1cd941d6efa8ab4a586dee104cc49c2b30e3f252df4598127253e002ddc027c238b7e4e323e9a141a6a8cfa324bfb35c7ffac8cbeda1b24d838b1328b21fc94d7c79622318e2b489572a8e0378e4e042cd3d52f0c480e722ee47a06d002d4279233acfcfd7e3f7ea901b9f8d80d4dabd258e951249d5953d723dca7bcae41ad051f6db298af51067e0b098bd10b775cd9ec3bc2659d547bfcece7f34afb0bd7f7491cfb22f5f10138cb442f94b1afdf31e9f4971e59c385a1ad673d2b04a7e5d63766d61c1f542d0f320252e8a80cbbc55a032074f741aba379785a9f5d7f288e0565d44783e8524af2800e4e87c38aa54840c5f9cb802f3c47f4768db0fef9cc651142acdcd4af36e5291070c855bf460548c1fc28785dfc766a998b0f62609c22570605bad3c7d0ad3b05ee7c9860052b2856d644dd27f7aacc2ff2e2074f99f1b8c2f6db8fcc9d058ac887bb4b10311d2c6730b978f8236d3c7195d5c1d2cfac06b358849d39a6c2e9159eff739223a744216296c8183088b06857240cd44bb3c65c11c2737fdef20b11d872dd8841f03e150c96f6e47ec4c87dbef873b8747a3fd8d8fbf90bc5ae3475bbd59e66b80a690e222fe4eeaa85390c453d181072e68665e3df30032204471cb698d3062ba0b2c163a47edafa0363dfe11a6b0842665fb12c9b7e7980f75b9e66433a9601bd8ee0e1680786045816a0f84203a09b2d77fc6844fdd255f6b0b835e0940a8dc43d6ca5c683165b471841fa45f243925e9b9d1e3ed8a1df37e7548d4a6c9dbe6e63bd1788f1214de4fa7dae681a95ec8a9127d9eecb3112588e5af2795323726bfafac6f6a8567d0a092e95a55f50973edcfacf2c979f8a786d0014a9dd9ae8f9552feaa0a7d5a83ebff66912581c9b7caf82c30acf392f17f7f49c14247062e6df5d932c82caafdf59c9c7ed124dcf3af6fdb15818f9229b9cd9325269070b33f3eb5db4df1de5ae5ee6e390610068a42a349b2942e64b4eb24d8009da6285a9740ef1da5992da610d6d8d49a9b987d9e52a9e775cd58e57910e959f68ac03b4d32220c92419b35b90df501e3cb9a190408609676b8ee63cea26da580e6a36b0ebab66837373f365e3eed85fe43635bdfdf8b75d6d918cbc4f0dcf0769dab40826043690aa5419a2004995797fa76e0251dd9f3061f35f634884d979eb8ec20c26c6a82971aaa6f73457e8e2928c5dcffea23c3106b74f4b1b60155eb8b00706346854fef3edbb4f2d3115b30f7d895b34cfcc16987bbf299555223f7ac0c939e5c8197f770de84bbbec52b7d63452c1feb05a23cb75e231f249f7e0ea8406bdeb312ba072d551af20776184919c3342ab49577ed2db206765846c7d5093af139eaa79f0eb177a64f55bd4d1fa852ac4fda6d978f0c0b8b483d08bcc1d43dc9ad9853267999e02879295882311b83ee8df84b0b66a2b40893357036bce8fba2d1f01fcf5657e9f9d6c513ed908ec34826508b69dcf534136c8298ffa038fbbc2bfeb6e6218d6fc4166450fc49dd1a137b393c52b98f0dda9a01f11397d2625956ade84bc168ded17999cdfa7ad2285a64a90600bc99143ad063e4bac1ef4eed44f792c9c9d008fb88d98714ca19f9fe6c9ed84329dea630d7efe08ad63d7bd3e7bbd48e195ef6c3336ec60faf2700504cdb5ec09441937318d928b18ffca0d68e975b7201147c581f01a84e44bbcd13187687aa7afa7f2e71b7caddfd7b0d529a89005f112a850cdc42989c1c70de6a38ba2617ce2e513dcfc0263a7cf668f86d761f69fa6ef569be7de20e6bd4a4c2ed1dcc5fcb81306236bcf24c8db31cbfc266f33ada5e4ad653462616a697ce44ef2c30ffb28f1cb977ad909468a777bc84ed0be8a3717104a3221d927f44722af775008c3478ffc61b0d8b9043cc48c229c81e7f2e3f75b7505c84b37d54313a8706c1fef0897f71bb8d4a3feb288a7444e035ff975a7b9d69f8d4d3a80a04def2b889b668bd3e436892747c960b3df72f4602c95e3bf1d6dc80345dfef5bcaa2ccc0865caa067ad026016b1e5e7fa156656d8f5318b7ce8a37f143de7e26ea4b8c60f059dbcdde61fc04b563121177dddc06911c1bd186b2a8bb9e9e8d92e1512fa0c3858cf495f63ead0d405d268635e38869cbe151863de074ed2f1a97e17f7eaa39a201260b61f472f154eeaae5ceaaeda2901b2258617951a7da81be363ff89ed41ff52e15c499520d38796a26ff220cddf95cfc8fe4e37d1ae5e9b7cf8ef1738b40d26d04ac4cce4472952e4665c8ca3407014ba92e8bb4881b5c14dd9aaf71b62f5ee4e43b32392199d5fb6b6cd581fb87e66d71d6a0c7616c2c22b07aa0cbdbcb2ebc1f54f0a3f66ccad750deca8cbe2c668e82ce99d3a113dad1914776850f3194b076ec4366d63b698eb57e4e733c00458e4dacaadbb79c164e8fecc6bdf4afc7e7ded1575176bd3ac929227bee4e57e3767ba4ac16ea9155043c191c0ebb27cbd2c80959057bfe29408a6d2a9cba314f6230c367b87a84da676e01b5b0ba0bbfb273616663c9cb59f2a734e0553eec3ccfb5d26211b5ce0193efc3e0f947f23af369b2648ad954d7d9fe31a898cca04b0011104e80e3af7a74a5bf35c55f2d8a394b9b171c8705a951a71bdf4eb1b3e1dbd52ba959f7cb07d613a7c6bdd183cb7851c26887520e989fb41b673ffcc572585c987ec141c835266463b33dcc93a2c20ea7029fb50f5915257037ab88cb104e592fd70a162ca6f3668e56301521fe2999796efe0baa577a770761afe3ac64e983337cf6d417b1e15ea2ff6b44d786fbf2fa89fb11ace6efe9e7d1ac072aa87ba905ae0f7b45200b2fd24f388e86a7bf3cc4ce3013f0169e5f036e111e786a83c9671d86cdba98b47ea9bda4e0ee941a7aa43690fee2077d3f135b5629b331a3bfccf80a37e01286b5d22013b226f63b2044738601ccf9bbfc2842625c06a3399ccdf4a7dbab53e336b6c516c897cdfaec781f0c4046c84f047fe198ecb16a42bece5fe636588703a940d9e1f711466d7a074789781244686b79622cfa9fc7871afa98b04f8ab947d09c3f09a1de706342a82f0874de8bb721d8283bbd08533e3758c71db17c74e51fa58f37f5d05c60afd9c5540c718044efe4260be1611a4d44dadacb751eb3ccd0380bcb0a0d7edbc90b54cc0337699862836537b5ca42ce492ee44deaa9c3af24bfe475f999d69a42025b46f0631e9d5d67b5a03401a7d82c22b7e3b57c36034504597d13c3839dc09d2ef2d789b44a6772d0723d2b4685439f6b4b6826dcc12b2b2adbda29dbf152818a02c008f316c7a43c905584deb5063e9ee4e46d70130d5bf462494d8b78b38570c32718efcf1d1afcdb9c7e635418bf240fd348bf56a8d87b1faa5472ec9112de06200fff6bada68c96fe04989dae02fc8ab97d746407651613ae15278b17e533db448e077d6d64f80110a20851129fc2d7d7aaafaba237c5114d5ae9d019350e8b7055a68b50dfc92721a7b054b6cb6ebb303ae0b7a6c7b6f42c8089a69fe81709eeb13f3209db14ca1d004c0c7396cd0f69b62636db7d064d7341f292a0f046f7018498b27ce4fb4146276113eef2020bf875cb4e39851d553c2ef9c299379cfc6c920efdf9780daaf33f99cfa2b1c8a4e2f7a2f9729e47db13a96935aa5c741494f43ee7e1ec6c31cc21b47555babdf42acf1cbc71d14d0b68e2995601c48507e7f897e72ebc05115023d666e4a94e9f8ed9f8173c5fe1ab6353c1c72ee7e95ab1afe918a3f2d7ddc88bc42df75a6f3f3955b243c61a0e5d897d0628a1bcd3fffbf17dbb2483c1c2e54cb24393e121dc82225b97810b95049b049fbe481f40c830f457251ebb51a8966ea6bd485dae6d1c66cd75a8072e0decbfec3d4087fb7c2eae7d8417be762d83bb6fb7d42bc3d3bf7506da615b8125421da95670b1a6cc028954edd1582b12df71cba882359e394a1a2d53925d479c3ada0aeeab9e34b7f2c0dd6b99b56a5df1d5f58f44fbc12543fcf98af0831d0883b9c8d015b55e31b7b0410a8867a265a3902b31dfff9ed3357e584f5520c28db43f018905ab807729fd5accb90719a98b72145549e23a18a39bd50dcef5cb55553200b2208c73c0fdf0d5859f12e7f3559ff29182f462bcc626099db55c826ff46a967894d31b3e7d86189d2fcc8a0e55d30337f65a176fe9bbbe2cbe878a127c4015660e208eef9e3cb63a005275cf0490a9325c4937fa202f0f570ae9e2798bce29e02bab3a6b402d8c839e696530e81e53ec391b45802573fffe98abb3db8d29b278dd02f8f22f4bda675e7ebf91be7ef72d74a45f9316622a94c3f01d8a9e34a5226552743b72ee0232ef781fb05c6c5d999096d3b4ead5bf8475b0e2dd09ddd2f0bc25298f628f7d78292aadaf8e7df15e8e25fdb8e5e2204db232e879d5e03121c5dc76f48ec717d57e88e86c353369a62008d68571a2c135dd5c8e9ef2f4d8983f104ecbe414c85e51a56e11aa491e7893682dadb640b307255ebf5b83950024696a31cd19488cfb4a76bc1e015491c86732dce64c79e4c11a710cfb4d0f80139e79a13777592a8d0539c2073da46bf39b619bdd8ea05cd43ec56ae5c09498c985a5a2dc8a40ef3b8cad0b113eb8c8d43fe","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
