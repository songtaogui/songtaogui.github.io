<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56e084dcfcf4b4f127bac95ffc3da371eed644a74edf0c0d33e5bac1652bc0be193ace9cb75ae37574ac6f0e7c1327e627fc5e56556012d5924938422f51e018db875578d0d071b9e358e4f95c98ea1b381386c26fae32b8bfcb31d6e7402ec4cbd63fc3765532bf02aa27f7b3743a7150e2f9299a007cc83e4f2d354cf828ea02f4cf2efd0629f17ad3d60c155cb0c37feb2188f68f56b2a55a52fb434204b12ec9d000e292277c5b56e026ca5beccc7c0a14eba1584e1bf8911fd4bff8105801865270572fc0cde79b2be85f23af45a3908963f319f4a96c36c36e404159da676862eba612fbcf938d6879cadc758183fbf01aba8f936c90f11a3477584e599de90a925eca55642fd0f194c42147b207a00c7944d95af093b34896dfd632668928f286b6822390f8ae42b2c5667c676835e841e3c664e5a4ca99338a815b7fb86cd26723e854ac7cd4d58680e7155051ba675d9b83a9a1328520df0536f5c04c0d10f8ccb6c550a22eedae8e3fcb48903ef264ecad3e4d2dc81708c7639e6c8e07908aac53dd32a7684ac5a9fd70678bfb36fb577f6adbe1336ee2333b65c30c0510a6d9678476c7b07f4d7a4097cfec97541cacc651a1bb8b948abab5d6e7f0af6fbdf80470acef046882eb78e617b299b80ff207bb39cf0c4d14e6349b5c09b54e235d731b7b131c312f6951dcaa7b96ea8da3a5b9c16d642fd4f41e093c3bcf648a030f73471f6778e9a785650b2b802f28f50e24c44d0102d436a903548d7fb888b5a15ff171a2881e5012651c64af03be5cf79b4888cd6791878754dd437622ba4ece318a0ba3ac3d6da5fc86a4a8badfd314c0c19d20deff333498af6677142dc4705b895b9821fc07f07cad63088d3f7563cd77010b3a08ead7dd5c2bacd97713189af41d57d7139eb0b67281e4c2f23673d502ffa9be362de19bf5acc5e3e1ba8806500900b1d5458c6ef8c2f344f7c5a98843a6451a8d2e77aa27b36f6a10cba4bef6cf94dc9fccbed6007f05ca7c4876d161f365ed2d94dd9b8dfe725a01aad5095e814f3068431529464576ff65f2e2db83f269bb6b9a480ac12f11fe77db32f9d9aa56a39a61c10741fefd3809ed67c443b613cfab90b9f462df13c74511dce4686f1bc0931400ab6389cf40f9403e3fad1126d44ccbaad51f783a95c825f39515e2ce66fbf5dbff3a99f36b6f4dfbc44d344960a9d12ba42dfc211307c1b43803d40522b585187d95920e3ec08a6d1affb66f93290e26c650cb5220e04e735dac6fbe38625ef3e1fc75292c0346a901b424049d7096e8bc0571f47d10c4e61d3f1db27f2083e090e9565fd4ef8dde32a6858e56c676b885b9278a8d623223dfae7ace147430097be8f9967150ce0382bb917f10bf8a9acb5acf451ffc8ff4f7a7392c880de07ccb23c352d3475f406a9510243c04cf0ae287cccd3131b34a2f5dd7d90760886868227345c942ccc07daacac8a894588fcebda28ede3108f73f748a87b9b326f3afce3b9e7b4df3513601c1537fe03988b2bd15629101dfe5dc52abd644f0cd030daec23a22742010eb4209ee4f00f3dbb0e84e26a7e34ec95d5bb213d8535076954e3489238fcf887f0ed86ff42621ccc95b2303504777d2a73d2c0a6c3d61417c523631a30d3d581ed51eafd8b6503a1ba9e33e7853c468e100cb2c8bfd52e873a95ca1b94abcccc2251b6e7815ce7cb14b3961634e703ba424216831e1cc00bec60c1c06201df0fd21722858bfb77c31f099bed6749b65662ec636f9ee33d0dcff13d5b7766d8b02b396d538653d0cafb8316f2fe1c1f839be417e92de508700e5d7cbbf2e42cddbda2b7eeec7d862177c2227de4ac79e86397af7e7540e32bbb9f2ae6ea66f2bb48912111f1e86b5e02e63ec26617c95c65b5b6ca668b8745dcaf0f0b16cad38b47a7da3f51af802a8c0aad29a736b05429d7c1a5e3d6f45893ece939ee3eac05f1b44e8b0a826797d71148bf187c22c3c584eb73378ebd837f3a476531e23f99d75306394e0aaa1861ce849f720e6f2fc3301e4e33464e35934fd8cabccbb9199b12e67a06f3e92e79ff625217f222823885caa897cb815e665467c2342730f0a99c6014530c877db05709dbc1ecc79b7b953a9a6f788bbf865a5d85a5870ea0742ec714dd4b613088eafb2832f68f67652af052e668aaa2222b3c84b417b1b65e0995683649a31eed02afeaedbbac0df1568e23c0adef1a9ebe61cba25e8aafa337583557b8297e123b021a517944566cc124760477320e6b8d70996fd00c77c95d0be296cc1d1f2e1ca7f651f06afe7a13ebf3fd19f619cf0c93488c1f26d406f20f1c517aa75233e05dd8c4be7bc085c6a304934b086ef33a47c55e953e46116f7f23fc320f129faa39851e7f52d2586d29d270bd1755784b8b41019163fee36cf5f8c9ea01a474f2fa0f9c6631bc6b2b0004f27810055d1c7a289deb823b9523303af7d823eeb1b0e39b1c292593709742e08eca8a0f362ce0db13bcd8154be19339e3a777261a4c926e84a0483958dcc9b2f2ea9f3e0636139310b74e07f0a35fee35666fab3de7cc65a963366c70cf5b341e0ee1e0ffd72eadba3dda8839bb46a850aaa0526ca39075f12cb51aa15e9badc38534d8797121eb859d2af1207bc02446b2440b2c92ee6f314b1dd4e06170f06f4eed1543e52963b926f5af1a1d160a546b35a96316908d38379a2e19c5f5f1f400b2f58ecb27ceb3d6593176b03618c95b78c2d433cc45d5790c51b04dea041e8b9bd15220b946514c8791c0703573c0bb752bcf1fcd2dde28ff0e1b333b7c67a573f302b704bad9bce8f7189514f72e56e25a4336f338070cdea5df977d26c6609fffd38a4b20a8a35c976dec34ecdc4e58e8510f7c4b00b1daafd89005144e19730a35a5f4d60a625d485097229c8a22c7bab201c4d6673d559c966928b6305dbd0ecd7de804831913551b87c3b35e7c220f0397383ad8b41a496d5a250cd46b2928df0320c7df19e0491cf7fbcd6bef6fe66e88f353e5dd90c16917bcd0a2f80315c6f40a4e870450a7ff37cd775ef02261a458cd2b30e5d457a5ce25bdd0ae7fb2ed0f826d5248d31198c71e69f9605758277a75905c5896c1122044b74ac94e2da8803676ef1c833a60d0b31cbeec0f9b8fb46ec3d93b27a6fd3a4bea1badb5de0ef6ee0c1d77d472fed371d0d799795a23aa0e34c827e14516ff95825763ad01be06db492bb46f4a20a67897032984f3230606c1f013b09403a5034a1e8d06d7c56e0befad56f3d238e7f3ee0bd0fb46bc519df010e6c2234d0898b0e0c51929bf9d3f16069ad8322dba11b859ff2cf6009ac33704586a750013489ddef3fbcaac2c3fe76488d707e37e46a38a7118c3dd74380f7b50460e5d33e11d1c370ade4dcda171ffe5fe6bca2e23d66bf76a7431ce703038cf408cd834a3eef3f618eca1dcad1ae693f69280c8b7704bbb829f004f216069e5cc9157881e346156e4dbc3ed629279ac673243c03f491bc12ab33611113a2de93f33a27c98dd32da7199c2148cc675d16f082158954a65375ae5fa174548da31fe6fa5cdd0df3b85d9c8bc09c6970e567492c02b2e177c09e025b1322706afd4dba944c00eb18a414c8470eb93f1a253159f32435dd437a2dd6c369c9f1ce34524c43ce16bf5d3484b530850674f408a70c5f92baf4950bfc143162dea33dd0caf6341f5a9edca7f912c58b926fb11e9568d1846949c7fb16320a28129f07165c4d03753dc026cb7a7096b23d69775a84e34c2be5b883db4157978b389070820ed0279e5c3ee938e2830d7b89588d5e0c04ac3164f54939900557ecb1d9252d77aefa1abd9ef501f8c0a118855cf25759de2d2ce03b8fc7e8293396395b103b6804d96b2b4c817dd793c70b8639477b9ba3b1b139816f91baf31aa74ea2aa092680a2defa45dc0fa0f180213901aed91e7f6f1e19553026d1cc7a32d321c06cbb6629da841a2ddc9a1d3eb5b9b2640c9f2bad01dca31ef7283b3e872e74742b4c80dffea06e267fbd4e7407ef43b0298ef1c108c249b359832f814f3d45605f803dbcc7ed131d4b2c6e164b51363c5050df4a40af3441ce1f105c217c4fc32e5b0cc35f4bdacbdd0e2bf56f2595d477c9bb926758977494089320ce809fdbe82b02e1fe1f20a20aa95989eb379e905463a04a8aa21916d0510b2dd310f77f5e5781f2e46f781b91d543bae8c6227ca5cf44a9549819ae9467be4d467235c8678fa57165cbcf4cd189914c0d014dc58529ec51666f1958614cf6c3d06bf7f80943fc7f805cf521d4aea6f5e563b03f9f4bc8a86aa061c50c52adb2be263d1e523342c359f700401e74dd8f673ec46f4490d4323d28acfe9519f5e59036da433a45c5db2409b1d7f7dcf2114a2e2eada8172de2aa71200727c9829cb4fb22104d66d81a163945efbd06aa1794ff38be06de5be19397b46dafc58b2cbe05ee37dbd90b607fa9a1b2a2a8932c9816652a5e452b08238c464e12332c41e412ae945e263d396ecfd68175babc9b3cfa97be7569d7b78b216b994367648f06e309bd4770ccf6babc50a434c063b10880ca98296e232dc5ab017ca3e4fd9ff71f5e0c5eb6daef9b58b7fa7241a57275881698f76d07ac9dc5e81ddc3a2133ae5b4b517a729d2d360941f409a8cae0e2a9e220437b2ea3938fe1326bbcb4c1787b93d15aa7c3b68f8dcbc9fe49c2138fb549563591df157b3589b094fbdb69c5d3ff9c50f100992a0d4dbddd7a1434416258441e5aeecc400429466af0ebd25bc5927f76337e6066116a8b944f360fce7659648cf24f3b432652d5ae8f07d905aefe94143c90859f13c885e7fbe69f5be0dc82306e19e08f0396b40953c85f749bd1ff45869486f68fc06bcff27b163c48ef3acb4165cc77d87d21901f086b245b517e98bd12326419fe973b3d317faf432c1bfd736d0ab5eacb0b85345b66c99bb290d91b5223c7b8ac9f199ac7e38bee1b2cda26cf199baa73398c03b4756042dc005d245787ec326b103a738518376a1e0708ad34dc79b06dace28d797d59ad750b882ade5da199bba91b1b5b480ade4cf668dfbf5f08b6129855cdbcc620c72a0856907b490223cac17ae3cb2920691b8bdd2f9bb5c2b5d83b9c31fadd58be1e49b0f2f4866c278e43fd0cfc3173eb7a8554a2dcde678acee697d1a027f79f4c194302bc3eae00d229ed52defbc4c1172695980a386ffa2968fd9d329868a102bb33daafa9fe34bddb2c6c03194b7f24cace0bb5cd72c75806699de6d5783caffa9477c364ad3ee01f4647426a4eef583f8e9f46a738d6aa8a3b944d6200ccbc3d395c358c9ae89a47d5aac7350a1bce1a223eeb6b1c17a7e170334a7a9d0a28f4b596e210b617611a5f6f1101cc54e69b6e0a55d4b5eff4e94d8d9575035447598aa7bc6ee65ffd0c2c80e665fe9ff306e0776f58335db581de4d70fd8da79dc4640958312da366a4c2f0e3a9cb5b306f60a0c54c173a43ed8a85a191c75c0e8a2ebdda6837314da168a63be4b11413884518cc4821d0e301ebb4d04ba8a84f70b466516cb4c2050d1c2d2b2aa7714da0c9dbbc420abc7400f063044b9ce004f55d242d840b086c21d65a323451a908f11229171f1c4acdd99cf61c6508fbfdcdded0c076efe3404721f0ef94e6c3689dde8f42c9b4b539ee919775306d1f5d3853939d0d377d1e71e80d72fa4f69219f082cb4c47a4a655eeff92cca6c72f8e9fd10b183ac08d1cd8a880b9623d59c34954ed880dc9e5da54b9a2b6caa423013a089895090c362eaf6b819428a508f8023856fda5f71d3fd88f87abfe43b324b2ce2efd1169115afef18b2a04160507d47dfd033db81880b23d6c7d99e1d5cf716c793432b8f821dbcc5137b727aba04885221546765f776adb3adc07cdd17e739ed2b42c0870aaa602205c34f5e044e227641ecf7f03eea9157c39a7a6e260b0046ff72072b24765a6c9d1a6eff477285e5c6ee920d171728148bd054eaa1a1a865571d2e446d3a6fa336d22dfcdc364c654b4679d72d35d0abf7b7bc54bc26f8aa2ab5f1105fd6e68c809f97bb866bbafb6e82971c7c2da0bb94082528cbe29e274347918a0c323c79e0ce2cb1717434711d0e88ae84f9c429db8223d3d5461fe16c290d52c6f46f4e8ca517949329d046bd98ccaf67a612edf107e2046e7021e377e52e01065895a46d13ee2c38efd3b8a59d62234e814645ae09fb7d90f478423897052f0fb18e676b6fb0ff6bd9c6129910b2c741b0b4372318249f191cf9d20673de1c5cbffd6fc3199b01f53f77e4c402a731e6d41c24a8bfe80d90bc79877979e3fe1c3f82552b364676a5d9b6fd994ea5023a919b0506d5a38f09563cfaaee9b5f56cc4c327eb77bdc624aa0c086f67aaa2020e20bd3587712e0cd3beaafa7cfd6ef73ec687de0972c7b025a7a52e9737d0527ad0b29b3c9aca37d579704226020ade776b7d759415acde34b34a8c551b69ff1bb4fe2ce052277ec5d4b356702ec8ed77d19b2e771ef9c5560c7fe24059cb83aea81bd9d981c95ce94c3b529c1a31c300132f080a48a9bf44134cff827e876f29f239a9dec52cd063c770b0ac363b3efd97acdf703b0af4d39c54c9a5e76797662f4728862dab6c51becfc0e7ac7e933136151dd42280a86c3cc062107e23616237d7370451d2666f5690e21d9b4340d4370f3279039be6604376b2b633c588da412d998388b878fe2b1ab922e38be3a28833240e735ed0a0f8f8bcaeb3dd22ef8888434f8ab76c0eb06c222dd767f6b2ef50e4c772b143946426a71feb4324cd236300f132fbceb91293c5a020b900d9616519fe3f0e5cec28c45eeb57303a89e0b1218227dfa4d20405a63787329809097093346f0dfb60ddb6bf5ca2280857def04cad23789f606d032a489f3939cd0329eee5cee6501d0e0a93bdca169a4ca7658c925ac27f9779411729044d9bdb4bf64a1a993ffa0df3113476b2e7f98929f7d4a4a139b011097a75f9ea873b693650d06fb91e3ee5db4d1fe1d4470f55cd231def79eb17bc462e40a8d11b52bce1c75d42bdb7077b0f68e058656f1693e3d392647d105125ee96917ce50927733998dba9f71e52e5920c551f43c95db03daf082e1c6c1033bd53b88ace19f8842315f7b6f936767d90bbb37e34a9e8e5162645b33e2928dd79756a3cd13bed7f937423a4eaff054dac9a7f1b18c764dc3a4e703a1e5bb38c6153195b6cf5e20e4ebe99aea9cf5dedb7885501269bad2e32be68678b988c49b8e293000ac7ecb134a7ae57666a41395ab7b593fd5fdcd3b610bade96cf55ada2372005ef98de4901f8a1da2a2f0899d22867bdd2b5cebadaec6cdcd9e080431e7ae973801886b209e282560509382374400220313dd353a1529b4ba99475ccca7925af5122677905d3654f48540a61297b5218dcfa4e641620f82a2abaec02ae353de6d2b4d1e043ca0d3bb2e7915c02c909882f998a2e731151a879b320220b814addee5cc2d3c39535d0c8da6539e659cb8e1c50bb1d53b7769d362a8fdd4c8abb36bb5cbe48bb6797021cde16f1ff22def649e61e1bcfd8621c70cf61b1a8fbf776e4541eec4f2e729325604d8636b32a1054eb4fcec969c8ef2f1847dfc9ce3c1b372de47676703fa3811df5e99c7ee35110a9c35e0dc84fbb6549bdda36b0d6f22375a32c00373fec4f9589d3bc75e224bf66b4f7b6fb06ea44d7d3964ac48ce0347b1ed404db47a6cc4eb06d6293b04334be6a2e2b523b501b1a030a8b4ab16213d86ac43f008c13875c54731d48d45c59fd7310a17c65d02290df2b97dcf24cf65cd9399297ae24fdf34771c209c081f04f061eb232c53145efb28ac7abad546a1ffc24e8d0e9332e3c01e8d6a4a9ed4a1b9867dcb92dd447ab108a55f1bd05829b921e2e99cf6ee1a1699d57af9bd4cdbda50f55d45f60969dfe720018271786ab24a780ccd7d29f35af83e3b723838010c8f7e9fd65415342f0cf8e10fbcb3ab7361465d821d19bba37f4adb8f39d1aedb3d74b9b5a86790c1e5bc20f7b1db82285f4b162d850923e05c733cbedd76af71c450864ee2e3cfc9636694494a2aeb135baf543b5960f5eab51ca7eb44192d4b7862b67bfba68a2e975186d4881c407c1021a5515607fe7985643d06248fd684ebf0adda32d847ce54dccb4ab7d6f663c39d027882adb7fcbb387ce52ebafcfad4ccbe32b0a0e14f4c49dcdf879714b28d8fe227d93957a311875d6fb5ae4a2f0d562ee1d475f49b8cb411c270e5838a228c95c06a6d620fbcd2cf2551c0f9e3feaf7141b20f8467b64b598989fe84e4fe2944915a3fb4373999cf2594565e9acd4a6b0c6947c3dce1873e9fbedab57015e92abd28ecb472e4e349ce7cd92b4e16943dfdb01a664122922ee5c73c22b0cc36963618ba0a1b9afc1402445ef3779055dbe292d684078b1e9c71da40ceac01da6a7b6c8532edb2ef22feca883dd17237b91055c440bd5e0ed9d54a76f3785d909db316abbdedc1757d551679ad2dadb937611730dbc1b06a3074df72fbba0929328659cf280661ae6bf25ef0b8167ef321c5726f70a440c50bbaacdabd53d7dbee1d17a4634fc17f5f3797caf15a3da49cb3355e48d147c82ade5b7a5146485d0a486bc78bfcfdc512faed5d4cb46283a24070a8e7e4a23e8e713cf47d556d75a0fdd5749bc0d059b875a6b5e0d4cd0a3bd4a575e7c2a7b5f1f5c30d1cb955c9f0a9c161998db0535c756d710d671e7c6da1eba8c586af34d76c5ececef14c000276c0d902eef992be7edb6f6f86abf9f55551dd94f55c9d7ab0202ade10fe527c7fd1216297166884a83a8b9bb4bc6c5bf0b0a29d5879a9b088d8c844311f16b9e9440b559c389f5fe51f7f96d1d8c30db6dbccdec477d34c1ef4cc78e888a9db5e9a5e9f24eb785aa525a5f147124b06a727bcb2a1d90cde7da78855c39e92da406b59126c74e714500458822397269f5c3c3a53dc6383b8a0927d08b8fa2c87a6312660441c85d3d6610c4faf2b2be15292dff3bc8e2b5cc75d885d5930a4bec74dbe39eada6c9f747b1372d7224cbd06f7c876bb407b050283b9b1d1d4f483b3688db89e0641555f951e0030fc55d691c173e762594d69dc49306b14eae7caaf17ec6e24bd845fcfb5f8f30baee26d2c257749b9ec2ad8c06c1c4d0fc410a96df1c39048356a6539cf1c792f540cce98adbed4c7e44dbb4585655a075b3b836d15bd3ca01e174e8c759236edafbd4c855d909ef262db0a6461a22a6c7c210c47fde61a511f58069dd2955999e186427f9288a74e39578ca02c5bab1d677ebc38e55a50322382cc0008d5bb5fb43a1200777964f45b272a645e794ac70bb04227638e9ee9621234f262111c35a9435f7aa8064056b52a6ae40c08950268b37a5c95a5117855d9ea83aed01ea46401466c08f83efbf3c92d0473c7532530459529e77ea3b19775e50fdb51d55394c89691c4281257cd53736c431b83b55e9493707badd41d515c68b3f94b0cf15f37d97245125abe77846dbfd05e26f0bb85e2b597dedc2768fc901cf7de0d6d283114afb390f58324fe4ec9964a7aef81a95168661149ee3e41b850f6c3bf6ed9842fef9dde9021be917ee391b55a96d33f35915f2f86d0df671b348918fc0e407c92b941406c7acccdd0668e34607c0c3f92510fa502b6908bdbd24d1b2c3bdf396dd6d11fcc48710bf1ec750b4d4df25fd54f74e7cf13ac17f19a9d0645ee54de953c2f311745d99be6e9dcd52967c11ca75dafb788f030bbdcbf89ab9b4ad0dbe792532e604dba0829ca694fdeab0da640ea203ff58557034c058ab1ac05ed116719dddf174bde6734e85dae09f3501687e7602d847da5dc2bb4c310761df50ba0a9cc893150ba80938b4ea299402e06f180f26670558bddb52715e64c9bbcc5cf7e501bb99c309e66daefb2cc157ea6f5c514c596fe3143d5136bdc4c434724800a265e1484881203d29ab23f00f4e9ef89c05181e6de59b967399e1593e6956ed16dd561e68176880ef7d073608932fac8332c2f33c7e6aea09db831dbfb06eada2c37c3aee3c26d82e16bf236dd65541a871ed608d4c3b05e31954e8ab22240f0f83b7deb2c2e52531aded5179121a8350982d3e412ab11ff494ba8387d03213a9cc7483076557dca325197823eb24d5301a65cda5c84807f975d65c5467db338f5d06391d2d06a13100e70d43950a2fe80fe63acd719f523c863fa66a88b63f6da87bc4b576f7a1e7bfde2327fd650b1ab699567ec513f94d3cabcd90fcd822376cd5fa60b651c96b1cca13c32867d6553751e1a902aa54a3d79d24705d66db894b140780ffffeefc4993e9ca260e0680464c616e835adff5c401d3cdf4e7a5c9708f8d457363fed86161d7e18be62eb493fd8f035d547757c3123051abe7c86e4aedc8ab7d79a5c45b490fcc334c9a75888dcd6ae1f16e83fb3a65f42722c9276fc4c9e5ebd5bb019e36905762e011075cdcf87763c4c623e1038d7d275c80bdd28e50a6973d44093cc3a8f0a526ad9a6adb864e1ab2d040728f39807975991906a6e9cad5ebb2c657833c38040736d082c6d77f4a6b9086d3a3836644e133128ad249b60ebf12fcb0c256ab0b3c226b7a75a0bdbe4dfa59cc156d7fc66444a80d6e115d73ac61a55c2bfa1b67e04bb5a71ef88e83cd4ab122c701e162d16f41da550d15fc347a1de3613264a72c34409093a2557c0d9b7a49e6cbf88491fd35eb92ab1747dead10f276a70a86ffd0ea0c5d0fa0802cda1d2340c63aebf823fb4dacdb3ad74a83c9e53e25c6ea0feac2f556df5da3369318e37fa96548e7ad226d9615d506700829c6f1353774ba9ebc5b65a22e3418a04b4a41e1ced8ac9ef5df13bba11fc9043d983ece99133710601b25d87ea1f0114d0ea162d2a9687844a06e152a6f711b4efd40f0958c75a069ac517f326dd6db38137e353c74c70306ec12d3226cb816cca3d119c3c1fbec293ebe040b40ca42c46f3fa798599b4199771eb406a70090e357f5961635fe56154ba183370ff4bbcee7eb8b1256dabc1e51f8e8b7aa431728edd1086a098fa6aac1012c6c3225024b6a79147473703f4d3e03444c9c4eaa6b63dc1c67ff113f52175616b89dbb596359f0dcd282be498a0bc7b7ca60c7397674c0272512e2e7d4a67362bee703c77c654b6bc94eb208f30c041e3b32c63d4bc077e747c1f0e6a98e36e52bb12f3809649c3a57c64ad48a03c06f724e55d6d0ae2d6c3ec3ff0fa064ddeb0d2acdc66b6ec7a299215954084450bf8e956dee00c905f5429d59398290f6da2063b6135bc0d01f517c4cd893096dcc936707efe00074dae9bbd35c26c26a1e838134fc5aa3f85d6e838af476b9f8aca92b9225014d10ce8b52a092fbaac2442349d1610990ce2d7fce5aa44785fcda0f3f9ea551c25a4f044d908c3f30678bb3ce6f562117e37835ad2b1cce27490341aab1fe22c8b6f4d331ddc34e639d73a814543fb40d72433edfcfc28ef63f296e3cd55fad4be69462f0603eb75a244c2422a39ef8be9d39d9073eb14ee3fab7f5953599a4d27a676243a6039250f787d09e69b292471daf534dbd8c619294010c2fa2331c94a90a8c2426ed5455386be6249c169e7e62e319ffdf4837c641dca45e6c878776e78d5584e74ebf3e63357d53bc0d5bbbb6355c8a738e30cccf6b8d7993df440c1d25df60e16e1d1a82b05811f2214c1c828e49782adfe3733997c30486183856d3e9a50fd9aa90ef3be99896e87def05a2738561ed810eda81b5a14bc4ce4fd9d286a9378f666dab41ddac24bf3091bb36b22add1bea23228d5c3b951af1b5914449ed65bf251d141c2edba7a30e133b737129c26beaf94607ad8295e99fcf421760a2cf818e723e6993d62cfea0110f703d4a5cbb7f4a426d6bb6616206827f4112a6d3143062c60f78d15843cf9d1e2b600d159273f2fa469b56df4c2570c077ca3082fe18cec29cc2c14ea1b739e183d4430cacaefcb30afb291840d60f78a375a6a0a849373d3c3690d6a1510f94fdfb918d1a504cbffa6aac0f631958c20e85bdf4735aef477ca1024db39ce7b8e85cbefbc5fec9b67a230afd718436cd4284e3108191e57311ae31fde2638ec172af93f2ac384044552fae7a60edb6145e034b92401ca035aede7a962b04ac821a11a7c8adec8d6ac731ba868914b939f59308541eb4853d1847f5603c6a8c68ead7b678bcb0dc19346869c822354975b479b10757eb2923811454ef9105824d9830844ecd12472d6f3b6f91acdab08cf5081f8d8c07868ffcce0e1e39917e7cb088fe32e0db289c06346405514ab67c1c8f291451ba7721c8c62fb58d5ca1db54ac40ac41fb137485d1528e9e3bfeefb1159fedc50ffca3a29b543774023d9a0441efac751ad450082f3c3fe3433f33deae95dbf88707f9848d3ae22e18c197cf24ef2eea1b74d7ff7b0fb8a065768688b363f34dc3cec822aa55b94fcd55d560e659ecec1aeef167600bfc0f362496a8cb63bf43d6ae9d3c53bd10114ae633a0075589c1043b69e77dca9b73e35de0160362ec4b1ebad2f7bdbb0b3b102c1229216fa5cb1453879de869536aa130d02c1776922707542f5de5d111fe0a86d4c00825286c607a6295e98e8dda8c8a1fe6f9086b10c1b2fd7c6ab109636f551006f3c43ac1b48b9725d5a98b669818d13ea82853a426f9e03136b6cda54aa6cd1ec89dcde3dc5154d7d7a07772c5d89b36614b0e54eeda9d3199d14121b978d41e41603d402318ab2ff22a02bda73bc27df1c08afa36367e60c738c8d24d93fc61d22c00f14a4f689d3e1e6a7b60285306084443ab8f282378bb2581a136204fdd886805225cb3d9a85a3a39ffbf6c2f016f976794d6a68625c73524f84e67e058479cd6924226da60e7c2c9955db03c124c2975be55475c120da0dfa36be33f9011f3a96d7fac05bb991cf80b9499a0aab51831a063e5cc4eac3c15aebcf54e4ff08bc644feb113c4aa1a1eb1d61e5d63037a99dd6d94cf6d85d7451b51fb13ad07e67b751b49a21fd47463487932b93329ba07a6428c932bcc518c26f648eaa34c36391152cbdf028cecc8d414c0126d8079249118b63831905e60982058bd560d6552c7f196894cdb219f64788215d5e734506279dd32278c6a76c53e1338bd8a4f88ea39a063404d3ac502ff3ba1971577fcb98fa114a003670c9dd6158fad508683029681caabbaa615087e1090c99fc2155075ef6a42aa1a9590627bb426a10ed22ae1aaa32c29580de51a51aae37bbfc1e0f0137b99ecf171da539d1423572e2bb3c17d5168ff28c0656348ac0bb10f01c63b119562d926fc4e3a5738f1f56cb44bff258c4d6a26c2b06ccb69cef2fb7728994bd0557d84c02c0ceb16558f4ec0c7c35ff24b795008681f45668c907a3dd5bcf189c53e9930625126f66307234c4371f36621b8e4bf96d9caf154b70395322610da5dbb5aeaf652536e41562af100dcc58f10b6f646368b77ce9c5c8742a3395b544089090cb7584ed0a0373b025c487b8729ac12f4d57de04d5acfcc28ba1ab79999ca672d45ee6091491e306f38483c0bae3e3951676fc558c26a707b67a96b745f3064177c2501d0bcbe6deaba992626e5b0c2a571111d11e5f289f94becfc3b463d933da4de5f1f03f46f4bc088e03c4bdaebc6b72286fb04abb2e3b29a3b0f9109417309e144d66aa5cbd9bade5735a7170bba8db74fc1456dd2600cbe374c898f2ebee644025e3b2c8bc268129a62c7c779b219430c4af0fa7e48112c6a7bec8e3c694b5f37260e35822be0971afe3e3d29f5dd220df43d5a62da6a28efb3bfe7c85d8f7751c89ebe42c553a6eee6b6dd22a369462933e5802323ce8e902c790b57df51bf0a7a754872797a7a3f5adda13c866a27ba6cb1d458dc4180e33554ed458d2c1b24769df4e661bc9bf1846cab3244ff00b1aa129446b5719b91e5395f273944c6c1a9649cc85b36c44826fb6faba183ea598df9aabc3d7171f8109a69e7b4c16dcff32483156d002393867bb9eebab251f6a7bee8891ba71b743676f9609a1ce05bed769a77f9bc04c961deab6584e8af377b4694d81f64d8d59d8edd9fb352012ac880e22e032662dd7290f0e24d4f48f7e2f91bd905bc4d605e0c1ae0b41d630b36626277062d3ac4b743749bb3b35eb74e839997e14b13316ff837a24a20abd64562ea61444f50dcccaa0d7184796b58dcf5c6009862f84574aeda8199758cf109edd13aa1eb73efd1942088429c6aadbd3397f0189cfc6dfd7e0bfeaba5f588ba6bed60bb8d6ae06f1de4c4b49974a33d8832351ef96cfb56465a8aedbf3961eec44db9cd78127e361d5bdd6d7bf4df7fc8fc243f52a9f33e8d107bc6c014640d65ce8e28ea3dc555e0a5838da0d1b739bb7f8f190a80348f593e3ee2a537049a07eaf1830376181ba23926996193b517e8a85509b449f8f6077fd939af203c652b5138bd5da6614705922db6ef15b0caab57f722eb29b79b8d3b15e7c498fd2aefd8088bd8cfa65ddf4cc18a4065537e8fe9cbc54dccde4fe07e6a6a9cd86c33894f207cd523ddb18dca7567c2eba0b730c80d21ef2bcef7c92f73dd87be5739d901be7e49e20a5ddfbb39f16ce1b8aece83fbb786f5258ab85e44d8b3705e9383be389b6c30bcf9ef25bd2893f6038fe7a5e1b635d037a138aad5607e4f8b073a07075b2bee4a4102b9d7a85eb7f96c5e3cf7e5c47fdcfbab235181798d8499a7c115ec8f44c12fff45ae48706befa932fbbf8a97c1a337d33b53e721b3f7dcd947ecf6680ee88a8104ec98d973a1857ce04b7553fc3aeafc155d3769706a16b5b934a3bf9a70f4a2acda82e27ac8b7c8dbcc8e9f5f73a7bdcb78c97c4539c3e9e07f2d54e96f3a8239feda5e16e5b1390b8f2b563c989bfa126b30297c8048e104ee0226902cab46afaffe2c4a50d73c87306c064362262a900afd2c0ed126b13c29bd742ada02ca02a5e721f70afb5fbfa4d990ac39e8755b4bb68da671b7c6b08fb9481e10164e1f616eb8ab8602f2418b8e5e3d305ad1f702ee8c6e70a6bfdc32483545da75c7298aef69762df624cffa5ff08b8afc392edbd5f4d0a918fd300b840ac292938decc3c5f9b790aa81643d55d4b06449b912acc3a28e530968749ddfea7ff0499cda1d93e1ea13199433ed428bea7743ec62ae49fc5622c4497c98215116826ac2f7f148adb28884e158ca4902a8379b8efa7e3602e12d625abc4ff4cebea325132c072f28364522abd534c4b9392512fea064c14296abf27ee2954f25eec65e9d008b7543875f3ab5d007b5f51c0b2825f628706dc113fb8aba005306ebdc91d7dcd0ca65b0b3805834c6749763b48ac887ae998a7dc1d6459d3dee538b1ef20f49395afea5ded00b419573d4a187fd44292d57630a27fdc29bd27d09ef5c552dfd3bdc4b76bea91125f63f5def68b3b3701d8a601d836a246a9442e8417f55bca402022820628681d0a9bc8ec7146ccf3d3727329d44161ef1672127237046ac76544482a091ba17f7e1d489c8f6e6320cdef918f2ece2ab176a1e0606c2bf4fcbe4d990083378ecc370e1d3d7cee5453c84fcd0c74be34e4807baad5de95553e1c4399343bd738acd12f858f822261cbda8f5d8b0a4c58ae50d5293e77530b4fb1d0f28dd7aee2767877294c6d3ee3191c974d6fd60af0aac1673ae9a90ae2a92ffddbc9b4029d016def400da6d65e5267c8ea7057018b0840dcfcfa8f9162faf2b847820c1a80b540d13263c05430a7efbd009f143fc9e4357b351b822dc80affe20b7c3853503e78474d9d1faf9d9a4a2b0111fc4b3c6bdb4547dc3912d5b034c37ae6869cf187e47ca097541d520dbf427608dabd5b42408f86e3cb73424f818a7e0316c54d8b8497cc43b356b95ec632456e22572526bfc42d68f8f1da8460bf27efe112223ec96c0f5e1c8af9afa0d4558e830959c556cff08f98413d354c9b2f47ac23bf3f1fe0947c4603301c097197bf02973344d48921d5c5143c41b0d25e86dc8e118d42811a8e8b944309ae3e6b8c9313f4d53393c753d4e7ac32eb3cbad7adf33d89507aebc77fa290ff78818a7a6b57dd860367ed8040bab09c2bdd70474e3e26bf4f86f0dc411747099bcb13cdd03d6cc72e534788db8e6a515a6983bb79dad463b7155d3556728e71fb31034ce44a1df6cf9582330aa7125abb4fadf33f978d86b22316a975b29b9d78a59cd728a1db0e8a75b6b02511b9948a14a03ea86191b4ffdbc488ab7cbb02c216aee1e749e6c887ffc729604d58347d80166154e55afaf134b0ab4cfe1e1b21c22b10498980a73adfe7c1ad2f4009667d8be98a4069fe298b725dc5d096aab06d8d3aef857d870390d202d170b3d409ddbd869e610c317022b5b974449a22e1139a225fe7984210c6798e1600fdc5516ca373b713d3777ef5761ea9b6d5f20b45c52d895ca5a7dfb3e627d00c5b92c11c0970e2fbca7f7f0c238d8bd50225779889b912c3cdf658e0735c1c772d0433b24c7161468e192290d9adfa3d139ea72c1672c85069b9bd1fe39d05268b85cb5962c872301eed20f6a06f6d1a5d8180ca2ecb8c56c520c7acd0df55e1e7e2f876902c3ef5b61408861c89c76a37cd3ac0c4bafed71ad0fd0609c0275047aa92ac9fab1db42c793d856d945cf2c1f8226327840214b2d12a49a814c54e5be3d4e33ae69cedd057dc113be0eae10b5f2a94ce58e10e73f8ec629cbb4b8909955b68711773d33700cd6e4bdc15192556aa70236a9a936ee18026d7b609db81a0037fec239609c813321bf81b4dfae752e3c4e92bffc7f1b1b417281bf6fc9a81f4a157446d6b63a47350515a0a6c69103c506f9af4225809a164695e15e6541f9fefc735d4468f8d8c447e3812a9fb7e60be0b406778114eca0b91fb9d416c7e3dcee864f9531e9f7c38b466ba1c8e1ea132fc7445657fc4afa3a8364466738d9165bc9cb2891c2a22e25a6a8522872776552205eeb04b68cf6d6be2831588e7555575cb78546c6b3c96d1073f3e50ea7c250003399fcd8220d1615d3b43aa4a6cfff9053ec1b7724bf03732790c6a32fd7e336d7b1bbf23e0b667c603ed753323a0a7d89f5439c7a68ece40b4f459a689cbb6fdeb253d732fe9c3ca4474308db2df0ac40afd44f793a30412436d34fb9f3de63c9fcdd9441ffefc8513f2852ebf41b41973ccb894c929b511c07adedd032fe0cf773265b4baf249f3f66522eb739fcc0bee610ae5433951e3e612f21115ad097e8ddde9dcdfd484b1479fd33d618e0ae3bdadb28baaef3246aca3c3e68c2a5b09034fe83d48e7b3f155de59522bc51392c2709e7113b5127a54d5ca6bf95d89b3acb8669c6083d4032f70c333f390fecf87a906c89ffd04732e478e6e2f8f8fbcdda906fd9711497f8c14bc541de1618f49eb174a522fdffbfe6db1d107a8cb6a0aeef4b211cff0c75d6e9e2367f34d0405abc3275ad27106538890c09800d9479193f4a6b20c3fb47a1b417d45cd2192bb3f1c184badcfa0f750eceba0e4bd5ec3bc8f2c686318ba1316c9c9b17ad93e8ca0feac86b3f8b9450af3f86bef0ae9c8f7e62192b3ed76551435c12e1b69508d167f85b705a52fb23a99b6ba70b2e57a759d5b81c8fdfba53c909615b85d147c7d5db9b06805f2772052ed8a978fc20d2405e96f3c3f60c66852f44a70c49a0ab6a64aa84bd8266937df46334edaf363c9a69b2fd3bb6ea039b567bd532de60c21f597e9e424324490688a462a77087d65504a11e5199245c3017143f2b88f74a5ea5f50771655b6ca042b7d3cd9b4df58f872c8d6d18fa9ecc974bdd22651d7b78ae68adf7f8f56b13d2fa0ff8915fdbd15efb76954d2a01ec74333d726662e9a58f8e49907df4e15fd338762a03e6f3722adf5553fbd215f59d7e972f0d3213df1b2b1da00b413d380f3b85ec1890bd2135bfdc840ac725645c79250dc2e5fe3396982da75ff8529976f72906ab62028d9fcdcb5aebf69bb28e22b1721bc896c25bbafe00be6c76dc081baa39e6454f5177568699fdc3e62ebd1a27f81448a13714cb87c1b5157b2ae4191bf203ef01c7972b8010f157b7905340079c9157008f21e3fb72d2dcd3adcefc7efd5f147e0babf7549c3cf275d311badc0bc10896dc923bf7f662f9de84b8380941ccd43d26dc9177459b29c9d0908169a193f12b1a81d2c82a1779c0731c160207e8fe0e00b1def933cf81965a40edfbbe753430e54e517d5062c229b0d089d32bf2274e93941615ab567b1163a7ae01b2d7479ec20a1e635e46758ba9ebfc4ab6ce32453a56a770a051de40400290dfecc280d0b8e938da48f7af34863b69b6fba8ecfcc7c4cb5e4f4f7cb177684bfe498856950a6ca3832ad399768cd5f95728f73413d216e7bdb73ba055889341b38c8c21ea8a12d75a6547e8e94a12cc655e597574201dab93210f1cada10b388363003db93929668c9235ed9cdfff6298b37227aa61aebe116218160770a21dd67ea1a1ad18c2537ca26bcf39acfc3cf849000b0e8fc29485c36eb80cf118bd6abd1a225f86754db9de27250630d6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
