<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b86cc56942f4d72f7e1ab4c033d158dba2b805e4bcfc7c63a5dba5f887006fc3abff5559ac572d20e889cb3e97cfedbfa850ba92cbae4b05fffd01d3bd1497469e560602e235ec4199e533c0157bd0ea64504265362dfdc9c119b47ff50d9cfe972d276052083b56f5f2ab0b8fda0410d7f597665548a02a61f5200495e0e1480e7f28222e97f039324580bf29596d1d43bc74032df23266aeb4ccd5c6793d90db055c3f4507a34c4f0a66266a9fc76a665894ab14ccd9742f1a68ce6391e6f4f839a0bdeed85f755fd11d3d60a580476f9db04a70263dfa3683496e1c2a16a8a1bc5208acd724de1c56c1b4b329baebf53f597a60d7767d8a0aec5d78c3806209a26b3f0de4648a15d110e7fab0e3fda052c1689179a31afd93a747c8cf3250b912d8e9b03f5bd4937c9c40a484c4664e84931fa8d66f9bdaf4485d0113fe26fb979270eff73ab1dd25d5a09f829dc9a4177cce34e90c2eb6ccb42164bba891578aab2cbad018fcf4bf2e0b975d9dbe9aa5f6d6507c6f394e83e49bc8413ca8c5824cc8e8525c92e48c72dc6075968abac7a95d756c0d6d669fa4bbd54d4eeef57d38305e451b19c184b9e1d4db052f5b186e5fdbadc80a9770eb208679454a176ee409409db07de568750e5e15dc1b21d63f10f56f2f44f522d1c81a61acb0286b1a36e2307f6e6201f223e8d6f21988024d6bb4e9cafc00acafe439bbbf5411ca60700dc5d229f23fbb9f80e5558b49177e4fab5f534fe828472a1e2c7490a49ac46f4e989b616b64448af638490f60b24b2c48f226783cab502d01c81bfdf2fb00ca3089f35be635212d92c6e4a792b5632ffb052bb9a8c16d0c9f08b4b739320b69a27cb16f3aea39710992d3afb986ea6e642f64f7f44cca5fea61a0dc622224f86594551c9c6e82d43930aca13f4e61588e08ac4fb01e620c37a5744581874f4e2585d991797b74e4c1ff4649d256dddef86654492437cd812414173988e4157907a8e20af869f2e550263c0b80cb9042441f56d8eafd30678bfdb5cf500767752f0abe8e74921e854effa7ed57a83ea9c5694b01ccc6a15cd1b6f70034beb1b58b0ad3ef078922153109961ccf7a96af218ef59887a09503f8a8f3a18311c69d61c177291723e068ec2c75b5f34e4b40dc626ccdce9a5ca1e1cabba95d7ba96a64d9807fb8878f39c2234cce9d6a94176f73bc417325c19d55b08da1f8f5478b649a7f24409f089a313523b621e839c3490ad1cd4d17c19de9a03f7dfd22eae4ffe35626cb6999dde0e290a0d2beda85f1b8b287abb4d2af0e28b521db84b4be7c3de84bd315ac492f1892236f33303a50d42de18bc7a2a0b63708edc912c86e3e5d588ae50337215b215501aa7c29dcb516a63356959a87bb05de2b6f0d1d59878489ae0e5f72a2643c35af5cabc9b44793a4068110fe94e4b555d9023b690922226137e49e780d545077310176f439b6f8ee5d32aa789e088b63cc2b13c7877337dda8de635f2a0c6315c10813cd7761622be4690241c7cf7684812845e6e9d39a108b0c773fd04ba33b2e7bafb22f9c2e793473f8ce517cf69911c298cd4d457a5461fb19551739915513b82e872659b43c6b49b2e7161d72b46c04a0411ef5fdc5611fc9be4266a82343029c443db7fbcf0a33d213769a5f3e0ae114e895804ee78ace8b2972048f43707c6f533d88712d99172939b793d70f8609d5f22b3dd3453042470cf02955b3b310e0de04f7151eb16eb7c818839fb20a7e0fb310eddf2353942e0a50b566ea3c8514feba958e45391ed43b3f237a346b6bb6ad90950dfa3c42ef3c32983c58957c66d06663439b5f6d538a5fd3d15c63cd8d9c555468a966e63277756ac20538f516d559fb4a403cd77d2589c890cf6d47478da36b508e0609580c974d7d38210a657788607126f83d59cb35e190a8ce06e1287f95b00432009e773a2c6f4982f68fe74317db6d7594aa97d7cf14b9ffe861da7386a4c2ed3f11624b0b04f3f52c53dadd343e9bfb5d33306a00afdf8594013a793909534ad6cc2fd50a69da4c6e8b6de44e093654d3c993d426b1d0f488887f92dfefd97880ef6b6a403b4ed9d141133762a0c0f67809f1472d8c862329d6b5d3813ead5e5302c5143881824882472b76485fbae55583efe7b5b406c5b690c57d97ff0fb6a5b9a607200b39c44ad578aac422ab03218069a417ba7e9ae1eac07211f0cd2f9abcb842a7285d03b5e643f9f74965f73f6fe34ff2ac97a7e5e07c06c7a5201ac2e6f347de40f38b53f9943b7a5dfcf0dda6feeec724b0efdf1f58eb0f14bc9b23791ee239e88420e5155302d73a8983befdb206b9b9cda2f0f43b97f2a452072875630e3d33a072478715f7363391653d6823ceb4c1db3903799537fb30d6d5c7ffec01e56a7d480794a8b8f106a126728d90caae261eda93d1278144aab694d8a3b91a7d0692818b202b9557d605bdce0d476cf98258d9baf95de02fc6ff39f861f7447dd18c166ef231f6b0a8b2eb06b40df247349e100093e4758a5b933b25554406c173c3aafc041541c1221bf2aa70d30a842975d9f473deb1beec578e1a2e03eb16718c17c21eb389a9d9830c36f01b953f8b5907e19ea929c4f6c237c1a1723ceb5e7456fa08ecb4c7941738f77a386aae363a2da2971dcded6016c622388366dbdf2f220f225ff6b1ab0bd035406b9a0439ec08f5274601d4d388d175cc253ff46917fba248487126c8896de077f5a56fe9e9d7671b36f2750ec6f821267bac65f1f69fdde48708fb718564ef8e0e19e1ba0dcf7be654fb1b25d57951440f1f5adfad2b7821c7b1af9997b0caf686072de973db1d47f8fe133a45afa83f0330bdc330e3543dd23c1fe45d240f9790d4c4da1f5c2d67ead9e33125e65858c98f384d1afa7ee15a2e854bdb4029e3743b042ebea1830f6c8a0182538ee01f7ee3b3a425a3152a7576db19e7c1a8c968185581466f549de8936e465bba5fd42afcb92a6d5871b126d3d90e5d824d50238695dac4455ea8c9e7c0c1b18fd4e925ef46f6d912379dab991af3bb0eeb061019fcd91b06b4fd7a98d822fa1509860b6cd0b296bec412a263889910d62b68529c794f2f6a033da311d359eb21d03cdc9324963ccf4fe499132e23c53e7bc677638f16ffeab54f02c30a83503a57ff4444dff15552ebecb1a19bc1a100f28c3661ee61cd1cbfbee28a11a689cf74af55db7caf75d17482ff5ee958fed623a140564f148e6d35f9526f67ee8e0099dd782467dc8979e4b0272191a2d3f52cd73b72c10996b33ad674d19367fe89d1c3a9739afec07f868906e35a738a35bebd3cfc109860c460178bef6d678b60f4fa6b6b710279096b072f5f253f2dd35e4c674481388f459dde04d83800fc31aa5be7a7b1331b46f757483c14402215dc9fca4b912596f2ec6dc60b05feefbdf04ecb2783d42df543bfcf404aadc34acee5601004f6f28a3e490454558c96e482c141d7b8814d2759d05db1f2a75b11cc9a3816e2eb789443601e6140b1d1b403cd6875aa6e78d10247c82cb50a2ea7786e2ea43eddbe04e32e19897d1092455fa63f536ecd27872635e001581fdb6d934fd6029e150838a15bfdf6decba9eb9e94b228af959a370b98059078110e9b9ffb48090fab3c9e28911b95011dcbc34ff7eac3acfafcd6167853d41db98f975d2f758d14dfe44cd2e50fe3fe1f1b00b66e01c477b63eab609531948f4446a7f90215d9fd79df078fccc947126111b428d023f4c3209e8e823a83ea4f69657c3a98ab840d99ab87e64039950b458b9673974cac621fc673a689e05363dc4e3efb58eff8d365f76b28a05c7018969da4ec4157defcb416d90eb1702212b0e14583d0b57fb658c22dd1b7d6fba328fd54b0e03361681b91bd93ad5193619a85ddf0876a024355de0e14dc9b2f879e6412999dd6cee45195689014646282c578ee4057e878065762a636ad451d09ae9f6c50f5928c38ceefa084ccdb9fe365c2bd186db4e7e2f4f6914f5fc7be149b928690e4c9d59253d1db9ef5945f6c51b379320b223f5fc122c6544440fce261b4749795bbdbac9c40d428fd2d882c3254a2a9badb16dc305b260db1b6d8fb9b4259a90a24ed4d2c943e93f6a3c94dab334ff12ee47a5b59875c1ba1cb649210bef3b8db18a23f3433df1ff96f726fa65303e0f48f89f4d284f0a6420adb70ea57bd10897abe2e0b2125a0ee676002634d0168b7921d82a451ac771f3949b540440fbd390499eed2a142387a5de1ec9bb698ae61d3e15b9f5f384f6fdbbd120609b82dff016adac7eee67bf6647d90162cfc1768c4a077b298284f4388d0c33295dab0d341efef8a00cfdae166f0c5b7ab4ad8340d70b0b97adde490e851e030688325f441ff8b075c20113c11f0dc8a7947d29152609a575efaf7f5449b4bf095b312abd84a22b6e22e9016d8544392541c88dd1a8f5b578f7b797f9958e5133b681da4cab21a741d223a261911044b1627660e7e1b0f3d1fcb58eeff6d3bfa77008ca8d7084cc3e570ee5353feb8af6356f907b42daf47b510556702278a0c48efd2755e6f1e7644bf1918ab54e3435e093d00f2c4795ba6b603e66fc3a84a5716b68e4b56d553fcfa069aa7cd88b8dd8cc01b458379f10a1b78fc58580a9575057e95387f658f26de149dfb015af6eeb1abd350a7047922b39ba1d26d9f06dcb1bf5e1ff59960946a1b917c3ce2353fed779f908511347f3b8324e7a321a2087eb6b8d5210ba8cc369948607ebdcf78e95ba12b7d42de095501448e0241364e848a467eeb89b5010161486a1a9c0ad2fe2b20d502b4a95c07fd4c3e93f7edf13e07e818282723865e43d19702a502f3315b8023cc6124f43040635cae165fc81a0d4c91b12e12631029cfca87fcb17001aa89cf00613f675dad52f554e21549f3822c6df24c56bf40bea1b8f05562c5858f36ab8e3e9b0aa95f9b6968f5a30034ba1c045a2a1db714ee73b7ca0ead9283070c5f6410db3c0d9d38b6177c476574087abaaad8128b8f925587e3ac50e318d9bff8c7b849ff5b26779ca1da53815df92aca861ccd9b9b38ac2c6c257572266ae4e640d5529af4ca2c415971a434d2bca8ea324ae09c0831f16b84fd43fdb3b629a71ba4f7f23e2c2abe1d89a03d50db17a61660ce8297ae4fea46c104f6435e867740672ff9519371bd19440574e73276a372343488724ea81518c9edaa15eb6186806f382aa5268b9da08b60ec296cc250d3b38b4c345fa1da45e7da87ae3ae7922bfcda033bee042b7d251f1b355a28c44dbda0046870c5644030e052ae1a9c4f3d339f111012ed60f3ae5624ec4331085b7840520b79ba47b55328074d06117baaf596d7313f24d8f7ed180df905740b9b96e1d155c611c1dd6f9e6bc47a770251cc7ca2a8360643b187b115864c7481447131f709bf092a4ac5151f5c7e4639449ee9818e3714ba936fb4b5446af1fa2f60931aed328497a413325b5f551397eea8402d5450117bca24da81daac5ac5c93286c62b5e08cd5ad7d7dc544ec47858deafa92d23a92c2c70f9feef589d4b7f9dfe0b90d7b6de5496bf42d2685392d22b58cac1a6a7122ada058bfe746a1dbe946685b97109b69ce59325550fe7fd0853aaeee2ad2ab1413fdd6801128b8f076d0d719d492d0eb883cb1edfb7e4e0797338227f70d04db1ab98a4cc5adba9d7597724c73d2b94605b1234626b1a45f0789d3ae79320f045e79acf6299409babb83a40b115926e59c19ae036abc190f91fe18305b997268105bded277a3e58dca82c3b7de3a7b34af9d89bbe6a03ad0ac7c6d6b5bb94db9d1ab9b99ce76ffffa76a0bba1a409900ccbf6cee778b619190a7edbce1d1d4bc95f957b3d1e94d42a6ae29553bb92c6d12552cb95a2de24ae7d59f5e89d754016bfbdb2e85c4f04d17613638fd18079d90d5e6e8f2cbee0f3b2cde70369b5e1f4430359343d460eb225cb94089493fb115f364651d9ea1c7ef72d8937a809046477018bb2f6246feb5480da5bc52c0bf044be2505c2cbaf9acb6578a500d3a7c55b57dddbeaffb1181340f3cfbc0069660bf130ffe7a3ebfe7be8fee7228cb1c07fd5e5d70639f3aa2c6c44655c6df1b1dac598a4ffcb893ac5592ca96addc245affbf6e3518fdfdb56c23408027f2ea498a2321d51f620041fffa4ba65e488a188e03a5552c6cf02e6d7eb3a4f38b5cb1b808b400987c905841f504e07c857bf468ca68857018c5d6b0b3f708b9e3322d7e3e5ce27b7404ef3a2845640f3c132fd7bc1ea8d355969ff3e9df2dee3377429c7d43e5247e25eb55756631e730bc34080818320465088ab4a18859c58baf363b44e0ac1c75b7c7eb8befab8309b1bf028e1e0b96df8631b3fc04797c316456d77c36e2da52f3d09f50bdf5740bb8a24eb78832a7daca174c5a29f3d6cb0154cd01dfff5375b43b413d57f5509c5f0a6f49015aab958be8958f5ca32c36a4ab09c844c0ad26832d9cf2a10a7bf442e917aebf8a84d907435ad49d5cacca6dd04ea662d9606a50c892f04459439d8a642c7d401f73b81e9e04267fbd01f10bce1ff929d095fe509cc4174435270ee46038f2cd75b14d9074bff33bdbb1b61733248daf1e2450402d51f881ceb0d1521ef87906cac547dfd7d45fb10444d390285d8d5f562f2c79a0a89262d75214d7f46428009ecde54da5799fcd21e3901620a2c7c54f1fa7d9a5803c8c2e32287b5fee5c661c84385ad1ca56e24622aee6185325941d89a6998454645baff5cb081b2bfd542d0de7b533485866252f8b8ccf89d19a14c2874c66f2ba207348e2b2483555dfe29ea4431a91640381a4eb315d4df30e8a8457f8070535ff5d706c847d2d6cd81682d42a5f3c23c21b54296a725f5f7e68e67861414e6d64d7f10206b9ddf4d667b56d934063ad1911b1908402df165d5760dc46e975dc31bc773ec18c20912703e22bc1c77535e27a72a93327d3f5a04854ac73f8f9724cfffdf5a771910279dd0f5da60df72cad4c84bc34193fc23ea0d8a9820652ba8bf627ed830a8e99eeb43d4b29cbd7b2f38693f5520fa1552b29bc5e3918a9b1471c4a9cdbfb16ce7ce20cede20c78afb9b3b73e5c0aaa5f49a46b88b914d6086556effc13ad177b9449c3830d126620ebae4ae1bddd3b2fd266b4c0be5a290bef92896e6d45fd2e81c775dceef6249f92d27305c775606c80dd8679800301062f2ce62ddcd6a8294d8c13567dfee069487ea276e137326327afdf68dd9d59719a7aea24e707be8bb7ed169854b76c951cd88ee41a79d92304d6157fd8753ebbbcdebab7010f5ad6f10b044ed081dc0bf134e51c885c4696fd140d22ee1df5531bc95e07347933249bc5e656ee3b6b8c6d87ef1fcd739f5ceb17793680f005b223f14668b0c9c430f708cfb12f8ed3be1e432c9265910083676e2d3c66d5958c3bd3921cc4b6741901e913f5a04bb38dde57ae8799a2d6403558cc6057e50fbb0079135c53e47f925a66b75457ac4b6a0f798cecbd0009d60b48e2f8845c9f5c5475c0b06d5ee5b355a545a0b4249938a8a1e355fdfc2888b78eb2a08a08c5aa9e6bd03d48f362809973b0da0770465a301e76df997c927b80085c571260c181f7ea7a9e4916f142be042966ba7a2cd43d2e90c6a3c506fda8c03ef80d5f4e59d179446f5863fcbc47e2b64c282f637119c18682e583eebd98edddbf573e1d04ce4ebc55ae3ed6720a7b30b406a067b7e144691972c2bec56a8f0f4767a7418ce8121d46a5b818183f961aa2c6b7bcec26776ae55cea8c2acdb27a0e6cd687325b5d320b2011c7bd0a1471e4a8d03528db171f4b07086b4c7efa140226e645802b3574a0102a4a778b893d61a5a1456ab18ec80197645b353720d2141e20902e6fdf60534d07fe1c606c3d52c0ba15723b46dafec57a34f6e6c31347adbd017aabaf649fe1c2caf8b20bd5c6788c475a24e2e417d268de7ff757bbb31a578e69fe1b338128850dae2ddd1f4e1e19f8a69f60599ec9579a30568264d26b1a72f2a917bd352489df625a2b04bdca1001c7012c80dce8f4e13d03e14b52b0405948e1c80faf47972d347a67d698ec81dfee492df1e4100d4ab299a2e13e7cf3a8ba2bf1e50e98625e7e1da012e658062e46492ad41d42450423f891700dfc02ee6c9d21bfb2ae9c5784a2e641cf2920fe0734d23d93b9cd5ffd83072bbed01f42f46503cffbc9cb213eee6f51487a802cfa1b6be385f60b8413323bc97a958de16b756f0ffcf2608c5725937a50c53b3fe0353285503ee8f4cba72eb7ca0dfcd4e1e92f12979d8c084d8fc3ad0fd2e8b499b3afb26a915ffbe68961d8aaaf696f198566ed76ed50f75a891edbe26732df914256519d14bcd0717beca5fd6cceb9634131ec47088fcc6bd7693b31ee475435e252c5fcf8a1d41531d1693dc2ef9a26376c46b1810b70e4bfe870653b603b58198636ac0f63e5eddf4b5ca7ee9038c93f53307949351be87ba3fe9fbc7ed00037fb1b7087947a3e4e91b5b6c68b33eb8ae13ade7f86ef4b9af150f3e79b6075f02dd7a7603605b461d02eb2fc6f6c85e5d04106054cc6648151da73b7e96e76b45455a661f5ad591830c4a630714214424913a73e8ca9854055ff699a21a1d88e21aa00b60a4d49d0d922047cf024d76c3c8822972a25aba1fa3a3caccedf1792df146860b82972393fe063dc44d981497b1eac297e4d79d5b571a07f81098a7f6f4cf92898b1da1b1b201b84ac5930a0a78ddf08ebbaf1ebce7eee3581089e402b7c914db7def57a708bff353df5a3a4d0c99bf41f31128b574340d579d451efe513921cfc729e9cc206cb69c868513074923bcda4bdae430c644ee15318112fa483c28d0ec4cac9937fcab7e3866f5315fdae11acc2918707264bb61403ecd81c7e8ace3be17542d095a0d1ed4ffc241a1ed00fa4ca5ad9b3c0d8aafb95ce455cabf9870dc3790ee5d795e21c02bb0a11c02d20985eadd171655b4b236d2025f31f09d691e0eec46031a8af0a55cdcb48c1fa2cbb3c5bc334587a695f67de8fcd1e729b0744096c02ef0ba68ac2edeb7c21a2bf3e0762eb01a159c7ffe922d94a0cc37f843b65c1299d0fa4a02807a835cbaf65e6ec5b6abf205a48fc4cf71145353029418ed653bac6dc97005b1db2f4cacac75eae2e8183ed039e6a0ae975f4f28858d1748e74ef3ad09c36b5c95db6d0dc7dba9823b9ff3bdc39c3b3c9e3b45ebc388b54e76aa831b9ad89b93deedb8d0b3b4b680d168ab392ff773d91f4c9785886d2d2f2a65d56cd31b3c73951875caa4695503245f3d2a307cc33d8969be058852cced978b3af2d8cfbbe1202a892d07d79402b502213ad13c548b166f1d2092bf12822a920a75c05d6bc92ff096782b38992618b6dbad04cfedead49f662a84585628b4c81b24b4eabee0decc214122503dfc29cf1d630eb0063bc3b41e4423ed6779e6f311bcd60c270f375c70c3b99b9adf4200d32934351e1ff7975c2a9aa183ef0d15fb4d9e2ea8eb9b356be75dc5e74290ed8572ec78fb35f461da733d0691afa43b6ea76b7c6824d75afd98bbfe74fd8b5dcfd74984944a1840026059ff12d8397435384afe24221c79725d7f49da40329b4de9e9b6fb2bf80e8133c38aef421d11597abeed227b5c1b87c6b50e1980b9cf165aa875e1d2eedaf3a2cdf3dbbe643f31144a64d37e7393f368988f663c689b88e70c3138e77a0bfa5900c3679216cea40b77186af26ad878ca3b9e28514b15497c3a38114128bd9ca402538a1f08bb770487d011106f60426b23e5fa3f414365a4a0f879ad7fcfe61e3992253e0813a5604d4b1396ee2920c1f46460bf33a095a4a2b7083ca9f11944e3366d6d85f9144966cbbb906d4bf28b3b6b571abeb6057cd407e4af30839e79cd7fb4532094b62aa2b18653d7bedd28be46826e1fc55d83bd0c0883fec538265f6ae5ad7dad39ac863821994c9b0be5cf8248d451a8e00a23da78e422e220a7810bd85ebd67c0c790d29758169c75addb963e7f25f7bb626fa1d8220f9c2bd9ed46a49f3d73aedb0abfefbebbd30fe65723a1096f0126e976af9479bbd1168c0f08edd42e6a46865289eed40a7ce17f01e1445634fda412df49abfe51e6bd03966450a66fea2f381363225b957b3538b56b11a812d559c396626a8859c9d76af77f8ac74f9db1f063c131b60ca2d54bf4498e8534307695a6214e160cb8353bbffbd63f5697af0cf9b80465c76f9690d95d6f5040ccb6df45cd59a28851beb216178e3b99b68de90e266eeac1e98b0551e3c4ce06ed6de38150e6e694f4c54b8758f127a5e371210a69a0ebab6a2eb16c44362c815389be64c533ae2e4da04a57aa248f8a5d2823f98aeffc945d3616326b60f2066dc3178e55e24c91aac3d80fd301f9a235add237f348fdbeb1ddf9bfa88c66de63852e06287e8b322de9964ccbe586ab9f75401e7e311e1c223688c3d3e18db71efe5174fd30c0a1afb6aa8493df6172e5b8db21a4ef3959fdb477ff004503082597f01e5d00a26b0d647b2d3ff18e61f0877318d30a9e84cf17f141798f8ad475502ad82634bf6a42538eb396fc5539aa8663f3177a6ffc5b7c1946c91f898b117d00bd0dd82ba17935773e1dbeb1af09e1a9d22c9b6357d44360cfce4087bcfa6d6418d9b438f3ada610fb333fc9d9ed3d05d7594233b0cf452c511f152f7edea2ac5eeb32e51add1d9f663cd8a3891e2c5ac89c7801702de43c37a8eb804ebbc28ae56774b277e4d5ec44a0bfa77688ec1b7ee7f72b2020fbdfde5b9c7892b83800c5822991fa288a82f7715ef1d7a85418a8e2d7a769f2d2e525fb33eec63317d75bda9c9ee207a3ddae8897b09c579ceed2361096155831d30e2bf6f02cea5f6d7753f6d4d0effa959973904dd9d22e009280f6425e345d3d14f5ac4a9b4e08f6b0a4602183718e7b14bc79b3d1472dfc50e7b1a4610d9281e9d22e5f46bf68bafc298e415bb17183c2164c3fdf0207a58b856dca398468649f41011e296323b691292a5c3dc29493d032e647bd74d8f5a93e1c3009cb59ea29b5e3fe1e1b5af09018536f704eff970fb14a288116699c7d91d6daa445c6acd37da78e0917740ef80698b7e164ecb02eb24d41de5c8e2356f2801cb8f8430dd7eb6ebc161afbdaa7d402b0bde6c832e9614e18eb0463549213097f1da3f17ac0e606927e43972b6117658f7cff6c2c41a7a84660e154bb13eb49855d0819ff24439a0a0652a9a94a447f5f39c2837a987dffd121db157d608ec600c0db9b773fb14f41d8324b0ea199e38c4ccfa9337dd8caf9dde9bd6a661f72bb5f3730920aa70ecf27502a760881121eb22bc1675a5b6621f9b5b20e6cbe548c8ebbd7aa59554be31324badd1f8de2852703ad3d8e10abdd9690cd3258e19f34c1f13ae42893b111ba364cd959af54c9c56d1e35c2a31f950c26da9662a846e6d44fa57ce79a13a64044586d3a467fc4ffc582ee2d5e3c7774ea77b1bf57f2966f22e36460104a3ca69b548241e477012e6aabd5058afb17347e5d822ce2729964a1f07ab497c36ac75f3923f992dac572589f4e08b775f3fe0d977f7e1bbf116a73e2db70be8364defd374b733925b08e5b7418d49a644c46dd7e2038d3422c3d1bb0fb01227a29d032053660f0b5574365cf451b225a2f4f23aa94dff3850d6ba5d781504b44fdd0bcbdbc83e46b70fe3ccaecb6192fa73a31b60a81504356544f5158668b9d62d913c0cba7411cad4d0ed7cb0d78b1c366f3deb88a1d188c7c8e6373026bfc8d751297dc62f3ad4f3c4f2519a06bc7332aadc400c8db731d63caa4effc9fd85540a44adb8281a29674cf3ffe72324f19cfbfbf8b866edd884dbcd556ac20700bd6f8d128451ac97c470702a306d68e13ef023a2583f31e7be0e7fa91dce3a35d4f3791cd85692e26b430260ae926c92e2774af32dc4ebe206c67feccdeaf4b06158530b181ca1f19a762c13769f1fe3828db3c2e379b1cd355d1b05327820bc838ec5ab68cb2aebb96a891f28775652c496a6db2860e8ce58df41ad1032ad571dad09d5aeeb9a8a6ff4ffa067da0165b25554b61b0ff8d0d042d4ca83b66dfad60d8b5291f8b45d2f6bc07451f712e515910d46bc7c39da3dfad21c1857e9d1e1ec115424f3541e055a3a62b0384a7ca9bad47fb8519abda29973f555fddcff8bd659c99e3eb8c8177318de0fd471bd4e16a0546c79d5190b468e7f053e3575f8be28252acbe3af54670c83d5e9a375d23e647a1deaf13eb0814acf81a08f0a6cddd5436770d7f247edead2542ea7c67a1ab8812acac55d67a4b317d7bbd4bb063b080eac223e2049ede45ceb6f12ebe0dbeefe73edc3d9b255ece755705a861969de3667c2a30530178b302be419a8cb355879a496b2386de72bbb644c945c49b858fdb786b086a569f4b2eb075341c8206ee514895fcc6e3c2f08f5fae62bb70404d9b4bd5df1adaa8e67bb62b5dde31a1b0e4088cd3d341f3ee0edc2b9ad38e448a06a6b8362633370af93d994e2119b2619e6c22c4355c09ea352e6c716d5be136051e1975a4766be5c52b89a789362cee2899a1a041fe1bc9154067523b89557bb72f3a4cbb8fb980df206c10bcf1dc51036cc5650f2b295ac1db408c70f914278e0dbd3d9086826089522eb188fb0fababfa516c2cd2c814257ec220c810233d0cd80c97ea90b8fe615179f45cd06b7e7a807a0a87f2cf83d7a75d8bac06f821cfc3287f292070b609b44cd1d0244c2d7ebee1667247e0882f679427b0e7a440ddbf87d8c9426c132fb7688859313144607d721e55a66d0da78b949bc73214212b902e17e6516d730d38ede4cd81a47b54b2fa031a1a1ce37dd8ebe086ded577d88344eabfa1d1f810e923a850a56e7d21ecc54735af9ba01219a0cbce94f6e7769a6228182e9711d23afbde99972bbddb2782b136c5ea3c04aaec5776eddeca7ea4ecf2acd5ee88caa2689a593674f2ed98c5e290101dde63044478a6a88ec253c2db53351cc4a9b6bb3aa8a778cba8e05237932e5ae7ce6e2c626e6e1e9c6c0704f5c35eefee4f42d5f6c1d0c4db164f7e20a1e8b693babcc128ed1eb8cfb231a8074195a56618b2b86e4ae5a89116fb54713c9908caa32aceaaa6f62fdee1369680b5aeb070b3e8508e345c82f6380b74de0999eab21f7f760ec9ad649a00cd2c3a3c2e447d9a10584f410f0fd53435ce62b3fcc5f39c6466b074702e67481763f03215f685a190b9b2279f8b70292cc421175d7cc5a0147fef1aa351f3112cb5ab0aa4fe915d23cb0298d18cf94bbede4412af79f10331a60e4d8a13be471eff86910010c4313128444c3cbbfb2fa4c6532bb85059c02c05f0e5353ca7049218e686da6ef8a0ca6f241d237cc8982171dc115c1e334a229197a8528ca2dbf973601f661b3a5caa6e93a7ff90ce28ef0391491b6b5e858595ec4144cae79a9fc278571ed57f98daedca637ef32d91bff3e2359245eec62407adb943f41ff73de72aed3abb4ed7def4fc29790feccf1e598d3b6df549cf6df770c92375d0489ba7f414141b8900f6a122be2864eba8234a22364cd07c11c593c899d2320e05d92416aca7e5672138d75603b00362a67e8e5a1cc6a790fb7dda5e313846051c2422f6c33ea6394991c3e2dc250d6acf94b2bd8061d9c87eaae6e12fcc9537b9061e08a3f475c5e4e646691dc618b1347f3886c7c8799d4cc23f59cc66960a69b3b6e81780d9d4bd9891feef6bb81a9424d2e03aa3283db23c2bfa6d65ef879e289f06e445079b84f1d26d18b2e94e947053a6b7fb0f6a95e04acfdbaefb21310c68b82be807f0e9a606cdaa86f6a8d6a836999c50f306a248ea3ce3ae0a9955db367acfd2466828474e4d9d194c344c58d42f245c98feb8cbc3c257d58b74119082a8febef738dd3d25e2f2c7a1736d0806088c5b06c7ee089900d09d3606cf0aede41df968ec32833e4775b463062f4c5d4c9aa2dc8fdac95a60fa43c540bade5adf6f8646101384dd62626d102ad62615de8cabe35d00c0d2ffdbac4e1033ec848db191c22cdd296394d767120d4fa410019bc45235584a3cf2e217b3246ddba02594c64181eede59efd519c8c74b74a754f890e5c6bfb6139aaa82f8c42acb319ea07e2b41e15feea2a0566c1f21b0f45caaa346a50bb13bd72183c998071332cc3b3350e9df15dadfbaa385f38b66ad619bb5746a1937e2e0691de4ced8fa3110513812d0d0bfbfd19d1b79c4570a1770f506573c39f3405c8b0cc58dba00629f29831d98b51720b7dee8b83f47325f1867e2a03ee7353cdbfabc1af78a32be61ce9b925c5601a5add3c02d81be98adbdd6548c8892b06226a4edcc736d575a4ec47e1408cc3e8d69258c69c2d6bb7289f87cda3e57d92eb067b0b57573f20debdda6f51e8fcbc7535723d73fcd655f43a6ae2f655cc3c91a9d00acdd0802eb7ee321f47bcfc3b46e7fe4832e11f23d7e2daf8c319e3e2a2e44d0db0825b1a5d44b341d127181c344a22c3e9654d00bc3dfd65b453a8337c74bdea9d8a22aba4d41a79f3694bb8d213c98eb11af9d212d28de9547ec506addcf34657770ec7ca4fea1bb4728fc8627a935a3b6d8e4b09d78e74e9d53dc0d64a983a265d650a49a73a6f78f9bd8d61863c56c319e47379a0b59091c06b584e6e403632a96b3bef9e0ee123b65dc10133b401cc310773238e19e003395fc283669030e0793a956f753ec991f0b94b52d6bbad8bf270e2d27c8af528e94dd4a2c0b5508e1ad20846c37d1fa0854de21516fa83e5675b2ead415fac41a91949e9efb700e09dad64b22b2a6875a3c8522f00012b8d51d38a5088d18939bef0c4db80acea619e96a4b54a7d9ce39f4ef9a02e08123a55bff7ac9d8896c2f5d335185e3f2011e1f988cbb32a9da185f53ed8d5c1e2f6cf84341db1f9225ba73afa0db39578a0e6c1c91cb2dc97515672b069f61883a2892e7881689da012c120e492f1d7d5d767030f49b88f5b5079b8c97ec2d96fc44e624ef73266577d4046cd676fd03ee1c18f204f2e08d0697a9e3267d76ed5b9b656305bca4da8bffd8173a2f26921bc06a87e9d68826158d47d63856c9ce0ab44a2b3c89967cc42eea6dfd1ba7715263e60616f9a07679a34f9afed13b4f0b68547c204faeb78e951f49401217aeb556cfec574ff852d62a87271403e2aecf6e21fe37f881468013febc2f5bad3e6a1a9f1985a5113a3ea26f62457b72919bc56eff6bec04bb91fdfb2f10ad162b5bfaa0fbaba0400170c9fe8f6ceec4c43994cf3c43e3cf5c9ad9254360446d5e4ee4010db0debe6494846e536cec9d4b2fbed8cde075a4a3d8fa0f0279e7082aea0b31b348b020bcde974c2a03196d2da940f7f0f72f50600a620139d9d06f7112f485a8706d4f905f740b89796f39079248a8aa291e886ff0259a1b827d530235116ac1e5264fb282ea5f9ca3b8b68263c819d07940bb351ed12fb5bd2767c256ded16948f9d343e731e4280c29e3cf53beb3284338043ba0d6a9801b3b21eab18cc1ec9ea3a8595279650cd5a7cab844ca106590c837b3cd409d642e25fa12dd3095720089e57cf58bfd79d29e264f823fea9126e5b4c42ba68a02689bb5dca8693a3d5836a18e63d68ffef870f8ca856296c964937f6d5c1ff32c5b8c9b12f947f60b85332ffce7faa059f08d079960c730f615cab0302a982b42dc16d62da9e770bc8ed25aeb7374f61a03ab762b9720b5c417f760a1c92ba519b101430d0f9b1bb7f357f6409fa37fc7a7b9f45b3c51260ffa8c24462a1a09644f0cea7e4f5d5659e143a4f004cf64f0604a2065783e635c016c2dafdc9d677624b4dc35e7cfe1736f79eb4eed3b26e353788d329e645339667e1f86bfe35d2a99b3ea9e3042da33510b7500562033a0969a5cd1433387cafd8e3a43c7b0be19a57b6cc548d254dae13a0dfa7dbf0fa98a39474af378e07ac5305b2795dd1fb5cfcee435e0c5f614cde6742901e2604eb53bf8323083346cd26a42bebb6867c08ad649afa58c93ed0ca9a7bb945480abfd6d7e6895471bd0bb983867adec6a90669b7d091b83a016cccd49526ed4bc6313568d5a7ee4ee58c9cf5fd3900a3a0aea757482bac881690531ad75d21008ab0ec47bbff936a26bab53d226710ec9df70c2f9866464070bbf6977fb6e0fb80d6a3d330e2a58f6f2fa7a421033210198f5ae37de6b76b212b4364a1f3bd05a651dde32f1234daa92e7f82ca888f46b83efebeff0d7c383f9c5745c8231f346b8156cd33cf68c04238cbf5a96cd28e04720a7486ba2d430bf8a570ef359cd9e268185f5e1c3c8b9842aabb977d9a84c8afce0551547637b4092aab234bc3ec0c9a3644c68683fc4829be9ea05da5160e59a9bf9607df97d47e5b44f1b2126d1e487ec4b2eb1fa90bb4e5c82daaeaf1591f882f65d8948a7394528b2da3e23c102cbe52a51bcc99d3cd703a8ea3ca593d4ff90b5b9b30c373204ac19e234e8513054623f6807dc6609a45c399507390795b610e2ac6cf3068a7f79d3813e3d8cbb9cffacd03506478b77d7d19a052c2523f80ad5a22e7d7b35d53a48aa5665de7e2e54920df662402c20fb3a38b3b1a9964441ff0dba5f0110c9b4e1c5afa8af126e7c7a73175a25300449613a27d0b07efb11b500680134af32ac595f6909c5c2233a35132146fe6b5522fc5d456dc7d0025e7217e0f811ec0aa7700b90b63a2b69af3e05b63402770c026fda0d1c34691cb2b79386bb5a0f3e817c4aadc86fc92773c03dfa854265658305aade540a7f2de82a3e040738d78f140ba607d416d6c90ae2bbed8749a775760f773578b19a215c53246a3e81d08adc05787f44998bbe7597538c9b2cee3853e2cb97298a395a39f4103f16d69441871f957c6d6f0e5ea7c2941303d923f929d1fb02824507eb2dfa6dadec77a53aadae198d2a7a748d5bde030f3719898a6598ee50d58354c264d0bc15c9fe73a8a8f72150234668494c404d1dd4a2c3b59827991711c331141caf1d5d4508f95fbe238ef5bb97d749b3889d5d257f3e56f7a66f5b807f318dc41671b710e8714ed92f0c24c4cef30ec4c27577317995a3f3878ec9edd0429a1616ac9854a7f440934d89ea90b9c577147bd34ae7397b20de0151315cde26b46b3caadbecf1640d5bd06ac2cfe5cbe1179722350efd51ced66446da36db4238f3fe7b52ce21ee4f48f76368bc56f1c19d676f04245d478f592ab582425194a401b987a8ff270ddc9687689686b8d409e138360aa99744322ba430b12d82ce0614e6bc8ad9c4d29c84f5486eb92008b20f0c5060a5cfd35f94bd54992284a462e4770832c8298eefadc35f0b6640e9ac02c61331fe9bc750f12870d85cee46d8c173ae25226d3aab48076e5856e7ba2bf6310fd107c765ee4b14a198f662d71f63ef90672af92e242543af48993d8f2a7156dc41b53dd302af213cc300109ac3605c3b45f76e3cd2fa877ee170ab3c04ceafe1a78185efc2fa888a7f3a3ac76a45975a8559cb2d7e54f8ce98f251f0321dd517508483e08f7e1fe42d5c2f039f6679972394c6821edb9544d6823fbacf2656ddf7b523a5608dd8e8c50f136a5b360f6f8b6f1e08c5008e808c27bed005a3189b60c7a484dfc59737096c0f6327fc5a5a0031bde10ac2f7424841780345e04a1e64897d21b97d76d964e41e3d61224e834ba2b07e0d527d26549f0d434e37ed4c140319a7f987bb2b804b884ba6c2525a9a88f6399eed081b0f38fdaa91a617c0776aea2e9c5c94d46f3d21c2d80a2ab40ada202573552a1b0ad4908102f0e3d430c19bfac8a31a26d438506ea2733bd32b0ff6dc3daed598951f5afb4734d19b5f3d916ac10d652d91ac2e6b20dcc5a3b3669319f9fa0f76b7154edbc9f95289109a0855deeabf35267a51e55ebabd2f1311dadd1c3e8f44c0c2e307dea1badb2c7fd51a7c81392c7f8d9aed767baf43fa3ac68752f7b2e158c643d47a4f06e9d2fcdca94f955248a226c9ebd69a32b0da6b25d5cb3c9cce68471e0b0137b3f17924af855797595b302aeacf5b15459348a8721788f7a2d0b7079db851ecf2d7fbe0101e15a686ee79bad310ab77270c1c657d3f713f4b9f659fa021fea14b8fcecc47096424496f63eb157177131beed21ec02aacfa85d5f3a5df04f26e5a5f7a2724ad1bd5b329263a684b54dc799485a28ff7913c6f4317626c10e1037b975891625e791d4e0b6796c6147fb9135882f779c15f16a5e0fb5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
