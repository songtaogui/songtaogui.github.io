<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3428d9281f7809e7b58b0996c694f3b815939768ac97b7a358cb85e597700c28bb9b9219ca54f5fe2feb21ec871c80e0503b9c820c5a2224198e8ea7fb7df5b0a40b860ef79161afe6a28aabed4f719a902c38acfdbe2fac5ea9aca29ff4d5cbd3c887a349172e636cbc13f3bd239419521135b9c456d0af03369fffc170961babb9a109117aa5faed0e343bebe79ede15971a5db6ca787045f576b8feb999f059ea2a3354cbdf6d0ba8a175563bbbef5fa5bc538772d16db5b0571cd32e81982a61d6d442fc28804dc6439aab7297ea4e07c672d16b0beda6e85a12e53041f9158940f61eaf326ac8ebd4c715552b32ced12100d9ca6fccdf89bc7f64568d905bdb32f37b31b74f24e158ef51838eb9302c595f33514ed0b39431c95d6125f01cb0a08636cee6fc267b2a83459c36d4f299950300a5d598033b0d42d572fef6dd999eaf5414b83ab8b2b14f835eb1afe26ca3a4f623791d22eb304b36db2be74422b296f40989931a772f11c423cb68c6cf4bb662bc159d9538d2537f93eefaf21950a7ff4d1fdf2dd9f2ebdf1081e28d03dd52a46771c2adce42c0fae3b91ba49413a2d8af0b6ce573dd3803ff4127c0d9c6ec7d6d20fba52226f2d87bf4bacba3167c629cc937546dc36249f80824253b45e9c50a934e71ac7d85f10850c28809ec0a2ef4418bb2d628034dce83a29a1846e4ad9d788367ff1a52ad71bf8363b069033202c7c703109f403019f82303c324ea20207cc04d153594cf272c24b384b2a0d2d608225a087bce361798a5be27590150e158b5d4d221cbffdf77d982fce80412cda65896ce0fe0708b8c6aa57fb7a2ca2d13a3336627313375551790a3d8afbd55b73377dd24522cdf78a1957fc3205649a2750e2c0c62d91f05138c309308738d0bbc5b9d42a72742240f527daa2707ba02f85e09c10ba4a3c21a7e23dfd30283a33cf0085b6d5803624238d2f166397f0d3d82ff67104d1f45bc62ea9f91b0b3a4c8019c81d73eba8e3d0bce58ffdbfb91796ec44829649533def3bef4ec7d265321ad02edfdd8b485985bd849834d1984413da7a9539f308e1c74328edf581ad812a90570d969d77236426a4e57f1d233ee6c987f262b6ca66c7f1b098548b70728d9d5841c66344c5fde6b43667f4574961d67ab94b95262ab8097c25bf214d95830ff16bc80f44d63f19825e73bddac20703e95c0f18ed4e8b8f1f2777188c1fe55ee8079661deb5914deefccf4b94933c6e2f181ecb49e9044107ec5d46842f2ecbf8654a424bae8d3ac873f16558edd156b5d10be521f3ffd744e19e838f04ba6c79117acf1d2985036c5be299f9e8328dab1ed36caa258c4e343fc69adaf5092669d98eac7f8889ca3f90c9594f2c78173bb20958eef1453adf32b6097e9ec5dd565c5e20499e58c4326ca37fc3a827c5696f56e0e37eb7bbd90861a654d693ebb986c7995463832445f8541ffd18d5dac71a7168d33f44c97ac3a6f4e67e57c7d4b43c97385aa9849fc539825f3908087cddfd10df8435dadcd475b3af4047b07f63254b1d4ced17f578f4b314709007f7e2d90d86254a406dd97f07f5ef09d7300ecc9c210455f1fd834803b0556c99244dab81689ba5f281eff6e7f77383cf1447c30b9214f230aae1c791504b91f32e3eb89f94f16454d51b57403469f3a7a74b8b54419441fdcd18b876b8e52b927e9c012a1067929d7dc9686db3357abcc04b8ec9f3e6f8f051ce440b7090b05ca17f83f03435ee63adb970b70ea188f895838035eefd876df1122a00bb1e6a7d0e0efb4481214cffadd5ba69d067a6af733a0c5340c000a662e0b5b190925bf6d6375b2734b00158ecc7b9eb3f14eda9e843de6571cdc3a51a45e5d60a063e29fbb73f8e167e96d32ab0608a20c432aa289b010b7bba22c008aa8264c854441c780be530af5f7f57bdb876452ed90edf2f68a8b824c723b00df00b1312dd1c82b816615e33bd79752a2af0f89280d34c9e6ef73c8c472a095263bc0a83b3b76400102f71c446a6a62b34db63a0c819ea92d4113eb38b405db5143bd3b298502e836abfc77a391f116887d0f039fc76002c3192f583c03918522b501b1731c682794faf3a9609672514b45d5734177a314cf7527a59e2d113c49eaad78885e7339d2c925ca713fa73230be0049a905a0c23cabe220948f9e79833a0588e6ba3cd8678d9ba7086854225f34c36862cc784f3886c38d61650f9c92fcb76506b89fc3a1d6c455b215f132b63718880494487166e45a2a7b75ed154b05449b31e351526faf1339a5679704d012c1cb050a44784c668abcef2df646142951897c846f65f0e20f6ffbba1d4c01d85a78ff8370db53acce906d8af5a78da52203f389f14ae93b125818f42292c0dc182bc6a47704f3bd96d8839bc61f2276d61c1a847e1078984f8911523d7fb4211f1554934fcbd855900c58c2edec9661640dd27a6e51967a9822bb424c9a93e93c07cbaa7e91046be5f24381b1dbfb1d561a1733b3bf02cf05d74d303ebb093cad801133ef9bb6d79a285a00374165ed1dc5698615148c3ad268680b24b39b7fbdff3fd02c9bc4c68925380bbe977ebd669f65232e4af9040b0674dcc451126e0b9ab87832ff79425d305b98da37786d885b2ac717b74c3ce8489c30df1e51afd28e42df1f1763d06f682996df065bdfaca7a6041a714c99396d8685b1268f5c53bc0d5f486a4f41350c33bcf1674cef36cdc44e5ca4c73356327de7d608279a1b00e42903e18e97177f3364cae2d9acdd417f1fbf5d89d4291b619c5301985ca1b93df6ce858c16dc6bc2cc4f08eec19c205cbb4c2e36ec23a835b9ec24e72d38dd1e6a11e0c1104f1fc44e4ed937283c2a20d47d7e986c94f8d964df8acfadf8d6f06ce0c01d560d8f10f1adfd48845715825a991865d4ba8e464f982f01f76edacd56b58ca71654f785f794fe4d567f987cf1d16d753e6125a6fae8b15dcf287cc1d0ac385ca8ec271181a6441cdcb87c93cade6052de833824e45aee2399df8eab6f16d8c08a0688bf0bfa3d3a23eb213075f183f2dd00f918da7e72c4d85495514ae50338cb068b816ce63e6b7801f1cb5b292bae2e11e775d9ab621eabcd0d0fadd3ce9c7d2ec939eaeb96bf4516281d7e59accf794486f79c53d7fb22c6c18e565b84df5b5ab23a9b507094160856975f833c6e50210a309b5365a557961704210853fe7c8304d5dc57443cfe13b9c4a98439f0cab8e2459608f43b1944a9bfcaf8e684392c9cfea07eef53e0dcb7f867d313bd43a3fca9a43597d42791efed2ea509366a16b51cd9e7eaecfbb9462904a1870a9def202f0a0a6310ac4cf1c04ba95b3889f6076687f3f2ef78f3c8525c90bbc7b88dbc96a363b21bef911654ad56922fbd30262fabf580adfd9bb5f3be61a5a6a779a996b79070fab14a5e72925698edeccb68c447f60e5c615f9b87f32bd042ad3281f0bb4063bc2eb008a2144ccbabe5f027b8f9c39ba09e141df11c8525a40dbd0c4b21d09707e4145117c0b54dae6faf56a185cae834733505f0a0e24fa8fe05179b9c621a732d445a76120c1ce08c4df7ce299876538b80c9e77999f1c1d44d22554fe7b300912db3131a8e4dd041f8ba21a0fb45518d1e4f61fd46743b2410739c8a598260856aee7fe52200f505f2317ec2a30ff8820e4291c118c3c4a42b4b7d59b4fb9474d6173940929a85fba31edb88dc34019d35602299c531bd394db1e78f8653df5e71b8a539fae1384faf24e0ddc61cad6d70b1c5e5dbb2ac156fdc37e30bc129d1af3bd632fbdae072dcdeaf514dad226a71fc4e2da1d6d721943f97f0f43e75473dc07d78c580ffdd293b0fc1c7f4b0e24640a29ad8bd4efef414db1db895c033ad12d33ef0e7ae22b1685cc4dae900324127f40364ba72afc18429f351bf5db9ef498aa5889e4baeaf70cdaa64f545f61a4bb6185c1373196081635e60bd2ddf52ce31fa8fce0396fd694bf8eea54ec5ea5826d46113130bd9b47de9b19e388d544232e87ba8ee826e1464716b163986ad8ae30a61c228ebafbad382dc34212cb37f045b2bdcb6c79ec3b82748f3b01d08a964031552a777673d23dad419bef843b75081a41998fc19df1cc5ed269b492274848d361f726a284209a9f00c7d27df59df77ee8c1bf84399115b2a0dba0724b81f459b9eaa5ed5416faf273bed80cbc17f32fd91e596d4921610b7da27404a49a0e71685d9b0d6d7c4e185bfab5f565cc15441f3dc8712bc6bd67c8ad0855e30723352a914b3343e43ecec36ec57cdfb90083dafd2cda61b8a61a32d22bb9d4b1e771246bf7aabd0c2f7d1d0d9dfa598caac88946376ac045948aaf6116d4d33407194b7ebba0fffa3fdc0410487fa76b4991a03222360d569e603d069985bf196dc448094f3c18a64bca34e64f506b48248622e8f09abf4b8a3de9bca4233b200b2fb9cba5aaf670746374056a9186c93f5beb3b11390a779086170315cab3dde83e16e32d823196e74a8daf20720b166619950b5e2927035030df534c354df64d6db19b86dcbb4f06e0738ead8db6cd874574ff6f4d34b8b09fea7c35a8c6a31a517fd18baa174ffb0efd87a0e8c488580ceda53ff4df67cadfc10477b647ab3f9beff01eb7422df51623772e8f665736fa24cf8872a6ba59799e89e7a6062ab59e3c45bab41ab9b1f484d344495a446289cdcabd1f28b218cf6eb8d72e189e7eeb6fc7488f0cd2474efaefe516c7de33a624bac8f6a6b905e5e996ac06e9f277186154cb9a3963a19a6d6bb920436573a5e6abf10f3905375e0b6b99b210854cc1855d545c431ae5676a792d37427dc52eda9474cdd3e4209fba48287c998a888bbadb0453b1b89805f4811d2f2d6dc4a3040dc3516682a2efdce40e15c2df73b34ba9e7cc05463e0c05b38e984f0a1561538e1a515ff1dba25929c3387d483ca4c07d572076df7a5d30de226e9cd7a18a758a5967ee9102f046f34da7b3aad87800e37607941789db18668ddbe39a3b81b322a68912c546aa9fe8aff2455fca6d33a0782879e9e2cf9828bc51bc4edd6b15dc22eca4bb292c967d89fd27894e03c89b13a6afa8f9383c213d0c238bdcda88695d3e96582e73df0c63d9d1d88ec51965aa4e973d507a675dec01d99140ca6b1430500a00dcacc9fb1efe7af1ea55093d84d144577f6fbd40a1404d45e4e3b1890d609b23070f38cd832bfa583382c7df4efde3901f50d2ab8e48f38d2bdc2ec7dfe6b5b9e10910269cf8feb7086192fbc590eebe2554033419f71787ba3f77a12c07e4ffb328728fc4da6c14449223b6a6b6b1cb54645c74b249ab00b1bb645a798fb5d5094ffa653d938d8ba6d156d8938f509c622fa1cbe538cd106d07e245755fa2ee5f1135d592a3346e885e6ae8d71f81d7c2d275e0057b623cec4e82c9a5c5692d02709988427d14d4e248469a6d654b2964189f6ba65eb1b779bc9e260a9b62d07281d9ef6d2e91f648c68f00dd13158c786c5c41c1982d52ab38e3889c532e234080b4e38059deae225ace660081f95a3afab4047964491fff3456156ca4922ffe1283c629b3f827a268a9a8d0cf109ae038a2474e8310a80840678845eaa1bbbc4666012aeb056fd97226995361e1ad08bf5099ace2177b8086de44549be0418a3055fce5def03fe501c4fd9d21692cf7d3a52f705de1ebbe60814c9981265b11250068dc00e3d28378917a8a89e293285239793b72f0f700a10325c029e361ca784e42f7cc432660f36dceeb733b722a4a9a1a185ae459c170919e4ad9efa037bec90cef8924ff3555efac1a4cd70a13f60daf6a52ded44fde110271133960932cfc5c7de54a4408437abea8ba6fa8ed8f7ed60c1dba5efcc0590be6434aec4cba7534cd45c121c0a2fe9b8a3bd5e6a3514a0474994c87f0d93aa4422ef3694ae0e7deee4a75d74ccc4c15b9daed09a110a5d12c7d85ef5f3a75bce1a6d5825465670fdf16befd73777c326bbfeb2b87874e213928c8c9651227dffde92577ecec09262e7748603334bbd942a65b18a95ceee67a6df3dd556897551db943db5cdebb8c35efc1f34b29fa3edcce3664d2074bb038bedf0867a35943990600fb697c5a9711ed1c151f93ce1f036bf65d98d398d5e91768842bda4218fd2e2fdbc4f8ea23f2023e14254f9a8632b6af84602e744c691be30ceeec516d05432663ae463e5b013299e5c60fd7c9ec6da7f15c6efeab83a1bec43e07c8131cef4c607f2044c27c1dbdae43c8c07a04b84cbf89c1c11dc7035abebf1e2ff6a6f42848c762d0c8a862841eae481bce1a69898bc200d4e93c9ce4cee0e9c0d2dbcdf0b5f42a65dbe97c8a1d0d661b1ab7e84a37822cd9a3a92ebc215f553fdb0cf4e8f752e70ef4f8b5868cd37763b85ad6c60534a98cb74881267d065145958f21924bf9fb1f32519a4bc328f3779f8eaa74db0ad8e98928f9c05e3e3b0e9292de3e1afd72a9042580b9a830be2a9ca4349a0fdfb1c9b8769e98c97797c168cedf025f6ec05c0318715054d92b2fdb20968e9f89f715c57494903f4170bf00afa61baaae3d66f38069202bd309d6cb57fe2e982600590ecc4ae408997d4dd2a07dd857725dbdd15535b5bfe0618080e94f6e9c0a28bc2f8c0a911e0bd2a767e5a3e8588d76aba2dc8a0eede360eb2cbf971ba93dfcb2b357659ccaa48e1334bb47c875dfcb03250976b8ea3aea708f6d5c88070649ec3310500707d7470582b9158c8d0577d7f5132869c87d0373a452dbad0b78699a15b63fdd8749f47f1e219efa4ed244373340c4cc3c1669a4bced4d500afc99e61c1898ca1b8a487f7dda37bbbceea4235bb1b2f7d3a847291bd4a31ad9df7a34a5621a50f6bd6cd6416e08a99dfbec5f711968a8b490d8224a37d5076a2432fb1a8c866acb585bcbc30d237559c8a656cb425b1bfa127547fc08803be2839ede00fec14cb2985feec7f5a1f9f5446b76ddfcc044708a50aaea4e27b2baf785a5196ff3b8c3039fa3964f622c07d7aa2dbe808744e151ad68116cd9c93db0d86a7be68b44ab6581766999e9c3172f5ea2dbf5e4c5f76bd87c05ff599e0d6519e1621e6021d03c95c6f33ce7f04e51f1935c30005204cd1cd9d1ccca875e47c41cad709b673e18126f604fadd44fc37c03d6fea091f677d867c974ab0613b093b622441938897adde1cd1f49b04567a7c13c9f418caa5aced2b4ce0822d4de9c07ff0454ebeb63e2254dcc0c9e7463a2ff6074e81ee162e718d03fa6583e05d7dcb52d9d7e7d3a6dfc94c489e85b8d155d4a7dec9a1b0dfa2448f7071d37d4eeb7c755f165006c4d0ff3fdeec5119645ca719ebdf9fccb083f0df0a9649cd7453a1a5d1158cb26a7a5974780ec45c9f2df7a62e747ae7c5723cf8da92433da03c361140cd4a13305527d8067afd92b0dd7064cffdd19b476c5380b330e990802e67a5073cdce4a9e5068ea368100a116a73b6693265f0b0a03151f75a25607b3119e96b3e86f2356891c1864f2be9379257eba5185b58eefa390e94fb74aeb336013be038d746c9da176ac3dd61294c21a4ec22fdfdfb24317a64e4747897d7ac3686bc43f48df91d08f602a009ce9d3c6cde2439eb566e69c7bbe9c39ad400ce5281e113e1655d85af7c8450f25dabd646d1afea2e2c842bfc68b3df53a9e9cd42326721184cb7b856580bc1c9f49cd28b279bfb649f20374eb6a13ddb7d799a97a3717522607f9f28090d4c314fa910cf16628580a24868908f1084f680187a45ef04867d02834f5130f5ccc678f86de56ee0b8da906e9faae4a5ae785f2748637ead18c824aecc016b5d80d7d0bf859b575304c2de0dcc3d0bd17f31b32b46d560fcac901b441f698e16422d58e8519ebeeb37b1d3e2e20dda4be7a6f80142fc3c2c119bd9e862991e814132ab65beaf02f12ab97494f413fa97144f0f0895a20f800fe80acf3e9e925087a2f2ef6418d0e28042c5a8824ff39d9d70420837ad3cf8850588af2016d4e06b37f95a6b6b4a0ffb6e7ca3ac538022e5208dd2a4f23158f611c5b36579d28dbab4fd7d0c43982d810590589aa46108ec64fc8f9089fab1f560c5d2071640fad9ebe9bc8f74d69667ab40151b4feaed08d64cf7d7e6696b74c16269b8a6d6c6e351e92da4a3ec52814f06963f0a340289753f0b1697c3201ece3de4fad80331282fd50ce331120dd29c528333b79fb97375763b504749647ce590747fbbedb150192dbc6329260a0ac387e83136b078ae4f1613ecc564a047357b92a00e10bdbcf658b862a87e90a4bafea7502b98d7e56e812dae1254711ef64a46a065fda85e6ae9d60d9842aeed27efc1e79b8ddf828f89f405db7b0c1efabfa0d57f46e8b1ca0abbba3a7edf545b66bdca26fc74f6384ca19ba8f560e7747b7b1192e85a3f9ea7256838dc75319b3dd4bb0d446784e8e86844e709b0bda0af2f8760abbece6b689964eccd192d61ca1439f7f4901996a1ba2ed9277c611c5434963a28aeedd3d7edffd3d183dc8129fcdbbeb5f9b55d273d096a7a11e606c2c7859b56ef7bf971247a94ec9085b05e1a2dd4a6c5a19a7348584b8cb7bad1ade17d98239905a0432bda3c8e366c1761443ff0ace541afff9a173d1416fe60bea37edfb7b464d26170dbb9b78ef274f69d5ba80b3b7db12166808e1f1eb6ed62554702c47a687260caea68ef51eaf405a4dfb099b4bb411b109d53e2fbac455d04ffa41a8ca4b7d8f14828664ee19e588ef19ea826f4e36e2f853f6637e1bbe2a603438d38c0f6397020652a9ce69ef38981cdeb4ba8c219d1d70da44e2e73f27372d94941d3f1b8186122df3c089937d95a4e3ea5ac6c3d0d5631af957a504e40fe6eb3d7388767e6999f2210387c15f34766af5bb9f317a41a2f4abe5cdbf6caaa3ca8e4ce3dfa7f165490c3b6ab9e2d776f6d66086fdb61b508aecefe02522c9fae8702a88fc1d1e1018326040fdba85d708037835c645f79792866132b9c1b16f0a10fd833ca260abff7bb5d95ecc0a3fceb0627a9845541d02562edb85f518639e2e220ceb0383f7e64211f2ec356b2f52a403d9cb024ee2186a5677a956875c0477635bab98f8dc4bd46fc7b9477dc26241f904fc3e7f2a43348091aa3be5d28b05e468738763d11eb330b41286e088fd034fee389b72e8568a7964c13535f048c6ceca3a85afe636c12ad018ce65ec1ae45c23367a99a236db47fefd016decb032953c9fb445577af756aaef0378855c7a42fbc0c068f7d3829c2f178287901173c4fab6e3ff03b04d2bf71c89f907e376619260dfb414df95b39805f7b598c0531972b901b5f2130628f303fb58d8e92e20f32e4ba45ad86c1b4f420b3815477e5224b632e0f346190dea43ebbaf780aa6be52b84f87dff63ef5e9a56490ef6fe9c6d524efdce2925d5bd7ac6fe63b69b7d19c97a138cc963cea75933150d4f36a8f6e1dae94b70d80f0f2c910ddac511ba081f554e607ff6012a53727026d725dd7dba3b07a52031c0bd0630b53f10859f68fa5ad6f849837c44912257bcab8f115a750e5e6300beb0ca7fd7cc50f8dfe2e2a0c14d102fa64f440df70692f01c469ebb40234443532635e3c3328130813fdce148ca6dcc512b475476b940741333b55291486c01f5595a802f1b3566af834063d86eb020c3f48c5cd19c02d4adaba2ae1da97031e69e3b9b56e5497caab600fb5e23199452164cbae99021b2090f4f592303b15b42e5bc6c33f471951e783abc3fb4c628d62ea14be4afcc30fcea7d4ca33cb7e2564eb6d9bb09e069430aed13331ea4d9777d0b251921df5e7913c3f834b6dae69e0f0f6d33f4959ad0fe8a7d519e73c14297ee6dfad4b39a41ef3886439a0ee0250ff3091a44898d1126e792f6d7502c2f7e431f51649e99211e0dd92f771535684d0f5ad1e4c0984e9a77d01b25a33da6fd103bd3b084bf463306854d0070ef3388509e0784db4308424075c21fda6b829086b3e97efb8c491bee6f6aacfd34c8b262f946182f36e42e0a44f5cc7de6d013aec2e3f89facefbde4635d8bdcc19f8013460097b979041dc3e577b496fc3ceb9ed4944387c78d1db45d6c7e075998e46b95a70b55d98b4057cfb8f4957c13f32ab57869d81c2c821e16dda0cd1abdff6ca2429e1db96d75708f3d51c002199a66f66e46406cc61836e3eaa6ae90f6ef44b32626728fb7cd7661a0432d29cc3e4dd25fd885e4808781294aecc73b6d157b64d86b4fb4daa5974e18aa61dfc937344c35e2ed65d740365b1cfe393a7a609a191c7913371aefb4c3b4e621fa4b1a806f5573e8aa372823d8bd36ffa02580e38ee879a082badd118caa76fdd3017605cdaf9540633f3e34c07b03e76158092bbff297e92b3aa5c0ce1ce25a974f2e7d42610648b694bf00d5e997d37867f5e7974ddc9b454279e87012ecfb3ac4e349383bf78087eeef35496bead5c61c84beff5eaff7061cfefc8dbf1b36fb17e0d7052996bcce576552be36e610e7c3a7cf5d0bb1f001e468514759ffdb2591d350d44427677eb608b1c7d13cd23a8c032e22cd99356052983576146f2ccc1f86fe9ee403a23632c3564246ef8335c7b03d578f2aae38a615cd8b45db2eb9edc6824a1ceefe2b694cd1065c017fae58da2d68f9beec120574b4e5d88cf8d71586f9226393deb4271ea6c0ff51ff4c2dbbeec38abe09d3e730f825ab9a56ac590c56c1985fb3a6c73e1d1239e21003f3d5cd120f2aaf49346b82955894a1d366777716d8fdcdf3c54215c5848afffc290467ae6abe956905a76966033f85a527526c4f0c53b7fcb74837a4c2fa92d938904c5f5f9b0adddbcb3fc0a1386e3bcdc0b73658596b3c28364e4cb50e8d4a8fd6856e7eca59bae62a5dd3770b9ba6938d9d20cea7350604f5ae261947e98f61203f4494a8757425ad6da12ad6bfe3667040b7c865d3818d871349cd176e71d40fc08db3cd6a0a5e3ef36456594b66c75bfc10bdbacca46b270798cd0cd7ba8ce4df8fbc1bd1508aefd0fb6ae3ad7819423d7787dfcbde9fdfa706a2c71d41f3eb118d996544c074d6836efbb41479bea99095955af99dc2d83379de097205ece234199e3a9f82c336ea7e1621bfe000571713ac4b2f921c7b89eaf706df16d917cdd00b08cfce1ca97a6ad2014f8854f62253ee494b7cfdf4ad0e659e4cdc65f795bd224cc7a657207d79693dfe3a614ac606d4baf60443e1c756ce14144f8cd26cfce37e098e2a859313b687e4b7c6919a487d584f301aa38ac5f72a8ebf6760885dd29c2a8e0331aaf30a9e34a3baf8595933bf60c5ab6d953c4a4da1b2318202a80edf7beaa42a2c6fbd1321c3f11c41e53e4cbcad06ca5bc4d2b6f217032c7f34d49024bac7bcfe0f1cdc1ece940769153a2ee9d46f7e86070c714cbcb0e8824529abac080c5b54c249d4bd53584c322c25094bb427a43fc2d30ae0cfa29cf1adae4ea07baa087c85f9d25bf990b99830ba096a9bcfec31150c5d30cec5c7470155b35e984babc2594bf3dc45dac42c32ecee852425914f1a473d5cf67060297231b3befb9b99fb2d4febe3b06f3d49e6f4da9d03efc8e536ee05793aef63aa4191da041819862ec6720f9e02c963da3c3b1adb7027d16527bf259ebe1dc9ea528561f4167787d6d7cc56ea6eeafeecfa42f2aa60bf06c06ba1f2741b05f8bcc034a1389eb6cd8a1f7d3d56b5de47581418416e6c38568bdc86762feaaf8434adab798709cf2ef304a3bcad60b6dcdfe76f19222cd8641bc13dd0e9ce80f81c540df54e72ea7340eab8642a1f3424e530e4f42c162d7837e40b353d74dde132432adbe2e3e618662965e1234b0e3018171a42a63313bede1e7481f05e9d19b005bd213d73014326bbfd0b5813e5d0a76760e178753a132e86d7b0cf46f47e897e0a291d893d5b912bb22ceee5e118ba30dac3a6b88b10d053c41dc3402a228444da06c9e5ebd2cb371a2c1be91bb5c8257e411c32a164b9c6dc013399efa77a05121b120d6d178e7e461811947f9d21c10a69930d06c6fe83fccbb86f1c06a6df7126073ac1132f5d6ad5a43d50f4f3aa847ae8687c3e17c1762eb33303755a4f1079852d0243b527286bb648c273f85d9a2d59e55bff122756e8e6ea75b721c29990e4f9f755e623263e7341f3cadb99503a9414f8c8b941b30082b105d3e10900c3000074cc08c46d6742d69cde5b167dcf9ef6be3254524bbf42df2a259469ab2936f811dfea9534e9cb94b76e9ee81f2737dd316636da3cea0b88b8e7eb99acfa23e0aeadc47859634406fa292016384b431fcc5bf0505bb6e8d9a48d34b0a732689daa969666de66832403ffdc52dbc09260c6ec6a69c325a9e7854d75491c7c833e404b92ccbf7e01cfc843df7383cf7e4a831405bc516fc62b9219d088843c061806ad4adb6885ec21d5f8c0f1c782dd94a03a746eeeccd988dc2eb1f822294969f81270b5ddbe941bcfceeae16db6fefdf0dfacfc2b6bba56aa280136c9a7bbbf24d0082723e17553fee9af066ab86300fee8cdfa00973641752c3ed1713a3bdf1aaa05f3b9fb625b99da147dac191a55858026c77df8ce796916314fa76dd5146a11a00b2e318b8684e2c313ff9fbaaf4582c336400e253074ccb613077e428a11c43aa812afd45a702645fb7239853e4adb733eb30cc2406f6394fb231c328892d8ea909e90352d04af2e987931e9c4089a47ffbcee17148d76611c11ba806e3486c99cc4fc749d27ca61ba2ac25d7d411df16efdf92dc165c9ee35b8f0a52aea7bd8550ae4c3b1a6fd022ae4cb06bb3f42174aeb21717b70cdada1691a10cc2b693c434eb1cdd1b17cfcb256b671a373dba882a9988364038955566a74ffdf7f70d27e9d924553db2ed4a26610c1efa24f1b4772259be04073eec12aacd1d065e68ae1cab92681e7611136c03fb6937f39fc42342e710cfdd7dfeb0ee411072cda0a27ad30dad5c16601c8b7a38d7ba56bd87b3df644608c8bf9646e22d9f4ae23a9154a12067dd85ef852a895ca076239be8f58a989e08a06623e27f433dd8f76784163b3ad8c0cd5469da751aea83558bd97d58c1228174e81641d793829496097e176c2ba749ecc7b4dd85610d8e44511abd49ad79ed3e0b9c7e012efafa8bc20c41001d0c90d9721ad88293f40fa37df3c7010b17aed6a8cd0f5ef4959b764b0ccc8501af94f62bd05aa7461b41754f4b90fce343bd24fa8a7b56fe590251ecb1a50e2b61582a93bc914ca5f62a71ceaae0ab81f68b8d3efbe3038bec71ee04412a34180e5ed361153710936c4e263f75620d846c261e7698c5c0b9f4371399bab052781e68354db48acaccd5ae9a5351872d60a21da0a99800d361b31331ea1c9e7a064f09c316a9e79de76d2d512ff32704f7da9ea41fec6d620fd557f018d70c8eef85bf092310bfef95066c3f96a9f1e2d0385c0bc64ee7b86bc0eb444d651f1321fb6ad2e7221c89dbda5d91b4d76040c5e4a6cb2c74da8be3ae8ec121fb6fd19e4890ff2b4f1ed69f5f2447a9113b4294076f5335bae3babd87afa5e58192d370b1c80da5f952814b53ba23bb8979833b734e333163a6c1cfd6327deb0c483f69b7513a761363d20f58d9e1ce4ff74c50df070a9570a948e24ea0ad84ec05e07a1758eba43d13f74c4d5de14b880737d8f1c0bdc710f4cd7aa08dfee34e363cabf835de471aacb2e9fe427f94af94b51b5f08ba5ade543a933b635deceedca06d1d26fe06a4e9482e6846656d1b282785eb14d1d2a25f3dbb99ce07cd591d2be2fcd1d6ed76e0fc626162640a2e942adc25a5efeab304caf9083b4df2d173e376a3046c6e299d0b6530796e937daf7b7f876e31424c3c8f4d70bbbd243b94eb4f7a48b67ffdf59ba9a334e12718d28021607f8298e1047fea63e0fb99349129bb5e138224edf25ff35b67de651ddc5fc0672dc0bcdb0ca39c44bfd98829d038b9f68838f858c07e7c14aeb4a38f0c82c8ed906ec069e8950eda68648a62576ce301bb0d01b1972ac484199a7de54355dd20b90aa6fbe44eaee036578b0ee85bd789d1592a82f4b58779fd96762b7db507a04839d579767140f071e0d185e7113b1b243f88bf2893f555bf176b5bc0501494612a2f3f8cbd3e834924b1dbbda1509462d2ac8f17873d5498ab41a2dee248f97f77f207dd45a4388d56559fabf68b169e2fb5e908f9575cc20b17f8380bea034baa082045b910b252c214c326ba0d25c26299528af31ea448cbf80b0162c85b0543a5b73aa416ee88a5641ef3d23881ba0361560c853decbbf03ecbaad3d274e1ca7f0b4f5af39cf5e781e0b78ed7bf8ca3a27a20beffc6f3dda3e8dd4ff068dd569b1e9bd5091a9de1f56e7802d563af60c40f640ac0a9663bfea617f4e86dd65ea4010fa5b1dd10cb76f259a214da8009076625e5c7c8eda938ead7f3d5069ed882d7e4e0a4bbe214c69aab1bad7002d6d122271379b0f82f106baa0d7adb06893c5adcc94b6d75dd256bf6c592fff15093aa283b3c1d6fcd86ed723aa9463ccebed24c1f0cc2657c155974f7475ee70c2481a0ac5b7f54f584576fa93e771eadb4d53fcdfcd99b261ea1ca527837b52f70f4ecdbbf3636047df2f48c1a6042edc6cc5913ee1cfc08efd46b9341c099618de4d662392d071ae61db656f28ffc1cd3fe0d9485226429662dda73293a62966d363b9ecc986710ebe52f084a3a8573d117eae542389fe2c44f92878e43aaa1820ed4940d106751c6e6ac0fe16f3444e3e94e25349dda7f5a986394ebe6f05fb534008b1f374ca159f75b232cee90e30cccd7c620c5b3af947c0bf23f943cd2f7cd30025f7417076e058d2b28d4492e431b7c5ecb52d63ca20d2413802ee39d129270468f9bab97bf32560f579a458126f90a878d95b6b57e0a40a9efeec47157595abb804028d923f42cf9fdb30157d51596f68db6304c2ae8f50ccc9cdc89159581cdda786c0dabc31d9a117993545d77151e08283ae2b8624a70330bb0c9569b95ba63d77ee9f2fac08b6730c34dca07488adc3ddc6084f5e165c88746bfb55bc608aa190502947513a865465a21416190b56d27dde7bb626ff7fc703c3a1ed7a55fb0e7c78a0582fbb6cf125e73a4f22045e6ad02195c797a6f70ee12ca9f3eb03dac0e99f5754e75cff0064efaf790a999ef375acbf1367a35be7817ce6ec5124e9e85e36973e9c52225e8209a62fa4ed8d84a37920962307ed3c4f56092c41f57b1425ca52759eb8ff4b86c3541f7db1579e2d72201420ea8836dde61320f00ed24195cbe191f386ecfdc9da8835e091d35055acf018a00af5faf7f0d0ee3a117d5904fdf49f92c3b30603f2e5f70e8edcd60e2b56d8c2260efcf194106bc7eaad8015177af792b8643d6bac49bd5eec3b654088a54af3cc0a82abc1fe6ce50f5275a485774c631b9bec27ea979e05948bf9142b90a62937f2d9e058153c419529926678df4902d2b0c6eda220be623b0b6efede3c8cc892e78dd3f624b02117ddf16754715da9b264dd6ace4fb9074f1bb56db441ecd75da613c5f43a54012c105ab18e771fa06b2b2c4837da14d590704c80588603476122297870a45c31c9cdeaef5b88cf57246b02cecaf0c1135b95e372b107318ce0d5e72312fe4b68291e25ce6521aa41e5673e11b61d23940aa221ff5ef567704f7495da47ae126b78a979989df495b365011f5f6b6bfe4d9b8a493c1b8a7bb0790856ff8cb016026366e550fc33705e27979e032cf395478dfd956f4bccaee8c7792a81a86b5056b8a1ba7f3e3dd2713d55018df931a72d2bb629051e56f57630bbd8349e767498e8371202903918d334f05ba60823b73a38b4562380ab72454c62daec5bb126b2e124a741aad5d9ba125e736c84b8d4692ba54dbc322d8ca58db23960cc093389daf4f202cb4817934861973c72bac33444783fb03192989c3e434471a9766ad02946f3835aea4742812a7b71b189d2b892ad0bb8d271957e97a8749f7470f1f210bbce84384d775044d17a185a5aa84ad6505420ffd4dd317c7c0eb0229b26524998c874594538943cc403df68edb173522aaaabdb4b14bee64f36052fdd3af67781d8d2ba3c0e41ac0416d9ec5fe544dd9eaf1baf6e1be64fb0e40997b35334a352ed9624022c82eaa27095bfdf0e03b2fd48be82bda64cc376fc27700f33db0e67e3a70e35c7ee1ca8287d9128a8167313c02c0094db29e1aebd0178f554c37d903abb279fc7cf22cb3cdfac1dc7f1d50ae3beb1409bb035357b65306cacb70cff48ac7c6a727bf95b0f5efe4e4a2eb4b82703df6ad110338aadd9c627511b827926ab37e12a52803a1cd5ec496148e01b1aad123382bcce9737debaa110b5774d3f2cce43e03ccdfab4860addf2a4eb48c2f2dfce427c3121d59a6492f6030d745a1f40b677bad7aac1baffe0437a418b4539865f814f43a28fccd3779ea194cfea226758f5841496865264d47985a6d2e293a2d9f96491e5c6875c3785b783febb19883ef953a0cae75f72878d9b2e31b59087084dbc2126f1684692b2c58f953c7c57dc01daebab10d50ff136df0da66bac426df59dd86edc11ca37b1ca8e4b31493ea5eab17c35823234930ad08ea27b210e195f357966cf933fae5fc65168527e16373048491e60645b19bfc41215fc572c4c3d2d53ce316e29072dd191299ed6aca4f83a50ffb52e547f7d7186cc559d48626f4570a198e9e03b76624a5488764d371a8a01cf921b9dbb54fd2d5cb6636b599b22e642623e2438ad9bdf92785ac5da2f5fce20ada54661a4b1bc0436755a776761e9436a80343b73fe82274e10fab9e12f551df87c3cc2c1e7b1335d2d241d51238e40f3459fc441affad3e6f15fce14daca8b99361cef31cb726fc4b1bb9af04ca9d331ec1dcd3fab48beeba7a1dd9542f9f93e8ac79ef6fd8e45f28b716af780e8a69b6348fa1a43f3a7268dd7c2639bc52526dc148ca0aa4c29835a3770f25a6546a3c0dc576a8420ed7aad3689d947c616c256d223ff4381053fc86fa3016a9e50ebee4ce2d9db7425c908a4f16ae77b264aa9d95cac361c7d43cc20d2527985efdeb1b6f59901a146a789e62c7368536672a1124d6214342cdb5931c9ef19d4f16ce2a8b6350c8383112c61bd8b9ea543e464265d4c5310fd5c41dbb801e2cc1f90d50d0403e6c8a5aff87a8dc1dd61ce2456300f32ff502f393ad5cfc2760f07069e40a5181a2eb4042ae6ac6a982b2e62749c1a1790b1af799bc3f7b55f82a49e83dda6e678ac5cc03b137f98ab83aea3d8c2265c9e75c7754350b7ed3e308ee299bfb9a711326c942803985ebc20c326f97d6d2339f0e87c7aff80bbf5e55b49aa872b6bd051f0e1bdb0582c127eff4593641a1d9be21751c3b2cefca4b058b9556c9c5cebf4fab3ecd629cc098df33dd438af706895ee7cd35dcfeba0d93333dff25ddcdcafd2a9a3862a6f06a36772cacb6afba6e4b55bca835bc51f5c70c96bb4b075e118b770f9446f56c69540329e617d58a415de422c5ba16113d4a3f464ee372db4163698d7af6d80ed220201d0792dfb4a6a865e9ae20b34c299126903ea9382898448fca466e84f604c74b69d99e38a8d1816519aff6bcdf6800d4fc473c1cb3639756512e36f71151f94a5a8df5683e98328b2206e88e560c398cc83cffdef583e204092aaba727f79b9adb888876a43428c75d34b56c90273e721c6d22a50c32f261bf274b3077f09e8fbcaf7efd1d307fa7f2e154fd36fa2e72611f183bd7f60a5d7efe910826f704560b068f1fa57e169e0d00dcb50ed57fdfdb75cafe3bdc4c11be1145ddf0fcfad45112a6bb1da9b262f5c5b97a4657062b89e818f3efdacc451daec70919f7178a51c9d1c8a2f52804fb2e09766659b11d285bdce1cd90a93cabcc98654fe8ea38e69a0db0a547e8ab85ef75965a7bfbc672a888cd514a9403de52db616ec265619e720ec797a11a62950e8b672c60a6c528ad70b39194b2e70eb66e7dfa92745d0d198016d1fba11e6c566537fde22b24a92c6b8ba9a0631d7c0a8c4bb91f15b786c8806ff09d639cd97670d8c0f75bce9da596763ad2abc9285a3a1038b7f5b367674b079ee9a2cb4250589e70d7368c842be14fdfcee2a7ec840f2a1bff699209ea76829a14aac66ce4582d778316cd05be0f603692c7780bae2e59b8e219b07a71eefc3bc8512549f20ac58d345837131777ba92e33d6e5b6430a18b0117b43df1cc4e11ec79b97427d2888aba751049583a4af8291c58570066f25bc0be009a42e079c09d3f9f65378c8c54338ea6dcae309c532a424760dd7db5fb5e4bbdb5c938e6d310f64672efb83b7d145085a049cd1a52ff40f6ee8b880d6283c5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
