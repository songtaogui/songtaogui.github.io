<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"494692089249d6416cd96aecfa594e41f8cd7973c50987398c5bf09cf961fa799062cd28afb66504968167ebb514ba0f8c1cb40a45fd33b95b44040572fb004d5dc2f9b798b2ca47ed297b3d81e0615dccd81e40e07dda4077259741a7c240b47d22e39317df31413aa2e9d5c29eafef5621c03cba35d2b507e961b5f6323451e36f08ce1e001064c06cd4065f9a3d7d2d6a8b463b5e7d7c1db92c75ad7f907589d0af1de286e4b9264a1c7f7e54ca6eb26e15448ff8f47bf18383a62c203970d02f42b307cb45f635aacdac2366ae0fb51431f76bad9fb363b435c78c87196c39a001b03b16569e9936fb7a4d491639ba99d4c33c5285f345b520becda4671a30e511c859bbaaa73fa38e87cddbaa2cdd336a868b6aebf429e3fe5766f6ea79c402e290e99473a35b4b4ca42fb3c33ff5eb284862ba89c0625c9418afd846a00728f07d5794f05bd3b55c5801fe30485db9a82bae716c19e0af2f5341eb2b43f22976218eedab9119f726b86e1060f2a815075ef596b14c6b7fb864fb138667f93234595707fbcee46922c4230c7753c800874ca8f51e03288f72d1b16bde10908e8f8fa2fa1875017120fc9ad322cfbce0342aa78cf3aab6c0a4c2a34e097d8520569db209c6316e4d6f7a317ec0abab5acc448b851b41798573996066f8d3db66e453572a5c7eef0062decb62b4357d4c762f8d0edaca319b31696017ef49de328747f0a0fc3a375800d559e954c14fdda5359b7c49f3bd7aab3fc35b6eb4bb169d39bdf15a7883feea53f51e46abce5b4e4237b790a31132264e5267c4dfc4ff1d861e9e978f4bf9a2134b42d12fa4cc3d68029fa6f4edb58480f7b1f361c9a4c77793cfd0815aadc523ab353406b8f6c10ce597a7f370ee4f48c93092ac5563c7a8c6914d2747dbef6d18c23ba251a4d9f6c0f4f4bf8757fef725e84594170f6ec9e8b6d6fb4fa0c6a39bdf9798dbbf09328cf88fad03600aa7a9f1eabbd73ecb78dbfcfcfb9584ce8f1c054142adbd16aa8f57f8c09d2adfefe3a2f87a73cac6191079b1f7c33362360e8309cdf6ceacdf62892be00208b486c95a38cf3477cbb015d7685ef4e25230c260f964237a5ab74bf534694fa7d72d6fe440f9d0662f538d20c732fd6f1fcbc1cc0b1361c19779de27ff4ece2a5fe151ee6abcf630f7bd2b59d6806ce3fb00b2bfe9ec055fe7df7f346ffc5910daf379f6ee9b138b4c8e01442c0e49873b68d46a992312b0dc6dccb042ea63a8b44407ae02c7eda73db7eb6d6ea36167c39f50fb2ae1fa437a86e5d9fa4d0cb4a0f81ea6052e9544b7e41e44f939cb56a43ccddd4fdd6fb80cdee1941858bfb2ea658fd732dd6ddeceb87d96371a20f67f5a427b9a97ad6aae0c3762f75d5ab7e584d9f121660b716d191d07a54fb5096f146ec5d2a1b116216d123679a370f1cab5b306e591da42a33c4857d28d6c47468ddf637fe7160f7cc18dba580d1275f082ff103a23f021b50982580883732275639060329e5b2bb35579e20cc81d1d59d48ab264e38710de291c8fc3e5065537d60b3ea1792a980b658f51e935cf9c260685879dbd28ddc2b42a5cc34df9caf7ba5a79fa2c52423625fdc8a42a8caac0cb7d0d6b6bfb8cd3c9e7e7deaed0fe0000d39e851da849d3f586be88dad1e8bd5420f943c263d93dac7916cd8dbf9ddf8213b109eee30ed64185e78bc9134d2befd9cf1521812d1abf742570bc04858ab92b249dbcfdaeb3c5d2380d5515cc0d1fed3748bbf9c0c056c3ab3aab06dad63ea31f7322899913122a2e4140a28971729e7d6f5fd82f56e712688feaa8ceea9844608cc95d4ff662593946adfdd8159071e76412f832bdbb7fef4abe30ebdd0736f5114f5960018dba4093ddbc15e27bc04aa85895fbba958871d5357bdd3ea045e1f9c6b7289045d10fe7a6ad96f9af5ef1a160a75dd327d396abbc830cfc0e89ef14cbaf7bb923d4467dd302d1561b7d940cfd06af86ac04d7183acd2853437d4f5d45974aa804365bf4ac1be5d578c6d6a8690b0489a3f2a954d584074bc6082964bc643242ee0dd62ed446f69f8e9e0ee58df084e203e7c12feca525f9f928c5cab4d7302b45bc116069a79bcf08a4b59dbd04f1ffd41af999b882f884a50d7537f1f253de9cdc7229c34deb2d194da2ec99c3f17f608fbaab139c68454371027d0f4794183809e7ebbc55f4be496af5477adbe51938b27485c98455c90d49176337d245c9308f68cef6df06e16476627fd44b2cbba83ea914a4db6885ffa5b32dc25638bacd6573b3d059129023579d15cb8af4802ca0c896a2c19ad52953a3b72481a398c2233572445af8f89f9a3774ef5bb308110a0ed61fc101cb4b55fa13fb6eeb20debe7395817c728dc2845d4c32173a292c03b775c658e15e71370a9a500b8ba4fa9b50e460947033cb14cea93690256be3f29a2b7b1a98620ff3bbb7fdf8fd74b1d5da85e9cac09fd85ec52b05f3da4d12d81d600b9bda760cb4e38ce57a963654dfceaeb4e5013d8c369d22b5918974560f339bf17c5ac98ca9c1a2fdd82997184bf0c938451a97cb1aa66fb88b0d6c32c4268a331584d64c0c73dd2f7df0090e3b2344d0265a7bb9521b5d494c8227acb6a2f2b4ffb5f3390c722a132e48ce9664c2f5f29084488f2d5d55b15590d271f1cfec30c5d6ce504e4feedfb06fa8d30ad93ecffc2f764ed5e7f68e71d76e61d240fc558ffd81672470e70aae7bebdf11987c892a72139cc18de73f897387d3608a19f42bdf53d2a7b1677468c1cfcdeed022274c8de4792cd2b00a30d31a81af990fb7de21f218ceb5bcffd737666232b761d126e2a3f504fadc3a7fea196b480b62943091c2de6fa3a871d280ba461f9b189bed77bce6a1ecb1e7602b58313504f63a0106e65f5b8560aaf449e7b0e2fe124a012dd5256e407d6956c1412c16a1b6d8e4031f955e8d16959897e628eb3da3432de4ac65c0639775e3baef840418cf416753a8bf7f25619d9d2905e838301b4f9a2a8f61479033bf45a75541852df95acb061d33f1b8576fb1b742f880c57fcd14550eecf0004f96d1866ab13ce571049b2dcb289515f13edbdd4c1d46d4ad6c2213126246c44f14bed0d8230fffde3dd2bdbd14500a525432f7492ab0a9fe0409e228e862e12e5af7d22e059858b43290405ce6440600d1cc631e2ee0b0bd9130417cc027591b8bd6bb9bc2a3459d4e34dbd8c6df434af1cea3add25d03bede66332fb01692156575c6f5d44381983fd25c4d6a803f34d17d4e4c0c9c063803a3ae28191239989702b0f064ceda9563a6fcfa8f2bc656c86e8072fbc1a25245ebe0dcd58e1136ef1631cddacbc529aded963ae2046946d78ad17db4c304ac0c06b1fe11220777bf93b1ff53b06881e5907ef4aabda16ad865480c571b01b07567ab5ec62b044673b613b975451214c9b4e4048a559975f34eef92f5f96f336c1db3b7004456d72008de2574e25759e750ddc8ed8275f31ed765160985b669f3fd9e07a89e36bd35db72d495a3f8adb45fb44fa0a723cf05ccea9d70cd789856a1a823676734c53e7585916ce24e3356275f08c7cee44819d21a63905682a707ea3b9946037b82f7fccde6d2bf713b85f885e88e532099e4acf94472f8facf257cdd056a4998a6647fb1c25c0052cd75c040bd075603f40a8f95d9163213af4fabd6f5e6378286c70d8dce6adc2d3a7b680802b062331e4a8139ce635f896338a4a3df2c08bb328c5558921cc888dfbf1a54cf99cba8ede61f98221e0068e2af6e5a3a5a384621844ec752d31ba1804ae08b40e71b221bc8aeab8d06fefbb5239979270a386616edd95b5c3a4e41f968d7a35c015131a22eda26fb6ab012232d12742354fe952e441cfdf070e5930b5e47dad500b9bd3f68a9cd26013c5b043c096dab8781245ea444056e47622018ad0ccaec020e74912f890ebc4532055d800a620d826ef68b2585302f9e1acf9320c5b6fc902d2ee8ff98d8d5830f9640923f9a0e776b86c5b4e52bd74c28bc60f24f23cdef5f5bdfb2e851f8352f28901cfda57972f0600dcc490bce362388da46fe2c6262fc68bb18a4339d4909ca09e27d22e261bdac5203f9059172f013c57cc2c92d8ba3a470d0f75330aba847ad48d1a077080c80c339454fd438a8353a0cfcb834161710f1ff62e09f09ce191881421d41f0a0945a546dfcbc42a5bbc191001290152ee76ca6028cf086413557f5fc113afb5779f12263e23e4949a6f8000cbaab0f655b560028367c56e96a6c192152c5bdebeb6365f68796d52d886fc5ff739998c07da04fcc6f943540b84d1e094b6d4d06a31242964de2947ea9a1112165d98781dfe8a6d1919c3f1ab5eab70387f4307feca885923e3396beb0059d238f3a3da2a27efbcd07136a94a40be64867eaf870d9197958aea3ab9071a068f1c757461f815a8ea4378aff4cc165bd3ee9675c6d4c4ecf150d6100cd24aa13151d383b5070ef741fe73cd668260abeb8b7da9de839dcb18fd20d2bd9a79d0d5f7206ab0a626762fe8a871c8703a3eff2afeece9131ac9d9a58efdb5127ac3df4e917fa7a1eba111072c3b97d6d6d517a68637fb77fde68853ad87aca7c1fb51c5a585103d43aba7e53e139bc36bbc518d3137344c7c9f93bb3e2e38c95749eec4f5183ccf59e18d6d67c8c57eff411624db0b970871d57eb447d9de59181e77deb1c65155298a90474d459ec53047bd5eccb3261fa2f965c8b0f99a42fa26be80a813247c875223dc3767a008d63829e0a8f1e51234c4cb5a7663f510def6ffe3bba2ad3be6da8a76abff0c934320ea3177e12087d944a5c278087393abcffdd627e928185d984b892b31bacf2e5af99200a9c3cac649653d5ced3225876fe932ccdf4218acd0a1f4f309740b31ccba914f4e13acd4104f8e84cb35c6b8f6ab44f2e29655f8ae8e8d80e7a026f231620c3b4cda130d632121f64a6371343dd03bdedf1d2ebe930c4abdb6274501c6ee3e5fde8bf89ea8f08b2984ee80e60ef00aab6700b3a224fe492a3264ca93a4fe82b65390c6a35ef2dd45c2e915b5c46762caabed598a67e9afc2c8b0068cc59dca7389d1662afae2fb29f31df7c6bef76fb84e06d9ff31015f5d2ed0426009c39d1394b82430d45c3b483e572c3eeee73a01c2884df3b6dc2d9d859795312b8c279c3c799146255116440440ce076b41a9f668cd1ab5efd6a6fe9cce429a45ea4dfa53c60c4c34722856f6520aecb503a4f287ce47ea8400075c16775763248148b5a52427526c8ab4a5194cf01ab3f98844a7ffe24f8aaae430f71cf698e530f8e817ff37c2de928bdf9eace7cab8f6e24c8813fe5c87937f8b26c2dbade2b1213f4e7bacc27bce66e1a16159aafa216894cc2ede8423a75f60239825ae5d9b5b230b486a7522cf23b6656aa954a004e237f7b5a18f8a9d67c6efc2406fe6b43378cb5983b7fe997d8759dc4726f34db36475763c0f846efd64c527859e860b14749afb75cfb8667f8ea8fb3999890d0cef095d57b85aab82ac8faa93bd1e193a5bbb476573566e16b3520914076c308b9c45216b798317396667dd87bcb7c57f888f1e5e71436a3bc19cb9fa60f7c4420813f964a8a30f1f0cf505fe6c4aac16c50e959b618145b5e5dcbdb906b003a04fa440e7ab91901bea04d570675552649e76b51db9ad07a46a5b9f14fbedbe2209215f69125669dfe7a7a4632573d9707903f41f320cf36922fd7799154f2a13687793327dd6da8442dc15c0d675e752be80a30d7ddab98142948f295956e943208af6fde43d7e354d51ffe83ca903890bc8aff34cb9849f381fbaddbff01fa022b0add6592ee0cca20e17679d9b9bc6f43d80d484766eb1b634dd4f7fd13bc20e249867e1e6a3f1b78059907b0ae2664ae418d0c85e082c9d4120908fd8a6caac09859fa729292f1ef8d93fdc009b9e88a5474a2eec0d3be4e9704b83528e27063a146ef08257e1e891af2af0eacb4f7adb080874b291674612fdb7f6cdee415625d180d9912f9f14199f294c78a0ea09683d7dffe41e793fc3c0f69211261050988b75689e56d447e2e4ef6200a9344fcfa8ce382964c5646bca867947a4bd6d2bd5447f823aed957e968995c2f7f709d1746625a4c460dd8c79e171108ab09da0fe68cef85fbadf534e7bd6420ad068a4b6edfefca4090b78eb885ec047be78bdb2e78c9480267b7b5b42cb4da4ae8d4c1ebca64bf5a611cdc1db7d651705415d2888581a61d15886fcd8ab40af3d3b9f7dfca459591aada2a1aaf8f81db6a35cfa9901e5e2aa0e44a906fe3fcbd680017e6cf05ea0d051b3c53f32c2429108674d5c17e390fc05a8c1be68f73921012fa5220beaaea7cb69a036d83c278b6b0450f82b98b1518b04c297d6125e679b1ff5619cf362da58f677f04437038aa7dda062a0be6295e9b4cc2beae905e8667c14fb4595e63fdfae525302073cff5de45a0078fafb0d842f10133ee2f1c44ce6ef1e2bfad5da4de30e51d24ae75453270489abf77b6d48b2cecadf0d1e4a54415f5838b2ec75b15d6d358772d1f7bb6aa4b374aa0a418780ba3b5f1513b8c4ab5c96a8c6d13beb797c69ece038ca27cbac477ef2421c20258cc6d6bc95e96518bc36d2ce5c32767098b95dea1d68f9aa79460c95b058bb8ac65d3e5388050b634feb407a96f59e4ca63460b4387044a9cef0a376cd5ec666b4b244d9f3d849c971cf90e52cc2278be510dd7bfa6fdf830b7f1166f27a2c9aa462ad246ac2d31e8681be5aa752983f06904f4653bda5cf0d9cb9f67b1b69f4f9c975a4e39062e5424067e0832a1aec6b30898b4bbd117cd09106c13a728eb1a1f2f3683df501bd865fa35c7b795d4bf6820d269b6b996af8f357c79b7c4f00ef72ab1337da2869389406ee6ea7a6dbd2b7fe2ee75d7cfac861e22572a796238ab4f9e8e3fe718ca59b001323cd7006e5b77a7797bab2bc7ad05e7e8d3c359ea2776bb3243b839f567af8f74255ae8a44ed86854b63e8aa25dc299f317f062acdcfd302934f2df3e0c06917c03f0192ddb014037002eef989af8139f58912f870277756ec9cf09d9cbbd3a012bc864cd075258834ab3e04da780d491b92668e9be850fdb439959d35815a5bfe36d92bd69f0a1c082a733ffaa22e2fffe78deb5215c50a596d1623604aa171e8953d50cd5a5ad3077b9fd0181d527ae6b957504498d7cf59a7131e968e18f11976e5d925454ae504004be9c5a174b6532e88ac024fc4d34ce60f930287cc25a4b8994229dac4c7951131a9179d0137753695d73f176e4a4c62980aecaa81c1506dc5eefd019a9bfe5861714b5cddb00c6d120518e82dd26e374c7052e34a093934d7dcbbc8522febdf405ef260a41ab917850b4f125fea87a90eca7d3af83f512e5b47f30ecd968916ead59dae01c4ddc65344978c1ca16d7871c9503e7fd49829ad1813694a2a85d5f9b9fb7b67409e9c6d13dbcd35ead9b627681108f5b2e6e282d76ea7e95c91a76059fb955579110b883736650db06a353dfc0022243b9e8152e03aad138279d391c0d0c1855ddcb1975013de6e13af23c910fa16a5a4948a16cf3056f64f30594177472e8ba16456e32304d98b1b9599702f1af9bfa9fff27650b4aa31ae7615e363b7d3a64bdbae84464145d481a7e1d57b8b11734bedc3854c1683308729158953e1d229d923f2d7b94613301968cc39d1f30d779edf8b18b59780d8db853f11b70ad3c4b81ad37280066f8a4112c5da89e1fca6ef1e39efc1ae236745bb5f26b8f574e2b3f2c1ff644bc98b736b50bf752dc3ad60e54e602dd63c8c27b9a205434575b9fe0f1374c805b6d5f3749e643534aecc7342ec323d15a0e5b901515042e78eb53049be20a37d25c0fda7d883c9c7a46bc726ab93aa9b92856f4aa7b80a52b6fff030d27a436d288ab5217531dff12c3b0d928d36270c8b5982b41538cd3ffb12a8748b989e806e45521a0506f56edaa50200290c5a79f5164ec3d25508fc764f75e2d418f741f893ca5678c1cd968cdd74b0e1e479edccac586839733a99a99f643dc51d460f70840d12e96776e17db1d0e3f9abbd23bdcf3c31266441ab8a462f4eba7da0d5bdf08c1fe4f83af1351b617d6210c4eccf168ddecc26d8a36978733b03b9d390213c6105cad46d5d6a3e26b468f56fc841ca04eb1d37ce3a26aeb4d362bbf75b0fc10da151ae22dc590e5863bb027e20453ae6bfe4c0f5a155f4a05e99a9b07b85c40a513e0052ab8b9c5b17809c1ebf6ce0e612641290dd503126e6ba5793fc9814a13a6709d5af63e49bd0a290b21fed77a360bb7c47680512a70e4d1061c4b54e423c8691d91bba9e560e1c0418da57a3f649f1e1c48ee24d9b30597136fe6d8743c10fd929f459094276b8e337ea0c19d60b7142a1954a133d23c1ea15e455b32371d857a5784beda355e7aec974ea3ee307615f21bb08a60b0bc78527645332a1db4b4038e2f033f63e67c1f36e5e0debe3a5a19c769e87c41a27e0362f26afd897037e40078dda04214439983b34e6299179648125af2996557e2e92b0214ac91576f7b3dd979ab7ad002d71894b4181fe9adf78f8f2fe4166cb77938d217add700c67ce7694ad5edd42c3f0e5cc0da8952a6aca04254b473add46ab7b33eac2063dba4aa96b71fbbd54c109531fde0e6cafb1296e0eabe069cd0b16c3e13f86b3a89fd0f50ba022c946eec7ae16f413cdbe781737c9c5588c5cb263d4c8c6b669a4e95ed002f130691c4cbdfaec5f6e597f636d7374b737577fe23a855b3a79c3796d418925136ae7d0eff1404e9e42b343c3149966e92a2c2a16392a397cb7e79549b5d96be45e7ee2615559e329fb1d59fb9353b1f4a47fe6d6a7b699cdaa4b24276c89221b71841d78e9f94469c3eeb113906ef2ace2b9af25e99b382b792ca0850ad7577a0d589e589d81fc3479c9dd52f0a4854b0a490bde2dfe4cc77e6c5072016f69ab550183fefb6b37c00ca75c3986ade552b4447ab0e8f6979839307b10d59b63f339111660eb8a98dee04730771f7e8cceba39d24e86ad60d213b754d8497729ed89e9778f1e09cb8610ab61d5b7e222c9dd3201ee82872b29c2d40a1d686dcd7d30620e131faabf16030ff720c6b7efc68d5756cf3ac2b39354fc08677031de0e49c0a180ef988f10e26d5fb5dee63d18d80255f79b0fd3f8dccbec058cd556d5080e55b7f39e6b46da4c52d99b20e4402de26f8ba2ed41960923edda1acbd5e4e45ee5178bdb35101ca2c40c9566e34eb7bf47f8643d0a3ee71aae826c279d3fec103fc4718bcef92f3b13d7b66b6c073d34b7255a64202948d4c15b9f89732ed1270f6db0df3859c5d3edb76d14a5f7a64514c2c40ac1cf449bd72875a94d4897de010755b898966d70acf3bccc1a62d4223bd53c98783bcfbd95e46ec8d39d77357e46c960bc713399a73825a3e0dcf9fe4ec9e66ef78988f495a2643693d8cc8ddcb8ffd32a3ce368c97be15af08c6a48cd0e7676251fc0c4c6456fceba4dd10aa8cb32517cb555c33ca6a787eee50456c76dfee9487e6f22b78041f0fa08346d89e239e3f5d7db6d1e60b91b57829add3fe4da4fac40a036587ccfe42d6c7b5010937dc510360ad09b0df8d82526c9579aa9b9e13ef6c9db65fd04a4b83c3bb313058b1f0146b2f826b6b065b70819900ee2464d103956dfc2829daecc19e11d97967c29aa250b9710b1d43647781aed47dfcd1bc97d49ccf01c74a523aadc78d9d72fcf8b389154125924e2794eaf23269d19149063b6f6744bcb346afcd73e609a86caa764de91b5c960b7aad96c59bcd33836413580cfe394795f6e8532ff37aa63ad9b7f0cc12a86042c8c7013c124cc095e533e8f0cdb6c2bbc258942450dfb6e09ee9ccf52efd3f7999e644341f190716c492cffd5eb7142fc2e77bcca2d6a65e2df4068070e797ce8be8956e7c1eb92a910943b63a51e1683626977e88ecd27b39c1ed9a5bc06847a09448fbd604aaf23cf6e9c6d099783bdbca1b6eacb8e7231247f7b3cff9af418c8b03d78bfb966753b069ca01090821928e7360368a6ab5c4722a55bf3a5a6d2ecc2b8a3c5cdfb288bd6374bea310ab85071117e9953b824cd74af82ed4cecd4b15c1e801cba15636edeff5c9169e0749254534567a3c1e94deaa1cc85fbde59cb5165088e96d898ed92c53da3f8cfd07e616ba42f431de634386227c757d4d66af2f5f9d61ab7732865c2928840dddf6f096d63708782816f6ceafb6774f3f7d1ff4e4cb0517cd71dbc3d67ed557f8a9044b3d3c0b35fdaf2c0c39191b54e282e92b1b7671c70aba78db0484616d148c23c7fb61475d5975ea0070b8dd1cbd09506b46065dc42a82da252d8ba46b8daa3e404d260a0a7fb07f997518761a4320404b7381c5dc02bdb7cf760d93f6e76b0a995bef2b4ec02bdf3cd0f91e58ce39ab14e45b4aad25d0eaf3d1d069da98292be3c1ad918d2cf5e3c7e52a527275e5781df6ef8403cbcc8e3e5dfb416cca2a9dfa0f89dab12ce9a3850b1c58fd9ce12337cc7405eb0d5e38f6b9e9b4cce9a7f945aa172a7b45ea2e78c2b5bfa0a01001583e9030e9f5bf1ecebc855f289511dfc6b782dcae0be137ca01126fc5a3b3a46f25878c9f1ca5e3933ac75239d835d7c2751293273e0e2acc9efb1a29b21c1f2250b97dd67a496b72a7e6c364435ac661dd79aaae7ac8aaa914d2d590caa12ec2a151ae199e92272416378313c530401088da88d53cbf7a6f8b892c8f8a96ca7d91569a7608c8121bf21797a1c0e3590fd459f3ac8bf88047a366d62109cb15b6cbe5cdcaf88cd5892671564019d6f39f943327693c351ffb2ba77f7d15822754fbe655cd41ed5d67f4ffda133d28710fe0f31c601183bed6996a7691271d80144a51c77c7b49d87b9db1329a5a37b2240a9b8bf8ab11038c9ee334df3708a9836dc886cc88b42d7d2df14988e7c3feb8f0792674e6d25e43489b39e2ed85a918b82fce397f0411ca3fa168d4c9ee2ac42c489f03560b833df15781edf5107b74d4c64435607f1dc243f29e91e504df6d595ce6d686f66b57af35b6b3165e779876b2a320793c8dd4256bac46b7327a31630e30aa426360ade6a4a8240e3ef080d0ead43f16fb1c7f90fce975007e9efabe2d6e24a26e42b7a04d23002fa4b8b72fbf7341250156fc363951080e6ecacef4059828ff362f3633d34d40e9f0323f387fd30c9fd889ac0bc10e211b4ba23c66dbf4f82b91a469b045c8c6a36bca58ee91a80ecd33e2218e486a1ded7b1c59e54d5517f14e2c9968fb593ef0f56416d7b433d92a154ffa74c018a88791105eb7d00602b98500285ccae7154e95f314eb024a3d872051d0c45ab6e46d416f8f3def7ad7dbbdc101effbd0119ac9cd5b6817513a0ebeafce7842b7bf739d651d80a1635a34f258fd54925ea10d918fb349f3710fd345391365f208e8d773ea9940927dcce7f5f1dc052d9bb34bfebe0dea2f991d263c4a03d266806851444c747396f1dde20f698a37b0bf034f97d13e8676eb122b2e898f4addb805b3345824b455455199e408089327ce1e41fc3f2035278bfab497fc4836ae66c50c5bc8ffab417db32857c7c09a1fee2900f28e4dbc2bbecd2e04dd110cc808a9987e371895793774b1dd7cc9a41e78e8badadb0ae6312defad9522a6a013e6904a470852c7940ee4653b63f17c7f2be636b09649e9d5a8d4c8cfc4523a2f99a95e989d7245e2a28960d462f30690b63261427e08d947bd92da08281d4845217e130cc27fb174ff215f900aba9c37b59c7d1f2b6c1401b334ed836df09a2ea11a1931b4116551e71bb4a95a87bdadfc435d292dd4090d62bd3c087274dcb6e5af45ccd600591803c909dcb83e0371b7126f56669a63ea69a376f9cc7bc591fd592ac0d1baa95ed7e19bb72f3a682f2486761801156e75ed9f31f0d6fe0dbc435e35b7b626bc89ca91603cdaa95ccfa68ee5a9b0c9518ba5ef098431bf721a3ab562f524e00869145f72262523236902793942b05a4a3a95a22426ad0c44dd866551d57bdc9c3f9e5db541ed63a92a55674afea140be4566f6de788bed0b02edef315a91a5edd8b894b81bde9c09e5a1b9ee3ca5d570e8ffeb58ea0e09a17c98ff0c3e1e8a4e6e50fe356ea8e2ef7eb692acf11fbecee120c10956e6de5bffe9557ecb9932999f9e554de50f51960aa48a51c6790d5feadd7be447bdfe76edff3ba32f4738eb4850a7e528447b67d410165fa19907a4b860a804bd3fb206701ae2b0b7624cabe085889ff02cee99869fbb9cd667a09dc70f53cf1f4f6ef89bf7564c1786026baf406a1a39637d25d4be5a97872e7fd91760872723ce4e1474a692084c3d90035627bf203eb98d412bf39c063793077d480d93549ab1cbede11ed8382debf23743ccb9af98f2da3dc333007605d08c23249f0a8483f5005bf4d586004357032e781a8c654f72af28d9334c60571e2e88f7dab31fbc8c3887f4d44ae68110657dd14224cca225df1c105ded5507bdf9e8e538f49fd9cf285c668019769e2a1e2e64d7b89edf3bd954f4bb246c082cf4919a05e0f798bce7e90bca23392fd2aab3fab27f00a49ed986d31885bec06ecaf373eefedf5d2c9e9f309f33547e34a5471a7f78c09bf9003f7a96d604b58ee5546c829fcd4f6f7cc5ae5fb04610c3e7b062df9fe07d3743f8541100595d29bbc29e516abd4d0d5bd9f39730d1019dddb0395a9710932426c1e8537fb4018411692be397f02836e659bbd828d60173985474c06ee4d5b7f712a398d0b612b79a0a5675c368a8ab12b59cddcbbbec79ca15dce64b93007f9d3d1e5b9863776d2facdba8e35f4768350669d6c16e392ae973e183a69248c2d94e7a8883355db213b467c72c7c99af5ea21e4e92fb2f625e72ec4dbb0fd1d727112f860985be468f5e5e7521a4067c4869851ddce431f5b5a2da6baee844bba2925bede54c37926adda0529f90e0cfc9c6ec28107cc674634064cd6cc8b2a2193ac0076fcc8ec5634861722cf93a28e01d23e4efef442df9c879c4fd853b553b366644c5157ac90ef4ab04620c7f48368957a9e58d8dc9687953b88562756776e1656c395afe1b2d32595c6ace2662f57d04ca9def5faa4d5c44819ff356e3c9d3aadac1d5835b7d94460fc94a171fba10e950fcc3e9be56302923e7ea3463f764a707168f5ad387c5fcd82890fb0f5cc9bb99122609bac609e60c94844ab5eeb90498f45e08ab0e7dd4899176833bdb4397c5203f5e86c540ccfd7305ce61752831e7b42652a343ba331b7e613eabbda1072a55f87a4a348690a36d4a2bae7e752483a5e1165c318b323506f1cd6072abc37e36afad6ecaa89c41805b0a22dbc2538a87457b0cd254a18a84a54c03d89d815069d213d23e6359ac9fbd9bb2db5d87fc35163e083e0c7d99fb92ec958ed0a70b106890768803846bddcf3099e59475e90c2d8f0963582557cbf6c5548fa0ca68aae491d17dc32e9f361952fd802ee48b6b696909c901b508ec6db99f609bda8d2eb99fd2c3af8478d33291136761acc551fa25d2b892fd1839fdf04895ad4872f7eeab241259acdcd021561af7b5557cdcae0684ce39e5c0b6840ac6a71dc1d23e2b80d47f36b7a2d85d19cd660c19d11e50688e64f99371a49651518feb166403ee41c0878919f8f0da7b847fa6f7fe9c27fd2f37f341f414ab8b24805836196982b0e34de1764a080fe8b73facadd0d1ed681f753d9db46b3d24f6bf83f752e992f552cda07f83abd198b9f9bb91c2b9634c32ba2e16fd90212129adbf88a9a30036325dd071f25495b597756c504126c442214da6b0abc4c48601e0df90ac08c04d2788db82b702b48e8c3e8805441d1176bcd50bc44303ec50c1c4bfa5d442d6d532b9a0b45acbbc282aea91d1841f2061bae02c41fc84bc30ce5d683f45e8d12e55bfef2c77b91745f0b2d19c030fc5a137c85a0e99322c32ca515d8ef7d0a892d88c454b17bcbf66f9147dcd0224bb2455a490c0b39c9c751ec1fbe7bd26de9367847161b97a6076e7b526df44fcf752a99b4a60d63872c29cf160b4000faac4a5349126f60386a3fea842fd299b42bb94a46a8536e644103f1b1e0f424204e129c8391a60caddb5b76486e0fe37ad416d4623304be90c2dc6793156f8381232d7942fde09f9cc3c8438439b6cc35babb7ff9dfeb91ba708b629ac1c9adf500c9d72af5f485bc6fdca3608052e21f0a7f04669e4eb3a6301c4f24bfb920fc157efe0b45757bf5f67cad963d6b710b3d439adc7a081fb96e7436f119c7177ec1862dc1453f3e4aa9c9790cc3a9764c6256fb61d7097db8c95e394fef3ac346ca7708b0a052b17d790e627234f2c19e038e58a5340b8d8d469afbed1df5db00f1d11089e375866517bb23e8b4dfadb5ab032fe8d31c240d511c1b49768320a144a32a386773fdea42135b3756e83ee69e619cc9e73cdd0819a8befbc93d339f9277cce476ecee85d74460e5767f0413a8bdc9b530a2e56dbe9a4c41953a26f58efd73de4098f14d744339bcae9f16968c2564d961527a90417e5c94b3d18812e6cdc564b1a040c983a8ffbfe16aeb34b510865999cf3fd22004b4fce85ca42b160c8cfca14194599c2fca616f63124a77dfc6617f9d79a10103099541d4a1098109adcaff935b1e7bb52a03b9d71c105822ccdc8cf4265860eb208d06986526547eeeb49db646cb80ac2672032bbadddb6b6fd4348447740e9d8811e1b6a8b6d9e1a50b19c72074bc9c9d2c0385cfeae340b7114a97700ae1ab9e8b5a85f82b846860efad421b3855399b8190eb6537b7fdab910887bb93292e0b778d224e92e167b52fa33cd5020814ebad68b3fd92eb805f8d50dd975a3c3ec61dd0711c3bb9a2582e02baadd974d4f57fab318783f0816dfcb5a9cfe939e3687813747adb26bb2bc385089770fa3aaaa8e4c38e2916012276fc8f54a1b402a7c98a05d02220a5d3e4b4baef7917ac2afe948946f8a4f3728d5a2fc835b910e7d2a1adcbefbf399dc5b3eccf77b1d14189183df6bb5d1f9281e351e6093a12098e6ef67b739d21acd8763c31fc5ab88d10aa84c49988876122e150e45a1ebc4e7b49ae0299a2cbcebb9bdbe924d830a660b5cf1d27f63ffb78d9a655130534aff9b9033ab12a0dd9ee3253fe14a5916c48b8b02219bc1f8f3632987f294805b09d11c3490cb240502e3b420a964d54993d5bc7f6fddfe16c77ef85c959f9e1a9ff19bd64c2665afaaeb045858dae61650745fddff069517fa702633cd3a1bcc32adcca28da086c3c8d4ac88c339bb3088e266d354f7b60481911ad76c46e7aec264caaabc0b1058470edb4ca5601ca42f802d7acacbdaa578088806efc18a9f2fb18490e98d909ad5d3059077c6729f18278730094a387341ed76585cc738756df458957a039aa86958fefcae51252e46d0db7ccfae42027577674f906c7ea6a9e28317916636c325f8d9318ce62b2ba1abb0343cc3cbc2cc2646451d339c5d60c25ac0fc52e6582ebe1b3d72fdca3980d59bb492eda74fe8015cb837e08030bc2069b6e8aa08da6f1b073bd6fdb0b606d0142110a007ef9daeb4c5b396d816c7c683fa7b80394616664d6b7f179ae046936ce87795280e62d0cad81f1dd8e5d5637fd28840333fd6c219b7309e93828ecf4750b9783fb44d3244bf77209b0feaa569bfeca6128c5b8be7e3c00835ce72c239d6244fc4c19c94b7210929d02e0fae322659e15f38d814a5a166b484a91e9c988185c27dd37f38a8549864faeb18a10faed98897240e806ff7c719c7ee3d3d4c7063c18010fd4d9b55387a2453d8aca050faa38e940d28513c3a8a5b2f468bcdac2c0a75dd945322aa407c4e7adfa4d00ee8b8bdf82cdac270147eb54e9eeb038556f926c1aa903a24b925fc4c8e71e80f8a560f517d81723fbe92254ae7c1a27b44a36c5c0532f484b946707abfc8b0d5b947bcd6b2fafa2f2516a3384be6b4486ca907772831ec9abe8afb4e7589139fbd095565a2170f804e479c57c66f2a62bb43f52c1016d9b527aeeccb4f3fee9fc042ebdb3166e463efadf1ea979fbdb497d823abd28fa69a09d06577a09984d555b1b48187805ebf5d7c58c4888f4b0cdcfb68970d5ce5bc72dd64496c1a756c1e6ae488e8d36c09ad23f9d8ed221878252e337e041f7d4f26cec115b066280b0a45d0f0f7f23810ee08cf6a4c291c37e5671756992a45e50dcff6b32301eef69d2742f6dd8e6375282661c36083b77c98f9f0d544dd176345880ce70e393b944e96fd9bfb086c2eb904743558707fa776c79f22806908eda1edf44afbd502a1830758f5386d80c88dc7fa556227d4030002400e768d0e547b81c12a3df065f6387414960430ef5b3188ee2cf04b3a1abc9072281d66ce32b4cac35bd88d503eb05fea2803d6edd520ed81c27ae2e4e278a51418545e7845ee87330ab8bc149f9d34b3a39e905c8d6a3b7afcce745b4b16581ac2b75854d10b303fba4fdea7375c179957364172530221c5ec8ed4a5449886b8618e0faedec0aac3d027f3217875813f84f3dd07cbec0c133712f1d2cb341158b4c6c7ef106fee139d69d4d87fe0cc1a0e47d446ac37e353a8d2d74f0511562ff815756470f2a32fd46fea210a4b0b22285d3193a611d130934e6df5736c46d4e2f3731c1ccaf7d6331c2387350aac0482c5974c6a2004eaf17829794436ec3002cbd1e8d44d2a95082e6c22d960c6e749de8a526000421d3b9391df2a511197214da52b000cef8fc85ffbc34899ee8bf4b5273a9b52c51daacd62819d19762eefe6ae9e67cfee6536a12e9b1e6938a59a0a75aa5e86aabe2a64a8a7538720c4da208963c07f2296381103ee5c005bdba2bf4b7cd33e14efdb57dbeaa8d86f1a5e1b10172eab93b4a37170c169efefe9607f4895e0fe7c8b2be6dc686a542551465d13a8ef008a2fd3b33fae6e853eed7cac225d23480d91aa59873a49bce363a404f1136210f64d64d87a5ea1786b4ce7f3267d758f88cce7ffe3018e41f4b7f9545e300da60fea293bd199ee92133a16131ae6e90523cfa872a4c8f833d8947a2e3869dc051248e5db84b8f4a90bae29859c9f500a4076ccd264d535a80178669de871da6e9a5d3b4f0b02afb1adcbbe954af868229aa8bd4aa6961f32318549203c9eb99e2c1ee88307d32b78253e6bb88a900aa4ca265d19de66418eaa99b80066a21b96d896fde1be5238e78fda04751b88e8206e2ff89e3c3eb63991ad58344d0e7e391fe27dd71bf87609f8e424a090c887675a8d45f6b0c31931b01c634070264b575de74506dddcdb0d2fa53de7dbe81b66e3ef69d513f083de252e8d8746ff6cba75edc8aaecbd03d5f724f9edd9e36f2b41ac556c7f66de677881c7c42c0b85f3918f58f902800e723278d4304ca3c2031c7c3827074a68453288d97cdc49d9707ac9fecc339081055291799121dad9c8b93cf01ead8229a8b448a0f33f5e65e91ccddbfcb92f1303befbcf3c201fcfab31d8ea51ca20efc6c253739dc384cb81a2e18aed05208a373bc7a5d32baa025a2fead1916461952cca6b72d3e3c3783531b5afe2ae353100871ee1728b50528be581e1e81fbf2d6fe742a06e261781cb29cdbe2981ef60873a50280e5b3d1c79b1c97d348ca85b2d6874ec30137d5a6b59fc733861c0f1487d5716360dbcdea94299342d7165dc74ecdd8dc3b10cf0708261a474cdd3aebf942a661dccb7c5000d0e2b9e7317e1d36c04d8046e105f4e14f2e4b19f2f40071ca27fdaf7d016ad17c06b2d60375ce21e49f0682c4547101d1fe702efa7db0d6de1527f1fa9fe86e6b451e123c98e13844ada4f9ec32795a7a33dab3127ae64d2b7ab7e44a83d6fe3505240a23c82446060f4529718418facec97311dd25e39e92c7b0d8729e22b7e5dba5abac8ae3477ce356d97e4589305ae09240aabc854eabff1ec34b05537031a57e0b6a2a139c2e3bffdd9ceaff1ed828bc027d6eb8da73be10cad8b8e41a3833354175d7bb5cc5291809b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
