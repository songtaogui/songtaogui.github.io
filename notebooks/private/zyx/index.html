<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f962e04d69503ce71014267240bc3afbf7b06946db66b2872ed2f8e5e98ef61441414748ff141440d8bf5173876f101c4ad2d268bf5643b82520aac756655dfa5d61cd94e1d1ee0a99c4a055940cc0875f320e9e302c92130bbb5a194f9e7368256f97dd807376c3aa49f8a64869603a3c4e2dac4e85c075b093798fdfee5c2ba9bc8f65932296ec71dbd62e21fb1a722dd2a4a1f6f248e6f16727d31870cf3d3da7623f9809ea97471bde7de6724a53f298d8b189e10db1436e3a017a95bfdda2affc4bf8969473bbfc2e83458a6f2d623cbf98aa913f436b2df39f34edf76d9d43d93eead048b2fd1bd2c3ec425d64186129483b49e1bb9efa785e41e1093577e41faed89313ce78d2e48ea43cb7bb1d5dbacb918597d39f77d347f6159d43742b737ac2b0310f1f5c30ebba56713792ad817f6aac06fc0c286f2f5e85cc93c1194aba794931c812282b794a35f39c8dedc268f38363bc3a424239474946699b8c5669166523f008bf20641403daae60e57229763503555cfad99a5d8076eb4024ff6b5ff52e74cfeb976c226c8b76e696d6d248829a8f36fa64bad883c849b81899187658cd7fe7e68155db12dbca3ebf867ab81c2266b9e63776c777b845f0db6fdf1aa9ebe71dd5b350e85d85c7404c635a2857652e694935ac4b37bf0c1b4179a0c66f86eecd73ad7eb1e38c9965aaad27d4541e80d40cd9242aa1acf083e5157276d26a0ec4ac03ab99bda0d87f756ad30cae756d2d70cffbd89d6124a9adbe1b2a8d7ea845cd46a89a23e9a0b6365de4aa14dc8d7fcaa7dec35dbfa500010df5820f6b5e963d2fe9319fbaab681df1d63530b8eeb7062e33673979ab9243d3def6f166a1a7d82559b5a53c6b998621d15fc2c024255a1d5c222e517eac7bb79f188dcc0f51916e349e6d9d3f9b2f8905b78e215c52755f0f2f1ef3601a7301884a9d586fe0f59e3d2b56caceafe7897a5642f926624ac56bc020239c1c2bbf90f74229b9cf5663d90478f775cfc9bae2ca22cb12cbf7a11169419420fa6e5b1e47cd40370baace2f22b2c62be5058fd140df2e515a5a67ebba3354d59925595a7394296e0b7f9befdf3bc037c8e03a15a9ee162aa290eae2f2613132c7d99f2a34ff256b2139207018832b003809a680468decac9e557c34c638d075cfc8812a8b6a980cda19d4928e9875686a7dae8435a5ef303115fd8980442c73a60217f518745f48cbc44a7df1dbd6a11bdc0635d01bec7a315559009f3236eb738b1406d6d4561616af6ea6b36a8e642d69f17cf08b46845e813bc12ef352e3095d684c1ce5618d39dab2ac3dc9abc14559000dc81053171a5804715dcaa67eae9328e33028f028613c3fb6b624256b8c35f3fc011fc581a577694b78f70e1cc8aaa071cf1d76902bb41f244082cfef956f3eeae50a29709644d3116bb97b73ab90ae49d6e926877f7c95e196290ac5ba4047584d205ff73c14381d763ccd8d2a8060d0408bec57df36b500573aec2a5dc7e28eece59762f1a30a244f3bd428a7aabc4680a18b36467b68c42d404597066985bb57554dfdbebdb6fde833fcf5f5de17ef00314fc5470dc468cc9ba053271a7aa9bb47db508373b013454fdcf520ea00590f855c39c3fce2b8eb71e346510ea42d6d051a53687ae6f6355d6fecde940faa55f6b360f9322e307899853d257b49373e43a10042eb759daf85c875a743b6859b6e7ba12086b6ad72f3de607d4e16a788af600410e41919b96353ea0d573d57612020346ef69a04344c0900ff5b07787a0ca9f871a4e56043f84c638566bb55fd6fd47de32f57fc1b2cd5638300b326eaf7e4fa35a874fc751fc903cf145fdaa0fbac5eb7adde64db58405748763c2b54c2ff7ac3eb1458f7766febe750e5a734613a4a7fb74e3e43363f7c0aafa29178dcc96475d8ef8516dc67779e181dc7fe9332893209bb84d366b567d693a92a31805f96f963ee9b6462279c97234e228da1738a0b33bb2560ed4452a6ce4ced1df35192292a72ed8389d580646d23a3c643efd614324707a79bf224fd76e9da70fb7045849f8401d21c8751afc83c03c8a7fec0bb7c90aafa923cd11558ed3e639e89915851bceadd41e8059ec9cc07e4a79e9dc392fb358f9ae00560981ed7f81731ab21f889f0066689e5a6ccebf099389f4ea67751b40f5a3b9946df53cdf8be80ef111f352dd6cbf8a4bccab25953fb3906d22b9dbfa0dedc59946d89c400d2171458c1189d20f3c8e135ceb10b651f25ca82a93120a45d0250a87f946d530b977197809c17f869a9094dae0d9774691a7dfee296532f78f3e59fd510bb8d372320ed7f2abd3559c05a594e836d262dbcb6f9277281cd49b2bc02a6b2425cbf9a359803ce3312d091876392467b1f51a919a43c057f6f7e01cf7c489d3f41d092ac9726c0fde450a4ebf06bc9393065d475fb45c143f275d2d6c081bdfdd844a02b65c099f7be442d167c653a0351fbde4cebca94f07181e7479419e187e22106e6dd77a5271ef5b4c4d0bdf8cb34c92c1bfde24ac598182c5efaff7cea19dbfcf264b10e44234b50efe9b1ed6b011b1e89e52cc6834b7416e2f9f6f8f756ea2461826ccde13e648decc3a1a331b74e7caab9296a27bec5ec010c496d9d6bd59da66f7951555e0800d5ec30517ea829a599fcf5e319fcafcbb8b26c09fb1bb3d637ec3a31050eb73a3332aa795a6b1d017f0247d1971722c4690ad983eb18eff8a03b0e1b6fd011356de1b2b4cb3f06b2809ca71e05a8a8b4b3ad3986769dbc2cbcaf2df31b78ca520716d987ff0975d40c652ebae1f39ca623d8b1dc08d63951f4733b8fbcecc158fc7f8d87e4d8370d85ef0e13417960aa879aede66c61f8eb424d51ebc77fd7e6563d91c195d69f7ea2be002fb8a0e14b1ae41d4c0be3978b24b16f79642ecac6a03485edb3004eac1038f83bff4c7ffb5c62746b5019d6e6d70c27b22f52f9383f038319e34f0f86ba5c332f221524bb10f38d1a3592b5cff408fd17838f95e6b426455c652b2f69d3afe8d1363fa0df657f7dfbe75c56f6efa40961438ed0bdd60672c207d3d46d98e813d92f3414dc9bb99919c9c61497a9f5025e4d1253a35324cff532a905250eee29888123b0d58d723e060b47c0cb3aa3eff48ba5a008050098979d8e0a4713c739e208077f0c73926b15a6c0b2831a774b1edd806b3634474d3a7a43762fe4d04cb5e27fe7869028a216c52a5df277f488507400058b03c4b10dc173c0d74677ac826c46e4703aa7f0a296c329245cb9c8a9e3ad5451df8f03ff5e61764b0a49d49719d4ef44de446485370c588861de76d63d50a9c91e990e899bc91b73fa6ce4286152243abdda27739ea1f01683adebe33119271d3748a7bea30c5c7061d45219399de9b3d00eafa1563645ab5ca7faae22158c030f4fb6efaf536665123b2bb649686a584b455f5e61f1e94d176f8aacad69ac6250a5893cb89c53a37d15e7392735d604a0bb84dfd0aab4a4a7fa83a63f89b9656c8cf4575ec364b93f7fbf47f65a5a745eb518c053d3dfe90ce5c754882f7d764f09d959eefce0b9318b6a3875445176a2bf3856483be415ca468cc142231252427961e5fb852388ba2d024f8ed77c84ada497b5c1980950aa381dcb37acb404f99fd8099ccbdaa408d384bfa77891d6d2e51593369ec0e920a2fe6a2fc38a91a32b9f1cd3f94f88cc42adbd5ae9d637e2fdb05972f241d37751cb083b5c86112dfd3a65c92b5ffadf577b6746d71f79f64e597af1d6e29b5ef86ee7734a19eb4c9913a2965f84adeae6828353b72038af34cc1948f8b532d2068e012e36da78fd4929b8f572e9746c3f741b77b17fa7de02423c396f39824eead20db783412708a440e2867014d92890d8937e2a2be04ef6bdd387dbd0790ad2f7d9c221fc6aef19e132261dd7bb9fe32d6ec86a8e994991432870c5c62d1b3a49f12d6bfe3ceaba51585ecfb1ed683395d9c33d56b0d106bdff89027c3bf1bf5f976caad687ae36750f074da01887cd754ed4a96286adfbb8688b9a01222965e9163993a10af9c69933ebd595297eacaca6340271b024072adc93984ae6e86edb9075d602aafb19db3935c8db1b3de1fc1b69a8c84e8f16c63a3fc7b6cb86319066b20411d0be2c449a86c31cfbe487a9fe7ddb9ce503dba435b3447daa7344c99c5d1f014d71a73ec112c33605150fcd869220d6dcd10bcc8f4273447f0020793e5767485bd0ccf064f333fc4847645aa69cc90e27bb5ba702fe3142d3ed08e21ac6164ac653b90d6386a702d40efd22ddd934e332b766c5ec02c0ad1ef037f609c22a13d9dac18ea509e989d5045bf5eaf65c99a9ea62c5eab6c77a749a14292da43ba96735081ffd45397fec94accef79d5002313e81e28684c5f166bea9611b60184ff1a4bcd0d217c8de2ed3d99983d420e3066eae48ad08dc14e0ef2a95613039c5f9d3f19ef06e846979f4495eabd4dc1b2854feb53bd139923c65fabbc04718e4eeae7e4bbe8076caf14a5186a780c0d18224bdc75c9f5ade11d9d14920b00171b1b308951198f8395e1dfe0f87d7420512b7c603c8fa503283b2a9ceacd1190e05f06709c5156e810c57fc982463358a55d2b8b2dca616cea83824277007b80f31d2bc2612e3f5feec83d18fa5633b551eeee4e766aa3dfc8ed4ff48411565d3ffce9a573508ccb4989fb2607beefbb6ca180f86902c81ee2f91583c1e7b33bdf083b9e4659259d16eca90ec30aa699d1d503fe7cf180ce81bd9d7cbbededcdd45d41f70cf6d4b3a675756804286bcdc5389fd1d7eb26b261ecd02beaac3887a390d0ff72eee0a377e8fa78d0c46ab59155f6a94f0947b9b41a8c3ddb9dc4c08241c5ad42b2ad1464ee984b82b6df8477c08b5e8c1078b82e6a8d22e53bab0b868f5e366014d8b0ce0ce3cf4097ab4e55130e647ebbd792f54f7df66c4f465dbc828d5e9b2e4641d059fa615c96c93455e9e34b4988d919fe5542cf4af6c14e02d292a72d0c8342beeaddf22633f2e6989947fe78984f3a21a85ddcbf628ee09d0ca5219ba8f74af227c039b29746a47e21e7a5743210cee2e180074b3ee3ee3ab09fe5ee63ef0ffd528e7e496cdfeb182cda858cb5d6377f654510ea635c4348eadc0d386d632bf4a4bba32e53e019687374733479ad97b1ce1b34ec0db82d30faa5cb2e98d8fcac75cd4699c7229129284412fe7fb5613beceadf284293e04c38062c308ea9a4b8450ae02423aed9443c5965576f4f453e7b4d29ce048f18e266473fcb581f5a71fbaf9c1f85a47555ea4324aeedc62bf1b04fe9679aa7b4e67b390735951328c7b67ce333d7864776552c95f131a53972528b9baaca4706dec3c5f3f6527ad11cba6bd28cb35a9759fd346893780ceea4ef4c5b885df3ded05c0908036cc09e07dc6ffc79edb7c57864a073596c5f40f833f7acc8511c7a57071dc57b276f4d8b901a5026dd3d58b11f89d32792fef15dedc4b1a7859138afcb837fc16e073a3f71fbe1d314d6c8edc4153eb1492aac19bef83d38732b68fc14837aa538da0ce8568976579bb44193df0087b0228ee38dc2651e4268055659ef0d1c577fb888813dd3e324381a293210ebe70d0bd0c2cab635e76fe14ed99a1c394c84411e38cdfa24acb295a3f36cc8bae05f89d6f56688c2a2a826a01bfe8a7e86c65c4e64250302e5fd403f4e14b0247e91baa30f6a0e6aac32882ce6111ce42bccb8925f32833f3c8c10d9d67d18ad8e80d8f9541503ecc0f2d8258098d1c3a0a86432641553cbce9bfc4567cb50b0c37628b4d76a02d4fdfdbaf4e8e38e3643e964aebf02457dfa0c41212b4627a171913f63cd8247469eaa8dca6114d5aecda29920658416dce1bf126a02971e33713f50482f1d8db6dd07bfe01fc9ed64485a2c6590a88416fe2146ae5311bbf838164f27015d6b65106be28109af680d01265c3281f51dc54c4565a1d44b05702c4e4e8084409a1a46685fdc07ff28331392867f354c9ccf40cd198e1462e59c03788bf1cbafcfe9812d455da8b8fc1ae003ec2e851a2e575d61362460a1ee99006d38b47cc600dd76c3b2b255bb788f77ca4a6e65a08a42af412ee13b200da62d72bda0a20e20c0ef95681676ff38a65c366efce8854dfa3954f0403989cbde0f6522f4a6094d0dcc19f8ee3c8445daf623a33173b35b8910d02cee12e2784c1ceeb375435b42c11f03ca769709afbf0ace82eeeeaf52fe0510eb289f44a621429302451f2e5f13ef1f73101306e9ee9dddd74dbeb19da9e26f3b5b3bc72bbb14d317e2e8708240a8daaa1a7870b0e0b7ec61e46d39da72f11984d03053a2902b78d25f90353adb3906b24b8e2c4a9983bd5e482032e10ec420ce63389bcf798f38fb03a9a1effd0bc4c6c9fb275a8109c9f42a0eff01a4c3a2be31e1304a0c16683d20190ea05f3c1c5321cdbc13ea2b6741e4e0be0405fc2a8149f99d96af151e0a3b9ab91bbc6171fb3a239433d38c57faa7b23a5d086e2ac6379a61d7b111bd4d495bd98bc081053c451bc4b5059d13e93280a08d2fe4190dc98980944a874c4c24e45c9e57f55916e9ee8508dde11963a9c2508e5d11d0600009ec032fb264e7fecf3604439e7ad2ccb150aa119f7e0e9e7f4bbd40899c00e391dac48a6aed53e0d55e74f9612ebfafb53a9b2f8bf1c35c57d92d960ba6f93fded405c067c2f545e9516ab9f48a1b55f0bc6d73ad97565e9b9f1e107dbfa13f6305361b3894c48f9840e68d8c72c446b94951fbcf64c3739fc1e8102a0f7798047b3f0bf036792fef9ef0222556c8e163160a26ae35c597f836b6db33e93016749e180f44fa63ccfd361fcab9ba019d2dac85cdae9e1c1cff16dd4a9d52e3544dd82784df4c45099abeb45fe7246f649fe370c62ea9e329e37f2dc67abfe86b12621c152ce986f05d4784f1740e00767cca3441b5ff62cd1eec16f648f8522b617c98e9a3a9e4c12ad2d3c3ba90b3b9bcf807fc4d5affc5898c9433f38d75d9cb1b3d680b8c6c4e9221a3d2b48523bb7ed5d53138e1b15c0cb6bc66f1701f54e32fe85a7ae3da3a05be38b4f5c112fff7c3e5f1273d173bf876e79906ef5c32c3cc314fe5aab3bdd81cc0a0bb2b911f25e95d52b6aafd481c433e33bb002535431aaccd52a7a336f2bd588f2d7da12028a011ec1e43c295c54ea3a72168f9448da2055e264312cdf3a02b352e3488078ed1f07147acf21cdb4fa528aab846af0913ef2c494eba2694991584e29a4ac4cfe9981923dd30a0a048b4aa8e7f89d5413726bb522fbcb180ad3a8739795f4daa9026849bd28afcc647472c704bfe2d31c4b57ba387107b8c22339a39ebe498b26a2949dddd921e524e073a968c90a9bca9a88a8932c2f972522908502b4fba9707f451a6e886b52d276fa7ae2201d32ddcd0098f562da081afde8199bb4c43a7080b229622518b79cca8738d47bb5ef3bda3b5216c88ac86c7a0b0389cd51ab93a31cfeb9252486e1e3d8a0ec0282c3c00e5093407ad565712cc245db1c7539594e4d6ac59c0a429214972d9d5d9d0fa1a782d5218dc17b08e52f3557ad0533df241a9e795176564e8283d73879464cbd3ff3c7102ca246ece55496ff8148e8b4b45d6585169575b798bd3926ed9c78d6fa4798bf8fbd8ccd0fc9ee01c5a6a2cb5b797eed20b89bd490ac712a0adff2cd49d88f7d3abcd6823aa2340a52de7d1f87224013c4b9aad0ebd4e6e299c66e2ed0499ff0bd231d17433d3775d5001698e938591d0b3c3a6f73b2b625036f492fc550c44cf8bf3d9c7f804718096b612cffee34cbdfce5264f37ca39fa6c7e9bdaeea84e1e6b8ec471d57b186b8d997bec3f7ffb1c5dadd4b049e56b9da8ebe5bcfb9f8491f47f148d02306e906f8c8b15ef65d60be453f5ec4f6b3f26415721286b46a78688ad897fdb993143dd08393f2926e081b893e7d8ea5c241a35437e4afda2c1d364247b6d7bbe3fb67886922f792f4a3c6b9941a17af593520ff62c36db8138918278ee0a7707e4bb2652f7742c31218d5b8c9b631c80c70fcb57ad3f447fc8ec46f3e1721e380aeb1b9f2721b96e270c3a52f43bc6cbc068ee5591be1bba76b7257ce461715aafe5da12c9209bffa0cc11fe1a698f96f9488c0d6b1d460d0b36d079655c9c7ab5b947b241361f1909700decbaa66c4d176b8f3cde08cd51201970b77f837a73d33a093ad6eb1afe99b8d3665b85fd3816e29aa9e2a1591b655cb40c30cd25f3f932e362929f89ab48893dc47066c735f21211783e289e3aaccb36a09c58a9a5c29b1db2d16d5406cf03aebb153974c7c3a015fbd9a31fa3afb26c6f449fade25ad92698db098abb33ce9b8ce04eadea84b4dfe6fd0ac0586e13223b1a30622b9dd87affa69ba397e6b9affc8603e93bc9da5da012d6d9b2e2c6922dc8b8c38c39a19807244808551120023ee0c684e525daba268f00414db85c875bfea42f1241c6b8394a14e24f7fc88566526e89e239e31d15656f68f5046a724803381a383f702c2765ec8fcac079fe7ca57b31c7b6a6fd794ce52291ab93a9d36442a4859c0b8aecbb590c125e48023c35c203ea3c91d0bba122d446a821fc5ec79cfb50c502dd1217b8239c08e69927a93d122f7c64747e65b85bdb8033f022d473e6f25051f03189c0edf7bba22a731c8ba6a2d081a18078fed5eabff619d8fdb0150f211031735f2244f6c3068daf823ce0ac40cb86dfacb5fd1bc4370c2005dbdfaa87feaf7b47465720081ec22fe64f2d5bc141b1ecfa717ce0805d9e78dccc209a7d438b74be1b28609fc650eefc349dfac13d4589cc1cd9883274b4914eb5c50b25668a5a31c9a5f3ae900cdcdb5f5e34737d2c9af9c2caea9d80bef5c93a55db75b86d1467b57b6952ee66cc0e2008e956faddb56094b7397fc92f155d87154375b3f9d12f729ea798c5406e8a3d1859f045760087661ad9d15c751ae5e41078ed7b1a621e4e7c65adf74eecbf6adb7ec26f367db4707baac41902740e33e023f537a85706d7bcf30e2383ea3859f17e28c78eff78136b87b4f7b652eb35b681a26577d50c2d83fc6190ef8a6e496e96544f26327f24645e1482f4bb651e9ded5ed00583b1b2da1e5c002c0e56375bf7797c81dd0fbd5f5a98582b9d9d2d292459b8f0a2d74c2d5131c859e14e79989f1a4b5e8b912f3ddfa425e8e21600987af78a02d62c1269f1126a2be841c56032e81e5608ada679a4294506db1d0e65ee47742aeafe03610006513ca3c323fd4659780e57c45337a76742bf13d6157152491bd6582a0981fca81df68ce2e45ad612df51dcc240cdc03924b1a6d8db6ac8c961e4f8a4876e9e71a920c395b4e9ae2d4a16756fff25853e0463822ded283df3c1780b21649ed9f23843755f99cbbc402d5e121cc517af5c6715afdfcf7e6f93ad75384f6e392eecd7caad7180273cbf694093e381279e698a416fbd142c21c6f635c1a080c58d5d362905c993b5796967a56e8e7e89ba5972fbe05dd4b91d95ab0c2b67c51651d053b4afa08f43222fdc14617df80763eafedc32ba7ae8062d237fc78aa480d03de38138af9dab481b0e24b85b4107231b9cb9836f5771af5bd09ccbc23361ca8e8e759688a0f668b2c516d8653c5e3e59b3b32909381e004ea83f6f4b8eb56a98e15dd53091ee0935cfbdb519c2a77089b0c7a1a8a0f9a23656498b655f32b5f758aeea12d885ed4c33fcf2ca45698d3bcb389000da825922cb81c1bd0039d1c1b45525006a0b0373ecf75adf1712d6d1537f8ddb0f9d3c1e4571e48c8a43f135c07e3ba41b7bd19b80e10ec88eb99491d1f7d5787c4f575bb142cc760f0e0a8bf3a9ea16a556e9d3d46fc9cf40c8e82277c36864b301f0ab8f168c478bc840b186cae3a56220d985d05811e623804fd057c2730f0e1604977f66d27e3e3b231fb8527927ccf9e7ef5b71e5668076c46252d17d472765e3b85a6f818d7b071ad9d58c61ad245f6a80f12b7dea9f2bb67a26bd35b25ac6851a19dd03143b9f260b6c98bd32731046b33c0223e9022504ab36cd7609c52087372a9755dde0b6b4dc4514385c206d74c690e3b0272fbb0edb6252668e282ae46a1f7648d4d9f85992223e49b64744b0d717eabf91a908225840b9d05104e4d5909ac4dfa7f5d147babe24222f2eb6405dd42a0c62dbc5ac7beb868d3bdbeeed4ee455736c3cc42f8c9f37be3447fb91d030325fe2be5d90e7fe1999e6249e8f1e8adb2aeb16243a6768b19ef0dbea87b4ac41b452a83d7c8bdd7363993a8be97c2a0034f06234b4a4a9797f6e978ab0eaff0db9443d4efac30f8a2ba1e4778a4d6d247d461c6667fdbb44c6f821df95dc5a4fc85053601758b7afae786ce09a631069127885eae84bdd1ee057331d974899cce3abf70ef239a96a6d96fc19bba26cad062fcdeb60175869d1c3eaed58159b6d4d98ed4748901cae3efe162e03b8e90d73a3aa5c23123d2299aae985071a222cc080c032048978e4a7a5ccf143d0dad44ae4203d776186f6b471a37e428f355df5ed9786fb2306d01b42e71cd92a98261d8068a9034a63a18525849a75b46ec06b8321cf3a3ff00ce354f59ac892ad32059ecf906d942834bfc80500391cb6a37554dbe3baecff6772c6ad9acecf62d834d5f82993508b900ea49ae13ca48f03095f2ddf4a1c8536a6548b465c3c3156fed2f8838e984cc840f795bc9d44b77bfa8f5c4f4f7d3ab66f15d0b287316bdbc46dec2915053fa9ebd4be0700cc3a13a344b4e72cf6abbd95bf43a9ffd55aeef5325e4204670f6e39b2a753b24b928cbc0a59544c820681590fe05ad957d205e6402e781b0d3d67c4408e1a4ac312bb4fc3aa2b16d9aff5924e09528e9d79995cbb284c415ff9d6b57bf27af921ff512821702f787f9eab2dca5c33f3e1d13198e358f8394c6f22863e97fd4faba4f95b980209599bd358f119dd0b4d993685c452a933df7af9f79cd5c1421c4e471f1692fce39da391c85015306d10856b793902e2cbe06840723a934c50cd3297621d244f44b681c4a05f87accebf538d2195857d4e5747964e906ffac13a4d1716bd0cafb75865acc5b8f4a524ec9aea62f1633d3adf41a4904cb00777b4347001315cb52111407aa33dbc6db5acd47b584298960e67a3f58376b38beca391d2e0fdc3b118028f5a1592d55f45a7fd2e1e3ef092250b411c92e4bd1ea696e99084f4cae261620aecedf659f867995c4d49c03dd7c9501cb2bf29ad5619dcd0d9b883f468a1965c878f7f3f92835eb400daaf033f7cb86bb3666ee42b68c795037a1cc83ed268b0ab436f5d77c735b55872709522800e31479696a54965f445e48c78a5ecff367431559118e83e7089b120619d7bc7d950943d4a3e9d4bd46444d848155b80cc6e8a32b41fbb663de283f9545bcefb54346a1b4403118e45efa6b430dd9b420aae7a53eb97dc3306b5dffc1c82e2c498a264142f619c8bec1aa94f1e371c6b3f158d62d24260ee411215526d4bb44ccfbb714dc6ba906a2dfcd8e6e0efbb0039053570e8cfcee02ff4a998f2f82294d43edc966cdf14f4588139a9719498e6a20cf13d07452e352656cf2da36e867e6908087cf23b4f6d3dbda08a397c2dc084fdf1d824914ecf376b5f334d2aa2e361a65fb5ea317e1f612f4735bc507f83bbcf3ddf736cb90f085450a996c4d5a6ab4d31b138288960edcf7131039645446e5e21148b1d9b8aede9f7290fc686d70938c084fda1eba2d5052bf35aab1912d0727a96350ebfe526f615c813ecff36299edc49c452b6bd4b8a1adda56c58ec9edc597b745e54978d1a70c6290b8a938fde1424ed0f6084ee73b5b7cfb896d473e8385e82e5e41dad581c045bdc2e71b5889ff6749c0c70726c48d491fb83b461e6a8e903b9bf14b1b159ef86eae566083c06ec9f5883d8f847e99c50e948638bed41bcbd16718094fb86b5e4b4aca4fc3cae34a696cf616b49e916d10bce517a29318b73496b2f774c71b785d3c0bccff7edfff766f6be7cdbff7fd7dbe7a5cc452e4fdc826e5aa6617eac012a2cea7883d185eeabb60b7c6970fdf6c43129db42bde0c34f2c91175d200a8290d6235fe7c8dca9fdcc129618538b92a7a63790751b9ab5706583748ba16e84137920f05a29e60318ab86ea057f1a8eccfc6e9b686d8f5b2222b74469cbbd6ad63e5e00263c90e200435ff92eaf4df1d169ece2fa7c870d69b5f981fb6673122936f91514f1cdc80f543c92c6b28a3b3251cd4d9b42390512e8e47871abd78e0300fef1ea76d5e56838cc05097daa4cda02c56ca304a5b20d2e30119406039267f496246f638123de7d83d62ca89298cd0af9c058ac01eb0c3034d4b726e50c621bd52e6e61dfc2168ce98a585383e2f2e4f0d58575f607ffc5dfeac5a3d42d7af53ef1bc2a00f373c6d3d4e6c1a17eed312d83f6520f3cef473d4cc3da9ff237769b226a675b002951c25349157d500dceefd492c716bb3938801921f16dde7321609e60443ef26b1fb4bc58cfa78f605cec58bac863dd4956b7627485c247251c886efc6ecae4b1e3563c0eb4027528ebd2c95c210516e452880341bab6316b2136ac06d843489472507201d0f91b03ff0e7d313b63b8d20d878ee75905f91da3bff1110a003887592841fdd4f760febd16888da78e1e587a977dbab6dae15a8ebb6db97238f9ce25c7d3fd8326089ee60a1d17bdeae93dbf570bb7b16bd12ecb6fb5ede344579552010c2b1c0395d53895830c46f98b058cff053fefd74068eed45a8ce6f563e27721967bce3e0c58a9157d25dcc7feef3f767c015c5a8e85b3620dea66d1b9a987561d56eae73b51a37c291470b2ff960639f4a1669b8bc7b4691d02f54508327646701ffab95c72597f9015ab252335b3a06574521c47031c8c66f4d2a31d8fe0ab6ce084f52f475d4b69230d295350c2895179910837ac4632d62c095a304ce644949603f4e215746be72017df6e3bd74067c37d5beaeb78a5cc1682b0025425ff01d83228acb8b714fdd619daae562ac6ed66615982aba6a9742b7e2bdd6ee15d5299aa2c79c9128b79d672d3e45fa52fab4658e722ed28a62644db83563fcd39199522008d6a9d4711456cb5816522fb644825e70f75e039b9042f163af2c8cbe42d54fd114b589a9c80a6bdbccb226ad2e0b12aaaaa91127a5b535106ed56555b75f336ff25c1e75320f605709511f5624989b88767fa776e6203afecc3c87c4779aa00bc7120d92b5bbd6129582056682851f4cb28bb68b9b0863493bf3a71757c81c2f950a27b4698c67421e877a6d25b5ec0d4f082ea88e2ee0dbeab2bc0fcf002a3b5c7f25c4b78ce9de14f39342598327e26e3f2cd173f75b83b5a8c1699ac0852d3db4b8feda7520491282557bc354b3f43144342a53084276a99aefa8a62b8b32b7debb6610c9396862be297a40a45c095baca77faf081539fa4d4b15a928bf32575960e950555a906e6755547d91043b9cc73f4f2e16be48671c5b7f9540a9fa60e00ba197336251682627cbd5d77c2394c4a7f37296b11a6da4891d0d26f5662f8aae110862d01b8d5ca568d6df65d0fe4c8cae26a168d9b8140c16cabea6cd669bf65ae48952841bdaa37941ae805ee89388d33c17b26749211208a51f4f9ca03f79b86f3c11224dee97a76b8c0a8ef5fbda695a3686e97b5eae3067eab581793cbb4948f41b01158ce2fbd97aab9bd515a39beb1e9bf452abe4aa9f818c8bc0f7986cea10fd4c106d9e90db24d3cf64f507a71ccec7411f2eb3d74b83d507a4a016e1090ade218ad270e800d6e9a4babf89df8aa5f484da83b8ec1af62e225007c61756008529902d0fc8765b81928ded30cb42ab40a8afce0db24b0237effbd131ac883fb2fa6faa962e518781d2113baeaffe7e909b91b87dd10f249ff4779bae30ac588f9fae0dd15f99f62b1e826b0adc708522fc21f090426101640a46f5cf3b58d8e00773486db61625cb55fb03039ed37809480e243c4859c179f952a3e43b13951d63988fef6d33dd37eff23f6461ff85464f1d83a155d1bf12744d49aeba3ce1bce3ba628330a57dd3852f293fb4f7057dde5ca9d3f12bb592bec4c2cf3db1d188c0b3eab1216d6d506187a2a5abd4126b9174445218a7f0e8d1131c128d92f761bc40310e6a634c8359d96d2f805277c81d0178774e921cdefb99f4ac12b8614151258efaeb1175c8f3e3b9c6a460a77ae67382241dce891f24c8a88145894c6d036b8e6f588ca108237411e5f4711c704e6f5a4ca65b38c25f8049ee77ba9d1a57eb94b4a69b1ff5a3dc1a11ede98cb309de5f251937f07a781c829d0833ffb91b26bb3743e334a9d8ce3a2809f2ab7ed1da331b70d2ef30a376de0f0ed8717614dee012eba21a5ffd9519f0befdff43dfc65e44a3f78aa19ce9c17c87580c46025bc967c9efac109a0b1a473f1513952f6f3aeee023eea17ae912404adc4bbc16537798108dd48dd09d91f58d24c1e63c1a2a8edc36256740181edc32db4ea3040285b4476a1e515990a233fd72c8c48d8defcf81edfc091239329b923258371bb910c138dd06fb5eb35cd17a69f2657d9f038327e54a1fd97e95d6f0e870edb4c274dbacbd1b80a27c1344e637eb9d3cee93b41069406b091bad1dc6ca0689e98140a8b16c078f912917289b2b76c2d1f17fbc4ee3a7ee37fdb607fec811695aec1f1e29eaf3dd402d28fe8d2d80c007c4e9a67062f62cd76c312b1e900256173278eb3ce77626c97b2d0943035b962739b1b9a4dad0acbe1937bc473cc822057fb61f63653aa80c22c0b3b6439883142f2f3c981c6905dd36ff3070d6e17300cbc0b802816e563966a7e7c2ad853a5b8f21217a72f27df90d25f77061acb3bd2746d179fdf703f1fd7f14d0e8db2263f210ba41462ce5d7ce4adcd616a67d111bcd7a5d76f20798a37a61aec7d3a3f1f5a40366a93e7696f8302527b05cef18e9cc8b7a5b847b0fa93a308e0eb1b26145168965eb78da051b342a7264e46794609b3435ef2c368b38810e30d78e99c9576a1325a088711a50b4e8e16b191963bf5d8bc77cb94cd0e34dfc204b01a66c2cc6d3ee5bd96b0a48b9ee1885d2b1fa7c93de872c219f0b7b5055cea170eac0b2d50bae64630f1a61e0a5429c1f55679deec2494915253952b4919feb8863f64b381c245060928f6a96af6848c298f4a52475a7a131853d8d96a88163ef504359fcf336968e4210dc7961c2da7e1880c8d00e0d5863f58ec80ad17eea1fc10a8e5ef5399de042ea82e96c02e01ce9435009b8b25c23dbdfdc27fc3fb41387bfe3bc65b6c6d309dec0ff36c6582333eafb4d8392ab2136bf26cd594029f67f96dd72dce2f3b18c35cbbea970f5b7560026440c0d5270030bbd2893fb5bccb4455b009d8c2948ec4e8fc69babdbbb66f08af7df3f9f55e1e72461db728edafdcb19931959bccf7d152b9ad3285e78ee3707b44718d3d3737137b31edc4638a2a7c5ed8f710e2ce467f33fa43a7bcb114d3c335a81870a71a35ed1c8a24cec50792c40b79749a56f35537e727ceb0e788c96af75f921cce99e2262c289e88372c989c44c27c7ccb680fa3da0f56ba6259d5ff4844f4b344915b03b317be99de5f20ffd13979d14c41fcff8adb455f98926d9ae55f75681d0a5cd95408581084913649af0bc036cde0fb3a76290f2fa0a21694eeea5d3eb9c6c8340cc612a9a515b9935e63e74fb70a73bf5975c511b5fcdbd1ca75d4dc724503fb2fd8fc681ecc2a364bb8e54e77d0d5b19a242ecd19072447294ea1e6446bedfe44a09ebbb32e53fc4e1c73ede8e7ae11dee7bc5e26ace03ea1ffa1052b42689a2b6cdbd578c988525e56e037742e264215e5725fdb24387bdfcb507d17639e1904947fd36bef1b74df1ba057ec8d60d1205d589e6964a1e25090f36056497415ac0ee92eac64ee45eecfbcb554c7abcbc1089efb0533e145d264d58fea6d3930c36f06656bc319a176fa50ed4bc8308944a4f6d4f1d07288787671a3288ce56e9607d766f846b1644b1137b44dcd4834182ca27b61c8272c107726298002fd21e6eeaefac372d32798c883e243193bdfd08a7d0beb239c3c1c2479e0a8b1b1612375faac0595b2e73b8100d5c5e4603c90f6b379cbda4be756e539569c247871030e1c72b64655947c5fcf66ebdf7676ca28254befc6d9a6d533c3e41b604fd2c37aa355ace1d4621315288e0f7abbf4f1795d7a23ef9d428ba98b1b1c0d7ba86639d34a67e7f227e0ee5f6041262e480712d5c8f6318a4e354dfe4b28107e62196ae97a1ce67128274202a79bd6c11c424cee123fc16188d4f474b782c5a9a9ae39f4b4daebe7c146ea81d47cfb903143d603df6341806637eb7f2520348e5da8f8ee1e578e4ce7122f53928e781a4af0fcb0fe1e883e4cd5ff27cd2f8ed937a1badbfab74cf2b5133081375e3f3045db36c5d49ff8f51780f8030ea609e91535d0ec63fbbfc08c6b094412e9adcae3f0ba26ee23c12f8a08aa2aa585105ce9c6f66fb434d74b0f572cbf2865e611405dcee5b76b119929465f07c9c12f6148064ead330efa594990e09614cd9d4d50b56ef97bb8b69cb2881c4e0c2a2da47283fe505d03511e632fdcb7da966fc66afeeb94488d92caeed3d18c6585f57acfe9e00e27f678e04b03984b62b9e50e3219f29c6668512785e9831dc0af75001fecf6e76ee0e2c95599246bb84b4fb40c31eeac6e2858987a26960189813114f3d828f83670905a7601af5b4c63ab3ab63ca51ac6dc5d55fcba55b86b1ffc88f34a6a5148fc3b0160d298d158f8f80feefbba0e141458ecc83756dbed9fd7b49d1895fba659223c20ef4682c0c093b8348a20756aae5fd8b54f673098666c3fbb74c22aa3e1b5e47b8df2cb99ba01173f0fd422e0b8c1e44a5252538e40fc85404242a548c3c8f6c63984ec1725102571eb94cd524dd80992d5121c7efeca57818111782297cbd324a980474345fffa4df4df5e990c2dea172af0275961f23db32398fac6aa866fb3a09fa003a3e906812778f17f9ae92323bdaa7c7721734a397ec7981312ca5b37ffde231ba01b6e9e89c9b7e3d463d8cb598baec44b47ebef4d1108d74aa0af0ef091dc2b43798f9aed0c3a482646a54765dfef516bb477dc98cf2310eab09bd1b1e7e7dbde30f48b198e508a381cfb60f6a9a829158f6d787e9976b3f3a74d0a301b46eb21470d0c0ea9c3fc072297db3c99d3d431126ccb5c3cb279753208af6f5a6528bb8d57698992ec5f6ac4c987522c81e59db34ab9494a421885cc67977dfb244ab5f505d83cf8f2a343c375499c8f5381b4c4f8be818f58c98d355bd8d120c093262ca4514f9aba9bbe856af46da10b1c8a46fc97b1485355fb90b7db024b5f76378a5ff35e84f118b3acc4bbdcf68baf6726c8030e1d7da5edc2f2ba69170b127ee4174485053f04700a09a95c54274993327aebce3ad20dba6180bcc84f350f08d4fc28f2d89237cd5f33cfdbd004db492c09f093c57d86e037a04f6d8e06a5cef6c94ec732f96e93a0d8fbad99ed34f9175037679ca2be1812e0a2c1ce5da1f5178f2d4920f218fb61101c9031a1983f58bb41d09916d54bdc7ddd31cf9252d3da885b6d19fb08510a5176c8816b9537909671fea137f4b2892e94af39ca9759c91bbad8943675a2d7e1f24e8f9cd8a4c110366442984cd332743416b58c42b7e52d3244557e4613f4080a72984ebb940e14956ef04d501f885daefe39bea3356d726d8b58ecb4890fc25e1cdcd07371d33e876459565da30e3c588941dc0388a18961dc9b0205590a8a072a10227f1ff250ec0d885a217d1b28546fcc3b56cdcecadc49d9ab04ace3b2b5198412fcbeb6da49c36b124885796aa9b25e717d0e88271e29e06e926668f6f6ecd071d409b0932703794b851d00d08ef02e9291b55bd88dec4ee25c716c6f6d75ef36afbe538f7148b32431cd5f3fa69121daa52f535361c891c86b88a29b3dab6cb8a1fc4a0d0560f4c5bf3daaff4a47f4fe908c0650f44a7c784620c18782a0f4f1fa009c2c35c548bd148bf4b71230966537a230c69c6be0281da1bcf0dd11f5e0d9335b5facd19fdc48f601f7d893cbb1a24413d4465227743a764c8034491980e9d93a9dfdcc00fdd79d829d79050599da273db784a19569fff7746a3b6bab65b2dd5414673fdd6c35a7a5b0886016e4cefdc09b1c31a988f7aa3b2490806aa68f41d6eee49af535a0fefe7836a79d35276f0bf2c6809383fedb96ddd4f0ee89f23e8a9fac9b96fdd76420c5c3611f67e6d311b9000f630d6fa51c076fc2b7abb1f39d860872c5fc5ba67ed33a69e193d5155f31e7f430894228814e0f9e56e5afe4f040831bc5c2b6c24d383edd891781240ec69bba47b6031fd65096818f25f628da8ad35c67ce0f9e8cd458fceb4f3b5d99e4f5bb380f824962d9fc8fb3d16cd8214926e3a6cfd95f0452f59b94d00ed403f6fec975d5e6eb83c5801bec519d2703f837be8e2090e8f83de0e4dec7a108628d118e028a37fd8e205773ea359b71c3cdd09319923e6e46ec89bd986c3f892dc8ba9671a039e2d9ed3afd83d290db3910c915de6e829847c4203ca0b2590a4a0dfc35bb2cc3776c4cd0775d09fd4061dcb4b1854cb3349ac491cc8fce87690fa96b95fe6dcf06782688d16373760322d0ef147182355182af81e2f1f4ec00abd51d8f36d8b755877a7a518f945885e58f41940665609adda2572a4db05e9233d74051628d1b2dd7d1f290d69e32deb9ef177d3d865ce6df63f09eee978a5d0d590ac2841b888a059d3149bea01f84f2894ad1c833c8e82a8f719beaa0719376ad74602622a005a68fdacb167c0107005bc77345203ca7671a89f9f952565a1c80b0b7b6b270684848b332d72009304cf8e2b0252b0904428534a91960dbccabef29c5d54c3ab67f372059d6050f973c579f42d355ea5e2c534f6c1a791ed6cafebbe0e4b5d384ef26f31ddd96e1e373d50ac904980c9135951d87be0b54c0b844d2985809ff0dfda2531136a8c9b5a4175c525528118e4406c6318bddb39c7f4e8c48a1775b00d36cc4da1bbc3c8a3078755da1a280c48e61c3ec990401533275e95eba0265e0a5a72f3f6cf9abf6eb5112b8221da7f4f7761e4ad8c06868a0e20079c916905485b918e46a780ac9dae6363f48eaaa360ed07dcb5f994517584c5aa7888e332d850ae597b0e647f863965920264f148229e339f6de6879eefb78295f0b42ec60bf53ef78570640455722d85fd614ecee28dc7be357b8cd29172fbfc286db5f522f1c1cfb50881e5e1520be6c9f27fc59face071c6670ebad81fa4df897b919eced48283cf71a3e316e7658c6390d5cb05437f01f9aa604cd822f10af1f077ef8534dead2c353a608e358f4b06be98573081d27a81b1ea57dfbb02bcfc8ee6f9bd149d9348ec216babde8861ede47754ead886de297cfd67998c72e92af35cbafa7d3966e06668c8cbca7e7e888a95c3efd22ccda73d8690f2e720c0ff148575513dc690f9318d9162a8a2f47f039c50f5a840cfe7c9f0359b4d668df8f4668e1758b92da3737db4e71e338872832c8a85a6ac58704a472a1484e5e21a7719ea8d1689ad2187e9417dda57a29f046ca4c65818232ec694a849068b7275904f2c4139def1ac5957def353c033b20b7fbe1d389632bc4465e331933b15852f2b411e11039778cf8393295af0f85f233eebd0facb79cdf436337cfce2e1a55d1d2f9e9789d94ea497dbd17286582f46cb07a91a756738b7de0049d27e9cad531019a5c38c473598962bde92e82bca41e5d15eafb17f89a9a1ff73094b271b1616f66a3036001fb066ac8c6334a618a837af92fd2d9cd210bb6ce29d2ebaefdfbe4fd3cc5bf63a22bf812674c38e610bad943f7b1a6bd73836d157652acadd18e126823ecc5c661afc5ff347c9c63af08a0afe5d45bd40f2da45e8f34e42534f01ad1e0cbdabb503a2c4e601ebdf03670f045d1a453ad8177e572ef22cf49e1807933038fa3a6cd5c2a4912d61576d521bc5351f0378149b0855bcd7d6de455ed6a955dc43a69d60c1ee1aef66a094be322229e82f9c95c6b9fcda75fcdc4051a065d6d66e9a43fc65ceaa904e1c58db1b728af340a31e86787a32a9597b15e25e8c66921609b2162c25ee37ed025494bf0822f07d63ba346cf6ee3ba73f2a738e1f997adcdbe9c6063fdd0c17566473453bbf80754bcc5afe6b643911e23b19d2aa0bef7e88251d692f2680ad85b5a629117bc25d6f6445174330f38376a9dbfe0118ae236b203ea99a5aa32cc447c839aa782a259cb760559ac93ee975f74d4af063b2a659762d05458e8bddd3e7914363aad9d718c90cc1a711aa59a3fa42a57767fadfee486390c9c5bbe921a39ab128b9c5dd4f62b792c78d8bba2d996fc51404e0224c097adbcf87e571cfa0a2fa57e8398ac58c5eb73a4bb74845bf721593fd3674097237787158e1bd52b36dba01503730be0b8e08eaada5a8dc6a1bba45556f400eea5042851ad8d399b8ccd7291ee97115f7105d997a24c5856476fbc1ece84001a07f1eda5c5b7110031d57ab824b49c09340802fb19685339f5a9e6645bd83d0b66a120877bd7bd033ff508b241dd8deb0225920885fda4f8062c3c15010648b1a26491ceac9f296f9993f2fde896d04384de33351b0df97ac60d0326df6565218b44792826e11b1f53541ca6dee0fb6450d884c7db23a7bfc835767058987205fb500e37b30ffa3aa9088581018cd5d7fdbe9939044c15d6073c0cfbe3cc85bdc91fc3fc204efb7e00997665a1bdc489155ed059dd691b1fd9f38aed3f5e4d656f270c8c513655b1aa094baf3b7501675d07cfdf2b6dc386282ca6b60cf50d5429d961b1cdcc78c426cc3d436a001c2c935730a32710436c7d2039f064fb53662ca0a8513aff8223ca83b50b8408f866f744758fdc80a3fa680c2bbb24f2a99c39351cd74328b153d53c0930caaf0f416b1d60094762d7b2ed665c187f580e295cec16f3a3ab5bd3a3000c2a594c272b2e083052dac631028ca69c47d390fc96e01fd37d1bbd4da8bf3c25aa082a6252e7b0f98f902f06cdcd98373cd86ecac431d6cdf5496c0c7b14133308028e7e52b6ecb9bd31c7116b313b707bfcf8cbd08d35ae7d6c9ee8f56d5647b9cc47a3adad62b6c9d61d6683cbdc14b4493e3c94ee80b75435c4f006b1e133043659b9380951574b22700dcd0ab283c5ecb50ba0f170cff08b4144fea9f27988830752b54b8e3bd4e84cb6f86fabed11df73b15adf6554c64a82d825aff0988a12e0852a1ccde40a2ba78e3a21207d3f1221e2b77d6faad96d2738417b27f0ebb1a99d0d21b18272bbfcdbe1fdd184fd713a7f62a08c264f1bb571f8266b7ed6ca936a6f905e8f500a4f2b90715259723f815e3b3914f184df01c0bac2e39d7acb9a6e6cbe47232ca491f7ee7c7df7f71454eee043e1bed00af7b65d5c3502b13ec7d86ced651a277ffd30d7097a9062e1a66d6d25215c12f3b655873d916531f57b60bc43625311b48057e4d23912ecf4b33424970a50a4282bc5295d0a2e60533df17bd8e87f171e57f75fd4f1a8c84e748e7672c3e8017162f0a24909d5d9f4065823188bd0279864b9a03c185777b78e68e5e2e5e2271af3f21b8c0d4aed29197bc950afa5c1c302767aa67169e24b06534726b63a3e33a1328b802e4c5650e92ed0ce11a4145e10a5fd2ae5bccd32a25f9e04fb72da7823bdcba031efd7a0dd2a663a495fde909bed1c77b89bd5b8376f1eb22d3f1973b841c9811a1d423cba709b177579d3f650230d3b9a876a6a97a4d943d03ac1df5a9d155e4682d05e6edc7a635dcac71bddbe28ebb292a67e6c76465efe11257637a04d2cd74155d675bb1c10decf7f777d6b403b1a792cc30c91b1eea61cf3ef455c97f56a6783e269eed99ca107124f8041fedf3e2dccf378d312e333750127d61727972f9165249c9b6e354bcc9567cd5cbcb342bb96af07d7f6344ce7af284cab23f66545f5d07e34a564050dc55fad676f6aa000cf44cc635a44419a1ea67184c4e8701ee475caae69ce10c859781050cb41eaddaae5f835bd7426ba65be7331a25c6e12a4fcea596c8415113e23c31f1e7fd78ba1edf45d0731aeef640eb1d8fac12431ff38e5bbf378b57c649bfd72704b0fb0b11517e470415bb270204af690051cbad973f6998bf238fe84a2b0b7531bfaaa23c5277d7e29e95e898a5ab72a37a99057c7a5309c31dc488482f285141cb19d5d5e0cecaf4389c448f4fc59ced79c933a2d60be181fcf260f59e95284907680a95e77ed604554185d4a7d38c67304b82a66c4bd46c9ccbcf744880ed5ef5940bd957a0dee64a0e343b471f5e118304a6bff4b9e8941e5c81f023cf5e8e455e63ec7186b4308bf2dd134a377b4739865c73a41885e465eb51ae02441be7a7a51d9b58b30ae0db70430780d05c921a2f148b82f7582885f94d33af7cba9758b1624555782879ad348936d1e7728ae9e42ffadabe71511fa0fab84c88334b9b31828c5cc1ba33eafe8a4e3a3fa23d70cff28139e28ebb948a7153ca03a8a4de03cadecc816018a61b413855ea8a65a006b6028f6d77bda55c06e7fb2bf6f1c29bebccad31c4e29d179049fa535ac05e7e763af97bdae580ba7d028696261edf","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
