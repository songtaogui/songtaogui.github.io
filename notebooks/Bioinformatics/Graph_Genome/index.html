<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67e931cd8c53fa8756a1ce3a06c778b7872ab0754ee00d06bf38d4413e3fbba048e9811ed8faba3deb0030dd3b723eb1456fb3d9fd32afa44b0f1c63c6e4686b658e644e9b02788fb10b9c0c51eb0a6278be4a5fc291100dfecb7614bf4bd9c86eb4e1ddf0694ee7473aac28ad85eea80c758626f76155493dcf41d3c52d149a0615f7d3096f7165c9f82a81f060ca9c71cbeb2d11354f30bd95535d8ad3d7a8bb93445cf439d775816d0d7d9a5457e956af9ddac6ed645418bfd3bbbacf2a36ee0820c04895bf59337ee497590dfdfaf1db14187990b753f613f212b2783e3133ba75a75bba1a74c93fbebe8d1377a422bf49f90f2085b4eb1340625e9b6e67eb610a0068fe0661a18f70404e1809895088b2642dc967dde10f52fc21c51c163a0c810f61e8c676b90b987e612218415d2c60fc27d23ec64e75451f26b6250cfc9e03faf7ab61902e440d931af93a222738511403ac56a1c0e0c40f3ca78061b0196bf6b6f597639802723999efefa27e46f66380126788640a02e0ac5c96bbe92b2f8c7086f9ebe1ccd6c1cea37e622cadab856a267e9c125b8c4dff7a1fc1e947b655d8d1609feae05fe86585efccc96cbeeac24a374f57282ff998a85367eb6a273d73b7050cdd6542a74d76b520d987ea2c3d19807c17131847ea90d8e8f2a78466114f49399a57fdb856399faf9bae570fb3cee6cafd6b59800f425b1bf98e1e79aab9cc36e2111c47849554795e01a2510a66d096630dce75fb0b367fa69ee0c48b805f1fc2d9572f18fa6ae1843fa3ed0aedaafb2995b809f9cbb2c77d4f38f8037d5b1ee9dc1290748644389285cfab3c42bb47f27c50cfe49b33202e51cbcf1309c876e4a39dc0f741895391756339a16ad8d2bdb545368e7ea0f3d81344848a5c7459395486db5bcead6e6db3b853c5a6baba58c885860bb25b07f8ef509e09170647d69466f5be9beaa3f0206cca3f18d36ec230764571a8c1ba6e3ecc5838cc178bfe7cc2369f2ccce47731af3d4df0ed6f4b9b03c3c0cbece161110d46e60bfcc9cbc0ededfb7b64db4597f4dfbff9d2b4a52b1440c5883a3e3cca10b5216a36d21c2963fa369f779777826624a4a626c7f5679153a91253ee7996968886dc1102dfa168d7ea1d64e71d3407567e1917ce91764389ebd29902e866fdd347095608b60dfb8f5ef2e0fcd1c10b4a35f4361f09744263e45ded03ef9670f7c421d156f9251b9a750db000387a2dbc26528c21035cd0e7783fb257472b47fdcd1559d512f56ea49cf3e9316926005a70c5707d8ce3a74a04bdb1ad9987bde87a84c08b99fcfd6a09c31fadb507246c4d9feb56cf478b897b729cac8e3da7ecf5131b2af533ebe6c9663f29c42ef5a27a3e1df36f75a614b625805cdfb8d8a5883c63d1170274e89f0e6f40de88f60abe90ac67f662706093417bee8ea3e683680350629595cab464446856231e446e1fd64b9e177b6aab829af7944d27ee2d854778745f99b5cf0f15855724be71f7c55ac6bf55b427330b0611f5a958169d6add7ecf3fdfc867104d985fc51c64f061ddf57245ace2aa8939a7dc6f787a34f2c9728df4beebb242665fd6a8db1a8b66b09048986d0aad2c5f515a1a8bbf040c9f01b529e88fb04c8ca2abd0d838417e7594d9f7fcf7d76ef88bdcdf69e1c0b97937301718b4bdff5ffe4204065d7c4bdd8dc05ac74adc6e884996c81812488f518fde0650d9533a79eb45989c5f9060bb56ac1db553730a7dadc180ee758cea2449bf4dfe4270fb9137b2a974694f13acc9e6e55f250366be5fbb627dc000e0263ba458bd6c824c5f93b2336ed8c1ecf61b43dac1c80237ea823178c15c205e52bcad89b2ab8bf882dd25a043fd96ba9ea14740c7c86185d20bb76a3e9928c8ee44a8190ee2d95de9323cc22011a0adf0f4383a757790a27828aee112c4e094ef8f1c8a8641cd456be5ad3b38c65e781ff6c5e389a2f2284e981034ee1f53d781986971e21bfabecbf5eb8502f3cd219f7536ff7487f5956d69d96b8ec499744df351688b57398ac627bfa97344ae20856edc012b289af0e0fbd4a18beee09aaa95057099d38641d1194fb06f3a70954a4671c492d5761c41f04516040dff9e902dd341964be795fa79075dc7bf4c93b4e706b0280617e20542bcbf7a455e7a594525403310d80d44106f4060b9fbe9e780b015eef406031c07bb5a26b374c9245926de0ae796840d57fa96b37f82eb2ca4492f17214abf81c04fb5b08be61f0370843e7a1032f4ecd06396e44680b9dc3092c2e90cfde5c66a25dac6d7ab21889ae29b561409d217484fefa29576baad4453d5830ff623ac583bf3393dcd896a25e0f92ea53b8310ba2074bcbe54d75607f5e7433d54e9351d03612122e162c0d11358e61a8e3cdb257bfaac5b907a0411496d21c1b71023a0aa11a1b3aeb16bcfa467c709475add2fef8ffc3d09b239737ce4cf722ee93ceb2899999f612aa272ded391b707921b6fa2fde693e0e345806eba463b646074e439262bbfb94e2aa02c36cb672ed5fa643b03973021255d50e12708a6a4dee287c243b6803ec701ca8900c16f87290017b24f104aa61d90223e027d022a0d0b8ba52e20627d371b44df9a53f304691bf9b447014c5c73ada29e6ede0d36c59c71e803d9ff086512158a19e022733af0a9289d993c7bf771e2b63ac93c8e8f1c8f2137180c6e3ccde193c005c8a646baeaebf164dd1e2d64146eb65fee230f99ab97ef247114be50e60442f25920b77ff9f621f0bb1408a3af0ec1368f3f5187d5f2a583ade7b28eeed4f733c4708559a7ae37a25028d7c2a898c7cee59a9c1d50f9d266b996710fbdd5de85606d4ed4a9ecbf9052ce56c655cde94cf04ec68102b953de55a9e8993dafe1c216502d05ef2bd3e4a2bd6a39ea517f7f37c0026d4b890fba5a07549124179db19f15e1b8caa2434b7d287a1416537b2b595b2bb2cf3bfae15d0ad37a0d12340ed6191d57197ad19210617425c86de04116651bfb2f8b73cb992c0352b304b115528e66cdb60cb4cd472655822fca95e1b31f1259668bd5cc6961c416ad99c6e6c554a6a3bdcc06bf46860e4df9349372ea77dd95953ae3df912e70077f103c6a33e3e39e79b7a9e992f64e9d1759d582edfb7a1e6df263407f96f1b0de791eccc27d73e666b88d03ba5598c16f75d5d4b2fb5a6a9c4a8ddaefcd8b60d38df3ba9cdc8b0b4a143533fcf0b4a28049508cc82087a556980fd3ffb7eab74c16d488f48b5948e59c2e689d6754e22bcb9b14428956d4ba32d19f742f0a5ca2f743143c92fdaaf4eebf283a02a0c592f39d739c24d64cb47f6b9f9ebb9401ffbda685bc148e5b047fcd9e9e3cfd6ef084becef825bf81fbaed2eef781cfaeeccbdbda8fa21a7f592c46cfb07f9643b83999d5a0f84dcf53cb3974f415f156def7c3ec883cb7cf6b3ccc991d12ef0e96684459af625f06f40a3a773708d2af32237c42dd0cd8b9a9751a0cecf02837bcfda5eb42a316030edb56bb31f8eb54fb29573546530236a33b702781bd6264b7872efb9bec457c1e46634038d347f76eed7eab6fe64877d2ea00fa8a0b037bcaeee62f2435626eacc4fe2300779469c7c0eea1bce91cef0417b1c2c1c0781813c2d36463a25246e652dfdf8a281bcb398f8e33f29fb1eff8e1b36fc262a42b5237ef14775ce7b59da69afe52f86018607d0ed223081e945ca078addbf654a3b819ebc1ed437ac2b87cc6e0356cdc58b65cea0964431621c983c9460011f7f312d519db9ee48b62c32ff9bce0621783df4f2d2040ea0cbc66b8c4afb8663220ca942b4813f40b1e45a0e355261ffb3a2e90198dfe059c9967116b49bd2b0e466829fb01c82c35fa7019bb910c755e2b458edab8d6d74b2ad8ccdc1c63ae789e6ba6160544c6d1e0e68d6537f35ac47d1dc91e851d75dcca7e8a6662f362d0258ba95ab706d5076e7e34e1c1f5efc611248d4e67cb8374087afcd3e1b5f16f5006459aae4952362369efc29d5ba7a5933ea97f4b4428ae634ab8db8294d015785077e588dcb4676c36447733a77fcec8a61c44e33ee26bf6a1960fb07af1dfaffc390df13df40be9e040f70da5f28f026bfeffa45785e19172fb18cdefc77f23dfd2ada11ed3346877166c6df0a4959e72161a3d42c8b9f4db6fd114a467f4329af9f6d84895ef87badb5440b7a41402f28ebd7b22ce7d298bf30370578bf763f676dba6b3f88bdff97250284c36e02444e2f12d970a4777c8c11bb32f5075074b9be2ae0706baae65ec6b7828cadb7e6604046b0c06a9cb49fd50e4ee123a71fc85e5265f14903a7c93cdefc4b5894c0d93ae0a6537ec07b9adb2b9dbc34cf71103fd79406f41309bc81f4f9e1e9274267b28097dac1e50b20d8bd942c8edbdd4fff57762b8041750500794ec4a68ee57e4ed32a4100cea27a786636950a10a06d4701af31a343403e072f0f4b6cc4776104cd8a49d954c8c791a3a1dc09109f7804f1e0a6ca5d5c59b4c8c63f2f2503420f42a62f07192f946b1726a9e7ca82a263a0bfa0945e37e4f9741a9aeaa5c5589a931ff9b775ed209d0b9bda11c05715e5cb3484f142134c3bbacadd6204168a9a2224a9ca356e310904869c86ab404d9b9a9313ce7c7b7b150d9f3cc54f5bec8b2af9b0e5f67c8140d9f1d3e535b3fcb7ace30bcc6fd75380b1c4edf1c334838145ad4db8a9e57c3354ef0add19d64f51ae4c2369c3581d51935ff0dbcff6c73708d7e2bc5671c52080d25c7704ce51c91550d449b2be1186e95634a87dfc83fcd00249db205ffb32fb11132f6fa85f888504d8044e8daa12dd61065cb7354491c140121034b09a96aa2bc9353c191ee81866149d37ac987e82a48c5b893170d9711cd683d98073cf7b5a3ede9de808a69668a668b3c63c38b44ff04d8eb5ce5c1da1b67ff31f882b4ebb90a19e68c6dbbc0f661ccc877bd57a223336e454cd92c5e678a0719ec77951cc51a5861b2ae060e4f6b5b218e02e0086968fc29f111f9817761559738a3093d2b4faa230b932e7ab348a0ea0014768d808cc19d963e58414a3358a4f7cb11c33579e1ac5b602696bd673b95a0d51e694fdfd8a8276fb7e57007b10abc8281f346f3bb5841f8d6cedcd2775f2207dda9dffb00235a6c741abbb8b79382bfcd4770031c01f22e9c44f9a03eabc243ceb1bdc69231b4c55a8ca211bc369f3df4345eec03bf2f85e889e396f455feacdfa70638addaaaf5b28c16ddd7ba3444583b0a2b6488f26ca67e255c93471896413c5384908ec4e5ff098acc66be0eb2c6c0cdb143a245474a1124eaa40d1949be8925f21b08ab441ca9980f1aaed1127c253ebaa60bea6d9dcadc1f05f63cff9cc27d25ef7afc38f7199b7bd063900b0d738d7f3468ac3ab3f2e13a64a37df192ad80e57e4bd720a4ae9f5a7701d6c3e719b3f29eddf09aafce2e42d78dd2b46631d95706369e4719f7856ba5bfd840fc2524a59c488b99004883e6785d6b04f2ed482906d94bfed8c72f15d7d0d861aff5dbcc978598235a432fa6db5a80563326ceca88745da36811b9f43a071dde92d006dc81e4844d2dc348304b583b88e5bc4069629d64e0c97e35d0802486e6cba1f64a1a351fd40794ba5941b57a22b8745d4f46a798c9c23f007e05eed56e0eb4c794eb83eb3848cd85e1cb87996cd40eecb396547081e4656f31b4b939a231f1e877221ebd8b525ce571f94463b1c4027b1a0cf1711797837f691e38ec455eb5e36115a67c040df3a39c174cd339b0aa430e5a78270265e729663a6a3913d90b920900e7c509c411a998976784c7cf2f2e604da679ea7b76e11d4a7e954bd6c9ae8604c06d9920541437bc42d6e96f8849d9d17eb627103fe8f277f5229f8c7dfa3394fea999d4ff677d4f7e73320b07bff76761c97ffe738b5eb22cf97d1396a0be99b3ed2ff3bae210c783ee666a6974fd2bbaeec45f450c58aa7fb0a86970961b6fadbaeccfd7576950e4907d29ffed39685265a932170fe4eed18603b807245738ad18654a97b983defa6aec3c82a920ca7c4449e51e1b4653613f459305f211159197d951cbbe0a0581b96c7912df5c1d604a0b88e20d94718208758713d152a8aaeac9664768019e83ff407ab35746b870f50b25e38756d898ecf1f86c09980a513467a4d03b8a0298e6aa6d3bd25033775fc438a26c200781f80ee43d51a320152ebc7db86701b70963bcb92cdfafb695afb5bc76aa066c89b8c31d9950d61e66aab1ef40367c6b259b9a8fc51a83176a747c79bae20413de96fb860d18cc099c266aae7652e0367e32d6e79eca3e60c5821f37f0445aa131ac47ab60b816f626dbdc2e208fc1deda873aa10bd7bad88e7eed55e99d28a4127de1b4ca15bf22404e30d819f8b267d74cd4084669aa660631310857f1d897ded0758ff668026e5e9383bfaa2afd196c49e8bde8bbc850684f31a337e59763e6b61de2972d27a65f2dbd86ecb78d6c7d7d8aa121a4820fe51c3049e4b693944ae6945e2a7e042ff6121f0026b0f0635e8cb5a62c29257f0a8ec6549f29a53bbce21cec86fffbd91c6726ffff43c9edcf72695d280339136ca4f2e28fa9e6558415f0dc7cc75962c177d10fec614833f16b82ce9f7ab826a1b4390e9be4770a8c49fe50290a27a39534362b9b9882e0dec6087936d583b418f390d835ba113b44d566f7a9af6d5d39811a727566b63fc9edc71dfd8eaabc1f45a79cfcb91af5494750d9485bb70477234c1e99e558bcd257570811952333eb161a5a39bd2ccc50236de0dba626add62b597068b95e0dbf89d3a2644ffbd9cc381c0fd51cbb67a756ef95783aca7560d34c2b828fde93cbebdf7900df8cec6884f9a42f8033bb5a63a1a2332488a91b3b1830271fe2a6fef4fcec9259f47dee9b2493d677f8a9fde321cf77465cc49f932d815aa05bffdb2a3c512ad24525fcdcbc1493bc8a558067a8912be4ea9daee2c0fc13843480266e65efc6d2653af0ee342c076ac5f5611aaf47262437782325069f2037f6a4dd4fdb51b84a621cd37677820760667f2932e4d7a0cb6cc9c46b22765f72f44f569412d7c0a78d6d8ed59ba32fbc1e9c9d54e2b1e460c05c031a9dc3d6d507c63ca1e49c361878211445a614f63f59f0b015dd35e97128e75f89159556630b6f4dd5589e11b5094bfca90a38ebaa5cad632b69ee3614a865a0c39f0d7060fe0736044c075e6a528eab341bf0982fb3a38f6425de53f35cfd07529643513e5cdead677b1cedd700383960a1d48703a6f0540e9633d1ea4599269e11f22dbad9bb4b19ae2479429b9d0d2f859cb734f9cb423ab093de1b80fb0e8d6662766c0b6f56ae26f873ce219b0ccd81ee11b8376d980c7c7251c041536222380b1a989ad8241c2c270fcaa1a366dd8e4000c9d29ac1c0a98172e25e592f3b4b75358c89fd479cef8463dd087cd2f8fd443a03026cfc0910b62b39cab5899bc5703aacf8659e0fb5b1cfdad11727bd7baa3caeddfc8d7c5f291a59fb5510eababbbec4ff769f7cab72523105c55aeabf5abf45508c759d35a310f8153eb55d50bb8b5e8d78b063ef465e59a3950fc1da913c53c511860a3f01f5fd4dcdd2c006aab4a18017bf71d7dfbcc708715381acc7a1c62e492a77e9cdf92d45990845f4b0d707d927996a0963bbbf16cbbd2aee1335ad9448354db897f12e4b6492332ea6ea849179a84c9ede39012b240bd0aeb27db8fdc6e72d39be4a1adab78a8666f4d050dc0832a2a03432089762ab8271b2520c5dec7b51324ef1c281cf56b47c5496f05dbf8cead7a45190b4df4b068d2ba5c6ebc7f0da9d9c6390db867c1c7a9e627a4ea900392fd6ba590fa2188f7e9b925143f64e1c188936150842cc21aca2cb4ba76dc30f5c57f197298faa38a953d7b70d22af869ffa2f566635ca71882a8c60677226422a3855c29b83adae999e5f13675f71d49061bf21f0b5345b21d05b1a99303770676051d174250ae1afbb683dc4578cf44f44dc60b809bad9c24c249c89fde9a96dcac0a8098647a0ccd3451b57b226367bdfe840ee42f9bc666053d89fefd170ac9e17f49aa88d7799857ee91e7407ee8789549146678c0a4cc690dc033d243bb6bd19faa0296e8c808c331020ce19e057f4d08e2bfb8301ac291fae298b4ce6232cedc6209cdfed7be5a9d8f7ad81186896f2f0fce72228e17863a14ee67491fd04becb1fbf9fe3b4dc809ec8fdee3d98340452c966e0702d5c0430a6f691116bf8d4d86fae387427394a7d8fd1ae2943ba7d1a20c4a9374f120cc5d1ebe50bc3ded888e3a1000ec820d83828a96a30d03b383d0681963e356b689fd1c5b3c39bd1ba26486e7ebe0f0cf972e2ff42b60bb345d81c2a912c6929d7b669d2cf620375ef6043157e6b06075106d36f99e4d757114e5c2ddf173a8bcf761ff659caeb7e4e3f57aaf2c3de2b17315a33455e16b04b60f8426bec6a72a77c1a85864f805dfc3a6df4a6a55bd4de5964e4e56bbe246dcee1315ed1cd36fa7ff56b94274a1242f4ba07b91d078ae4c610ea5f589a4378028e294ca55a1037ca6b00074c79e862d80a8e6667fb86426233d954942390b52a8038baa17c60d089c8249117b23662ff0680b43e09bb8b95568bf7f1ad155d064d1833b3c4a04eb182b253a742b1b5bf12c11eb98375147811ce4e8d83b3e68f38b88dbf569296bb8b184a26d9093c831a44ec0d1dc8e126b4f83530a8e03b448d637bdece4f4ecfaab0d501d8185c42c5d46e167cb371e2ea5bbdebd30fb806b39fdaa6df966ae6ccd06e8688193674d45db5cba1b03ad1a2f31000517f22b56f0de4b2a58d210677278da34d9f6a89fd0c000cfda2eb36d1f62009a8561cc9a9e867ead1ef2f2078b22818914c86735c503b6004542f3b25f419dbe0bd1ee66ee5c6b10320217a8c4fa80994a5306091b0515d2a8c033d1102f887f284cab2a03b8ecb058b08ed7a32f85b9759fb5aaabf8dac355d30811fc8d494c055f320b61e65c443a017658ceb3d73c2935d9fee00d6713e3a9bf4df99c7a3ef474407276fa3dec12a78e38f8b1bb42ef7edcd0559a617d3e5a3660f4233c9d36ecb260bd0d1953d7d83521e9be59866ed687f6a31523b930b750654c9945e5a7db635422a3e960f4e63c9279e7cd65eca312945f87e54b99107f6ac9a473019545c06ab7301abcc78d09fab88fa30d0c8c8ff663c3b98707878c4290156ee7e64bf18d5ccf7471af9a1d305ef1cd212a5106fe6ede1f62b162a15349af6bca2db495a7a90a5f20da4a5b5920c25b8b8899ac861d200ec04bd83afad61a40608b89e034b46391082f3a70b192bb3a363a05c236fe251a4b615d0d54b965b9d9afeae733ef28d5df6e97aca0838f9eee2bda6c8a8275dc97afa3ae94d2149984d27cf4256081c9c44669d74ed6bfdd62fd4c1e29a00a2b5cf61b1047bcea7a7a2720e7b43bb62c30051f4b9983537c52d3f01b4358821b0b16624850947dc5e1e03765843fc5c6b70d26b81d45da9569b633eebc903cf7d9eba0349efc0f1d6964a5a552693069cb040031890d89071235243f6c1d3a3bba9235e595a058f750a75d23b09a0b396a55bb1356986ac7719301e7ca7c5bd401a93c49d4ae23918a192b81dd2a7bbb42e7be11c3c66ec2a1b8555f4ca799877af1396070ae7c9e73d5efa1ba152d68105c3d54fd0e6e0c2f86662bf7ce1cf4c5f1c8b8461af94ebec6965672338d33a0e82f906bac8fc00d7faec9b4605f8f1201e2c6a77ee63f44a8d7759fbc11c99b6e4c54fcdd9c59b27c2a2199c7169cb9b2a0d293d2555d34494710f1e3558906d4cc5f8af56ae8679540224eefac980ad4198b1b1faf2f5dd6a593215656a2988f865cf5eee68e58116306574292eb0d244f12a8e9c7f080431323e9084d3e04e05d01c56ca263f27252f01e1746724a3a302ecce4a436b33e7dd03a5991fe3b75726d17bec4202fd255d52903e64d70f7793543f230820616f0878d632b382c7cea8c300379a42b9d4607783311035db38bafe8ced1b27033697da1cb8f3afd10b62697d691d2a77e0420345c8ca252386ef410371091ccde468119c8974528e70cf0ab115bfc353f1b3ecfd7d5629335713cc300eb6485b1ec8e2da67986e7146330ce84ada745ebe3919b9f8a3dc940e02e06e50b7332f00483fec73364d44cf6cab7e30f61849d7afb95ccc4f700856ea18a7794380d976c45db23b70dba0c5238fad068177d4e165e19480c555520f040355868fe1c75b3ede8b946c781a97561daba0f73848a8097d3f2447d04496d339f902da6e6cb6bbd6f4e7c4468c2d1eae972d07ea66419f0875b18abe62ad9dbf2ebd92dc2e9524d4d8c47dec36a41d5085b0b60cfbd88c59253ff8a9f8a270f0abc3e4c1da2553329e871fb6e36d893ccfbc2fd6ec1edee71ad8f73adda6a75524d01497a3b9c50cb98e8aad18de48c0ad79f250cca2c1be92e75f730d7ab730da2623fd9c329bf970d5ed136af242111adb7fc4b1ff4ec393df363603f1c2a7fc2d7492739fca3ce2f6163e57306c1e85b3107eaa78235b8fcb5710bca71fa600fab26b336ee919f7344b446b15bd72d7b3eced6bb327ba2c973ceec0aae5a3dc3351fb4c7c91e87640d7c720679f76d730fb2f313c576417a884a477cc49b0adeb8cbe0b58b959c27865bc1d166e065ed8b93d0e554c51b13ddc0b6a14ba526a861dad7e03d65b586a284cd83e8511b6c65a1e95062d3a99df569266b081b8ebeee3a32077a2b379aeb5db9af4f7918d745ef5638e11d22b0df53fd240fff3a91123eecbfc325530a59d91faaf2f347e9841f5c72613de1ba6b735b80545f4e2597923d8a818fa65aa905813b590ca6296d76b19bd375386aeda489f7808481d3d9fd491044d4dd70aee77da86dd933d6e901114273e89ff75a1bf7e5a6b64c5460b7f9b0d36fd31f8fa0bbcf9ecb3e665a0181316839d3b0d1a05f0a068d5789f92fe7eeb10ab527fc9bd73daddf0c84fe572f233794accd68cb36c8979d347464c0e527afe9f6611d840f8457d6003fad45992aa82deb5b084da57b6498778759351b0eaf10fccc838130660382224e57bd6cf270b75c93be81ab02450b8f496109f2dfda090ac581f1ad17f3b91bbce07590fb2132f56bfb420c409f5a2116419bbd87348ad0689b2d29812e463a80221ac3c505a8b30985081f5f77590409e66c89199bf9491a801e0c53255e033f9f5eab1202ad4eb3a15cf92b18381054b94dbd0150ea700fae3fa8ea8811855786cc73f1b955f73c9007b6f61fd6ed03a6794c4810718f9cc52b70990a72cc80387388f2939cbf0140c053aa8593de947f651a8fbbddbd999d8c854371d6dd3a19cc7a78c1242a8309d47897224c0f9dfa23954eb362c1b893aaa188bfe07bc27c3a91285a2f561cfe01322075427a71117ac8017872a151a424f57c2b61fdc5bb40e3f117628b43c0f767a3769771396f88cc22ec5466962e7f0fcda1c56896528241eff449e257fb975e91354be1e6c0c23e850d8b8d8e2eb1843eec3947240689c2a022e3d578272e56c0ff70aa38a5548229f4a4170b3141ca558bddc6edbddb708a90d7d1b426f1f388fe210c3efd28f35ae26e18043d4fd9f17a2085ab1c95b4da79b163803115c99c7dd762461162272e42966a870ac8edbfd63f3dd973dcc5d40d9066c93c92d3c4a51384fc89f3a9aab8106e3d1e7bf9fdcb8d114286f029216e7b3d0be879fba31edc347c982fc8c3e531a0ddf344fbf3984ad55966d7902f38ea54102006cc01dc73294e575b3eada8c353bfd51a37603d2727522a6efbffcd3945ba22fb96c878ac24ec272a0cfdc16487a57622f4c8e6a7a61287eac280d28be352456bc76b57ffcc2edd291771cc750f5387d728f4911e9820d3ff9b5b3c93523bf84cc4890c3051cfe7928d78ed161f1c50c3c1e28b24a22a1abb012b6b6aa70c722f99557e5c5024b7c920fd4122400b665a6ab962b9e41df671fda94f5fe7df8aa929c03d276b5b8caa370ba42e03b9513afe5bb0e49cbe3e5ad8fc082f45e725a6cff85f7e1627f0eee0ce427b246d73fd63647af014d6abf15926b79994e25a8f45f2151e6f86645f6d9c737bff2ffa114294ece4d0822ce2f7bbd51f750d1db9892e21699640c8028c79873db6cdb8edef802fe4e8c08f2e1f08d4b97dcf366e22be7429f66aa51101a9ef247a7b99f129d942719a24c19c9309c79b7e84799c35af8eff57c2429f0f2e6b0a5aefb0f1fd92d24a4938a3c151c1837f89b51550c4df147cbc2e934c2c45d9222659bb7bde59ee6fa74675737b423a296cc7f246978a16fd16da093042c7cc38001ca926c2a5108c8865120337896782ea80a54cb645cbc3cade8ea4746410d6ad4afc93d5ae7d1b05a6cbd73b139ec7b40474a7c9a3cf632547938d5782778ddee53eb630dcec80b8b4e48e4c20e5dcc8654ac4239ba6193ccfd449b06d20d8bcff687a256c65f43c6dd0414c2abd066700ace4929eab595f875e7011126803f031af3a875ca45e5b58fafb2b03d0dbb3cc45ee5263d36c7c96e52198dc3dbb007214955832bf9bf73d514a4f36cb42ea31f92eb8c1ea4fe288eaaa340084da837155c1b061ea1537f4e486dd3ba457b6465e4df61d7a7aee6d36caee2094123f3aa38e1c2a22ec88c08d8015ac135b167e60c1beebb125a7fe479ac739fe21fd240509a433d20346989fa876c3a4e63116c29beb68ad1750bfccf4d4506fec502250c1a867657b719ae21f7afbd0a8dfc3d906a1acbcc4934bc344643168e9d83e7ea3576d1bf67ade869fa422901d93b7a8038a123d91c871287052404c4564577ab1d84745b84df04fa814c1b785d1a4b5201ba1d369e63bfc490a1cbd73aa36ecec4e821f6f58dee6eb3a219b8b0c3e17b950b64c01970a48e7e6a5297c4bb60c89364a0005fcf7716c4f906f18bce8c184bcb83fc229f711c51c9940dd2f803dc1e95bccbab9ce33fd75503d4627b4bb4fdec53159a7066c299269520a7b49dff201541b12baf651cb904e81939fb216db4a5211b2dd934f764f6ae17b4684f466374574c2f4f52b8388214284546c517167878e47c15cefc3eb12f3e4c613ead3ff6518e2398716a2bb7302bf5f7d762ad5011bcc43019e1f0f17a83c8fbd9ca948323f73a9ba35c18513717662853486b95c6d493f38e63c5c72a579c26b9f7ce13bb9e77db9e608573800b8402de7db63883e798a382010e304f848651d65b1a821504e00b415824f02b16bc392d998fbf9f702aced5ae7612afcc80d880d054756db70d572dcd56ff8cea2632fc44e6076165b23cf0b9431f905ad59a93cb24fe22eee6d131bcef76f5c9712c2461e06c694dd30f968772b1cb62891f5f842e41050547c83578073602bb51b5a1a1c0b463e0c4473ee01c1f0232b295ca84fe9ae3f3aff7a09d7c9b48359484ec91672c7e464ada78304be64d30a14679313784f418c07cb6a37d40fee3f693ea20ddd749eb009fdcb7285b53089e348336159df45a5e02fdaa64f11796450195959d8c58e9224e35036a6538bd7f7b164d51f80c3ea3dd3e104bdaf0a23a6af13b3e87f199236a92deafee144b56125502b0b88be5efe01ce4ac08bac835d28d1148a63ceb463edef5ecbb40ed432f024d9e882e689d4402773a80d98877498e65f4bc1e92fe8824dc71512de45d4badd5f5e81a97a094590d2eceaa180a5094223a3f069a9c6761993155d39cacba7401dea46da2ae9e5ec689d36ce96377fc081e6c25f39c9c7bece194af494480b8dcf32867b6fece9cc4332aa006044aeb717844733d7c4b600f499f7ce4b802915ec226a039a3c41c644f116d5e63d4c6c46b3a4a6b58ce15e5fd8c30696c1a86339919b044cdd0d88c5adf61344ef6f384d3d568dd128161d176d86cf36cf40b540a87a1cb4e74ac522e0a5886534e0bb89d869e06c4fda695d46e18ddd63e3fc623de65da435a471521f51a2dd36d6afdf7fab3e5d0ed99336a98baea57d0d2f4a165dd38d831d7f833ba7a53cddc6e22c42e71033b56cb6a1284c15ac8e08d2ca56285e65026337c8f0c7ed0df6242e796aa467bec340586a01015e91c595e6b309f1c3d0708ce424726a63a4af17d3623a1631e4f6b84efd42ca417ddfbcfe2123f3e8eb80539b5988859bfaed1658aa66f03b62255c97e659aa95ce840b92b27606c07bd919b0b5861eb38f0eda51f17bb32cdfc67eade2943b6b6b7b914cfc56bcd81c0328eed6b60bd252f7e2a3f2033cf7f8e21c309b5be3e40313ffc73c70d64ec9b147b0eb2e9b1219a14b8e2c84bf2e003ab01521ab7e26aba35f89e970d573b49ab6f4f13838d6fa12d9b2ebe8d2cd41944b072a70e201c60e10a90cf7da1edfe43e3d264f9ab5c7c7b41cb11ed2c23e66a349a5bfccf62aa8706a52229265a5432057162d6b93ab041970bb52246c30bbb799354c698439924360e3066a7aeacd9ce50b58adb7ee26bfd6d9c9ea3d39ed0051f65b8d67279da653f6c360a9c4cda4db5b723c05c3a552dfca3c41c4d8c9513e35b6868df36d8612f6a96cfc9315df4f8fa4020bdfacdc4bf7b8152e3aad861b6433c1d58a85a5214e686dec9100207194e9e000eca43c420e4dbc6e5a2ac78dc134ac6b21db48ea0d5a9c12ac0b006564e8fc6221735206b8add9994ef5dd1311d9705d0c527736882194d459dcf7382d688f429d0a17d722bfb53721b9e38702f7a37072aa2424c31bd924bacbfbaf66aa21f0681511a29530eb515ee01452417d4ff4ba35f1b72e3ff460f6667370506486ef3486bb42219dfac9ad266418f8f0c5a8f98313780177748d1458c08d4773fead28dea3abf6ae5520718042e37c070ac87f07f1c48fa063163d61dba245ccc7c7d3ab4586bd5ee29bd40259789805d7106af8d7e1c9dca8083c6e331952a52d1aaaad12af68d8e2c3f6fd9f6056b25787a1e195a931f3f7bd74c75838d26afcb2879e49ce802961f41699682ef88b4c413484addb92318b623630277cb70125650f52aa4835f1b55318664479bd9713bc02c6abd32f972b9fdf15215a7b0653565f00e66c4d5d4b2ac0741c7fa484538e185fc0168e3919372a2a6d4b76d84a4e77dae84086b6d785c9b6a4e27049d7bad6278ba5e592d7bc3034be92d8d1ba228ea24c350247b3e36ff429343d438efcec32e772f4ef3885a1407fcf198a18d571bc1b7b3a8d6c5e9fc9f5353a8b8a57488983d16dbcd16d635cc87d2665fbf3e04f2907112c0ed313ab24428a902c43a948d154455f33bf7ddf0c9b7da32d1ecbe6534b1766c3d5806318ec4c5dd85d9cdd3bd1d3c5b52f0e60377adb30b47b5d02dc04ea3f3cb43d0879c95df999c77a6293acfe22763cf03cf5c7be681c04251f4a4fe09f55b4ccc1daf40621b83674ab597550d21e6de4fc1923407a45fb3fb6125d0af721d8c6ac29f6448e4c2dc01b40ff178d6eb587762593d61db2e530f02873e84a799d5d90b766ca05c0bd4e91e760cf9f1dc86b6bb4dc50939d664046faad0f367a46d57b1c6a65a990a53d43e67b1ac20f5bc2e3d36c974b00016404f71b096d97d8f66e9ee25c188fa524a81a05939b701f8270e4099e3eb0b7a23ea2fdfbf9d5673302ef6e4e2bb2f3891e7ba3e37043371ef2cc6a6fb6035b2e03b454672fd84b1aaafed996fb204d82d79af00ccd580139a0b952bf946219e911ff6977f4613683143d7b15329fa96cbf3645ccc04bf35c5b07513ea2f89793d6d6522658dbab55e5b5c1f24d081a124018767a806a134987c894541d3ae09e5423ea7940607e18189a91f8594e524feda09b4cc3d6ea7b9218735da15090783728df1d312d3759152a0b3d506753786f31ba4edf9c2e4e4218db0e7a65d68d3be0de19d318386b91c9a14285accc577784bdc16522a17de10d7602187861c48c1e493918da411877eb44164ba18e6e33ca6f1866f0df5f4a263020fdca05e71c7582c50769e2be0263af6482a7bedd8dac6d577a51f345c46afb5607c20d41424208ef262dcccc8338750e8e0de430c7b9c08ffb0f555e48c747263fa6b04206134e9360936c7057d2d58dbe7b476740b6b0e5fd96a606c45980d3e21e50d4b051d3ccc2d8aa0cf4821da81afa361c1f122886f6ff0d3d9ba3bd8088ebd3fec8e2368dad035f8472379f3bf1a07f2706b5d284f86772b58395207ce120466777fdbed193241d92175879016d622e9dd003530f9afc3e3f9db2fe727806dc5003d3d82b98495122ef06fdb06cc7853f8387b8401f6f849b86998b494fdd0f773361dc6b4f85aa521217ae160b3442bf131e69c21b838b0300e511a0718b9c477873ca85ea517a335e805b2683a90dbd2fc5e1558df363ebbdaf1144f63c2898a8f22baf0090426807e4ab207e0be76e8446faf74b316f8fa1e2fd38ce6051088f7aabf90014da1882dbee716ea4ff0a7473d94fd14e47a9778e3e35046bec1180b56436058f12411452bfb7f75cfedced1bffefe4b6d7f8fd4bdb590df13e33f742475c51d07d3916180fe4a2b66561c136175fb6093cc4838d6a08c34bb44027f7428031b4caccbc26003ce2658ebcee6716d47305e6cd75be28181596e0d4f48ae476123703fdb87c804ac6f416f7c11765e2387607b69299b52883708cc22a88cdccd22f6892ae76a1755f4b6aa27708ba3f55ef3e474cd8e02a4556e0f59ef7815ed1660c5b4339b024d5f9f411f58aa4483d13307353e7451e563a796737932fabf88fcaf441958223e248cbad0f08badbd0adcc1a7dae3c705f2bb67f8d8405c6df755737268478b661e6e13182abb9b224b11d35a675aac6d493797b4be387652a4ae328ecec23d179925a21327dd388a35cd7e73d20305c9b8d326a3cf03086fe5191849d0fd208ecafc8dac92cc966b171340898fda03baf9e20e3a88e989a7b49a2da3fea6af2c56248407003b456fc3c2f2db981f22060aefd11af3e3fdf369b0b0396efdffb3ff3256d9631c9769616ac0eaa389e258a6d37d7cd373d1b861dbfe53a1c07f097811fe928dc4b1fdf4631961241dd333b9b63779125221622d672fc70865f2da96d3a4dd4040666301eb5e4f9d5d45b706fb3ed6c7beacde7ed940a62a5fb94bc882a9e93a591d4ba90f33c00c3eb8bc100430c4ed1f091764a27145ba899eaf3ec79fa7120d56d232d0d529d7cda7b460a13b6e38f8dd10dce8f2a09d186289b466ffde93f0d3ecbcaed6ae383e7597633463cbf6a1bab164498bffe8ec20695109e901d390130e9cfd5a6471eafad2fcfeb218c490395c46eac3135294526c470a083a042760c7624a69c2f9221e8683ada2d72238d8f605b7a03daad830f4fd11d4c7de8fa79d01b324857ab1f6d4e079621514edad64bb4f8af0ca7328b44a5cdd8aad12ce179f518ea6c2b0817b05ef0ded9bd9ed7c56e208e7205ff4c226f1edc76c75cc76ca944d03bbd92c35049a69df6a2e2675ca5350beb1d44dd851d5650f30cb3e4213bb991bcacbc71c800933809285a9803b332d8663aff8d63e825db916a1fda125be90df8d8fd473319878862da18855401e9b15e2d9eda785d0a3ef6dccf052486563c3ee8f937d35e2dc22b82f0178b722152d6d3c544bcebb42e2be562a48bfa36d01c5db5659b21fed97952888504f5df8434ac58de81e4c5889147c4b5ab80f8c7e1bf707c6f04004304ebafa588b8a2f5edd2d382c761fd97120367d1fecc8820e2e97dad5276aeaac3a42afe7919d187492ca09fa6d14bc50ed93702cf70d3b8bb2c9967d0874ed91530883ed4c47103ab90e20e603330cc697cb696aca29fffdb3dd58f6d85945485f0f2c4e00bb3b36bd1ae09a5aeb9e75201ff41ff73a7b79731c187e1ca186625e8e25af6d74559e6f65122c048d1a5ba12a27407002bfc0ecca321258c001734bdf01b1bdae67afba4cc0d2cd3e212df216fc0fa50d2144d63494143bc4ade3644f37ec1d5f15722a1fb1e12de0db53e9d456a45c2e12d62420a9fb0c844672ca71fbdb725756c2f2f1de68226b430317ef16a67d386a99057608526a8b4d6fd91df6e52db0553aa2050b41c7f43564bfdfcf6dad847a04a9b97c4c8f34e2edf3dba81cca716923e74c61de0826abefff6e62adfc85a36719be576e9829009e00e2f4a4b2a0d544f585f8705c53039506158f1d815e0fdb59a6ccf7e445ab1a43be2ec121faf056491f41b898afdc5a72d33c74568369418bc6eee39cb00135d0e64b40bbd588432646c0cf59b872ee43e3d3a8dd7749cf9d5672ad4cf1500e765992f5be681c1be8e67496cb2a2a57ad3158887571d6b52fd313532c8d615725adb530fbb8424b91c8ac862a0f250b8c4216d837870ccac474625382597c184f8b20fe0d44fd6f296543424e5071acfef3594f6c4d72499e5e930eb0e33c8ff5f9637ca79134340ae78722f027cb13e620947a35c3adc4c890247395e32034cbfd0811ad294943b472e7c62b7607cd928466bdb22298c363de751c1dd5464b072a4094b6f2a60c624a6d059bd7e75e02f08537427c4303eb68ff6a108a18296920603746d0c8223481554689","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
