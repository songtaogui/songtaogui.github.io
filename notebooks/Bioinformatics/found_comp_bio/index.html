<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc7207d6dc528dea1a06e50385801f99c7ea1121049542c2aed8382c0ab8259da9620be8a6c093b62de5bc2e70911aa5c0940d0133e4c7502e22ccdb8fdb4d5dc7550ae8d80d50637f93339bcb143ae2de1b30c6911316d86a47337f5e6e13f243923d52bf33e8ab102be01635a140e6ef123f4be51dfe16c820d1a93ca0fdc1e6fbf299b7531ab111934b1f6f4e48d1662cc8ede301ce19218e7d625ea484dc8a2bcbdb87a8bf5d5f857b08576e8d3d1ad639519abefe3872d16850c276d1ba7e2a0c83679f05f3aba461fa4b1aee568f5eeb3a9b66afff66c3d5e8ab640a2554fd7b5df7602b48262b427e4febf3f22a2fb11a9e796a0daef07c8dad52189d7d628d524d9ae3f45ee403bc6af17c1f07fac559f3133ed2b09e0cb1ee2e0aaafbffa05bfd8d0e51ae4e1aa6bfd01f0944b6e921e5489acd72f93c1937ed019d1ea5298c97a6fec20679fb8d40eb5fd56cc04bcfeede3e43e068abb6238bce6f714d12005fa8bd5325c67faf60b951487e69f3a0366176bdc895201a8a5d583c7df885e62e3a3991a962b7df9e78cd72a2040e741188795d767c7f9fe75d6f34534b5d4b7fac0e87da5943e3ded7a123f629323ed1c6a5aace2062bd07deb3dca4ca6c5be930b4a963d8f6a4a223dc575425716c073fc550aba34d8595ee18a78d2f8482e2d4f592f1f3a3eeb225bb300f0e5a82431789b582fc0df694ee9731ba977393d3339fb7efe7d8bb39850340d1a2e0a627c457da3687192a4f850bcc3a78019b52850856cfd849fd032fca79e869c0f33b44c5e74fbebc4260253b866b6c2022481560fb93051c377b53977b34b8b480105f2aefd9af5eb5e6be441e2af3a9a67904a901e929671d5d837e256ca7c6329540dbcf211368d931033ef2f22e4329506324c9a5cb3152a30d89045a0a8aeafdca087bd8b856f61653ad9b9c5abfcc1f7ef89b2af61267890868401f2bc4898d5c8a148cd272c28acbc82f5cce6951d87b362a95a6bfdbdd04f19990b35ca1713887af1f4776c6bc22e42930280f77752fda7ae562197f920d2e23637c8e71ecc169ad5379c98faec58a2a9dc412514d8c378e919ee16ab11f80c53d4207f4770c7138c62c3042eadbb74842f779f3e5d4bafd06980b0115a35cd3912339c5a9174a18d9df7595b8c051ea5c030d955bf37d2fd50818bff1bfbac1095fa99ba0054567e889643a019eed4fdf9118f2623532c5eb0ff0db34f2d223a42bfec95d041caff18aeb0fd3ba47043a2eb0013a36e63751893a40bc3b39a488729d5dd69f19ef5ceb411254823087519f50ba3e43e87250ee5becd84c94c4333583ce53eb5b30e990d80e89bf8c556e415bf487daa71b0b047946f1ccc0b80ddc926fd18bec36f803f32e7c90fb94b6d48670570480f5ac0b785500417a600851cf6800547a20f088889265f7f5dc9e40572b610af4a5bf4cbacbbae9cfb066256c0afb784dee55f2b9912167aa5f8a7a91d10c90f96a9f5c9c6526bca3fdca96e54292ad42dc2c5ddfc6cb019557ba60d8797271cff72c1bfa4f68a6f7ea5f08118413021de7e0c16642f5547ee0dbfb4f653bd4a2264b1a9541b20afbc56a8bc4511724fa8234577f04308cc131ff3236127affd482f9c7851285ece0d1e259c06d3b1ff8e156969b9eaa6c75c3378dfc044e37ba12bbc7e5639ba629329a2ffd4758a6e4c18b6b70e070eb560ad4c9e735d2a4d10750479ad382bfe05a9e89c66ca42a06576cf4988b4f19e189ecda975d96800f366d61648f50f0a47615694c565d409f8c242dcd16836d1d686ddfa24fcb572e3c9d2705edcd3b18373c8dac965b9af8a2034d5dde793192014f0690663378e539b383b0b3cf22c4b587280365bca8e262ea56d208ab45ef3d3c7e5cd5ff8d1eded5193d409198656f8da8e836d8d2dd20fae35343592f3e50b05a4a68e7f3b453d3abeba97762ec6ddceefe72ee41ad6de17ebe37e214099b786a52fee1343f30ca1a28ba2431378eef4f38abaec2b5271ef3afee7ddf9ef72407331afa0b59a38cef66d2f49d4256000d861695273d1bdf17359e7d4aa0458b0a39ab3bec2cb1b4f50a3a85b331abc83de7dd70344b36887e1a52e02a7795abb786e5d284183844b105b14e65d9f8f30b5bac5795d5c8a64087c830e82aeb038bb8c11c5b4025cc7e2eff5a8de6bc14b69ce4031bcc8e9ae3dc06fda151a1879fad9fe8cd7b849f518e9780a41cb0641e8b2e58ac97ae71dae53fc2dd2da1469f073c19f8a95a118ae87e248d7991a41361546d3726e5ed73d1c47007ad1e3d37f7a157709b6759f61d08b9e779cd84194a3c80924cc53c4b449c41be0840354c8f66b8ddd3c5d13d8dc4c756403605de1a075353a62fec0689e4293b02d61a159f14e5c6ea7a7face984129704008b5e8f7ae53d9864cbd8f73c29e820a230310b06d58b55f671ebf027c356261bcd6c71720c9640acd3fc7330cd79565df72453f61bf6f638e10833292de287dc225571ac4a5238a299dc29501d3c9179fa5f90773bd4975cd52fc67dec142ead92cbb153312eca5be09944bd0e415aaefd1247fd0a1def6db111fd75773dc4fe4b063d6112da1d3ae1fb25d85f5b1bd74e4ab427c7ce883ce8302b4616cfd3f2bc1d39902bbb4424fd8883ba77dcbf7620ff1112cdf2047053e3dab46e2ac73dc0400070d6ea9c34e7d5dc17c5956673ecb400f3992fa70b7cc70fb6a25c1f9f44fc172637949b5f8280230fed165efa103561e0193f004039697d5138ffe75725ce3a828230e4350f0e59b7884ca70f32853995f0e31a5069f3d790ac4fa79eb057c0face0c5f7c70b5cb2a4ed6a806ebc22bdfc4ab6f182ffc0333e2cb3605198faabb0b36a5a893800a53f20d693927787ecaa954e7c3c217ba5b01ec75dec2e561abb8d52080786364ae7fb69279b4c0ab2ccc4e2e7dc4d8adbb375c96e7c35be01f5dafe4d54759e2e8e3e411c2c24c9a00adefd3669309969c6fcd0bf338419ea170118308963b13171ac593ec89518762c725f933767009834617027a7602403c32c955a2876dd3925f0ced01fa7d0425b2018dff3e3e7f43894a42e359f5dcc6d310f2a2c53ed4548a56bd5c3e0d3feb58b1b886bda1d4fabbbd4eba1e825de59fe878acf923ff8c0622577deabaeb2a33cb13dda661eb039c36b13b0ff1c369a288035d49a5c208026bcca2886469809611925fe61a443f1adab3808c4bb5570d9d1f27d1248fe7fea91ad1967278687a8137db82cb5fe7d10ecf8e457a50daa8377a80f794e179a8d50aaa45592a64c2cfc77a93dd7aaec53c3af70ec24b65a3225c82d51956367bce8d3b51e2246ce7d57426c4a32123899415a7f50b27d1a5efadece17310fae757bb783509d323b574d6063866b65f1964b4d2bbdb369ca81930f24a57e42647b10cf8dcf6c7ccf2d0730691861737dd3d407ebffa70d6d4e60dd89013adf276f41a6863d5639abb19da2b773d82083f5d1e6a7db41eadc8a527b89df21a80799d818e6e357aa3210558837ffb67a775ed3c811cccd864b9b81767fff3977bec67d0442413dfcff166a678b9b427ac9f80d9f788042414b8c3cb72490e4b48004c31906b3ba710e99855a56cb3c0ed1e9c324b28c7be01aa5a9d832d0824e1608071aeab4bda187609b802b6fd86c006502601a48d769ed6998f7afb7003141c47f7927ce7d04c58a42aaae09aa728318ee975e1438b2f54ef711acad013bfe52009bf09ab9d2ab380131559f6f6db7efb7b39f2197d9902a6604deab791bb411ec1817915b37edb8c5579f13dac4d85ecf6d21c30e32319e135dfc6175c0ef29f01e8aa06c79240602a1df9b17a068693ad1eabcb61c2640618610575a4bd7e907918d5a71761b5d1348ea912d515a2088bc067bd3d90eabcd0a3c8945f856d8bf4669ea8b828fd9db785d3dc759499601a3364d9e942e89a893fca2273554424becbbbbe05a2c89ace0e8b6a2afe905b0a4b25f21180d848e89aad0742ecf8db6804ad26479561b75cb37122fdb1e74221c399281ecd74574c8d7bf6ef97f7ec163bf8168ad8896517fdc9c60e5a2bd0459e5b0ccd846c841862ed0b26cafb77b0fb2a0e214035a858cc56a34b9350dc41b1311ef5118ad4de5da548ecf0882789bd3b680916404b7072e60a276a5fc5e7e5932db59073ca5324c61441f7e1a0d056904af0e6b2f985ca920bb856f3d3db5f4700d4d3d2b51f7feaecb282b72e520ce49a5f8c72482da683d1edc8ba6dcbed76957b8f74e2ad33e7e82669c98ebae767d1ee075f5c975286c7ec21fe50c25e693d72cb6a554ecbc25a53860a62b2709434838b68bda64f5abb6b697704812e61f0598536a833166c84ba9eef69cb2a420e13007f8bcc8ac8df6eacdc2961636b9168a7bde25dcb9a2e1db0ab0614124df571165e23a962103637c15205e116d0576320026ba0f1d912b56eb6eb364a28710eacde8487fce01d22f55bb630b73516150e3b54a96edea77df241dbe459f42021b2b0b35abe564f5e8dd3d283a224c84fe2b9b2d9e963d2d556b8d8338d9850b4686814a26a6651df22efd9ac568ecdfa6e2116730ca19c5456c40a0941691b8741334e6bcf4152980363b3b7fdad5cad3871c30a9cf50fa7107e67bb9f8ef81874e625deb8f797cf68ec4b0b0a63dc8203d9fb2d35108232b583902c1cd1863f7c1af270ef7bad84bd32f000a41a646b72c41bf3aba5c1b2e9e45e73ba48dd7eafeb663f0fab4f927465c9da396a42f7016076df1afb0e1b0936b81fbd0fdd41d48b068ea9d7cab7a60b395657e6fb02cde130fd5a3458405a68b6b77ca068089e42428d4071a586d1f5fb01d3b6b93c2c38d7eb1b056ca5e75e53b2aa5e81acd99368fbffe15c0a912f3574eb42cfcf9f7586853fb0a3b379ba7903c8ed3823f1dd80bbbedb15541b5cd4cbb2c8730c927d289c565b012b9a15b89ef3638929d6f370611c71847b52f9e15db1c8078d76e9b4d1c67e4272f9996b308f11ad5ef9063a3f42eb6d3ec2b6d77d7b4616b5a70907e28d43c7be29b98d9c5748540e0b26e11a724db6ef81d5fd5642c76c36cc57efaac8c5a235a028a3520ac26f7a13e0224157c9d96c501f111303216bdfecfacfeb2141377f56af05edd3d0e946a3780d1daba7f3b635a3a0886857a44b81b3a7685e4fa38a80f91cb6dc863ace0045f7323cb2951b75b129aa59694cb91669028d8e3bcabb553e67a56c23f67b424134ec3f94a3295fb71d82780aa79852093c498e32095b7a3e6aa3aa4f2fc1aea5e66c3b3bea6901d622539933fcf4414f86bd09da10045ffd3d8d45b0d2ddecf6a51cc4f55b5cb7dbda00078c4b4d0411f83ef8a1e3a9f468bb22d08797805f262b9f755569754be3d57a5ecc0cde21a2cb4334c45ef146d450596f00f0b213e4d79505d055292a6eb374b233a4fcd726cdb3820d8f3d68247414d24da0ebcdbeccb8bf942c3f47ef0c708111e0d521aa673db248a0d7d39d65025a5eb48482a09e0b96a9e0a1917fd002be64538f78ecd5810172cd42810792b739a5ad4e5306b72514818c6ff151060b4628a293ccfde3866bfd5f96b3b393c08695ddf9c839fc8ced2e9ce72b2ef1ec2e0559c2d3da2be48c16e02a8ec7da0d15e3c608c722ac3f8ca482b34013b91b3d7a19cc69c5da443002b7b09dd6b61fa68b04fa10031972c3d683900c87733067dea83267b641bea29d780ff133862c16ce23f6826dcca0a2407154caaba35819d8873bd9a03e7017b96fedf370a2460ed875be4af4706f66ca216844477561c264e30a5059a62bbd099913a5a457ebf39c10a605b1ab13c5e793b1a23b845ff7ca9faf5b7f0c27b958b9b2d40b052cb294366be4656808bce192d146e9bf930d83850e48f7f7ef383a466c832173737509262f2788a196b71eb415bfc469b22c69806f41176525a70f52b1fb21b5c7fbe4c34f2d8a356fccddbf29c1ddfcfffac2f01162334a916d1f1f667c0ded3f06c5156ddc2b5332515c5863b0e1f39e76a397a212190620f8146de82ced1b8f6718308b18803775c0edbd1433f1c1abdbc6a9973c60967ab8d1810269c75b7e9bfb48251408174d3375fce2f5a443b3515cb70c0cad9e2117eb07b5797e548affe0857efaffe95226b392b8916e306f959d9f06bf5f4f34487f291aaed80187cd247c2597bc6fe8e9d30e927cf4f9577e81b8b35abf3e419aaa3b4606bb4c7962f27eafb3e54ab7a1e89410adbfc78b78934c41ccf9b6d71f2b5fda380abf2d8700169b4db1352128bb2fe645428b3def90cdab0b56184d4306c24e8ae8966ce5e4570f805922bfd1775b72d0ca33452bbf1333410b4a4ae3fb8899cb1b2a7db601db6aba81bee90b91988c077f94d19b5853d67ced55c143945d5c86e64dfb98799c501b313d95a1c14550d6d0a16d51ad3d2714cf4fd541f4b5275ef6eb169c9f92447da0f8e556c2357d13a3398c98ee3bef40bbe60c2ed3eeb4521df040a6bdc80bb95361c390dc54a4e610f5e734f61b3ba5ab6e0e07e4586fab83500bb372fa9c0b41263b3e4b13156ad7cc68c0134af5cb96e77309064f608b3454b1a04a546bebbf028e198244e788b0d5567b17854c603450de6a0d0aa1d1032168e7d812d4340db06b1dfcf2080a06335532f73a73da003ced177b562eb4bc8d126c59fa0e8467226a5d9d0b8d831cb4c6cd460f6146a8342daea096d5141073b3a5b202610bf4f9423b480d29053ae261fb4e8bb868acb6e83acecd753664406e8468b6ee6c7738c5bea50b6f3255d93c4e5d92f883072923e5fbcde5597b45ea68514d6350fe70c500f63e3356b3a40041337c13b3a5aeab18574b6ab1d4e1645cb529797b959e7181df26b9199f882c2269c7c669a8535d5eaf14fd78221c87bd24b9923647b700f9305aa51cb19853d5f875dc6b8c4e082a210feaa6e3cffa097ba52995106c788674261ca3cca43ff7951a29015d834251439562857ed2740fee5b0d2b2b3d86baf0a44f6e44fa218181a47d34673f40897be835a0afb1450f745824094d1eba96878bf1e14a95815da763ecce663adbe97c84bd69141f19e7cd9c1f465385bf0702d46913bc145a253c90683a4307929a5e1e5ea84698678f0e72005116bba523afbf44d4e6bfe353582bb38a8b96a5eec348e212e5e1fa16414c4ea16582cd0ecee4ff3a2fdd6b489684082bbed3af22edef18831b2ae3c9b65189f757b4410167eb43d96032c248b4539de6b69344df9bb9a6f06eaf82c310e5338863157398e9d897083a7ae7b2ad198f5cfa94c4c8c25212d13e08fe2092927aa74b81df797dcb55d90bd3ff151cd9a4f25a74cc66290f316aaf931a8c68bdee43f3f5638c28da4b80285b7cacf0d537a44e8d9d82fee9114c33356657f87e7001815b40dd4c41e8df78287eff23da43fce9d31a7130afcff2064df5cdcf20c29dbad8d607e854f93c3304b90577ec4960813a6671d4d035db859349ebc61dac6c7731ae46c32f0ddecb9c3797d4b334da7de6e3a631e5ddff8b8826191235d086f94591a4bce31c3937e1e6c75a9c273c33f09e32404ae1d1ad148751943d96b75cd7812a9eb69343f6f8185d66f4eee882815ac68b3b4bac5a19246cf3a214ec7d812ec85d3e4edd48c5d40b4f5b53da9f0a1ac65644b1271091163c74925bf2b61f488ec876336a6e79b4385d3799576ea2c4e66bc319dd6fd60fbf32b05a427b6c28ef0241b2951516774ed8b4189c728b733103d043ee54812aae00a22ea41ab5240d24ef7825e3de1793e91e5b7092ff2cb11592f256ff67b19bfb019ea2c05fdcf06cc20687524b8fe6c24c7071f314ab4e7d66bfc3bd898ddb1c80fdb08cde2514e526b6449aa2260943ce75869fff9d42a425b16759bb3a20a01732cba0399f84a487837552819431928ac0cfa0d4288e705f10ea17d3fc47b3d360103e6fb837af2dd11b148c914ed572282a28853eb95b4c7ea62befc1d115959faa419c4c49a6cd5b543406b9cc909eff9af4f212ce555a7bbe90e4544d6b65b8bc4eef9c11b54fa661e59a2285e79c4e9566ea6d566708f58850caa28b83009778c03b27d9d066f0831c2d26d8bf5e4382995bba969e45ae8ae088f45be397b368adaca11b742665dfa670a45d8000f5c7cbf50813008e33fd8b2a38e4c0990dd152332ec19f1b953ec7c1d26a5eb1c5f0196ecffc32b6d04dbb05b9cf85e711261c09ae468028aafda03f93642f045b5a2d926db803b8b3dfe966107e7a203b6c0dc785dc2135bd0de7b38dbc8e15763a1b6493b9e5fc1efa701311c729f6984a571f6fab16d0a2b3696279a6a49a5ec9f36e3fbef479b8313723088a0d39d36d5e8a66c2defb440c649d65b0b26d3e1bd5f30568a25211894ed26b363239f585c6bf1a01f96448c5a928e1238f913f16cf3b734cc7fa4d210f30b0d6b1ae2f6eef9f8149b37612e8e06f2f760dadee29f560a4c628c126fac777c9ca395ef43aeed9672f0e6e92718084e598a11e08dbfb2f41c1aa9276af6d73fa0a605f50cee57b362d79e4c83af95b37361ce2742706a861a88fdbc725866fde4b8b466da870d7a82dde1bdd484b6b73368b8cdb6f818f8ff421424d1ed16f1c2cf2d72eb01f0f3a1bc5c200ca69a6d6df8c8bd8f1bed0569dc3c07284074eedf165b7094929591390ba987c6a2fc29d271bff85c26946c3992cb35dcb9382114ce29617cc0ce286b1c9324fa50dfff1be00e4ac47978931944503104d296407411dc4f2026a8db619ff1a78af34c0819f6227db38024bbe47a3a6a842ca4eb294bdd001328f2cf84cc6527452a99cb469cb7d4ecaf88047fc271909574d0b91ebfeba438441e3639c56091011e9f7c489215a303c39bcf4473e3c8e1a1694d703a45e074674a1031706d4e1b1edb6a1f91404ac135e33a666518dfa462c5463fea27ee1c3ae3e2595a292d809ca2597f68aa90676cbcbdeaeab5f6a2cb74fb6c931a495cd9b9d5b7f1acc14855496ef7ed790b7968e8046e19ffb1f243e1b65226a5a25b23f6510078eeb74dd6c0a7f948918d0ac014910a49a93d396c5c9f37d32cdcb45d03070aa75cc0294a8254d2f2f47428ce66895d452a430642e26cfd9cc60b3ca083ed18981639a04f93006573f1a820b14739ff6d91bbfafd2292afe49172b8fc5aa500bdf361624b3442adae1469e4fac00c9506932c9b6bc688e5a0c9b7782f34680327a292d2692019b1beb38609919c51ff55a6268446e9225a95d3cf0e220226a0bb2c732bf8f1f192ec2e2b1b50eff56b801b079ac1b38b1d8b99a44cb0adff35ece353f71e8bfa256089688b359b865eb8af4af9bef416630c3dfad26211220f49ba685e5617067bed20aaa6eaebdec4663b6fa08e3bdf5f44c3e5d5284a368e10bd1e27631e2292b0d204c77a9e3b09bbc76abbc1cdb0e03222697311825defd52df71517a87b2fcf885f2ad2f8c2a95633dff4561f8b50b8e12e012e1ec7be81a0b83508e9e535637fe51dd8a7b7335ec621c038e10b31d6e02b49b0760513c0bbb3b795b6cc6881ba1b38edb435c85ec7155859836d171a630612756591178864e204b44623d5583554e5d16a6dd0d8a05acc04a4b6653fc04f334d1464edf8a529496a18333755831ad976ad5e7dc71bb993fdbc6df76123e1a6a8958d285ef049e723499e1213895dd2df73c8cae232f69fc9fcbf54b88b48dff55ea51047e4b2bc30d8473944c1c2aa2b688cd6326b71dee8c178b1afc6ac4b9866c8e1bf3213ce77dc9a4db98d25740310d1eb96b2539eb3bcedba6d82ebb91b4c2c5375c4ec0e0644c913d789f04c5aa1a2f29feadb0b99d0bd8cbffdd75cb80978f83a570b52a211ba1581a4948b5ca94c38e16f92434984266c433f5d462b190096e9511e3b9ce1c3a6cbf00c74f4ab0705064bbf2ab78d23fd90c08a49bd05a8645b20dfb1661127d9a678835f342c5fe3687331a07b5a22f86b6c1344b2b7d9b7d137d84b578a71a17de01c8966b8dba3912b5cd45bd99964404f8cc92347b4212c1729f4a3c97fbee91c24bf77a3cf6da74b5bd143aa24ef4dceaa4dce29980ad1c224d3b1199806a02b1a4872838ca99ce5de5e21f761f76758852c21f07f13f11d0e5dbc9f7b78f7beec0e6f0d23fb32ae8ad78832ff30c6983bef22ea3f1778b1d4247bbc90a24aa64b26e9bbc15d2c05aa34d2447294e081f4b5bda3d993eb1fc5f98e47eb4a77f9ad55307c7e209ff4cff3463ca2c2624712a183b6813d6c546245f22e92effe90dd90e5cad7088edaf6cc140c77e6cf3499ed8de062364d286879eff4eb121ab30d1ebfe2a81081c8c161c7f3a8a8663c7749b7aeeb8bac42336d9876765cf7781d263f9781434f8630da0fd679e0aca5561794155cad9790feaeaa46d547208fb6234131be4ceca130463cacc7d1847f3fc17f476b20fe25c7221d5416e08d5321818839c21a0d49c872b2d6cca05eadec892f2ce2c2bd6ea65e34baad9f22abf648645e11e254c44c7914d1a58068e33448a959ccdb16a56c1e24587cd5854a7533b2fe730434650f8091354b54ec509105d00e139f29792824704e670ba001388026e7265a2bf399d89ffc00a319ec26847f65aafbb80f4720625edf914a2f870b6a6b0d7d844f97105bf2454cbac89fb428e6dd9caeb7c639957d40a95935cb0fccaae706f4de15f10ad36a9b79e4b426d9499bd50b6004372023bc85a41878880eb0d245f9dc149a3a380c1cedb03f70e5ab09e77050a22f33c5f7a9d62ec910054a48fe9a8a57738eb702338448cbf890ff9b0eea52934f67f1bf1e72a5fc78960c9e457ea6e764bfa0595ed0a25b8c70b8ed60c6fe5da98ac253210b38750058184930ed34a75c5e4b3ebe0d98eb91d7ff3ac1cfb950e4b68127403e0199b492e00114a2061c0e86a1dac5b8d4dfc4fe3cd4b466b535f56a081f461721673f8cff7cd34dd967d9d5ff5f68029b1a86fe083a7c805257744619192688ccc24f17a7cc1766ec0eb052493584553934324babbb9b18ba9d6bb8f1cc6bf4189c19c19d5079aa5688aec73355b2c3dd0a6a24daa6fc8760c3dc9bbce237a4f2213ae6c88a7c95a055c10e04082ad8cd4ff9e9f8d280c0f3fa6af051e63672a764a41b5a01e783e555bf8615fa8a3ceab858da5d19035b23715379027bc6bcf6a5999eabaea6ea085c312ecdcf6d032ec719e5860ca5236ac18d761fd07ea5efd2a8431bff081c39e386dd2f2c90c36a55df1b30848f3e2e0d78976a5a85e218eb72663d8631d4b42d89b383e2f5eb58f7a1e05fb394d134fa20b6dace79e020b5722077bf51f8f35a5c3960e59f52d5ad49aecda2e2c0ab417bf77bedd202d2cec12b73369f7f8e60e27e2c4001ff32c25a7a5f13a98166954b95ef2792a2bf026daf892a616baf8d0752f947f23d6e501f6d5ed2381d3e0c32ac43027f0ba40c4a13c73282730924c499f5264f1cde9fe93cc533e222c4c3602046a2fab5e484bba633a1fb944bb74f38206d931de4b3bff11cbdd743065a88d6302b9b57f17d42f37b44b260416ab51f2ef66d7fc2cb289826c97bd854815da66efc799efa05d8305b09879709a378f5f5d87eac2d5d1cfa366f3c1eb6fe0bac577b8b86bfcc1e37dcb91eccf647c6d7ccfe7893e0f12dbc06359e8cd861e56e71df6d64fac3f998c70d21bc07aef528025c075024a83c25a9a44ab08a1d68bcfb7f32985f893f7237634852c64444bb753ddda24d3ef36eba9816b6149c72a8b34d64eb39def9486f20a3c5edb3ea770213c78589cf829e6b3ec272637f54c90dad6a700bd91141360853629371c1edbf0629cc39ed83607c7b98de3c0a8bd1e9e248ee398cdb719cb615a1e5f020804d142aa570144bc22fd8a7db568bb6920e09843e79dd0817a924c22929e34896a9b5866f7f04c449bc7035523aa9be40fd1f9db882f0943a7949ff3869587b4bf42e509d606c55680e3527e0b946e14ce80a959378b5e26504cce106ca252886884426e4282792fb76f53ef02112b2bc894779f5e5b1d447b66c345903c0ab1699c79df2cd328e6dac6cabdc383252bb1d8cfff57992dc8a1e2554a7a4ae1b00d31aef9744edace60dd343ee6a28577a6661a17ae6c9d491e287bb397e3a3fcd72d23cf201a1a0715ab1d4bab29964d2f2234cdb564eb9b7130e3c80557265211fe7419445ea36fb21fc67dec649af21c24dc747143fbf13b6ebbc35c30f3fde204929350b7e857d6e8a429210fded5c9cd7982c73664cd7dbd099744253a2f42de17ee0b37aff3fbb72a1b95aa15fe00463601341128ac1072d465ad8b45ebdc61302f034aed123aa92f8558e6c0dc3661019806abc9fa022ca2a030f33f35f9c7b4c04607103b91527dd8ec0d18ca57990a91017c1b35c43740a8381c889c3f8f2396dfc06fdf2257689962f35fbcc1c603d287b61f1fa77950e8513f746d073dd47e414be872b97dbb6cd90990581a9e7819d63f4dba57fe09d001edb2081c95f1229d129018125e174251123bd1796ef2f6e3d01cfaae431f8f9ef38154738a6064cf392f2cc2140c4461303fe2d01fbd5a282fce0bf9e4127880f5fa4c3fda43334b189c718659d28de9490aa30ec29f4dc5ee81799a20741813c114d3265f6e9bafc1d4a7b78a1cbbd46de8bd2bbd22e705e46ce656b41c0b1a9f2bca56cadedc6d79412d84b36d113f57e1bd9bc79ddddb8ef96b5ce1798161b13f50ca127987b215b06723497f4e8f3a703e0fd3dc18670d9511493cef03c8d6428e2d9bf704d6cf854dc1d8e34d0e3b48681642c60c4e5ec025e8b8409930997c28d929323db5d5300182acfa21ec27b00a19363cab81d3806a66bda9bb35a3929f64cc405d6930d78a75714f44c63a727aeab292570262e236953c195542245f7c462f9355005126b8e0c059a4ecba97bc22d1adf7ab81035bca633eb173d351c4fec0e2cb156f5c027e9c357555250bb1296077ee84820159933b83603557c2bef97c2bb286225122e7842ec1d05afb96eb6413206a84141f5e360181110dab0984e01f3847ecdaef36639550709414e7ea550f64ad3b968992122bd55889550670e04cbb50d2e835e2781e8e9b34b4a07f0647bb50e929dcbd434db4643d7be8c7ab1e940134358b8048eaccc6ed9e7a21a20ab3cb8e2ef94d7522ecdfb6b956cb9f90213a789f0ca897bb6c86bc88a55018f638c1691d58e7aca821221ba94b859753fcdc8324a4ef9317628bc6c5db14af6baaac4c83cb6a5a4c2fdfc3738bed2d2b43502d27017f6491740b9a53a33a2471b2dee47d6c93817cfdd0a612c7af08e4cebf2c3dd8eb7a88ae912f17b32ded7e556727196069cc1a30ceb8fb7e18f2f0bd0e87fdfd5d99d1fd3afab7f4ed1e02f242582bf7b1e26a3201b5c43aadb3e32e8d18a24a75664a4b208981d3ac624731c634f81609b4e747fa18eeaccb215d4fb44bf1d08f2a0373ed6e59177fa729c18f81dcc3858e0491e7631864e1c6e21df55b1a9a504e924d35b936b4cc54916eb574ffdb7f0e56168fe8c96ac00560086975780990dc5b82f058539f97ac4c7e852c752436745c241d2922ca5c53909ae464b24fbe49dfa2ca8f9a096e05d841d24f62fe66ba9769a63326e486a73fa66864830b59de866a151207824712d4d25914dca64d9d22daabf860a0a69a1ff8d35998618551eb90618db8c49a6d90095082064b01e32b1ea000da683e8df3d1c45af62a6e4ea5544f1fcb8d38f9270298bb7d38c5b9a127a32c7d8ca54ab9a5f95f2c5da903f5586537947a28a8bd00a4bd271adddb4ce2272484f051d3b299b168388c139f8b1291c20ad6d2244225d62a6220cf46f929cf965fe83e5e6b0dc6ed911daaf985443c204462f87bebc2bf044950dab44d4823860073806a62573bc6272082b659ddd99b119c33ed6dc2e0482cb4f4bc6c8fddbcf5715e93b0aafa2bfe634d69ffbe5874dee70c86c5a0bf8de215e89b7ee251bc139e6d6dc947320f59457a44fc27311c707c7ac40ca07e976dac9872495a1186861afa1268c89e1afe49f02ce17d420fca3e933707b904447835bfd24d56a029a876ab854ffd3de5d1a400a9f30ab1b07621eb9aad69bafe1bde649aafdcdd824f4f3d2126b3bdcafbcbdbd6336fcf2254f09278de6e3c621b7294c887c4aa735f34a143a6903ef4762b225bac0847074bc471db4dac4b0098caffb813d10fbe268df095e3239792a828b6374d0d46e60703961f3e1b8605b06397af88792144038f312c65b317dc933e440064c7e5522520849462594dc384510f04c1a263bc919d41c8b63ce457ee3bf75a892f8b85563f6ea2052637fc2331bee4c14a760b59a950fe489fff05d20e81041bb93db2637a73de2d725db21bfd172c41784fb9262062d8e935b93f818df67f47655fab5df9816eb8f1dd126d8eed36ba35eb5db51f1fb5feccfc6d77c00d999cab40c99117bf8853c8c4b9bf254c6581ea4b5d1b13c13ba8ab1f1aafcfa9e0b03e235a6d148e3d43503812323b947f6448527e70d8f03221c09d10d1d52ec417bd19b58d36cde5aa9ed5b86911549ae8611f4b4d1ae7ab8c4e8789e6f4c85b4314b3fdfd745d8583d018f66610ba1ff2c1264fd6da01db27720a8f0f5d7e630587e8b7c0c0d09b2fe8672fd29dc8f271502bf6783b639b22f82d9100985ad01dfcab283a03c57de73468dcc4efc340761e7ad9bbd63f8f4532175174768cefd2195620bbafb14b7b284a44ad15d4df04450e550370921278a86a47eab6cf69899402a7ba6abb5dd206652e749cf550ba0d05e020a6307ca250a54aef12169a735ce62bcd5b9073d2a2aa2398c0519f93636a515d0c5994ccbda1cc2c08b277d41455652b34eb06ce76c973334af26b91c8b8d4c344adad6edb8e84beb8c5cd4c74b4915f1da1db3ea22b72647fc1adf8b277c38ae65c5b49766cd457b0db2d1516e5b61903c3c470bb9f92df51c1b9ae311413e399910e754a5948d5aef5e1e44664ed227ad556fd997122caa34a66ef4e02215ae9e34630c36922b99f63a21184d520b1f7fcbcda405c94fc65ca697d27c9782ec50524a3b71b4255f2272d67daf5d1f0a94bb8dffdb131a7854de1e617a8ada16ec5b4dbb34d93e3d6d6de3ee72bedc7d80291eaae4e517898cc7c4355a0358f61b6b5e19098c78579e07aba5824e8b27f62837083ecf26bfa85df5aac9aa84bd76f06432401efdfdf9efe0fe06b807a6ad487f50f2bde06fab242f83c71c3ba5bd5771b998639db6bef8ba64488a9b26cc576feb1cb219b8ba3c6a5aca62fad64fcf0497c3af4aa5df472e4b03c47203e9fca92224ad674492b20d388a469428ad19a825ddec3fe26df1ba6d64a582e60a8b80b3dee9f711017394e5896257be1f62f84bff2945145c7d6c4cc0923e6b9bae2deb6f3f3ba61507dbcf8a134360431a09ad015d6673ec0c04e0f4673312617575b11f12042430212a0349af4c28372a6bfb77e5cdf928cf2c730c535cc9ef36cca7bf9d963002fbec8c81a4731b9e30aa3efd08a8864935a93ce40c56ec6eeffb2ae92802ad8b4a4e4388dbc7abc79089c87daaf5c188dc18e0cb9d44ccdf13c058a68d95ecb16cd36927c73cfabe1dac3bf1402aa14478f8f9f6efac5dd403b2aa73bfb7bc1fd05249541ffdd190cdf847a3995206bf57a1b7e542e2771fc9ab05b036c43a8e5d3e56dd81eb56f472705e6481a1af557ed250163ba946725c73f0732cf21622bc9f106728c63df0501c3126cf6bbe619ce2be9bce3504863d6b20ba7f307f7cdc8c961e83bf2de2293269a6ee6c8dc49ce3fa1f75072ed6155528a9eeee50d0b38b4d9b5ef21ee34500dedbaff52e191fec750938dcb9ab19b77a7f55f87ac641b5d98a2cb3ac646580f3168b4a83ea7588340ce1694336c603272dcd6db7c6b02c90c3c0a694b8d3916a60c3414e7c30ebc2e3d2b7c6deaaef9978f21a5c1b6b1595f49be36ea0b102a34068c80a4ad0f5f61bd8117857e63c6cf1d2023603adf3e87585518b23b0bbf7b91d876a18cd67caa7c9337ec5f1579f00214f6c92b67721cfdc6d436bf5a627f812e18099971ad40b26d2e84017e1554530296ac59959d2f8d672c7b4f42f9f388df360c35003c864d898811b0b6776f155ef830f23dc5e6ef25115d0b866f44a9898a641d57760790d52cdbdb1b3070aa6de353e4b0a9f5551237bfd5fb78953f489ff8b2535277a5736b06cae821081c89f585afeda5d2645dbf1fb33322aecc03673af8d8824180befd5252883eb2eb8613e4ff30d04afd69f72c53f43f372b6c3039fdcee8702b27fa29549520b9eb11ef53593e5f879dc9a434c1084fb262342d547fc8b99c4dfeb4fb39477846bc2896441bbe5d90ee5e64ffd0e57acc2ca77113d3718a94ec9a38eeaf709998e6d5e4c1317bcbfc79a98f5abb873ba240d750b25d538076fcd5919ca7704ba30044525cfca6d84d3d3753d9064a771a8a733176f5eff6c0a42eab4c918f8521a5623d5bac91ce85184d4a8d5090dba0962fbfb7375664e894a96fbbe4eab5d65d9ba347b752985462408158e697a07b15cfba1a839612894755779754d0a6abae081ccf2e8814f342ba8fc57348bf4dcea55b1202b0d170bbe19d2968b6d0da7daabb85b8ea30410cb3fb1f830496836ecd6bb470708ca9a0bd0a5f850395ceac539e19748c0047bd8730a79bfa4a49b85e09786425eaf97fedd84c0d7198f90992d117b9a249f798e9efff24f9bbce0e22bcdd4c80aa35b03c91aa5a77832c42cfef48d6f5c9d66314f2c541cdac18bea53e9bf39991d481a58855a57ba7ffa83d6b4c005501c4d9025408890949f8f4895d9c4fced474fd6755816f86504200b546f49aac7824e8f6ef8f6a300fcdd797cd9f7184ad1e8119d40a571980f5111ac4ff27b6c338ab9210c61bcf42c61a4d75cce04e6299c3fb76106bdfb22391efe50ecb88d7f6b08c1592cb0761f8e49c73f6c76e809ee4c1e5eafe825616416c03335dabe557b2faa3287609125114cc75263637fc6fc6bfa4a60ae3b9188a8670d5612680539b4340bcb5b739827e1fc33cba7e1d01997ad7328312098c97a9bd6962fbffd6b14ac0bcc9f0855912931212b534243f11a2964fac996f6eaaaf83165cdff3fb6839f925328c53522cfcd3a9e587384d3654b4da20ad429fe07a1525f7943bbabfce797c330544ea042d977cd1cee52043481e4e92a29d1a22fa98c1c5fb2c640f0266f3f6c4f713488b0cd782d2c3aa8b3e18ff862100c8faad99b994559ee8c8b4036c42450cd18b3d2e1ca5907906860f205f1423416a56a1ca491c0258813a4cc7b02b6ef36adaced076df2f6b49c598c3e80cf1c153d14e5d64c381cc054d2f2816c89ea3c6bacadb4de01c2a8123b770a2dc8bc3d8d826fc5cfa5b6d32f06c127051c4ef06aae1f9d1eba38c589da09ca23781596246c81f8e10d4ac626af827c6a3eb747fa8f7bd2d24a08fb9d556b233fc1b90777fcade9b9eb3b3f37672a19294466d80e7db24b9cf2ef584fc635c99165002d35f1364e6bdb75d3306aa46986726eb9ce62eb088573aec3614a3f1351794d9de490671b2cde100d8a6027faf78b6b61deff7799ed823a417605514fef7dd7c9d0b6c2e009c5d99d331c7ed99b0fca1a205f7ba92f54050d157474540569069e71be92d38f532270d91e7d6e012c92c60a3c084f89c0841c359e8a782dc54159aab95410838e6266a9c202b4eae6be38d86323260cdda7f23bda66603863ad0c8867f08126b8f7ba25ec522085e454fba1496468dcc6f865de01489337ef517419e3431c23007400d33a32e303e3b37e11516746a578603fa0189ca3bf1bcb1e3a5be3df6f97bc75308b5a8ff3b70e48b6fa532e764242566723b73dc178052c5da08ccfe449389a70a39edc6cbec0b78d24dfc0a2f93607043539899f21f0b97c7e19452a84380d1a79d4c9a556d8abb3ca8cfa9ebd826db12d32dc00c3349d54ed5e0d529d7902f70976113a03ae6da73425baf02b714d61d72d12717e9286f7aa6a20ef9b1ac56d3e7be64cc29b16b90697897e323e09ccc8e3acf9345a82b5f7529e27ef85ee3287dd5f498a82e3832b56afda24d7b4ce640809faee9688df9c0178d4f3c343e0425758ed21161320bb0ff0f43ce2699285122ad64db8dc9ff5283436c095369803d4506c0615fee0643dab23976452fadd5ef75e4cd0a7007bcb4588dd9aabc4c199abb497e91889c87eeb4bd3d5b4386482653aa90e0ce","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
