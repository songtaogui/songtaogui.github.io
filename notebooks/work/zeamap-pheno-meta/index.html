<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b64777b001d7bf031242deba4a1e69859d0f5f190202a88fdb455075d0efb060dbbb47e33ca46b5ca8c69fa53642ae5d2354060e709b20fbf0e807bd3ba527b9adc7cffcbeff8019e36e85f487dac7472f1f3b69e77fa1a744ed80c4ccd561b3a8cc5cbac044d5fc264fbc7560c79fa19277d7cccb81d770b255e9677146a3e1b1161656c98571ef35ec9ad3c94aa6860c85fcbd40cd6d94123c7d3ba38b4f51f29925b81dbed4cf9f3b5124358b967a6477e296b64dc478705a6eb0f5069c72eaff8fcdde36c9fcd7df7b7c2e914b9e8412a61f31d5062691db1892f743808f63a76cc11e385447f7367044fc21763beffec762d123d073c784001fe073354188511a986bc4cc522f884aba6fd883f6717014fca6487302ae1e5ccfd95ba46bbf95bfb6a256369088ddd3e75b599d64cf46cd9c180abad1b96c1859a1016c7e2e79b99abb9d9f65af044d5771b7bfca1c44fd43f9f3713a4469d06c14175a9e2ff3121e498ac9920c9bacb73d4bc9098088aa9ebe3ae21158ce7f7211f0cc2c9e11943f5c5bc6fc82a9d45ab069262e136de1ac7cee47f0b76f65cfff223253efce7cceab21a9ede5bd5db527faaa16cc855a7b3eeef1386a27c63774c12596a62596bdc0374f7a78f2e5fb8bce1bb69f42e83d4f928c89496ec833ca2f68bafa77ed4121391eefd0db3f4329236a749ccbe87b70c646b89eaab1502eb4de97ab6106884b5c245a8be35ae080fd45f9d68f7030a8aa6b6e1d0c880a11b3cd7c5c4e904113909caccfed1021c4e21a2060b3536791c5e8620221a61d3d99edf7ab930fe89805482b45473653971d894e12928280122ce69b0f20419fc345ff3c797de30f6781fcd8637388e68794f3a44e004414860856189446213d056e9a06c2bbfedd65d06817ddb4047c904501f625cbfbbf654e072fddaa9fb538d577d0a16ea4f28489c08629bdd0b6a2d42fa9d69ba7818cc3e6661214550cb8facc562ac470ff81e04efb75c49787c91f972752e86a05cd3595c92c203fcf92c12235a09b0a059d3af34f64b0cd260de0e809318ccd2910aa7cb5ebf11a0861427330cfc754e37b7e043415d3e519aaa2578660b8664f5361134ff11510d86ccbdc8768c5676df607b5d27a3c7122ce1082afcaace13c898cdc057ac5755b24d48e88b2a04e279de4c80c7c90094ea72be84948e9a6d02316df530c4c758fa6440ce01ab27455d847a7608eab4b746a1ab7b10d840a8fb71880308b63f4274a4fe5e32bc7c5750225312f1f42307d258675273b888965c939c8f9a59ad9726af7546c69ea24b4ffd3fd773419c0b29db5a8a6c63b692e8f043336a7d178069f94de625efed1a0f393907c1f4fb4b058052f7bbb3b26bec0bc9b74066f1f9278d2b42d799b1bf82781ac68c121e4058fbc61ef4e19ca75cc2aa05fd7bcbc4a9a9a1fbd8c37a017a1cb357e19bcb743fa0dfce87543b11050557a263c1c3b5ccb53f6bb30652dbe279da7872256175f565c8508fa19d4d02004a956563f80aa9162c9686e8db76b36565ddbe46bd14ffad00af72afff2affb6b972897881bb42ecf1de0b0deb1bd7f1cad50225c3a83966f35aa60a7d0cafd7524223ae87df43bdc2512052d4703df9727f5be0370cd8b1a84a0349e07e178cb616b7b1e8ab5e376b8678b797aae44d5ef0730e3615b3b7c095e48492560d1f52b9223992259225b7ac3e0038376d196b1fb5d404a57476fe25f57356faaba0146cce4e84150dfd5968bab8c921c655343b34075a3fd9237b3917deb9dfe53d26c604fcbeba19e0b5e66ad0054f121540d4febc754fedddda9e0f2095703228a6409a7df7bb65d2a5af02b3ca6130424fe4e733ac51334d92189bf844aab77983798fa6e90fe5b8b0f9c7b4db41f19691440ef38db10e677e01b476167714322a8a31245cc3666288127a46d03b5cdc8fdef0a089f43a62e09f012cdfdb5c2ed509e3aead2309e385890aafdf362a116c05a1bd8f9daa582b11d27cc11dd7b2625b05c167b5423a8e29706f67ec6bd249a886bc3fc20aa8652e6446a3b2ba6b2049ee91fc209bac33da0c063f41849a36c198d5e63ee0a5d5f3f001a499233195c8f9973fe8ebe2b7a83880fa12d4a634d3945f3dd02dadf6e96a74bf88179d3a2fbdbc9726ef56de1fb60a571f5c313121c55181ae4a79e30884c34e0bade144f33036ee362b1c67a68a95864bd3c0f7b8e9ab82c7bae698b77590388dad944f163595f220006828eaa825b919287e707581f1aa77ed3fb5d42c46bf91633bbb7c23ab3f1908073fdce204e3bcd010478dcc00fd11327bbbabcc1e8b92505d542c172803a1448877b5dbfb830210dbba85405ed2dd6ae9e7f6531354ce976a86d85154e07561cecbd65450ba7cc5eb5d24da8a5691bb8300278dcfee4a47b80e9c205278284416985e4a499398e51005e83aa0a862d2d0b92f0b7279b499ac4f4b35942d4a10e46ca7fee473549cace8b99de3a692f8990361f87ff625fecd77c506859827bc7ecc254c15c972278ea8ed93d7479fa8fa6f423350071ca0c3a7d562db627789c5cd2c0d67376bb438a6dbf1f4843ad2ae8a61ae693bb4533afb9833f65ec1014eda28feef9e0a490b4c83cbcefb1d66a1602e6f6245bba8c4a86b272b6b8f96ad2a3dd11e0fe3046c82673c487e1ecda498bc776048b376bc34a4ddb043b7e7baddbfe9601b450208bcd520de48fd4d5096ecfbe1b3a40fa8979e327e330949366068f0276c5d1e4a80032715ccfab572d8166d9962e75e8d23f327dec054b72741d1c838347e78c538109436cb3a829bf00857d30050d372de423f7cc6d6284d3b8535a7c4744ed675924075dde792445de227820d8ea2522c2ea0491a477e0dfd0bfb28d5930281709c2bc476c1b3df5f5cbc7eaaae9d0d63888f4bfb6522a5d54c2d23a72747e54b70ca1f407570140b5d17eb6438249fba760be78bd6683fdeceda7016d785208712e416617f9fe474628f813b92c4a38058cc32eacf06f30e8e7f3e4e8e5b18dca176e5f96ff9aacaaeccd2c93baa8f7f6996dfa87d8b5e17991ce38ddadf49811d78258b26dca94d91b5ee2bdcd4abf268d0ed893d999ba49029a54a498376e8ed3c68f37fea622e15010268c6c5bbab0f61d29fd2d97587885bbf0b92893c7814074dd04e58ddea2bcb65267b15ee4e349e8df4babe842cb8daae3c614ff186055208d01ee63dfbd50485dacf426e55c331018f50bbc5f446ddf62143cd050a7cf8e5ae4e42d03c4dd7814729796a079b938cad96629b329d38bef9ab8b2ce2cf37f5dff626695abccb7475a9c05ebbc560459c0353804f703bd8c3a714a226206147a5318e9bb3693c1d2de9ac67bbb0ce05c59a4911782d65c49cee9bbcb7772df94802f768bb338f78a08cc2dc105546e9a296522b9c8b0be9f4327972fd1ecb3a4ee17c1715213d67bea10b2f734d951bc5354fbda7c6762668039c2d90d2db26b5503676cad9f7d7b284cb49cfc9f70797fd46443287fff392a44f902f9742552cd44c5102149c10a11ed048e8af6b34c5d921034633f6909a1ec864cb9d759a33575d95bae76ec69b092a0e2e1ea4f40a6dff950fe706723b3dedb7da9875e1567d6f5b1952c6b0ef398d4aa7413edca2d82d6378ee2811f2553b34fe669c26fce26d9290a32b66256e8953324209d33e343d7cd1b8a909d856d21e57ab8a3c77efb5de0cd592886604a763415486aaa4301d032f859be1852df70b34107a7d62366391a21b917d70212cd365f34d733d9df83bdd5f4fb22d5acb8fe3418d8d42f252e99f368680368e868c696c919248b5c2e58746c4e7d95628ee26b696890841a789615c7015c40f912e2a32f4ad685a08c2fd4ff71b03de5ce80366652f78dbf955693d1bca59011583069225e93e7b67d5cebc56251cdd5865e5b0f6ea461ac3efd5fd69c12f770ce7d9d3c2a458d47124c1dc410babd9eed71f6ef811ac771b9a6f1c02a3e9f5db2b76ec834f8e1eefd6253fc699204ea27b931a929341df0f6727249520ccffc75ea47becf1ddf57cf2ee8fdf6e12d2427b8bb91775e83ef3ec7a126b2f14729a2362cea8ce3e4b1171b5b8b61e02086bbd46fe01759dff8ea562f98a7e7c2b6d712e0ffe0108cece1bfd5aa54a37e23c21bc9846b5116820f9a79a9f0195064c44512667e3fc0d83fc6afe876c4e5925dcc5267434d5d4678295699cc94ae530e9fbe33be84930ff78e936e62ecf710fb01d2c9d891c59cf93e9c7fc86c1e7d0301f848bb78a9ed59dc1232526d24191bd996374511c124a816aaae11648aae789d9a5b5af934cb103bdf0661eca9f3493f215f45f962f964793d4bdb1ac88a88b81263eab6bbb9f9b8086517a5af433f3a626eb8be1415d38e50375b6b7d35f38b3babcb34833d127eecde1c8f75f0edfb40ca1490b1d706ac760e53b17fbab92e93bf1832dc869597d92a67c96514ec67786999393a9919a5e8e24bf3c9bba8526393a66dcc5e8262654a7c9c367a1045bcc5ac4e126694f16ed3e1b32a79f6721510b88152ce67abe92bcee89f7167636bc06cc2d6157887a70fbbb829895433c5ac4a6e93a326090a8a0c965cded2fb86e10fa5c1670fe8d8b20a5ed303b17582bb994a983523b64db39cb3f84e8fabef4c4348913b877f6b57649c04f482bb808fa83468a03b2829dd7df84e0e02f4641b7504424bb11592671f56d08decb42eb891d219c523f4f76621a34e55da5537b1ff54c9ea2ee3ee8ec49201aeefef2ab3f6f77422fb57ea92263f8aa1e309a357604e97dfe853fd726ad0aef139dc60d9cb939ac519406e4fbfea566e50ad4fca4c86c82c2c47c3c82c35b7169bcb7ac92bcf292ad961bad163f72dd8b68645e15c020ba1762ffcad71fd57b3eaa1a5c054d27d1532f1805408cf138828bfe94d3000e080db11930696a7755c48d902c6f835d31547deb45aca0d9d7f1aede35e27aaa395ac295417271e1b049d068d0f3d5d764217e1f0370f77ec78d4221848301ff58c630886b791aac07ed40c746ee5c5d459f15b9b3850f935eb4b055a55349dd36320dcddf85824656a3422e65a090fef953581488387d29784e48a184b64707e864788842f62e6480782777c836b643a330be1d1ef745918620be33e37c4fbdb97a52bec968a512e6e212668e30b48e15537534eb5fe821beae900fccbb6133ababb14114f232e57656d30200c252193dcd69220e0cfeedfb1b5fff8bf6e71a4ba758f0fcff75e1d1bb4433f80f6e361719500c0ae2424aed3b49a824e8446303bf0bef2840d18f449d92dc5eb5ef4291eca225e2a08e5dd647af20bcc0b0889af779f8413ca038facfbc8fa4f74b6834c56e2d26afd7d9a2fd1824cabefcc214fc560b582be0d7da4058f7838a6c97a94138b3382eee16cbfb01cc42c76553832eac63e898b55e6b6f7e768cb3cefed032a2a229581ed1253ca31ca7f4c0bb8b5f8ad3fe4238569eb3d52390905ddca8eddbd44f67e623f39881b0605f824b4ad851ebe50d9e5b4d3731c938896658b5eb593cac01ce6694c5dbe79a0dfd26bbf7bfedb12f5d76f21806cf1770954204a02fd90a5beba76d354b9565b8e892c817372d70697f60aebc496c5d8b5b96bda171fff92277848bd3d555a891dc8ae17f7a0d1b44b4a2a17fef55e52044998470293877b09a314bc17156bff2cf417fb0619c0d85f0449eeb15e6aa6cca20b55751cd8e5c37f4c95c0edc2c2a4949442b34771fb7f2bca6d8aec077f9ea1fef41fc36773d251973ea61a6169b867636d49eb74a84137857d123a99f3966cad5256b7a8336aa4075f7193ac569a06d59fb7e8841ec789193314036628c7e8fd2802a8fcb6e26f4ce3c8b3106cfbf11a20cf801bbf26725522f6ff272b4db0d16f0fb29165865846cac52c00d763a31f6e1be2c8f7491fb768aef5651a1180bea54318427891c117f9ec6d7ef91042159e0179e41aff4c9b68d03bb413248536999d2596548194f6b21928c5bf463e2859daeeccf7044b9af4d05e718dd351180f08e3b104fb7af51dd0040b7b81039fa72aee424391c90cc9229a7e351ac04086546898161d0e2fca7b232dc4836387e1eb1cae4f6a658db7bb5cbbe7b348d7346297b8575907db8d64443a8b4c397a29a3e7d9a908f10f89f9e8968da5499010822ebf14f163f4e04c414adaffab8484583fa0acb3a9d816b8eb2d166999b288b24bc1db418191aa34aed98e46023a6fbcef97cff73f02c9b49ffa506d20394cbaf2103954a88ba57b1a01f708f65658c8bc9440ea551b93e4367c02f682c90cf4d052b8e1ed7b7476c4af39e3269c3cb6ef962461c1068fd83723bb68cd9effb24535588b24fe8883182ba4363b3941901b152f7e897e2b85dabc99d2829c51dd7ed2aaa3416d8e5849b8ca2f41038634597376e5219fd305acdc90096a92f8b86763456f1f2913e81ee9a49893423e3784b1728214902c294f739627a96e7d52e4978ee0ced6924f9ecfcce668b1aaf2a061aa9c949b0b5fa8109abf2637de7e28745104e589c248b655b5114e8245ebc0fb63737c10677736e53b5ff0a0860929867a5c08fd3fe4f124d46c280e57df056f264818500eb3afacb099ef765f059c0de9496a0090d933f1dcede5049503581073ef0ab0857d11db964cebb7df5cdda90207cc94c3f0675d5db5fcac71aa697bc901565fef2e649e36e65aca102673f0cecdd961ed9aa72ac2a7bfcae78ad456fd0b54539e12b3126a8ed601397204f7159a538008aacb33eecb428af1296e5f83e32615e0622eea76d8c24cb10adbdc416155815bfe5d34b4124a4fd704da2f9cfec246f30c6cb0483a44e58c42c36bd115367e8870e964aee41b8f050344616dc1627d1a832d6f36bee4f9fe91baad6645096f3e0bcf3922f86250705d18312b8a33b14a06394a573ea18ffd53a80ad48e6f58e47b61ee3e5627a0cd79075b7635ff825df2df07cf1715c9d7a5a245b84e9f05e6e6e9ca094d1aa57d9ce124c696615f512080ea6519d7a7dbdb29f0e925718f423ce35da77168c28ab24ba36b899f6dcbc6ed29cc18fdbc502fc6e5bfffffe1727754ee8af7db69fceb30bc8a4b19a190d2bde94f294c188ef9a5b4c8364ce267465a1fae1abedcd1fe48f17f8825b6370679da76c3f37ac028ea8fba393c3e0ad3af035996f04b4ecf5419c6770d1f89697e43bef9d7f5e3ceadb0c5904a2379b886a62c91d192190200625a9952983280203cf896a788625f9d604de299be20b357dee08b0ee481b619ae2436f5204563d17778723ef80a2d9ed318308ea0d03db66278669a53851645956da823e9db76cbf0230d16b865aee9856b32a8f563a0651d3b3a355c85904512aa93f8a6b2a20289f89668720b34716c35ac334d6cffe50b71329ca730ba95b8c2c5d22d42bdd60d595d25c61bb823cce3172d9dad4b363288877d7c0829443439a8875fd6181727970e2dff7b65b73b1063ac652024e991e285c66c3e4aaa1c011d77c7bd3fc427c40b7b349724f450d47f6590fd7387ce498fcbddfe00d81d2b1406b6ea34a882cda64852830284def234904f171c1bf46be9f45fa116388f37939192220f0b512b660959a00c34578d8ca231131f9a3e0b8e95ff9e855fba76ae6a8268dd1e76d316424f8ce6063ad05f7a199ac19b2ffbf3e5259ff4d7c87101c74d46259964ad64312d68c84bab0bb84e98a79d89800c7beaf6b816eb10606c21f36b22a780fa82a97d0220ac65a58654027f1ec49a90573cd7914a9109b3947e85e8ec525fead79a1a5ffe1abcac6e0fc0d68132d817bed0e7ed26f84cbfdbc9ddf2a4ca89a2c515b2a6339355185b9d62398202f949933486855c8cb5762662600cc9ebdc1b7cd53672b9a8b0f29c004d7b170a77355af9e18fc077891f0247e2e30abb0c9236412516ca44f4c1338aabf14ae37b8d781512823cd19f2deea54b9fe51c1f0072317660e5334e7b0d75fe8b599bfe703bf90e14a6106d7598ced9480ae77787ca426c699aa951e57002754bd396388c9bfeaf822edd34dee832e47b23645519b46e2fff52caa0af8513f996097ca8b243693650c5a1e60015781aed345c766cba83e3cb4cee0833d2189a4c3267898299f96d842fb0b5afaf8cda5f04619a24d8727f26efb3f4a7ff1de2dee6e5c1e44ac88c622f43b21a4ea1da3b639bfa6611b9b1a76d6915c74e8302eac5bf615d3e1833aca91ba786ee4e4b20f32bf21ac6c9f4b75102b8a09f0fa233e15c2822c17cca81149bb8d741ebea8ed700d4e3766f541e353abda1b7a5c35a8f7c4397e9f5b9d78578d09f0c12992e49aec38b1acd140e7caa140c417638fd1030d7db8126fc0f94ba240a42c2c00c40b50d0dec9ba8e6a5a591e183581cdc6433ae155cc74858263db5ae5b9be1a0e4f2926882b42f20e57bf477f9137d18f57f9760d3732fe40e0ef772d65177c8e53afcdffaf551cf61d18755dc7aca41b4f67b31cb86f3ec4fd12adb7b9e083f6419fde61728570b66f83856e34426ce49651e78f0e8eda7401704521ff1a0e9bd593b47f6b85f40ffdd2590fd24d858cb6b23a49f9c03498efc11aa5a2218504edc9d5e994a8cdaa46b6c40ed2995aed535a7263bd2faa1cf695a23eef6af6c728fec6294f9153687430d74c10594054651a6cd8de57a69fb47c436db31ccc6420e5e4e1bef987be4d7d59e53b3dbfdaa87a8124d97e39ba2ce42ddf1817a50b3175da9d95d7c907ff4500bc33d7821bab1d8ee80b206905dd15ac038ce7980fa2f00b8c38927375ff1d36edfd2e499f9ca80c9dd3262f41932e15c3027b6b30a9a124c0c59ab8735ac8d2bc7978c4c2a45367d472f17e058ccb9f1aba2b4b0d679858d61f0d435d0dad44b749ce2f8502a8a82a6f1713fdfb72dbc71c8082da7ad8cdc64d5d0f145bf74e9a1f1f050de29e5fcefe366c219d5847e74a6135fa377e22ddbd0b6222fe54018a6c68e35bffd8eea276fbc56ef78eb891534570bebf7c83dc92cc6721da008828a9d4c1677caa4158976f40e4a6f2aff040bcdf7c38a49f18401de1cd6da1cdb1ae84f30046ea821203d94fe1a66071b6f608e7fce053df22f46ac7956ebbc28951fb380a319922a63883f98d8dc3bd024ccff2b1e310d643db4ce99271f92bb45210383ab74eefa3845980ff07f33b542b763e89ff40dec1a603198f9cfd7566e96873b7181c380c5548d52f4fd11b0a6dbdc65631326a35bcc40379a22e08872c481751733dbae2f98347e9180f8a00240309815e6f7830cd9394725127cc56b9671d106fbe4f341102e041b9aa04b2ba142dde64e7a196e8d4085ae86d0c47170ac5fe5ec424a9181619ffe1ac25712ffb22ae49103eb92c33494cc64f92e2113a7bd5ab66a726e99a0e59dd985599b3964b85a7efef77d19cba8b9af6e4fd026147790f0422d837641247170cf4f7b579f899908287a506e134f888cb77fee8c4e65cf1f4ffeb06e090babfa4eaac69d14cae995cbf797e61c3ebe6b4f38a22ba19dce0ca200bbd2e8f108d85f08775e3cf77f5ba3e59b2e2c5d20485f01ee1bc5ff765a9c0d889f35b7f91a93ca9cec66dd2128ea1ed744c5c9635ccb405f46f3681c4356611fa101d4b0b8dc3c9fd7869467e891d496ea7f2066c06a9c357a4a4d3d891b43e641a73aecc81109049c499cd524582f1c0a5b60c12904ceeb6234bac3b6b8f5053827596695e04930b4469763232823ec2e86583cdb953fe79b77be8edf44d2fd878630d41d4a4e614140b613f072a8c0f9de781ba2dc217475897ed3674a16256c8fd1fec4b8064a13a42a7a076cb7f5ca2ce8312c2d57ee7e8d68e47fe3a49895239c93ea5471ccf1844e9dd7a1d45a0bcc943db6e00395825fadd8f3fcff5617c498b85e2fc85922dd2cbe61b3fb466131aa44417a771e40d77deab3081e4928ba2e10f06f83f9fb52e771dc5aa42b6e348ee6945668ea5bc8d60c4c7c377065c43471e19727ee9952900ae01bd2beb4cb29199bb85b88578751ebdc02e73ee0c8b28975814b6c441d03446654faad040a0eb757868fe078d39f6f23141242a3fa10769cef8f5453637275e6feee7b93632b1647d1db2605cd494c69cce85865eebcc3cd3be78bef63c477d7121cb759a3205d67515a97ce3eceab5630408a6b355571fa607206879491168c2964e5d6bd7b2d8dcce1ba9d4d48ddeeddb0b973e83076fcd1cfae08c8c0f324bcf2a13099a03a40fa460e07b8ea46d62f8f17d1e819a55ba086eebd2d7f59d3d207218ded153966e7f524ef22fbfb4e597bdc10cde7b6788cad10abb659790ee866d6d0c9724572515e5bf6520e6765bdfb782e868da2ede7b6358288e8a3e389a71b2b3dab866f7354389a4c789954487f03220b3da5901ebafa9da2b1813bdb58564d58d07feba62822e12277bd39a469ee2154f7c7c23ac43255ef42b319d58f6d23b7d5655d53946eaf030b220a3ddf52e6ac8d18174a054b332dd66149bce3ea7ea9b2053f4d62d0799284d7668f2034c6eb20ffe8edf1c1a8c29736dc6ef0e26dab806af9b7b3d68f4f9af726bf1cf25212c365ff44b9179a5bf2ae3e5defdd41e33b8aeb25010516ac32ea063303e4d9ff1c997db47a829dfb06018496a21ea3c72dc66d9fe4de8ee2a545341206d06d61a8bc17827145a3b46448f101ef3a819abb2ecb6a28771632208f064e2171b32875b694d8cdb9b2db3462f1ebee0472bf762ad0865e8be1c724c50a4eed68ee122ef9786edda5a14e8f87ab2b05c5d36ce1f29f9f3e53369fe932d7b8505c35365f3129eb826ca9e9d26b452e8988f6a6c03b37694d05bb4ac2ff54fb6f3fd83e7a6fc3c7154b4b7b387b1318dc46913238948fe8be9ee53e7c3d02b9d3c424da32566bdd95990e76c32dfb3694f8cf81f21705cdd556b5e014d0b600dfcc2ff2c08fbb4cb1cbd44696c9564d0d8f2d964240af04177589129de4095af6dae22ba8bb13b6cc758be79b80b274314e68d7c7fdbfef570caa5f6dde81e511764cad09ab01906e71e3db73b2e87d0449c0d3b8e996bba885ca617e22616a5f1ab5af56b8af10cdcd66f3e7d795566c98d808eb0b3cc1703773d911a82da671dd3e821500583addec1727515aaf82df243e781ae6caf32cdc325e521cb045f23ee7aae8cc448d038c979285dbfcaba6ed1953726fdc93b71cd310dfdbd3f54cc857035958b33f91f5b337f2053c8183d12739d1d5aa3500176976d80ca881efb5e8b450d3d52d48f2f413a8715bc548ba7d1b8c46955e5b0e7e2e9e4261a85a0e419be02966a54223b94f03113ee7268fa1f69d26a2bf1a6813fecf0a84a200f2f8d80496152dfd5b8e6558421404e6afbd17bb1789f6f3548303e7dd5ede28d752373cac4c0f5bf8584ce9de9045dbc8e6f907180022b62485278a627c11fcf0a033b997bd8cf990c04953e3e0c31ba939523c58fa60127f0d51274e4808d8ca3744eb672f08688cb0e32a3675dc807aeaf1a7eb983b3f6a52997b7246f833b8dd0936fc29e28ba1448b724d2b4a390e808df61965c1d898af554654c85e35d783f9e8ee9d5f1a1879f87667372d079a150b9e86a8050c5ebeeb6fac7988b3e4209d70c699f092d809c139cd98de5a616d037f9012e5dda3708f1cbdbf41bad43827b51e076207bc15cfa8a74b128d73561950404835d535d4c529b71521d588f31acb79664821be3921c2ffe6ad9072fac184ccb8d438c1776bcad915c6a1b82c06c9ae2e962d2c791ec3a6607e12d33ba08258a777f0dbb691dfb910bf38b19a4a07b585aff40359ba811f00793755e23b17b97997b0f1fdc97a1396489526aeb1eb31024a4e16b7841789e9917a0fb3f8f167ee988128acf876419568dba0841712694c5832bb78ee121099ae3c33b4d2b0b3c01755c4c2aeed3cc858e508ba6c549910f106df432c47cd7b3dc9b12a408c43fa11df6f0be51465ea02cab8a34907657968c5029926d612db4924ede9408fd8d49bc5d091a636cc5d795ea5daf3c78b866efc56e0d4be86c5aeaa270b151064c51c5ffb3e176522ee72280eac9fc11889b20c1f68e11dd72deaa33ff2686ca65424851ed0ae00d1ee28465b8871abc0268ca7785cde68bb0a33230ec32f534d5b0c7cf9bc5c235c871e988fa684f05f260275cfcd1ecbbb9e588c6bdf14710eb8abcea7966b702775210d793c9dc54fd2d0a21260d8d43761a4c40ab7169868e71d27355f467bdf24248aca2ee0104b229f61b527238a1192aa0a9cc77bffae44ab98a38743e38234195190c462fd5678d563df478a989a2fff4019d20eb3a4087df303b2f392defe5cbd4a003ea44d53e8b2582175b902f3c0fb7bd650ed5d9b7691f8e3ec35ba72f48f080ca230b1558b3b15f2f1a75ede998f7836271c9c7ccf1e14f3a59c4fd1bf193c5a4d4e229f11c9e2452806db730e0a1fc6ce52469fe6044e6f0d2fb6435d5b1b8d65c25243ae1aa32ddace5a157061b3cc697e4529c1455c3fc25409e51e6fb1aff284feb824c209224bcd0f05150edf12d125d23b3a615c78f58c88d3f0cf6a61fb6d81d3780f55c04ab29c98dcb1bdf34888360c491a8c89f55b93b95eea32a773a3c954e688f2b8a208cbf02d8ab653b8426646fccea0f4748213b3556f1a4fb538aaa4903d024bb916d6aeab9afde5cf6f0de0d36f8e898caa292b1fd4f415cac69df7b8bdd4ab49fabc92a6b18d841ce40ed731545c695be9a75a255b2982e2026bb841181a293dbcb534b1b822f2c06b5994f15b39c814f9f0475fae8536a24f81d73923ddc0fc78fe61af517299ac486443f6fca9f88df1b9f66fab3f25a1028a669ada28ce3e9732435179b438c9f08bc12669015aa4ed7223675397c7680c365ffaf5bd9643454770831c53c77a2a608193ee366552642c185185d402947d5cbeb2126d9d63df47a5f7d3a904ec9879f7d15a3a9646f78170af73260b4e34c2c90b7c4cfb3287fe6408cf64ccabefac18f9082ea38670a021b0854991f64ad7bcd9a06bf4acbae98553693ac870a5e71c2f4f44100a7cd99ce8b5541739c918b9396e74dd6854d50be32fa2894c63b9065607e6276ca1ebda81b15c5498a77670da0cb230f7915ebefb7430bce131f505f759501818d4c06b1dbab7cd38861f1943e3302600e85f94acd2d5ec36e19fc1184413800b67f66aaada409ac9148059db358e415c638243f0b2eda06f2714efbaf9051cdb8ae9eb0ba642696f4bc5bc0fefd99e4255cf0c15a4e83c9719118c0cb9df8f2f8f0c0751e7ebf53c7e4fc2083fe9c120cd4de78621ca42a3b6947813779a4fa6dbcf9d70929568a646f5bc6c7612237f5b8543dd73e4bfeec8b1be9b1a22f2f32e924fbf98f87dd5882ac69afc6b3853e405738e2fa67efc674c31b29cad3094a5dfd207f37c6287a5bad33d046c9bc2df10b18ed4a1cea69e385a961c6663e0ad13e835db22525e4686ea8b16c8e7c776768594870aac19fce664e1ec0db3850df7216972872c7617396dd7c758698b00d1479a9fdccd4470b44dcbde9623ff98fb8c247e0e1b4dd9424f07e15e9b69c153b1b753c7217738a56a8c9b2f60d11dcef0d28fc8573b0aac42e865ee45459abb31dff9b977a81121faded4867649256cb85444a6c1a98cbc91333b32661e6b625823883711c78e675a635ba14bf899acc6cc1dde0bd40d77b1cf1f6d7faf0b7cfa1157f4d07d93115d64fcb2cbc44043ddb2e33418e44cd1bda0545389358e37cea110fcb3b6aa4fca56150f34dcfba7f20b2f08e8722be1af88c52bfc5200540cee98d29c2f2a562e4a2acf2d5caf758a31b68ca8da4a821f7c9a9fd80b7c1c9139a0f551fa7a6473adfec243d9542823fc45dcd6b59a563b82359d45c9e5231d05a8cd77f5fb67d6742ec36a004a2fdc1ab40acb964ad5faec3d804c58c095d4871d43f9aa0d6f48cec7d81d41e4a758ab6cd32a6cc19396eb189c5ebc940ad3cd4bc1aad4bb87a22770cf70f7af1a0288259cdcb32aea77f2d2bfc3c6552f2d2f2f17d08a5814fcbe6a70ba8367e8ab09192d7676cf30ce1160f7d3658cf876beaab93d25bda1c39e552c98c8741192e6731ae9fcc4d9e3b9d96314ea55a682d4ef55f469aede3c39a875a112841d56361df6b607d82d342fe1e087a3c268c09a55276705517e74420caf8e980df986f740885a8585235bb773ba745f5205177d0dc1acd0b717406873dd17e11d5724f587fb6642decf039ce0feae621dedc95b36aaa0b87138387b103b6207ddab7640c879cbfd725e44ab92c1a4a2b73d53eaca2285fb4cb796b46b7a0490d8bc8b9a6d71676a7d17c796c8ac5e8fb2b938d81133ddfff96172a49ca4f6ffd7ff2b62cb19ef401fa39536eb4b0707b286dbab683ab185b2ecb59e79ee23d4b5816319335e5cd0c9b24770eab7768649fd91f6f83a85532fe58bfc324ad104e4020d3766050dec753b5aaa56a1150db3320ecc141d0eb018ed01938e7e3b4c74205caff305685303b786310bc8d5f61a03c0dc839f711a4d375d974a67a32ccfbe4b5a4e3bfaaa80283ce5ec595c9380fc932ada042ac8ffd6b262926b99d9b9d9dd3c21b9acd79158e8237f4efcbf10b5dbffc56e0b2d4deecbaf27f74431b5b3a1caea829c88114cc353ae77457b58136135d6b2b1c2acba12021c06f3d455425a59e677278547ed3b1c178f5a9d6563d6e2488b5d3dfe547b9e1c9e44abdf414d473e881b3d0024686e4cd6ac60ed8dce256260237497057206c57119194a5ea473e7bc894dfbc3111f0c9a15aa4b08b897aa7a28a61c6234ed8e821e0a5e9d29af447790a9426357cfa919e5390968e011cb6a9cd60b211957231160101c4491d7194c0e2533550be5852b1c95892619a08230dbff863dec8c3a0351e3f830a7d646eb6c1b2a497e8a71569d404256f26b6725cf311c84d7103bf41d968adc6a49ea5b9dbe8d4ad8a72be1e47f4191cbee0b7e12e1a86b24ec0a6de7cb5b462673beb79f657ae1bcaf1360e705032756555fceac364c11fff32f880916ced4f6b7d506385def2ea173b85a960f24666ed4041ea4a3431d751e59a0a4a7c567517db4ce80a194aca5e498e4b170941ae4d1593515fb3cb76d07fc291fb467b73480ec8409066a6d2e46ec50658f3fe7b2e51ef2d3f6fc1f2c1ec92534544e585eceb2daebd288d7bf0d34ceeea5e32d091da0e933ccc3ee57c2595efdd4d78f1cb05172403fdf3186f7587c506892cd12840dff6b12b8894314aca1598ed1b245d234685e4118743e2fd557256c60f29a918a7ba1bee5b578f9a6ff25e94a06d3f4d4e54927cb43c171d4c85cf10a4461245375ca666a1c956c7bc7a4431173e0a5cf74abc259dd75722a3c5eac40fc8e83ff4e5864f4484c9ef65b5a802587d370af329a10956934e937422d422efa3b488e68bd9b908d6887c5b78d953ab39add828e5c22d26340edde2ae9cc12548a201f41ffb0b954a93ac9b03eb1eccc3f2f6dc690f9d984af83b4876773edabd2b115670b1fb5ffdb722301f9b7b447eda87bbff957e71377b143b26c6ba26723faaacd50eeebf1031c59efac156f1db79dc534376d2facf9552a267fe48b147173d6a01965099e0345a1a2fe3a09619ee42083c36d8c72f283ab43ceb07edad5b19377cbe51706583722bcce1914311963e9e016f9efadd39a342a951ee0277abd49e89208a153ab29f2b394ce0ec162085da411b7d8cb50a7e14081815df253e9d1deec874035defa39104efda50b630b0a122e1d6af334841cbd0960466b5536e6d3aa70fb550a4febe6a8d59f040cfd129446954371ca22b5ec2f7543166473ee77726848f3fc9926889cebdbc407b99e55fb3b8c21ec21b347438fb3f0c9291371a071d6ce475f279debf7eb9a63b56bfe7b1e497df574cf984d6bf2968497b744c85a0c65cea478f5861a6315f2ad1ac3d7588bab18479b254215a65ea481a7c8ed6f1f7c60fbef1407d7c6348691f2ad162ab2622e23a6d0838d5fd52382ac43be001d61483616668732a12079f42725c35fe35ef06c3ec1dad5c503cb0545404b89aa38ce4027d94fac3035fa12d518f6e97e9848f4ae808c933daf9baeeaae8983ea34704390bfb7d8630e67bdd3319fe29dd0bfe7a9298031eb67f9c5c3a05b36dc3fcc3c6f0d2b334043e34315d698c2b1bd01871660f79dc4aa373336f27c02496586861e6c0cc81bcabfd24c3f5c1697a8b735f60d81f70810f357e5d2e87af8f990d8440d0c943995d210c1baa75a2fda5ef686f9d8405846dc922ff84c1cd0628e0caee601c3981bd716084d83b78372c34d16a39aa53d44327bec659f61f64c652535c26c3f3aafb376922843b33a78d43651639c0bfc83dfaa289dccd315e62560a3a8da6df080140415768a4741579b56ab676d4e6be82297898b9aaa60a60708d559f4b4f785b2b4cfadd74cc9326bf62b210789aebf80284274c2dbc7c17e06d942d18e7c1eb7994265c6930bfd3c3036dd20112305ba5a37cc7847601300fbc81deb733ed5fe9fb206c204b5d2c13f689c340a3a69b3da6e4fc4b81cee67f4790f88bbf3e82b247bd49711c4c18347e78d891bcb357a562cf614451d0d11f130543451edf4201c18a0501c9c2a7b79e52f5d8e514f8b0adef7d99e5522ad43d8ea24fdef20bd1b6a9c63984b5548d087c5c6e88cb5950eb35268d2277042f411948f5c3c8c6c649486fc56df8b9651ad481dbb124f6d4feb74b07186564583093e584835eeac8e4efbb5b63d380159dd13d4c609653f3d1e163038f1dc58a256c14874db29bf62b8900f920103832b00a9574a205b41601525b2fd223ce90b7d240cd6fda7157099847523ff8e8d0183ff233799b5f88ab214a29e10f72f88d48f36c80ff6deb1fd6a9eb467918201dad51584aeec714c07f06da96282257877f95169327e3c494076729fc4ff17d217457ea6a1a8f4542270c4f7f8aa5d0843e52b3bc9650c565ba179da08d257626cd6019b2ebb0e96da008bc64cb93210ef920114eb430034cdbe5559c3a21b989b8e9eee38a1e593320b784d92546180f75a7d04bc06f2c0e3e3d12303145f23fe60bf9de4598fdca3ed52486b27917f4abda236fd36d7ded39a3a6c1f448b63a49c6519c2049abcb331111c83139d39d932862069074eff9b5985e72b4b5a682fc6fb442d4e7730808fcb49a821431e96a8f5b59937e76537c80a3b30dbe5096739f4f8ee74d02f412198a6fdeb32ee7ba5b414a73e464ac9078a65625c085d62246176ff56a69d1c966fb3a2c32a04203d805c018a11071153f27c6ab8098e44576aa057f0cc436f378b066c4fefdb5259d99809f543c4f7920deef5e40d3037fa46d1b268d8adcfa2c6c4fabd3abf03856c7529193a274ce06cd2607aaedd5a2a920418d1c18a53083c6db725601ab1adbed97f5a232752d4088555bba6368bddbdd19337b5de065aeefbe17ce28dfd140dadfb4bf55661943dc59da0ae52fc235909c031dfaa55999287bfe1f4612b5e382fb64fc786e5a59f850940b16933f4044b393d6be5db38e5158027f6876537be13d03a3322a069e177b5a5e95125002b3d9f6646506746943d2db66c81d8d49fd6ea198528451f7710f33020ae1c3cf50cd2ac3a3d452b48a530e645885b35beb2394d408a0ae3cdd5f422622a3bf19ca3480c09d710454255b6b3c2bcaa7e6712799a99c07dad701cf3828382f3c1d7f321d2a17c48068f89250d0b4ec756745e024f27e31723eb8ea485f8da701fa2ea010c5dc4c75fc049abb7a0d08693392ea33e789f58759e75bffc82f777aa366b1cc4e53234d64e63e81bc44c7db909b7aecda9e96ab17a29d564e9f65c9151330be778f82f1307ef5c617021dffcdec96558cd3c45c31ddbc16b3c468dc9fd3f8c00d15ac69d4b6c66949d2170586aa7484be0c457b2f8897f47d041b5eb7bbd6c89e05fc93f53e13817142d2e8e21f091ec4688f6ca23629404494475dc913ddd3e599b5c27e8a6eb1e19efe1c2bfc4e3d9ce72d48802dc4296c47e0192b3bc9fa74f0ebe081f7803e56d8682a3abea4bb38c1a4b0a00f6126bac2d4d1357973634bee6845c666facaa0221cfc1857792416582378b5ef24445b5b842eabc77334335703f09cfc23b309d93c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
